<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0078104e80e2e588a14008aabb2db2f6517661b0.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=2 sw=2 et tw=78:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Steve Clark &lt;buster@netscape.com&gt;
 *   HÃ¥kan Waara &lt;hwaara@chello.se&gt;
 *   Dan Rosen &lt;dr@netscape.com&gt;
 *   Daniel Glazman &lt;glazman@netscape.com&gt;
 *   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK *****
 *
 * This Original Code has been modified by IBM Corporation.
 * Modifications made by IBM described herein are
 * Copyright (c) International Business Machines
 * Corporation, 2000
 *
 * Modifications to Mozilla code or documentation
 * identified per MPL Section 3.3
 *
 * Date         Modified by     Description of modification
 * 05/03/2000   IBM Corp.       Observer events for reflow states
 */</comment> 

<comment type="block">/* a presentation of a document, part 2 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PL_ARENA_CONST_ALIGN_MASK</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMXULDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStubDocumentObserver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICSSStyleSheet.h"</cpp:file></cpp:include> <comment type="line">// XXX for UA sheet loading hack, can this go away please?</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMCSSStyleSheet.h"</cpp:file></cpp:include>  <comment type="line">// for Pref-related rule management (bugs 22963,20760,31816)</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsINameSpaceManager.h"</cpp:file></cpp:include>  <comment type="line">// for Pref-related rule management (bugs 22963,20760,31816)</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIViewManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCRT.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCRTGlue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prinrval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsVoidArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIViewObserver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContainerFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsEventStateManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDOMEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLParts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionController.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionPrivate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMRange.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOM3Node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNodeList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRange.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSPseudoElements.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsUnicharUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWeakReference.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPageSequenceFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICaret.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXPointer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMXMLDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableView.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIParser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsParserCIID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameSelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNSHTMLInputElement.h"</cpp:file></cpp:include> <comment type="line">//optimization for ::DoXXX commands</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNSHTMLTextAreaElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsViewsCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPCOM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupportsPrimitives.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILayoutHistoryState.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollPositionListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICompositeListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILineIterator.h"</cpp:file></cpp:include> <comment type="line">// for ScrollContentIntoView</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTimer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWeakPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pldhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObserverService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObserver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShell.h"</cpp:file></cpp:include>        <comment type="line">// for reflow observation</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIBaseWindow.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutErrors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRendering.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFrameDebug.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="line">// for |#ifdef DEBUG| code</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSpaceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prenv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAttribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIGlobalHistory2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDisplayList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRegion.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF_DSP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRenderingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFontMetrics.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIReflowCallback.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPIDOMWindow.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFocusController.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPluginInstance.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObjectFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObjectLoadingContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNetUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsEventDispatcher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleSheetService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxImageSurface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxContext.h"</cpp:file></cpp:include>

<comment type="line">// Drag &amp; Drop, Clipboard</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWidgetsCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClipboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClipboardHelper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShellTreeItem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIURI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlong.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDragService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCopySupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLAnchorElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLAreaElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLLinkElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITimer.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibilityService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibleEvent.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// For style data reconstruction</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleChangeList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSFrameConstructor.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMenuFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITreeBoxObject.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMenuParent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPlaceholderFrame.h"</cpp:file></cpp:include>

<comment type="line">// Content viewer interfaces</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContentViewer.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentCID.h"</cpp:file></cpp:include>
<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kCSSStyleSheetCID</name></expr></argument>, <argument><expr><name>NS_CSS_STYLESHEET_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>NS_DEFINE_IID</name><argument_list>(<argument><expr><name>kRangeCID</name></expr></argument>,     <argument><expr><name>NS_RANGE_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsIPresShell</name>::<name>gIsAccessibilityActive</name></name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<comment type="line">// convert a color value to a string, in the CSS format #RRGGBB</comment>
<comment type="line">// *  - initially created for bugs 31816, 20760, 22963</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColorToString</name><parameter_list>(<param><decl><type><name>nscolor</name></type> <name>aColor</name></decl></param>, <param><decl><type><name>nsAutoString</name> &amp;</type><name>aString</name></decl></param>)</parameter_list>;</function_decl>

<comment type="line">// Class ID's</comment>
<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kFrameSelectionCID</name></expr></argument>, <argument><expr><name>NS_FRAMESELECTION_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">// RangePaintInfo is used to paint ranges to offscreen buffers</comment>
<struct>struct <name>RangePaintInfo</name> <block>{<public type="default">
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>mRange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayListBuilder</name></type> <name>mBuilder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>mList</name></decl>;</decl_stmt>

  <comment type="line">// offset of builder's reference frame to the root frame</comment>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>mRootOffset</name></decl>;</decl_stmt>

  <constructor><name>RangePaintInfo</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
    <member_list>: <call><name>mRange</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call>, <call><name>mBuilder</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
  </member_list><block>{
  }</block></constructor>

  <destructor><name>~<name>RangePaintInfo</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name><name>mList</name>.<name>DeleteAll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>
</public>}</block>;</struct>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NOISY</name></cpp:undef>

<comment type="line">// ----------------------------------------------------------------------</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<comment type="line">// Set the environment variable GECKO_VERIFY_REFLOW_FLAGS to one or</comment>
<comment type="line">// more of the following flags (comma separated) for handy debug</comment>
<comment type="line">// output.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRUint32</name></type> <name>gVerifyReflowFlags</name></decl>;</decl_stmt>

<struct>struct <name>VerifyReflowFlags</name> <block>{<public type="default">
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type>    <name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>bit</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VerifyReflowFlags</name></type> <name><name>gFlags</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr>"verify"</expr>,                <expr><name>VERIFY_REFLOW_ON</name></expr> }</block></expr>,
  <expr><block>{ <expr>"reflow"</expr>,                <expr><name>VERIFY_REFLOW_NOISY</name></expr> }</block></expr>,
  <expr><block>{ <expr>"all"</expr>,                   <expr><name>VERIFY_REFLOW_ALL</name></expr> }</block></expr>,
  <expr><block>{ <expr>"list-commands"</expr>,         <expr><name>VERIFY_REFLOW_DUMP_COMMANDS</name></expr> }</block></expr>,
  <expr><block>{ <expr>"noisy-commands"</expr>,        <expr><name>VERIFY_REFLOW_NOISY_RC</name></expr> }</block></expr>,
  <expr><block>{ <expr>"really-noisy-commands"</expr>, <expr><name>VERIFY_REFLOW_REALLY_NOISY_RC</name></expr> }</block></expr>,
  <expr><block>{ <expr>"space-manager"</expr>,         <expr><name>VERIFY_REFLOW_INCLUDE_SPACE_MANAGER</name></expr> }</block></expr>,
  <expr><block>{ <expr>"resize"</expr>,                <expr><name>VERIFY_REFLOW_DURING_RESIZE_REFLOW</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_VERIFY_REFLOW_FLAGS</name></cpp:macro> <cpp:value>(sizeof(gFlags) / sizeof(gFlags[0]))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowVerifyReflowFlags</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Here are the available GECKO_VERIFY_REFLOW_FLAGS:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>VerifyReflowFlags</name>*</type> <name>flag</name> <init>= <expr><name>gFlags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>VerifyReflowFlags</name>*</type> <name>limit</name> <init>= <expr><name>gFlags</name> + <name>NUM_VERIFY_REFLOW_FLAGS</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>flag</name> &lt; <name>limit</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  %s\n"</expr></argument>, <argument><expr><name><name>flag</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>++<name>flag</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Note: GECKO_VERIFY_REFLOW_FLAGS is a comma separated list of flag\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"names (no whitespace)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//========================================================================</comment>
<comment type="line">//========================================================================</comment>
<comment type="line">//========================================================================</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
<class_decl>class <name>ReflowCountMgr</name>;</class_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>kGrandTotalsStr</name><index>[]</index></name> <init>= <expr>"Grand Totals"</expr></init></decl>;</decl_stmt>

<comment type="line">// Counting Class</comment>
<class>class <name>ReflowCounter</name> <block>{<private type="default">
</private><public>public:
  <constructor_decl><name>ReflowCounter</name><parameter_list>(<param><decl><type><name>ReflowCountMgr</name> *</type> <name>aMgr</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</constructor_decl>
  <destructor_decl><name>~<name>ReflowCounter</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function_decl><type><name>void</name></type> <name>ClearTotals</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayTotals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayDiffTotals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayHTMLTotals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>void</name></type> <name>Add</name><parameter_list>()</parameter_list>                <block>{ <expr_stmt><expr><name>mTotal</name>++</expr>;</expr_stmt>         }</block></function>
  <function><type><name>void</name></type> <name>Add</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mTotal</name> += <name>aTotal</name></expr>;</expr_stmt> }</block></function>

  <function_decl><type><name>void</name></type> <name>CalcDiffInTotals</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>SetTotalsCache</name><parameter_list>()</parameter_list>;</function_decl>

  <function><type><name>void</name></type> <name>SetMgr</name><parameter_list>(<param><decl><type><name>ReflowCountMgr</name> *</type> <name>aMgr</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mMgr</name> = <name>aMgr</name></expr>;</expr_stmt> }</block></function>

  <function><type><name>PRUint32</name></type> <name>GetTotal</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mTotal</name></expr>;</return> }</block></function>
  
</public><protected>protected:
  <function_decl><type><name>void</name></type> <name>DisplayTotals</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aTitle</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayHTMLTotals</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aTitle</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mTotal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCacheTotal</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>ReflowCountMgr</name> *</type> <name>mMgr</name></decl>;</decl_stmt> <comment type="line">// weak reference (don't delete)</comment>
</protected>}</block>;</class>

<comment type="line">// Counting Class</comment>
<class>class <name>IndiReflowCounter</name> <block>{<private type="default">
</private><public>public:
  <constructor><name>IndiReflowCounter</name><parameter_list>(<param><decl><type><name>ReflowCountMgr</name> *</type> <name>aMgr</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>
    <member_list>: <call><name>mFrame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
      <call><name>mCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>mMgr</name><argument_list>(<argument><expr><name>aMgr</name></expr></argument>)</argument_list></call>,
      <call><name>mCounter</name><argument_list>(<argument><expr><name>aMgr</name></expr></argument>)</argument_list></call>,
      <call><name>mHasBeenOutput</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>IndiReflowCounter</name></name><parameter_list>()</parameter_list> <block>{}</block></destructor>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>mName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type>   <name>mFrame</name></decl>;</decl_stmt>   <comment type="line">// weak reference (don't delete)</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>      <name>mCount</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>ReflowCountMgr</name> *</type> <name>mMgr</name></decl>;</decl_stmt> <comment type="line">// weak reference (don't delete)</comment>

  <decl_stmt><decl><type><name>ReflowCounter</name></type> <name>mCounter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>        <name>mHasBeenOutput</name></decl>;</decl_stmt>

</public>}</block>;</class>

<comment type="line">//--------------------</comment>
<comment type="line">// Manager Class</comment>
<comment type="line">//--------------------</comment>
<class>class <name>ReflowCountMgr</name> <block>{<private type="default">
</private><public>public:
  <constructor_decl><name>ReflowCountMgr</name><parameter_list>()</parameter_list>;</constructor_decl>
  <destructor_decl><specifier>virtual</specifier> <name>~<name>ReflowCountMgr</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function_decl><type><name>void</name></type> <name>ClearTotals</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>ClearGrandTotals</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayTotals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayHTMLTotals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayDiffsInTotals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>Add</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>ReflowCounter</name> *</type> <name>LookUp</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>PaintCount</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>, <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aColor</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>FILE</name> *</type> <name>GetOutFile</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mFD</name></expr>;</return> }</block></function>

  <function><type><name>PLHashTable</name> *</type> <name>GetIndiFrameHT</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIndiFrameCounts</name></expr>;</return> }</block></function>

  <function><type><name>void</name></type> <name>SetPresContext</name><parameter_list>(<param><decl><type><name>nsPresContext</name> *</type> <name>aPresContext</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mPresContext</name> = <name>aPresContext</name></expr>;</expr_stmt> }</block></function> <comment type="line">// weak reference</comment>
  <function><type><name>void</name></type> <name>SetPresShell</name><parameter_list>(<param><decl><type><name>nsIPresShell</name>*</type> <name>aPresShell</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mPresShell</name>= <name>aPresShell</name></expr>;</expr_stmt> }</block></function> <comment type="line">// weak reference</comment>

  <function><type><name>void</name></type> <name>SetDumpFrameCounts</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aVal</name></decl></param>)</parameter_list>         <block>{ <expr_stmt><expr><name>mDumpFrameCounts</name> = <name>aVal</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>void</name></type> <name>SetDumpFrameByFrameCounts</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aVal</name></decl></param>)</parameter_list>  <block>{ <expr_stmt><expr><name>mDumpFrameByFrameCounts</name> = <name>aVal</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>void</name></type> <name>SetPaintFrameCounts</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aVal</name></decl></param>)</parameter_list>        <block>{ <expr_stmt><expr><name>mPaintFrameByFrameCounts</name> = <name>aVal</name></expr>;</expr_stmt> }</block></function>

</public><protected>protected:
  <function_decl><type><name>void</name></type> <name>DisplayTotals</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type> <name>aDupArray</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>aTitle</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DisplayHTMLTotals</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type> <name>aDupArray</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>aTitle</name></decl></param>)</parameter_list>;</function_decl>

  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>RemoveItems</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>
  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>RemoveIndiItems</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>
  <function_decl><type><name>void</name></type> <name>CleanUp</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// stdout Output Methods</comment>
  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>DoSingleTotal</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>
  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>DoSingleIndi</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>

  <function_decl><type><name>void</name></type> <name>DoGrandTotals</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>DoIndiTotalsTree</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// HTML Output Methods</comment>
  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>DoSingleHTMLTotal</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>
  <function_decl><type><name>void</name></type> <name>DoGrandHTMLTotals</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Zero Out the Totals</comment>
  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>DoClearTotals</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>

  <comment type="line">// Displays the Diff Totals</comment>
  <macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRIntn</argument>)</argument_list></macro> <constructor_decl><name>DoDisplayDiffTotals</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</constructor_decl>

  <decl_stmt><decl><type><name>PLHashTable</name> *</type> <name>mCounts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLHashTable</name> *</type> <name>mIndiFrameCounts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type> <name>mFD</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>PRBool</name></type> <name>mDumpFrameCounts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>mDumpFrameByFrameCounts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>mPaintFrameByFrameCounts</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>mCycledOnce</name></decl>;</decl_stmt>

  <comment type="line">// Root Frame for Individual Tracking</comment>
  <decl_stmt><decl><type><name>nsPresContext</name> *</type> <name>mPresContext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIPresShell</name>*</type>    <name>mPresShell</name></decl>;</decl_stmt>

  <comment type="line">// ReflowCountMgr gReflowCountMgr;</comment>
</protected>}</block>;</class>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="line">//========================================================================</comment>

<comment type="line">// comment out to hide caret</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHOW_CARET</name></cpp:macro></cpp:define>

<comment type="line">// The upper bound on the amount of time to spend reflowing, in</comment>
<comment type="line">// microseconds.  When this bound is exceeded and reflow commands are</comment>
<comment type="line">// still queued up, a reflow event is posted.  The idea is for reflow</comment>
<comment type="line">// to not hog the processor beyond the time specifed in</comment>
<comment type="line">// gMaxRCProcessingTime.  This data member is initialized from the</comment>
<comment type="line">// layout.reflow.timeslice pref.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_MAX_REFLOW_TIME</name></cpp:macro>    <cpp:value>1000000</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRInt32</name></type> <name>gMaxRCProcessingTime</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

<comment type="line">// Largest chunk size we recycle</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>gMaxRecycledSize</name> <init>= <expr>400</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_INCREMENT</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCK_INCREMENT</name></cpp:macro> <cpp:value>4044</cpp:value></cpp:define> <comment type="block">/* a bit under 4096, for malloc overhead */</comment>

<comment type="block" format="doxygen">/**A block of memory that the stack will 
 * chop up and hand out
 */</comment>
<struct>struct <name>StackBlock</name> <block>{<public type="default">
   
   <comment type="line">// a block of memory.  Note that this must be first so that it will</comment>
   <comment type="line">// be aligned.</comment>
   <decl_stmt><decl><type><name>char</name></type> <name><name>mBlock</name><index>[<expr><name>BLOCK_INCREMENT</name></expr>]</index></name></decl>;</decl_stmt>

   <comment type="line">// another block of memory that would only be created</comment>
   <comment type="line">// if our stack overflowed. Yes we have the ability</comment>
   <comment type="line">// to grow on a stack overflow</comment>
   <decl_stmt><decl><type><name>StackBlock</name>*</type> <name>mNext</name></decl>;</decl_stmt>

   <constructor><name>StackBlock</name><parameter_list>()</parameter_list> <member_list>: <call><name>mNext</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> </member_list><block>{ }</block></constructor>
   <destructor><name>~<name>StackBlock</name></name><parameter_list>()</parameter_list> <block>{ }</block></destructor>
</public>}</block>;</struct>

<comment type="block">/* we hold an array of marks. A push pushes a mark on the stack
 * a pop pops it off.
 */</comment>
<struct>struct <name>StackMark</name> <block>{<public type="default">
   <comment type="line">// the block of memory we are currently handing out chunks of</comment>
   <decl_stmt><decl><type><name>StackBlock</name>*</type> <name>mBlock</name></decl>;</decl_stmt>
   
   <comment type="line">// our current position in the memory</comment>
   <decl_stmt><decl><type><name>size_t</name></type> <name>mPos</name></decl>;</decl_stmt>
</public>}</block>;</struct>


<comment type="block">/* A stack arena allows a stack based interface to a block of memory.
 * It should be used when you need to allocate some temporary memory that
 * you will immediately return.
 */</comment>
<class>class <name>StackArena</name> <block>{<private type="default">
</private><public>public:
  <constructor_decl><name>StackArena</name><parameter_list>()</parameter_list>;</constructor_decl>
  <destructor_decl><name>~<name>StackArena</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function><type><name>nsresult</name></type> <name>Init</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mBlocks</name> ? <name>NS_OK</name> : <name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return> }</block></function>

  <comment type="line">// Memory management functions</comment>
  <function_decl><type><name>void</name>*</type> <name>Allocate</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>Push</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>Pop</name><parameter_list>()</parameter_list>;</function_decl>

</public><private>private:
  <comment type="line">// our current position in memory</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>mPos</name></decl>;</decl_stmt>

  <comment type="line">// a list of memory block. Usually there is only one</comment>
  <comment type="line">// but if we overrun our stack size we can get more memory.</comment>
  <decl_stmt><decl><type><name>StackBlock</name>*</type> <name>mBlocks</name></decl>;</decl_stmt>

  <comment type="line">// the current block of memory we are passing our chucks of</comment>
  <decl_stmt><decl><type><name>StackBlock</name>*</type> <name>mCurBlock</name></decl>;</decl_stmt>

  <comment type="line">// our stack of mark where push has been called</comment>
  <decl_stmt><decl><type><name>StackMark</name>*</type> <name>mMarks</name></decl>;</decl_stmt>

  <comment type="line">// the current top of the mark list</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mStackTop</name></decl>;</decl_stmt>

  <comment type="line">// the size of the mark array</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mMarkLength</name></decl>;</decl_stmt>
</private>}</block>;</class>



<constructor><name><name>StackArena</name>::<name>StackArena</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mMarkLength</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mMarks</name> = <name>nsnull</name></expr>;</expr_stmt>

  <comment type="line">// allocate our stack memory</comment>
  <expr_stmt><expr><name>mBlocks</name> = new <call><name>StackBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCurBlock</name> = <name>mBlocks</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>mStackTop</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mPos</name> = 0</expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>StackArena</name>::~<name>StackArena</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// free up our data</comment>
  <expr_stmt><expr>delete<index>[]</index> <name>mMarks</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><name>mBlocks</name></expr>)</condition>
  <block>{
    <decl_stmt><decl><type><name>StackBlock</name>*</type> <name>toDelete</name> <init>= <expr><name>mBlocks</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mBlocks</name> = <name><name>mBlocks</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>delete <name>toDelete</name></expr>;</expr_stmt>
  }</block></while>
}</block></destructor> 

<function><type><name>void</name></type>
<name><name>StackArena</name>::<name>Push</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// Resize the mark array if we overrun it.  Failure to allocate the</comment>
  <comment type="line">// mark array is not fatal; we just won't free to that mark.  This</comment>
  <comment type="line">// allows callers not to worry about error checking.</comment>
  <if>if <condition>(<expr><name>mStackTop</name> &gt;= <name>mMarkLength</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>newLength</name> <init>= <expr><name>mStackTop</name> + <name>MARK_INCREMENT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StackMark</name>*</type> <name>newMarks</name> <init>= <expr>new <name><name>StackMark</name><index>[<expr><name>newLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>newMarks</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>mMarkLength</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newMarks</name></expr></argument>, <argument><expr><name>mMarks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StackMark</name></expr></argument>)</argument_list></sizeof>*<name>mMarkLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <comment type="line">// Fill in any marks that we couldn't allocate during a prior call</comment>
      <comment type="line">// to Push().</comment>
      <for>for (<init>;</init> <condition><expr><name>mMarkLength</name> &lt; <name>mStackTop</name></expr>;</condition> <incr><expr>++<name>mMarkLength</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"should only hit this on out-of-memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newMarks</name><index>[<expr><name>mMarkLength</name></expr>]</index></name>.<name>mBlock</name> = <name>mCurBlock</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newMarks</name><index>[<expr><name>mMarkLength</name></expr>]</index></name>.<name>mPos</name> = <name>mPos</name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr>delete <index>[]</index> <name>mMarks</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mMarks</name> = <name>newMarks</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mMarkLength</name> = <name>newLength</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// set a mark at the top (if we can)</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mStackTop</name> &lt; <name>mMarkLength</name></expr></argument>, <argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mStackTop</name> &lt; <name>mMarkLength</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>mMarks</name><index>[<expr><name>mStackTop</name></expr>]</index></name>.<name>mBlock</name> = <name>mCurBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mMarks</name><index>[<expr><name>mStackTop</name></expr>]</index></name>.<name>mPos</name> = <name>mPos</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>mStackTop</name>++</expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name>*</type>
<name><name>StackArena</name>::<name>Allocate</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mStackTop</name> &gt; 0</expr></argument>, <argument><expr>"Allocate called without Push"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// make sure we are aligned. Beard said 8 was safer then 4. </comment>
  <comment type="line">// Round size to multiple of 8</comment>
  <expr_stmt><expr><name>aSize</name> = <call><name>PR_ROUNDUP</name><argument_list>(<argument><expr><name>aSize</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// if the size makes the stack overflow. Grab another block for the stack</comment>
  <if>if <condition>(<expr><name>mPos</name> + <name>aSize</name> &gt;= <name>BLOCK_INCREMENT</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aSize</name> &lt;= <name>BLOCK_INCREMENT</name></expr></argument>,<argument><expr>"Requested memory is greater that our block size!!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>mCurBlock</name>-&gt;<name>mNext</name></name> == <name>nsnull</name></expr>)</condition><then>
      <expr_stmt><expr><name><name>mCurBlock</name>-&gt;<name>mNext</name></name> = new <call><name>StackBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>mCurBlock</name> =  <name><name>mCurBlock</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mPos</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// return the chunk they need.</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>result</name> <init>= <expr><name><name>mCurBlock</name>-&gt;<name>mBlock</name></name> + <name>mPos</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mPos</name> += <name>aSize</name></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>StackArena</name>::<name>Pop</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// pop off the mark</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mStackTop</name> &gt; 0</expr></argument>, <argument><expr>"unmatched pop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStackTop</name>--</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mStackTop</name> &gt;= <name>mMarkLength</name></expr>)</condition><then> <block>{
    <comment type="line">// We couldn't allocate the marks array at the time of the push, so</comment>
    <comment type="line">// we don't know where we're freeing to.</comment>
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mStackTop</name> == 0</expr>)</condition><then> <block>{
      <comment type="line">// But we do know if we've completely pushed the stack.</comment>
      <expr_stmt><expr><name>mCurBlock</name> = <name>mBlocks</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mPos</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <comment type="line">// Mark the "freed" memory with 0xdd to help with debugging of memory</comment>
  <comment type="line">// allocation problems.</comment>
  <block>{
    <decl_stmt><decl><type><name>StackBlock</name> *</type><name>block</name> <init>= <expr><name><name>mMarks</name><index>[<expr><name>mStackTop</name></expr>]</index></name>.<name>mBlock</name></expr></init>, *<name>block_end</name> <init>= <expr><name>mCurBlock</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><name><name>mMarks</name><index>[<expr><name>mStackTop</name></expr>]</index></name>.<name>mPos</name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init> <condition><expr><name>block</name> != <name>block_end</name></expr>;</condition> <incr><expr><name>block</name> = <name><name>block</name>-&gt;<name>mNext</name></name></expr>, <expr><name>pos</name> = 0</expr></incr>) <block>{
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>mBlock</name></name> + <name>pos</name></expr></argument>, <argument><expr>0xdd</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>block</name>-&gt;<name>mBlock</name></name></expr></argument>)</argument_list></sizeof> - <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>mBlock</name></name> + <name>pos</name></expr></argument>, <argument><expr>0xdd</expr></argument>, <argument><expr><name>mPos</name> - <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>mCurBlock</name> = <name><name>mMarks</name><index>[<expr><name>mStackTop</name></expr>]</index></name>.<name>mBlock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mPos</name>      = <name><name>mMarks</name><index>[<expr><name>mStackTop</name></expr>]</index></name>.<name>mPos</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Uncomment this to disable the frame arena.</comment>
<comment type="line">//#define DEBUG_TRACEMALLOC_FRAMEARENA 1</comment>

<comment type="line">// Memory is allocated 4-byte aligned. We have recyclers for chunks up to</comment>
<comment type="line">// 200 bytes</comment>
<class>class <name>FrameArena</name> <block>{<private type="default">
</private><public>public:
  <constructor_decl><name>FrameArena</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aArenaSize</name> <init>= <expr>4096</expr></init></decl></param>)</parameter_list>;</constructor_decl>
  <destructor_decl><name>~<name>FrameArena</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <comment type="line">// Memory management functions</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void*</argument>)</argument_list></macro> <constructor_decl><name>AllocateFrame</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>;</constructor_decl>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro>  <constructor_decl><name>FreeFrame</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPtr</name></decl></param>)</parameter_list>;</constructor_decl>

</public><private>private:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <comment type="line">// Number of frames in the pool</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFrameCount</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRACEMALLOC_FRAMEARENA</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// Underlying arena pool</comment>
  <decl_stmt><decl><type><name>PLArenaPool</name></type> <name>mPool</name></decl>;</decl_stmt>

  <comment type="line">// The recycler array is sparse with the indices being multiples of 4,</comment>
  <comment type="line">// i.e., 0, 4, 8, 12, 16, 20, ...</comment>
  <decl_stmt><decl><type><name>void</name>*</type>       <name><name>mRecyclers</name><index>[<expr><name>gMaxRecycledSize</name> &gt;&gt; 2</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</private>}</block>;</class>

<constructor><name><name>FrameArena</name>::<name>FrameArena</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aArenaSize</name></decl></param>)</parameter_list>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <member_list>: <call><name>mFrameCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</member_list><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRACEMALLOC_FRAMEARENA</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// Initialize the arena pool</comment>
  <expr_stmt><expr><call><name>PL_INIT_ARENA_POOL</name><argument_list>(<argument><expr>&amp;<name>mPool</name></expr></argument>, <argument><expr>"FrameArena"</expr></argument>, <argument><expr><name>aArenaSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Zero out the recyclers array</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mRecyclers</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mRecyclers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></constructor>

<destructor><name><name>FrameArena</name>::~<name>FrameArena</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mFrameCount</name> == 0</expr></argument>, <argument><expr>"Some frame destructors were not called"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRACEMALLOC_FRAMEARENA</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// Free the arena in the pool and finish using it</comment>
  <expr_stmt><expr><call><name>PL_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name>mPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></destructor> 

<function><type><name>void</name>*</type>
<name><name>FrameArena</name>::<name>AllocateFrame</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name>*</type> <name>result</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRACEMALLOC_FRAMEARENA</name></expr></argument>)</argument_list></call></expr></cpp:if>

  <expr_stmt><expr><name>result</name> = <call><name>PR_Malloc</name><argument_list>(<argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <comment type="line">// Ensure we have correct alignment for pointers.  Important for Tru64</comment>
  <expr_stmt><expr><name>aSize</name> = <call><name>PR_ROUNDUP</name><argument_list>(<argument><expr><name>aSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Check recyclers first</comment>
  <if>if <condition>(<expr><name>aSize</name> &lt; <name>gMaxRecycledSize</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>   <name>index</name> <init>= <expr><name>aSize</name> &gt;&gt; 2</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> = <name><name>mRecyclers</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
      <comment type="line">// Need to move to the next object</comment>
      <decl_stmt><decl><type><name>void</name>*</type> <name>next</name> <init>= <expr>*((<name>void</name>**)<name>result</name>)</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>mRecyclers</name><index>[<expr><name>index</name></expr>]</index></name> = <name>next</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
    <comment type="line">// Allocate a new chunk from the arena</comment>
    <expr_stmt><expr><call><name>PL_ARENA_ALLOCATE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>mPool</name></expr></argument>, <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>result</name> != <name>nsnull</name></expr>)</condition><then>
    <expr_stmt><expr>++<name>mFrameCount</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>FrameArena</name>::<name>FreeFrame</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPtr</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr>--<name>mFrameCount</name></expr>;</expr_stmt>

  <comment type="line">// Mark the memory with 0xdd in DEBUG builds so that there will be</comment>
  <comment type="line">// problems if someone tries to access memory that they've freed.</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aPtr</name></expr></argument>, <argument><expr>0xdd</expr></argument>, <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRACEMALLOC_FRAMEARENA</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>PR_Free</name><argument_list>(<argument><expr><name>aPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="line">// Ensure we have correct alignment for pointers.  Important for Tru64</comment>
  <expr_stmt><expr><name>aSize</name> = <call><name>PR_ROUNDUP</name><argument_list>(<argument><expr><name>aSize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// See if it's a size that we recycle</comment>
  <if>if <condition>(<expr><name>aSize</name> &lt; <name>gMaxRecycledSize</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>   <name>index</name> <init>= <expr><name>aSize</name> &gt;&gt; 2</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>*</type>       <name>currentTop</name> <init>= <expr><name><name>mRecyclers</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>mRecyclers</name><index>[<expr><name>index</name></expr>]</index></name> = <name>aPtr</name></expr>;</expr_stmt>
    <expr_stmt><expr>*((<name>void</name>**)<name>aPtr</name>) = <name>currentTop</name></expr>;</expr_stmt>
  }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_dbaron</name></cpp:ifdef>
  <else>else <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr>"WARNING: FrameArena::FreeFrame leaking chunk of %d bytes.\n"</expr></argument>,
            <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<struct>struct <name>nsCallbackEventRequest</name>
<block>{<public type="default">
  <decl_stmt><decl><type><name>nsIReflowCallback</name>*</type> <name>callback</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>next</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="line">// ----------------------------------------------------------------------------</comment>
<class_decl>class <name>nsPresShellEventCB</name>;</class_decl>

<class>class <name>PresShell</name> <super>: <specifier>public</specifier> <name>nsIPresShell</name>, <specifier>public</specifier> <name>nsIViewObserver</name>,
                  <specifier>public</specifier> <name>nsStubDocumentObserver</name>,
                  <specifier>public</specifier> <name>nsISelectionController</name>, <specifier>public</specifier> <name>nsIObserver</name>,
                  <specifier>public</specifier> <name>nsSupportsWeakReference</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor_decl><name>PresShell</name><parameter_list>()</parameter_list>;</constructor_decl>

  <function_decl><type><name>NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW</name>

  <comment type="line">// nsISupports</comment>
  <name>NS_DECL_ISUPPORTS</name>

  <comment type="line">// nsIPresShell</comment>
  <name>NS_IMETHOD</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                  <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                  <param><decl><type><name>nsIViewManager</name>*</type> <name>aViewManager</name></decl></param>,
                  <param><decl><type><name>nsStyleSet</name>*</type> <name>aStyleSet</name></decl></param>,
                  <param><decl><type><name>nsCompatibility</name></type> <name>aCompatMode</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>Destroy</name><parameter_list>()</parameter_list>;</function_decl>

  <expr_stmt><expr>virtual <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void*</argument>)</argument_list></macro> <macro><name>AllocateFrame</name><argument_list>(<argument>size_t aSize</argument>)</argument_list></macro></expr>;</expr_stmt>
  <expr_stmt><expr>virtual <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro>  <macro><name>FreeFrame</name><argument_list>(<argument>size_t aSize</argument>, <argument>void* aFreeChunk</argument>)</argument_list></macro></expr>;</expr_stmt>

  <comment type="line">// Dynamic stack memory allocation</comment>
  <expr_stmt><expr>virtual <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <call><name>PushStackMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>virtual <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <call><name>PopStackMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>virtual <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void*</argument>)</argument_list></macro> <macro><name>AllocateStackMemory</name><argument_list>(<argument>size_t aSize</argument>)</argument_list></macro></expr>;</expr_stmt>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetPreferenceStyleRules</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForceReflow</name></decl></param>)</parameter_list>;</function_decl>
  
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetSelection</name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>, <param><decl><type><name>nsISelection</name>**</type> <name>aSelection</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>nsISelection</name>*</type> <name>GetCurrentSelection</name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetDisplaySelection</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>aToggle</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetDisplaySelection</name><parameter_list>(<param><decl><type><name>PRInt16</name> *</type><name>aToggle</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ScrollSelectionIntoView</name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>, <param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>RepaintSelection</name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>BeginObservingDocument</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>EndObservingDocument</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetDidInitialReflow</name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aDidInitialReflow</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>InitialReflow</name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aHeight</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ResizeReflow</name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aHeight</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>StyleChangeReflow</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetPageSequenceFrame</name><parameter_list>(<param><decl><type><name>nsIPageSequenceFrame</name>**</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>;</function_decl>
  <expr_stmt><expr>virtual <macro><name>NS_HIDDEN_</name><argument_list>(<argument>nsIFrame*</argument>)</argument_list></macro> <macro><name>GetPrimaryFrameFor</name><argument_list>(<argument>nsIContent* aContent</argument>)</argument_list></macro> const</expr>;</expr_stmt>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetLayoutObjectFor</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type>   <name>aContent</name></decl></param>,
                                <param><decl><type><name>nsISupports</name>**</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetPlaceholderFrameFor</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>  <name>aFrame</name></decl></param>,
                                    <param><decl><type><name>nsIFrame</name>**</type> <name>aPlaceholderFrame</name></decl></param>)</parameter_list> <specifier>const</specifier>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>FrameNeedsReflow</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>IntrinsicDirty</name></type> <name>aIntrinsicDirty</name></decl></param>,
                              <param><decl><type><name>nsFrameState</name></type> <name>aBitToAdd</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CancelAllPendingReflows</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>IsSafeToFlush</name><parameter_list>(<param><decl><type><name>PRBool</name>&amp;</type> <name>aIsSafeToFlush</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>FlushPendingNotifications</name><parameter_list>(<param><decl><type><name>mozFlushType</name></type> <name>aType</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block" format="doxygen">/**
   * Recreates the frames for a node
   */</comment>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>RecreateFramesFor</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block" format="doxygen">/**
   * Post a callback that should be handled after reflow has finished.
   */</comment>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>PostReflowCallback</name><parameter_list>(<param><decl><type><name>nsIReflowCallback</name>*</type> <name>aCallback</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CancelReflowCallback</name><parameter_list>(<param><decl><type><name>nsIReflowCallback</name>*</type> <name>aCallback</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>ClearFrameRefs</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CreateRenderingContext</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                                    <param><decl><type><name>nsIRenderingContext</name>**</type> <name>aContext</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GoToAnchor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aAnchorName</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aScroll</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>ScrollContentIntoView</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                   <param><decl><type><name>PRIntn</name></type>      <name>aVPercent</name></decl></param>,
                                   <param><decl><type><name>PRIntn</name></type>      <name>aHPercent</name></decl></param>)</parameter_list> <specifier>const</specifier>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetIgnoreFrameDestruction</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIgnore</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>NotifyDestroyingFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  
  <function_decl><type><name>NS_IMETHOD</name></type> <name>DoCopy</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetSelectionForCopy</name><parameter_list>(<param><decl><type><name>nsISelection</name>**</type> <name>outSelection</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetLinkLocation</name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aNode</name></decl></param>, <param><decl><type><name>nsAString</name>&amp;</type> <name>aLocationString</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>DoGetContents</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name>&amp;</type> <name>aMimeType</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aSelectionOnly</name></decl></param>, <param><decl><type><name>nsAString</name>&amp;</type> <name>outValue</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>CaptureHistoryState</name><parameter_list>(<param><decl><type><name>nsILayoutHistoryState</name>**</type> <name>aLayoutHistoryState</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aLeavingPage</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>IsPaintingSuppressed</name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aResult</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>UnsuppressPainting</name><parameter_list>()</parameter_list>;</function_decl>
  
  <function_decl><type><name>NS_IMETHOD</name></type> <name>DisableThemeSupport</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>PRBool</name></type> <name>IsThemeSupportEnabled</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name>nsresult</name></type> <name>GetAgentStyleSheets</name><parameter_list>(<param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aSheets</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>nsresult</name></type> <name>SetAgentStyleSheets</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aSheets</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name>nsresult</name></type> <name>AddOverrideStyleSheet</name><parameter_list>(<param><decl><type><name>nsIStyleSheet</name> *</type><name>aSheet</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>nsresult</name></type> <name>RemoveOverrideStyleSheet</name><parameter_list>(<param><decl><type><name>nsIStyleSheet</name> *</type><name>aSheet</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>HandleEventWithTarget</name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                   <param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                   <param><decl><type><name>nsEventStatus</name>*</type> <name>aStatus</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetEventTargetFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>**</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetEventTargetContent</name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>nsIContent</name>**</type> <name>aContent</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>IsReflowLocked</name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aIsLocked</name></decl></param>)</parameter_list>;</function_decl>  

  <function_decl><type><specifier>virtual</specifier> <name>nsresult</name></type> <name>ReconstructFrames</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Freeze</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Thaw</name><parameter_list>()</parameter_list>;</function_decl>
  
  <function_decl><type><name>NS_IMETHOD</name></type> <name>RenderOffscreen</name><parameter_list>(<param><decl><type><name>nsRect</name></type> <name>aRect</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aUntrusted</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aIgnoreViewportScrolling</name></decl></param>,
                             <param><decl><type><name>nscolor</name></type> <name>aBackgroundColor</name></decl></param>,
                             <param><decl><type><name>nsIRenderingContext</name>**</type> <name>aRenderedContext</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>RenderNode</name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aNode</name></decl></param>,
                                                   <param><decl><type><name>nsIRegion</name>*</type> <name>aRegion</name></decl></param>,
                                                   <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                                                   <param><decl><type><name>nsRect</name>*</type> <name>aScreenRect</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>RenderSelection</name><parameter_list>(<param><decl><type><name>nsISelection</name>*</type> <name>aSelection</name></decl></param>,
                                                        <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                                                        <param><decl><type><name>nsRect</name>*</type> <name>aScreenRect</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>HidePopups</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">//nsIViewObserver interface</comment>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>nsIView</name> *</type><name>aView</name></decl></param>,
                   <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aDirtyRegion</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ComputeRepaintRegionForCopy</name><parameter_list>(<param><decl><type><name>nsIView</name>*</type>      <name>aRootView</name></decl></param>,
                                         <param><decl><type><name>nsIView</name>*</type>      <name>aMovingView</name></decl></param>,
                                         <param><decl><type><name>nsPoint</name></type>       <name>aDelta</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aCopyRect</name></decl></param>,
                                         <param><decl><type><name>nsRegion</name>*</type>     <name>aRepaintRegion</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>HandleEvent</name><parameter_list>(<param><decl><type><name>nsIView</name>*</type>        <name>aView</name></decl></param>,
                         <param><decl><type><name>nsGUIEvent</name>*</type>     <name>aEvent</name></decl></param>,
                         <param><decl><type><name>nsEventStatus</name>*</type>  <name>aEventStatus</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>HandleDOMEventWithTarget</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aTargetContent</name></decl></param>,
                                      <param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>,
                                      <param><decl><type><name>nsEventStatus</name>*</type> <name>aStatus</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ResizeReflow</name><parameter_list>(<param><decl><type><name>nsIView</name> *</type><name>aView</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aHeight</name></decl></param>)</parameter_list>;</function_decl>
  <macro><name>NS_IMETHOD_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro> <constructor_decl><name>IsVisible</name><parameter_list>()</parameter_list>;</constructor_decl>
  <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>WillPaint</name><parameter_list>()</parameter_list>;</constructor_decl>

  <comment type="line">// caret handling</comment>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetCaret</name><parameter_list>(<param><decl><type><name>nsICaret</name> **</type><name>aOutCaret</name></decl></param>)</parameter_list>;</function_decl>
  <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>MaybeInvalidateCaretPosition</name><parameter_list>()</parameter_list>;</constructor_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetCaretEnabled</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInEnable</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetCaretReadOnly</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aReadOnly</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetCaretEnabled</name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aOutEnabled</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetCaretVisibilityDuringSelection</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aVisibility</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsICaret</name></expr></argument>&gt;</argument_list></name></type> <name>SetCaret</name><parameter_list>(<param><decl><type><name>nsICaret</name> *</type><name>aNewCaret</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetSelectionFlags</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>aInEnable</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>GetSelectionFlags</name><parameter_list>(<param><decl><type><name>PRInt16</name> *</type><name>aOutEnable</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// nsISelectionController</comment>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>CharacterMove</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>WordMove</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>WordExtendForDelete</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>LineMove</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>IntraLineMove</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>PageMove</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ScrollPage</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ScrollLine</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>ScrollHorizontal</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aLeft</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CompleteScroll</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CompleteMove</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>SelectAll</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CheckVisibility</name><parameter_list>(<param><decl><type><name>nsIDOMNode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>startOffset</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>EndOffset</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>_retval</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// nsIDocumentObserver</comment>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>BeginUpdate</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsUpdateType</name></type> <name>aUpdateType</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>EndUpdate</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsUpdateType</name></type> <name>aUpdateType</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>BeginLoad</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>EndLoad</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>CharacterDataChanged</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                    <param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                    <param><decl><type><name>CharacterDataChangeInfo</name>*</type> <name>aInfo</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>ContentStatesChanged</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                    <param><decl><type><name>nsIContent</name>*</type> <name>aContent1</name></decl></param>,
                                    <param><decl><type><name>nsIContent</name>*</type> <name>aContent2</name></decl></param>,
                                    <param><decl><type><name>PRInt32</name></type> <name>aStateMask</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>AttributeChanged</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aNameSpaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aAttribute</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aModType</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>ContentAppended</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                               <param><decl><type><name>PRInt32</name></type> <name>aNewIndexInContainer</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>ContentInserted</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                               <param><decl><type><name>nsIContent</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndexInContainer</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>ContentRemoved</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                              <param><decl><type><name>nsIContent</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndexInContainer</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>StyleSheetAdded</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                               <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                               <param><decl><type><name>PRBool</name></type> <name>aDocumentSheet</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>StyleSheetRemoved</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                 <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>aDocumentSheet</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>StyleSheetApplicableStateChanged</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                                <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                                                <param><decl><type><name>PRBool</name></type> <name>aApplicable</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>StyleRuleChanged</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                                <param><decl><type><name>nsIStyleRule</name>*</type> <name>aOldStyleRule</name></decl></param>,
                                <param><decl><type><name>nsIStyleRule</name>*</type> <name>aNewStyleRule</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>StyleRuleAdded</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                              <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                              <param><decl><type><name>nsIStyleRule</name>*</type> <name>aStyleRule</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>StyleRuleRemoved</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                                <param><decl><type><name>nsIStyleRule</name>*</type> <name>aStyleRule</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_DECL_NSIOBSERVER</name>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
  <name>NS_IMETHOD</name></type> <name>DumpReflows</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>CountReflows</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>PaintCount</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>, <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aColor</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_IMETHOD</name></type> <name>SetPaintFrameCount</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aOn</name></decl></param>)</parameter_list>;</function_decl>
  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>ListStyleContexts</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aRootFrame</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>,
                                 <param><decl><type><name>PRInt32</name></type> <name>aIndent</name> <init>= <expr>0</expr></init></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>ListStyleSheets</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndent</name> <init>= <expr>0</expr></init></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>VerifyStyleTree</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRLogModuleInfo</name>*</type> <name>gLog</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</public><protected>protected:
  <destructor_decl><specifier>virtual</specifier> <name>~<name>PresShell</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function_decl><type><name>void</name></type> <name>HandlePostedReflowCallbacks</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>UnsuppressAndInvalidate</name><parameter_list>()</parameter_list>;</function_decl>

  <function><type><name>void</name></type>     <name>WillCauseReflow</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr>++<name>mChangeNestCount</name></expr>;</expr_stmt> }</block></function>
  <function_decl><type><name>nsresult</name></type> <name>DidCauseReflow</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type>     <name>WillDoReflow</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type>     <name>DidDoReflow</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>ProcessReflowCommands</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInterruptible</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type>     <name>ClearReflowEventStatus</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type>     <name>PostReflowEvent</name><parameter_list>()</parameter_list>;</function_decl>
  
  <function_decl><type><name>void</name></type> <name>DoReflow</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <function_decl><type><name>void</name></type> <name>DoVerifyReflow</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>VerifyHasDirtyRootAncestor</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <class_decl><specifier>friend</specifier> class <name>nsPresShellEventCB</name>;</class_decl>

  <class_decl>class <name>ReflowEvent</name>;</class_decl>
  <class_decl><specifier>friend</specifier> class <name>ReflowEvent</name>;</class_decl>

  <class>class <name>ReflowEvent</name> <super>: <specifier>public</specifier> <name>nsRunnable</name></super> <block>{<private type="default">
  </private><public>public:
    <macro><name>NS_DECL_NSIRUNNABLE</name></macro>
    <constructor><name>ReflowEvent</name><parameter_list>(<param><decl><type><name>PresShell</name> *</type><name>aPresShell</name></decl></param>)</parameter_list> <member_list>: <call><name>mPresShell</name><argument_list>(<argument><expr><name>aPresShell</name></expr></argument>)</argument_list></call> </member_list><block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aPresShell</name></expr></argument>, <argument><expr>"Null parameters!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>
    <function><type><name>void</name></type> <name>Revoke</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mPresShell</name> = <name>nsnull</name></expr>;</expr_stmt> }</block></function>
  </public><private>private:  
    <decl_stmt><decl><type><name>PresShell</name> *</type><name>mPresShell</name></decl>;</decl_stmt>
  </private>}</block>;</class>

  <comment type="line">// Utility to find which view to scroll.</comment>
  <function_decl><type><name>nsIScrollableView</name>*</type> <name>GetViewToScroll</name><parameter_list>(<param><decl><type><name><name>nsLayoutUtils</name>::<name>Direction</name></name></type> <name>aDirection</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>mCaretEnabled</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <function_decl><type><name>nsresult</name></type> <name>CloneStyleSet</name><parameter_list>(<param><decl><type><name>nsStyleSet</name>*</type> <name>aSet</name></decl></param>, <param><decl><type><name>nsStyleSet</name>**</type> <name>aResult</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>VerifyIncrementalReflow</name><parameter_list>()</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>mInVerifyReflow</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> <name>ShowEventTargetDebug</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block" format="doxygen">/**
    * methods that manage rules that are used to implement the associated preferences
    *  - initially created for bugs 31816, 20760, 22963
    */</comment>
  <function_decl><type><name>nsresult</name></type> <name>ClearPreferenceStyleRules</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>CreatePreferenceStyleSheet</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>SetPrefLinkRules</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>SetPrefFocusRules</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>SetPrefNoScriptRule</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>SetPrefNoFramesRule</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// methods for painting a range to an offscreen buffer</comment>

  <comment type="line">// given a display list, clip the items within the list to</comment>
  <comment type="line">// the range</comment>
  <function_decl><type><name>nsRect</name></type> <name>ClipListToRange</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                         <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>,
                         <param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>,
                         <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// create a RangePaintInfo for the range aRange containing the</comment>
  <comment type="line">// display list needed to paint the range to a surface</comment>
  <function_decl><type><name>RangePaintInfo</name>*</type> <name>CreateRangePaintInfo</name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>,
                                       <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>,
                                       <param><decl><type><name>nsRect</name>&amp;</type> <name>aSurfaceRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Paint the items to a new surface and return it.
   *
   * aSelection - selection being painted, if any
   * aRegion - clip region, if any
   * aArea - area that the surface occupies, relative to the root frame
   * aPoint - reference point, typically the mouse position
   * aScreenRect - [out] set to the area of the screen the painted area should
   *               be displayed at
   */</comment>
  <function_decl><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>PaintRangePaintInfo</name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>RangePaintInfo</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>*</type> <name>aItems</name></decl></param>,
                      <param><decl><type><name>nsISelection</name>*</type> <name>aSelection</name></decl></param>,
                      <param><decl><type><name>nsIRegion</name>*</type> <name>aRegion</name></decl></param>,
                      <param><decl><type><name>nsRect</name></type> <name>aArea</name></decl></param>,
                      <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                      <param><decl><type><name>nsRect</name>*</type> <name>aScreenRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block" format="doxygen">/**
   * Methods to handle changes to user and UA sheet lists that we get
   * notified about.
   */</comment>
  <function_decl><type><name>void</name></type> <name>AddUserSheet</name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>AddAgentSheet</name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>RemoveSheet</name><parameter_list>(<param><decl><type><name><name>nsStyleSet</name>::<name>sheetType</name></name></type> <name>aType</name></decl></param>, <param><decl><type><name>nsISupports</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Hide a view if it is a popup</comment>
  <function_decl><type><name>void</name></type> <name>HideViewIfPopup</name><parameter_list>(<param><decl><type><name>nsIView</name>*</type> <name>aView</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Utility method to restore the root scrollframe state</comment>
  <function_decl><type><name>void</name></type> <name>RestoreRootScrollPosition</name><parameter_list>()</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>nsICSSStyleSheet</name>*</type>         <name>mPrefStyleSheet</name></decl>;</decl_stmt> <comment type="line">// mStyleSet owns it but we maintain a ref, may be null</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>PRUint32</name></type>                  <name>mUpdateCount</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="line">// reflow roots that need to be reflowed, as both a queue and a hashtable</comment>
  <decl_stmt><decl><type><name>nsVoidArray</name></type> <name>mDirtyRoots</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mDocumentLoading</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mIsReflowing</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mIgnoreFrameDestruction</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mHaveShutDown</name></decl>;</decl_stmt>

  <comment type="line">// This is used to protect ourselves from triggering reflow while in the</comment>
  <comment type="line">// middle of frame construction and the like... it really shouldn't be</comment>
  <comment type="line">// needed, one hopes, but it is for now.</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type>  <name>mChangeNestCount</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>nsIFrame</name>*</type>   <name>mCurrentEventFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>mCurrentEventContent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsVoidArray</name></type> <name>mCurrentEventFrameStack</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>mCurrentEventContentStack</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICaret</name></expr></argument>&gt;</argument_list></name></type>            <name>mCaret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt16</name></type>                       <name>mSelectionFlags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FrameArena</name></type>                    <name>mFrameArena</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StackArena</name></type>                    <name>mStackArena</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDragService</name></expr></argument>&gt;</argument_list></name></type>      <name>mDragService</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name><name>nsRevocableEventPtr</name><argument_list>&lt;<argument><expr><name>ReflowEvent</name></expr></argument>&gt;</argument_list></name></type> <name>mReflowEvent</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>mFirstCallbackEventRequest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>mLastCallbackEventRequest</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRPackedBool</name></type>      <name>mIsThemeSupportDisabled</name></decl>;</decl_stmt>  <comment type="line">// Whether or not form controls should use nsITheme in this shell.</comment>

  <decl_stmt><decl><type><name>PRPackedBool</name></type>      <name>mIsDocumentGone</name></decl>;</decl_stmt>      <comment type="line">// We've been disconnected from the document.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>      <name>mPaintingSuppressed</name></decl>;</decl_stmt>  <comment type="line">// For all documents we initially lock down painting.</comment>
                                          <comment type="line">// We will refuse to paint the document until either</comment>
                                          <comment type="line">// (a) our timer fires or (b) all frames are constructed.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>      <name>mShouldUnsuppressPainting</name></decl>;</decl_stmt>  <comment type="line">// Indicates that it is safe to unlock painting once all pending</comment>
                                                <comment type="line">// reflows have been processed.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsITimer</name></expr></argument>&gt;</argument_list></name></type> <name>mPaintSuppressionTimer</name></decl>;</decl_stmt> <comment type="line">// This timer controls painting suppression.  Until it fires</comment>
                                             <comment type="line">// or all frames are constructed, we won't paint anything but</comment>
                                             <comment type="line">// our &lt;body&gt; background and scrollbars.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAINTLOCK_EVENT_DELAY</name></cpp:macro> <cpp:value>250</cpp:value></cpp:define> <comment type="line">// 250ms.  This is actually</comment>
                                  <comment type="line">// pref-controlled, but we use this</comment>
                                  <comment type="line">// value if we fail to get the pref</comment>
                                  <comment type="line">// for any reason.</comment>

  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sPaintSuppressionCallback</name><parameter_list>(<param><decl><type><name>nsITimer</name>*</type> <name>aTimer</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPresShell</name></decl></param>)</parameter_list>;</function_decl> <comment type="line">// A callback for the timer.</comment>

  <macro><name>MOZ_TIMER_DECLARE</name><argument_list>(<argument>mReflowWatch</argument>)</argument_list></macro>  <comment type="line">// Used for measuring time spent in reflow</comment>
  <macro><name>MOZ_TIMER_DECLARE</name><argument_list>(<argument>mFrameCreationWatch</argument>)</argument_list></macro>  <comment type="line">// Used for measuring time spent in frame creation </comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
  <decl_stmt><decl><type><name>ReflowCountMgr</name> *</type> <name>mReflowCountMgr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function_decl><type><name>nsresult</name></type> <name>CompleteMoveInner</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>sScrollIntoView</name></decl></param>)</parameter_list>;</function_decl>
  
</protected><private>private:

  <function_decl><type><name>PRBool</name></type> <name>InZombieDocument</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>RetargetEventToParent</name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>*</type> <name>aEvent</name></decl></param>,
                                 <param><decl><type><name>nsEventStatus</name>*</type>  <name>aEventStatus</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">//helper funcs for event handling</comment>
</private><protected>protected:
  <comment type="line">//protected because nsPresShellEventCB needs this.</comment>
  <function_decl><type><name>nsIFrame</name>*</type> <name>GetCurrentEventFrame</name><parameter_list>()</parameter_list>;</function_decl>
</protected><private>private:
  <function_decl><type><name>void</name></type> <name>PushCurrentEventInfo</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>PopCurrentEventInfo</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>HandleEventInternal</name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>nsIView</name>*</type> <name>aView</name></decl></param>,
                               <param><decl><type><name>nsEventStatus</name> *</type><name>aStatus</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>HandlePositionedEvent</name><parameter_list>(<param><decl><type><name>nsIView</name>*</type>       <name>aView</name></decl></param>,
                                 <param><decl><type><name>nsIFrame</name>*</type>      <name>aTargetFrame</name></decl></param>,
                                 <param><decl><type><name>nsGUIEvent</name>*</type>    <name>aEvent</name></decl></param>,
                                 <param><decl><type><name>nsEventStatus</name>*</type> <name>aEventStatus</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">//help funcs for resize events</comment>
  <function_decl><type><name>void</name></type> <name>CreateResizeEventTimer</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>KillResizeEventTimer</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>FireResizeEvent</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sResizeEventCallback</name><parameter_list>(<param><decl><type><name>nsITimer</name>*</type> <name>aTimer</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPresShell</name></decl></param>)</parameter_list> ;</function_decl>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsITimer</name></expr></argument>&gt;</argument_list></name></type> <name>mResizeEventTimer</name></decl>;</decl_stmt>

  <typedef>typedef <function_decl><type><name>void</name></type> (*<name>nsPluginEnumCallback</name>)<parameter_list>(<param><decl><type><name>PresShell</name>*</type></decl></param>, <param><decl><type><name>nsIContent</name>*</type></decl></param>)</parameter_list>;</function_decl></typedef>
  <function_decl><type><name>void</name></type> <name>EnumeratePlugins</name><parameter_list>(<param><decl><type><name>nsIDOMDocument</name> *</type><name>aDocument</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>aPluginTag</name></decl></param>,
                        <param><decl><type><name>nsPluginEnumCallback</name></type> <name>aCallback</name></decl></param>)</parameter_list>;</function_decl>
</private>}</block>;</class>

<class>class <name>nsPresShellEventCB</name> <super>: <specifier>public</specifier> <name>nsDispatchingCallback</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>nsPresShellEventCB</name><parameter_list>(<param><decl><type><name>PresShell</name>*</type> <name>aPresShell</name></decl></param>)</parameter_list> <member_list>: <call><name>mPresShell</name><argument_list>(<argument><expr><name>aPresShell</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>HandleEvent</name><parameter_list>(<param><decl><type><name>nsEventChainPostVisitor</name>&amp;</type> <name>aVisitor</name></decl></param>)</parameter_list>
  <block>{
    <if>if <condition>(<expr><name><name>aVisitor</name>.<name>mPresContext</name></name> &amp;&amp; <name><name>aVisitor</name>.<name>mEvent</name>-&gt;<name>eventStructType</name></name> != <name>NS_EVENT</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>mPresShell</name>-&gt;<name>GetCurrentEventFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>frame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>HandleEvent</name></name><argument_list>(<argument><expr><name><name>aVisitor</name>.<name>mPresContext</name></name></expr></argument>,
                           <argument><expr>(<name>nsGUIEvent</name>*) <name><name>aVisitor</name>.<name>mEvent</name></name></expr></argument>,
                           <argument><expr>&amp;<name><name>aVisitor</name>.<name>mEventStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></function>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>PresShell</name></expr></argument>&gt;</argument_list></name></type> <name>mPresShell</name></decl>;</decl_stmt>
</public>}</block>;</class>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
<decl_stmt><decl><type><name>PRLogModuleInfo</name>*</type> <name><name>PresShell</name>::<name>gLog</name></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>VerifyStyleTree</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, <param><decl><type><name>nsFrameManager</name>*</type> <name>aFrameManager</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>nsIFrameDebug</name>::<name>GetVerifyStyleTreeEnable</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name><name>aFrameManager</name>-&gt;<name>GetRootFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aFrameManager</name>-&gt;<name>DebugVerifyStyleTree</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERIFY_STYLE_TREE</name></cpp:macro> <cpp:value>::VerifyStyleTree(mPresContext, FrameManager())</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERIFY_STYLE_TREE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>gVerifyReflowEnabled</name></decl>;</decl_stmt>

<function><type><name>PRBool</name></type>
<name><name>nsIPresShell</name>::<name>GetVerifyReflowEnable</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>firstTime</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>firstTime</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>firstTime</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>flags</name> <init>= <expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"GECKO_VERIFY_REFLOW_FLAGS"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>flags</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>error</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

      <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <decl_stmt><decl><type><name>char</name>*</type> <name>comma</name> <init>= <expr><call><name>PL_strchr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>comma</name></expr>)</condition><then>
          <expr_stmt><expr>*<name>comma</name> = '\0'</expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>PRBool</name></type> <name>found</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>VerifyReflowFlags</name>*</type> <name>flag</name> <init>= <expr><name>gFlags</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>VerifyReflowFlags</name>*</type> <name>limit</name> <init>= <expr><name>gFlags</name> + <name>NUM_VERIFY_REFLOW_FLAGS</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>flag</name> &lt; <name>limit</name></expr>)</condition> <block>{
          <if>if <condition>(<expr><call><name>PL_strcasecmp</name><argument_list>(<argument><expr><name><name>flag</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>gVerifyReflowFlags</name> |= <name><name>flag</name>-&gt;<name>bit</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
          <expr_stmt><expr>++<name>flag</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr>! <name>found</name></expr>)</condition><then>
          <expr_stmt><expr><name>error</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr>! <name>comma</name></expr>)</condition><then>
          <break>break;</break></then></if>

        <expr_stmt><expr>*<name>comma</name> = ','</expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> = <name>comma</name> + 1</expr>;</expr_stmt>
      }</block></for>

      <if>if <condition>(<expr><name>error</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>ShowVerifyReflowFlags</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>VERIFY_REFLOW_ON</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>gVerifyReflowEnabled</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Note: verifyreflow is %sabled"</expr></argument>,
           <argument><expr><name>gVerifyReflowEnabled</name> ? "en" : "dis"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (noisy)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (all)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_DUMP_COMMANDS</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (show reflow commands)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (noisy reflow commands)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>VERIFY_REFLOW_REALLY_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (REALLY noisy reflow commands)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>gVerifyReflowEnabled</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIPresShell</name>::<name>SetVerifyReflowEnable</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aEnabled</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>gVerifyReflowEnabled</name> = <name>aEnabled</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsIPresShell</name>::<name>GetVerifyReflowFlags</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <return>return <expr><name>gVerifyReflowFlags</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr>0</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIPresShell</name>::<name>AddWeakFrame</name></name><parameter_list>(<param><decl><type><name>nsWeakFrame</name>*</type> <name>aWeakFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>aWeakFrame</name>-&gt;<name>GetFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aWeakFrame</name>-&gt;<name>GetFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AddStateBits</name><argument_list>(<argument><expr><name>NS_FRAME_EXTERNAL_REFERENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aWeakFrame</name>-&gt;<name>SetPreviousWeakFrame</name></name><argument_list>(<argument><expr><name>mWeakFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mWeakFrames</name> = <name>aWeakFrame</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIPresShell</name>::<name>RemoveWeakFrame</name></name><parameter_list>(<param><decl><type><name>nsWeakFrame</name>*</type> <name>aWeakFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWeakFrames</name> == <name>aWeakFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mWeakFrames</name> = <call><name><name>aWeakFrame</name>-&gt;<name>GetPreviousWeakFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsWeakFrame</name>*</type> <name>nextWeak</name> <init>= <expr><name>mWeakFrames</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>nextWeak</name> &amp;&amp; <call><name><name>nextWeak</name>-&gt;<name>GetPreviousWeakFrame</name></name><argument_list>()</argument_list></call> != <name>aWeakFrame</name></expr>)</condition> <block>{
    <expr_stmt><expr><name>nextWeak</name> = <call><name><name>nextWeak</name>-&gt;<name>GetPreviousWeakFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <if>if <condition>(<expr><name>nextWeak</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nextWeak</name>-&gt;<name>SetPreviousWeakFrame</name></name><argument_list>(<argument><expr><call><name><name>aWeakFrame</name>-&gt;<name>GetPreviousWeakFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name>NS_NewPresShell</name><parameter_list>(<param><decl><type><name>nsIPresShell</name>**</type> <name>aInstancePtrResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aInstancePtrResult</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>nsnull</name> == <name>aInstancePtrResult</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>PresShell</name>*</type> <name>it</name> <init>= <expr>new <call><name>PresShell</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>nsnull</name> == <name>it</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><call><name><name>it</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIPresShell</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr>(<name>void</name> **) <name>aInstancePtrResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<constructor><name><name>PresShell</name>::<name>PresShell</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mSelection</name> = <name>nsnull</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
  <expr_stmt><expr><name>mReflowCountMgr</name> = new <call><name>ReflowCountMgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>SetPresContext</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>SetPresShell</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
  <if>if <condition>(<expr>! <name>gLog</name></expr>)</condition><then>
    <expr_stmt><expr><name>gLog</name> = <call><name>PR_NewLogModule</name><argument_list>(<argument><expr>"PresShell"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mSelectionFlags</name> = <name><name>nsISelectionDisplay</name>::<name>DISPLAY_TEXT</name></name> | <name><name>nsISelectionDisplay</name>::<name>DISPLAY_IMAGES</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsThemeSupportDisabled</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <expr_stmt><expr>new (<name>this</name>) <call><name>nsFrameManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<macro><name>NS_IMPL_ISUPPORTS8</name><argument_list>(<argument>PresShell</argument>, <argument>nsIPresShell</argument>, <argument>nsIDocumentObserver</argument>,
                   <argument>nsIViewObserver</argument>, <argument>nsISelectionController</argument>,
                   <argument>nsISelectionDisplay</argument>, <argument>nsIObserver</argument>, <argument>nsISupportsWeakReference</argument>,
                   <argument>nsIMutationObserver</argument>)</argument_list></macro>

<destructor><name><name>PresShell</name>::~<name>PresShell</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mHaveShutDown</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Someone did not call nsIPresShell::destroy"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mCurrentEventContentStack</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr></argument>,
               <argument><expr>"Huh, event content left on the stack in pres shell dtor!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mFirstCallbackEventRequest</name> == <name>nsnull</name> &amp;&amp;
               <name>mLastCallbackEventRequest</name> == <name>nsnull</name></expr></argument>,
               <argument><expr>"post-reflow queues not empty.  This means we're leaking"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <expr_stmt><expr>delete <name>mStyleSet</name></expr>;</expr_stmt>
  <expr_stmt><expr>delete <name>mFrameConstructor</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>mCurrentEventContent</name> = <name>nsnull</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<comment type="block" format="doxygen">/**
 * Initialize the presentation shell. Create view manager and style
 * manager.
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                <param><decl><type><name>nsIViewManager</name>*</type> <name>aViewManager</name></decl></param>,
                <param><decl><type><name>nsStyleSet</name>*</type> <name>aStyleSet</name></decl></param>,
                <param><decl><type><name>nsCompatibility</name></type> <name>aCompatMode</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aDocument</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aPresContext</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aViewManager</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>nsnull</name> == <name>aDocument</name>) || (<name>nsnull</name> == <name>aPresContext</name>) ||
      (<name>nsnull</name> == <name>aViewManager</name>)</expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"PresShell double init'ed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_ALREADY_INITIALIZED</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>mStackArena</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mDocument</name> = <name>aDocument</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mViewManager</name> = <name>aViewManager</name></expr>;</expr_stmt>

  <comment type="line">// Create our frame constructor.</comment>
  <expr_stmt><expr><name>mFrameConstructor</name> = new <call><name>nsCSSFrameConstructor</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mFrameConstructor</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// The document viewer owns both view manager and pres shell.</comment>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>SetViewObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Bind the context to the presentation shell.</comment>
  <expr_stmt><expr><name>mPresContext</name> = <name>aPresContext</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aPresContext</name>-&gt;<name>SetShell</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Now we can initialize the style set.</comment>
  <expr_stmt><expr><name>result</name> = <call><name><name>aStyleSet</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// From this point on, any time we return an error we need to make</comment>
  <comment type="line">// sure to null out mStyleSet first, since an error return from this</comment>
  <comment type="line">// method will cause the caller to delete the style set, so we don't</comment>
  <comment type="line">// want to delete it in our destructor.</comment>
  <expr_stmt><expr><name>mStyleSet</name> = <name>aStyleSet</name></expr>;</expr_stmt>

  <comment type="line">// Notify our prescontext that it now has a compatibility mode.  Note that</comment>
  <comment type="line">// this MUST happen after we set up our style set but before we create any</comment>
  <comment type="line">// frames.</comment>
  <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>CompatibilityModeChanged</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// setup the preference style rules (no forced reflow), and do it</comment>
  <comment type="line">// before creating any frames.</comment>
  <expr_stmt><expr><call><name>SetPreferenceStyleRules</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>result</name> = <call><name>CallCreateInstance</name><argument_list>(<argument><expr><name>kFrameSelectionCID</name></expr></argument>, <argument><expr>&amp;<name>mSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mStyleSet</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Create and initialize the frame manager</comment>
  <expr_stmt><expr><name>result</name> = <call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Init</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mStyleSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Frame manager initialization failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mStyleSet</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Important: this has to happen after the selection has been set up</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_CARET</name></cpp:ifdef>
  <comment type="line">// make the caret</comment>
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>err</name> <init>= <expr><call><name>NS_NewCaret</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mCaret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">//SetCaretEnabled(PR_TRUE);       // make it show in browser windows</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <comment type="line">//set up selection to be displayed in document</comment>
  <comment type="line">// Don't enable selection for print media</comment>
  <decl_stmt><decl><type><name><name>nsPresContext</name>::<name>nsPresContextType</name></name></type> <name>type</name> <init>= <expr><call><name><name>aPresContext</name>-&gt;<name>Type</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>type</name> != <name><name>nsPresContext</name>::<name>eContext_PrintPreview</name></name> &amp;&amp;
      <name>type</name> != <name><name>nsPresContext</name>::<name>eContext_Print</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SetDisplaySelection</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_DISABLED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  
  <if>if <condition>(<expr><name>gMaxRCProcessingTime</name> == -1</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>gMaxRCProcessingTime</name> =
      <call><name><name>nsContentUtils</name>::<name>GetIntPref</name></name><argument_list>(<argument><expr>"layout.reflow.timeslice"</expr></argument>,
                                 <argument><expr><name>NS_MAX_REFLOW_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObserverService</name></expr></argument>&gt;</argument_list></name></type> <name>os</name> <init>=
      <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/observer-service;1"</expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>os</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>NS_LINK_VISITED_EVENT_TOPIC</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"agent-sheet-added"</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"user-sheet-added"</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"agent-sheet-removed"</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"user-sheet-removed"</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"chrome-flush-skin-caches"</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"a11y-init-or-shutdown"</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
  }</block>

  <comment type="line">// cache the drag service so we can check it during reflows</comment>
  <expr_stmt><expr><name>mDragService</name> = <call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/widget/dragservice;1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
    <if>if <condition>(<expr><name>mReflowCountMgr</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>paintFrameCounts</name> <init>=
        <expr><call><name><name>nsContentUtils</name>::<name>GetBoolPref</name></name><argument_list>(<argument><expr>"layout.reflow.showframecounts"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>PRBool</name></type> <name>dumpFrameCounts</name> <init>=
        <expr><call><name><name>nsContentUtils</name>::<name>GetBoolPref</name></name><argument_list>(<argument><expr>"layout.reflow.dumpframecounts"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>PRBool</name></type> <name>dumpFrameByFrameCounts</name> <init>=
        <expr><call><name><name>nsContentUtils</name>::<name>GetBoolPref</name></name><argument_list>(<argument><expr>"layout.reflow.dumpframebyframecounts"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>SetDumpFrameCounts</name></name><argument_list>(<argument><expr><name>dumpFrameCounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>SetDumpFrameByFrameCounts</name></name><argument_list>(<argument><expr><name>dumpFrameByFrameCounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>SetPaintFrameCounts</name></name><argument_list>(<argument><expr><name>paintFrameCounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>Destroy</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
  <expr_stmt><expr><call><name>DumpReflows</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mReflowCountMgr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>mReflowCountMgr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mReflowCountMgr</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>mHaveShutDown</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>mPresContext</name></expr>)</condition><then> <block>{
    <comment type="line">// We need to notify the destroying the nsPresContext to ESM for</comment>
    <comment type="line">// suppressing to use from ESM.</comment>
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>NotifyDestroyPresContext</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObserverService</name></expr></argument>&gt;</argument_list></name></type> <name>os</name> <init>=
      <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/observer-service;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>os</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>NS_LINK_VISITED_EVENT_TOPIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"agent-sheet-added"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"user-sheet-added"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"agent-sheet-removed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"user-sheet-removed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"chrome-flush-skin-caches"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
      <expr_stmt><expr><call><name><name>os</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>"a11y-init-or-shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
  }</block>

  <comment type="line">// If our paint suppression timer is still active, kill it.</comment>
  <if>if <condition>(<expr><name>mPaintSuppressionTimer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mPaintSuppressionTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mPaintSuppressionTimer</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>Terminate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCaret</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="line">// release our pref style sheet, if we have one still</comment>
  <expr_stmt><expr><call><name>ClearPreferenceStyleRules</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mIsDestroying</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <comment type="line">// We can't release all the event content in</comment>
  <comment type="line">// mCurrentEventContentStack here since there might be code on the</comment>
  <comment type="line">// stack that will release the event content too. Double release</comment>
  <comment type="line">// bad!</comment>

  <comment type="line">// The frames will be torn down, so remove them from the current</comment>
  <comment type="line">// event frame stack (since they'd be dangling references if we'd</comment>
  <comment type="line">// leave them in) and null out the mCurrentEventFrame pointer as</comment>
  <comment type="line">// well.</comment>

  <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>nsnull</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name><name>mCurrentEventFrameStack</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>mCurrentEventFrameStack</name>.<name>ReplaceElementAt</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <if>if <condition>(<expr><name>mViewManager</name></expr>)</condition><then> <block>{
    <comment type="line">// Clear the view manager's weak pointer back to |this| in case it</comment>
    <comment type="line">// was leaked.</comment>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>SetViewObserver</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mViewManager</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>BeginShutdown</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// This shell must be removed from the document before the frame</comment>
  <comment type="line">// hierarchy is torn down to avoid finding deleted frames through</comment>
  <comment type="line">// this presshell while the frames are being torn down</comment>
  <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>DeleteShell</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Revoke any pending reflow event.  We need to do this and cancel</comment>
  <comment type="line">// pending reflows before we destroy the frame manager, since</comment>
  <comment type="line">// apparently frame destruction sometimes spins the event queue when</comment>
  <comment type="line">// plug-ins are involved(!).</comment>
  <expr_stmt><expr><call><name><name>mReflowEvent</name>.<name>Revoke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>CancelAllPendingReflows</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Destroy the frame manager. This will destroy the frame hierarchy</comment>
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>WillDestroyFrameTree</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_WARN_IF_FALSE</name><argument_list>(<argument><expr>!<name>mWeakFrames</name></expr></argument>, <argument><expr>"Weak frames alive after destroying FrameManager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>mWeakFrames</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name><name>mWeakFrames</name>-&gt;<name>Clear</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <comment type="line">// Let the style set do its cleanup.</comment>
  <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>Shutdown</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mPresContext</name></expr>)</condition><then> <block>{
    <comment type="line">// Clear out the prescontext's property table -- since our frame tree is</comment>
    <comment type="line">// now dead, we shouldn't be looking up any more properties in that table.</comment>
    <comment type="line">// We want to do this before we call SetShell() on the prescontext, so</comment>
    <comment type="line">// property destructors can usefully call GetPresShell() on the</comment>
    <comment type="line">// prescontext.</comment>
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>PropertyTable</name></name><argument_list>()</argument_list></call>-&gt;<call><name>DeleteAllProperties</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We hold a reference to the pres context, and it holds a weak link back</comment>
    <comment type="line">// to us. To avoid the pres context having a dangling reference, set its </comment>
    <comment type="line">// pres shell to NULL</comment>
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>SetShell</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Clear the link handler (weak reference) as well</comment>
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>SetLinkHandler</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>KillResizeEventTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mHaveShutDown</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

                  <comment type="line">// Dynamic stack memory allocation</comment>
<comment type="block">/* virtual */</comment> <function><type><name>void</name></type>
<name><name>PresShell</name>::<name>PushStackMemory</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mStackArena</name>.<name>Push</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>void</name></type>
<name><name>PresShell</name>::<name>PopStackMemory</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mStackArena</name>.<name>Pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>void</name>*</type>
<name><name>PresShell</name>::<name>AllocateStackMemory</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mStackArena</name>.<name>Allocate</name></name><argument_list>(<argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>FreeFrame</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPtr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mFrameArena</name>.<name>FreeFrame</name></name><argument_list>(<argument><expr><name>aSize</name></expr></argument>, <argument><expr><name>aPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name>*</type>
<name><name>PresShell</name>::<name>AllocateFrame</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mFrameArena</name>.<name>AllocateFrame</name></name><argument_list>(<argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIPresShell</name>::<name>SetAuthorStyleDisabled</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aStyleDisabled</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aStyleDisabled</name> != <call><name><name>mStyleSet</name>-&gt;<name>GetAuthorStyleDisabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>SetAuthorStyleDisabled</name></name><argument_list>(<argument><expr><name>aStyleDisabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReconstructStyleData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIPresShell</name>::<name>GetAuthorStyleDisabled</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name><name>mStyleSet</name>-&gt;<name>GetAuthorStyleDisabled</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>SetPreferenceStyleRules</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForceReflow</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mDocument</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>window</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// If the document doesn't have a window there's no need to notify</comment>
  <comment type="line">// its presshell about changes to preferences since the document is</comment>
  <comment type="line">// in a state where it doesn't matter any more (see</comment>
  <comment type="line">// DocumentViewerImpl::Close()).</comment>

  <if>if <condition>(<expr>!<name>window</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if> 

  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr>"presContext cannot be null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mPresContext</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// first, make sure this is not a chrome shell </comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>container</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShellTreeItem</name></expr></argument>&gt;</argument_list></name></type> <name>docShell</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &amp;&amp; <name>docShell</name></expr>)</condition><then><block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>docShellType</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> = <call><name><name>docShell</name>-&gt;<name>GetItemType</name></name><argument_list>(<argument><expr>&amp;<name>docShellType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
          <if>if <condition>(<expr><name><name>nsIDocShellTreeItem</name>::<name>typeChrome</name></name> == <name>docShellType</name></expr>)</condition><then><block>{
            <return>return <expr><name>NS_OK</name></expr>;</return>
          }</block></then></if>
        }</block></then></if>      
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_attinasi</name></cpp:ifdef>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Setting Preference Style Rules:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// if here, we need to create rules for the prefs</comment>
      <comment type="line">// - this includes the background-color, the text-color,</comment>
      <comment type="line">//   the link color, the visited link color and the link-underlining</comment>
    
      <comment type="line">// first clear any exising rules</comment>
      <expr_stmt><expr><name>result</name> = <call><name>ClearPreferenceStyleRules</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <comment type="line">// now the link rules (must come after the color rules, or links will not be correct color!)</comment>
      <comment type="line">// XXX - when there is both an override and agent pref stylesheet this won't matter,</comment>
      <comment type="line">//       as the color rules will be overrides and the links rules will be agent</comment>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = <call><name>SetPrefLinkRules</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = <call><name>SetPrefFocusRules</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = <call><name>SetPrefNoScriptRule</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = <call><name>SetPrefNoFramesRule</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_attinasi</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"Preference Style Rules set: error=%ld\n"</expr></argument>, <argument><expr>(<name>long</name>)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <if>if <condition>(<expr><name>aForceReflow</name></expr>)</condition><then><block>{
      <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>ClearStyleDataAndReflow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>PresShell</name>::<name>ClearPreferenceStyleRules</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mPrefStyleSheet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mStyleSet</name></expr></argument>, <argument><expr>"null styleset entirely unexpected!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mStyleSet</name></expr>)</condition><then> <block>{
      <comment type="line">// remove the sheet from the styleset: </comment>
      <comment type="line">// - note that we have to check for success by comparing the count before and after...</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>numBefore</name> <init>= <expr><call><name><name>mStyleSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>numBefore</name> &gt; 0</expr></argument>, <argument><expr>"no user stylesheets in styleset, but we have one!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>RemoveStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name>mPrefStyleSheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_attinasi</name></cpp:ifdef>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>numBefore</name> - 1) == <call><name><name>mStyleSet</name>-&gt;<name>GetNumberOfUserStyleSheets</name></name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr>"Pref stylesheet was not removed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"PrefStyleSheet removed\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// clear the sheet pointer: it is strictly historical now</comment>
      <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>PresShell</name>::<name>CreatePreferenceStyleSheet</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mPrefStyleSheet</name></expr></argument>, <argument><expr>"prefStyleSheet already exists"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name>CallCreateInstance</name><argument_list>(<argument><expr><name>kCSSStyleSheetCID</name></expr></argument>, <argument><expr>&amp;<name>mPrefStyleSheet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>"null but no error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>uri</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>NS_NewURI</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"about:PreferenceStyleSheet"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"null but no error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <call><name><name>mPrefStyleSheet</name>-&gt;<name>SetURIs</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mPrefStyleSheet</name>-&gt;<name>SetComplete</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCSSStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>sheet</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>result</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"@namespace url(http://www.w3.org/1999/xhtml);"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>AppendStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name>mPrefStyleSheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>result</name> = <name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  }</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_attinasi</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"CreatePrefStyleSheet completed: error=%ld\n"</expr></argument>,<argument><expr>(<name>long</name>)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">// XXX We want these after the @namespace rule.  Does order matter</comment>
<comment type="line">// for these rules, or can we call nsICSSStyleRule::StyleRuleCount()</comment>
<comment type="line">// and just "append"?</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRUint32</name></type> <name>sInsertPrefSheetRulesAt</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>SetPrefNoScriptRule</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// also handle the case where print is done from print preview</comment>
  <comment type="line">// see bug #342439 for more details</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>scriptEnabled</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>IsScriptEnabled</name></name><argument_list>()</argument_list></call> ||
    ((<call><name><name>mPresContext</name>-&gt;<name>Type</name></name><argument_list>()</argument_list></call> == <name><name>nsPresContext</name>::<name>eContext_PrintPreview</name></name> || 
      <call><name><name>mPresContext</name>-&gt;<name>Type</name></name><argument_list>()</argument_list></call> == <name><name>nsPresContext</name>::<name>eContext_Print</name></name>) &amp;&amp;
     <call><name>NS_PTR_TO_INT32</name><argument_list>(<argument><expr><call><name><name>mDocument</name>-&gt;<name>GetProperty</name></name><argument_list>(
                       <argument><expr><name><name>nsGkAtoms</name>::<name>scriptEnabledBeforePrintPreview</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>scriptEnabled</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name>mPrefStyleSheet</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>CreatePreferenceStyleSheet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// get the DOM interface to the stylesheet</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCSSStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"noscript{display:none!important}"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>PresShell</name>::<name>SetPrefNoFramesRule</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>,<argument><expr>"null prescontext not allowed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mPresContext</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  
  <if>if <condition>(<expr>!<name>mPrefStyleSheet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name>CreatePreferenceStyleSheet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>"prefstylesheet should not be null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// get the DOM interface to the stylesheet</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCSSStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>allowSubframes</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>     
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>docShell</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>docShell</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>docShell</name>-&gt;<name>GetAllowSubframes</name></name><argument_list>(<argument><expr>&amp;<name>allowSubframes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>allowSubframes</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"noframes{display:block}"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"frame, frameset, iframe {display:none!important}"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>
  
<function><type><name>nsresult</name></type> <name><name>PresShell</name>::<name>SetPrefLinkRules</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>,<argument><expr>"null prescontext not allowed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mPresContext</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  
  <if>if <condition>(<expr>!<name>mPrefStyleSheet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name>CreatePreferenceStyleSheet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>"prefstylesheet should not be null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// get the DOM interface to the stylesheet</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCSSStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// support default link colors: </comment>
  <comment type="line">//   this means the link colors need to be overridable, </comment>
  <comment type="line">//   which they are if we put them in the agent stylesheet,</comment>
  <comment type="line">//   though if using an override sheet this will cause authors grief still</comment>
  <comment type="line">//   In the agent stylesheet, they are !important when we are ignoring document colors</comment>
  
  <decl_stmt><decl><type><name>nscolor</name></type> <name>linkColor</name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>DefaultLinkColor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type> <name>activeColor</name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>DefaultActiveLinkColor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type> <name>visitedColor</name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>DefaultVisitedLinkColor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>NS_NAMED_LITERAL_STRING</name><argument_list>(<argument><expr><name>ruleClose</name></expr></argument>, <argument><expr>"}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>strColor</name></decl>;</decl_stmt>

  <comment type="line">// insert a rule to color links: '*|*:link {color: #RRGGBB [!important];}'</comment>
  <expr_stmt><expr><call><name>ColorToString</name><argument_list>(<argument><expr><name>linkColor</name></expr></argument>, <argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"*|*:link{color:"</expr></argument>)</argument_list></call> +
                         <name>strColor</name> + <name>ruleClose</name></expr></argument>,
                         <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// - visited links: '*|*:visited {color: #RRGGBB [!important];}'</comment>
  <expr_stmt><expr><call><name>ColorToString</name><argument_list>(<argument><expr><name>visitedColor</name></expr></argument>, <argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"*|*:visited{color:"</expr></argument>)</argument_list></call> +
                         <name>strColor</name> + <name>ruleClose</name></expr></argument>,
                         <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// - active links: '*|*:-moz-any-link:active {color: #RRGGBB [!important];}'</comment>
  <expr_stmt><expr><call><name>ColorToString</name><argument_list>(<argument><expr><name>activeColor</name></expr></argument>, <argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"*|*:-moz-any-link:active{color:"</expr></argument>)</argument_list></call> +
                         <name>strColor</name> + <name>ruleClose</name></expr></argument>,
                         <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>underlineLinks</name> <init>=
    <expr><call><name><name>mPresContext</name>-&gt;<name>GetCachedBoolPref</name></name><argument_list>(<argument><expr><name>kPresContext_UnderlineLinks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>underlineLinks</name></expr>)</condition><then> <block>{
    <comment type="line">// create a rule to make underlining happen</comment>
    <comment type="line">//  '*|*:-moz-any-link {text-decoration:[underline|none];}'</comment>
    <comment type="line">// no need for important, we want these to be overridable</comment>
    <comment type="line">// NOTE: these must go in the agent stylesheet or they cannot be</comment>
    <comment type="line">//       overridden by authors</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"*|*:-moz-any-link{text-decoration:underline}"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"*|*:-moz-any-link{text-decoration:none}"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>rv</name></expr>;</return>          
}</block></function>

<function><type><name>nsresult</name></type> <name><name>PresShell</name>::<name>SetPrefFocusRules</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>,<argument><expr>"null prescontext not allowed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>mPresContext</name></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = <name>NS_ERROR_FAILURE</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>mPrefStyleSheet</name></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = <call><name>CreatePreferenceStyleSheet</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>, <argument><expr>"prefstylesheet should not be null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// get the DOM interface to the stylesheet</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCSSStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mPrefStyleSheet</name></expr></argument>,<argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>mPresContext</name>-&gt;<name>GetUseFocusColors</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nscolor</name></type> <name>focusBackground</name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>FocusBackgroundColor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nscolor</name></type> <name>focusText</name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>FocusTextColor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">// insert a rule to make focus the preferred color</comment>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>strRule</name></decl>, <decl><type ref="prev"/><name>strColor</name></decl>;</decl_stmt>

        <comment type="line" format="doxygen">///////////////////////////////////////////////////////////////</comment>
        <comment type="line">// - focus: '*:focus</comment>
        <expr_stmt><expr><call><name>ColorToString</name><argument_list>(<argument><expr><name>focusText</name></expr></argument>,<argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"*:focus,*:focus&gt;font {color: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>Append</name></name><argument_list>(<argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>" !important; background-color: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ColorToString</name><argument_list>(<argument><expr><name>focusBackground</name></expr></argument>,<argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>Append</name></name><argument_list>(<argument><expr><name>strColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>" !important; } "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// insert the rules</comment>
        <expr_stmt><expr><name>result</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><name>strRule</name></expr></argument>, <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <decl_stmt><decl><type><name>PRUint8</name></type> <name>focusRingWidth</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>FocusRingWidth</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>focusRingOnAnything</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetFocusRingOnAnything</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>(<call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &amp;&amp; <name>focusRingWidth</name> != 1 &amp;&amp; <name>focusRingWidth</name> &lt;= 4 ) || <name>focusRingOnAnything</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>strRule</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>focusRingOnAnything</name></expr>)</condition><then>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"*|*:link:focus, *|*:visited"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>    <comment type="line">// If we only want focus rings on the normal things like links</comment>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>":focus {outline: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="line">// For example 3px dotted WindowText (maximum 4)</comment>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendInt</name></name><argument_list>(<argument><expr><name>focusRingWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"px dotted WindowText !important; } "</expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="line">// For example 3px dotted WindowText</comment>
        <comment type="line">// insert the rules</comment>
        <expr_stmt><expr><name>result</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><name>strRule</name></expr></argument>, <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>focusRingWidth</name> != 1</expr>)</condition><then> <block>{
          <comment type="line">// If the focus ring width is different from the default, fix buttons with rings</comment>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"button::-moz-focus-inner, input[type=\"reset\"]::-moz-focus-inner,"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"input[type=\"button\"]::-moz-focus-inner, "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"input[type=\"submit\"]::-moz-focus-inner { padding: 1px 2px 1px 2px; border: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendInt</name></name><argument_list>(<argument><expr><name>focusRingWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"px dotted transparent !important; } "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><name>strRule</name></expr></argument>, <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"button:focus::-moz-focus-inner, input[type=\"reset\"]:focus::-moz-focus-inner,"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"input[type=\"button\"]:focus::-moz-focus-inner, input[type=\"submit\"]:focus::-moz-focus-inner {"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>strRule</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"border-color: ButtonText !important; }"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> = <call><name><name>sheet</name>-&gt;<name>InsertRule</name></name><argument_list>(<argument><expr><name>strRule</name></expr></argument>, <argument><expr><name>sInsertPrefSheetRulesAt</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>AddUserSheet</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Make sure this does what DocumentViewerImpl::CreateStyleSet does wrt</comment>
  <comment type="line">// ordering. We want this new sheet to come after all the existing stylesheet</comment>
  <comment type="line">// service sheets, but before other user sheets; see nsIStyleSheetService.idl</comment>
  <comment type="line">// for the ordering.  Just remove and readd all the nsStyleSheetService</comment>
  <comment type="line">// sheets.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStyleSheetService</name></expr></argument>&gt;</argument_list></name></type> <name>dummy</name> <init>=
    <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_STYLESHEETSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>BeginUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsStyleSheetService</name> *</type><name>sheetService</name> <init>= <expr><name><name>nsStyleSheetService</name>::<name>gInstance</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name> &amp;</type> <name>userSheets</name> <init>= <expr>*<call><name><name>sheetService</name>-&gt;<name>UserStyleSheets</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
  <comment type="line">// Iterate forwards when removing so the searches for RemoveStyleSheet are as</comment>
  <comment type="line">// short as possible.</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name><name>userSheets</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>RemoveStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name><name>userSheets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// Now iterate backwards, so that the order of userSheets will be the same as</comment>
  <comment type="line">// the order of sheets from it in the style set.</comment>
  <for>for (<init><expr><name>i</name> = <call><name><name>userSheets</name>.<name>Count</name></name><argument_list>()</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>PrependStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name><name>userSheets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>EndUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ReconstructStyleData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>AddAgentSheet</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Make sure this does what DocumentViewerImpl::CreateStyleSet does</comment>
  <comment type="line">// wrt ordering.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aSheet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sheet</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>AppendStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>, <argument><expr><name>sheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReconstructStyleData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>RemoveSheet</name></name><parameter_list>(<param><decl><type><name><name>nsStyleSet</name>::<name>sheetType</name></name></type> <name>aType</name></decl></param>, <param><decl><type><name>nsISupports</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>sheet</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aSheet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sheet</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>RemoveStyleSheet</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>, <argument><expr><name>sheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReconstructStyleData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>SetDisplaySelection</name></name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>aToggle</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>SetDisplaySelection</name></name><argument_list>(<argument><expr><name>aToggle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetDisplaySelection</name></name><parameter_list>(<param><decl><type><name>PRInt16</name> *</type><name>aToggle</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aToggle</name> = <call><name><name>mSelection</name>-&gt;<name>GetDisplaySelection</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetSelection</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>, <param><decl><type><name>nsISelection</name> **</type><name>aSelection</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aSelection</name> || !<name>mSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aSelection</name> = <call><name><name>mSelection</name>-&gt;<name>GetSelection</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!(*<name>aSelection</name>)</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsISelection</name>*</type>
<name><name>PresShell</name>::<name>GetCurrentSelection</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mSelection</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>GetSelection</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ScrollSelectionIntoView</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>, <param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>ScrollSelectionIntoView</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>, <argument><expr><name>aRegion</name></expr></argument>, <argument><expr><name>aIsSynchronous</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>RepaintSelection</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>RepaintSelection</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Make shell be a document observer</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>BeginObservingDocument</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mDocument</name> &amp;&amp; !<name>mIsDestroying</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mIsDocumentGone</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Adding a presshell that was disconnected from the document "
                 "as a document observer?  Sounds wrong..."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mIsDocumentGone</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Make shell stop being a document observer</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>EndObservingDocument</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// XXXbz do we need to tell the frame constructor that the document</comment>
  <comment type="line">// is gone, perhaps?  Except for printing it's NOT gone, sometimes.</comment>
  <expr_stmt><expr><name>mIsDocumentGone</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_kipp</name></cpp:ifdef>
<decl_stmt><decl><type><name>char</name>*</type> <name>nsPresShell_ReflowStackPointerTop</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>CheckForFocus</name><parameter_list>(<param><decl><type><name>nsPIDOMWindow</name>*</type> <name>aOurWindow</name></decl></param>,
                          <param><decl><type><name>nsIFocusController</name>*</type> <name>aFocusController</name></decl></param>,
                          <param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aOurWindow</name>-&gt;<name>IsOuterWindow</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Uh, our window has to be an outer window!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Now that we have a root frame, we can set focus on the presshell.</comment>
  <comment type="line">// We do this only if our DOM window is currently focused or is an</comment>
  <comment type="line">// an ancestor of a previously focused window.</comment>

  <if>if <condition>(<expr>!<name>aFocusController</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMWindowInternal</name></expr></argument>&gt;</argument_list></name></type> <name>ourWin</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aOurWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMWindowInternal</name></expr></argument>&gt;</argument_list></name></type> <name>focusedWindow</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aFocusController</name>-&gt;<name>GetFocusedWindow</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedWindow</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>focusedWindow</name></expr>)</condition><then> <block>{
    <comment type="line">// This should never really happen, but if it does, assume</comment>
    <comment type="line">// we can focus ourself to keep the window from being keydead.</comment>
    <expr_stmt><expr><name>focusedWindow</name> = <name>ourWin</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Walk up the document chain, starting with focusedWindow's document.</comment>
  <comment type="line">// We stop walking when we find a document that has a null DOMWindow</comment>
  <comment type="line">// (meaning that the DOMWindow has a new document now) or find ourWin</comment>
  <comment type="line">// as the document's window.  We also stop if we hit aDocument, since</comment>
  <comment type="line">// that means there is a child document which loaded before us that's</comment>
  <comment type="line">// already been given focus.</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>focusedDOMDoc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>focusedWindow</name>-&gt;<name>GetDocument</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedDOMDoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocument</name></expr></argument>&gt;</argument_list></name></type> <name>curDoc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>focusedDOMDoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>curDoc</name></expr>)</condition><then> <block>{
    <comment type="line">// This can happen if the previously focused DOM window has been</comment>
    <comment type="line">// unhooked from its document during document teardown.  We don't</comment>
    <comment type="line">// really have any other information to help us determine where</comment>
    <comment type="line">// focusedWindow fits into the DOM window hierarchy.  For now, we'll</comment>
    <comment type="line">// go ahead and allow this window to take focus, so that something</comment>
    <comment type="line">// ends up focused.</comment>

    <expr_stmt><expr><name>curDoc</name> = <name>aDocument</name></expr>;</expr_stmt>
  }</block></then></if>

  <while>while <condition>(<expr><name>curDoc</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>curWin</name> <init>= <expr><call><name><name>curDoc</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>curWin</name> || <name>curWin</name> == <name>ourWin</name></expr>)</condition><then>
      <break>break;</break></then></if>

    <expr_stmt><expr><name>curDoc</name> = <call><name><name>curDoc</name>-&gt;<name>GetParentDocument</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>curDoc</name> == <name>aDocument</name></expr>)</condition><then>
      <return>return;</return></then></if>
  }</block></while>

  <if>if <condition>(<expr>!<name>curDoc</name></expr>)</condition><then> <block>{
    <comment type="line">// We reached the top of the document chain, and did not encounter ourWin</comment>
    <comment type="line">// or a windowless document. So, focus should be unaffected by this</comment>
    <comment type="line">// document load.</comment>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>active</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aFocusController</name>-&gt;<name>GetActive</name></name><argument_list>(<argument><expr>&amp;<name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>active</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>ourWin</name>-&gt;<name>Focus</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// We need to ensure that the focus controller is updated, since it may be</comment>
  <comment type="line">// suppressed when this function is called.</comment>
  <expr_stmt><expr><call><name><name>aFocusController</name>-&gt;<name>SetFocusedWindow</name></name><argument_list>(<argument><expr><name>ourWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetDidInitialReflow</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aDidInitialReflow</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aDidInitialReflow</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aDidInitialReflow</name> = <name>mDidInitialReflow</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>InitialReflow</name></name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aHeight</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mIsDestroying</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><name>mDidInitialReflow</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIURI</name> *</type><name>uri</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetDocumentURI</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>uri</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>url</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>uri</name>-&gt;<name>GetSpec</name></name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** PresShell::InitialReflow (this=%p, url='%s')\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>this</name></expr></argument>, <argument><expr><call><name><name>url</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>EraseCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// XXX Do a full invalidate at the beginning so that invalidates along</comment>
  <comment type="line">// the way don't have region accumulation issues?</comment>

  <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>SetVisibleArea</name></name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aWidth</name></expr></argument>, <argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>root</name> <init>= <expr><name>mDocument</name> ? <call><name><name>mDocument</name>-&gt;<name>GetRootContent</name></name><argument_list>()</argument_list></call> : <name>nsnull</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Get the root frame from the frame manager</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if>if <condition>(<expr><name>root</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Reset and start: Frame Creation: PresShell::InitialReflow(), this=%p\n",
                        (<name>void</name>*)<name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MOZ_TIMER_RESET</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MOZ_TIMER_START</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>rootFrame</name></expr>)</condition><then> <block>{
      <comment type="line">// Have style sheet processor construct a frame for the</comment>
      <comment type="line">// precursors to the root content object's frame</comment>
      <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ConstructRootFrame</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr>&amp;<name>rootFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>SetRootFrame</name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Have the style sheet processor construct frame for the root</comment>
    <comment type="line">// content object down</comment>
    <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ContentInserted</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr>0</expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Stop: Frame Creation: PresShell::InitialReflow(), this=%p\n",
                        (<name>void</name>*)<name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MOZ_TIMER_STOP</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Something in mFrameConstructor-&gt;ContentInserted may have caused</comment>
    <comment type="line">// Destroy() to get called, bug 337586.</comment>
    <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr>!<name>mHaveShutDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Run the XBL binding constructors for any new frames we've constructed</comment>
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>BindingManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ProcessAttachedQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Constructors may have killed us too</comment>
    <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr>!<name>mHaveShutDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Now flush out pending restyles before we actually reflow, in</comment>
    <comment type="line">// case XBL constructors changed styles somewhere.</comment>
    <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ProcessPendingRestyles</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// And that might have run _more_ XBL constructors</comment>
    <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr>!<name>mHaveShutDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Now reget the root frame, since all that script might have affected it</comment>
    <comment type="line">// somehow.  Currently that can't happen, as long as mHaveShutDown is</comment>
    <comment type="line">// false, but let's not rely on that.</comment>
    <expr_stmt><expr><name>rootFrame</name> = <call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>rootFrame</name></expr>)</condition><then> <block>{
    <comment type="line">// Note: Because the frame just got created, it has the NS_FRAME_IS_DIRTY</comment>
    <comment type="line">// bit set.  Unset it so that FrameNeedsReflow() will work right.</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mDirtyRoots</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call> == -1</expr></argument>,
                 <argument><expr>"Why is the root in mDirtyRoots already?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>rootFrame</name>-&gt;<name>RemoveStateBits</name></name><argument_list>(<argument><expr><name>NS_FRAME_IS_DIRTY</name> |
                               <name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><name>eResize</name></expr></argument>, <argument><expr><name>NS_FRAME_IS_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mDirtyRoots</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call> != -1</expr></argument>,
                 <argument><expr>"Should be in mDirtyRoots now"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mReflowEvent</name>.<name>IsPending</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Why no reflow event pending?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Restore our root scroll position now if we're getting here after EndLoad</comment>
  <comment type="line">// got called, since this is our one chance to do it.  Note that we need not</comment>
  <comment type="line">// have reflowed for this to work; when the scrollframe is finally reflowed</comment>
  <comment type="line">// it'll puick up the position we store in it here.</comment>
  <if>if <condition>(<expr>!<name>mDocumentLoading</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>RestoreRootScrollPosition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// For printing, we just immediately unsuppress.</comment>
  <if>if <condition>(<expr>!<call><name><name>mPresContext</name>-&gt;<name>IsPaginated</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Kick off a one-shot timer based off our pref value.  When this timer</comment>
    <comment type="line">// fires, if painting is still locked down, then we will go ahead and</comment>
    <comment type="line">// trigger a full invalidate and allow painting to proceed normally.</comment>
    <expr_stmt><expr><name>mPaintingSuppressed</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mPaintSuppressionTimer</name> = <call><name>do_CreateInstance</name><argument_list>(<argument><expr>"@mozilla.org/timer;1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mPaintSuppressionTimer</name></expr>)</condition><then>
      <comment type="line">// Uh-oh.  We must be out of memory.  No point in keeping painting locked down.</comment>
      <expr_stmt><expr><name>mPaintingSuppressed</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then>
    <else>else <block>{
      <comment type="line">// Initialize the timer.</comment>

      <comment type="line">// Default to PAINTLOCK_EVENT_DELAY if we can't get the pref value.</comment>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>delay</name> <init>=
        <expr><call><name><name>nsContentUtils</name>::<name>GetIntPref</name></name><argument_list>(<argument><expr>"nglayout.initialpaint.delay"</expr></argument>,
                                   <argument><expr><name>PAINTLOCK_EVENT_DELAY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name><name>mPaintSuppressionTimer</name>-&gt;<name>InitWithFuncCallback</name></name><argument_list>(<argument><expr><name>sPaintSuppressionCallback</name></expr></argument>,
                                                   <argument><expr><name>this</name></expr></argument>, <argument><expr><name>delay</name></expr></argument>, 
                                                   <argument><expr><name><name>nsITimer</name>::<name>TYPE_ONE_SHOT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return> <comment type="line">//XXX this needs to be real. MMP</comment>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>sPaintSuppressionCallback</name></name><parameter_list>(<param><decl><type><name>nsITimer</name> *</type><name>aTimer</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPresShell</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PresShell</name>*</type> <name>self</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>PresShell</name>*</expr></argument>, <argument><expr><name>aPresShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>self</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>self</name>-&gt;<name>UnsuppressPainting</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ResizeReflow</name></name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aHeight</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsReflowing</name></expr></argument>, <argument><expr>"Shouldn't be in reflow here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// If we don't have a root frame yet, that means we haven't had our initial</comment>
  <comment type="line">// reflow... If that's the case, and aWidth or aHeight is unconstrained,</comment>
  <comment type="line">// ignore them altogether.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>rootFrame</name> &amp;&amp;
      (<name>aWidth</name> == <name>NS_UNCONSTRAINEDSIZE</name> || <name>aHeight</name> == <name>NS_UNCONSTRAINEDSIZE</name>)</expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>SetVisibleArea</name></name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aWidth</name></expr></argument>, <argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// There isn't anything useful we can do if the initial reflow hasn't happened</comment>
  <if>if <condition>(<expr>!<name>rootFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mViewManager</name></expr></argument>, <argument><expr>"Must have view manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>BeginUpdateViewBatch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXX Do a full invalidate at the beginning so that invalidates along</comment>
  <comment type="line">// the way don't have region accumulation issues?</comment>

  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WillDoReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <block>{
    <comment type="line">// Kick off a top-down reflow</comment>
    <expr_stmt><expr><call><name>AUTO_LAYOUT_PHASE_ENTRY_POINT</name><argument_list>(<argument><expr><call><name>GetPresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Reflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIsReflowing</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mDirtyRoots</name>.<name>RemoveElement</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DoReflow</name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIsReflowing</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block>

  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidDoReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>EndUpdateViewBatch</name></name><argument_list>(<argument><expr><name>NS_VMREFRESH_NO_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>CreateResizeEventTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return> <comment type="line">//XXX this needs to be real. MMP</comment>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESIZE_EVENT_DELAY</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>CreateResizeEventTimer</name></name> <parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>KillResizeEventTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mIsDocumentGone</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><name>mResizeEventTimer</name> = <call><name>do_CreateInstance</name><argument_list>(<argument><expr>"@mozilla.org/timer;1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mResizeEventTimer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mResizeEventTimer</name>-&gt;<name>InitWithFuncCallback</name></name><argument_list>(<argument><expr><name>sResizeEventCallback</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>RESIZE_EVENT_DELAY</name></expr></argument>, 
                                            <argument><expr><name><name>nsITimer</name>::<name>TYPE_ONE_SHOT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>KillResizeEventTimer</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if<condition>(<expr><name>mResizeEventTimer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mResizeEventTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mResizeEventTimer</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>sResizeEventCallback</name></name><parameter_list>(<param><decl><type><name>nsITimer</name> *</type><name>aTimer</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPresShell</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PresShell</name>*</type> <name>self</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>PresShell</name>*</expr></argument>, <argument><expr><name>aPresShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>self</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>self</name>-&gt;<name>FireResizeEvent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>FireResizeEvent</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mIsDocumentGone</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">//Send resize event from here.</comment>
  <function_decl><type><name>nsEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_RESIZE_EVENT</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsEventStatus</name></type> <name>status</name> <init>= <expr><name>nsEventStatus_eIgnore</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>window</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>window</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsEventDispatcher</name>::<name>Dispatch</name></name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name>mPresContext</name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>SetIgnoreFrameDestruction</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIgnore</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mIgnoreFrameDestruction</name> = <name>aIgnore</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>NotifyDestroyingFrame</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mIgnoreFrameDestruction</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>NotifyDestroyingFrame</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>PRInt32</name></type> <name>idx</name> <init>= <expr><call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>idx</name></expr>;</condition> <incr/>) <block>{
      <expr_stmt><expr>--<name>idx</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>mDirtyRoots</name><index>[<expr><name>idx</name></expr>]</index></name> == <name>aFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mDirtyRoots</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>

    <comment type="line">// Notify the frame manager</comment>
    <expr_stmt><expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>NotifyDestroyingFrame</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Remove frame properties</comment>
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>PropertyTable</name></name><argument_list>()</argument_list></call>-&gt;<call><name>DeleteAllPropertiesFor</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// note that this can return a null caret, but NS_OK</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>GetCaret</name></name><parameter_list>(<param><decl><type><name>nsICaret</name> **</type><name>outCaret</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>outCaret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr>*<name>outCaret</name> = <name>mCaret</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>outCaret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>PresShell</name></macro><expr_stmt><expr><name>::<name>MaybeInvalidateCaretPosition</name></name>()
<block>{
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>InvalidateOutsideCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
}

already_AddRefed<expr_stmt><expr>&lt;<name>nsICaret</name>&gt; <macro><name>PresShell</name></macro><name>::<name>SetCaret</name></name>(<name>nsICaret</name> *<name>aNewCaret</name>)
<block>{
  <expr><name>nsICaret</name> *<name>oldCaret</name> = <name>nsnull</name></expr>;
  <expr><call><name><name>mCaret</name>.<name>swap</name></name><argument_list>(<argument><expr><name>oldCaret</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>mCaret</name> = <name>aNewCaret</name></expr>;
  <return>return <expr><name>oldCaret</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>SetCaretEnabled</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInEnable</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>   <name>oldEnabled</name> <init>= <expr><name>mCaretEnabled</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>mCaretEnabled</name> = <name>aInEnable</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mCaret</name> &amp;&amp; (<name>mCaretEnabled</name> != <name>oldEnabled</name>)</expr>)</condition><then>
  <block>{
<comment type="block">/*  Don't change the caret's selection here! This was an evil side-effect of SetCaretEnabled()
    nsCOMPtr&lt;nsIDOMSelection&gt; domSel;
    if (NS_SUCCEEDED(GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel))) &amp;&amp; domSel)
      mCaret-&gt;SetCaretDOMSelection(domSel);
*/</comment>
    <expr_stmt><expr><name>result</name> = <call><name><name>mCaret</name>-&gt;<name>SetCaretVisible</name></name><argument_list>(<argument><expr><name>mCaretEnabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>SetCaretReadOnly</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aReadOnly</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>SetCaretReadOnly</name></name><argument_list>(<argument><expr><name>aReadOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>GetCaretEnabled</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aOutEnabled</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aOutEnabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aOutEnabled</name> = <name>mCaretEnabled</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>SetCaretVisibilityDuringSelection</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aVisibility</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>SetVisibilityDuringSelection</name></name><argument_list>(<argument><expr><name>aVisibility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>SetSelectionFlags</name></name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>aInEnable</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mSelectionFlags</name> = <name>aInEnable</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>GetSelectionFlags</name></name><parameter_list>(<param><decl><type><name>PRInt16</name> *</type><name>aOutEnable</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aOutEnable</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>aOutEnable</name> = <name>mSelectionFlags</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//implementation of nsISelectionController</comment>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>CharacterMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>CharacterMove</name></name><argument_list>(<argument><expr><name>aForward</name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>)</argument_list></call></expr>;</return>  
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>WordMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>WordMove</name></name><argument_list>(<argument><expr><name>aForward</name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>)</argument_list></call></expr>;</return>  
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>WordExtendForDelete</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>WordExtendForDelete</name></name><argument_list>(<argument><expr><name>aForward</name></expr></argument>)</argument_list></call></expr>;</return>  
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>LineMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>mSelection</name>-&gt;<name>LineMove</name></name><argument_list>(<argument><expr><name>aForward</name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  
<comment type="line">// if we can't go down/up any more we must then move caret completely to </comment>
<comment type="line">// end/beginning respectively.</comment>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
    <expr_stmt><expr><name>result</name> = <call><name>CompleteMove</name><argument_list>(<argument><expr><name>aForward</name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>IntraLineMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>IntraLineMove</name></name><argument_list>(<argument><expr><name>aForward</name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>)</argument_list></call></expr>;</return>  
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>PageMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIViewManager</name>*</type> <name>viewManager</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIScrollableView</name> *</type><name>scrollableView</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>viewManager</name></expr>)</condition><then> 
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>viewManager</name>-&gt;<name>GetRootScrollableView</name></name><argument_list>(<argument><expr>&amp;<name>scrollableView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name>scrollableView</name></expr>)</condition><then> 
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIView</name> *</type><name>scrolledView</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name><name>scrollableView</name>-&gt;<name>GetScrolledView</name></name><argument_list>(<argument><expr><name>scrolledView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>CommonPageMove</name></name><argument_list>(<argument><expr><name>aForward</name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>, <argument><expr><name>scrollableView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// do ScrollSelectionIntoView()</comment>
  <return>return <expr><call><name>ScrollSelectionIntoView</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>, <argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>ScrollPage</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollView</name> <init>= <expr><call><name>GetViewToScroll</name><argument_list>(<argument><expr><name><name>nsLayoutUtils</name>::<name>eVertical</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>scrollView</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>scrollView</name>-&gt;<name>ScrollByPages</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>aForward</name> ? 1 : -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ScrollLine</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollView</name> <init>= <expr><call><name>GetViewToScroll</name><argument_list>(<argument><expr><name><name>nsLayoutUtils</name>::<name>eVertical</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>scrollView</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_WIDGET_COCOA</name></cpp:ifdef>
    <comment type="line">// Emulate the Mac IE behavior of scrolling a minimum of 2 lines</comment>
    <comment type="line">// rather than 1.  This vastly improves scrolling speed.</comment>
    <expr_stmt><expr><call><name><name>scrollView</name>-&gt;<name>ScrollByLines</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>aForward</name> ? 2 : -2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name><name>scrollView</name>-&gt;<name>ScrollByLines</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>aForward</name> ? 1 : -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      
<comment type="line">//NEW FOR LINES    </comment>
    <comment type="line">// force the update to happen now, otherwise multiple scrolls can</comment>
    <comment type="line">// occur before the update is processed. (bug #7354)</comment>

  <comment type="line">// I'd use Composite here, but it doesn't always work.</comment>
    <comment type="line">// vm-&gt;Composite();</comment>
    <decl_stmt><decl><type><name>nsIViewManager</name>*</type> <name>viewManager</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>viewManager</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>viewManager</name>-&gt;<name>ForceUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ScrollHorizontal</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aLeft</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollView</name> <init>= <expr><call><name>GetViewToScroll</name><argument_list>(<argument><expr><name><name>nsLayoutUtils</name>::<name>eHorizontal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>scrollView</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>scrollView</name>-&gt;<name>ScrollByLines</name></name><argument_list>(<argument><expr><name>aLeft</name> ? -1 : 1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//NEW FOR LINES    </comment>
    <comment type="line">// force the update to happen now, otherwise multiple scrolls can</comment>
    <comment type="line">// occur before the update is processed. (bug #7354)</comment>

  <comment type="line">// I'd use Composite here, but it doesn't always work.</comment>
    <comment type="line">// vm-&gt;Composite();</comment>
    <decl_stmt><decl><type><name>nsIViewManager</name>*</type> <name>viewManager</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>viewManager</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>viewManager</name>-&gt;<name>ForceUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CompleteScroll</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollView</name> <init>= <expr><call><name>GetViewToScroll</name><argument_list>(<argument><expr><name><name>nsLayoutUtils</name>::<name>eVertical</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>scrollView</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>scrollView</name>-&gt;<name>ScrollByWhole</name></name><argument_list>(<argument><expr>!<name>aForward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//TRUE = top, aForward TRUE=bottom</comment>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CompleteMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>CompleteMoveInner</name><argument_list>(<argument><expr><name>aForward</name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>CompleteMoveInner</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aScrollIntoView</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIScrollableView</name> *</type><name>scrollableView</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>mViewManager</name></expr>)</condition><then> 
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>mViewManager</name>-&gt;<name>GetRootScrollableView</name></name><argument_list>(<argument><expr>&amp;<name>scrollableView</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name>scrollableView</name></expr>)</condition><then> 
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIView</name> *</type><name>scrolledView</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name><name>scrollableView</name>-&gt;<name>GetScrolledView</name></name><argument_list>(<argument><expr><name>scrolledView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// get a frame</comment>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>frame</name> <init>= <expr>(<name>nsIFrame</name>*)<call><name><name>scrolledView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <comment type="line">//we need to get to the area frame.</comment>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>frameType</name></decl>;</decl_stmt>
  <do>do 
  <block>{
    <expr_stmt><expr><name>frameType</name> = <call><name><name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>frameType</name> != <name><name>nsGkAtoms</name>::<name>areaFrame</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>frame</name> = <call><name><name>frame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></then></if>
  }</block>while<condition>(<expr><name>frameType</name> != <name><name>nsGkAtoms</name>::<name>areaFrame</name></name></expr>)</condition>;</do>
  
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if> <comment type="line">//could not find an area frame.</comment>

  <decl_stmt><decl><type><name>nsPeekOffsetStruct</name></type> <name>pos</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>GetExtremeCaretPosition</name></name><argument_list>(<argument><expr>!<name>aForward</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>HandleClick</name></name><argument_list>(<argument><expr><name><name>pos</name>.<name>mResultContent</name></name></expr></argument> ,<argument><expr><name><name>pos</name>.<name>mContentOffset</name></name></expr></argument> ,<argument><expr><name><name>pos</name>.<name>mContentOffset</name></name></expr></argument><comment type="block">/*End*/</comment> ,<argument><expr><name>aExtend</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>aForward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aScrollIntoView</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name>ScrollSelectionIntoView</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>, 
                                     <argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
      <return>return <expr><name>result</name></expr>;</return></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>SelectAll</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name><name>mSelection</name>-&gt;<name>SelectAll</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CheckVisibility</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>startOffset</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>EndOffset</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>_retval</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>node</name> || <name>startOffset</name>&gt;<name>EndOffset</name> || !<name>_retval</name> || <name>startOffset</name>&lt;0 || <name>EndOffset</name>&lt;0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>_retval</name> = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">//initialize return parameter</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>frame</name> <init>= <expr><call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then> <comment type="line">//no frame to look at so it must not be visible</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>  
  <comment type="line">//start process now to go through all frames to find startOffset. then check chars after that to see </comment>
  <comment type="line">//if anything until EndOffset is visible.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>finished</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>CheckVisibility</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>,<argument><expr><name>startOffset</name></expr></argument>,<argument><expr><name>EndOffset</name></expr></argument>,<argument><expr><name>PR_TRUE</name></expr></argument>,<argument><expr>&amp;<name>finished</name></expr></argument>, <argument><expr><name>_retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return><comment type="line">//dont worry about other return val</comment>
}</block></function>

<comment type="line">//end implementations nsISelectionController</comment>


<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>StyleChangeReflow</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// At the moment at least, we don't have a root frame before the initial</comment>
  <comment type="line">// reflow; it's safe to just ignore the request in that case</comment>
  <if>if <condition>(<expr>!<name>rootFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <return>return <expr><call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><name>eStyleChange</name></expr></argument>, <argument><expr><name>NS_FRAME_IS_DIRTY</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIFrame</name>*</type>
<name><name>nsIPresShell</name>::<name>GetRootFrame</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIFrame</name>*</type>
<name><name>nsIPresShell</name>::<name>GetRootScrollFrame</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Ensure root frame is a viewport frame</comment>
  <if>if <condition>(<expr>!<name>rootFrame</name> || <name><name>nsGkAtoms</name>::<name>viewportFrame</name></name> != <call><name><name>rootFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>theFrame</name> <init>= <expr><call><name><name>rootFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>theFrame</name> || <name><name>nsGkAtoms</name>::<name>scrollFrame</name></name> != <call><name><name>theFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>
  <return>return <expr><name>theFrame</name></expr>;</return>
}</block></function>

<function><type><name>nsIScrollableFrame</name>*</type>
<name><name>nsIPresShell</name>::<name>GetRootScrollFrameAsScrollable</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>GetRootScrollFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIScrollableFrame</name>*</type> <name>scrollableFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr>&amp;<name>scrollableFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>scrollableFrame</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetPageSequenceFrame</name></name><parameter_list>(<param><decl><type><name>nsIPageSequenceFrame</name>**</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aResult</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>nsnull</name> == <name>aResult</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>aResult</name> = <name>nsnull</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>mFrameConstructor</name>-&gt;<name>GetPageSequenceFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>frame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>*<name>aResult</name> ? <name>NS_OK</name> : <name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>BeginUpdate</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>, <param><decl><type><name>nsUpdateType</name></type> <name>aUpdateType</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mUpdateCount</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>BeginUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aUpdateType</name> &amp; <name>UPDATE_STYLE</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>BeginUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>EndUpdate</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>, <param><decl><type><name>nsUpdateType</name></type> <name>aUpdateType</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>0 != <name>mUpdateCount</name></expr></argument>, <argument><expr>"too many EndUpdate's"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>--<name>mUpdateCount</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>aUpdateType</name> &amp; <name>UPDATE_STYLE</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>EndUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mStylesHaveChanged</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>ReconstructStyleData</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>EndUpdate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>RestoreRootScrollPosition</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// Restore frame state for the root scroll frame</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILayoutHistoryState</name></expr></argument>&gt;</argument_list></name></type> <name>historyState</name> <init>=
    <expr><call><name><name>mDocument</name>-&gt;<name>GetLayoutHistoryState</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Make sure we don't reenter reflow via the sync paint that happens while</comment>
  <comment type="line">// we're scrolling to our restored position.  Entering reflow for the</comment>
  <comment type="line">// scrollable frame will cause it to reenter ScrollToRestoredPosition(), and</comment>
  <comment type="line">// it'll get all confused.</comment>
  <expr_stmt><expr>++<name>mChangeNestCount</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>historyState</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>scrollFrame</name> <init>= <expr><call><name>GetRootScrollFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>scrollFrame</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIScrollableFrame</name>*</type> <name>scrollableFrame</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>scrollFrame</name></expr></argument>, <argument><expr>&amp;<name>scrollableFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>scrollableFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>RestoreFrameStateFor</name><argument_list>(<argument><expr><name>scrollFrame</name></expr></argument>, <argument><expr><name>historyState</name></expr></argument>,
                                             <argument><expr><name><name>nsIStatefulFrame</name>::<name>eDocumentScrollState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>scrollableFrame</name>-&gt;<name>ScrollToRestoredPosition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr>--<name>mChangeNestCount</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>BeginLoad</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>)</parameter_list>
<block>{  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_PERF_METRICS</name></cpp:ifdef>
  <comment type="line">// Reset style resolution stopwatch maintained by style set</comment>
  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Reset: Style Resolution: PresShell::BeginLoad(), this=%p\n", (<name>void</name>*)<name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <expr_stmt><expr><name>mDocumentLoading</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>EndLoad</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Wrong document"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>RestoreRootScrollPosition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_PERF_METRICS</name></cpp:ifdef>
  <comment type="line">// Dump reflow, style resolution and frame construction times here.</comment>
  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Stop: Reflow: PresShell::EndLoad(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_STOP</name><argument_list>(<argument><expr><name>mReflowWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_LOG</name><argument_list>(<argument><expr>("Reflow time (this=%p): ", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_PRINT</name><argument_list>(<argument><expr><name>mReflowWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Stop: Frame Creation: PresShell::EndLoad(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_STOP</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_LOG</name><argument_list>(<argument><expr>("Frame construction plus style resolution time (this=%p): ", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_PRINT</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Print style resolution stopwatch maintained by style set</comment>
  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Stop: Style Resolution: PresShell::EndLoad(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <expr_stmt><expr><name>mDocumentLoading</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>VerifyHasDirtyRootAncestor</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXXbz due to bug 372769, can't actually assert anything here...</comment>
  <return>return;</return>
  
  <comment type="line">// XXXbz shouldn't need this part; remove it once FrameNeedsReflow</comment>
  <comment type="line">// handles the root frame correctly.</comment>
  <if>if <condition>(<expr>!<call><name><name>aFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
        
  <comment type="line">// Make sure that there is a reflow root ancestor of |aFrame| that's</comment>
  <comment type="line">// in mDirtyRoots already.</comment>
  <while>while <condition>(<expr><name>aFrame</name> &amp;&amp; (<call><name><name>aFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_HAS_DIRTY_CHILDREN</name>)</expr>)</condition> <block>{
    <if>if <condition>(<expr>((<call><name><name>aFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_REFLOW_ROOT</name>) ||
         !<call><name><name>aFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call>) &amp;&amp;
        <call><name><name>mDirtyRoots</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
      <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>aFrame</name> = <call><name><name>aFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Frame has dirty bits set but isn't scheduled to be "
                "reflowed?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>FrameNeedsReflow</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>IntrinsicDirty</name></type> <name>aIntrinsicDirty</name></decl></param>,
                            <param><decl><type><name>nsFrameState</name></type> <name>aBitToAdd</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aBitToAdd</name> == <name>NS_FRAME_IS_DIRTY</name> ||
                  <name>aBitToAdd</name> == <name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>,
                  <argument><expr>"Unexpected bits being added"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mIsReflowing</name></expr></argument>, <argument><expr>"can't mark frame dirty during reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If we've not yet done the initial reflow, then don't bother</comment>
  <comment type="line">// enqueuing a reflow command yet.</comment>
  <if>if <condition>(<expr>! <name>mDidInitialReflow</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// If we're already destroying, don't bother with this either.</comment>
  <if>if <condition>(<expr><name>mIsDestroying</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <comment type="line">//printf("gShellCounter: %d\n", gShellCounter++);</comment>
  <if>if <condition>(<expr><name>mInVerifyReflow</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\nPresShell@%p: frame %p needs reflow\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>this</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_REALLY_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Current content model:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsIContent</name> *</type><name>rootContent</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetRootContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>rootContent</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>rootContent</name>-&gt;<name>List</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Grab |wasDirty| now so we can go ahead and update the bits on</comment>
  <comment type="line">// aFrame and then get |targetFrameDirty|.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>wasDirty</name> <init>= <expr><call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aFrame</name>-&gt;<name>AddStateBits</name></name><argument_list>(<argument><expr><name>aBitToAdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>targetFrameDirty</name> <init>= <expr>((<call><name><name>aFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_IS_DIRTY</name>) != 0)</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAME_IS_REFLOW_ROOT</name><parameter_list>(<param><type><name>_f</name></type></param>)</parameter_list></cpp:macro>                   \
  <cpp:value>((_f-&gt;GetStateBits() &amp; NS_FRAME_REFLOW_ROOT) &amp;&amp;  \
   (_f != aFrame || !targetFrameDirty))</cpp:value></cpp:define>


  <comment type="line">// Mark the intrinsic widths as dirty on the frame, all of its ancestors,</comment>
  <comment type="line">// and all of its descendants, if needed:</comment>

  <if>if <condition>(<expr><name>aIntrinsicDirty</name> != <name>eResize</name></expr>)</condition><then> <block>{
    <comment type="line">// Mark argument and all ancestors dirty. (Unless we hit a reflow root that</comment>
    <comment type="line">// should contain the reflow.  That root could be aFrame itself if it's not</comment>
    <comment type="line">// dirty, or it could be some ancestor of aFrame.)</comment>
    <for>for (<init><decl><type><name>nsIFrame</name> *</type><name>a</name> <init>= <expr><name>aFrame</name></expr></init></decl>;</init>
         <condition><expr><name>a</name> &amp;&amp; !<call><name>FRAME_IS_REFLOW_ROOT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>a</name> = <call><name><name>a</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></incr>)
      <expr_stmt><expr><call><name><name>a</name>-&gt;<name>MarkIntrinsicWidthsDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
  }</block></then></if>

  <if>if <condition>(<expr><name>aIntrinsicDirty</name> == <name>eStyleChange</name></expr>)</condition><then> <block>{
    <comment type="line">// Mark all descendants dirty (using an nsVoidArray stack rather than</comment>
    <comment type="line">// recursion).</comment>
    <decl_stmt><decl><type><name>nsVoidArray</name></type> <name>stack</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name><name>stack</name>.<name>Count</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>f</name> <init>=
        <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>stack</name>.<name>FastElementAt</name></name><argument_list>(<argument><expr><call><name><name>stack</name>.<name>Count</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>stack</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><call><name><name>stack</name>.<name>Count</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>PRInt32</name></type> <name>childListIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsIAtom</name> *</type><name>childListName</name></decl>;</decl_stmt>
      <do>do <block>{
        <expr_stmt><expr><name>childListName</name> = <call><name><name>f</name>-&gt;<name>GetAdditionalChildListName</name></name><argument_list>(<argument><expr><name>childListIndex</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>nsIFrame</name> *</type><name>kid</name> <init>= <expr><call><name><name>f</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>childListName</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>kid</name></expr>;</condition>
             <incr><expr><name>kid</name> = <call><name><name>kid</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
          <expr_stmt><expr><call><name><name>kid</name>-&gt;<name>MarkIntrinsicWidthsDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>kid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block> while <condition>(<expr><name>childListName</name></expr>)</condition>;</do>
    }</block></while>
  }</block></then></if>

  <comment type="line">// Set NS_FRAME_HAS_DIRTY_CHILDREN bits (via nsIFrame::ChildIsDirty) up the</comment>
  <comment type="line">// tree until we reach either a frame that's already dirty or a reflow root.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>f</name> <init>= <expr><name>aFrame</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr><call><name>FRAME_IS_REFLOW_ROOT</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> || !<call><name><name>f</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// we've hit a reflow root or the root frame</comment>
      <if>if <condition>(<expr>!<name>wasDirty</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mDirtyRoots</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <else>else <block>{
        <expr_stmt><expr><call><name>VerifyHasDirtyRootAncestor</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      
      <break>break;</break>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>child</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>f</name> = <call><name><name>f</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wasDirty</name> = <call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>f</name>-&gt;<name>ChildIsDirty</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>,
                 <argument><expr>"ChildIsDirty didn't do its job"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>wasDirty</name></expr>)</condition><then> <block>{
      <comment type="line">// This frame was already marked dirty.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><call><name>VerifyHasDirtyRootAncestor</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr><call><name>PostReflowEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsIScrollableView</name>*</type>
<name><name>PresShell</name>::<name>GetViewToScroll</name></name><parameter_list>(<param><decl><type><name><name>nsLayoutUtils</name>::<name>Direction</name></name></type> <name>aDirection</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEventStateManager</name></expr></argument>&gt;</argument_list></name></type> <name>esm</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollView</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>focusedContent</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>esm</name>-&gt;<name>GetFocusedContent</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedContent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>focusedContent</name> &amp;&amp; <name>mSelection</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsISelection</name>*</type> <name>domSelection</name> <init>= <expr><call><name><name>mSelection</name>-&gt;
      <name>GetSelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>domSelection</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>focusedNode</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>domSelection</name>-&gt;<name>GetFocusNode</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>focusedContent</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>focusedNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr><name>focusedContent</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>startFrame</name> <init>= <expr><call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>focusedContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>startFrame</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIScrollableViewProvider</name></expr></argument>&gt;</argument_list></name></type> <name>svp</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>startFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// If this very frame provides a scroll view, start there instead of frame's</comment>
      <comment type="line">// closest view, because the scroll view may be inside a child frame.</comment>
      <comment type="line">// For example, this happens in the case of overflow:scroll.</comment>
      <comment type="line">// In that case we still use GetNearestScrollingView() because</comment>
      <comment type="line">// we need a scrolling view that matches aDirection.</comment>
      <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>sv</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsIView</name>*</type> <name>startView</name> <init>= <expr><name>svp</name> &amp;&amp; (<name>sv</name> = <call><name><name>svp</name>-&gt;<name>GetScrollableView</name></name><argument_list>()</argument_list></call>) ? <call><name><name>sv</name>-&gt;<name>View</name></name><argument_list>()</argument_list></call> : <call><name><name>startFrame</name>-&gt;<name>GetClosestView</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>startView</name></expr></argument>, <argument><expr>"No view to start searching for scrollable view from"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>scrollView</name> = <call><name><name>nsLayoutUtils</name>::<name>GetNearestScrollingView</name></name><argument_list>(<argument><expr><name>startView</name></expr></argument>, <argument><expr><name>aDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>scrollView</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIViewManager</name>*</type> <name>viewManager</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>viewManager</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>viewManager</name>-&gt;<name>GetRootScrollableView</name></name><argument_list>(<argument><expr>&amp;<name>scrollView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>scrollView</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CancelAllPendingReflows</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mDirtyRoots</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
<function><type><name>void</name></type> <name><name>nsIPresShell</name>::<name>InvalidateAccessibleSubtree</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>gIsAccessibilityActive</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAccessibilityService</name></expr></argument>&gt;</argument_list></name></type> <name>accService</name> <init>= 
      <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/accessibilityService;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>accService</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>accService</name>-&gt;<name>InvalidateSubtreeFor</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aContent</name></expr></argument>,
                                       <argument><expr><name><name>nsIAccessibleEvent</name>::<name>EVENT_REORDER</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>RecreateFramesFor</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mDidInitialReflow</name></expr>)</condition><then> <block>{
    <comment type="line">// Nothing to do here.  In fact, if we proceed and aContent is the</comment>
    <comment type="line">// root we will crash.</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Don't call RecreateFramesForContent since that is not exported and we want</comment>
  <comment type="line">// to keep the number of entrypoints down.</comment>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mViewManager</name></expr></argument>, <argument><expr>"Should have view manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>BeginUpdateViewBatch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Have to make sure that the content notifications are flushed before we</comment>
  <comment type="line">// start messing with the frame model; otherwise we can get content doubling.</comment>
  <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_ContentAndNotify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsStyleChangeList</name></type> <name>changeList</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>changeList</name>.<name>AppendChange</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>nsChangeHint_ReconstructFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mFrameConstructor</name>-&gt;<name>ProcessRestyledFrames</name></name><argument_list>(<argument><expr><name>changeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>EndUpdateViewBatch</name></name><argument_list>(<argument><expr><name>NS_VMREFRESH_NO_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
  <expr_stmt><expr><call><name>InvalidateAccessibleSubtree</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ClearFrameRefs</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ClearFrameRefs</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr><name>aFrame</name> == <name>mCurrentEventFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCurrentEventContent</name> = <call><name><name>aFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>aFrame</name> == <name>mDrawEventTargetFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mDrawEventTargetFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name>&lt;<call><name><name>mCurrentEventFrameStack</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><name>aFrame</name> == (<name>nsIFrame</name>*)<call><name><name>mCurrentEventFrameStack</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">//One of our stack frames was deleted.  Get its content so that when we</comment>
      <comment type="line">//pop it we can still get its new frame from its content</comment>
      <decl_stmt><decl><type><name>nsIContent</name> *</type><name>currentEventContent</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>mCurrentEventContentStack</name>.<name>ReplaceObjectAt</name></name><argument_list>(<argument><expr><name>currentEventContent</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mCurrentEventFrameStack</name>.<name>ReplaceElementAt</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <decl_stmt><decl><type><name>nsWeakFrame</name>*</type> <name>weakFrame</name> <init>= <expr><name>mWeakFrames</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>weakFrame</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsWeakFrame</name>*</type> <name>prev</name> <init>= <expr><call><name><name>weakFrame</name>-&gt;<name>GetPreviousWeakFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>weakFrame</name>-&gt;<name>GetFrame</name></name><argument_list>()</argument_list></call> == <name>aFrame</name></expr>)</condition><then> <block>{
      <comment type="line">// This removes weakFrame from mWeakFrames.</comment>
      <expr_stmt><expr><call><name><name>weakFrame</name>-&gt;<name>Clear</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>weakFrame</name> = <name>prev</name></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CreateRenderingContext</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                                  <param><decl><type><name>nsIRenderingContext</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aResult</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>nsnull</name> == <name>aResult</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>widget</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mPresContext</name>-&gt;<name>IsScreen</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Get the widget to create the rendering context for and calculate</comment>
    <comment type="line">// the offset from the frame to it.  (Calculating the offset is important</comment>
    <comment type="line">// if the frame isn't the root frame.)</comment>
    <decl_stmt><decl><type><name>nsPoint</name></type> <name>viewOffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIView</name>*</type> <name>view</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetClosestView</name></name><argument_list>(<argument><expr>&amp;<name>viewOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsPoint</name></type> <name>widgetOffset</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>widget</name> = <call><name><name>view</name>-&gt;<name>GetNearestWidget</name></name><argument_list>(<argument><expr>&amp;<name>widgetOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = <name>viewOffset</name> + <name>widgetOffset</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>pageFrame</name> <init>= <expr><call><name><name>nsLayoutUtils</name>::<name>GetPageFrame</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// This might not always come up with a frame, i.e. during reflow;</comment>
    <comment type="line">// that's fine, because the translation doesn't matter during reflow.</comment>
    <if>if <condition>(<expr><name>pageFrame</name></expr>)</condition><then>
      <expr_stmt><expr><name>offset</name> = <call><name><name>aFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>pageFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></else></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIRenderingContext</name>*</type> <name>result</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIDeviceContext</name> *</type><name>deviceContext</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>DeviceContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>widget</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>deviceContext</name>-&gt;<name>CreateRenderingContext</name></name><argument_list>(<argument><expr><name>widget</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>deviceContext</name>-&gt;<name>CreateRenderingContext</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr>*<name>aResult</name> = <name>result</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>result</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><name><name>offset</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>offset</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GoToAnchor</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aAnchorName</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aScroll</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mDocument</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>
  
  <comment type="line">// Hold a reference to the ESM in case event dispatch tears us down.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEventStateManager</name></expr></argument>&gt;</argument_list></name></type> <name>esm</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name><name>aAnchorName</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aScroll</name></expr></argument>, <argument><expr>"can't scroll to empty anchor name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>esm</name>-&gt;<name>SetContentState</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>NS_EVENT_STATE_URLTARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>doc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMHTMLDocument</name></expr></argument>&gt;</argument_list></name></type> <name>htmlDoc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name></decl>;</decl_stmt>

  <comment type="line">// Search for an element with a matching "id" attribute</comment>
  <if>if <condition>(<expr><name>doc</name></expr>)</condition><then> <block>{    
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>element</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>doc</name>-&gt;<name>GetElementById</name></name><argument_list>(<argument><expr><name>aAnchorName</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>element</name></expr>)</condition><then> <block>{
      <comment type="line">// Get the nsIContent interface, because that's what we need to</comment>
      <comment type="line">// get the primary frame</comment>
      <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Search for an anchor element with a matching "name" attribute</comment>
  <if>if <condition>(<expr>!<name>content</name> &amp;&amp; <name>htmlDoc</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNodeList</name></expr></argument>&gt;</argument_list></name></type> <name>list</name></decl>;</decl_stmt>
    <comment type="line">// Find a matching list of named nodes</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>htmlDoc</name>-&gt;<name>GetElementsByName</name></name><argument_list>(<argument><expr><name>aAnchorName</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>list</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>;</decl_stmt>
      <comment type="line">// Loop through the named nodes looking for the first anchor</comment>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>PR_TRUE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>list</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>node</name></expr>)</condition><then> <block>{  <comment type="line">// End of list</comment>
          <break>break;</break>
        }</block></then></if>
        <comment type="line">// Ensure it's an anchor element</comment>
        <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>content</name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><call><name><name>content</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>a</name></name> &amp;&amp;
              <call><name><name>content</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eHTML</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <break>break;</break>
          }</block></then></if>
          <expr_stmt><expr><name>content</name> = <name>nsnull</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Search for anchor in the HTML namespace with a matching name</comment>
  <if>if <condition>(<expr>!<name>content</name> &amp;&amp; !<name>htmlDoc</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNodeList</name></expr></argument>&gt;</argument_list></name></type> <name>list</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_NAMED_LITERAL_STRING</name><argument_list>(<argument><expr><name>nameSpace</name></expr></argument>, <argument><expr>"http://www.w3.org/1999/xhtml"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Get the list of anchor elements</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>doc</name>-&gt;<name>GetElementsByTagNameNS</name></name><argument_list>(<argument><expr><name>nameSpace</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"a"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>list</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>;</decl_stmt>
      <comment type="line">// Loop through the named nodes looking for the first anchor</comment>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>PR_TRUE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>list</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>node</name></expr>)</condition><then> <block>{ <comment type="line">// End of list</comment>
          <break>break;</break>
        }</block></then></if>
        <comment type="line">// Compare the name attribute</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>element</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>value</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>element</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>element</name>-&gt;<name>GetAttribute</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"name"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><call><name><name>value</name>.<name>Equals</name></name><argument_list>(<argument><expr><name>aAnchorName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>jumpToRange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIXPointerResult</name></expr></argument>&gt;</argument_list></name></type> <name>xpointerResult</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMXMLDocument</name></expr></argument>&gt;</argument_list></name></type> <name>xmldoc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>xmldoc</name></expr>)</condition><then> <block>{
      <comment type="line">// Try XPointer</comment>
      <expr_stmt><expr><call><name><name>xmldoc</name>-&gt;<name>EvaluateXPointer</name></name><argument_list>(<argument><expr><name>aAnchorName</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>xpointerResult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>xpointerResult</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>xpointerResult</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>jumpToRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>jumpToRange</name></expr>)</condition><then> <block>{
          <comment type="line">// We know it was an XPointer, so there is no point in</comment>
          <comment type="line">// trying any other pointer types, let's just return</comment>
          <comment type="line">// an error.</comment>
          <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>

      <comment type="line">// Finally try FIXptr</comment>
      <if>if <condition>(<expr>!<name>jumpToRange</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>xmldoc</name>-&gt;<name>EvaluateFIXptr</name></name><argument_list>(<argument><expr><name>aAnchorName</name></expr></argument>,<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>jumpToRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <if>if <condition>(<expr><name>jumpToRange</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>jumpToRange</name>-&gt;<name>GetStartContainer</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>node</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRUint16</name></type> <name>nodeType</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>node</name>-&gt;<name>GetNodeType</name></name><argument_list>(<argument><expr>&amp;<name>nodeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>jumpToRange</name>-&gt;<name>GetStartOffset</name></name><argument_list>(<argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch <condition>(<expr><name>nodeType</name></expr>)</condition> <block>{
            <case>case <expr><name><name>nsIDOMNode</name>::<name>ATTRIBUTE_NODE</name></name></expr>:
            <block>{
              <comment type="line">// XXX Assuming jumping to the ownerElement is the sanest action.</comment>
              <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAttribute</name></expr></argument>&gt;</argument_list></name></type> <name>attr</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>content</name> = <call><name><name>attr</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>DOCUMENT_NODE</name></name></expr>:
            <block>{
              <if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocument</name></expr></argument>&gt;</argument_list></name></type> <name>document</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>content</name> = <call><name><name>document</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>
              <break>break;</break>
            }</block>
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>DOCUMENT_FRAGMENT_NODE</name></name></expr>:
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>ELEMENT_NODE</name></name></expr>:
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>ENTITY_REFERENCE_NODE</name></name></expr>:
            <block>{
              <if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>parent</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>content</name> = <call><name><name>parent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>
              <break>break;</break>
            }</block>
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>CDATA_SECTION_NODE</name></name></expr>:
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>COMMENT_NODE</name></name></expr>:
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>TEXT_NODE</name></name></expr>:
            </case><case>case <expr><name><name>nsIDOMNode</name>::<name>PROCESSING_INSTRUCTION_NODE</name></name></expr>:
            <block>{
              <comment type="line">// XXX This should scroll to a specific position in the text.</comment>
              <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
          </case>}</block></switch>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>esm</name>-&gt;<name>SetContentState</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>NS_EVENT_STATE_URLTARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>content</name></expr>)</condition><then> <block>{
    <comment type="line">// Flush notifications so we scroll to the right place</comment>
    <if>if <condition>(<expr><name>aScroll</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>ScrollContentIntoView</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>NS_PRESSHELL_SCROLL_TOP</name></expr></argument>,
                                 <argument><expr><name>NS_PRESSHELL_SCROLL_ANYWHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Should we select the target? This action is controlled by a</comment>
    <comment type="line">// preference: the default is to not select.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>selectAnchor</name> <init>= <expr><call><name><name>nsContentUtils</name>::<name>GetBoolPref</name></name><argument_list>(<argument><expr>"layout.selectanchor"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Even if select anchor pref is false, we must still move the</comment>
    <comment type="line">// caret there. That way tabbing will start from the new</comment>
    <comment type="line">// location</comment>
    <if>if <condition>(<expr>!<name>jumpToRange</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>jumpToRange</name> = <call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>kRangeCID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>jumpToRange</name></expr>)</condition><then> <block>{
        <while>while <condition>(<expr><name>content</name> &amp;&amp; <call><name><name>content</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition> <block>{
          <expr_stmt><expr><name>content</name> = <call><name><name>content</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr>"No nsIDOMNode for descendant of anchor"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>jumpToRange</name>-&gt;<name>SelectNodeContents</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>jumpToRange</name></expr>)</condition><then> <block>{
      <comment type="line">// Select the anchor</comment>
      <decl_stmt><decl><type><name>nsISelection</name>*</type> <name>sel</name> <init>= <expr><call><name><name>mSelection</name>-&gt;
        <name>GetSelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>sel</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>RemoveAllRanges</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>AddRange</name></name><argument_list>(<argument><expr><name>jumpToRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>selectAnchor</name></expr>)</condition><then> <block>{
          <comment type="line">// Use a caret (collapsed selection) at the start of the anchor</comment>
          <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>CollapseToStart</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>  

      <if>if <condition>(<expr><name>selectAnchor</name> &amp;&amp; <name>xpointerResult</name></expr>)</condition><then> <block>{
        <comment type="line">// Select the rest (if any) of the ranges in XPointerResult</comment>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>xpointerResult</name>-&gt;<name>GetLength</name></name><argument_list>(<argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{ <comment type="line">// jumpToRange is i = 0</comment>
          <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>xpointerResult</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>AddRange</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block></then></if>
      <comment type="line">// Selection is at anchor.</comment>
      <comment type="line">// Now focus the document itself if focus is on an element within it.</comment>
      <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>win</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>win</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFocusController</name></expr></argument>&gt;</argument_list></name></type> <name>focusController</name> <init>= <expr><call><name><name>win</name>-&gt;<name>GetRootFocusController</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>focusController</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMWindowInternal</name></expr></argument>&gt;</argument_list></name></type> <name>focusedWin</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>focusController</name>-&gt;<name>GetFocusedWindow</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedWin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>SameCOMIdentity</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name>focusedWin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>esm</name>-&gt;<name>ChangeFocusWith</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>nsIEventStateManager</name>::<name>eEventFocusedByApplication</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_FAILURE</name></expr>;</expr_stmt> <comment type="line">//changed to NS_OK in quirks mode if ScrollTo is called</comment>
    
    <comment type="line">// Scroll to the top/left if the anchor can not be</comment>
    <comment type="line">// found and it is labelled top (quirks mode only). @see bug 80784</comment>
    <if>if <condition>(<expr>(<call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>aAnchorName</name></expr></argument>)</argument_list></call>.<call><name>LowerCaseEqualsLiteral</name><argument_list>(<argument><expr>"top"</expr></argument>)</argument_list></call>) &amp;&amp;
        (<call><name><name>mPresContext</name>-&gt;<name>CompatibilityMode</name></name><argument_list>()</argument_list></call> == <name>eCompatibility_NavQuirks</name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
      <comment type="line">// Check |aScroll| after setting |rv| so we set |rv| to the same</comment>
      <comment type="line">// thing whether or not |aScroll| is true.</comment>
      <if>if <condition>(<expr><name>aScroll</name> &amp;&amp; <name>mViewManager</name></expr>)</condition><then> <block>{
        <comment type="line">// Get the viewport scroller</comment>
        <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollingView</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>GetRootScrollableView</name></name><argument_list>(<argument><expr>&amp;<name>scrollingView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>scrollingView</name></expr>)</condition><then> <block>{
          <comment type="line">// Scroll to the top of the page</comment>
          <expr_stmt><expr><call><name><name>scrollingView</name>-&gt;<name>ScrollTo</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NS_VMREFRESH_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * This function takes a scrolling view, a rect, and a scroll position and
 * attempts to scroll that rect to that position in that view.  The rect
 * should be in the coordinate system of the _scrolled_ view.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ScrollViewToShowRect</name><parameter_list>(<param><decl><type><name>nsIScrollableView</name>*</type> <name>aScrollingView</name></decl></param>,
                                 <param><decl><type><name>nsRect</name> &amp;</type>           <name>aRect</name></decl></param>,
                                 <param><decl><type><name>PRIntn</name></type>             <name>aVPercent</name></decl></param>,
                                 <param><decl><type><name>PRIntn</name></type>             <name>aHPercent</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Determine the visible rect in the scrolling view's coordinate space.</comment>
  <comment type="line">// The size of the visible area is the clip view size</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>visibleRect</name> <init>= <expr><call><name><name>aScrollingView</name>-&gt;<name>View</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetBounds</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// get width and height</comment>
  <expr_stmt><expr><call><name><name>aScrollingView</name>-&gt;<name>GetScrollPosition</name></name><argument_list>(<argument><expr><name><name>visibleRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>visibleRect</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// The actual scroll offsets</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>scrollOffsetX</name> <init>= <expr><name><name>visibleRect</name>.<name>x</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>scrollOffsetY</name> <init>= <expr><name><name>visibleRect</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>lineHeight</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aScrollingView</name>-&gt;<name>GetLineHeight</name></name><argument_list>(<argument><expr>&amp;<name>lineHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// See how the rect should be positioned vertically</comment>
  <if>if <condition>(<expr><name>NS_PRESSHELL_SCROLL_ANYWHERE</name> == <name>aVPercent</name> ||
      (<name>NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE</name> == <name>aVPercent</name> &amp;&amp;
       <name><name>aRect</name>.<name>height</name></name> &lt; <name>lineHeight</name>)</expr>)</condition><then> <block>{
    <comment type="line">// The caller doesn't care where the frame is positioned vertically,</comment>
    <comment type="line">// so long as it's fully visible</comment>
    <if>if <condition>(<expr><name><name>aRect</name>.<name>y</name></name> &lt; <name><name>visibleRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
      <comment type="line">// Scroll up so the frame's top edge is visible</comment>
      <expr_stmt><expr><name>scrollOffsetY</name> = <name><name>aRect</name>.<name>y</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>aRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>visibleRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Scroll down so the frame's bottom edge is visible. Make sure the</comment>
      <comment type="line">// frame's top edge is still visible</comment>
      <expr_stmt><expr><name>scrollOffsetY</name> += <call><name><name>aRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call> - <call><name><name>visibleRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>scrollOffsetY</name> &gt; <name><name>aRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>scrollOffsetY</name> = <name><name>aRect</name>.<name>y</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>
  }</block></then> <else>else <if>if <condition>(<expr><name>NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE</name> == <name>aVPercent</name></expr>)</condition><then> <block>{
    <comment type="line">// Scroll only if no part of the frame is visible in this view</comment>
    <if>if <condition>(<expr><call><name><name>aRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call> - <name>lineHeight</name> &lt; <name><name>visibleRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
      <comment type="line">// Scroll up so the frame's top edge is visible</comment>
      <expr_stmt><expr><name>scrollOffsetY</name> = <name><name>aRect</name>.<name>y</name></name></expr>;</expr_stmt>
    }</block></then>  <else>else <if>if <condition>(<expr><name><name>aRect</name>.<name>y</name></name> + <name>lineHeight</name> &gt; <call><name><name>visibleRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Scroll down so the frame's bottom edge is visible. Make sure the</comment>
      <comment type="line">// frame's top edge is still visible</comment>
      <expr_stmt><expr><name>scrollOffsetY</name> += <call><name><name>aRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call> - <call><name><name>visibleRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>scrollOffsetY</name> &gt; <name><name>aRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>scrollOffsetY</name> = <name><name>aRect</name>.<name>y</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>
  }</block></then> <else>else <block>{
    <comment type="line">// Align the frame edge according to the specified percentage</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>frameAlignY</name> <init>=
      <expr><call><name>NSToCoordRound</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>y</name></name> + <name><name>aRect</name>.<name>height</name></name> * (<name>aVPercent</name> / 100.0f)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>scrollOffsetY</name> =
      <call><name>NSToCoordRound</name><argument_list>(<argument><expr><name>frameAlignY</name> - <name><name>visibleRect</name>.<name>height</name></name> * (<name>aVPercent</name> / 100.0f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <comment type="line">// See how the frame should be positioned horizontally</comment>
  <if>if <condition>(<expr><name>NS_PRESSHELL_SCROLL_ANYWHERE</name> == <name>aHPercent</name> ||
      (<name>NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE</name> == <name>aHPercent</name> &amp;&amp;
       <name><name>aRect</name>.<name>width</name></name> &lt; <name>lineHeight</name>)</expr>)</condition><then> <block>{
    <comment type="line">// The caller doesn't care where the frame is positioned horizontally,</comment>
    <comment type="line">// so long as it's fully visible</comment>
    <if>if <condition>(<expr><name><name>aRect</name>.<name>x</name></name> &lt; <name><name>visibleRect</name>.<name>x</name></name></expr>)</condition><then> <block>{
      <comment type="line">// Scroll left so the frame's left edge is visible</comment>
      <expr_stmt><expr><name>scrollOffsetX</name> = <name><name>aRect</name>.<name>x</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>aRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>visibleRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Scroll right so the frame's right edge is visible. Make sure the</comment>
      <comment type="line">// frame's left edge is still visible</comment>
      <expr_stmt><expr><name>scrollOffsetX</name> += <call><name><name>aRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call> - <call><name><name>visibleRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>scrollOffsetX</name> &gt; <name><name>aRect</name>.<name>x</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>scrollOffsetX</name> = <name><name>aRect</name>.<name>x</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>
  }</block></then> <else>else <if>if <condition>(<expr><name>NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE</name> == <name>aHPercent</name></expr>)</condition><then> <block>{
    <comment type="line">// Scroll only if no part of the frame is visible in this view</comment>
    <comment type="line">// XXXbz using the line height here is odd, but there are no</comment>
    <comment type="line">// natural dimensions to use here, really....</comment>
    <if>if <condition>(<expr><call><name><name>aRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call> - <name>lineHeight</name> &lt; <name><name>visibleRect</name>.<name>x</name></name></expr>)</condition><then> <block>{
      <comment type="line">// Scroll left so the frame's left edge is visible</comment>
      <expr_stmt><expr><name>scrollOffsetX</name> = <name><name>aRect</name>.<name>x</name></name></expr>;</expr_stmt>
    }</block></then>  <else>else <if>if <condition>(<expr><name><name>aRect</name>.<name>x</name></name> + <name>lineHeight</name> &gt; <call><name><name>visibleRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Scroll right so the frame's right edge is visible. Make sure the</comment>
      <comment type="line">// frame's left edge is still visible</comment>
      <expr_stmt><expr><name>scrollOffsetX</name> += <call><name><name>aRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call> - <call><name><name>visibleRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>scrollOffsetX</name> &gt; <name><name>aRect</name>.<name>x</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>scrollOffsetX</name> = <name><name>aRect</name>.<name>x</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>
  }</block></then> <else>else <block>{
    <comment type="line">// Align the frame edge according to the specified percentage</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>frameAlignX</name> <init>=
      <expr><call><name>NSToCoordRound</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>x</name></name> + (<name><name>aRect</name>.<name>width</name></name>) * (<name>aHPercent</name> / 100.0f)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>scrollOffsetX</name> =
      <call><name>NSToCoordRound</name><argument_list>(<argument><expr><name>frameAlignX</name> - <name><name>visibleRect</name>.<name>width</name></name> * (<name>aHPercent</name> / 100.0f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <expr_stmt><expr><call><name><name>aScrollingView</name>-&gt;<name>ScrollTo</name></name><argument_list>(<argument><expr><name>scrollOffsetX</name></expr></argument>, <argument><expr><name>scrollOffsetY</name></expr></argument>,
                           <argument><expr><name>NS_VMREFRESH_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ScrollContentIntoView</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                 <param><decl><type><name>PRIntn</name></type>      <name>aVPercent</name></decl></param>,
                                 <param><decl><type><name>PRIntn</name></type>      <name>aHPercent</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><name>aContent</name></expr></init></decl>;</decl_stmt> <comment type="line">// Keep content alive while flushing.</comment>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>NS_ERROR_NULL_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocument</name></expr></argument>&gt;</argument_list></name></type> <name>currentDoc</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>currentDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>currentDoc</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Before we scroll the frame into view, ask the command dispatcher</comment>
  <comment type="line">// if we're resetting focus because a window just got an activate</comment>
  <comment type="line">// event. If we are, we do not want to scroll the frame into view.</comment>
  <comment type="line">// Example: The user clicks on an anchor, and then deactivates the </comment>
  <comment type="line">// window. When they reactivate the window, the expected behavior</comment>
  <comment type="line">// is not for the anchor link to scroll back into view. That is what</comment>
  <comment type="line">// this check is preventing.</comment>
  <comment type="line">// XXX: The dependency on the command dispatcher needs to be fixed.</comment>
  <decl_stmt><decl><type><name>nsPIDOMWindow</name>*</type> <name>ourWindow</name> <init>= <expr><call><name><name>currentDoc</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>ourWindow</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFocusController</name> *</type><name>focusController</name> <init>= <expr><call><name><name>ourWindow</name>-&gt;<name>GetRootFocusController</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>focusController</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>dontScroll</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>focusController</name>-&gt;<name>GetSuppressFocusScroll</name></name><argument_list>(<argument><expr>&amp;<name>dontScroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>(<expr><name>dontScroll</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// This is a two-step process.</comment>
  <comment type="line">// Step 1: Find the bounds of the rect we want to scroll into view.  For</comment>
  <comment type="line">//         example, for an inline frame we may want to scroll in the whole</comment>
  <comment type="line">//         line.</comment>
  <comment type="line">// Step 2: Walk the views that are parents of the frame and scroll them</comment>
  <comment type="line">//         appropriately.</comment>
  
  <decl_stmt><decl><type><name>nsRect</name></type>  <name>frameBounds</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIView</name>*</type> <name>closestView</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>GetOffsetFromView</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr>&amp;<name>closestView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>frameBounds</name>.<name>MoveTo</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If this is an inline frame and either the bounds height is 0 (quirks</comment>
  <comment type="line">// layout model) or aVPercent is not NS_PRESSHELL_SCROLL_ANYWHERE, we need to</comment>
  <comment type="line">// change the top of the bounds to include the whole line.</comment>
  <if>if <condition>(<expr><name><name>frameBounds</name>.<name>height</name></name> == 0 || <name>aVPercent</name> != <name>NS_PRESSHELL_SCROLL_ANYWHERE</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>frameType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>prevFrame</name> <init>= <expr><name>frame</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>f</name> <init>= <expr><name>frame</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>f</name> &amp;&amp;
           (<name>frameType</name> = <call><name><name>f</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call>) == <name><name>nsGkAtoms</name>::<name>inlineFrame</name></name></expr>)</condition> <block>{
      <expr_stmt><expr><name>prevFrame</name> = <name>f</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>f</name> = <call><name><name>prevFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>f</name> != <name>frame</name> &amp;&amp;
        <name>f</name> &amp;&amp;
        <name>frameType</name> == <name><name>nsGkAtoms</name>::<name>blockFrame</name></name></expr>)</condition><then> <block>{
      <comment type="line">// find the line containing aFrame and increase the top of |offset|.</comment>
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILineIterator</name></expr></argument>&gt;</argument_list></name></type> <name>lines</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>lines</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lines</name>-&gt;<name>FindLineContaining</name></name><argument_list>(<argument><expr><name>prevFrame</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>trash1</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>trash2</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsRect</name></type> <name>lineBounds</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRUint32</name></type> <name>trash3</name></decl>;</decl_stmt>

          <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>lines</name>-&gt;<name>GetLine</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr>&amp;<name>trash1</name></expr></argument>, <argument><expr>&amp;<name>trash2</name></expr></argument>,
                                          <argument><expr><name>lineBounds</name></expr></argument>, <argument><expr>&amp;<name>trash3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsPoint</name></type> <name>blockOffset</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsIView</name>*</type> <name>blockView</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>f</name>-&gt;<name>GetOffsetFromView</name></name><argument_list>(<argument><expr><name>blockOffset</name></expr></argument>, <argument><expr>&amp;<name>blockView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>blockView</name> == <name>closestView</name></expr>)</condition><then> <block>{
              <comment type="line">// XXX If views not equal, this is hard.  Do we want to bother?</comment>
              <decl_stmt><decl><type><name>nscoord</name></type> <name>newoffset</name> <init>= <expr><name><name>lineBounds</name>.<name>y</name></name> + <name><name>blockOffset</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr><name>newoffset</name> &lt; <name><name>frameBounds</name>.<name>y</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>frameBounds</name>.<name>y</name></name> = <name>newoffset</name></expr>;</expr_stmt></then></if>
            }</block></then></if>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>closestView</name> &amp;&amp; !<call><name><name>closestView</name>-&gt;<name>ToScrollableView</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"What happened to the scrolled view?  "
               "The frame should not be directly in the scrolling view!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Walk up the view hierarchy.  Make sure to add the view's position</comment>
  <comment type="line">// _after_ we get the parent and see whether it's scrollable.  We want to</comment>
  <comment type="line">// make sure to get the scrolled view's position after it has been scrolled.</comment>
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollingView</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>closestView</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsIView</name>*</type> <name>parent</name> <init>= <expr><call><name><name>closestView</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>scrollingView</name> = <call><name><name>parent</name>-&gt;<name>ToScrollableView</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>scrollingView</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ScrollViewToShowRect</name><argument_list>(<argument><expr><name>scrollingView</name></expr></argument>, <argument><expr><name>frameBounds</name></expr></argument>, <argument><expr><name>aVPercent</name></expr></argument>, <argument><expr><name>aHPercent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>frameBounds</name> += <call><name><name>closestView</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><name>closestView</name> = <name>parent</name></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// GetLinkLocation: copy link location to clipboard</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>PresShell</name>::<name>GetLinkLocation</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aNode</name></decl></param>, <param><decl><type><name>nsAString</name>&amp;</type> <name>aLocationString</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_dr</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"dr :: PresShell::GetLinkLocation\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>anchorText</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>strippedChars</name><index>[]</index></name> <init>= <expr><block>{<expr>'\t'</expr>,<expr>'\r'</expr>,<expr>'\n'</expr>}</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// are we an anchor?</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMHTMLAnchorElement</name></expr></argument>&gt;</argument_list></name></type> <name>anchor</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMHTMLAreaElement</name></expr></argument>&gt;</argument_list></name></type> <name>area</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMHTMLLinkElement</name></expr></argument>&gt;</argument_list></name></type> <name>link</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>xlinkType</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>anchor</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>anchor</name>-&gt;<name>GetHref</name></name><argument_list>(<argument><expr><name>anchorText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// area?</comment>
    <expr_stmt><expr><name>area</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>area</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name><name>area</name>-&gt;<name>GetHref</name></name><argument_list>(<argument><expr><name>anchorText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// link?</comment>
      <expr_stmt><expr><name>link</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>link</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>link</name>-&gt;<name>GetHref</name></name><argument_list>(<argument><expr><name>anchorText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <comment type="line">// Xlink?</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>element</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>element</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>NS_NAMED_LITERAL_STRING</name><argument_list>(<argument><expr><name>xlinkNS</name></expr></argument>,<argument><expr>"http://www.w3.org/1999/xlink"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>element</name>-&gt;<name>GetAttributeNS</name></name><argument_list>(<argument><expr><name>xlinkNS</name></expr></argument>,<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"type"</expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>xlinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name><name>xlinkType</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"simple"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>element</name>-&gt;<name>GetAttributeNS</name></name><argument_list>(<argument><expr><name>xlinkNS</name></expr></argument>,<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"href"</expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>anchorText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>anchorText</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
              <comment type="line">// Resolve the full URI using baseURI property</comment>

              <decl_stmt><decl><type><name>nsAutoString</name></type> <name>base</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOM3Node</name></expr></argument>&gt;</argument_list></name></type> <name>node</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>,<argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>node</name>-&gt;<name>GetBaseURI</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIIOService</name></expr></argument>&gt;</argument_list></name></type>
                <name>ios</name><argument_list>(<argument><expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/network/io-service;1"</expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>baseURI</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>rv</name> = <call><name><name>ios</name>-&gt;<name>NewURI</name></name><argument_list>(<argument><expr><call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nsnull</name></expr></argument>,<argument><expr><name>nsnull</name></expr></argument>,<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>baseURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>spec</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>rv</name> = <call><name><name>baseURI</name>-&gt;<name>Resolve</name></name><argument_list>(<argument><expr><call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>anchorText</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>CopyUTF8toUTF16</name><argument_list>(<argument><expr><name>spec</name></expr></argument>, <argument><expr><name>anchorText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></then></if>
        }</block></then></if>
      }</block></else></if>
    }</block></else></if>
  }</block></else></if>

  <if>if <condition>(<expr><name>anchor</name> || <name>area</name> || <name>link</name> || <call><name><name>xlinkType</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"simple"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">//Remove all the '\t', '\r' and '\n' from 'anchorText'</comment>
    <expr_stmt><expr><call><name><name>anchorText</name>.<name>StripChars</name></name><argument_list>(<argument><expr><name>strippedChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>aLocationString</name> = <name>anchorText</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// if no link, fail.</comment>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetSelectionForCopy</name></name><parameter_list>(<param><decl><type><name>nsISelection</name>**</type> <name>outSelection</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>outSelection</name> = <name>nsnull</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mDocument</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>ourWindow</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>ourWindow</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFocusController</name> *</type><name>focusController</name> <init>= <expr><call><name><name>ourWindow</name>-&gt;<name>GetRootFocusController</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>focusController</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>focusedElement</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>focusController</name>-&gt;<name>GetFocusedElement</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>focusedElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelection</name></expr></argument>&gt;</argument_list></name></type> <name>sel</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>content</name></expr>)</condition><then>
  <block>{
    <comment type="line">//check to see if we need to get selection from frame</comment>
    <comment type="line">//optimization that MAY need to be expanded as more things implement their own "selection"</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNSHTMLInputElement</name></expr></argument>&gt;</argument_list></name></type>    <name>htmlInputElement</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNSHTMLTextAreaElement</name></expr></argument>&gt;</argument_list></name></type> <name>htmlTextAreaElement</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>htmlInputElement</name> || <name>htmlTextAreaElement</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>htmlInputFrame</name> <init>= <expr><call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>htmlInputFrame</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelectionController</name></expr></argument>&gt;</argument_list></name></type> <name>selCon</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rv</name> = <call><name><name>htmlInputFrame</name>-&gt;
        <name>GetSelectionController</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>,<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>selCon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
      <if>if <condition>(<expr>!<name>selCon</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

      <expr_stmt><expr><name>rv</name> = <call><name><name>selCon</name>-&gt;<name>GetSelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>,
                                <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>sel</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>sel</name> = <call><name><name>mSelection</name>-&gt;<name>GetSelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr>*<name>outSelection</name> = <name>sel</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>outSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>


<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>DoGetContents</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name>&amp;</type> <name>aMimeType</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aSelectionOnly</name></decl></param>, <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutValue</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aOutValue</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr>!<name>mDocument</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelection</name></expr></argument>&gt;</argument_list></name></type> <name>sel</name></decl>;</decl_stmt>

  <comment type="line">// Now we have the selection.  Make sure it's nonzero:</comment>
  <if>if <condition>(<expr><name>aSelectionOnly</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>rv</name> = <call><name>GetSelectionForCopy</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<name>sel</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  
    <decl_stmt><decl><type><name>PRBool</name></type> <name>isCollapsed</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>GetIsCollapsed</name></name><argument_list>(<argument><expr>&amp;<name>isCollapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>isCollapsed</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  }</block></then></if>
  
  <comment type="line">// call the copy code</comment>
  <return>return <expr><call><name><name>nsCopySupport</name>::<name>GetContents</name></name><argument_list>(<argument><expr><name>aMimeType</name></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>,
                                    <argument><expr><name>mDocument</name></expr></argument>, <argument><expr><name>aOutValue</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>DoCopy</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mDocument</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelection</name></expr></argument>&gt;</argument_list></name></type> <name>sel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetSelectionForCopy</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
    <return>return <expr><name>rv</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name>sel</name></expr>)</condition><then> 
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">// Now we have the selection.  Make sure it's nonzero:</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isCollapsed</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>GetIsCollapsed</name></name><argument_list>(<argument><expr>&amp;<name>isCollapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>isCollapsed</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// call the copy code</comment>
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsCopySupport</name>::<name>HTMLCopy</name></name><argument_list>(<argument><expr><name>sel</name></expr></argument>, <argument><expr><name>mDocument</name></expr></argument>, <argument><expr><name><name>nsIClipboard</name>::<name>kGlobalClipboard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <comment type="line">// Now that we have copied, update the Paste menu item</comment>
  <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>domWindow</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>domWindow</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>domWindow</name>-&gt;<name>UpdateCommands</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"clipboard"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CaptureHistoryState</name></name><parameter_list>(<param><decl><type><name>nsILayoutHistoryState</name>**</type> <name>aState</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aLeavingPage</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aState</name></expr></argument>, <argument><expr>"null state pointer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// We actually have to mess with the docshell here, since we want to</comment>
  <comment type="line">// store the state back in it.</comment>
  <comment type="line">// XXXbz this isn't really right, since this is being called in the</comment>
  <comment type="line">// content viewer's Hide() method...  by that point the docshell's</comment>
  <comment type="line">// state could be wrong.  We should sort out a better ownership</comment>
  <comment type="line">// model for the layout history state.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>container</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>docShell</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>docShell</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILayoutHistoryState</name></expr></argument>&gt;</argument_list></name></type> <name>historyState</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>docShell</name>-&gt;<name>GetLayoutHistoryState</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>historyState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>historyState</name></expr>)</condition><then> <block>{
    <comment type="line">// Create the document state object</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>NS_NewLayoutHistoryState</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>historyState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
      <expr_stmt><expr>*<name>aState</name> = <name>nsnull</name></expr>;</expr_stmt>
      <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>    

    <expr_stmt><expr><call><name><name>docShell</name>-&gt;<name>SetLayoutHistoryState</name></name><argument_list>(<argument><expr><name>historyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr>*<name>aState</name> = <name>historyState</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Capture frame state for the entire frame hierarchy</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rootFrame</name></expr>)</condition><then> <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <comment type="line">// Capture frame state for the root scroll frame</comment>
  <comment type="line">// Don't capture state when first creating doc element hierarchy</comment>
  <comment type="line">// As the scroll position is 0 and this will cause us to loose</comment>
  <comment type="line">// our previously saved place!</comment>
  <if>if <condition>(<expr><name>aLeavingPage</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>scrollFrame</name> <init>= <expr><call><name>GetRootScrollFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>scrollFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>CaptureFrameStateFor</name><argument_list>(<argument><expr><name>scrollFrame</name></expr></argument>, <argument><expr><name>historyState</name></expr></argument>,
                                           <argument><expr><name><name>nsIStatefulFrame</name>::<name>eDocumentScrollState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>CaptureFrameState</name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><name>historyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
 
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>IsPaintingSuppressed</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aResult</name> = <name>mPaintingSuppressed</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>UnsuppressAndInvalidate</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name><name>mPresContext</name>-&gt;<name>EnsureVisible</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// No point; we're about to be torn down anyway.</comment>
    <return>return;</return>
  }</block></then></if>
  
  <expr_stmt><expr><name>mPaintingSuppressed</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rootFrame</name></expr>)</condition><then> <block>{
    <comment type="line">// let's assume that outline on a root frame is not supported</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>rect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>rootFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>rootFrame</name>-&gt;<name>Invalidate</name></name><argument_list>(<argument><expr><name>rect</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// This makes sure to get the same thing that nsPresContext::EnsureVisible()</comment>
  <comment type="line">// got.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsPIDOMWindow</name></expr></argument>&gt;</argument_list></name></type> <name>ourWindow</name> <init>= <expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFocusController</name></expr></argument>&gt;</argument_list></name></type> <name>focusController</name> <init>=
    <expr><name>ourWindow</name> ? <call><name><name>ourWindow</name>-&gt;<name>GetRootFocusController</name></name><argument_list>()</argument_list></call> : <name>nsnull</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>ourWindow</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>CheckForFocus</name><argument_list>(<argument><expr><name>ourWindow</name></expr></argument>, <argument><expr><name>focusController</name></expr></argument>, <argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>focusController</name></expr>)</condition><then> <comment type="line">// Unsuppress now that we've shown the new window and focused it.</comment>
    <expr_stmt><expr><call><name><name>focusController</name>-&gt;<name>SetSuppressFocus</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"PresShell suppression on Web page loads"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>mViewManager</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>SynthesizeMouseMove</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  
  <comment type="line">// If there is no selection, create a collapsed selection at the top of the document. </comment>
  <if>if <condition>(<expr><name>mSelection</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsISelection</name>*</type> <name>domSelection</name> <init>= <expr><call><name><name>mSelection</name>-&gt;
      <name>GetSelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>domSelection</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>rangeCount</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>domSelection</name>-&gt;<name>GetRangeCount</name></name><argument_list>(<argument><expr>&amp;<name>rangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>rangeCount</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>CompleteMoveInner</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>UnsuppressPainting</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mPaintSuppressionTimer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mPaintSuppressionTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mPaintSuppressionTimer</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mIsDocumentGone</name> || !<name>mPaintingSuppressed</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// If we have reflows pending, just wait until we process</comment>
  <comment type="line">// the reflows and get all the frames where we want them</comment>
  <comment type="line">// before actually unlocking the painting.  Otherwise</comment>
  <comment type="line">// go ahead and unlock now.</comment>
  <if>if <condition>(<expr><call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><name>mShouldUnsuppressPainting</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>UnsuppressAndInvalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>DisableThemeSupport</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// Doesn't have to be dynamic.  Just set the bool.</comment>
  <expr_stmt><expr><name>mIsThemeSupportDisabled</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> 
<name><name>PresShell</name>::<name>IsThemeSupportEnabled</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>!<name>mIsThemeSupportDisabled</name></expr>;</return>
}</block></function>

<comment type="line">// Post a request to handle an arbitrary callback after reflow has finished.</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>PostReflowCallback</name></name><parameter_list>(<param><decl><type><name>nsIReflowCallback</name>*</type> <name>aCallback</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name>*</type> <name>result</name> <init>= <expr><call><name>AllocateFrame</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsCallbackEventRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_UNLIKELY</name><argument_list>(<argument><expr>!<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>request</name> <init>= <expr>(<name>nsCallbackEventRequest</name>*)<name>result</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>request</name>-&gt;<name>callback</name></name> = <name>aCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>request</name>-&gt;<name>next</name></name> = <name>nsnull</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mLastCallbackEventRequest</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mLastCallbackEventRequest</name> = <name><name>mLastCallbackEventRequest</name>-&gt;<name>next</name></name> = <name>request</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>mFirstCallbackEventRequest</name> = <name>request</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mLastCallbackEventRequest</name> = <name>request</name></expr>;</expr_stmt>
  }</block></else></if>
 
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CancelReflowCallback</name></name><parameter_list>(<param><decl><type><name>nsIReflowCallback</name>*</type> <name>aCallback</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>before</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>node</name> <init>= <expr><name>mFirstCallbackEventRequest</name></expr></init></decl>;</decl_stmt>
   <while>while<condition>(<expr><name>node</name></expr>)</condition>
   <block>{
      <decl_stmt><decl><type><name>nsIReflowCallback</name>*</type> <name>callback</name> <init>= <expr><name><name>node</name>-&gt;<name>callback</name></name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>callback</name> == <name>aCallback</name></expr>)</condition><then> 
      <block>{
        <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>toFree</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>node</name> == <name>mFirstCallbackEventRequest</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>mFirstCallbackEventRequest</name> = <name>node</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>before</name> == <name>nsnull</name></expr></argument>, <argument><expr>"impossible"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>before</name>-&gt;<name>next</name></name> = <name>node</name></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>toFree</name> == <name>mLastCallbackEventRequest</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>mLastCallbackEventRequest</name> = <name>before</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>FreeFrame</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsCallbackEventRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>toFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name>before</name> = <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
      }</block></else></if>
   }</block></while>

   <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>HandlePostedReflowCallbacks</name></name><parameter_list>()</parameter_list>
<block>{
   <decl_stmt><decl><type><name>PRBool</name></type> <name>shouldFlush</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

   <while>while <condition>(<expr><name>mFirstCallbackEventRequest</name></expr>)</condition> <block>{
     <decl_stmt><decl><type><name>nsCallbackEventRequest</name>*</type> <name>node</name> <init>= <expr><name>mFirstCallbackEventRequest</name></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><name>mFirstCallbackEventRequest</name> = <name><name>node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
     <if>if <condition>(<expr>!<name>mFirstCallbackEventRequest</name></expr>)</condition><then> <block>{
       <expr_stmt><expr><name>mLastCallbackEventRequest</name> = <name>nsnull</name></expr>;</expr_stmt>
     }</block></then></if>
     <decl_stmt><decl><type><name>nsIReflowCallback</name>*</type> <name>callback</name> <init>= <expr><name><name>node</name>-&gt;<name>callback</name></name></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>FreeFrame</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsCallbackEventRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <if>if <condition>(<expr><name>callback</name></expr>)</condition><then> <block>{
       <if>if <condition>(<expr><call><name><name>callback</name>-&gt;<name>ReflowFinished</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
         <expr_stmt><expr><name>shouldFlush</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
       }</block></then></if>
     }</block></then></if>
   }</block></while>

   <if>if <condition>(<expr><name>shouldFlush</name></expr>)</condition><then>
     <expr_stmt><expr><call><name>FlushPendingNotifications</name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>IsSafeToFlush</name></name><parameter_list>(<param><decl><type><name>PRBool</name>&amp;</type> <name>aIsSafeToFlush</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>aIsSafeToFlush</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mIsReflowing</name> || <name>mChangeNestCount</name></expr>)</condition><then> <block>{
    <comment type="line">// Not safe if we are reflowing or in the middle of frame construction</comment>
    <expr_stmt><expr><name>aIsSafeToFlush</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Not safe if we are painting</comment>
    <decl_stmt><decl><type><name>nsIViewManager</name>*</type> <name>viewManager</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>viewManager</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>isPainting</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>viewManager</name>-&gt;<name>IsPainting</name></name><argument_list>(<argument><expr><name>isPainting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>isPainting</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>aIsSafeToFlush</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>PresShell</name>::<name>FlushPendingNotifications</name></name><parameter_list>(<param><decl><type><name>mozFlushType</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aType</name> &amp; (<name>Flush_StyleReresolves</name> | <name>Flush_OnlyReflow</name> |
                        <name>Flush_OnlyPaint</name>)</expr></argument>,
               <argument><expr>"Why did we get called?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isSafeToFlush</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>IsSafeToFlush</name><argument_list>(<argument><expr><name>isSafeToFlush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>isSafeToFlush</name> || <name>mViewManager</name></expr></argument>, <argument><expr>"Must have view manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>isSafeToFlush</name> &amp;&amp; <name>mViewManager</name></expr>)</condition><then> <block>{
    <comment type="line">// Processing pending notifications can kill us, and some callers only</comment>
    <comment type="line">// hold weak refs when calling FlushPendingNotifications().  :(</comment>
    <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// Style reresolves not in conjunction with reflows can't cause</comment>
    <comment type="line">// painting or geometry changes, so don't bother with view update</comment>
    <comment type="line">// batching if we only have style reresolve</comment>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>BeginUpdateViewBatch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aType</name> &amp; <name>Flush_StyleReresolves</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ProcessPendingRestyles</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mIsDestroying</name></expr>)</condition><then> <block>{
        <comment type="line">// We no longer have a view manager and all that.</comment>
        <comment type="line">// XXX FIXME: Except we're in the middle of a view update batch...  We</comment>
        <comment type="line">// need to address that somehow.  See bug 369165.</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>aType</name> &amp; <name>Flush_OnlyReflow</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>RecalcQuotesAndCounters</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ProcessReflowCommands</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mIsDestroying</name></expr>)</condition><then> <block>{
        <comment type="line">// We no longer have a view manager and all that.</comment>
        <comment type="line">// XXX FIXME: Except we're in the middle of a view update batch...  We</comment>
        <comment type="line">// need to address that somehow.  See bug 369165.</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>updateFlags</name> <init>= <expr><name>NS_VMREFRESH_NO_SYNC</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aType</name> &amp; <name>Flush_OnlyPaint</name></expr>)</condition><then> <block>{
      <comment type="line">// Flushing paints, so perform the invalidates and drawing</comment>
      <comment type="line">// immediately</comment>
      <expr_stmt><expr><name>updateFlags</name> = <name>NS_VMREFRESH_IMMEDIATE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!(<name>aType</name> &amp; <name>Flush_OnlyReflow</name>)</expr>)</condition><then> <block>{
      <comment type="line">// Not flushing reflows, so do deferred invalidates.  This will keep us</comment>
      <comment type="line">// from possibly flushing out reflows due to invalidates being processed</comment>
      <comment type="line">// at the end of this view batch.</comment>
      <expr_stmt><expr><name>updateFlags</name> = <name>NS_VMREFRESH_DEFERRED</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>EndUpdateViewBatch</name></name><argument_list>(<argument><expr><name>updateFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>IsReflowLocked</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aIsReflowLocked</name></decl></param>)</parameter_list> 
<block>{
  <expr_stmt><expr>*<name>aIsReflowLocked</name> = <name>mIsReflowing</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>CharacterDataChanged</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                                <param><decl><type><name>nsIContent</name>*</type>  <name>aContent</name></decl></param>,
                                <param><decl><type><name>CharacterDataChangeInfo</name>*</type> <name>aInfo</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsDocumentGone</name></expr></argument>, <argument><expr>"Unexpected CharacterDataChanged"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Unexpected aDocument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then> <block>{
    <comment type="line">// Invalidate the caret's current location before we call into the frame</comment>
    <comment type="line">// constructor. It is important to do this now, and not wait until the</comment>
    <comment type="line">// resulting reflow, because this call causes continuation frames of the</comment>
    <comment type="line">// text frame the caret is in to forget what part of the content they</comment>
    <comment type="line">// refer to, making it hard for them to return the correct continuation</comment>
    <comment type="line">// frame to the caret.</comment>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>InvalidateOutsideCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>CharacterDataChanged</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name><name>aInfo</name>-&gt;<name>mAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ContentStatesChanged</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                                <param><decl><type><name>nsIContent</name>*</type> <name>aContent1</name></decl></param>,
                                <param><decl><type><name>nsIContent</name>*</type> <name>aContent2</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aStateMask</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsDocumentGone</name></expr></argument>, <argument><expr>"Unexpected ContentStatesChanged"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Unexpected aDocument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ContentStatesChanged</name></name><argument_list>(<argument><expr><name>aContent1</name></expr></argument>, <argument><expr><name>aContent2</name></expr></argument>, <argument><expr><name>aStateMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>AttributeChanged</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                            <param><decl><type><name>nsIContent</name>*</type>  <name>aContent</name></decl></param>,
                            <param><decl><type><name>PRInt32</name></type>      <name>aNameSpaceID</name></decl></param>,
                            <param><decl><type><name>nsIAtom</name>*</type>     <name>aAttribute</name></decl></param>,
                            <param><decl><type><name>PRInt32</name></type>      <name>aModType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsDocumentGone</name></expr></argument>, <argument><expr>"Unexpected AttributeChanged"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Unexpected aDocument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXXwaterson it might be more elegant to wait until after the</comment>
  <comment type="line">// initial reflow to begin observing the document. That would</comment>
  <comment type="line">// squelch any other inappropriate notifications as well.</comment>
  <if>if <condition>(<expr><name>mDidInitialReflow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>AttributeChanged</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aNameSpaceID</name></expr></argument>,
                                        <argument><expr><name>aAttribute</name></expr></argument>, <argument><expr><name>aModType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ContentAppended</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                           <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                           <param><decl><type><name>PRInt32</name></type>     <name>aNewIndexInContainer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsDocumentGone</name></expr></argument>, <argument><expr>"Unexpected ContentAppended"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Unexpected aDocument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr>!<name>mDidInitialReflow</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Start: Frame Creation: PresShell::ContentAppended(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_START</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ContentAppended</name></name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>, <argument><expr><name>aNewIndexInContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Stop: Frame Creation: PresShell::ContentAppended(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_STOP</name><argument_list>(<argument><expr><name>mFrameCreationWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ContentInserted</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>,
                           <param><decl><type><name>nsIContent</name>*</type>  <name>aContainer</name></decl></param>,
                           <param><decl><type><name>nsIContent</name>*</type>  <name>aChild</name></decl></param>,
                           <param><decl><type><name>PRInt32</name></type>      <name>aIndexInContainer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsDocumentGone</name></expr></argument>, <argument><expr>"Unexpected ContentInserted"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Unexpected aDocument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mDidInitialReflow</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ContentInserted</name></name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>, <argument><expr><name>aChild</name></expr></argument>,
                                     <argument><expr><name>aIndexInContainer</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ContentRemoved</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                          <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                          <param><decl><type><name>nsIContent</name>*</type> <name>aChild</name></decl></param>,
                          <param><decl><type><name>PRInt32</name></type>     <name>aIndexInContainer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsDocumentGone</name></expr></argument>, <argument><expr>"Unexpected ContentRemoved"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <name>mDocument</name></expr></argument>, <argument><expr>"Unexpected aDocument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Make sure that the caret doesn't leave a turd where the child used to be.</comment>
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>InvalidateOutsideCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Notify the ESM that the content has been removed, so that</comment>
  <comment type="line">// it can clean up any state related to the content.</comment>
  <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ContentRemoved</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ContentRemoved</name></name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>, <argument><expr><name>aChild</name></expr></argument>,
                                    <argument><expr><name>aIndexInContainer</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>ReconstructFrames</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
          
  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>mFrameConstructor</name>-&gt;<name>ReconstructDocElementHierarchy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIPresShell</name>::<name>ReconstructStyleDataInternal</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mDidInitialReflow</name></expr>)</condition><then> <block>{
    <comment type="line">// Nothing to do here, since we have no frames yet</comment>
    <return>return;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>mIsDestroying</name></expr>)</condition><then> <block>{
    <comment type="line">// We don't want to mess with restyles at this point</comment>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>root</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetRootContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>root</name></expr>)</condition><then> <block>{
    <comment type="line">// No content to restyle</comment>
    <return>return;</return>
  }</block></then></if>
  
  <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>PostRestyleEvent</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>eReStyle_Self</name></expr></argument>, <argument><expr><name>NS_STYLE_HINT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
  <expr_stmt><expr><call><name>InvalidateAccessibleSubtree</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIPresShell</name>::<name>ReconstructStyleDataExternal</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>ReconstructStyleDataInternal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>StyleSheetAdded</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                           <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                           <param><decl><type><name>PRBool</name></type> <name>aDocumentSheet</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// We only care when enabled sheets are added</comment>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aStyleSheet</name></expr></argument>, <argument><expr>"Must have a style sheet!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>applicable</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aStyleSheet</name>-&gt;<name>GetApplicable</name></name><argument_list>(<argument><expr><name>applicable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>applicable</name> &amp;&amp; <call><name><name>aStyleSheet</name>-&gt;<name>HasRules</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> 
<name><name>PresShell</name>::<name>StyleSheetRemoved</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                             <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aDocumentSheet</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// We only care when enabled sheets are removed</comment>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aStyleSheet</name></expr></argument>, <argument><expr>"Must have a style sheet!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>applicable</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aStyleSheet</name>-&gt;<name>GetApplicable</name></name><argument_list>(<argument><expr><name>applicable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>applicable</name> &amp;&amp; <call><name><name>aStyleSheet</name>-&gt;<name>HasRules</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>StyleSheetApplicableStateChanged</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                                            <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                                            <param><decl><type><name>PRBool</name></type> <name>aApplicable</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>aStyleSheet</name>-&gt;<name>HasRules</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>StyleRuleChanged</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                            <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                            <param><decl><type><name>nsIStyleRule</name>*</type> <name>aOldStyleRule</name></decl></param>,
                            <param><decl><type><name>nsIStyleRule</name>*</type> <name>aNewStyleRule</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>StyleRuleAdded</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                          <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                          <param><decl><type><name>nsIStyleRule</name>*</type> <name>aStyleRule</name></decl></param>)</parameter_list> 
<block>{
  <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>StyleRuleRemoved</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                            <param><decl><type><name>nsIStyleSheet</name>*</type> <name>aStyleSheet</name></decl></param>,
                            <param><decl><type><name>nsIStyleRule</name>*</type> <name>aStyleRule</name></decl></param>)</parameter_list> 
<block>{
  <expr_stmt><expr><name>mStylesHaveChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsIFrame</name>*</type>
<name><name>PresShell</name>::<name>GetPrimaryFrameFor</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetLayoutObjectFor</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type>   <name>aContent</name></decl></param>,
                              <param><decl><type><name>nsISupports</name>**</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier> 
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_ERROR_NULL_POINTER</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>nsnull</name>!=<name>aResult</name>) &amp;&amp; (<name>nsnull</name>!=<name>aContent</name>)</expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>aResult</name> = <name>nsnull</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>primaryFrame</name> <init>= <expr><call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>primaryFrame</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>result</name> = <call><name><name>primaryFrame</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsISupports</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr>(<name>void</name>**)<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetPlaceholderFrameFor</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>  <name>aFrame</name></decl></param>,
                                  <param><decl><type><name>nsIFrame</name>**</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr>*<name>aResult</name> = <call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPlaceholderFrameFor</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//nsIViewObserver</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ComputeRepaintRegionForCopy</name></name><parameter_list>(<param><decl><type><name>nsIView</name>*</type>      <name>aRootView</name></decl></param>,
                                       <param><decl><type><name>nsIView</name>*</type>      <name>aMovingView</name></decl></param>,
                                       <param><decl><type><name>nsPoint</name></type>       <name>aDelta</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aCopyRect</name></decl></param>,
                                       <param><decl><type><name>nsRegion</name>*</type>     <name>aRepaintRegion</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>nsLayoutUtils</name>::<name>ComputeRepaintRegionForCopy</name></name><argument_list>(
      <argument><expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>aRootView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>aMovingView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>aDelta</name></expr></argument>, <argument><expr><name>aCopyRect</name></expr></argument>, <argument><expr><name>aRepaintRegion</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>RenderOffscreen</name></name><parameter_list>(<param><decl><type><name>nsRect</name></type> <name>aRect</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aUntrusted</name></decl></param>,
                           <param><decl><type><name>PRBool</name></type> <name>aIgnoreViewportScrolling</name></decl></param>,
                           <param><decl><type><name>nscolor</name></type> <name>aBackgroundColor</name></decl></param>,
                           <param><decl><type><name>nsIRenderingContext</name>**</type> <name>aRenderedContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIView</name>*</type> <name>rootView</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>GetRootView</name></name><argument_list>(<argument><expr><name>rootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rootView</name></expr></argument>, <argument><expr>"No root view?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>rootWidget</name> <init>= <expr><call><name><name>rootView</name>-&gt;<name>GetWidget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rootWidget</name></expr></argument>, <argument><expr>"No root widget?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>aRenderedContext</name> = <name>nsnull</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aUntrusted</name></expr></argument>, <argument><expr>"We don't support untrusted yet"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aUntrusted</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRenderingContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmpContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>DeviceContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>CreateRenderingContext</name><argument_list>(<argument><expr><name>rootWidget</name></expr></argument>, 
      <argument><expr>*<call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmpContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>tmpContext</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>bounds</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>aRect</name>.<name>Size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>bounds</name>.<name>ScaleRoundOut</name></name><argument_list>(<argument><expr>1.0f / <call><name><name>mPresContext</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsIDrawingSurface</name>*</type> <name>surface</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name>
    <init>= <expr><call><name><name>tmpContext</name>-&gt;<name>CreateDrawingSurface</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>, <argument><expr><name>NS_CREATEDRAWINGSURFACE_FOR_PIXEL_ACCESS</name></expr></argument>,
                                       <argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRenderingContext</name></expr></argument>&gt;</argument_list></name></type> <name>localcx</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsLayoutUtils</name>::<name>CreateOffscreenContext</name></name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>DeviceContext</name></name><argument_list>()</argument_list></call></expr></argument>,
      <argument><expr><name>surface</name></expr></argument>, <argument><expr><name>aRect</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>localcx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>tmpContext</name>-&gt;<name>DestroyDrawingSurface</name></name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// clipping and translation is set by CreateOffscreenContext</comment>

  <expr_stmt><expr><call><name><name>localcx</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>aBackgroundColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>localcx</name>-&gt;<name>FillRect</name></name><argument_list>(<argument><expr><name>aRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rootFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>localcx</name>.<name>swap</name></name><argument_list>(<argument><expr>*<name>aRenderedContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  
  <function_decl><type><name>nsDisplayListBuilder</name></type> <name>builder</name><parameter_list>(<param><decl><type><name>rootFrame</name></type></decl></param>, <param><decl><type><name>PR_FALSE</name></type></decl></param>, <param><decl><type><name>PR_FALSE</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIScrollableView</name>*</type> <name>scrollingView</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>GetRootScrollableView</name></name><argument_list>(<argument><expr>&amp;<name>scrollingView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>r</name> <init>= <expr><name>aRect</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aIgnoreViewportScrolling</name> &amp;&amp; <name>scrollingView</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>scrollingView</name>-&gt;<name>GetScrollPosition</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>localcx</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>r</name>.<name>MoveBy</name></name><argument_list>(<argument><expr>-<name>x</name></expr></argument>, <argument><expr>-<name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>builder</name>.<name>SetIgnoreScrollFrame</name></name><argument_list>(<argument><expr><call><name>GetRootScrollFrame</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>builder</name>.<name>EnterPresShell</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rv</name> = <call><name><name>rootFrame</name>-&gt;<name>BuildDisplayListForStackingContext</name></name><argument_list>(<argument><expr>&amp;<name>builder</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>builder</name>.<name>LeavePresShell</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>nsRegion</name></type> <name>region</name><parameter_list>(<param><decl><type><name>r</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>list</name>.<name>OptimizeVisibility</name></name><argument_list>(<argument><expr>&amp;<name>builder</name></expr></argument>, <argument><expr>&amp;<name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>list</name>.<name>Paint</name></name><argument_list>(<argument><expr>&amp;<name>builder</name></expr></argument>, <argument><expr><name>localcx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Flush the list so we don't trigger the IsEmpty-on-destruction assertion</comment>
  <expr_stmt><expr><call><name><name>list</name>.<name>DeleteAll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>localcx</name>.<name>swap</name></name><argument_list>(<argument><expr>*<name>aRenderedContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Clip the display list aList to a range. Returns the clipped
 * rectangle surrounding the range.
 */</comment>
<function><type><name>nsRect</name></type>
<name><name>PresShell</name>::<name>ClipListToRange</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                           <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>,
                           <param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>,
                           <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// iterate though the display items and add up the bounding boxes of each.</comment>
  <comment type="line">// This will allow the total area of the frames within the range to be</comment>
  <comment type="line">// determined. To do this, remove an item from the bottom of the list, check</comment>
  <comment type="line">// whether it should be part of the range, and if so, append it to the top</comment>
  <comment type="line">// of the temporary list tmpList. If the item is a text frame at the end of</comment>
  <comment type="line">// the selection range, wrap it in an nsDisplayClip to clip the display to</comment>
  <comment type="line">// the portion of the text frame that is part of the selection. Then, append</comment>
  <comment type="line">// the wrapper to the top of the list. Otherwise, just delete the item and</comment>
  <comment type="line">// don't append it.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>surfaceRect</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>tmpList</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>i</name></decl>;</decl_stmt>
  <while>while <condition>(<expr>(<name>i</name> = <call><name><name>aList</name>-&gt;<name>RemoveBottom</name></name><argument_list>()</argument_list></call>)</expr>)</condition> <block>{
    <comment type="line">// itemToInsert indiciates the item that should be inserted into the</comment>
    <comment type="line">// temporary list. If null, no item should be inserted.</comment>
    <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>itemToInsert</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>i</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>frame</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>content</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>content</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>atStart</name> <init>= <expr>(<name>content</name> == <call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>atEnd</name> <init>= <expr>(<name>content</name> == <call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>atStart</name> || <name>atEnd</name>) &amp;&amp; <call><name><name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>textFrame</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>frameStartOffset</name></decl>, <decl><type ref="prev"/><name>frameEndOffset</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>GetOffsets</name></name><argument_list>(<argument><expr><name>frameStartOffset</name></expr></argument>, <argument><expr><name>frameEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <decl_stmt><decl><type><name>PRInt32</name></type> <name>hilightStart</name> <init>=
            <expr><name>atStart</name> ? <call><name>PR_MAX</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>frameStartOffset</name></expr></argument>)</argument_list></call> : <name>frameStartOffset</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>hilightEnd</name> <init>=
            <expr><name>atEnd</name> ? <call><name>PR_MIN</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>frameEndOffset</name></expr></argument>)</argument_list></call> : <name>frameEndOffset</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>hilightStart</name> &lt; <name>hilightEnd</name></expr>)</condition><then> <block>{
            <comment type="line">// determine the location of the start and end edges of the range.</comment>
            <decl_stmt><decl><type><name>nsPoint</name></type> <name>startPoint</name></decl>, <decl><type ref="prev"/><name>endPoint</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>GetPresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>GetPointFromOffset</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>,
                                      <argument><expr><name>hilightStart</name></expr></argument>, <argument><expr>&amp;<name>startPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>GetPointFromOffset</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>,
                                      <argument><expr><name>hilightEnd</name></expr></argument>, <argument><expr>&amp;<name>endPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// the clip rectangle is determined by taking the the start and</comment>
            <comment type="line">// end points of the range, offset from the reference frame.</comment>
            <comment type="line">// Because of rtl, the end point may be to the left of the</comment>
            <comment type="line">// start point, so x is set to the lowest value</comment>
            <decl_stmt><decl><type><name>nsRect</name></type> <name>textRect</name><argument_list>(<argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>frame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name><name>startPoint</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>endPoint</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>textRect</name>.<name>x</name></name> += <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>textRect</name>.<name>width</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>startPoint</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>endPoint</name>.<name>x</name></name></expr></argument>)</argument_list></call> - <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>surfaceRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>surfaceRect</name></expr></argument>, <argument><expr><name>textRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// wrap the item in an nsDisplayClip so that it can be clipped to</comment>
            <comment type="line">// the selection. If the allocation fails, fall through and delete</comment>
            <comment type="line">// the item below.</comment>
            <expr_stmt><expr><name>itemToInsert</name> = new (<name>aBuilder</name>)<call><name>nsDisplayClip</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>textRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then>
        <else>else <block>{
          <comment type="line">// if the node is within the range, append it to the temporary list</comment>
          <decl_stmt><decl><type><name>PRBool</name></type> <name>before</name></decl>, <decl><type ref="prev"/><name>after</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>nsRange</name>::<name>CompareNodeToRange</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>aRange</name></expr></argument>, <argument><expr>&amp;<name>before</name></expr></argument>, <argument><expr>&amp;<name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>before</name> &amp;&amp; !<name>after</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>itemToInsert</name> = <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>surfaceRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>surfaceRect</name></expr></argument>, <argument><expr><call><name><name>i</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></else></if>
      }</block></then></if>
    }</block></then></if>

    <comment type="line">// insert the item into the list if necessary. If the item has a child</comment>
    <comment type="line">// list, insert that as well</comment>
    <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>sublist</name> <init>= <expr><call><name><name>i</name>-&gt;<name>GetList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>itemToInsert</name> || <name>sublist</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>tmpList</name>.<name>AppendToTop</name></name><argument_list>(<argument><expr><name>itemToInsert</name> ? <name>itemToInsert</name> : <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// if the item is a list, iterate over it as well</comment>
      <if>if <condition>(<expr><name>sublist</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>surfaceRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>surfaceRect</name></expr></argument>,
          <argument><expr><call><name>ClipListToRange</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>, <argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
      <comment type="line">// otherwise, just delete the item and don't readd it to the list</comment>
      <expr_stmt><expr><call><name><name>i</name>-&gt;~<name>nsDisplayItem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>

  <comment type="line">// now add all the items back onto the original list again</comment>
  <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr>&amp;<name>tmpList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>surfaceRect</name></expr>;</return>
}</block></function>

<function><type><name>RangePaintInfo</name>*</type>
<name><name>PresShell</name>::<name>CreateRangePaintInfo</name></name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>,
                                <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>,
                                <param><decl><type><name>nsRect</name>&amp;</type> <name>aSurfaceRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>RangePaintInfo</name>*</type> <name>info</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>range</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>ancestorFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// If the start or end of the range is the document, just use the root</comment>
  <comment type="line">// frame, otherwise get the common ancestor of the two endpoints of the</comment>
  <comment type="line">// range.</comment>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startParent</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endParent</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>doc</name> <init>= <expr><call><name><name>startParent</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>startParent</name> == <name>doc</name> || <name>endParent</name> == <name>doc</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>ancestorFrame</name> = <name>rootFrame</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>ancestor</name> <init>= <expr><call><name><name>nsContentUtils</name>::<name>GetCommonAncestor</name></name><argument_list>(<argument><expr><name>startParent</name></expr></argument>, <argument><expr><name>endParent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>ancestor</name> || <call><name><name>ancestor</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eCONTENT</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"common ancestor is not content"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ancestor</name> || !<call><name><name>ancestor</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eCONTENT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>ancestorContent</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIContent</name>*</expr></argument>, <argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ancestorFrame</name> = <call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>ancestorContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// use the nearest ancestor frame that includes all continuations as the</comment>
    <comment type="line">// root for building the display list</comment>
    <while>while <condition>(<expr><name>ancestorFrame</name> &amp;&amp;
           <call><name><name>nsLayoutUtils</name>::<name>GetNextContinuationOrSpecialSibling</name></name><argument_list>(<argument><expr><name>ancestorFrame</name></expr></argument>)</argument_list></call></expr>)</condition>
      <expr_stmt><expr><name>ancestorFrame</name> = <call><name><name>ancestorFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></while>
  }</block></else></if>

  <if>if <condition>(<expr>!<name>ancestorFrame</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <expr_stmt><expr><name>info</name> = new <call><name>RangePaintInfo</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>ancestorFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>info</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>ancestorRect</name> <init>= <expr><call><name><name>ancestorFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// get a display list containing the range</comment>
  <expr_stmt><expr><call><name><name>info</name>-&gt;<name>mBuilder</name>.<name>SetPaintAllFrames</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>info</name>-&gt;<name>mBuilder</name>.<name>EnterPresShell</name></name><argument_list>(<argument><expr><name>ancestorFrame</name></expr></argument>, <argument><expr><name>ancestorRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>ancestorFrame</name>-&gt;<name>BuildDisplayListForStackingContext</name></name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>mBuilder</name></name></expr></argument>,
                                                    <argument><expr><name>ancestorRect</name></expr></argument>, <argument><expr>&amp;<name><name>info</name>-&gt;<name>mList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>info</name>-&gt;<name>mBuilder</name>.<name>LeavePresShell</name></name><argument_list>(<argument><expr><name>ancestorFrame</name></expr></argument>, <argument><expr><name>ancestorRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>rangeRect</name> <init>= <expr><call><name>ClipListToRange</name><argument_list>(<argument><expr>&amp;<name><name>info</name>-&gt;<name>mBuilder</name></name></expr></argument>, <argument><expr>&amp;<name><name>info</name>-&gt;<name>mList</name></name></expr></argument>,
                                     <argument><expr><name>range</name></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// determine the offset of the reference frame for the display list</comment>
  <comment type="line">// to the root frame. This will allow the coordinates used when painting</comment>
  <comment type="line">// to all be offset from the same point</comment>
  <expr_stmt><expr><name><name>info</name>-&gt;<name>mRootOffset</name></name> = <call><name><name>ancestorFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>rangeRect</name>.<name>MoveBy</name></name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>mRootOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aSurfaceRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>aSurfaceRect</name></expr></argument>, <argument><expr><name>rangeRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>info</name></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>PresShell</name>::<name>PaintRangePaintInfo</name></name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>RangePaintInfo</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>*</type> <name>aItems</name></decl></param>,
                               <param><decl><type><name>nsISelection</name>*</type> <name>aSelection</name></decl></param>,
                               <param><decl><type><name>nsIRegion</name>*</type> <name>aRegion</name></decl></param>,
                               <param><decl><type><name>nsRect</name></type> <name>aArea</name></decl></param>,
                               <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                               <param><decl><type><name>nsRect</name>*</type> <name>aScreenRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>pc</name> <init>= <expr><call><name>GetPresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIDeviceContext</name>*</type> <name>deviceContext</name> <init>= <expr><call><name><name>pc</name>-&gt;<name>DeviceContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// use the rectangle to create the surface</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>pixelArea</name> <init>= <expr><name>aArea</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pixelArea</name>.<name>ScaleRoundOut</name></name><argument_list>(<argument><expr>1.0 / <call><name><name>pc</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// if the area of the image is larger than the maximum area, scale it down</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>scale</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>rootScreenRect</name> <init>= <expr><call><name>GetRootFrame</name><argument_list>()</argument_list></call>-&gt;<call><name>GetScreenRect</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// if the image is larger in one or both directions than half the size of</comment>
  <comment type="line">// the available screen area, scale the image down to that size.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>maxSize</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>deviceContext</name>-&gt;<name>GetClientRect</name></name><argument_list>(<argument><expr><name>maxSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>maxWidth</name> <init>= <expr><call><name><name>pc</name>-&gt;<name>AppUnitsToDevPixels</name></name><argument_list>(<argument><expr><name><name>maxSize</name>.<name>width</name></name> &gt;&gt; 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>maxHeight</name> <init>= <expr><call><name><name>pc</name>-&gt;<name>AppUnitsToDevPixels</name></name><argument_list>(<argument><expr><name><name>maxSize</name>.<name>height</name></name> &gt;&gt; 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>resize</name> <init>= <expr>(<name><name>pixelArea</name>.<name>width</name></name> &gt; <name>maxWidth</name> || <name><name>pixelArea</name>.<name>height</name></name> &gt; <name>maxHeight</name>)</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>resize</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>scale</name> = 1.0</expr>;</expr_stmt>
    <comment type="line">// divide the maximum size by the image size in both directions. Whichever</comment>
    <comment type="line">// direction produces the smallest result determines how much should be</comment>
    <comment type="line">// scaled.</comment>
    <if>if <condition>(<expr><name><name>pixelArea</name>.<name>width</name></name> &gt; <name>maxWidth</name></expr>)</condition><then>
      <expr_stmt><expr><name>scale</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>float</name><argument_list>(<argument><expr><name>maxWidth</name></expr></argument>)</argument_list></call> / <name><name>pixelArea</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>pixelArea</name>.<name>height</name></name> &gt; <name>maxHeight</name></expr>)</condition><then>
      <expr_stmt><expr><name>scale</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>float</name><argument_list>(<argument><expr><name>maxHeight</name></expr></argument>)</argument_list></call> / <name><name>pixelArea</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>pixelArea</name>.<name>width</name></name> = <call><name>NSToIntFloor</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><name><name>pixelArea</name>.<name>width</name></name></expr></argument>)</argument_list></call> * <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pixelArea</name>.<name>height</name></name> = <call><name>NSToIntFloor</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><name><name>pixelArea</name>.<name>height</name></name></expr></argument>)</argument_list></call> * <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// adjust the screen position based on the rescaled size</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>left</name> <init>= <expr><name><name>rootScreenRect</name>.<name>x</name></name> + <name><name>pixelArea</name>.<name>x</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>top</name> <init>= <expr><name><name>rootScreenRect</name>.<name>y</name></name> + <name><name>pixelArea</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>aScreenRect</name>-&gt;<name>x</name></name> = <call><name>NSToIntFloor</name><argument_list>(<argument><expr><name><name>aPoint</name>.<name>x</name></name> - <call><name>float</name><argument_list>(<argument><expr><name><name>aPoint</name>.<name>x</name></name> - <name>left</name></expr></argument>)</argument_list></call> * <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aScreenRect</name>-&gt;<name>y</name></name> = <call><name>NSToIntFloor</name><argument_list>(<argument><expr><name><name>aPoint</name>.<name>y</name></name> - <call><name>float</name><argument_list>(<argument><expr><name><name>aPoint</name>.<name>y</name></name> - <name>top</name></expr></argument>)</argument_list></call> * <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <comment type="line">// move aScreenRect to the position of the surface in screen coordinates</comment>
    <expr_stmt><expr><call><name><name>aScreenRect</name>-&gt;<name>MoveTo</name></name><argument_list>(<argument><expr><name><name>rootScreenRect</name>.<name>x</name></name> + <name><name>pixelArea</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>rootScreenRect</name>.<name>y</name></name> + <name><name>pixelArea</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name><name>aScreenRect</name>-&gt;<name>width</name></name> = <name><name>pixelArea</name>.<name>width</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aScreenRect</name>-&gt;<name>height</name></name> = <name><name>pixelArea</name>.<name>height</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>gfxImageSurface</name>*</type> <name>surface</name> <init>=
    <expr>new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>pixelArea</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>pixelArea</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>gfxImageSurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>surface</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <comment type="line">// clear the image</comment>
  <function_decl><type><name>gfxContext</name></type> <name>context</name><parameter_list>(<param><decl><type><name>surface</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>context</name>.<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_CLEAR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>context</name>.<name>Rectangle</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>pixelArea</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>pixelArea</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>context</name>.<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRenderingContext</name></expr></argument>&gt;</argument_list></name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>deviceContext</name>-&gt;<name>CreateRenderingContextInstance</name></name><argument_list>(<argument><expr>*<call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>rc</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>deviceContext</name></expr></argument>, <argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aRegion</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>rc</name>-&gt;<name>SetClipRegion</name></name><argument_list>(<argument><expr>*<name>aRegion</name></expr></argument>, <argument><expr><name>nsClipCombine_kReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>resize</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>rc</name>-&gt;<name>Scale</name></name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// translate so that points are relative to the surface area</comment>
  <expr_stmt><expr><call><name><name>rc</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr>-<name><name>aArea</name>.<name>x</name></name></expr></argument>, <argument><expr>-<name><name>aArea</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// temporarily hide the selection so that text is drawn normally. If a</comment>
  <comment type="line">// selection is being rendered, use that, otherwise use the presshell's</comment>
  <comment type="line">// selection.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsFrameSelection</name></expr></argument>&gt;</argument_list></name></type> <name>frameSelection</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aSelection</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelectionPrivate</name></expr></argument>&gt;</argument_list></name></type> <name>selpriv</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aSelection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>selpriv</name>-&gt;<name>GetFrameSelection</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>frameSelection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>frameSelection</name> = <call><name>FrameSelection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <decl_stmt><decl><type><name>PRInt16</name></type> <name>oldDisplaySelection</name> <init>= <expr><call><name><name>frameSelection</name>-&gt;<name>GetDisplaySelection</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>frameSelection</name>-&gt;<name>SetDisplaySelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_HIDDEN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// next, paint each range in the selection</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>count</name> <init>= <expr><call><name><name>aItems</name>-&gt;<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>RangePaintInfo</name>*</type> <name>rangeInfo</name> <init>= <expr>(*<name>aItems</name>)<index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
    <comment type="line">// the display lists paint relative to the offset from the reference</comment>
    <comment type="line">// frame, so translate the rendering context</comment>
    <function_decl><type><name><name>nsIRenderingContext</name>::<name>AutoPushTranslation</name></name></type>
      <name>translate</name><parameter_list>(<param><decl><type><name>rc</name></type></decl></param>, <param><decl><type><name><name>rangeInfo</name>-&gt;<name>mRootOffset</name>.<name>x</name></name></type></decl></param>, <param><decl><type><name><name>rangeInfo</name>-&gt;<name>mRootOffset</name>.<name>y</name></name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name><name>aArea</name>.<name>MoveBy</name></name><argument_list>(<argument><expr>-<name><name>rangeInfo</name>-&gt;<name>mRootOffset</name>.<name>x</name></name></expr></argument>, <argument><expr>-<name><name>rangeInfo</name>-&gt;<name>mRootOffset</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>rangeInfo</name>-&gt;<name>mList</name>.<name>Paint</name></name><argument_list>(<argument><expr>&amp;<name><name>rangeInfo</name>-&gt;<name>mBuilder</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>aArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aArea</name>.<name>MoveBy</name></name><argument_list>(<argument><expr><name><name>rangeInfo</name>-&gt;<name>mRootOffset</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>rangeInfo</name>-&gt;<name>mRootOffset</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// restore the old selection display state</comment>
  <expr_stmt><expr><call><name><name>frameSelection</name>-&gt;<name>SetDisplaySelection</name></name><argument_list>(<argument><expr><name>oldDisplaySelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>surface</name></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>PresShell</name>::<name>RenderNode</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aNode</name></decl></param>,
                      <param><decl><type><name>nsIRegion</name>*</type> <name>aRegion</name></decl></param>,
                      <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                      <param><decl><type><name>nsRect</name>*</type> <name>aScreenRect</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// create a temporary rendering context for text measuring</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRenderingContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmprc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CreateRenderingContext</name><argument_list>(<argument><expr><call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmprc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// area will hold the size of the surface needed to draw the node, measured</comment>
  <comment type="line">// from the root frame.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>area</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>RangePaintInfo</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>rangeItems</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_NewRange</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>range</name>-&gt;<name>SelectNode</name></name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>RangePaintInfo</name>*</type> <name>info</name> <init>= <expr><call><name>CreateRangePaintInfo</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>tmprc</name></expr></argument>, <argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>info</name> &amp;&amp; !<call><name><name>rangeItems</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>info</name></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>aRegion</name></expr>)</condition><then> <block>{
    <comment type="line">// combine the area with the supplied region</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>rrectPixels</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aRegion</name>-&gt;<name>GetBoundingBox</name></name><argument_list>(<argument><expr>&amp;<name><name>rrectPixels</name>.<name>x</name></name></expr></argument>, <argument><expr>&amp;<name><name>rrectPixels</name>.<name>y</name></name></expr></argument>,
                            <argument><expr>&amp;<name><name>rrectPixels</name>.<name>width</name></name></expr></argument>, <argument><expr>&amp;<name><name>rrectPixels</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsRect</name></type> <name>rrect</name> <init>= <expr><name>rrectPixels</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>rrect</name>.<name>ScaleRoundOut</name></name><argument_list>(<argument><expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>area</name>.<name>IntersectRect</name></name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>rrect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>pc</name> <init>= <expr><call><name>GetPresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>

    <comment type="line">// move the region so that it is offset from the topleft corner of the surface</comment>
    <expr_stmt><expr><call><name><name>aRegion</name>-&gt;<name>Offset</name></name><argument_list>(<argument><expr>-<name><name>rrectPixels</name>.<name>x</name></name> + (<name><name>rrectPixels</name>.<name>x</name></name> - <call><name><name>pc</name>-&gt;<name>AppUnitsToDevPixels</name></name><argument_list>(<argument><expr><name><name>area</name>.<name>x</name></name></expr></argument>)</argument_list></call>)</expr></argument>,
                    <argument><expr>-<name><name>rrectPixels</name>.<name>y</name></name> + (<name><name>rrectPixels</name>.<name>y</name></name> - <call><name><name>pc</name>-&gt;<name>AppUnitsToDevPixels</name></name><argument_list>(<argument><expr><name><name>area</name>.<name>y</name></name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><call><name>PaintRangePaintInfo</name><argument_list>(<argument><expr>&amp;<name>rangeItems</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aRegion</name></expr></argument>, <argument><expr><name>area</name></expr></argument>, <argument><expr><name>aPoint</name></expr></argument>,
                             <argument><expr><name>aScreenRect</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>PresShell</name>::<name>RenderSelection</name></name><parameter_list>(<param><decl><type><name>nsISelection</name>*</type> <name>aSelection</name></decl></param>,
                           <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                           <param><decl><type><name>nsRect</name>*</type> <name>aScreenRect</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// create a temporary rendering context for text measuring</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRenderingContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmprc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CreateRenderingContext</name><argument_list>(<argument><expr><call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmprc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// area will hold the size of the surface needed to draw the selection,</comment>
  <comment type="line">// measured from the root frame.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>area</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>RangePaintInfo</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>rangeItems</name></decl>;</decl_stmt>

  <comment type="line">// iterate over each range and collect them into the rangeItems array.</comment>
  <comment type="line">// This is done so that the size of selection can be determined so as</comment>
  <comment type="line">// to allocate a surface area</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRanges</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aSelection</name>-&gt;<name>GetRangeCount</name></name><argument_list>(<argument><expr>&amp;<name>numRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name>numRanges</name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>)
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aSelection</name>-&gt;<name>GetRangeAt</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>RangePaintInfo</name>*</type> <name>info</name> <init>= <expr><call><name>CreateRangePaintInfo</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>tmprc</name></expr></argument>, <argument><expr><name>area</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>info</name> &amp;&amp; !<call><name><name>rangeItems</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>delete <name>info</name></expr>;</expr_stmt>
      <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <return>return <expr><call><name>PaintRangePaintInfo</name><argument_list>(<argument><expr>&amp;<name>rangeItems</name></expr></argument>, <argument><expr><name>aSelection</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>area</name></expr></argument>, <argument><expr><name>aPoint</name></expr></argument>,
                             <argument><expr><name>aScreenRect</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsIView</name>*</type>             <name>aView</name></decl></param>,
                 <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type>      <name>aDirtyRegion</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>AUTO_LAYOUT_PHASE_ENTRY_POINT</name><argument_list>(<argument><expr><call><name>GetPresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Paint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>mIsDestroying</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"A paint message was dispatched to a destroyed PresShell"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>nsnull</name> == <name>aView</name>)</expr></argument>, <argument><expr>"null view"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>frame</name> = <call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>aView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type> <name>backgroundColor</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>GetDefaultBackgroundColor</name></name><argument_list>(<argument><expr>&amp;<name>backgroundColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>nsIView</name> *</type><name>view</name> <init>= <expr><name>aView</name></expr></init></decl>;</init> <condition><expr><name>view</name></expr>;</condition> <incr><expr><name>view</name> = <call><name><name>view</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name><name>view</name>-&gt;<name>HasWidget</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>widgetIsTranslucent</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>view</name>-&gt;<name>GetWidget</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetWindowTranslucency</name><argument_list>(<argument><expr><name>widgetIsTranslucent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>widgetIsTranslucent</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>backgroundColor</name> = <call><name>NS_RGBA</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
  
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>NS_GET_A</name><argument_list>(<argument><expr><name>backgroundColor</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>backgroundColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>FillRect</name></name><argument_list>(<argument><expr><call><name><name>aDirtyRegion</name>.<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsLayoutUtils</name>::<name>PaintFrame</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>aDirtyRegion</name></expr></argument>,
                            <argument><expr><name>backgroundColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsIFrame</name>*</type>
<name><name>PresShell</name>::<name>GetCurrentEventFrame</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mCurrentEventFrame</name> &amp;&amp; <name>mCurrentEventContent</name></expr>)</condition><then> <block>{
    <comment type="line">// Make sure the content still has a document reference. If not,</comment>
    <comment type="line">// then we assume it is no longer in the content tree and the</comment>
    <comment type="line">// frame shouldn't get an event, nor should we even assume its</comment>
    <comment type="line">// safe to try and find the frame.</comment>
    <if>if <condition>(<expr><call><name><name>mCurrentEventContent</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mCurrentEventFrame</name> = <call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>mCurrentEventContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>mCurrentEventFrame</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetEventTargetFrame</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>**</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aFrame</name> = <call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>GetEventTargetContent</name></name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>nsIContent</name>**</type> <name>aContent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mCurrentEventContent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aContent</name> = <name>mCurrentEventContent</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>currentEventFrame</name> <init>= <expr><call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>currentEventFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>currentEventFrame</name>-&gt;<name>GetContentForEvent</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr>*<name>aContent</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>PushCurrentEventInfo</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mCurrentEventFrame</name> || <name>mCurrentEventContent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mCurrentEventFrameStack</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr>(<name>void</name>*)<name>mCurrentEventFrame</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mCurrentEventContentStack</name>.<name>InsertObjectAt</name></name><argument_list>(<argument><expr><name>mCurrentEventContent</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>aFrame</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCurrentEventContent</name> = <name>aContent</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>PopCurrentEventInfo</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCurrentEventContent</name> = <name>nsnull</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>0 != <call><name><name>mCurrentEventFrameStack</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCurrentEventFrame</name> = (<name>nsIFrame</name>*)<call><name><name>mCurrentEventFrameStack</name>.<name>ElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mCurrentEventFrameStack</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCurrentEventContent</name> = <call><name><name>mCurrentEventContentStack</name>.<name>ObjectAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mCurrentEventContentStack</name>.<name>RemoveObjectAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>PresShell</name>::<name>InZombieDocument</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// If a content node points to a null document, or the document is not</comment>
  <comment type="line">// attached to a window, then it is possibly in a zombie document,</comment>
  <comment type="line">// about to be replaced by a newly loading document.</comment>
  <comment type="line">// Such documents cannot handle DOM events.</comment>
  <comment type="line">// It might actually be in a node not attached to any document,</comment>
  <comment type="line">// in which case there is not parent presshell to retarget it to.</comment>
  <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>doc</name> <init>= <expr><call><name><name>aContent</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr>!<name>doc</name> || !<call><name><name>doc</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>PresShell</name>::<name>RetargetEventToParent</name></name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>*</type>     <name>aEvent</name></decl></param>,
                                          <param><decl><type><name>nsEventStatus</name>*</type>  <name>aEventStatus</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Send this events straight up to the parent pres shell.</comment>
  <comment type="line">// We do this for keystroke events in zombie documents or if either a frame</comment>
  <comment type="line">// or a root content is not present.</comment>
  <comment type="line">// That way at least the UI key bindings can work.</comment>

  <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>container</name></expr>)</condition><then>
    <expr_stmt><expr><name>container</name> = <call><name>do_QueryReferent</name><argument_list>(<argument><expr><name>mForwardingContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Now, find the parent pres shell and send the event there</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShellTreeItem</name></expr></argument>&gt;</argument_list></name></type> <name>treeItem</name> <init>= 
    <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>treeItem</name></expr></argument>, <argument><expr>"No tree item for container."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShellTreeItem</name></expr></argument>&gt;</argument_list></name></type> <name>parentTreeItem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>treeItem</name>-&gt;<name>GetParent</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>parentTreeItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>parentDocShell</name> <init>= 
    <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>parentTreeItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>parentDocShell</name> || <name>treeItem</name> == <name>parentTreeItem</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>parentPresShell</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>parentDocShell</name>-&gt;<name>GetPresShell</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>parentPresShell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIViewObserver</name></expr></argument>&gt;</argument_list></name></type> <name>parentViewObserver</name> <init>= 
    <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>parentPresShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>parentViewObserver</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Fake the event as though it'ss from the parent pres shell's root view.</comment>
  <decl_stmt><decl><type><name>nsIView</name> *</type><name>parentRootView</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>parentPresShell</name>-&gt;<name>GetViewManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootView</name><argument_list>(<argument><expr><name>parentRootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><call><name><name>parentViewObserver</name>-&gt;<name>HandleEvent</name></name><argument_list>(<argument><expr><name>parentRootView</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>, 
                                         <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>HandleEvent</name></name><parameter_list>(<param><decl><type><name>nsIView</name>         *</type><name>aView</name></decl></param>,
                       <param><decl><type><name>nsGUIEvent</name>*</type>     <name>aEvent</name></decl></param>,
                       <param><decl><type><name>nsEventStatus</name>*</type>  <name>aEventStatus</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aView</name></expr></argument>, <argument><expr>"null view"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mIsDestroying</name> || <name>mIsReflowing</name> || <name>mChangeNestCount</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
  <if>if <condition>(<expr><name><name>aEvent</name>-&gt;<name>eventStructType</name></name> == <name>NS_ACCESSIBLE_EVENT</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>HandleEventInternal</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aView</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Check for a theme change up front, since the frame type is irrelevant</comment>
  <if>if <condition>(<expr><name><name>aEvent</name>-&gt;<name>message</name></name> == <name>NS_THEMECHANGED</name> &amp;&amp; <name>mPresContext</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>ThemeChanged</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Check for a system color change up front, since the frame type is</comment>
  <comment type="line">// irrelevant</comment>
  <if>if <condition>(<expr>(<name><name>aEvent</name>-&gt;<name>message</name></name> == <name>NS_SYSCOLORCHANGED</name>) &amp;&amp; <name>mPresContext</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIViewManager</name>*</type> <name>vm</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>vm</name></expr>)</condition><then> <block>{
      <comment type="line">// Only dispatch system color change when the message originates from</comment>
      <comment type="line">// from the root views widget. This is necessary to prevent us from </comment>
      <comment type="line">// dispatching the SysColorChanged notification for each child window </comment>
      <comment type="line">// which may be redundant.</comment>
      <decl_stmt><decl><type><name>nsIView</name> *</type><name>view</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>vm</name>-&gt;<name>GetRootView</name></name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>view</name> == <name>aView</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>aEventStatus</name> = <name>nsEventStatus_eConsumeDoDefault</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>SysColorChanged</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>aView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>dispatchUsingCoordinates</name> <init>=
      <expr>!<call><name>NS_IS_KEY_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>NS_IS_IME_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> &amp;&amp;
      !<call><name>NS_IS_CONTEXT_MENU_KEY</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>NS_IS_FOCUS_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// if this event has no frame, we need to retarget it at a parent</comment>
  <comment type="line">// view that has a frame.</comment>
  <if>if <condition>(<expr>!<name>frame</name> &amp;&amp;
      (<name>dispatchUsingCoordinates</name> || <call><name>NS_IS_KEY_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> ||
       <call><name>NS_IS_IME_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIView</name>*</type> <name>targetView</name> <init>= <expr><name>aView</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>targetView</name> &amp;&amp; !<call><name><name>targetView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <expr_stmt><expr><name>targetView</name> = <call><name><name>targetView</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    
    <if>if <condition>(<expr><name>targetView</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aView</name> = <name>targetView</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>frame</name> = <call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>aView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>dispatchUsingCoordinates</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr>"Nothing to handle this event!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>framePresContext</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>rootPresContext</name> <init>= <expr><call><name><name>framePresContext</name>-&gt;<name>RootPresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rootPresContext</name> = <call><name><name>mPresContext</name>-&gt;<name>RootPresContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"How did we end up outside the connected prescontext/viewmanager hierarchy?"</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <comment type="line">// If we aren't starting our event dispatch from the root frame of the root prescontext,</comment>
    <comment type="line">// then someone must be capturing the mouse. In that case we don't want to search the popup</comment>
    <comment type="line">// list.</comment>
    <if>if <condition>(<expr><name>framePresContext</name> == <name>rootPresContext</name> &amp;&amp;
        <name>frame</name> == <call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIFrame</name>*</expr></argument>&gt;</argument_list></name>&amp;</type> <name>popups</name> <init>= <expr><call><name><name>rootPresContext</name>-&gt;<name>GetActivePopups</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
      <comment type="line">// Search from top to bottom</comment>
      <for>for (<init><expr><name>i</name> = <call><name><name>popups</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>popup</name> <init>= <expr><name><name>popups</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>popup</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call>.<call><name>Contains</name><argument_list>(
                <argument><expr><call><name><name>nsLayoutUtils</name>::<name>GetEventCoordinatesRelativeTo</name></name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>popup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// The event should target the popup</comment>
          <expr_stmt><expr><name>frame</name> = <name>popup</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsPoint</name></type> <name>eventPoint</name>
        <init>= <expr><call><name><name>nsLayoutUtils</name>::<name>GetEventCoordinatesRelativeTo</name></name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>targetFrame</name> <init>= <expr><call><name><name>nsLayoutUtils</name>::<name>GetFrameForPoint</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>eventPoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>targetFrame</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PresShell</name>*</type> <name>shell</name> <init>=
          <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>PresShell</name>*</expr></argument>, <argument><expr><call><name><name>targetFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>shell</name> != <name>this</name></expr>)</condition><then> <block>{
        <comment type="line">// Handle the event in the correct shell.</comment>
        <comment type="line">// Prevent deletion until we're done with event handling (bug 336582).</comment>
        <function_decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>shell</name></type></decl></param>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>nsIView</name>*</type> <name>subshellRootView</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>shell</name>-&gt;<name>GetViewManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootView</name><argument_list>(<argument><expr><name>subshellRootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// We pass the subshell's root view as the view to start from. This is</comment>
        <comment type="line">// the only correct alternative; if the event was captured then it</comment>
        <comment type="line">// must have been captured by us or some ancestor shell and we</comment>
        <comment type="line">// now ask the subshell to dispatch it normally.</comment>
        <return>return <expr><call><name><name>shell</name>-&gt;<name>HandlePositionedEvent</name></name><argument_list>(<argument><expr><name>subshellRootView</name></expr></argument>, <argument><expr><name>targetFrame</name></expr></argument>,
                                            <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    
    <if>if <condition>(<expr>!<name>targetFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>targetFrame</name> = <name>frame</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><call><name>HandlePositionedEvent</name><argument_list>(<argument><expr><name>aView</name></expr></argument>, <argument><expr><name>targetFrame</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  
  <if>if <condition>(<expr><name>frame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PushCurrentEventInfo</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// key and IME events go to the focused frame</comment>
    <decl_stmt><decl><type><name>nsIEventStateManager</name> *</type><name>esm</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_IS_KEY_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> || <call><name>NS_IS_IME_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> ||
        <call><name>NS_IS_CONTEXT_MENU_KEY</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>esm</name>-&gt;<name>GetFocusedFrame</name></name><argument_list>(<argument><expr>&amp;<name>mCurrentEventFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mCurrentEventFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>esm</name>-&gt;<name>GetFocusedContent</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mCurrentEventContent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOZ_X11</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOZ_X11</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if>if <condition>(<expr><call><name>NS_IS_IME_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// bug 52416 (MOZ_X11)</comment>
          <comment type="line">// Lookup region (candidate window) of UNIX IME grabs</comment>
          <comment type="line">// input focus from Mozilla but wants to send IME event</comment>
          <comment type="line">// to redraw pre-edit (composed) string</comment>
          <comment type="line">// If Mozilla does not have input focus and event is IME,</comment>
          <comment type="line">// sends IME event to pre-focused element</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr><call><name>NS_IS_KEY_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> || <call><name>NS_IS_IME_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// bug 292263 (XP_WIN)</comment>
          <comment type="line">// If software keyboard has focus, it may send the key messages and</comment>
          <comment type="line">// the IME messages to pre-focused window. Therefore, if Mozilla</comment>
          <comment type="line">// doesn't have focus and event is key event or IME event, we should</comment>
          <comment type="line">// send the events to pre-focused element.</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(MOZ_X11) */</comment>
          <decl_stmt><decl><type><name>nsPIDOMWindow</name> *</type><name>ourWindow</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>ourWindow</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsIFocusController</name> *</type><name>focusController</name> <init>=
              <expr><call><name><name>ourWindow</name>-&gt;<name>GetRootFocusController</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>focusController</name></expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>PRBool</name></type> <name>active</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
              <comment type="line">// check input focus is in Mozilla</comment>
              <expr_stmt><expr><call><name><name>focusController</name>-&gt;<name>GetActive</name></name><argument_list>(<argument><expr>&amp;<name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>!<name>active</name></expr>)</condition><then> <block>{
                <comment type="line">// if not, search for pre-focused element</comment>
                <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>focusedElement</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>focusController</name>-&gt;<name>GetFocusedElement</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusedElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>focusedElement</name></expr>)</condition><then> <block>{
                  <comment type="line">// get mCurrentEventContent from focusedElement</comment>
                  <expr_stmt><expr><name>mCurrentEventContent</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>focusedElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
              }</block></then></if>
            }</block></then></if>
          }</block></then></if>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(MOZ_X11) || defined(XP_WIN) */</comment>
        <if>if <condition>(<expr>!<name>mCurrentEventContent</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>mCurrentEventContent</name> = <call><name><name>mDocument</name>-&gt;<name>GetRootContent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>nsnull</name></expr>;</expr_stmt> <comment type="line">// XXXldb Isn't it already?</comment>
      }</block></then></if>
      <if>if <condition>(<expr>!<name>mCurrentEventContent</name> || <call><name>InZombieDocument</name><argument_list>(<argument><expr><name>mCurrentEventContent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>RetargetEventToParent</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PopCurrentEventInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
      }</block></then></if>
    }</block></else></if> <else>else <block>{
      <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>frame</name></expr>;</expr_stmt>
    }</block></else>
    <if>if <condition>(<expr><call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>HandleEventInternal</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aView</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ShowEventTargetDebug</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>PopCurrentEventInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Focus events need to be dispatched even if no frame was found, since</comment>
    <comment type="line">// we don't want the focus controller to be out of sync.</comment>

    <if>if <condition>(<expr>!<call><name>NS_EVENT_NEEDS_FRAME</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
      <return>return <expr><call><name>HandleEventInternal</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aView</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>NS_IS_KEY_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Keypress events in new blank tabs should not be completely thrown away.</comment>
      <comment type="line">// Retarget them -- the parent chrome shell might make use of them.</comment>
      <return>return <expr><call><name>RetargetEventToParent</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if>
  }</block></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ShowEventTargetDebug</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>nsIFrameDebug</name>::<name>GetShowEventTargetFrameBorder</name></name><argument_list>()</argument_list></call> &amp;&amp;
      <call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>mDrawEventTargetFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mDrawEventTargetFrame</name>-&gt;<name>Invalidate</name></name><argument_list>(
          <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>mDrawEventTargetFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mDrawEventTargetFrame</name> = <name>mCurrentEventFrame</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mDrawEventTargetFrame</name>-&gt;<name>Invalidate</name></name><argument_list>(
        <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>mDrawEventTargetFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>HandlePositionedEvent</name></name><parameter_list>(<param><decl><type><name>nsIView</name>*</type>       <name>aView</name></decl></param>,
                                 <param><decl><type><name>nsIFrame</name>*</type>      <name>aTargetFrame</name></decl></param>,
                                 <param><decl><type><name>nsGUIEvent</name>*</type>    <name>aEvent</name></decl></param>,
                                 <param><decl><type><name>nsEventStatus</name>*</type> <name>aEventStatus</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>PushCurrentEventInfo</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>aTargetFrame</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mCurrentEventFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>targetElement</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mCurrentEventFrame</name>-&gt;<name>GetContentForEvent</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>,
                                           <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>targetElement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If there is no content for this frame, target it anyway.  Some</comment>
    <comment type="line">// frames can be targeted but do not have content, particularly</comment>
    <comment type="line">// windows with scrolling off.</comment>
    <if>if <condition>(<expr><name>targetElement</name></expr>)</condition><then> <block>{
      <comment type="line">// Bug 103055, bug 185889: mouse events apply to *elements*, not all</comment>
      <comment type="line">// nodes.  Thus we get the nearest element parent here.</comment>
      <comment type="line">// XXX we leave the frame the same even if we find an element</comment>
      <comment type="line">// parent, so that the text frame will receive the event (selection</comment>
      <comment type="line">// and friends are the ones who care about that anyway)</comment>
      <comment type="line">//</comment>
      <comment type="line">// We use weak pointers because during this tight loop, the node</comment>
      <comment type="line">// will *not* go away.  And this happens on every mousemove.</comment>
      <while>while <condition>(<expr><name>targetElement</name> &amp;&amp;
             !<call><name><name>targetElement</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eELEMENT</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>targetElement</name> = <call><name><name>targetElement</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>

      <comment type="line">// If we found an element, target it.  Otherwise, target *nothing*.</comment>
      <if>if <condition>(<expr>!<name>targetElement</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mCurrentEventContent</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mCurrentEventFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>targetElement</name> != <name>mCurrentEventContent</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mCurrentEventContent</name> = <name>targetElement</name></expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name>HandleEventInternal</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aView</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>ShowEventTargetDebug</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>PopCurrentEventInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>HandleEventWithTarget</name></name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                 <param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>, <param><decl><type><name>nsEventStatus</name>*</type> <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>ret</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>PushCurrentEventInfo</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> = <call><name>HandleEventInternal</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PopCurrentEventInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>PRBool</name></type>
<name>IsSynthesizedMouseMove</name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>aEvent</name>-&gt;<name>eventStructType</name></name> == <name>NS_MOUSE_EVENT</name> &amp;&amp;
         <call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsMouseEvent</name>*</expr></argument>, <argument><expr><name>aEvent</name></expr></argument>)</argument_list></call>-&gt;<name>reason</name> != <name><name>nsMouseEvent</name>::<name>eReal</name></name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>HandleEventInternal</name></name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>nsIView</name> *</type><name>aView</name></decl></param>,
                               <param><decl><type><name>nsEventStatus</name>*</type> <name>aStatus</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
  <if>if <condition>(<expr><name><name>aEvent</name>-&gt;<name>eventStructType</name></name> == <name>NS_ACCESSIBLE_EVENT</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsAccessibleEvent</name>*</expr></argument>, <argument><expr><name>aEvent</name></expr></argument>)</argument_list></call>-&gt;<name>accessible</name> = <name>nsnull</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAccessibilityService</name></expr></argument>&gt;</argument_list></name></type> <name>accService</name> <init>= 
      <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/accessibilityService;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>accService</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>container</name></expr>)</condition><then> <block>{
        <comment type="line">// This presshell is not active. This often happens when a</comment>
        <comment type="line">// preshell is being held onto for fastback.</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsIAccessible</name>*</type> <name>acc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>domNode</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>domNode</name></expr></argument>, <argument><expr>"No dom node for doc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>accService</name>-&gt;<name>GetAccessibleInShell</name></name><argument_list>(<argument><expr><name>domNode</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Addref this - it's not a COM Ptr</comment>
      <comment type="line">// We'll make sure the right number of Addref's occur before</comment>
      <comment type="line">// handing this back to the accessibility client</comment>
      <expr_stmt><expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsAccessibleEvent</name>*</expr></argument>, <argument><expr><name>aEvent</name></expr></argument>)</argument_list></call>-&gt;<name>accessible</name> = <name>acc</name></expr>;</expr_stmt>
      <comment type="line">// Ensure this is set in case a11y was activated before any</comment>
      <comment type="line">// nsPresShells existed to observe "a11y-init-or-shutdown" topic</comment>
      <expr_stmt><expr><name>gIsAccessibilityActive</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEventStateManager</name></expr></argument>&gt;</argument_list></name></type> <name>manager</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name>NS_EVENT_NEEDS_FRAME</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call> || <call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>isHandlingUserInput</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_IS_TRUSTED_EVENT</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <switch>switch <condition>(<expr><name><name>aEvent</name>-&gt;<name>message</name></name></expr>)</condition> <block>{
      <case>case <expr><name>NS_GOTFOCUS</name></expr>:
      </case><case>case <expr><name>NS_LOSTFOCUS</name></expr>:
      </case><case>case <expr><name>NS_ACTIVATE</name></expr>:
      </case><case>case <expr><name>NS_DEACTIVATE</name></expr>:
        <comment type="line">// Treat focus/blur events as user input if they happen while</comment>
        <comment type="line">// executing trusted script, or no script at all. If they</comment>
        <comment type="line">// happen during execution of non-trusted script, then they</comment>
        <comment type="line">// should not be considered user input.</comment>
        <if>if <condition>(<expr>!<call><name><name>nsContentUtils</name>::<name>IsCallerChrome</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <break>break;</break>
        }</block></then></if>
      </case><case>case <expr><name>NS_MOUSE_BUTTON_DOWN</name></expr>:
      </case><case>case <expr><name>NS_MOUSE_BUTTON_UP</name></expr>:
      </case><case>case <expr><name>NS_KEY_PRESS</name></expr>:
      </case><case>case <expr><name>NS_KEY_DOWN</name></expr>:
      </case><case>case <expr><name>NS_KEY_UP</name></expr>:
        <expr_stmt><expr><name>isHandlingUserInput</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      </case>}</block></switch>
    }</block></then></if>

    <function_decl><type><name>nsAutoHandlingUserInputStatePusher</name></type> <name>userInpStatePusher</name><parameter_list>(<param><decl><type><name>isHandlingUserInput</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>nsAutoPopupStatePusher</name></type> <name>popupStatePusher</name><argument_list>(<argument><expr><call><name><name>nsDOMEvent</name>::<name>GetEventPopupControlState</name></name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// FIXME. If the event was reused, we need to clear the old target,</comment>
    <comment type="line">// bug 329430</comment>
    <expr_stmt><expr><name><name>aEvent</name>-&gt;<name>target</name></name> = <name>nsnull</name></expr>;</expr_stmt>

    <comment type="line">// 1. Give event to event manager for pre event state changes and</comment>
    <comment type="line">//    generation of synthetic events.</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>manager</name>-&gt;<name>PreHandleEvent</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>mCurrentEventFrame</name></expr></argument>,
                                 <argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>aView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// 2. Give event to the DOM for third party and JS use.</comment>
    <if>if <condition>(<expr>(<call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call>) &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// We want synthesized mouse moves to cause mouseover and mouseout</comment>
      <comment type="line">// DOM events (PreHandleEvent above), but not mousemove DOM events.</comment>
      <if>if <condition>(<expr>!<call><name>IsSynthesizedMouseMove</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <function_decl><type><name>nsPresShellEventCB</name></type> <name>eventCB</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr><name>mCurrentEventContent</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>nsEventDispatcher</name>::<name>Dispatch</name></name><argument_list>(<argument><expr><name>mCurrentEventContent</name></expr></argument>, <argument><expr><name>mPresContext</name></expr></argument>,
                                      <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>, <argument><expr>&amp;<name>eventCB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>targetContent</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>rv</name> = <call><name><name>mCurrentEventFrame</name>-&gt;<name>GetContentForEvent</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>,
                                                      <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>targetContent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>targetContent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>nsEventDispatcher</name>::<name>Dispatch</name></name><argument_list>(<argument><expr><name>targetContent</name></expr></argument>, <argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>,
                                        <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>, <argument><expr>&amp;<name>eventCB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then> <else>else <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>nsEventDispatcher</name>::<name>Dispatch</name></name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>, <argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>,
                                        <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if></else></if>
        }</block></else></if>
      }</block></then></if>

      <comment type="line">// 3. Give event to event manager for post event state changes and</comment>
      <comment type="line">//    generation of synthetic events.</comment>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name> <argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp;
          (<call><name>GetCurrentEventFrame</name><argument_list>()</argument_list></call> || !<call><name>NS_EVENT_NEEDS_FRAME</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>manager</name>-&gt;<name>PostHandleEvent</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>mCurrentEventFrame</name></expr></argument>,
                                      <argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>aView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="line">// Dispatch event to content only (NOT full processing)</comment>
<comment type="line">// See also HandleEventWithTarget which does full event processing.</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>HandleDOMEventWithTarget</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aTargetContent</name></decl></param>, <param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>,
                                    <param><decl><type><name>nsEventStatus</name>*</type> <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PushCurrentEventInfo</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aTargetContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Bug 41013: Check if the event should be dispatched to content.</comment>
  <comment type="line">// It's possible that we are in the middle of destroying the window</comment>
  <comment type="line">// and the js context is out of date. This check detects the case</comment>
  <comment type="line">// that caused a crash in bug 41013, but there may be a better way</comment>
  <comment type="line">// to handle this situation!</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>container</name></expr>)</condition><then> <block>{

    <comment type="line">// Dispatch event to content</comment>
    <expr_stmt><expr><call><name><name>nsEventDispatcher</name>::<name>Dispatch</name></name><argument_list>(<argument><expr><name>aTargetContent</name></expr></argument>, <argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>PopCurrentEventInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ResizeReflow</name></name><parameter_list>(<param><decl><type><name>nsIView</name> *</type><name>aView</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aHeight</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>ResizeReflow</name><argument_list>(<argument><expr><name>aWidth</name></expr></argument>, <argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>PresShell</name></macro><expr_stmt><expr><name>::<name>IsVisible</name></name>()
<block>{
  <expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name> <name>container</name> = <call><name><name>mPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>()</argument_list></call></expr>;
  <expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIBaseWindow</name></expr></argument>&gt;</argument_list></name> <name>bw</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;
  <if>if <condition>(<expr>!<name>bw</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <name>PRBool</name> <name>res</name> = <name>PR_TRUE</name></block></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>bw</name>-&gt;<name>GetVisibility</name></name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>PresShell</name></macro><expr_stmt><expr><name>::<name>WillPaint</name></name>()
<block>{
  <comment type="line">// Don't reenter reflow and don't reflow during frame construction.  Also</comment>
  <comment type="line">// don't bother reflowing if some viewmanager in our tree is painting while</comment>
  <comment type="line">// we still have painting suppressed.</comment>
  <if>if <condition>(<expr><name>mIsReflowing</name> || <name>mChangeNestCount</name> || <name>mPaintingSuppressed</name></expr>)</condition><then> <block>{
    <return>return;</return>
  <expr_stmt/></block></then></if>}</block>
  
  <comment type="line">// Process reflows, if we have them, to reduce flicker due to invalidates and</comment>
  <comment type="line">// reflow being interspersed.  Note that we _do_ allow this to be</comment>
  <comment type="line">// interruptible; if we can't do all the reflows it's better to flicker a bit</comment>
  <comment type="line">// than to freeze up.</comment>
  <comment type="line">// XXXbz this update batch may not be strictly necessary, but it's good form.</comment>
  <comment type="line">// XXXbz should we be flushing out style changes here?  Probably not, I'd say.</comment>
  <call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mViewManager</name></expr></argument>, <argument><expr>"Something weird is going on"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>BeginUpdateViewBatch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ProcessReflowCommands</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>EndUpdateViewBatch</name></name><argument_list>(<argument><expr><name>NS_VMREFRESH_NO_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

nsresult
<macro><name>PresShell</name></macro><expr_stmt><expr><name>::<name>GetAgentStyleSheets</name></name>(<name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name>&amp; <name>aSheets</name>)
<block>{
  <expr><call><name><name>aSheets</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;
  <expr><name>PRInt32</name> <name>sheetCount</name> = <call><name><name>mStyleSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>)</argument_list></call></expr>;

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>sheetCount</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIStyleSheet</name> *</type><name>sheet</name> <init>= <expr><call><name><name>mStyleSet</name>-&gt;<name>StyleSheetAt</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>aSheets</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>sheet</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  <expr_stmt/></block></for>}</block></expr></expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

nsresult
<macro><name>PresShell</name></macro><expr_stmt><expr><name>::<name>SetAgentStyleSheets</name></name>(const <name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleSheet</name></expr></argument>&gt;</argument_list></name>&amp; <name>aSheets</name>)
<block>{
  <return>return <expr><call><name><name>mStyleSet</name>-&gt;<name>ReplaceSheets</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>, <argument><expr><name>aSheets</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>AddOverrideStyleSheet</name></name><parameter_list>(<param><decl><type><name>nsIStyleSheet</name> *</type><name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mStyleSet</name>-&gt;<name>PrependStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eOverrideSheet</name></name></expr></argument>, <argument><expr><name>aSheet</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>RemoveOverrideStyleSheet</name></name><parameter_list>(<param><decl><type><name>nsIStyleSheet</name> *</type><name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mStyleSet</name>-&gt;<name>RemoveStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eOverrideSheet</name></name></expr></argument>, <argument><expr><name>aSheet</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>StopPluginInstance</name><parameter_list>(<param><decl><type><name>PresShell</name> *</type><name>aShell</name></decl></param>, <param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>frame</name> <init>= <expr><call><name><name>aShell</name>-&gt;<name>FrameManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetPrimaryFrameFor</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIObjectFrame</name> *</type><name>objectFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>frame</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr>&amp;<name>objectFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>!<name>objectFrame</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><call><name><name>objectFrame</name>-&gt;<name>StopPlugin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>FreezeSubDocument</name><argument_list>(<argument>nsIDocument *aDocument</argument>, <argument>void *aData</argument>)</argument_list></macro>
<block>{
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>aDocument</name>-&gt;<name>GetPrimaryShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>shell</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>shell</name>-&gt;<name>Freeze</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>Freeze</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>domDoc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>domDoc</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>EnumeratePlugins</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"object"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>StopPluginInstance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EnumeratePlugins</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"applet"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>StopPluginInstance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EnumeratePlugins</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"embed"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>StopPluginInstance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>SetCaretVisible</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>mPaintingSuppressed</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>EnumerateSubDocuments</name></name><argument_list>(<argument><expr><name>FreezeSubDocument</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartPluginInstance</name><parameter_list>(<param><decl><type><name>PresShell</name> *</type><name>aShell</name></decl></param>, <param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObjectLoadingContent</name></expr></argument>&gt;</argument_list></name></type> <name>objlc</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>objlc</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPluginInstance</name></expr></argument>&gt;</argument_list></name></type> <name>inst</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>objlc</name>-&gt;<name>EnsureInstantiation</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>ThawSubDocument</name><argument_list>(<argument>nsIDocument *aDocument</argument>, <argument>void *aData</argument>)</argument_list></macro>
<block>{
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>aDocument</name>-&gt;<name>GetPrimaryShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>shell</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>shell</name>-&gt;<name>Thaw</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>Thaw</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>domDoc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>domDoc</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>EnumeratePlugins</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"object"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>StartPluginInstance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EnumeratePlugins</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"applet"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>StartPluginInstance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EnumeratePlugins</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"embed"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>StartPluginInstance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>EnumerateSubDocuments</name></name><argument_list>(<argument><expr><name>ThawSubDocument</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>UnsuppressPainting</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>HidePopups</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIViewManager</name> *</type><name>vm</name> <init>= <expr><call><name>GetViewManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>vm</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIView</name> *</type><name>rootView</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>vm</name>-&gt;<name>GetRootView</name></name><argument_list>(<argument><expr><name>rootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rootView</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>HideViewIfPopup</name><argument_list>(<argument><expr><name>rootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">//--------------------------------------------------------</comment>
<comment type="line">// Start of protected and private methods on the PresShell</comment>
<comment type="line">//--------------------------------------------------------</comment>

<comment type="line">//-------------- Begin Reflow Event Definition ------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>ReflowEvent</name>::<name>Run</name></name><parameter_list>()</parameter_list> <block>{    
  <comment type="line">// Take an owning reference to the PresShell during this call to ensure</comment>
  <comment type="line">// that it doesn't get killed off prematurely.</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>PresShell</name></expr></argument>&gt;</argument_list></name></type> <name>ps</name> <init>= <expr><name>mPresShell</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>ps</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
       <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n*** Handling reflow event: PresShell=%p, event=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>ps</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// NOTE: the ReflowEvent class is a friend of the PresShell class</comment>
    <expr_stmt><expr><call><name><name>ps</name>-&gt;<name>ClearReflowEventStatus</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Set a kung fu death grip on the view manager associated with the pres shell</comment>
    <comment type="line">// before processing that pres shell's reflow commands.  Fixes bug 54868.</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIViewManager</name></expr></argument>&gt;</argument_list></name></type> <name>viewManager</name> <init>= <expr><call><name><name>ps</name>-&gt;<name>GetViewManager</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>viewManager</name>-&gt;<name>BeginUpdateViewBatch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ps</name>-&gt;<name>ProcessReflowCommands</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>viewManager</name>-&gt;<name>EndUpdateViewBatch</name></name><argument_list>(<argument><expr><name>NS_VMREFRESH_NO_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Now, explicitly release the pres shell before the view manager</comment>
    <expr_stmt><expr><name>ps</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>viewManager</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-------------- End Reflow Event Definition ---------------------------</comment>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>PostReflowEvent</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>mReflowEvent</name>.<name>IsPending</name></name><argument_list>()</argument_list></call> || <name>mIsDestroying</name> || <name>mIsReflowing</name> ||
      <call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ReflowEvent</name></expr></argument>&gt;</argument_list></name></type> <name>ev</name> <init>= <expr>new <call><name>ReflowEvent</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name>NS_DispatchToCurrentThread</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"failed to dispatch reflow event"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>mReflowEvent</name> = <name>ev</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY_RC</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n*** PresShell::PostReflowEvent(), this=%p, event=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>this</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
  }</block></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>DidCauseReflow</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mChangeNestCount</name> != 0</expr></argument>, <argument><expr>"Unexpected call to DidCauseReflow()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>--<name>mChangeNestCount</name> == 0</expr>)</condition><then> <block>{
    <comment type="line">// We may have had more reflow commands appended to the queue during</comment>
    <comment type="line">// our reflow.  Make sure these get processed at some point.</comment>
    <expr_stmt><expr><call><name>PostReflowEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>WillDoReflow</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// We just reflowed, tell the caret that its frame might have moved.</comment>
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>InvalidateOutsideCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>UpdateCaretPosition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>DidDoReflow</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>HandlePostedReflowCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Null-check mViewManager in case this happens during Destroy.  See</comment>
  <comment type="line">// bugs 244435 and 238546.</comment>
  <if>if <condition>(<expr>!<name>mPaintingSuppressed</name> &amp;&amp; <name>mViewManager</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>SynthesizeMouseMove</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>mCaret</name></expr>)</condition><then> <block>{
    <comment type="line">// Update the caret's position now to account for any changes created by</comment>
    <comment type="line">// the reflow.</comment>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>InvalidateOutsideCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>UpdateCaretPosition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>DoReflow</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>target</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRenderingContext</name></expr></argument>&gt;</argument_list></name></type> <name>rcx</name></decl>;</decl_stmt>
  <comment type="line">// Always create the rendering context relative to the root frame during</comment>
  <comment type="line">// reflow; otherwise, it crashes on the mac (I'm not quite sure why)</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CreateRenderingContext</name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rcx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
   <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"CreateRenderingContext failure"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <return>return;</return>
 }</block></then></if>

  <expr_stmt><expr><call><name><name>target</name>-&gt;<name>WillReflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If the target frame is the root of the frame hierarchy, then</comment>
  <comment type="line">// use all the available space. If it's simply a `reflow root',</comment>
  <comment type="line">// then use the target frame's size as the available space.</comment>
  <decl_stmt><decl><type><name>nsSize</name></type> <name>size</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>target</name> == <name>rootFrame</name></expr>)</condition><then>
     <expr_stmt><expr><name>size</name> = <call><name><name>mPresContext</name>-&gt;<name>GetVisibleArea</name></name><argument_list>()</argument_list></call>.<call><name>Size</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
  <else>else
     <expr_stmt><expr><name>size</name> = <call><name><name>target</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>target</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>target</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"reflow roots should never split"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Don't pass size directly to the reflow state, since a</comment>
  <comment type="line">// constrained height implies page/column breaking.</comment>
  <comment type="line">// Exception: the root frame always uses a constrained reflow</comment>
  <decl_stmt><decl><type><name>nsSize</name></type> <name>reflowSize</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>target</name> != <name>rootFrame</name></expr>)</condition><then>
    <expr_stmt><expr><name>reflowSize</name> = <call><name>nsSize</name><argument_list>(<argument><expr><name><name>size</name>.<name>width</name></name></expr></argument>, <argument><expr><name>NS_UNCONSTRAINEDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>reflowSize</name> = <name>size</name></expr>;</expr_stmt></else></if>
  <function_decl><type><name>nsHTMLReflowState</name></type> <name>reflowState</name><parameter_list>(<param><decl><type><name>mPresContext</name></type></decl></param>, <param><decl><type><name>target</name></type></decl></param>, <param><decl><type><name>rcx</name></type></decl></param>, <param><decl><type><name>reflowSize</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// fix the computed height</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>reflowState</name>.<name>mComputedMargin</name></name> == <call><name>nsMargin</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"reflow state should not set margin for reflow roots"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>size</name>.<name>height</name></name> != <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>reflowState</name>.<name>mComputedHeight</name></name> =
      <name><name>size</name>.<name>height</name></name> - <call><name><name>reflowState</name>.<name>mComputedBorderPadding</name>.<name>TopBottom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>reflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call> ==
                 <name><name>size</name>.<name>width</name></name> -
                   <call><name><name>reflowState</name>.<name>mComputedBorderPadding</name>.<name>LeftRight</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"reflow state computed incorrect width"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsReflowStatus</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>desiredSize</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>target</name>-&gt;<name>Reflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>reflowState</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If an incremental reflow is initiated at a frame other than the</comment>
  <comment type="line">// root frame, then its desired size had better not change!  If it's</comment>
  <comment type="line">// initiated at the root, then the size better not change unless its</comment>
  <comment type="line">// height was unconstrained to start with.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>target</name> == <name>rootFrame</name> &amp;&amp; <name><name>size</name>.<name>height</name></name> == <name>NS_UNCONSTRAINEDSIZE</name>) ||
               (<name><name>desiredSize</name>.<name>width</name></name> == <name><name>size</name>.<name>width</name></name> &amp;&amp;
                <name><name>desiredSize</name>.<name>height</name></name> == <name><name>size</name>.<name>height</name></name>)</expr></argument>,
               <argument><expr>"non-root frame's desired size changed during an "
               "incremental reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>desiredSize</name>.<name>mOverflowArea</name></name> ==
                 <call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>desiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>desiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"reflow roots must not have visible overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>status</name> == <name>NS_FRAME_COMPLETE</name></expr></argument>,
               <argument><expr>"reflow roots should never split"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>target</name>-&gt;<name>SetSize</name></name><argument_list>(<argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>desiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>desiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>nsContainerFrame</name>::<name>SyncFrameViewAfterReflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                             <argument><expr><call><name><name>target</name>-&gt;<name>GetView</name></name><argument_list>()</argument_list></call></expr></argument>,
                                             <argument><expr>&amp;<name><name>desiredSize</name>.<name>mOverflowArea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>target</name>-&gt;<name>DidReflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>NS_FRAME_REFLOW_FINISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>target</name> == <name>rootFrame</name> &amp;&amp; <name><name>size</name>.<name>height</name></name> == <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mPresContext</name>-&gt;<name>SetVisibleArea</name></name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>desiredSize</name>.<name>width</name></name></expr></argument>,
                                        <argument><expr><name><name>desiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>DoVerifyReflow</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>nsIFrameDebug</name>::<name>GetVerifyTreeEnable</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrameDebug</name>*</type>  <name>frameDebug</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>rootFrame</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIFrameDebug</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr>(<name>void</name>**)&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>VerifyTree</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr><call><name>GetVerifyReflowEnable</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// First synchronously render what we have so far so that we can</comment>
    <comment type="line">// see it.</comment>
    <decl_stmt><decl><type><name>nsIView</name>*</type> <name>rootView</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>GetRootView</name></name><argument_list>(<argument><expr><name>rootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>UpdateView</name></name><argument_list>(<argument><expr><name>rootView</name></expr></argument>, <argument><expr><name>NS_VMREFRESH_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FlushPendingNotifications</name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mInVerifyReflow</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>ok</name> <init>= <expr><call><name>VerifyIncrementalReflow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mInVerifyReflow</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"ProcessReflowCommands: finished (%s)\n"</expr></argument>,
             <argument><expr><name>ok</name> ? "ok" : "failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>0 != <call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"XXX yikes! reflow commands queued during verify-reflow\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>ProcessReflowCommands</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInterruptible</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Start: Reflow: PresShell::ProcessReflowCommands(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_START</name><argument_list>(<argument><expr><name>mReflowWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

  <if>if <condition>(<expr>0 != <call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_DUMP_COMMANDS</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"ProcessReflowCommands: begin incremental reflow\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>WillDoReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If reflow is interruptible, then make a note of our deadline.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRIntervalTime</name></type> <name>deadline</name> <init>= <expr><name>aInterruptible</name>
        ? <call><name>PR_IntervalNow</name><argument_list>()</argument_list></call> + <call><name>PR_MicrosecondsToInterval</name><argument_list>(<argument><expr><name>gMaxRCProcessingTime</name></expr></argument>)</argument_list></call>
        : (<name>PRIntervalTime</name>)0</expr></init></decl>;</decl_stmt>

    <comment type="line">// force flushing of any pending notifications</comment>
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>BeginUpdate</name></name><argument_list>(<argument><expr><name>UPDATE_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>EndUpdate</name></name><argument_list>(<argument><expr><name>UPDATE_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// That might have executed JS (via XBL binding constructors).  So we may</comment>
    <comment type="line">// no longer have reflow commands.  In fact, we may have had Destroy()</comment>
    <comment type="line">// called.</comment>

    <comment type="line">// Scope for the reflow entry point, in addition to the |if| condition.</comment>
    <if>if <condition>(<expr>!<name>mIsDestroying</name> &amp;&amp; <call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AUTO_LAYOUT_PHASE_ENTRY_POINT</name><argument_list>(<argument><expr><call><name>GetPresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Reflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mIsReflowing</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

      <do>do <block>{
        <comment type="line">// Send an incremental reflow notification to the target frame.</comment>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>idx</name> <init>= <expr><call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>target</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><name><name>mDirtyRoots</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mDirtyRoots</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// It's not dirty anymore, which probably means the notification</comment>
          <comment type="line">// was posted in the middle of a reflow (perhaps with a reflow</comment>
          <comment type="line">// root in the middle).  Don't do anything.</comment>
          <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><call><name>DoReflow</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Keep going until we're out of reflow commands, or we've run</comment>
        <comment type="line">// past our deadline.</comment>
      }</block> while <condition>(<expr><call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call> &amp;&amp;
               (!<name>aInterruptible</name> || <call><name>PR_IntervalNow</name><argument_list>()</argument_list></call> &lt; <name>deadline</name>)</expr>)</condition>;</do>

      <comment type="line">// XXXwaterson for interruptible reflow, examine the tree and</comment>
      <comment type="line">// re-enqueue any unflowed reflow targets.</comment>

      <expr_stmt><expr><name>mIsReflowing</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>DidDoReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>VERIFY_REFLOW_DUMP_COMMANDS</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\nPresShell::ProcessReflowCommands() finished: this=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>DoVerifyReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// If any new reflow commands were enqueued during the reflow, schedule</comment>
    <comment type="line">// another reflow event to process them.  Note that we want to do this</comment>
    <comment type="line">// after DidDoReflow(), since that method can change whether there are</comment>
    <comment type="line">// dirty roots around by flushing, and there's no point in posting a reflow</comment>
    <comment type="line">// event just to have the flush revoke it.</comment>
    <if>if <condition>(<expr><call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><call><name>PostReflowEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>MOZ_TIMER_DEBUGLOG</name><argument_list>(<argument><expr>("Stop: Reflow: PresShell::ProcessReflowCommands(), this=%p\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_TIMER_STOP</name><argument_list>(<argument><expr><name>mReflowWatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  

  <if>if <condition>(<expr><name>mShouldUnsuppressPainting</name> &amp;&amp; <call><name><name>mDirtyRoots</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
    <comment type="line">// We only unlock if we're out of reflows.  It's pointless</comment>
    <comment type="line">// to unlock if reflows are still pending, since reflows</comment>
    <comment type="line">// are just going to thrash the frames around some more.  By</comment>
    <comment type="line">// waiting we avoid an overeager "jitter" effect.</comment>
    <expr_stmt><expr><name>mShouldUnsuppressPainting</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnsuppressAndInvalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ClearReflowEventStatus</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mReflowEvent</name>.<name>Forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
<comment type="block">/*
 * It's better to add stuff to the |DidSetStyleContext| method of the
 * relevant frames than adding it here.  These methods should (ideally,
 * anyway) go away.
 */</comment>

<comment type="line">// Return value says whether to walk children.</comment>
<typedef>typedef <function_decl><type><name>PRBool</name></type> (* <name>PR_CALLBACK</name> <name>frameWalkerFn</name>)<parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>void</name> *</type><name>aClosure</name></decl></param>)</parameter_list>;</function_decl></typedef>
   
<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>ReResolveMenusAndTrees</name><argument_list>(<argument>nsIFrame *aFrame</argument>, <argument>void *aClosure</argument>)</argument_list></macro>
<block>{
  <comment type="line">// Trees have a special style cache that needs to be flushed when</comment>
  <comment type="line">// the theme changes.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsITreeBoxObject</name></expr></argument>&gt;</argument_list></name></type> <name>treeBox</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>treeBox</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>treeBox</name>-&gt;<name>ClearStyleAndImageCaches</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// We deliberately don't re-resolve style on a menu's popup</comment>
  <comment type="line">// sub-content, since doing so slows menus to a crawl.  That means we</comment>
  <comment type="line">// have to special-case them on a skin switch, and ensure that the</comment>
  <comment type="line">// popup frames just get destroyed completely.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIMenuFrame</name></expr></argument>&gt;</argument_list></name></type> <name>menuFrame</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>menuFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>menuFrame</name>-&gt;<name>UngenerateMenu</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
    <expr_stmt><expr><call><name><name>menuFrame</name>-&gt;<name>OpenMenu</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>ReframeImageBoxes</name><argument_list>(<argument>nsIFrame *aFrame</argument>, <argument>void *aClosure</argument>)</argument_list></macro>
<block>{
  <decl_stmt><decl><type><name>nsStyleChangeList</name> *</type><name>list</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsStyleChangeList</name>*</expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>imageBoxFrame</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>list</name>-&gt;<name>AppendChange</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><call><name><name>aFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><name>NS_STYLE_HINT_FRAMECHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// don't walk descendants</comment>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return> <comment type="line">// walk descendants</comment>
}</block>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalkFramesThroughPlaceholders</name><parameter_list>(<param><decl><type><name>nsPresContext</name> *</type><name>aPresContext</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                              <param><decl><type><name>frameWalkerFn</name></type> <name>aFunc</name></decl></param>, <param><decl><type><name>void</name> *</type><name>aClosure</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>walkChildren</name> <init>= <expr><call>(*<name>aFunc</name>)<argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>walkChildren</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>listIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>childList</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <do>do <block>{
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>child</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>childList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>child</name></expr>)</condition> <block>{
      <if>if <condition>(<expr>!(<call><name><name>child</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_OUT_OF_FLOW</name>)</expr>)</condition><then> <block>{
        <comment type="line">// only do frames that are in flow, and recur through the</comment>
        <comment type="line">// out-of-flows of placeholders.</comment>
        <expr_stmt><expr><call><name>WalkFramesThroughPlaceholders</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>,
                                      <argument><expr><call><name><name>nsPlaceholderFrame</name>::<name>GetRealFrameFor</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>aFunc</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>childList</name> = <call><name><name>aFrame</name>-&gt;<name>GetAdditionalChildListName</name></name><argument_list>(<argument><expr><name>listIndex</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block> while <condition>(<expr><name>childList</name></expr>)</condition>;</do>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>Observe</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aSubject</name></decl></param>, 
                   <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aTopic</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr>"chrome-flush-skin-caches"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>rootFrame</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Need to null-check because "chrome-flush-skin-caches" can happen</comment>
    <comment type="line">// at interesting times during startup.</comment>
    <if>if <condition>(<expr><name>rootFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mViewManager</name></expr></argument>, <argument><expr>"View manager must exist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>BeginUpdateViewBatch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>WalkFramesThroughPlaceholders</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>rootFrame</name></expr></argument>,
                                    <argument><expr>&amp;<name>ReResolveMenusAndTrees</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Because "chrome:" URL equality is messy, reframe image box</comment>
      <comment type="line">// frames (hack!).</comment>
      <decl_stmt><decl><type><name>nsStyleChangeList</name></type> <name>changeList</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>WalkFramesThroughPlaceholders</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>rootFrame</name></expr></argument>,
                                    <argument><expr><name>ReframeImageBoxes</name></expr></argument>, <argument><expr>&amp;<name>changeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mFrameConstructor</name>-&gt;<name>ProcessRestyledFrames</name></name><argument_list>(<argument><expr><name>changeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>EndUpdateViewBatch</name></name><argument_list>(<argument><expr><name>NS_VMREFRESH_NO_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
      <expr_stmt><expr><call><name>InvalidateAccessibleSubtree</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr><name>NS_LINK_VISITED_EVENT_TOPIC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>uri</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aSubject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>uri</name> &amp;&amp; <name>mDocument</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>NotifyURIVisitednessChanged</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr>"agent-sheet-added"</expr></argument>)</argument_list></call> &amp;&amp; <name>mStyleSet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AddAgentSheet</name><argument_list>(<argument><expr><name>aSubject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr>"user-sheet-added"</expr></argument>)</argument_list></call> &amp;&amp; <name>mStyleSet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AddUserSheet</name><argument_list>(<argument><expr><name>aSubject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr>"agent-sheet-removed"</expr></argument>)</argument_list></call> &amp;&amp; <name>mStyleSet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>RemoveSheet</name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>, <argument><expr><name>aSubject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr>"user-sheet-removed"</expr></argument>)</argument_list></call> &amp;&amp; <name>mStyleSet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>RemoveSheet</name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name>aSubject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
  <if>if <condition>(<expr>!<call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><name>aTopic</name></expr></argument>, <argument><expr>"a11y-init-or-shutdown"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>gIsAccessibilityActive</name> = <name>aData</name> &amp;&amp; *<name>aData</name> == '1'</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"unrecognized topic in PresShell::Observe"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>EnumeratePlugins</name></name><parameter_list>(<param><decl><type><name>nsIDOMDocument</name> *</type><name>aDocument</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>aPluginTag</name></decl></param>,
                            <param><decl><type><name>nsPluginEnumCallback</name></type> <name>aCallback</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNodeList</name></expr></argument>&gt;</argument_list></name></type> <name>nodes</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aDocument</name>-&gt;<name>GetElementsByTagName</name></name><argument_list>(<argument><expr><name>aPluginTag</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>nodes</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>nodes</name>-&gt;<name>GetLength</name></name><argument_list>(<argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>nodes</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>content</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>aCallback</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>HideViewIfPopup</name></name><parameter_list>(<param><decl><type><name>nsIView</name>*</type> <name>aView</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsIFrame</name>*</expr></argument>, <argument><expr><call><name><name>aView</name>-&gt;<name>GetClientData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>frame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIMenuParent</name>*</type> <name>parent</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>parent</name>-&gt;<name>HideChain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// really make sure the view is hidden</comment>
      <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>SetViewVisibility</name></name><argument_list>(<argument><expr><name>aView</name></expr></argument>, <argument><expr><name>nsViewVisibility_kHide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIView</name>*</type> <name>child</name> <init>= <expr><call><name><name>aView</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>child</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name>HideViewIfPopup</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="line">//------------------------------------------------------</comment>
<comment type="line">// End of protected and private methods on the PresShell</comment>
<comment type="line">//------------------------------------------------------</comment>

<comment type="line">// Start of DEBUG only code</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsViewsCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWidgetsCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIURL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILinkHandler.h"</cpp:file></cpp:include>

<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kViewManagerCID</name></expr></argument>, <argument><expr><name>NS_VIEW_MANAGER_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kWidgetCID</name></expr></argument>, <argument><expr><name>NS_CHILD_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogVerifyMessage</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>k1</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>k2</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"verifyreflow: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>name</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>nsnull</name> != <name>k1</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrameDebug</name>*</type>  <name>frameDebug</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>k1</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIFrameDebug</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr>(<name>void</name>**)&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
     <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>GetFrameName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name><name>name</name>.<name>Assign</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"(null)"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>" %p "</expr></argument>, <argument><expr>(<name>void</name>*)<name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" != "</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>nsnull</name> != <name>k2</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrameDebug</name>*</type>  <name>frameDebug</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>k2</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIFrameDebug</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr>(<name>void</name>**)&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>GetFrameName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name><name>name</name>.<name>Assign</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"(null)"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>" %p "</expr></argument>, <argument><expr>(<name>void</name>*)<name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" %s"</expr></argument>, <argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogVerifyMessage</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>k1</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>k2</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aMsg</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>r1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>r2</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"VerifyReflow Error:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrameDebug</name>*</type>  <name>frameDebug</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>k1</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIFrameDebug</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr>(<name>void</name>**)&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>"  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>GetFrameName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>" %p "</expr></argument>, <argument><expr>(<name>void</name>*)<name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"{%d, %d, %d, %d}"</expr></argument>, <argument><expr><name><name>r1</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>r1</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>r1</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>r1</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" != \n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>k2</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIFrameDebug</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr>(<name>void</name>**)&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>"  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>GetFrameName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>" %p "</expr></argument>, <argument><expr>(<name>void</name>*)<name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"{%d, %d, %d, %d}\n"</expr></argument>, <argument><expr><name><name>r2</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>r2</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>r2</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>r2</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  %s\n"</expr></argument>, <argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>CompareTrees</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aFirstPresContext</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFirstFrame</name></decl></param>, 
             <param><decl><type><name>nsPresContext</name>*</type> <name>aSecondPresContext</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aSecondFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aFirstPresContext</name> || !<name>aFirstFrame</name> || !<name>aSecondPresContext</name> || !<name>aSecondFrame</name></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>ok</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>listName</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>listIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <do>do <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>k1</name> <init>= <expr><call><name><name>aFirstFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>listName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>k2</name> <init>= <expr><call><name><name>aSecondFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>listName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>l1</name> <init>= <expr><call><name><name>nsContainerFrame</name>::<name>LengthOf</name></name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>l2</name> <init>= <expr><call><name><name>nsContainerFrame</name>::<name>LengthOf</name></name><argument_list>(<argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>l1</name> != <name>l2</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"child counts don't match: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d != %d\n"</expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>0 == (<name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name>)</expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsRect</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIView</name>*</type> <name>v1</name></decl>, *<decl><type ref="prev"/><name>v2</name></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>((<name>nsnull</name> == <name>k1</name>) &amp;&amp; (<name>nsnull</name> != <name>k2</name>)) ||
          ((<name>nsnull</name> != <name>k1</name>) &amp;&amp; (<name>nsnull</name> == <name>k2</name>))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"child lists are different\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>nsnull</name> != <name>k1</name></expr>)</condition><then> <block>{
        <comment type="line">// Verify that the frames are the same size</comment>
        <if>if <condition>(<expr><call><name><name>k1</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call> != <call><name><name>k2</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"(frame rects)"</expr></argument>, <argument><expr><call><name><name>k1</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>k2</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// Make sure either both have views or neither have views; if they</comment>
        <comment type="line">// do have views, make sure the views are the same size. If the</comment>
        <comment type="line">// views have widgets, make sure they both do or neither does. If</comment>
        <comment type="line">// they do, make sure the widgets are the same size.</comment>
        <expr_stmt><expr><name>v1</name> = <call><name><name>k1</name>-&gt;<name>GetView</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v2</name> = <call><name><name>k2</name>-&gt;<name>GetView</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>((<name>nsnull</name> == <name>v1</name>) &amp;&amp; (<name>nsnull</name> != <name>v2</name>)) ||
            ((<name>nsnull</name> != <name>v1</name>) &amp;&amp; (<name>nsnull</name> == <name>v2</name>))</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"child views are not matched\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>nsnull</name> != <name>v1</name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><call><name><name>v1</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call> != <call><name><name>v2</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"(view rects)"</expr></argument>, <argument><expr><call><name><name>v1</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>v2</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>

          <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>w1</name> <init>= <expr><call><name><name>v1</name>-&gt;<name>GetWidget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>w2</name> <init>= <expr><call><name><name>v2</name>-&gt;<name>GetWidget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>((<name>nsnull</name> == <name>w1</name>) &amp;&amp; (<name>nsnull</name> != <name>w2</name>)) ||
              ((<name>nsnull</name> != <name>w1</name>) &amp;&amp; (<name>nsnull</name> == <name>w2</name>))</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"child widgets are not matched\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <if>if <condition>(<expr><name>nsnull</name> != <name>w1</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>w1</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>w2</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>r1</name> != <name>r2</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"(widget rects)"</expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></then></if></else></if>
        }</block></then></if></else></if>
        <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; (0 == (<name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name>))</expr>)</condition><then> <block>{
          <break>break;</break>
        }</block></then></if>

        <comment type="line">// verify that neither frame has a space manager,</comment>
        <comment type="line">// or they both do and the space managers are equivalent</comment>
        <decl_stmt><decl><type><name>nsSpaceManager</name> *</type><name>sm1</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsSpaceManager</name>*</expr></argument>,
                         <argument><expr><call><name><name>k1</name>-&gt;<name>GetProperty</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>spaceManagerProperty</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// look at the test frame</comment>
        <decl_stmt><decl><type><name>nsSpaceManager</name> *</type><name>sm2</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsSpaceManager</name>*</expr></argument>,
                         <argument><expr><call><name><name>k2</name>-&gt;<name>GetProperty</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>spaceManagerProperty</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// now compare the space managers</comment>
        <if>if <condition>(<expr>((<name>nsnull</name> == <name>sm1</name>) &amp;&amp; (<name>nsnull</name> != <name>sm2</name>)) ||
            ((<name>nsnull</name> != <name>sm1</name>) &amp;&amp; (<name>nsnull</name> == <name>sm2</name>))</expr>)</condition><then> <block>{   <comment type="line">// one is null, and the other is not</comment>
          <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"space managers are not matched\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>sm1</name> &amp;&amp; <name>sm2</name></expr>)</condition><then> <block>{  <comment type="line">// both are not null, compare them</comment>
          <comment type="line">// first, compare yMost</comment>
          <decl_stmt><decl><type><name>nscoord</name></type> <name>yMost1</name></decl>, <decl><type ref="prev"/><name>yMost2</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsresult</name></type> <name>smresult</name> <init>= <expr><call><name><name>sm1</name>-&gt;<name>YMost</name></name><argument_list>(<argument><expr><name>yMost1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>NS_ERROR_ABORT</name> != <name>smresult</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>smresult</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad result"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>smresult</name> = <call><name><name>sm2</name>-&gt;<name>YMost</name></name><argument_list>(<argument><expr><name>yMost2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>smresult</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad result"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>yMost1</name> != <name>yMost2</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"yMost of space managers differs\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <comment type="line">// now compare bands by sampling</comment>
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>yIncrement</name> <init>= <expr><name>yMost1</name>/100</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>0==<name>yIncrement</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>yIncrement</name> = 1</expr>;</expr_stmt>   <comment type="line">// guarantee we make progress in the loop below</comment>
            }</block></then></if>
            <decl_stmt><decl><type><name>nscoord</name></type> <name>yOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <for>for ( <init>;</init> <condition><expr><name>ok</name> &amp;&amp; <name>yOffset</name> &lt; <name>yMost1</name></expr>;</condition> <incr><expr><name>yOffset</name> += <name>yIncrement</name></expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>nscoord</name></type> <name>small</name><init>=<expr>5</expr></init>, <name>large</name><init>=<expr>100</expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>nsBandData</name></type> <name>band1</name></decl>, <decl><type ref="prev"/><name>band2</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>nsBandTrapezoid</name></type> <name><name>trap1</name><index>[<expr>20</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>trap2</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>band1</name>.<name>mSize</name></name> = <name><name>band2</name>.<name>mSize</name></name> = 20</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>band1</name>.<name>mTrapezoids</name></name> = <name>trap1</name></expr>;</expr_stmt>  
              <expr_stmt><expr><name><name>band2</name>.<name>mTrapezoids</name></name> = <name>trap2</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>sm1</name>-&gt;<name>GetBandData</name></name><argument_list>(<argument><expr><name>yOffset</name></expr></argument>, <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name>small</name></expr></argument>,<argument><expr><name>small</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>band1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>sm2</name>-&gt;<name>GetBandData</name></name><argument_list>(<argument><expr><name>yOffset</name></expr></argument>, <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name>small</name></expr></argument>,<argument><expr><name>small</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>band2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>band1</name>.<name>mCount</name></name> != <name><name>band2</name>.<name>mCount</name></name></expr>)</condition><then> 
              <block>{ <comment type="line">// count mismatch, stop comparing</comment>
                <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"band.mCount of space managers differs\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"count1= %d, count2=%d, yOffset = %d, size=%d\n"</expr></argument>,
                        <argument><expr><name><name>band1</name>.<name>mCount</name></name></expr></argument>, <argument><expr><name><name>band2</name>.<name>mCount</name></name></expr></argument>, <argument><expr><name>yOffset</name></expr></argument>, <argument><expr><name>small</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
                      
              }</block></then>
              <else>else   <comment type="line">// band counts match, compare individual traps</comment>
              <block>{ 
                <decl_stmt><decl><type><name>PRInt32</name></type> <name>trapIndex</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
                <for>for ( <init>;</init><condition><expr><name>trapIndex</name>&lt;<name><name>band1</name>.<name>mCount</name></name></expr>;</condition> <incr><expr><name>trapIndex</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>PRBool</name></type> <name>match</name> <init>= <expr>(<name><name>trap1</name><index>[<expr><name>trapIndex</name></expr>]</index></name>.<call><name>EqualGeometry</name><argument_list>(<argument><expr><name><name>trap2</name><index>[<expr><name>trapIndex</name></expr>]</index></name></expr></argument>)</argument_list></call>) &amp;&amp; 
                    <name><name>trap1</name><index>[<expr><name>trapIndex</name></expr>]</index></name>.<name>mState</name> == <name><name>trap2</name><index>[<expr><name>trapIndex</name></expr>]</index></name>.<name>mState</name></expr></init></decl>;</decl_stmt>
                  <if>if <condition>(<expr>!<name>match</name></expr>)</condition><then>
                  <block>{
                    <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"band.mTrapezoids of space managers differs\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"index %d\n"</expr></argument>, <argument><expr><name>trapIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  }</block></then></if>
                }</block></for>
              }</block></else></if>
              <comment type="line">// test the larger maxSize</comment>
              <expr_stmt><expr><call><name><name>sm1</name>-&gt;<name>GetBandData</name></name><argument_list>(<argument><expr><name>yOffset</name></expr></argument>, <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name>large</name></expr></argument>,<argument><expr><name>large</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>band1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>sm2</name>-&gt;<name>GetBandData</name></name><argument_list>(<argument><expr><name>yOffset</name></expr></argument>, <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name>large</name></expr></argument>,<argument><expr><name>large</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>band2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>band1</name>.<name>mCount</name></name> != <name><name>band2</name>.<name>mCount</name></name></expr>)</condition><then> 
              <block>{ <comment type="line">// count mismatch, stop comparing</comment>
                <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"band.mCount of space managers differs\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"count1= %d, count2=%d, yOffset = %d, size=%d\n"</expr></argument>,
                        <argument><expr><name><name>band1</name>.<name>mCount</name></name></expr></argument>, <argument><expr><name><name>band2</name>.<name>mCount</name></name></expr></argument>, <argument><expr><name>yOffset</name></expr></argument>, <argument><expr><name>small</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
                      
              }</block></then>
              <else>else   <comment type="line">// band counts match, compare individual traps</comment>
              <block>{ 
                <decl_stmt><decl><type><name>PRInt32</name></type> <name>trapIndex</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
                <for>for ( <init>;</init> <condition><expr><name>trapIndex</name>&lt;<name><name>band1</name>.<name>mCount</name></name></expr>;</condition> <incr><expr><name>trapIndex</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>PRBool</name></type> <name>match</name> <init>= <expr>(<name><name>trap1</name><index>[<expr><name>trapIndex</name></expr>]</index></name>.<call><name>EqualGeometry</name><argument_list>(<argument><expr><name><name>trap2</name><index>[<expr><name>trapIndex</name></expr>]</index></name></expr></argument>)</argument_list></call>) &amp;&amp; 
                    <name><name>trap1</name><index>[<expr><name>trapIndex</name></expr>]</index></name>.<name>mState</name> == <name><name>trap2</name><index>[<expr><name>trapIndex</name></expr>]</index></name>.<name>mState</name></expr></init></decl>;</decl_stmt>
                  <if>if <condition>(<expr>!<name>match</name></expr>)</condition><then>
                  <block>{
                    <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"band.mTrapezoids of space managers differs\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"index %d\n"</expr></argument>, <argument><expr><name>trapIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  }</block></then></if>
                }</block></for>
              }</block></else></if>
            }</block></for>
          }</block></then></if>
        }</block></then></if></else></if>




        <comment type="line">// Compare the sub-trees too</comment>
        <if>if <condition>(<expr>!<call><name>CompareTrees</name><argument_list>(<argument><expr><name>aFirstPresContext</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>aSecondPresContext</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
          <if>if <condition>(<expr>0 == (<name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name>)</expr>)</condition><then> <block>{
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>

        <comment type="line">// Advance to next sibling</comment>
        <expr_stmt><expr><name>k1</name> = <call><name><name>k1</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>k2</name> = <call><name><name>k2</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <break>break;</break>
      }</block></else></if></else></if>
    }</block></for>
    <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; (0 == (<name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name>))</expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>listName1</name> <init>= <expr><call><name><name>aFirstFrame</name>-&gt;<name>GetAdditionalChildListName</name></name><argument_list>(<argument><expr><name>listIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>listName2</name> <init>= <expr><call><name><name>aSecondFrame</name>-&gt;<name>GetAdditionalChildListName</name></name><argument_list>(<argument><expr><name>listIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>listIndex</name>++</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>listName1</name> != <name>listName2</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>0 == (<name>VERIFY_REFLOW_ALL</name> &amp; <name>gVerifyReflowFlags</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>LogVerifyMessage</name><argument_list>(<argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr>"child list names are not matched: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsAutoString</name></type> <name>tmp</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nsnull</name> != <name>listName1</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>listName1</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"(null)"</expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" != "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>nsnull</name> != <name>listName2</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>listName2</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"(null)"</expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>listName</name> = <name>listName1</name></expr>;</expr_stmt>
  }</block> while <condition>(<expr><name>ok</name> &amp;&amp; (<name>listName</name> != <name>nsnull</name>)</expr>)</condition>;</do>

  <return>return <expr><name>ok</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static nsIFrame*
FindTopFrame(nsIFrame* aRoot)
{
  if (aRoot) {
    nsIContent* content = aRoot-&gt;GetContent();
    if (content) {
      nsIAtom* tag;
      content-&gt;GetTag(tag);
      if (nsnull != tag) {
        NS_RELEASE(tag);
        return aRoot;
      }
    }

    <comment type="line">// Try one of the children</comment>
    nsIFrame* kid = aRoot-&gt;GetFirstChild(nsnull);
    while (nsnull != kid) {
      nsIFrame* result = FindTopFrame(kid);
      if (nsnull != result) {
        return result;
      }
      kid = kid-&gt;GetNextSibling();
    }
  }
  return nsnull;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

<function><type><name>nsresult</name></type>
<name><name>PresShell</name>::<name>CloneStyleSet</name></name><parameter_list>(<param><decl><type><name>nsStyleSet</name>*</type> <name>aSet</name></decl></param>, <param><decl><type><name>nsStyleSet</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsStyleSet</name> *</type><name>clone</name> <init>= <expr>new <call><name>nsStyleSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>clone</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>aSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eOverrideSheet</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIStyleSheet</name>*</type> <name>ss</name> <init>= <expr><call><name><name>aSet</name>-&gt;<name>StyleSheetAt</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eOverrideSheet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ss</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>clone</name>-&gt;<name>AppendStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eOverrideSheet</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></for>

  <expr_stmt><expr><name>n</name> = <call><name><name>aSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eDocSheet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIStyleSheet</name>*</type> <name>ss</name> <init>= <expr><call><name><name>aSet</name>-&gt;<name>StyleSheetAt</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eDocSheet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ss</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>clone</name>-&gt;<name>AddDocStyleSheet</name></name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>mDocument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></for>
  <expr_stmt><expr><name>n</name> = <call><name><name>aSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIStyleSheet</name>*</type> <name>ss</name> <init>= <expr><call><name><name>aSet</name>-&gt;<name>StyleSheetAt</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ss</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>clone</name>-&gt;<name>AppendStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eUserSheet</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></for>

  <expr_stmt><expr><name>n</name> = <call><name><name>aSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIStyleSheet</name>*</type> <name>ss</name> <init>= <expr><call><name><name>aSet</name>-&gt;<name>StyleSheetAt</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ss</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>clone</name>-&gt;<name>AppendStyleSheet</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eAgentSheet</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></for>
  <expr_stmt><expr>*<name>aResult</name> = <name>clone</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// After an incremental reflow, we verify the correctness by doing a</comment>
<comment type="line">// full reflow into a fresh frame tree.</comment>
<function><type><name>PRBool</name></type>
<name><name>PresShell</name>::<name>VerifyIncrementalReflow</name></name><parameter_list>()</parameter_list>
<block>{
   <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
     <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Building Verification Tree...\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
   }</block></then></if>

  <comment type="line">// Create a presentation context to view the new frame tree</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type> <name>cx</name> <init>=
       <expr>new <call><name>nsPresContext</name><argument_list>(<argument><expr><name>mDocument</name></expr></argument>, <argument><expr><call><name><name>mPresContext</name>-&gt;<name>IsPaginated</name></name><argument_list>()</argument_list></call> ?
                                        <name><name>nsPresContext</name>::<name>eContext_PrintPreview</name></name> :
                                        <name><name>nsPresContext</name>::<name>eContext_Galley</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIDeviceContext</name> *</type><name>dc</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>DeviceContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Get our scrolling preference</comment>
  <decl_stmt><decl><type><name>nsIView</name>*</type> <name>rootView</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mViewManager</name>-&gt;<name>GetRootView</name></name><argument_list>(<argument><expr><name>rootView</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name>*</type> <name>nativeParentWidget</name> <init>= <expr><call><name><name>rootView</name>-&gt;<name>GetWidget</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetNativeData</name><argument_list>(<argument><expr><name>NS_NATIVE_WIDGET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Create a new view manager.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIViewManager</name></expr></argument>&gt;</argument_list></name></type> <name>vm</name> <init>= <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>kViewManagerCID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>vm</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Create a child window of the parent that is our "root view/window"</comment>
  <comment type="line">// Create a view</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>tbounds</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetVisibleArea</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIView</name>*</type> <name>view</name> <init>= <expr><call><name><name>vm</name>-&gt;<name>CreateView</name></name><argument_list>(<argument><expr><name>tbounds</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//now create the widget for the view</comment>
  <expr_stmt><expr><name>rv</name> = <call><name><name>view</name>-&gt;<name>CreateWidget</name></name><argument_list>(<argument><expr><name>kWidgetCID</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nativeParentWidget</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Setup hierarchical relationship in view manager</comment>
  <expr_stmt><expr><call><name><name>vm</name>-&gt;<name>SetRootView</name></name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Make the new presentation context the same size as our</comment>
  <comment type="line">// presentation context.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>r</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>GetVisibleArea</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>SetVisibleArea</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Create a new presentation shell to view the document. Use the</comment>
  <comment type="line">// exact same style information that this document has.</comment>
  <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsStyleSet</name></expr></argument>&gt;</argument_list></name></type> <name>newSet</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>CloneStyleSet</name><argument_list>(<argument><expr><name>mStyleSet</name></expr></argument>, <argument><expr><call><name>getter_Transfers</name><argument_list>(<argument><expr><name>newSet</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>sh</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>mDocument</name>-&gt;<name>CreateShell</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vm</name></expr></argument>, <argument><expr><name>newSet</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>newSet</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Note that after we create the shell, we must make sure to destroy it</comment>
  <expr_stmt><expr><call><name><name>sh</name>-&gt;<name>SetVerifyReflowEnable</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// turn off verify reflow while we're reflowing the test frame tree</comment>
  <expr_stmt><expr><call><name><name>vm</name>-&gt;<name>SetViewObserver</name></name><argument_list>(<argument><expr>(<name>nsIViewObserver</name> *)((<name>PresShell</name>*)<call><name><name>sh</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WillCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sh</name>-&gt;<name>InitialReflow</name></name><argument_list>(<argument><expr><name><name>r</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DidCauseReflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mDocument</name>-&gt;<name>BindingManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ProcessAttachedQueue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sh</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sh</name>-&gt;<name>SetVerifyReflowEnable</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// turn on verify reflow again now that we're done reflowing the test frame tree</comment>
  <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
     <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Verification Tree built, comparing...\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Now that the document has been reflowed, use its frame tree to</comment>
  <comment type="line">// compare against our frame tree.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>root1</name> <init>= <expr><call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>root2</name> <init>= <expr><call><name><name>sh</name>-&gt;<name>FrameManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>ok</name> <init>= <expr><call><name>CompareTrees</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; (<name>VERIFY_REFLOW_NOISY</name> &amp; <name>gVerifyReflowFlags</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Verify reflow failed, primary tree:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrameDebug</name>*</type>  <name>frameDebug</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>root1</name></expr></argument>, <argument><expr>&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>List</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Verification tree:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>root2</name></expr></argument>, <argument><expr>&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>List</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>sh</name>-&gt;<name>EndObservingDocument</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sh</name>-&gt;<name>Destroy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>VERIFY_REFLOW_NOISY</name> &amp; <name>gVerifyReflowFlags</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Finished Verifying Reflow...\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="line">// Layout debugging hooks</comment>
<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ListStyleContexts</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aRootFrame</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsStyleContext</name> *</type><name>sc</name> <init>= <expr><call><name><name>aRootFrame</name>-&gt;<name>GetStyleContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>sc</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>sc</name>-&gt;<name>List</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>ListStyleSheets</name></name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>sheetCount</name> <init>= <expr><call><name><name>mStyleSet</name>-&gt;<name>SheetCount</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eDocSheet</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>sheetCount</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>mStyleSet</name>-&gt;<name>StyleSheetAt</name></name><argument_list>(<argument><expr><name><name>nsStyleSet</name>::<name>eDocSheet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;<call><name>List</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>PresShell</name>::<name>VerifyStyleTree</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>VERIFY_STYLE_TREE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//=============================================================</comment>
<comment type="line">//=============================================================</comment>
<comment type="line">//-- Debug Reflow Counts</comment>
<comment type="line">//=============================================================</comment>
<comment type="line">//=============================================================</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
<comment type="line">//-------------------------------------------------------------</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>DumpReflows</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mReflowCountMgr</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>uriStr</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mDocument</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIURI</name> *</type><name>uri</name> <init>= <expr><call><name><name>mDocument</name>-&gt;<name>GetDocumentURI</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>uri</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>uri</name>-&gt;<name>GetPath</name></name><argument_list>(<argument><expr><name>uriStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>DisplayTotals</name></name><argument_list>(<argument><expr><call><name><name>uriStr</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>DisplayHTMLTotals</name></name><argument_list>(<argument><expr><call><name><name>uriStr</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>DisplayDiffsInTotals</name></name><argument_list>(<argument><expr>"Differences"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-------------------------------------------------------------</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>CountReflows</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mReflowCountMgr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>Add</name></name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-------------------------------------------------------------</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>PaintCount</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>, <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aColor</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mReflowCountMgr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>PaintCount</name></name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-------------------------------------------------------------</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>PresShell</name>::<name>SetPaintFrameCount</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aPaintFrameCounts</name></decl></param>)</parameter_list>
<block>{ 
  <if>if <condition>(<expr><name>mReflowCountMgr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mReflowCountMgr</name>-&gt;<name>SetPaintFrameCounts</name></name><argument_list>(<argument><expr><name>aPaintFrameCounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return> 
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<comment type="line">//-- Reflow Counter Classes Impls</comment>
<comment type="line">//------------------------------------------------------------------</comment>

<comment type="line">//------------------------------------------------------------------</comment>
<constructor><name><name>ReflowCounter</name>::<name>ReflowCounter</name></name><parameter_list>(<param><decl><type><name>ReflowCountMgr</name> *</type> <name>aMgr</name></decl></param>)</parameter_list> <member_list>:
  <call><name>mMgr</name><argument_list>(<argument><expr><name>aMgr</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>ClearTotals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetTotalsCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<comment type="line">//------------------------------------------------------------------</comment>
<destructor><name><name>ReflowCounter</name>::~<name>ReflowCounter</name></name><parameter_list>()</parameter_list>
<block>{
  
}</block></destructor>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>ClearTotals</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mTotal</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>SetTotalsCache</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mCacheTotal</name> = <name>mTotal</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>CalcDiffInTotals</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mCacheTotal</name> = <name>mTotal</name> - <name>mCacheTotal</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>DisplayTotals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DisplayTotals</name><argument_list>(<argument><expr><name>mTotal</name></expr></argument>, <argument><expr><name>aStr</name>?<name>aStr</name>:"Totals"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>DisplayDiffTotals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DisplayTotals</name><argument_list>(<argument><expr><name>mCacheTotal</name></expr></argument>, <argument><expr><name>aStr</name>?<name>aStr</name>:"Diff Totals"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>DisplayHTMLTotals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DisplayHTMLTotals</name><argument_list>(<argument><expr><name>mTotal</name></expr></argument>, <argument><expr><name>aStr</name>?<name>aStr</name>:"Totals"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>DisplayTotals</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aTitle</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// figure total</comment>
  <if>if <condition>(<expr><name>aTotal</name> == 0</expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>gTots</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name><name>mMgr</name>-&gt;<name>LookUp</name></name><argument_list>(<argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%25s\t"</expr></argument>, <argument><expr><name>aTitle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d\t"</expr></argument>, <argument><expr><name>aTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>gTots</name> != <name>this</name> &amp;&amp; <name>aTotal</name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>gTots</name>-&gt;<name>Add</name></name><argument_list>(<argument><expr><name>aTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCounter</name>::<name>DisplayHTMLTotals</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTotal</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aTitle</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aTotal</name> == 0</expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>gTots</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name><name>mMgr</name>-&gt;<name>LookUp</name></name><argument_list>(<argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type> <name>fd</name> <init>= <expr><call><name><name>mMgr</name>-&gt;<name>GetOutFile</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>"&lt;tr&gt;&lt;td&gt;&lt;center&gt;%s&lt;/center&gt;&lt;/td&gt;"</expr></argument>, <argument><expr><name>aTitle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>"&lt;td&gt;&lt;center&gt;%d&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;\n"</expr></argument>, <argument><expr><name>aTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>gTots</name> != <name>this</name> &amp;&amp; <name>aTotal</name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>gTots</name>-&gt;<name>Add</name></name><argument_list>(<argument><expr><name>aTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<comment type="line">//-- ReflowCountMgr</comment>
<comment type="line">//------------------------------------------------------------------</comment>
<constructor><name><name>ReflowCountMgr</name>::<name>ReflowCountMgr</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mCounts</name> = <call><name>PL_NewHashTable</name><argument_list>(<argument><expr>10</expr></argument>, <argument><expr><name>PL_HashString</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, 
                                <argument><expr><name>PL_CompareValues</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIndiFrameCounts</name> = <call><name>PL_NewHashTable</name><argument_list>(<argument><expr>10</expr></argument>, <argument><expr><name>PL_HashString</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, 
                                     <argument><expr><name>PL_CompareValues</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCycledOnce</name>              = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mDumpFrameCounts</name>         = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mDumpFrameByFrameCounts</name>  = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mPaintFrameByFrameCounts</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></constructor>

<comment type="line">//------------------------------------------------------------------</comment>
<destructor><name><name>ReflowCountMgr</name>::~<name>ReflowCountMgr</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>CleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>ReflowCounter</name> *</type> <name><name>ReflowCountMgr</name>::<name>LookUp</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>counter</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>nsnull</name></expr>;</return>

}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>Add</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aName</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aName</name> != <name>nsnull</name></expr></argument>, <argument><expr>"Name shouldn't be null!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mDumpFrameCounts</name> &amp;&amp; <name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>counter</name> == <name>nsnull</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>counter</name> = new <call><name>ReflowCounter</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>counter</name> != <name>nsnull</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>char</name> *</type> <name>name</name> <init>= <expr><call><name>NS_strdup</name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>name</name> != <name>nsnull</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>Add</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>(<name>mDumpFrameByFrameCounts</name> || <name>mPaintFrameByFrameCounts</name>) &amp;&amp; 
      <name>nsnull</name> != <name>mIndiFrameCounts</name> &amp;&amp; 
      <name>aFrame</name> != <name>nsnull</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>char</name> *</type> <name>key</name> <init>= <expr>new <name><name>char</name><index>[<expr>16</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"%p"</expr></argument>, <argument><expr>(<name>void</name>*)<name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>IndiReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>IndiReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mIndiFrameCounts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>counter</name> == <name>nsnull</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>counter</name> = new <call><name>IndiReflowCounter</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>counter</name> != <name>nsnull</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>counter</name>-&gt;<name>mFrame</name></name> = <name>aFrame</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>mName</name>.<name>AssignASCII</name></name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name>mIndiFrameCounts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// this eliminates extra counts from super classes</comment>
    <if>if <condition>(<expr><name>counter</name> != <name>nsnull</name> &amp;&amp; <call><name><name>counter</name>-&gt;<name>mName</name>.<name>EqualsASCII</name></name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>counter</name>-&gt;<name>mCount</name></name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>mCounter</name>.<name>Add</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>PaintCount</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type>    <name>aName</name></decl></param>, 
                                <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>, 
                                <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, 
                                <param><decl><type><name>nsIFrame</name>*</type>       <name>aFrame</name></decl></param>, 
                                <param><decl><type><name>PRUint32</name></type>        <name>aColor</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mPaintFrameByFrameCounts</name> &amp;&amp; 
      <name>nsnull</name> != <name>mIndiFrameCounts</name> &amp;&amp; 
      <name>aFrame</name> != <name>nsnull</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>char</name> *</type> <name>key</name> <init>= <expr>new <name><name>char</name><index>[<expr>16</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"%p"</expr></argument>, <argument><expr>(<name>void</name>*)<name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>IndiReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>IndiReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mIndiFrameCounts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>counter</name> != <name>nsnull</name> &amp;&amp; <call><name><name>counter</name>-&gt;<name>mName</name>.<name>EqualsASCII</name></name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>PushState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsFont</name></type> <name>font</name><argument_list>(<argument><expr>"Times"</expr></argument>, <argument><expr><name>NS_FONT_STYLE_NORMAL</name></expr></argument>, <argument><expr><name>NS_FONT_VARIANT_NORMAL</name></expr></argument>,
                  <argument><expr><name>NS_FONT_WEIGHT_NORMAL</name></expr></argument>, <argument><expr>0</expr></argument>,
                  <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFontMetrics</name></expr></argument>&gt;</argument_list></name></type> <name>fm</name> <init>= <expr><call><name><name>aPresContext</name>-&gt;<name>GetMetricsFor</name></name><argument_list>(<argument><expr><name>font</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>SetFont</name></name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>counter</name>-&gt;<name>mCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name> <init>= <expr>0</expr></init>, <name>y</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nscoord</name></type> <name>width</name></decl>, <decl><type ref="prev"/><name>height</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>SetTextRunRTL</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>GetWidth</name></name><argument_list>(<argument><expr>(<name>char</name>*)<name>buf</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>fm</name>-&gt;<name>GetHeight</name></name><argument_list>(<argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>fm</name>-&gt;<name>GetMaxAscent</name></name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>PRUint32</name></type> <name>color</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>color2</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>aColor</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>color</name>  = <name>aColor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>color2</name> = <call><name>NS_RGB</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>PRUint8</name></type> <name>rc</name> <init>= <expr>0</expr></init>, <name>gc</name> <init>= <expr>0</expr></init>, <name>bc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>counter</name>-&gt;<name>mCount</name></name> &lt; 5</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>rc</name> = 255</expr>;</expr_stmt>
          <expr_stmt><expr><name>gc</name> = 255</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>( <expr><name><name>counter</name>-&gt;<name>mCount</name></name> &lt; 11</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>gc</name> = 255</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>rc</name> = 255</expr>;</expr_stmt>
        }</block></else></if></else></if>
        <expr_stmt><expr><name>color</name>  = <call><name>NS_RGB</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,<argument><expr><name>gc</name></expr></argument>,<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>color2</name> = <call><name>NS_RGB</name><argument_list>(<argument><expr><name>rc</name>/2</expr></argument>,<argument><expr><name>gc</name>/2</expr></argument>,<argument><expr><name>bc</name>/2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>

      <decl_stmt><decl><type><name>nsRect</name></type> <name>rect</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>, <argument><expr><name>width</name>+15</expr></argument>, <argument><expr><name>height</name>+15</expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><call><name>NS_RGB</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>FillRect</name></name><argument_list>(<argument><expr><name>rect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>color2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>DrawString</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name>+15</expr></argument>,<argument><expr><name>y</name>+15</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>DrawString</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name><name>aRenderingContext</name>-&gt;<name>PopState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>RemoveItems</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr>(<name>char</name> *)<name><name>he</name>-&gt;<name>key</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>delete <name>counter</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_Free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HT_ENUMERATE_REMOVE</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>RemoveIndiItems</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr>(<name>char</name> *)<name><name>he</name>-&gt;<name>key</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IndiReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>IndiReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>delete <name>counter</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_Free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HT_ENUMERATE_REMOVE</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>CleanUp</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>RemoveItems</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableDestroy</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCounts</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>nsnull</name> != <name>mIndiFrameCounts</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mIndiFrameCounts</name></expr></argument>, <argument><expr><name>RemoveIndiItems</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableDestroy</name><argument_list>(<argument><expr><name>mIndiFrameCounts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIndiFrameCounts</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>DoSingleTotal</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr>(<name>char</name> *)<name><name>he</name>-&gt;<name>key</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>DisplayTotals</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>DoGrandTotals</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>gTots</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>gTots</name> == <name>nsnull</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>gTots</name> = new <call><name>ReflowCounter</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><call><name>NS_strdup</name><argument_list>(<argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gTots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>gTots</name>-&gt;<name>ClearTotals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\t\t\t\tTotal\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;78</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"-"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>DoSingleTotal</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>RecurseIndiTotals</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, 
                              <param><decl><type><name>PLHashTable</name> *</type>   <name>aHT</name></decl></param>, 
                              <param><decl><type><name>nsIFrame</name> *</type>      <name>aParentFrame</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type>         <name>aLevel</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aParentFrame</name> == <name>nsnull</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"%p"</expr></argument>, <argument><expr>(<name>void</name>*)<name>aParentFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>IndiReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>IndiReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>aHT</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>counter</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>counter</name>-&gt;<name>mHasBeenOutput</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>name</name> <init>= <expr><call><name>ToNewCString</name><argument_list>(<argument><expr><name><name>counter</name>-&gt;<name>mName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>aLevel</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s - %p   [%d]["</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>aParentFrame</name></expr></argument>, <argument><expr><name><name>counter</name>-&gt;<name>mCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d"</expr></argument>, <argument><expr><call><name><name>counter</name>-&gt;<name>mCounter</name>.<name>GetTotal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>child</name> <init>= <expr><call><name><name>aParentFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>child</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name>RecurseIndiTotals</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aHT</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>aLevel</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>

}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>DoSingleIndi</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>IndiReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>IndiReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>counter</name> &amp;&amp; !<name><name>counter</name>-&gt;<name>mHasBeenOutput</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>char</name> *</type> <name>name</name> <init>= <expr><call><name>ToNewCString</name><argument_list>(<argument><expr><name><name>counter</name>-&gt;<name>mName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s - %p   [%d]["</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>void</name>*)<name><name>counter</name>-&gt;<name>mFrame</name></name></expr></argument>, <argument><expr><name><name>counter</name>-&gt;<name>mCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d"</expr></argument>, <argument><expr><call><name><name>counter</name>-&gt;<name>mCounter</name>.<name>GetTotal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>DoIndiTotalsTree</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n------------------------------------------------\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"-- Individual Frame Counts\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"------------------------------------------------\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mPresShell</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name> *</type> <name>rootFrame</name> <init>= <expr><call><name><name>mPresShell</name>-&gt;<name>FrameManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>RecurseIndiTotals</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>mIndiFrameCounts</name></expr></argument>, <argument><expr><name>rootFrame</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"------------------------------------------------\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"-- Individual Counts of Frames not in Root Tree\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"------------------------------------------------\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mIndiFrameCounts</name></expr></argument>, <argument><expr><name>DoSingleIndi</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>DoSingleHTMLTotal</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr>(<name>char</name> *)<name><name>he</name>-&gt;<name>key</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>DisplayHTMLTotals</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>DoGrandHTMLTotals</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>gTots</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>gTots</name> == <name>nsnull</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>gTots</name> = new <call><name>ReflowCounter</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><call><name>NS_strdup</name><argument_list>(<argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gTots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>gTots</name>-&gt;<name>ClearTotals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type> <name><name>title</name><index>[]</index></name> <init>= <expr><block>{<expr>"Class"</expr>, <expr>"Reflows"</expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;tr&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;td&gt;&lt;center&gt;&lt;b&gt;%s&lt;b&gt;&lt;/center&gt;&lt;/td&gt;"</expr></argument>, <argument><expr><name><name>title</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;/tr&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>DoSingleHTMLTotal</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>DisplayTotals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_rods</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><name>aStr</name>?<name>aStr</name>:"No name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><name>mDumpFrameCounts</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DoGrandTotals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>mDumpFrameByFrameCounts</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DoIndiTotalsTree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

}</block></function>
<comment type="line">//------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>DisplayHTMLTotals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32x</name></cpp:ifdef> <comment type="line">// XXX NOT XP!</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>char</name> *</type> <name>sptr</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>aStr</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>sptr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>sptr</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>eptr</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>eptr</name></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>eptr</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"_stats.html"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>mFD</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mFD</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;html&gt;&lt;head&gt;&lt;title&gt;Reflow Stats&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>title</name> <init>= <expr><name>aStr</name>?<name>aStr</name>:"No name"</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;center&gt;&lt;b&gt;%s&lt;/b&gt;&lt;br&gt;&lt;table border=1 style=\"background-color:#e0e0e0\"&gt;"</expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DoGrandHTMLTotals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;/center&gt;&lt;/table&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>, <argument><expr>"&lt;/body&gt;&lt;/html&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>mFD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFD</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// not XP!</comment>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>DoClearTotals</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>ClearTotals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>ClearTotals</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>DoClearTotals</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>ClearGrandTotals</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> != <name>mCounts</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>gTots</name> <init>= <expr>(<name>ReflowCounter</name> *)<call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>gTots</name> == <name>nsnull</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>gTots</name> = new <call><name>ReflowCounter</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><call><name>NS_strdup</name><argument_list>(<argument><expr><name>kGrandTotalsStr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gTots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>gTots</name>-&gt;<name>ClearTotals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>gTots</name>-&gt;<name>SetTotalsCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>PRIntn</name></type> <name><name>ReflowCountMgr</name>::<name>DoDisplayDiffTotals</name></name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>cycledOnce</name> <init>= <expr>(<name>arg</name> != 0)</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr>(<name>char</name> *)<name><name>he</name>-&gt;<name>key</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReflowCounter</name> *</type> <name>counter</name> <init>= <expr>(<name>ReflowCounter</name> *)<name><name>he</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>cycledOnce</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>CalcDiffInTotals</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>DisplayDiffTotals</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>counter</name>-&gt;<name>SetTotalsCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<comment type="line">//------------------------------------------------------------------</comment>
<function><type><name>void</name></type> <name><name>ReflowCountMgr</name>::<name>DisplayDiffsInTotals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mCycledOnce</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Differences\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;78</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"-"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ClearGrandTotals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name>mCounts</name></expr></argument>, <argument><expr><name>DoDisplayDiffTotals</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>mCycledOnce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mCycledOnce</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_REFLOW_PERF</comment>

<comment type="line">// make a color string like #RRGGBB</comment>
<function><type><name>void</name></type> <name>ColorToString</name><parameter_list>(<param><decl><type><name>nscolor</name></type> <name>aColor</name></decl></param>, <param><decl><type><name>nsAutoString</name> &amp;</type><name>aString</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"#%02x%02x%02x"</expr></argument>,
              <argument><expr><call><name>NS_GET_R</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NS_GET_G</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NS_GET_B</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CopyASCIItoUTF16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>aString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
