<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0014459a4db78477c0adf60712aa492330cf12ec.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</comment>
<comment type="block">/* vim: set cindent tabstop=4 expandtab shiftwidth=4: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * The Mozilla Foundation.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   L. David Baron &lt;dbaron@dbaron.org&gt;, Mozilla Corporation
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="line">//</comment>
<comment type="line">// This file implements a garbage-cycle collector based on the paper</comment>
<comment type="line">// </comment>
<comment type="line">//   Concurrent Cycle Collection in Reference Counted Systems</comment>
<comment type="line">//   Bacon &amp; Rajan (2001), ECOOP 2001 / Springer LNCS vol 2072</comment>
<comment type="line">//</comment>
<comment type="line">// We are not using the concurrent or acyclic cases of that paper; so</comment>
<comment type="line">// the green, red and orange colors are not used.</comment>
<comment type="line">//</comment>
<comment type="line">// The collector is based on tracking pointers of four colors:</comment>
<comment type="line">//</comment>
<comment type="line">// Black nodes are definitely live. If we ever determine a node is</comment>
<comment type="line">// black, it's ok to forget about, drop from our records.</comment>
<comment type="line">//</comment>
<comment type="line">// White nodes are definitely garbage cycles. Once we finish with our</comment>
<comment type="line">// scanning, we unlink all the white nodes and expect that by</comment>
<comment type="line">// unlinking them they will self-destruct (since a garbage cycle is</comment>
<comment type="line">// only keeping itself alive with internal links, by definition).</comment>
<comment type="line">//</comment>
<comment type="line">// Grey nodes are being scanned. Nodes that turn grey will turn</comment>
<comment type="line">// either black if we determine that they're live, or white if we</comment>
<comment type="line">// determine that they're a garbage cycle. After the main collection</comment>
<comment type="line">// algorithm there should be no grey nodes.</comment>
<comment type="line">//</comment>
<comment type="line">// Purple nodes are *candidates* for being scanned. They are nodes we</comment>
<comment type="line">// haven't begun scanning yet because they're not old enough, or we're</comment>
<comment type="line">// still partway through the algorithm.</comment>
<comment type="line">//</comment>
<comment type="line">// XPCOM objects participating in garbage-cycle collection are obliged</comment>
<comment type="line">// to inform us when they ought to turn purple; that is, when their</comment>
<comment type="line">// refcount transitions from N+1 -&gt; N, for nonzero N. Furthermore we</comment>
<comment type="line">// require that *after* an XPCOM object has informed us of turning</comment>
<comment type="line">// purple, they will tell us when they either transition back to being</comment>
<comment type="line">// black (incremented refcount) or are ultimately deleted.</comment>


<comment type="line">// Safety:</comment>
<comment type="line">//</comment>
<comment type="line">// An XPCOM object is either scan-safe or scan-unsafe, purple-safe or</comment>
<comment type="line">// purple-unsafe.</comment>
<comment type="line">//</comment>
<comment type="line">// An object is scan-safe if:</comment>
<comment type="line">//</comment>
<comment type="line">//  - It can be QI'ed to |nsXPCOMCycleCollectionParticipant|, though this</comment>
<comment type="line">//    operation loses ISupports identity (like nsIClassInfo).</comment>
<comment type="line">//  - The operation |traverse| on the resulting</comment>
<comment type="line">//    nsXPCOMCycleCollectionParticipant does not cause *any* refcount</comment>
<comment type="line">//    adjustment to occur (no AddRef / Release calls).</comment>
<comment type="line">//</comment>
<comment type="line">// An object is purple-safe if it satisfies the following properties:</comment>
<comment type="line">//</comment>
<comment type="line">//  - The object is scan-safe.  </comment>
<comment type="line">//  - If the object calls |nsCycleCollector::suspect(this)|, </comment>
<comment type="line">//    it will eventually call |nsCycleCollector::forget(this)|, </comment>
<comment type="line">//    exactly once per call to |suspect|, before being destroyed.</comment>
<comment type="line">//</comment>
<comment type="line">// When we receive a pointer |ptr| via</comment>
<comment type="line">// |nsCycleCollector::suspect(ptr)|, we assume it is purple-safe. We</comment>
<comment type="line">// can check the scan-safety, but have no way to ensure the</comment>
<comment type="line">// purple-safety; objects must obey, or else the entire system falls</comment>
<comment type="line">// apart. Don't involve an object in this scheme if you can't</comment>
<comment type="line">// guarantee its purple-safety.</comment>
<comment type="line">//</comment>
<comment type="line">// When we have a scannable set of purple nodes ready, we begin</comment>
<comment type="line">// our walks. During the walks, the nodes we |traverse| should only</comment>
<comment type="line">// feed us more scan-safe nodes, and should not adjust the refcounts</comment>
<comment type="line">// of those nodes. </comment>
<comment type="line">//</comment>
<comment type="line">// We do not |AddRef| or |Release| any objects during scanning. We</comment>
<comment type="line">// rely on purple-safety of the roots that call |suspect| and</comment>
<comment type="line">// |forget| to hold, such that we will forget about a purple pointer</comment>
<comment type="line">// before it is destroyed.  The pointers that are merely scan-safe,</comment>
<comment type="line">// we hold only for the duration of scanning, and there should be no</comment>
<comment type="line">// objects released from the scan-safe set during the scan (there</comment>
<comment type="line">// should be no threads involved).</comment>
<comment type="line">//</comment>
<comment type="line">// We *do* call |AddRef| and |Release| on every white object, on</comment>
<comment type="line">// either side of the calls to |Unlink|. This keeps the set of white</comment>
<comment type="line">// objects alive during the unlinking.</comment>
<comment type="line">// </comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__MINGW32__</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crtdbg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCycleCollectionParticipant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIProgrammingLanguage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBaseHashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHashKeys.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDeque.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCycleCollector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prenv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPrintfCString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObserverService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsServiceManagerUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SHUTDOWN_COLLECTIONS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUTDOWN_COLLECTIONS</name><parameter_list>(<param><type><name>params</name></type></param>)</parameter_list></cpp:macro> <cpp:value>params.mShutdownCollections</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUTDOWN_COLLECTIONS</name><parameter_list>(<param><type><name>params</name></type></param>)</parameter_list></cpp:macro> <cpp:value>DEFAULT_SHUTDOWN_COLLECTIONS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Various parameters of this collector can be tuned using environment</comment>
<comment type="line">// variables.</comment>

<struct>struct <name>nsCycleCollectorParams</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mDoNothing</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mReportStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mHookMalloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mDrawGraphs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mFaultIsFatal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mLogPointers</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mShutdownCollections</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mScanDelay</name></decl>;</decl_stmt>
    
    <constructor><name>nsCycleCollectorParams</name><parameter_list>()</parameter_list> <member_list>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
        <call><name>mDoNothing</name>     <argument_list>(<argument><expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_DO_NOTHING"</expr></argument>)</argument_list></call> != <name>NULL</name></expr></argument>)</argument_list></call>,
        <call><name>mReportStats</name>   <argument_list>(<argument><expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_REPORT_STATS"</expr></argument>)</argument_list></call> != <name>NULL</name></expr></argument>)</argument_list></call>,
        <call><name>mHookMalloc</name>    <argument_list>(<argument><expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_HOOK_MALLOC"</expr></argument>)</argument_list></call> != <name>NULL</name></expr></argument>)</argument_list></call>,
        <call><name>mDrawGraphs</name>    <argument_list>(<argument><expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_DRAW_GRAPHS"</expr></argument>)</argument_list></call> != <name>NULL</name></expr></argument>)</argument_list></call>,
        <call><name>mFaultIsFatal</name>  <argument_list>(<argument><expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_FAULT_IS_FATAL"</expr></argument>)</argument_list></call> != <name>NULL</name></expr></argument>)</argument_list></call>,
        <call><name>mLogPointers</name>   <argument_list>(<argument><expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_LOG_POINTERS"</expr></argument>)</argument_list></call> != <name>NULL</name></expr></argument>)</argument_list></call>,

        <call><name>mShutdownCollections</name><argument_list>(<argument><expr><name>DEFAULT_SHUTDOWN_COLLECTIONS</name></expr></argument>)</argument_list></call>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <call><name>mDoNothing</name>     <argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">// The default number of collections to "age" candidate</comment>
        <comment type="line">// pointers in the purple buffer before we decide that any</comment>
        <comment type="line">// garbage cycle they're in has stabilized and we want to</comment>
        <comment type="line">// consider scanning it.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Making this number smaller causes:</comment>
        <comment type="line">//   - More time to be spent in the collector (bad)</comment>
        <comment type="line">//   - Less delay between forming garbage and collecting it (good)</comment>

        <call><name>mScanDelay</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    </member_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
        <decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_SCAN_DELAY"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>s</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>PR_sscanf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr>&amp;<name>mScanDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>s</name> = <call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_SHUTDOWN_COLLECTIONS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>s</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>PR_sscanf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr>&amp;<name>mShutdownCollections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></constructor>
</public>}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<comment type="line">// Various operations involving the collector are recorded in a</comment>
<comment type="line">// statistics table. These are for diagnostics.</comment>

<struct>struct <name>nsCycleCollectorStats</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFailedQI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSuccessfulQI</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mVisitedNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mWalkedGraph</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCollectedBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFreeCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFreedBytes</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSetColorGrey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSetColorBlack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSetColorWhite</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFailedUnlink</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCollectedNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mBumpGeneration</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mZeroGeneration</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSuspectNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSpills</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mForgetNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFreedWhilePurple</name></decl>;</decl_stmt>
  
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCollection</name></decl>;</decl_stmt>

    <constructor><name>nsCycleCollectorStats</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsCycleCollectorStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>
  
    <function><type><name>void</name></type> <name>Dump</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\f\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP</name><parameter_list>(<param><type><name>entry</name></type></param>)</parameter_list></cpp:macro> <cpp:value>fprintf(stderr, "%30.30s: %-20.20d\n", #entry, entry)</cpp:value></cpp:define>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mFailedQI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mSuccessfulQI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mVisitedNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mWalkedGraph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mCollectedBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mFreeCalls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mFreedBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mSetColorGrey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mSetColorBlack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mSetColorWhite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mFailedUnlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mCollectedNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mBumpGeneration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mZeroGeneration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mSuspectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mSpills</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mForgetNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mFreedWhilePurple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>DUMP</name><argument_list>(<argument><expr><name>mCollection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DUMP</name></cpp:undef>
    }</block></function>
</public>}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>PRBool</name></type>
<name>nsCycleCollector_shouldSuppress</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Base types</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<struct_decl>struct <name>PtrInfo</name>;</struct_decl>

<class>class <name>EdgePool</name>
<block>{<private type="default">
</private><public>public:
    <comment type="line">// EdgePool allocates arrays of void*, primarily to hold PtrInfo*.</comment>
    <comment type="line">// However, at the end of a block, the last two pointers are a null</comment>
    <comment type="line">// and then a void** pointing to the next block.  This allows</comment>
    <comment type="line">// EdgePool::Iterators to be a single word but still capable of crossing</comment>
    <comment type="line">// block boundaries.</comment>

    <constructor><name>EdgePool</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>mSentinelAndBlocks</name><index>[<expr>0</expr>]</index></name>.<name>block</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mSentinelAndBlocks</name><index>[<expr>1</expr>]</index></name>.<name>block</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></constructor>

    <destructor><name>~<name>EdgePool</name></name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Block</name> *</type><name>b</name> <init>= <expr><call><name>Blocks</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>b</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Block</name> *</type><name>next</name> <init>= <expr><call><name><name>b</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr>delete <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> = <name>next</name></expr>;</expr_stmt>
        }</block></while>
    }</block></destructor>

</public><private>private:
    <struct_decl>struct <name>Block</name>;</struct_decl>
    <union>union <name>PtrInfoOrBlock</name> <block>{<public type="default">
        <comment type="line">// Use a union to avoid reinterpret_cast and the ensuing</comment>
        <comment type="line">// potential aliasing bugs.</comment>
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>ptrInfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Block</name> *</type><name>block</name></decl>;</decl_stmt>
    </public>}</block>;</union>
    <struct>struct <name>Block</name> <block>{<public type="default">
        <enum>enum <block>{ <decl><name>BlockSize</name> <init>= <expr>64 * 1024</expr></init></decl> }</block>;</enum>

        <decl_stmt><decl><type><name>PtrInfoOrBlock</name></type> <name><name>mPointers</name><index>[<expr><name>BlockSize</name></expr>]</index></name></decl>;</decl_stmt>
        <constructor><name>Block</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><name><name>mPointers</name><index>[<expr><name>BlockSize</name> - 2</expr>]</index></name>.<name>block</name> = <name>nsnull</name></expr>;</expr_stmt> <comment type="line">// sentinel</comment>
            <expr_stmt><expr><name><name>mPointers</name><index>[<expr><name>BlockSize</name> - 1</expr>]</index></name>.<name>block</name> = <name>nsnull</name></expr>;</expr_stmt> <comment type="line">// next block pointer</comment>
        }</block></constructor>
        <function><type><name>Block</name>*&amp;</type> <name>Next</name><parameter_list>()</parameter_list>
            <block>{ <return>return <expr><name><name>mPointers</name><index>[<expr><name>BlockSize</name> - 1</expr>]</index></name>.<name>block</name></expr>;</return> }</block></function>
        <function><type><name>PtrInfoOrBlock</name>*</type> <name>Start</name><parameter_list>()</parameter_list>
            <block>{ <return>return <expr>&amp;<name><name>mPointers</name><index>[<expr>0</expr>]</index></name></expr>;</return> }</block></function>
        <function><type><name>PtrInfoOrBlock</name>*</type> <name>End</name><parameter_list>()</parameter_list>
            <block>{ <return>return <expr>&amp;<name><name>mPointers</name><index>[<expr><name>BlockSize</name> - 2</expr>]</index></name></expr>;</return> }</block></function>
    </public>}</block>;</struct>

    <comment type="line">// Store the null sentinel so that we can have valid iterators</comment>
    <comment type="line">// before adding any edges and without adding any blocks.</comment>
    <decl_stmt><decl><type><name>PtrInfoOrBlock</name></type> <name><name>mSentinelAndBlocks</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

    <function><type><name>Block</name>*&amp;</type> <name>Blocks</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name><name>mSentinelAndBlocks</name><index>[<expr>1</expr>]</index></name>.<name>block</name></expr>;</return> }</block></function>

</private><public>public:
    <class>class <name>Iterator</name>
    <block>{<private type="default">
    </private><public>public:
        <constructor><name>Iterator</name><parameter_list>()</parameter_list> <member_list>: <call><name>mPointer</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
        <constructor><name>Iterator</name><parameter_list>(<param><decl><type><name>PtrInfoOrBlock</name> *</type><name>aPointer</name></decl></param>)</parameter_list> <member_list>: <call><name>mPointer</name><argument_list>(<argument><expr><name>aPointer</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
        <constructor><name>Iterator</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Iterator</name>&amp;</type> <name>aOther</name></decl></param>)</parameter_list> <member_list>: <call><name>mPointer</name><argument_list>(<argument><expr><name><name>aOther</name>.<name>mPointer</name></name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

        <function><type><name>Iterator</name>&amp;</type> <name>operator++</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>mPointer</name>-&gt;<name>ptrInfo</name></name> == <name>nsnull</name></expr>)</condition><then> <block>{
                <comment type="line">// Null pointer is a sentinel for link to the next block.</comment>
                <expr_stmt><expr><name>mPointer</name> = (<name>mPointer</name> + 1)-&gt;<name><name>block</name>-&gt;<name>mPointers</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr>++<name>mPointer</name></expr>;</expr_stmt>
            <return>return <expr>*<name>this</name></expr>;</return>
        }</block></function>

        <function><type><name>PtrInfo</name>*</type> <name>operator*</name><parameter_list>()</parameter_list> <specifier>const</specifier>
        <block>{
            <if>if <condition>(<expr><name><name>mPointer</name>-&gt;<name>ptrInfo</name></name> == <name>nsnull</name></expr>)</condition><then> <block>{
                <comment type="line">// Null pointer is a sentinel for link to the next block.</comment>
                <return>return <expr>(<name>mPointer</name> + 1)-&gt;<name><name>block</name>-&gt;<name>mPointers</name>-&gt;<name>ptrInfo</name></name></expr>;</return>
            }</block></then></if>
            <return>return <expr><name><name>mPointer</name>-&gt;<name>ptrInfo</name></name></expr>;</return>
        }</block></function>
        <function><type><name>PRBool</name></type> <name>operator==</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Iterator</name>&amp;</type> <name>aOther</name></decl></param>)</parameter_list> <specifier>const</specifier>
            <block>{ <return>return <expr><name>mPointer</name> == <name><name>aOther</name>.<name>mPointer</name></name></expr>;</return> }</block></function>
        <function><type><name>PRBool</name></type> <name>operator!=</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Iterator</name>&amp;</type> <name>aOther</name></decl></param>)</parameter_list> <specifier>const</specifier>
            <block>{ <return>return <expr><name>mPointer</name> != <name><name>aOther</name>.<name>mPointer</name></name></expr>;</return> }</block></function>

    </public><private>private:
        <decl_stmt><decl><type><name>PtrInfoOrBlock</name> *</type><name>mPointer</name></decl>;</decl_stmt>
    </private>}</block>;</class>

    <class_decl>class <name>Builder</name>;</class_decl>
    <class_decl><specifier>friend</specifier> class <name>Builder</name>;</class_decl>
    <class>class <name>Builder</name> <block>{<private type="default">
    </private><public>public:
        <constructor><name>Builder</name><parameter_list>(<param><decl><type><name>EdgePool</name> &amp;</type><name>aPool</name></decl></param>)</parameter_list>
            <member_list>: <call><name>mCurrent</name><argument_list>(<argument><expr>&amp;<name><name>aPool</name>.<name>mSentinelAndBlocks</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>,
              <call><name>mBlockEnd</name><argument_list>(<argument><expr>&amp;<name><name>aPool</name>.<name>mSentinelAndBlocks</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>,
              <call><name>mNextBlockPtr</name><argument_list>(<argument><expr>&amp;<call><name><name>aPool</name>.<name>Blocks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
        </member_list><block>{
        }</block></constructor>

        <function><type><name>Iterator</name></type> <name>Mark</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>Iterator</name><argument_list>(<argument><expr><name>mCurrent</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

        <function><type><name>void</name></type> <name>Add</name><parameter_list>(<param><decl><type><name>PtrInfo</name>*</type> <name>aEdge</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>mCurrent</name> == <name>mBlockEnd</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Block</name> *</type><name>b</name> <init>= <expr>new <call><name>Block</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>b</name></expr>)</condition><then> <block>{
                    <comment type="line">// This means we just won't collect (some) cycles.</comment>
                    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"out of memory, ignoring edges"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>
                <expr_stmt><expr>*<name>mNextBlockPtr</name> = <name>b</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mCurrent</name> = <call><name><name>b</name>-&gt;<name>Start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mBlockEnd</name> = <call><name><name>b</name>-&gt;<name>End</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mNextBlockPtr</name> = &amp;<call><name><name>b</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr>(<name>mCurrent</name>++)-&gt;<name>ptrInfo</name> = <name>aEdge</name></expr>;</expr_stmt>
        }</block></function>
    </public><private>private:
        <comment type="line">// mBlockEnd points to space for null sentinel</comment>
        <decl_stmt><decl><type><name>PtrInfoOrBlock</name> *</type><name>mCurrent</name></decl>, *<decl><type ref="prev"/><name>mBlockEnd</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Block</name> **</type><name>mNextBlockPtr</name></decl>;</decl_stmt>
    </private>}</block>;</class>

</public>}</block>;</class>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>

<struct>struct <name>ReversedEdge</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>mTarget</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReversedEdge</name> *</type><name>mNext</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<enum>enum <name>NodeColor</name> <block>{ <decl><name>black</name></decl>, <decl><name>white</name></decl>, <decl><name>grey</name></decl> }</block>;</enum>

<comment type="line">// This structure should be kept as small as possible; we may expect</comment>
<comment type="line">// a million of them to be allocated and touched repeatedly during</comment>
<comment type="line">// each cycle collection.</comment>

<struct>struct <name>PtrInfo</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>void</name> *</type><name>mPointer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>mParticipant</name></decl>;</decl_stmt>
    <macro><name>PRUint32</name></macro> <label><name>mColor</name> :</label> <expr_stmt><expr>2</expr>;</expr_stmt>
    <macro><name>PRUint32</name></macro> <label><name>mInternalRefs</name> :</label> <expr_stmt><expr>30</expr>;</expr_stmt>
    <macro><name>PRUint32</name></macro> <label><name>mRefCount</name> :</label> <expr_stmt><expr>31</expr>;</expr_stmt>
    <macro><name>PRUint32</name></macro> <label><name>mWasPurple</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>mFirstChild</name></decl>;</decl_stmt> <comment type="line">// first</comment>
    <decl_stmt><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>mLastChild</name></decl>;</decl_stmt> <comment type="line">// one after last</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type> <name>mBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>mName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mLangID</name></decl>;</decl_stmt>

    <comment type="line">// For finding roots in ExplainLiveExpectedGarbage (when there are</comment>
    <comment type="line">// missing calls to suspect or failures to unlink).</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSCCIndex</name></decl>;</decl_stmt> <comment type="line">// strongly connected component</comment>

    <comment type="line">// For finding roots in ExplainLiveExpectedGarbage (when nodes</comment>
    <comment type="line">// expected to be garbage are black).</comment>
    <decl_stmt><decl><type><name>ReversedEdge</name>*</type> <name>mReversedEdges</name></decl>;</decl_stmt> <comment type="line">// linked list</comment>
    <decl_stmt><decl><type><name>PtrInfo</name>*</type> <name>mShortestPathToExpectedGarbage</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <macro><name>PtrInfo</name><argument_list>(<argument>void *aPointer</argument>, <argument>nsCycleCollectionParticipant *aParticipant
            IF_DEBUG_CC_PARAM(PRUint32 aLangID)</argument>
            )</argument_list></macro>
        : <constructor><name>mPointer</name><parameter_list>(<param><decl><type><name>aPointer</name></type></decl></param>)</parameter_list>,
          <name>mParticipant</name>(<name>aParticipant</name></constructor></public>)</block>,
          <expr_stmt><expr><call><name>mColor</name><argument_list>(<argument><expr><name>grey</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mInternalRefs</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mRefCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mWasPurple</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mFirstChild</name><argument_list>()</argument_list></call></expr>,
          <expr><call><name>mLastChild</name><argument_list>()</argument_list></call></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
        , <expr><call><name>mBytes</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mName</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mLangID</name><argument_list>(<argument><expr><name>aLangID</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mSCCIndex</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mReversedEdges</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>,
          <macro><name>mShortestPathToExpectedGarbage</name><argument_list>(<argument>nsnull</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{
    }</block>

    <comment type="line">// Allow uninitialized values in large arrays.</comment>
    <macro><name>PtrInfo</name><argument_list>()</argument_list></macro> <block>{}</block></expr></expr_stmt></struct>
};

<comment type="block" format="doxygen">/**
 * A structure designed to be used like a linked list of PtrInfo, except
 * that allocates the PtrInfo 32K-at-a-time.
 */</comment>
<class>class <name>NodePool</name>
<block>{<private type="default">
</private><private>private:
    <enum>enum <block>{ <decl><name>BlockSize</name> <init>= <expr>32 * 1024</expr></init></decl> }</block>;</enum> <comment type="line">// could be int template parameter</comment>

    <struct>struct <name>Block</name> <block>{<public type="default">
        <decl_stmt><decl><type><name>Block</name>*</type> <name>mNext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PtrInfo</name></type> <name><name>mEntries</name><index>[<expr><name>BlockSize</name></expr>]</index></name></decl>;</decl_stmt>

        <constructor><name>Block</name><parameter_list>()</parameter_list> <member_list>: <call><name>mNext</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
    </public>}</block>;</struct>

</private><public>public:
    <constructor><name>NodePool</name><parameter_list>()</parameter_list>
        <member_list>: <call><name>mBlocks</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
          <call><name>mLast</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>

    <destructor><name>~<name>NodePool</name></name><parameter_list>()</parameter_list>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
        <block>{
            <decl_stmt><decl><type><name>Enumerator</name></type> <name>queue</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>PL_strfree</name><argument_list>(<argument><expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call>-&gt;<name>mName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>Block</name> *</type><name>b</name> <init>= <expr><name>mBlocks</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>b</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>Block</name> *</type><name>n</name> <init>= <expr><name><name>b</name>-&gt;<name>mNext</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr>delete <name>b</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> = <name>n</name></expr>;</expr_stmt>
        }</block></while>
    }</block></destructor>

    <class_decl>class <name>Builder</name>;</class_decl>
    <class_decl><specifier>friend</specifier> class <name>Builder</name>;</class_decl>
    <class>class <name>Builder</name> <block>{<private type="default">
    </private><public>public:
        <constructor><name>Builder</name><parameter_list>(<param><decl><type><name>NodePool</name>&amp;</type> <name>aPool</name></decl></param>)</parameter_list>
            <member_list>: <call><name>mNextBlock</name><argument_list>(<argument><expr>&amp;<name><name>aPool</name>.<name>mBlocks</name></name></expr></argument>)</argument_list></call>,
              <call><name>mNext</name><argument_list>(<argument><expr><name><name>aPool</name>.<name>mLast</name></name></expr></argument>)</argument_list></call>,
              <call><name>mBlockEnd</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
        </member_list><block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aPool</name>.<name>mBlocks</name></name> == <name>nsnull</name> &amp;&amp; <name><name>aPool</name>.<name>mLast</name></name> == <name>nsnull</name></expr></argument>,
                         <argument><expr>"pool not empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>Add</name><argument_list>(<argument><expr><name>void</name> *<name>aPointer</name></expr></argument>, <argument><expr><name>nsCycleCollectionParticipant</name> *<name>aParticipant</name>
                     <macro><name>IF_DEBUG_CC_PARAM</name><argument_list>(<argument>PRUint32 aLangID</argument>)</argument_list></macro></expr></argument>
                    )</argument_list>
        <argument_list>{
            if <argument><expr>(<name>mNext</name> == <name>mBlockEnd</name>) <block>{
                <expr><name>Block</name> *<name>block</name></expr>;
                <if>if <condition>(<expr>!(*<name>mNextBlock</name> = <name>block</name> = new <call><name>Block</name><argument_list>()</argument_list></call>)</expr>)</condition><then>
                    <return>return <expr><name>nsnull</name></expr>;</return></then></if>
                <name>mNext</name> = <name><name>block</name>-&gt;<name>mEntries</name></name></block></expr></argument>;
                <argument><expr><name>mBlockEnd</name> = <name><name>block</name>-&gt;<name>mEntries</name></name> + <name>BlockSize</name></expr></argument>;
                <argument><expr><name>mNextBlock</name> = &amp;<name><name>block</name>-&gt;<name>mNext</name></name></expr></argument>;
            }</argument_list>
            return new <argument_list>(<argument><expr><name>mNext</name>++</expr></argument>)</argument_list> <name>PtrInfo</name><argument_list>(<argument><expr><name>aPointer</name></expr></argument>, <argument><expr><name>aParticipant</name>
                                         <call><name>IF_DEBUG_CC_PARAM</name><argument_list>(<argument><expr><name>aLangID</name></expr></argument>)</argument_list></call></expr></argument>
                                        )</argument_list></decl>;</decl_stmt>
        </public>}</block>
    <decl>private<range>:
        <expr><name>Block</name> **<name>mNextBlock</name></expr></range></decl>;</class>
        <decl_stmt><decl><type><name>PtrInfo</name> *&amp;</type><name>mNext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>mBlockEnd</name></decl>;</decl_stmt>
    </public>}</block>;</class>

    <class_decl>class <name>Enumerator</name>;</class_decl>
    <class_decl><specifier>friend</specifier> class <name>Enumerator</name>;</class_decl>
    <class>class <name>Enumerator</name> <block>{<private type="default">
    </private><public>public:
        <constructor><name>Enumerator</name><parameter_list>(<param><decl><type><name>NodePool</name>&amp;</type> <name>aPool</name></decl></param>)</parameter_list>
            <member_list>: <call><name>mFirstBlock</name><argument_list>(<argument><expr><name><name>aPool</name>.<name>mBlocks</name></name></expr></argument>)</argument_list></call>,
              <call><name>mCurBlock</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
              <call><name>mNext</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
              <call><name>mBlockEnd</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
              <call><name>mLast</name><argument_list>(<argument><expr><name><name>aPool</name>.<name>mLast</name></name></expr></argument>)</argument_list></call>
        </member_list><block>{
        }</block></constructor>

        <function><type><name>PRBool</name></type> <name>IsDone</name><parameter_list>()</parameter_list> <specifier>const</specifier>
        <block>{
            <return>return <expr><name>mNext</name> == <name>mLast</name></expr>;</return>
        }</block></function>

        <function><type><name>PtrInfo</name>*</type> <name>GetNext</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>IsDone</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"calling GetNext when done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>mNext</name> == <name>mBlockEnd</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Block</name> *</type><name>nextBlock</name> <init>= <expr><name>mCurBlock</name> ? <name><name>mCurBlock</name>-&gt;<name>mNext</name></name> : <name>mFirstBlock</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>mNext</name> = <name><name>nextBlock</name>-&gt;<name>mEntries</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mBlockEnd</name> = <name>mNext</name> + <name>BlockSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mCurBlock</name> = <name>nextBlock</name></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>mNext</name>++</expr>;</return>
        }</block></function>
    </public><private>private:
        <decl_stmt><decl><type><name>Block</name> *</type><name>mFirstBlock</name></decl>, *<decl><type ref="prev"/><name>mCurBlock</name></decl>;</decl_stmt>
        <comment type="line">// mNext is the next value we want to return, unless mNext == mBlockEnd</comment>
        <comment type="line">// NB: mLast is a reference to allow enumerating while building!</comment>
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>mNext</name></decl>, *<decl><type ref="prev"/><name>mBlockEnd</name></decl>, *&amp;<decl><type ref="prev"/><name>mLast</name></decl>;</decl_stmt>
    </private>}</block>;</class>

<private>private:
    <decl_stmt><decl><type><name>Block</name> *</type><name>mBlocks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>mLast</name></decl>;</decl_stmt>
</private>};


<struct_decl>struct <name>GCGraph</name>;</struct_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>GCGraph</name> *</type><name>sCurrGraph</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

<struct>struct <name>GCGraph</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>NodePool</name></type> <name>mNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EdgePool</name></type> <name>mEdges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mRootCount</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ReversedEdge</name> *</type><name>mReversedEdges</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <constructor><name>GCGraph</name><parameter_list>()</parameter_list> <member_list>: <call><name>mRootCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> </member_list><block>{
        <expr_stmt><expr><name>sCurrGraph</name> = <name>this</name></expr>;</expr_stmt>
    }</block></constructor>
    <destructor><name>~<name>GCGraph</name></name><parameter_list>()</parameter_list> <block>{ 
        <expr_stmt><expr><name>sCurrGraph</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></destructor>
</public>}</block>;</struct>

<comment type="line">// XXX Would be nice to have an nsHashSet&lt;KeyType&gt; API that has</comment>
<comment type="line">// Add/Remove/Has rather than PutEntry/RemoveEntry/GetEntry.</comment>
<typedef>typedef <type><name><name>nsTHashtable</name><argument_list>&lt;<argument><expr><name>nsVoidPtrHashKey</name></expr></argument>&gt;</argument_list></name></type> <name>PointerSet</name>;</typedef>
<typedef>typedef <type><name><name>nsBaseHashtable</name><argument_list>&lt;<argument><expr><name>nsVoidPtrHashKey</name></expr></argument>, <argument><expr><name>PRUint32</name></expr></argument>, <argument><expr><name>PRUint32</name></expr></argument>&gt;</argument_list></name></type>
    <name>PointerSetWithGeneration</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>WriteGraph</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>redPtr</name></decl></param>)</parameter_list>;</function_decl>

<struct>struct <name>nsPurpleBuffer</name>
<block>{<public type="default">

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSOCIATIVITY</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_LOW_BIT</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_INDEX_BITS</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_ENTRIES</name></cpp:macro> <cpp:value>(1 &lt;&lt; N_INDEX_BITS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_POINTERS</name></cpp:macro> <cpp:value>(N_ENTRIES * ASSOCIATIVITY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOTAL_BYTES</name></cpp:macro> <cpp:value>(N_POINTERS * PR_BYTES_PER_WORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEX_MASK</name></cpp:macro> <cpp:value>PR_BITMASK(N_INDEX_BITS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POINTER_INDEX</name><parameter_list>(<param><type><name>P</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((((PRUword)P) &gt;&gt; INDEX_LOW_BIT) &amp; (INDEX_MASK))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>INDEX_LOW_BIT</name> + <name>N_INDEX_BITS</name> &gt; (8 * <name>PR_BYTES_PER_WORD</name>))</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "index bit overflow"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// This class serves as a generational wrapper around a pldhash</comment>
    <comment type="line">// table: a subset of generation zero lives in mCache, the</comment>
    <comment type="line">// remainder spill into the mBackingStore hashtable. The idea is</comment>
    <comment type="line">// to get a higher hit rate and greater locality of reference for</comment>
    <comment type="line">// generation zero, in which the vast majority of suspect/forget</comment>
    <comment type="line">// calls annihilate one another.</comment>

    <decl_stmt><decl><type><name>nsCycleCollectorParams</name> &amp;</type><name>mParams</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>nsCycleCollectorStats</name> &amp;</type><name>mStats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>void</name>*</type> <name><name>mCache</name><index>[<expr><name>N_POINTERS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCurrGen</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>PointerSetWithGeneration</name></type> <name>mBackingStore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsDeque</name> *</type><name>mTransferBuffer</name></decl>;</decl_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <constructor><name>nsPurpleBuffer</name><parameter_list>(<param><decl><type><name>nsCycleCollectorParams</name> &amp;</type><name>params</name></decl></param>,
                   <param><decl><type><name>nsCycleCollectorStats</name> &amp;</type><name>stats</name></decl></param>)</parameter_list> 
        <member_list>: <call><name>mParams</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call>,
          <call><name>mStats</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call>,
          <call><name>mCurrGen</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
          <call><name>mTransferBuffer</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    </member_list><block>{
        <expr_stmt><expr><call><name>Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <constructor><name>nsPurpleBuffer</name><parameter_list>(<param><decl><type><name>nsCycleCollectorParams</name> &amp;</type><name>params</name></decl></param>)</parameter_list> 
        <member_list>: <call><name>mParams</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call>,
          <call><name>mCurrGen</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
          <call><name>mTransferBuffer</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    </member_list><block>{
        <expr_stmt><expr><call><name>Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <destructor><name>~<name>nsPurpleBuffer</name></name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mCache</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mBackingStore</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></destructor>

    <function><type><name>void</name></type> <name>Init</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mCache</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mBackingStore</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function_decl><type><name>void</name></type> <name>BumpGeneration</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>SelectAgedPointers</name><parameter_list>(<param><decl><type><name>nsDeque</name> *</type><name>transferBuffer</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>PRBool</name></type> <name>Exists</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>idx</name> <init>= <expr><call><name>POINTER_INDEX</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>ASSOCIATIVITY</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>mCache</name><index>[<expr><name>idx</name>+<name>i</name></expr>]</index></name> == <name>p</name></expr>)</condition><then>
                <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
        }</block></for>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>gen</name></decl>;</decl_stmt>
        <return>return <expr><call><name><name>mBackingStore</name>.<name>Get</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>gen</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name>Put</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>idx</name> <init>= <expr><call><name>POINTER_INDEX</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>ASSOCIATIVITY</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<name><name>mCache</name><index>[<expr><name>idx</name>+<name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>mCache</name><index>[<expr><name>idx</name>+<name>i</name></expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
        }</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
        <expr_stmt><expr><name><name>mStats</name>.<name>mSpills</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>SpillOne</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>Remove</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>     
    <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>idx</name> <init>= <expr><call><name>POINTER_INDEX</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>ASSOCIATIVITY</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>mCache</name><index>[<expr><name>idx</name>+<name>i</name></expr>]</index></name> == <name>p</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>mCache</name><index>[<expr><name>idx</name>+<name>i</name></expr>]</index></name> = (<name>void</name>*)0</expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>mBackingStore</name>.<name>Remove</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>SpillOne</name><parameter_list>(<param><decl><type><name>void</name>* &amp;</type><name>p</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>mBackingStore</name>.<name>Put</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>mCurrGen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> = (<name>void</name>*)0</expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>SpillAll</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>N_POINTERS</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>mCache</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>SpillOne</name><argument_list>(<argument><expr><name><name>mCache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></function>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name>zeroGenerationCallback</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type>  <name>ptr</name></decl></param>,
                       <param><decl><type><name>PRUint32</name>&amp;</type>    <name>generation</name></decl></param>,
                       <param><decl><type><name>void</name>*</type>        <name>userArg</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>nsPurpleBuffer</name> *</type><name>purp</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsPurpleBuffer</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>userArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>purp</name>-&gt;<name>mStats</name>.<name>mZeroGeneration</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>generation</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsPurpleBuffer</name>::<name>BumpGeneration</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>SpillAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mCurrGen</name> == 0xffffffff</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mBackingStore</name>.<name>Enumerate</name></name><argument_list>(<argument><expr><name>zeroGenerationCallback</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mCurrGen</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr>++<name>mCurrGen</name></expr>;</expr_stmt>
    }</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>mStats</name>.<name>mBumpGeneration</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>PRBool</name></type>
<name>SufficientlyAged</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>generation</name></decl></param>, <param><decl><type><name>nsPurpleBuffer</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>generation</name> + <name><name>p</name>-&gt;<name>mParams</name>.<name>mScanDelay</name></name> &lt; <name><name>p</name>-&gt;<name>mCurrGen</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name>ageSelectionCallback</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type>  <name>ptr</name></decl></param>,
                     <param><decl><type><name>PRUint32</name>&amp;</type>    <name>generation</name></decl></param>,
                     <param><decl><type><name>void</name>*</type>        <name>userArg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsPurpleBuffer</name> *</type><name>purp</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsPurpleBuffer</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>userArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>SufficientlyAged</name><argument_list>(<argument><expr><name>generation</name></expr></argument>, <argument><expr><name>purp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsISupports</name> *</type><name>root</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsISupports</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>purp</name>-&gt;<name>mTransferBuffer</name>-&gt;<name>Push</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsPurpleBuffer</name>::<name>SelectAgedPointers</name></name><parameter_list>(<param><decl><type><name>nsDeque</name> *</type><name>transferBuffer</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Rely on our caller having done a BumpGeneration first, which in</comment>
    <comment type="line">// turn calls SpillAll.</comment>
    <expr_stmt><expr><name>mTransferBuffer</name> = <name>transferBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mBackingStore</name>.<name>Enumerate</name></name><argument_list>(<argument><expr><name>ageSelectionCallback</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mTransferBuffer</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>



<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Implement the LanguageRuntime interface for C++/XPCOM </comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>


<struct>struct <name>nsCycleCollectionXPCOMRuntime</name> <super>: 
    <specifier>public</specifier> <name>nsCycleCollectionLanguageRuntime</name></super> 
<block>{<public type="default">
    <function><type><name>nsresult</name></type> <name>BeginCycleCollection</name><parameter_list>()</parameter_list> 
    <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <function><type><name>nsresult</name></type> <name>FinishCycleCollection</name><parameter_list>()</parameter_list> 
    <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <function_decl><type><specifier>inline</specifier> <name>nsCycleCollectionParticipant</name> *</type><name>ToParticipant</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <function><type><specifier>virtual</specifier> <name>void</name></type> <name>PrintAllReferencesTo</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{}</block></function>
    <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SuspectExtraPointers</name><parameter_list>()</parameter_list> <block>{}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>

<struct>struct <name>nsCycleCollector</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mCollectionInProgress</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mScanInProgress</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsCycleCollectionLanguageRuntime</name> *</type><name><name>mRuntimes</name><index>[<expr><name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name>+1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCycleCollectionXPCOMRuntime</name></type> <name>mXPCOMRuntime</name></decl>;</decl_stmt>

    <comment type="line">// The buffer |mBuf| serves a variety of purposes; mostly involving the</comment>
    <comment type="line">// transfer of pointers from a hashtable iterator routine to some outer</comment>
    <comment type="line">// logic that might also need to mutate the hashtable.</comment>

    <decl_stmt><decl><type><name>nsDeque</name></type> <name>mBuf</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>nsCycleCollectorParams</name></type> <name>mParams</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsPurpleBuffer</name></type> <name>mPurpleBuf</name></decl>;</decl_stmt>

    <function_decl><type><name>void</name></type> <name>RegisterRuntime</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>, 
                         <param><decl><type><name>nsCycleCollectionLanguageRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>ForgetRuntime</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>SelectPurple</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>MarkRoots</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>ScanRoots</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>PRBool</name></type> <name>CollectWhite</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>;</function_decl> <comment type="line">// returns whether anything collected</comment>

    <constructor_decl><name>nsCycleCollector</name><parameter_list>()</parameter_list>;</constructor_decl>
    <destructor_decl><name>~<name>nsCycleCollector</name></name><parameter_list>()</parameter_list>;</destructor_decl>

    <function_decl><type><name>PRBool</name></type> <name>Suspect</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>current</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>PRBool</name></type> <name>Forget</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>Allocated</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>n</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>sz</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>Freed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>n</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>Collect</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTryCollections</name> <init>= <expr>1</expr></init></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>Shutdown</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>nsCycleCollectorStats</name></type> <name>mStats</name></decl>;</decl_stmt>    

    <decl_stmt><decl><type><name>FILE</name> *</type><name>mPtrLog</name></decl>;</decl_stmt>

    <function_decl><type><name>void</name></type> <name>MaybeDrawGraphs</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>ExplainLiveExpectedGarbage</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>PRBool</name></type> <name>CreateReversedEdges</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>DestroyReversedEdges</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>ShouldBeFreed</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>WasFreed</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>PointerSet</name></type> <name>mExpectedGarbage</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>


<class>class <name>GraphWalker</name>
<block>{<private type="default">
</private><private>private:
    <function_decl><type><name>void</name></type> <name>DoWalk</name><parameter_list>(<param><decl><type><name>nsDeque</name> &amp;</type><name>aQueue</name></decl></param>)</parameter_list>;</function_decl>

</private><public>public:
    <function_decl><type><name>void</name></type> <name>Walk</name><parameter_list>(<param><decl><type><name>PtrInfo</name> *</type><name>s0</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>WalkFromRoots</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>aGraph</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// Provided by concrete walker subtypes.</comment>
    <function_decl><type><specifier>virtual</specifier> <name>PRBool</name></type> <name>ShouldVisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> <specifier>const</specifier> *</type><name>pi</name></decl></param>)</parameter_list> = 0;</function_decl>
    <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>VisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> *</type><name>pi</name></decl></param>)</parameter_list> = 0;</function_decl>
</public>}</block>;</class>


<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// The static collector object</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>


<decl_stmt><decl><type><specifier>static</specifier> <name>nsCycleCollector</name> *</type><name>sCollector</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>


<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Utility functions</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Fault</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ptr</name><init>=<expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <comment type="line">// This should be nearly impossible, but just in case.</comment>
    <if>if <condition>(<expr>!<name>sCollector</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name><name>sCollector</name>-&gt;<name>mParams</name>.<name>mFaultIsFatal</name></name></expr>)</condition><then> <block>{

        <if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Fatal fault in cycle collector: %s (ptr: %p)\n"</expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Fatal fault in cycle collector: %s\n"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

     
        <if>if <condition>(<expr><name>sCurrGraph</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>FILE</name> *</type><name>stream</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>fname</name><index>[]</index></name> <init>= <expr>"c:\\fault-graph.dot"</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>fname</name><index>[]</index></name> <init>= <expr>"/tmp/fault-graph.dot"</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"depositing faulting cycle-collection graph in %s\n"</expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>stream</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"w+"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>WriteGraph</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>*<name>sCurrGraph</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if> 

        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr><call><name>nsPrintfCString</name><argument_list>(<argument><expr>256</expr></argument>,
                  <argument><expr>"Fault in cycle collector: %s (ptr: %p)\n"</expr></argument>,
                  <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// When faults are not fatal, we assume we're running in a</comment>
    <comment type="line">// production environment and we therefore want to disable the</comment>
    <comment type="line">// collector on a fault. This will unfortunately cause the browser</comment>
    <comment type="line">// to leak pretty fast wherever creates cyclical garbage, but it's</comment>
    <comment type="line">// probably a better user experience than crashing. Besides, we</comment>
    <comment type="line">// *should* never hit a fault.</comment>

    <expr_stmt><expr><name><name>sCollector</name>-&gt;<name>mParams</name>.<name>mDoNothing</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Fault</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PtrInfo</name> *</type><name>pi</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Fault in cycle collector: %s\n"
           "  while operating on pointer %p %s\n"</expr></argument>,
           <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  which has internal references from:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>sCurrGraph</name>-&gt;<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
        <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>ppi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>e</name> <init>= <expr><name><name>ppi</name>-&gt;<name>mFirstChild</name></name></expr></init>, <name>e_end</name> <init>= <expr><name><name>ppi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
                 <condition><expr><name>e</name> != <name>e_end</name></expr>;</condition> <incr><expr>++<name>e</name></expr></incr>) <block>{
                <if>if <condition>(<expr>*<name>e</name> == <name>pi</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"    %p %s\n"</expr></argument>, <argument><expr><name><name>ppi</name>-&gt;<name>mPointer</name></name></expr></argument>, <argument><expr><name><name>ppi</name>-&gt;<name>mName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></while>
    }</block></then></if>

    <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>inline</specifier> <name>void</name></type>
<name>Fault</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>PtrInfo</name> *</type><name>pi</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function><type><specifier>static</specifier> <name>nsISupports</name> *</type>
<name>canonicalize</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>child</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>in</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsCycleCollectionISupports</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>child</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ToParticipant</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>s</name></decl></param>, <param><decl><type><name>nsXPCOMCycleCollectionParticipant</name> **</type><name>cp</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// We use QI to move from an nsISupports to an</comment>
    <comment type="line">// nsXPCOMCycleCollectionParticipant, which is a per-class singleton helper</comment>
    <comment type="line">// object that implements traversal and unlinking logic for the nsISupports</comment>
    <comment type="line">// in question.</comment>
    <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <if>if <condition>(<expr><name>cp</name></expr>)</condition><then>
        <expr_stmt><expr>++<name><name>sCollector</name>-&gt;<name>mStats</name>.<name>mSuccessfulQI</name></name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr>++<name><name>sCollector</name>-&gt;<name>mStats</name>.<name>mFailedQI</name></name></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>nsCycleCollectionParticipant</name> *</type>
<name><name>nsCycleCollectionXPCOMRuntime</name>::<name>ToParticipant</name></name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name> *</type><name>cp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>::<name>ToParticipant</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsISupports</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cp</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name><name>GraphWalker</name>::<name>Walk</name></name><parameter_list>(<param><decl><type><name>PtrInfo</name> *</type><name>s0</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDeque</name></type> <name>queue</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>queue</name>.<name>Push</name></name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DoWalk</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>GraphWalker</name>::<name>WalkFromRoots</name></name><parameter_list>(<param><decl><type><name>GCGraph</name>&amp;</type> <name>aGraph</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDeque</name></type> <name>queue</name></decl>;</decl_stmt>
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor</name><parameter_list>(<param><decl><type><name><name>aGraph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>aGraph</name>.<name>mRootCount</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>queue</name>.<name>Push</name></name><argument_list>(<argument><expr><call><name><name>etor</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>DoWalk</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>GraphWalker</name>::<name>DoWalk</name></name><parameter_list>(<param><decl><type><name>nsDeque</name> &amp;</type><name>aQueue</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Use a aQueue to match the breadth-first traversal used when we</comment>
    <comment type="line">// built the graph, for hopefully-better locality.</comment>
    <while>while <condition>(<expr><call><name><name>aQueue</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PtrInfo</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>aQueue</name>.<name>PopFront</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>this</name>-&gt;<name>ShouldVisitNode</name></name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>this</name>-&gt;<name>VisitNode</name></name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>child</name> <init>= <expr><name><name>pi</name>-&gt;<name>mFirstChild</name></name></expr></init>,
                                <name>child_end</name> <init>= <expr><name><name>pi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
                 <condition><expr><name>child</name> != <name>child_end</name></expr>;</condition> <incr><expr>++<name>child</name></expr></incr>) <block>{
                <expr_stmt><expr><call><name><name>aQueue</name>.<name>Push</name></name><argument_list>(<argument><expr>*<name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></while><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>sCollector</name>-&gt;<name>mStats</name>.<name>mWalkedGraph</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Bacon &amp; Rajan's |MarkRoots| routine.</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<struct>struct <name>PtrToNodeEntry</name> <super>: <specifier>public</specifier> <name>PLDHashEntryHdr</name></super>
<block>{<public type="default">
    <comment type="line">// The key is mNode-&gt;mPointer</comment>
    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>mNode</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>PtrToNodeMatchEntry</name><argument_list>(<argument>PLDHashTable *table</argument>,
                    <argument>const PLDHashEntryHdr *entry</argument>,
                    <argument>const void *key</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PtrToNodeEntry</name> *</type><name>n</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>PtrToNodeEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>n</name>-&gt;<name>mNode</name>-&gt;<name>mPointer</name></name> == <name>key</name></expr>;</return>
}</block>

<decl_stmt><decl><type><specifier>static</specifier> <name>PLDHashTableOps</name></type> <name>PtrNodeOps</name> <init>= <expr><block>{
    <expr><name>PL_DHashAllocTable</name></expr>,
    <expr><name>PL_DHashFreeTable</name></expr>,
    <expr><name>PL_DHashVoidPtrKeyStub</name></expr>,
    <expr><name>PtrToNodeMatchEntry</name></expr>,
    <expr><name>PL_DHashMoveEntryStub</name></expr>,
    <expr><name>PL_DHashClearEntryStub</name></expr>,
    <expr><name>PL_DHashFinalizeStub</name></expr>,
    <expr><name>nsnull</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<class>class <name>GCGraphBuilder</name> <super>: <specifier>private</specifier> <name>nsCycleCollectionTraversalCallback</name></super>
<block>{<private type="default">
</private><private>private:
    <decl_stmt><decl><type><name><name>NodePool</name>::<name>Builder</name></name></type> <name>mNodeBuilder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>EdgePool</name>::<name>Builder</name></name></type> <name>mEdgeBuilder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLDHashTable</name></type> <name>mPtrToNodeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>mCurrPi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCycleCollectionLanguageRuntime</name> **</type><name>mRuntimes</name></decl>;</decl_stmt> <comment type="line">// weak, from nsCycleCollector</comment>

</private><public>public:
    <constructor_decl><name>GCGraphBuilder</name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>aGraph</name></decl></param>,
                   <param><decl><type><name>nsCycleCollectionLanguageRuntime</name> **</type><name>aRuntimes</name></decl></param>)</parameter_list>;</constructor_decl>
    <destructor_decl><name>~<name>GCGraphBuilder</name></name><parameter_list>()</parameter_list>;</destructor_decl>

    <function><type><name>PRUint32</name></type> <name>Count</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name><name>mPtrToNodeMap</name>.<name>entryCount</name></name></expr>;</return> }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <function_decl><type><name>PtrInfo</name>*</type> <name>AddNode</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>s</name></decl></param>, <param><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>aParticipant</name></decl></param>,
                     <param><decl><type><name>PRUint32</name></type> <name>aLangID</name></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <function_decl><type><name>PtrInfo</name>*</type> <name>AddNode</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>s</name></decl></param>, <param><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>aParticipant</name></decl></param>)</parameter_list>;</function_decl>
    <function><type><name>PtrInfo</name>*</type> <name>AddNode</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>s</name></decl></param>, <param><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>aParticipant</name></decl></param>,
                     <param><decl><type><name>PRUint32</name></type> <name>aLangID</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>AddNode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>aParticipant</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <function_decl><type><name>void</name></type> <name>Traverse</name><parameter_list>(<param><decl><type><name>PtrInfo</name>*</type> <name>aPtrInfo</name></decl></param>)</parameter_list>;</function_decl>

</public><private>private:
    <comment type="line">// nsCycleCollectionTraversalCallback methods.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>DescribeNode</name><parameter_list>(<param><decl><type><name>nsrefcnt</name></type> <name>refCount</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>objSz</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>objName</name></decl></param>)</parameter_list>;</constructor_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>DescribeNode</name><parameter_list>(<param><decl><type><name>nsrefcnt</name></type> <name>refCount</name></decl></param>)</parameter_list>;</constructor_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>NoteXPCOMChild</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>child</name></decl></param>)</parameter_list>;</constructor_decl>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>NoteNativeChild</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>child</name></decl></param>,
                                     <param><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>participant</name></decl></param>)</parameter_list>;</constructor_decl>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor_decl><name>NoteScriptChild</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>, <param><decl><type><name>void</name> *</type><name>child</name></decl></param>)</parameter_list>;</constructor_decl>
</private>}</block>;</class>

<constructor><name><name>GCGraphBuilder</name>::<name>GCGraphBuilder</name></name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>aGraph</name></decl></param>,
                               <param><decl><type><name>nsCycleCollectionLanguageRuntime</name> **</type><name>aRuntimes</name></decl></param>)</parameter_list>
    <member_list>: <call><name>mNodeBuilder</name><argument_list>(<argument><expr><name><name>aGraph</name>.<name>mNodes</name></name></expr></argument>)</argument_list></call>,
      <call><name>mEdgeBuilder</name><argument_list>(<argument><expr><name><name>aGraph</name>.<name>mEdges</name></name></expr></argument>)</argument_list></call>,
      <call><name>mRuntimes</name><argument_list>(<argument><expr><name>aRuntimes</name></expr></argument>)</argument_list></call>
</member_list><block>{
    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>mPtrToNodeMap</name></expr></argument>, <argument><expr>&amp;<name>PtrNodeOps</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PtrToNodeEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>32768</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>mPtrToNodeMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt></then></if>
}</block></constructor>

<destructor><name><name>GCGraphBuilder</name>::~<name>GCGraphBuilder</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>mPtrToNodeMap</name>.<name>ops</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>PL_DHashTableFinish</name><argument_list>(<argument><expr>&amp;<name>mPtrToNodeMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></destructor>

<decl_stmt><decl><type><name>PtrInfo</name>*</type>
<name><name>GCGraphBuilder</name>::<name>AddNode</name></name><argument_list>(<argument><expr><name>void</name> *<name>s</name></expr></argument>, <argument><expr><name>nsCycleCollectionParticipant</name> *<name>aParticipant</name>
                        <macro><name>IF_DEBUG_CC_PARAM</name><argument_list>(<argument>PRUint32 aLangID</argument>)</argument_list></macro></expr></argument>
                       )</argument_list>
<argument_list>{
    <argument><expr><name>PtrToNodeEntry</name> *<name>e</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PtrToNodeEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mPtrToNodeMap</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><name>PtrInfo</name> *<name>result</name></expr></argument>;
    if <argument><expr>(!<name><name>e</name>-&gt;<name>mNode</name></name>) <block>{
        <comment type="line">// New entry.</comment>
        <expr><name>result</name> = <macro><name>mNodeBuilder</name></macro>.<macro><name>Add</name><argument_list>(<argument>s</argument>, <argument>aParticipant
                                  IF_DEBUG_CC_PARAM(aLangID)</argument>
                                 )</argument_list></macro></expr>;
        <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <expr_stmt><expr><block>{
            <expr><call><name>PL_DHashTableRawRemove</name><argument_list>(<argument><expr>&amp;<name>mPtrToNodeMap</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt></then></if>
            <return>return <expr><name>nsnull</name></expr>;</return>
        }</block>
        <name><name>e</name>-&gt;<name>mNode</name></name> = <name>result</name></expr></argument>;
    }</argument_list> else <argument_list>{
        <argument><expr><name>result</name> = <name><name>e</name>-&gt;<name>mNode</name></name></expr></argument>;
        <argument><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>mParticipant</name></name> == <name>aParticipant</name></expr></argument>,
                     <argument><expr>"nsCycleCollectionParticipant shouldn't change!"</expr></argument>)</argument_list></call></expr></argument>;
    }</argument_list>
    return <name>result</name></decl>;</decl_stmt>
}

void
<macro><name>GCGraphBuilder</name></macro><expr_stmt><expr><name>::<name>Traverse</name></name>(<name>PtrInfo</name>* <name>aPtrInfo</name>)
<block>{
    <expr><name>mCurrPi</name> = <name>aPtrInfo</name></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <if>if <condition>(<expr>!<name><name>mCurrPi</name>-&gt;<name>mParticipant</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"unknown pointer during walk"</expr></argument>, <argument><expr><name>aPtrInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    <expr_stmt/></block></then></if>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <name><name>mCurrPi</name>-&gt;<name>mFirstChild</name></name> = <call><name><name>mEdgeBuilder</name>.<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aPtrInfo</name>-&gt;<name>mParticipant</name>-&gt;<name>Traverse</name></name><argument_list>(<argument><expr><name><name>aPtrInfo</name>-&gt;<name>mPointer</name></name></expr></argument>, <argument><expr>*<name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"script pointer traversal failed"</expr></argument>, <argument><expr><name>aPtrInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>mCurrPi</name>-&gt;<name>mLastChild</name></name> = <call><name><name>mEdgeBuilder</name>.<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}

NS_IMETHODIMP_<expr_stmt><expr>(<name>void</name>)
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<macro><name>GCGraphBuilder</name></macro><name>::<name>DescribeNode</name></name>(<name>nsrefcnt</name> <name>refCount</name>, <name>size_t</name> <name>objSz</name>, const <name>char</name> *<name>objName</name>)
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>GCGraphBuilder</name></macro><name>::<name>DescribeNode</name></name>(<name>nsrefcnt</name> <name>refCount</name>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr><name><name>mCurrPi</name>-&gt;<name>mBytes</name></name> = <name>objSz</name></expr>;
    <expr><name><name>mCurrPi</name>-&gt;<name>mName</name></name> = <call><name>PL_strdup</name><argument_list>(<argument><expr><name>objName</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>refCount</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"zero refcount"</expr></argument>, <argument><expr><name>mCurrPi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <name><name>mCurrPi</name>-&gt;<name>mRefCount</name></name> = <name>refCount</name></block></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>sCollector</name>-&gt;<name>mStats</name>.<name>mVisitedNode</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

NS_IMETHODIMP_<expr_stmt><expr>(<name>void</name>)
<macro><name>GCGraphBuilder</name></macro><name>::<name>NoteXPCOMChild</name></name>(<name>nsISupports</name> *<name>child</name>) 
<block>{
    <if>if <condition>(<expr>!<name>child</name> || !(<name>child</name> = <call><name>canonicalize</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return;</return></then></if></block></expr></expr_stmt> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>nsCycleCollector_shouldSuppress</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name> *</type><name>cp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ToParticipant</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cp</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>childPi</name> <init>= <expr><call><name>AddNode</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>nsIProgrammingLanguage</name>::<name>CPLUSPLUS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>childPi</name></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name><name>mEdgeBuilder</name>.<name>Add</name></name><argument_list>(<argument><expr><name>childPi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name><name>childPi</name>-&gt;<name>mInternalRefs</name></name></expr>;</expr_stmt>
    }</block></then></if>
}

NS_IMETHODIMP_<expr_stmt><expr>(<name>void</name>)
<macro><name>GCGraphBuilder</name></macro><name>::<name>NoteNativeChild</name></name>(<name>void</name> *<name>child</name>,
                                <name>nsCycleCollectionParticipant</name> *<name>participant</name>)
<block>{
    <if>if <condition>(<expr>!<name>child</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>participant</name></expr></argument>, <argument><expr>"Need a nsCycleCollectionParticipant!"</expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>childPi</name> <init>= <expr><call><name>AddNode</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>participant</name></expr></argument>, <argument><expr><name><name>nsIProgrammingLanguage</name>::<name>CPLUSPLUS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>childPi</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name><name>mEdgeBuilder</name>.<name>Add</name></name><argument_list>(<argument><expr><name>childPi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>++<name><name>childPi</name>-&gt;<name>mInternalRefs</name></name></expr>;</expr_stmt>
}

NS_IMETHODIMP_<expr_stmt><expr>(<name>void</name>)
<macro><name>GCGraphBuilder</name></macro><name>::<name>NoteScriptChild</name></name>(<name>PRUint32</name> <name>langID</name>, <name>void</name> *<name>child</name>) 
<block>{
    <if>if <condition>(<expr>!<name>child</name></expr>)</condition><then>
        <return>return;</return></then></if></block></expr></expr_stmt>

    <if>if <condition>(<expr><name>langID</name> &gt; <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name> || !<name><name>mRuntimes</name><index>[<expr><name>langID</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"traversing pointer for unregistered language"</expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>cp</name> <init>= <expr><name><name>mRuntimes</name><index>[<expr><name>langID</name></expr>]</index></name>-&gt;<call><name>ToParticipant</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>cp</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>childPi</name> <init>= <expr><call><name>AddNode</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>langID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>childPi</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name><name>mEdgeBuilder</name>.<name>Add</name></name><argument_list>(<argument><expr><name>childPi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>++<name><name>childPi</name>-&gt;<name>mInternalRefs</name></name></expr>;</expr_stmt>
}


void 
<macro><name>nsCycleCollector</name></macro><expr_stmt><expr><name>::<name>SelectPurple</name></name>()
<block>{
    <expr><call><name><name>mPurpleBuf</name>.<name>BumpGeneration</name></name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>mPurpleBuf</name>.<name>SelectAgedPointers</name></name><argument_list>(<argument><expr>&amp;<name>mBuf</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name>
<macro><name>nsCycleCollector</name></macro><name>::<name>MarkRoots</name></name>(<name>GCGraph</name> &amp;<name>graph</name>)
<block>{
    <if>if <condition>(<expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
        <return>return;</return></then></if>

    <name>GCGraphBuilder</name> <call><name>builder</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>mRuntimes</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsISupports</name> *</type><name>s</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsISupports</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mBuf</name>.<name>ObjectAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name> *</type><name>cp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ToParticipant</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>cp</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>builder</name>.<name>AddNode</name></name><argument_list>(<argument><expr><call><name>canonicalize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cp</name></expr></argument>,
                                             <argument><expr><name><name>nsIProgrammingLanguage</name>::<name>CPLUSPLUS</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>pinfo</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>pinfo</name>-&gt;<name>mWasPurple</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><name><name>graph</name>.<name>mRootCount</name></name> = <call><name><name>builder</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// read the PtrInfo out of the graph that we are building</comment>
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>builder</name>.<name>Traverse</name></name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}


<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Bacon &amp; Rajan's |ScanRoots| routine.</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>


struct <label><name>ScanBlackWalker</name> :</label> <expr_stmt><expr>public <name>GraphWalker</name>
<block>{
    <expr><name>PRBool</name> <macro><name>ShouldVisitNode</name><argument_list>(<argument>PtrInfo const *pi</argument>)</argument_list></macro>
    <block>{ 
        <return>return <expr><name><name>pi</name>-&gt;<name>mColor</name></name> != <name>black</name></expr>;</return></block></expr>
    }</block>

    <name>void</name> <macro><name>VisitNode</name><argument_list>(<argument>PtrInfo *pi</argument>)</argument_list></macro>
    <block>{ 
        <expr><name><name>pi</name>-&gt;<name>mColor</name></name> = <name>black</name></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
        <expr><name><name>sCollector</name>-&gt;<name>mStats</name>.<name>mSetColorBlack</name></name>++</expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr></expr_stmt>
};


<struct>struct <name>scanWalker</name> <super>: <specifier>public</specifier> <name>GraphWalker</name></super>
<block>{<public type="default">
    <function><type><name>PRBool</name></type> <name>ShouldVisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> <specifier>const</specifier> *</type><name>pi</name></decl></param>)</parameter_list>
    <block>{ 
        <return>return <expr><name><name>pi</name>-&gt;<name>mColor</name></name> == <name>grey</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name>VisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> *</type><name>pi</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mColor</name></name> != <name>grey</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"scanning non-grey node"</expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name> &gt; <name><name>pi</name>-&gt;<name>mRefCount</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"traversed refs exceed refcount"</expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name> == <name><name>pi</name>-&gt;<name>mRefCount</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pi</name>-&gt;<name>mColor</name></name> = <name>white</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
            <expr_stmt><expr><name><name>sCollector</name>-&gt;<name>mStats</name>.<name>mSetColorWhite</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ScanBlackWalker</name><argument_list>()</argument_list></call>.<call><name>Walk</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>pi</name>-&gt;<name>mColor</name></name> == <name>black</name></expr></argument>,
                         <argument><expr>"Why didn't ScanBlackWalker make pi black?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>
</public>}</block>;</struct>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>ScanRoots</name></name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// On the assumption that most nodes will be black, it's</comment>
    <comment type="line">// probably faster to use a GraphWalker than a</comment>
    <comment type="line">// NodePool::Enumerator.</comment>
    <expr_stmt><expr><call><name>scanWalker</name><argument_list>()</argument_list></call>.<call><name>WalkFromRoots</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <comment type="line">// Sanity check: scan should have colored all grey nodes black or</comment>
    <comment type="line">// white. So we ensure we have no grey nodes at this point.</comment>
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>etor</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>etor</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>pinfo</name>-&gt;<name>mColor</name></name> == <name>grey</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"valid grey node after scanning"</expr></argument>, <argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Bacon &amp; Rajan's |CollectWhite| routine, somewhat modified.</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<function><type><name>PRBool</name></type>
<name><name>nsCycleCollector</name>::<name>CollectWhite</name></name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Explanation of "somewhat modified": we have no way to collect the</comment>
    <comment type="line">// set of whites "all at once", we have to ask each of them to drop</comment>
    <comment type="line">// their outgoing links and assume this will cause the garbage cycle</comment>
    <comment type="line">// to *mostly* self-destruct (except for the reference we continue</comment>
    <comment type="line">// to hold). </comment>
    <comment type="line">// </comment>
    <comment type="line">// To do this "safely" we must make sure that the white nodes we're</comment>
    <comment type="line">// operating on are stable for the duration of our operation. So we</comment>
    <comment type="line">// make 3 sets of calls to language runtimes:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   - Root(whites), which should pin the whites in memory.</comment>
    <comment type="line">//   - Unlink(whites), which drops outgoing links on each white.</comment>
    <comment type="line">//   - Unroot(whites), which returns the whites to normal GC.</comment>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>mBuf</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_CC</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type>struct <name>_CrtMemState</name></type> <name>ms1</name></decl>, <decl><type ref="prev"/><name>ms2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>_CrtMemCheckpoint</name><argument_list>(<argument><expr>&amp;<name>ms1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>etor</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>etor</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><name><name>pinfo</name>-&gt;<name>mPointer</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>pinfo</name>-&gt;<name>mColor</name></name> == <name>white</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>mBuf</name>.<name>Push</name></name><argument_list>(<argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>pinfo</name>-&gt;<name>mWasPurple</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>nsISupports</name>*</type> <name>s</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsISupports</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PRBool</name></type> <name>forgetResult</name> <init>= <expr><call><name>Forget</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>forgetResult</name></expr></argument>, <argument><expr>"Forget failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>pinfo</name>-&gt;<name>mWasPurple</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsISupports</name>*</type> <name>s</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsISupports</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name>*</type> <name>cp</name> <init>=
                <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsXPCOMCycleCollectionParticipant</name>*</expr></argument>&gt;</argument_list></name>
                           <argument_list>(<argument><expr><name><name>pinfo</name>-&gt;<name>mParticipant</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name>*</type> <name>checkcp</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>checkcp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>checkcp</name> == <name>cp</name></expr></argument>,
                         <argument><expr>"QI should return the same participant!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name><name>cp</name>-&gt;<name>UnmarkPurple</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>PRBool</name></type> <name>forgetResult</name> <init>= <expr><call><name>Forget</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>forgetResult</name></expr></argument>, <argument><expr>"Forget failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></while>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PtrInfo</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mBuf</name>.<name>ObjectAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>pinfo</name>-&gt;<name>mParticipant</name>-&gt;<name>Root</name></name><argument_list>(<argument><expr><name><name>pinfo</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"Failed root call while unlinking"</expr></argument>, <argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PtrInfo</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mBuf</name>.<name>ObjectAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>pinfo</name>-&gt;<name>mParticipant</name>-&gt;<name>Unlink</name></name><argument_list>(<argument><expr><name><name>pinfo</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"Failed unlink call while unlinking"</expr></argument>, <argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
            <expr_stmt><expr><name><name>mStats</name>.<name>mFailedUnlink</name></name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then>
        <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
            <expr_stmt><expr>++<name><name>mStats</name>.<name>mCollectedNode</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
    }</block></for>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PtrInfo</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mBuf</name>.<name>ObjectAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>pinfo</name>-&gt;<name>mParticipant</name>-&gt;<name>Unroot</name></name><argument_list>(<argument><expr><name><name>pinfo</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"Failed unroot call while unlinking"</expr></argument>, <argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

    <expr_stmt><expr><call><name><name>mBuf</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_CC</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>_CrtMemCheckpoint</name><argument_list>(<argument><expr>&amp;<name>ms2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>ms2</name>.<name>lTotalCount</name></name> &lt; <name><name>ms1</name>.<name>lTotalCount</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>mStats</name>.<name>mFreedBytes</name></name> += (<name><name>ms1</name>.<name>lTotalCount</name></name> - <name><name>ms2</name>.<name>lTotalCount</name></name>)</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>count</name> &gt; 0</expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Memory-hooking stuff</comment>
<comment type="line">// When debugging wild pointers, it sometimes helps to hook malloc and</comment>
<comment type="line">// free. This stuff is disabled unless you set an environment variable.</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>hookedMalloc</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GLIBC__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name>*</type> (*<name>old_memalign_hook</name>)<parameter_list>(<param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name>*</type> (*<name>old_realloc_hook</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name>*</type> (*<name>old_malloc_hook</name>)<parameter_list>(<param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (*<name>old_free_hook</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name>*</type> <name>my_memalign_hook</name><parameter_list>(<param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name>*</type> <name>my_realloc_hook</name><parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name>*</type> <name>my_malloc_hook</name><parameter_list>(<param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>my_free_hook</name><parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>void</name> *</decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> 
<name>install_old_hooks</name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>__memalign_hook</name> = <name>old_memalign_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>__realloc_hook</name> = <name>old_realloc_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>__malloc_hook</name> = <name>old_malloc_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>__free_hook</name> = <name>old_free_hook</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> 
<name>save_old_hooks</name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Glibc docs recommend re-saving old hooks on</comment>
    <comment type="line">// return from recursive calls. Strangely when </comment>
    <comment type="line">// we do this, we find ourselves in infinite</comment>
    <comment type="line">// recursion.</comment>

    <comment type="line">//     old_memalign_hook = __memalign_hook;</comment>
    <comment type="line">//     old_realloc_hook = __realloc_hook;</comment>
    <comment type="line">//     old_malloc_hook = __malloc_hook;</comment>
    <comment type="line">//     old_free_hook = __free_hook;</comment>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> 
<name>install_new_hooks</name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>__memalign_hook</name> = <name>my_memalign_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>__realloc_hook</name> = <name>my_realloc_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>__malloc_hook</name> = <name>my_malloc_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>__free_hook</name> = <name>my_free_hook</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name>*</type>
<name>my_realloc_hook</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>caller</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>    

    <expr_stmt><expr><call><name>install_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>save_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Freed</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Allocated</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>install_new_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name>*</type> 
<name>my_memalign_hook</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>alignment</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>caller</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>    

    <expr_stmt><expr><call><name>install_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>memalign</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>save_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Allocated</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>install_new_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> 
<name>my_free_hook</name> <parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>caller</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>install_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>save_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Freed</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>install_new_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>      


<function><type><specifier>static</specifier> <name>void</name>*</type>
<name>my_malloc_hook</name> <parameter_list>(<param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>caller</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>install_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>malloc</name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>save_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Allocated</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>install_new_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> 
<name>InitMemHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>hookedMalloc</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>save_old_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>install_new_hooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hookedMalloc</name> = <name>PR_TRUE</name></expr>;</expr_stmt>        
    }</block></then></if>
}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__MINGW32__</name></cpp:ifndef>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>AllocHook</name><parameter_list>(<param><decl><type><name>int</name></type> <name>allocType</name></decl></param>, <param><decl><type><name>void</name> *</type><name>userData</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>int</name></type> 
          <name>blockType</name></decl></param>, <param><decl><type><name>long</name></type> <name>requestNumber</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>int</name></type> 
          <name>lineNumber</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>allocType</name> == <name>_HOOK_FREE</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Freed</name></name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>InitMemHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>hookedMalloc</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>_CrtSetAllocHook</name> <argument_list>(<argument><expr><name>AllocHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hookedMalloc</name> = <name>PR_TRUE</name></expr>;</expr_stmt>        
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// __MINGW32__</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>0</expr></cpp:elif> <comment type="line">// defined(XP_MACOSX)</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc/malloc.h&gt;</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (*<name>old_free</name>)<parameter_list>(<param><decl><type>struct <name>_malloc_zone_t</name> *</type><name>zone</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>freehook</name><parameter_list>(<param><decl><type>struct <name>_malloc_zone_t</name> *</type><name>zone</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Freed</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>old_free</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitMemHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>hookedMalloc</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>malloc_zone_t</name> *</type><name>default_zone</name> <init>= <expr><call><name>malloc_default_zone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>old_free</name> = <name><name>default_zone</name>-&gt;<name>free</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>default_zone</name>-&gt;<name>free</name></name> = <name>freehook</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hookedMalloc</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitMemHook</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// GLIBC / WIN32 / OSX</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// DEBUG_CC</comment>

<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Collector implementation</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<constructor><name><name>nsCycleCollector</name>::<name>nsCycleCollector</name></name><parameter_list>()</parameter_list> <member_list>: 
    <call><name>mCollectionInProgress</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mScanInProgress</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <call><name>mPurpleBuf</name><argument_list>(<argument><expr><name>mParams</name></expr></argument>, <argument><expr><name>mStats</name></expr></argument>)</argument_list></call>,
    <call><name>mPtrLog</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <call><name>mPurpleBuf</name><argument_list>(<argument><expr><name>mParams</name></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</member_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>mExpectedGarbage</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mRuntimes</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mRuntimes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name><name>nsIProgrammingLanguage</name>::<name>CPLUSPLUS</name></name></expr>]</index></name> = &amp;<name>mXPCOMRuntime</name></expr>;</expr_stmt>
}</block></constructor>


<destructor><name><name>nsCycleCollector</name>::~<name>nsCycleCollector</name></name><parameter_list>()</parameter_list>
<block>{
}</block></destructor>


<function><type><name>void</name></type> 
<name><name>nsCycleCollector</name>::<name>RegisterRuntime</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>, 
                                  <param><decl><type><name>nsCycleCollectionLanguageRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>mParams</name>.<name>mDoNothing</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name>langID</name> &gt; <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"unknown language runtime in registration"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>mRuntimes</name><index>[<expr><name>langID</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"multiple registrations of language runtime"</expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>langID</name></expr>]</index></name> = <name>rt</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type> 
<name><name>nsCycleCollector</name>::<name>ForgetRuntime</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>mParams</name>.<name>mDoNothing</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name>langID</name> &gt; <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"unknown language runtime in deregistration"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>! <name><name>mRuntimes</name><index>[<expr><name>langID</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"forgetting non-registered language runtime"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>langID</name></expr>]</index></name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteGraph</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>redPtr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, 
            <argument><expr>"digraph collection {\n"
            "rankdir=LR\n"
            "node [fontname=fixed, fontsize=10, style=filled, shape=box]\n"</expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
    
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>etor</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>etor</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name> <init>= <expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, 
                <argument><expr>"n%p [label=\"%s\\n%p\\n%u/%u refs found\", "
                "fillcolor=%s, fontcolor=%s]\n"</expr></argument>, 
                <argument><expr><name>p</name></expr></argument>,
                <argument><expr><name><name>pi</name>-&gt;<name>mName</name></name></expr></argument>,
                <argument><expr><name>p</name></expr></argument>,
                <argument><expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mRefCount</name></name></expr></argument>,
                <argument><expr>(<name>redPtr</name> &amp;&amp; <name>redPtr</name> == <name>p</name> ? "red" : (<name><name>pi</name>-&gt;<name>mColor</name></name> == <name>black</name> ? "black" : "white"))</expr></argument>,
                <argument><expr>(<name><name>pi</name>-&gt;<name>mColor</name></name> == <name>black</name> ? "white" : "black")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>child</name> <init>= <expr><name><name>pi</name>-&gt;<name>mFirstChild</name></name></expr></init>,
                 <name>child_end</name> <init>= <expr><name><name>pi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
             <condition><expr><name>child</name> != <name>child_end</name></expr>;</condition> <incr><expr>++<name>child</name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"n%p -&gt; n%p\n"</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>(*<name>child</name>)-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></while>
    
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"\n}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>    
}</block></function>


<function><type><name>void</name></type> 
<name><name>nsCycleCollector</name>::<name>MaybeDrawGraphs</name></name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>mParams</name>.<name>mDrawGraphs</name></name></expr>)</condition><then> <block>{
        <comment type="line">// We draw graphs only if there were any white nodes.</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>anyWhites</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>fwetor</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
        <while>while <condition>(<expr>!<call><name><name>fwetor</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pinfo</name> <init>= <expr><call><name><name>fwetor</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>pinfo</name>-&gt;<name>mColor</name></name> == <name>white</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>anyWhites</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></while>

        <if>if <condition>(<expr><name>anyWhites</name></expr>)</condition><then> <block>{
            <comment type="line">// We can't just use _popen here because graphviz-for-windows</comment>
            <comment type="line">// doesn't set up its stdin stream properly, sigh.</comment>
            <decl_stmt><decl><type><name>FILE</name> *</type><name>stream</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            <expr_stmt><expr><name>stream</name> = <call><name>fopen</name><argument_list>(<argument><expr>"c:\\cycle-graph.dot"</expr></argument>, <argument><expr>"w+"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>stream</name> = <call><name>popen</name><argument_list>(<argument><expr>"dotty -"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>WriteGraph</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
            <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Even dotty doesn't work terribly well on windows, since</comment>
            <comment type="line">// they execute lefty asynchronously. So we'll just run </comment>
            <comment type="line">// lefty ourselves.</comment>
            <expr_stmt><expr><call><name>_spawnlp</name><argument_list>(<argument><expr><name>_P_WAIT</name></expr></argument>, 
                     <argument><expr>"lefty"</expr></argument>, 
                     <argument><expr>"lefty"</expr></argument>,
                     <argument><expr>"-e"</expr></argument>,
                     <argument><expr>"\"load('dotty.lefty');"
                     "dotty.simple('c:\\cycle-graph.dot');\""</expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr>"c:\\cycle-graph.dot"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<class>class <name>Suppressor</name> <super>:
    <specifier>public</specifier> <name>nsCycleCollectionTraversalCallback</name></super>
<block>{<private type="default">
</private><protected>protected:
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>sSuppressionList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>sInitialized</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mSuppressThisNode</name></decl>;</decl_stmt>
</protected><public>public:
    <constructor><name>Suppressor</name><parameter_list>()</parameter_list>
    <block>{
    }</block></constructor>

    <function><type><name>PRBool</name></type> <name>shouldSuppress</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>s</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name>sInitialized</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>sSuppressionList</name> = <call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_CC_SUPPRESS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sInitialized</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>sSuppressionList</name> == <name>nsnull</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mSuppressThisNode</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name> *</type><name>cp</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"checking suppression on wrong type of pointer"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>PR_TRUE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>cp</name>-&gt;<name>Traverse</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>*<name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>mSuppressThisNode</name></expr>;</return>
    }</block></function>

    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor><name>DescribeNode</name><parameter_list>(<param><decl><type><name>nsrefcnt</name></type> <name>refCount</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>objSz</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>objName</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>mSuppressThisNode</name> = (<call><name>PL_strstr</name><argument_list>(<argument><expr><name>sSuppressionList</name></expr></argument>, <argument><expr><name>objName</name></expr></argument>)</argument_list></call> != <name>nsnull</name>)</expr>;</expr_stmt>
    }</block></constructor>

    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor><name>NoteXPCOMChild</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>child</name></decl></param>)</parameter_list> <block>{}</block></constructor>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor><name>NoteScriptChild</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>, <param><decl><type><name>void</name> *</type><name>child</name></decl></param>)</parameter_list> <block>{}</block></constructor>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <constructor><name>NoteNativeChild</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>child</name></decl></param>,
                                     <param><decl><type><name>nsCycleCollectionParticipant</name> *</type><name>participant</name></decl></param>)</parameter_list> <block>{}</block></constructor>
</public>}</block>;</class>

<decl_stmt><decl><type><name>char</name> *</type><name><name>Suppressor</name>::<name>sSuppressionList</name></name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>Suppressor</name>::<name>sInitialized</name></name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>nsCycleCollector_shouldSuppress</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Suppressor</name></type> <name>supp</name></decl>;</decl_stmt>
    <return>return <expr><call><name><name>supp</name>.<name>shouldSuppress</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>nsCycleCollector_isScanSafe</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsXPCOMCycleCollectionParticipant</name> *</type><name>cp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ToParticipant</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>cp</name> != <name>nsnull</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PRBool</name></type>
<name><name>nsCycleCollector</name>::<name>Suspect</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>current</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Re-entering ::Suspect during collection used to be a fault, but</comment>
    <comment type="line">// we are canonicalizing nsISupports pointers using QI, so we will</comment>
    <comment type="line">// see some spurious refcount traffic here. </comment>

    <if>if <condition>(<expr><name>mScanInProgress</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>nsCycleCollector_isScanSafe</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"suspected a non-scansafe pointer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_IsMainThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"trying to suspect from non-main thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>mParams</name>.<name>mDoNothing</name></name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>mStats</name>.<name>mSuspectNode</name></name>++</expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>nsCycleCollector_shouldSuppress</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__MINGW32__</name></cpp:ifndef>
    <if>if <condition>(<expr><name><name>mParams</name>.<name>mHookMalloc</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>InitMemHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>mParams</name>.<name>mLogPointers</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>mPtrLog</name></expr>)</condition><then>
            <expr_stmt><expr><name>mPtrLog</name> = <call><name>fopen</name><argument_list>(<argument><expr>"pointer_log"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mPtrLog</name></expr></argument>, <argument><expr>"S %p\n"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>current</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mBuf</name>.<name>Push</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>mPurpleBuf</name>.<name>Put</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>nsCycleCollector</name>::<name>Forget</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Re-entering ::Forget during collection used to be a fault, but</comment>
    <comment type="line">// we are canonicalizing nsISupports pointers using QI, so we will</comment>
    <comment type="line">// see some spurious refcount traffic here. </comment>

    <if>if <condition>(<expr><name>mScanInProgress</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_IsMainThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"trying to forget from non-main thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name><name>mParams</name>.<name>mDoNothing</name></name></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if> <comment type="line">// it's as good as forgotten</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><name><name>mStats</name>.<name>mForgetNode</name></name>++</expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__MINGW32__</name></cpp:ifndef>
    <if>if <condition>(<expr><name><name>mParams</name>.<name>mHookMalloc</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>InitMemHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>mParams</name>.<name>mLogPointers</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>mPtrLog</name></expr>)</condition><then>
            <expr_stmt><expr><name>mPtrLog</name> = <call><name>fopen</name><argument_list>(<argument><expr>"pointer_log"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mPtrLog</name></expr></argument>, <argument><expr>"F %p\n"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name><name>mPurpleBuf</name>.<name>Remove</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
<function><type><name>void</name></type> 
<name><name>nsCycleCollector</name>::<name>Allocated</name></name><parameter_list>(<param><decl><type><name>void</name> *</type><name>n</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>sz</name></decl></param>)</parameter_list>
<block>{
}</block></function>

<function><type><name>void</name></type> 
<name><name>nsCycleCollector</name>::<name>Freed</name></name><parameter_list>(<param><decl><type><name>void</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>mStats</name>.<name>mFreeCalls</name></name>++</expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>n</name></expr>)</condition><then> <block>{
        <comment type="line">// Ignore null pointers coming through</comment>
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>mPurpleBuf</name>.<name>Exists</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>mStats</name>.<name>mForgetNode</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mStats</name>.<name>mFreedWhilePurple</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"freed while purple"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mPurpleBuf</name>.<name>Remove</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><name><name>mParams</name>.<name>mLogPointers</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>mPtrLog</name></expr>)</condition><then>
                <expr_stmt><expr><name>mPtrLog</name> = <call><name>fopen</name><argument_list>(<argument><expr>"pointer_log"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>mPtrLog</name></expr></argument>, <argument><expr>"R %p\n"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>Collect</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aTryCollections</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_CC</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr>!<name><name>mParams</name>.<name>mDoNothing</name></name> &amp;&amp; <name><name>mParams</name>.<name>mHookMalloc</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>InitMemHook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// This can legitimately happen in a few cases. See bug 383651.</comment>
    <if>if <condition>(<expr><name>mCollectionInProgress</name></expr>)</condition><then>
        <return>return;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: Starting nsCycleCollector::Collect(%d)\n"</expr></argument>, <argument><expr><name>aTryCollections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRTime</name></type> <name>start</name> <init>= <expr><call><name>PR_Now</name><argument_list>()</argument_list></call></expr></init>, <name>now</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>mCollectionInProgress</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObserverService</name></expr></argument>&gt;</argument_list></name></type> <name>obs</name> <init>=
      <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/observer-service;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>obs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>obs</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"cycle-collector-begin"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>origTryCollections</name> <init>= <expr><name>aTryCollections</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while <condition>(<expr><name>aTryCollections</name> &gt; 0</expr>)</condition> <block>{
        <comment type="line">// This triggers a JS GC. Our caller assumes we always trigger at</comment>
        <comment type="line">// least one JS GC -- they rely on this fact to avoid redundant JS</comment>
        <comment type="line">// GC calls -- so it's essential that we actually execute this</comment>
        <comment type="line">// step!</comment>
        <comment type="line">//</comment>
        <comment type="line">// It is also essential to empty mBuf here because starting up</comment>
        <comment type="line">// collection in language runtimes may force some "current" suspects</comment>
        <comment type="line">// into mBuf.</comment>
        <expr_stmt><expr><call><name><name>mBuf</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name>now</name> = <call><name>PR_Now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>BeginCycleCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: mRuntimes[*]-&gt;BeginCycleCollection() took %lldms\n"</expr></argument>,
               <argument><expr>(<call><name>PR_Now</name><argument_list>()</argument_list></call> - <name>now</name>) / <name>PR_USEC_PER_MSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><name><name>mParams</name>.<name>mDoNothing</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>aTryCollections</name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
            <expr_stmt><expr><name>now</name> = <call><name>PR_Now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>purpleStart</name> <init>= <expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>SelectPurple</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>purpleEnd</name> <init>= <expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: SelectPurple() took %lldms\n"</expr></argument>,
                   <argument><expr>(<call><name>PR_Now</name><argument_list>()</argument_list></call> - <name>now</name>) / <name>PR_USEC_PER_MSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if>if <condition>(<expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>aTryCollections</name> = 0</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>mScanInProgress</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>GCGraph</name></type> <name>graph</name></decl>;</decl_stmt>

                <comment type="line">// The main Bacon &amp; Rajan collection algorithm.</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><name>now</name> = <call><name>PR_Now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>MarkRoots</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
                <block>{
                    <decl_stmt><decl><type><name>PRTime</name></type> <name>then</name> <init>= <expr><call><name>PR_Now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: MarkRoots() took %lldms\n"</expr></argument>,
                           <argument><expr>(<name>then</name> - <name>now</name>) / <name>PR_USEC_PER_MSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>now</name> = <name>then</name></expr>;</expr_stmt>
                }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><call><name>ScanRoots</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: ScanRoots() took %lldms\n"</expr></argument>,
                       <argument><expr>(<call><name>PR_Now</name><argument_list>()</argument_list></call> - <name>now</name>) / <name>PR_USEC_PER_MSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
                <expr_stmt><expr><call><name>MaybeDrawGraphs</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><name>mScanInProgress</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
                <if>if <condition>(<expr><name>aTryCollections</name> != <name>origTryCollections</name> &amp;&amp; <name>purpleStart</name> != <name>purpleEnd</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
                    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
                    <while>while <condition>(<expr><name>i</name>++ &lt; <name>purpleStart</name></expr>)</condition> <block>{
                        <expr_stmt><expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></while>
                    <while>while <condition>(<expr><name>i</name>++ &lt; <name>purpleEnd</name></expr>)</condition> <block>{
                        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mColor</name></name> == <name>white</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsCycleCollector: a later shutdown collection collected the additional\n"
                                   "  suspect %p %s\n"
                                   "  (which could be fixed by improving traversal)\n"</expr></argument>,
                                   <argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></while>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><name>now</name> = <call><name>PR_Now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <decl_stmt><decl><type><name>PRBool</name></type> <name>collected</name> <init>= <expr><call><name>CollectWhite</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: CollectWhite() took %lldms\n"</expr></argument>,
                       <argument><expr>(<call><name>PR_Now</name><argument_list>()</argument_list></call> - <name>now</name>) / <name>PR_USEC_PER_MSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="line">// Some additional book-keeping.</comment>

                <expr_stmt><expr>--<name>aTryCollections</name></expr>;</expr_stmt>

                <comment type="line">// Since runtimes may add wrappers to the purple buffer</comment>
                <comment type="line">// (which will mean we won't stop repeating due to the</comment>
                <comment type="line">// mBuf.GetSize() == 0 check above), we should stop</comment>
                <comment type="line">// repeating collections if we didn't collect anything</comment>
                <comment type="line">// this time.</comment>
                <if>if <condition>(<expr>!<name>collected</name></expr>)</condition><then>
                    <expr_stmt><expr><name>aTryCollections</name> = 0</expr>;</expr_stmt></then></if>
            }</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
            <expr_stmt><expr><name><name>mStats</name>.<name>mCollection</name></name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>mParams</name>.<name>mReportStats</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>mStats</name>.<name>Dump</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>

        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>FinishCycleCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></while>

    <expr_stmt><expr><name>mCollectionInProgress</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COLLECT_TIME_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cc: Collect() took %lldms\n"</expr></argument>,
           <argument><expr>(<call><name>PR_Now</name><argument_list>()</argument_list></call> - <name>start</name>) / <name>PR_USEC_PER_MSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ExplainLiveExpectedGarbage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>Shutdown</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Here we want to run a final collection on everything we've seen</comment>
    <comment type="line">// buffered, irrespective of age; then permanently disable</comment>
    <comment type="line">// the collector because the program is shutting down.</comment>

    <expr_stmt><expr><name><name>mParams</name>.<name>mScanDelay</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Collect</name><argument_list>(<argument><expr><call><name>SHUTDOWN_COLLECTIONS</name><argument_list>(<argument><expr><name>mParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SelectPurple</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Might have been able to release more cycles if the cycle collector would "
               "run once more at shutdown.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>mParams</name>.<name>mDoNothing</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PLDHashOperator</argument>)</argument_list></macro>
<macro><name>AddExpectedGarbage</name><argument_list>(<argument>nsVoidPtrHashKey *p</argument>, <argument>void *arg</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>nsCycleCollector</name> *</type><name>c</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCycleCollector</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>c</name>-&gt;<name>mBuf</name>.<name>Push</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>p</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block>

<struct>struct <name>SetSCCWalker</name> <super>: <specifier>public</specifier> <name>GraphWalker</name></super>
<block>{<public type="default">
    <constructor><name>SetSCCWalker</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aIndex</name></decl></param>)</parameter_list> <member_list>: <call><name>mIndex</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
    <function><type><name>PRBool</name></type> <name>ShouldVisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> <specifier>const</specifier> *</type><name>pi</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> == 0</expr>;</return> }</block></function>
    <function><type><name>void</name></type> <name>VisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> *</type><name>pi</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> = <name>mIndex</name></expr>;</expr_stmt> }</block></function>
</public><private>private:
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mIndex</name></decl>;</decl_stmt>
</private>}</block>;</struct>

<struct>struct <name>SetNonRootGreyWalker</name> <super>: <specifier>public</specifier> <name>GraphWalker</name></super>
<block>{<public type="default">
    <function><type><name>PRBool</name></type> <name>ShouldVisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> <specifier>const</specifier> *</type><name>pi</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>pi</name>-&gt;<name>mColor</name></name> == <name>white</name></expr>;</return> }</block></function>
    <function><type><name>void</name></type> <name>VisitNode</name><parameter_list>(<param><decl><type><name>PtrInfo</name> *</type><name>pi</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name><name>pi</name>-&gt;<name>mColor</name></name> = <name>grey</name></expr>;</expr_stmt> }</block></function>
</public>}</block>;</struct>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>ExplainLiveExpectedGarbage</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mScanInProgress</name> || <name>mCollectionInProgress</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>Fault</name><argument_list>(<argument><expr>"can't explain expected garbage during collection itself"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>mParams</name>.<name>mDoNothing</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsCycleCollector: not explaining expected garbage since\n"
               "  cycle collection disabled\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>mBuf</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>BeginCycleCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>SuspectExtraPointers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><name>mCollectionInProgress</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mScanInProgress</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <block>{
        <decl_stmt><decl><type><name>GCGraph</name></type> <name>graph</name></decl>;</decl_stmt>

        <comment type="line">// Instead of filling mBuf from the purple buffer, we fill it</comment>
        <comment type="line">// from the list of nodes we were expected to collect.</comment>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>suspectCurrentCount</name> <init>= <expr><call><name><name>mBuf</name>.<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mExpectedGarbage</name>.<name>EnumerateEntries</name></name><argument_list>(<argument><expr>&amp;<name>AddExpectedGarbage</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MarkRoots</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ScanRoots</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>mScanInProgress</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>PRBool</name></type> <name>describeExtraRefcounts</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>findCycleRoots</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <block>{
            <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mColor</name></name> == <name>white</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>findCycleRoots</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name> != <name><name>pi</name>-&gt;<name>mRefCount</name></name> &amp;&amp; <name>i</name> &gt;= <name>suspectCurrentCount</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>describeExtraRefcounts</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
            }</block></while>
        }</block>

        <comment type="line">// The describeExtraRefcounts check isn't much use now that</comment>
        <comment type="line">// we're traversing from suspectCurrent roots too.  But it's</comment>
        <comment type="line">// just extra work, not extra output.</comment>
        <if>if <condition>(<expr><name>describeExtraRefcounts</name> &amp;&amp; <call><name>CreateReversedEdges</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Note that the external references may have been external</comment>
            <comment type="line">// to a different node in the cycle collection that just</comment>
            <comment type="line">// happened, if that different node was purple and then</comment>
            <comment type="line">// black.</comment>

            <comment type="line">// Use mSCCIndex temporarily to track whether we've reached</comment>
            <comment type="line">// nodes in the breadth-first search.</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>INDEX_UNREACHED</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>INDEX_REACHED</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
            <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor_clear</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
            <while>while <condition>(<expr>!<call><name><name>etor_clear</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>etor_clear</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> = <name>INDEX_UNREACHED</name></expr>;</expr_stmt>
            }</block></while>

            <decl_stmt><decl><type><name>nsDeque</name></type> <name>queue</name></decl>;</decl_stmt> <comment type="line">// for breadth-first search</comment>
            <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor_roots</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
            <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>graph</name>.<name>mRootCount</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>root_pi</name> <init>= <expr><call><name><name>etor_roots</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>i</name> &gt;= <name>suspectCurrentCount</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>root_pi</name>-&gt;<name>mSCCIndex</name></name> = <name>INDEX_REACHED</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>root_pi</name>-&gt;<name>mShortestPathToExpectedGarbage</name></name> = <name>root_pi</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>queue</name>.<name>Push</name></name><argument_list>(<argument><expr><name>root_pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <while>while <condition>(<expr><call><name><name>queue</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition> <block>{
                <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr>(<name>PtrInfo</name>*)<call><name><name>queue</name>.<name>PopFront</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>ReversedEdge</name> *</type><name>e</name> <init>= <expr><name><name>pi</name>-&gt;<name>mReversedEdges</name></name></expr></init></decl>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> = <name><name>e</name>-&gt;<name>mNext</name></name></expr></incr>) <block>{
                    <if>if <condition>(<expr><name><name>e</name>-&gt;<name>mTarget</name>-&gt;<name>mSCCIndex</name></name> == <name>INDEX_UNREACHED</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>e</name>-&gt;<name>mTarget</name>-&gt;<name>mSCCIndex</name></name> = <name>INDEX_REACHED</name></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>target</name> <init>= <expr><name><name>e</name>-&gt;<name>mTarget</name></name></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr>!<name><name>target</name>-&gt;<name>mShortestPathToExpectedGarbage</name></name></expr>)</condition><then>
                            <expr_stmt><expr><name><name>target</name>-&gt;<name>mShortestPathToExpectedGarbage</name></name> = <name>pi</name></expr>;</expr_stmt></then></if>
                        <expr_stmt><expr><call><name><name>queue</name>.<name>Push</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>

                <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name> != <name><name>pi</name>-&gt;<name>mRefCount</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsCycleCollector: %s %p was not collected due "
                           "to %d\n"
                           "  external references (%d total - %d known)\n"</expr></argument>,
                           <argument><expr><name><name>pi</name>-&gt;<name>mName</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>,
                           <argument><expr><name><name>pi</name>-&gt;<name>mRefCount</name></name> - <name><name>pi</name>-&gt;<name>mInternalRefs</name></name></expr></argument>,
                           <argument><expr><name><name>pi</name>-&gt;<name>mRefCount</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  An object expected to be garbage could be "
                           "reached from it by the path:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name>PtrInfo</name> *</type><name>path</name> <init>= <expr><name>pi</name></expr></init>, *<name>prev</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</init> <condition><expr><name>prev</name> != <name>path</name></expr>;</condition>
                         <incr><expr><name>prev</name> = <name>path</name></expr>,
                         <expr><name>path</name> = <name><name>path</name>-&gt;<name>mShortestPathToExpectedGarbage</name></name></expr></incr>)
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"    %s %p\n"</expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>mName</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

                    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  The %d known references to it were from:\n"</expr></argument>,
                           <argument><expr><name><name>pi</name>-&gt;<name>mInternalRefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name>ReversedEdge</name> *</type><name>e</name> <init>= <expr><name><name>pi</name>-&gt;<name>mReversedEdges</name></name></expr></init></decl>;</init>
                         <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> = <name><name>e</name>-&gt;<name>mNext</name></name></expr></incr>) <block>{
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"    %s %p\n"</expr></argument>,
                               <argument><expr><name><name>e</name>-&gt;<name>mTarget</name>-&gt;<name>mName</name></name></expr></argument>, <argument><expr><name><name>e</name>-&gt;<name>mTarget</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                    <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name><name>pi</name>-&gt;<name>mLangID</name></name></expr>]</index></name>-&gt;<call><name>PrintAllReferencesTo</name><argument_list>(<argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>

            <expr_stmt><expr><call><name>DestroyReversedEdges</name><argument_list>(<argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>findCycleRoots</name></expr>)</condition><then> <block>{
            <comment type="line">// NOTE: This code changes the white nodes that are not</comment>
            <comment type="line">// roots to gray.</comment>

            <comment type="line">// Put the nodes in post-order traversal order from a</comment>
            <comment type="line">// depth-first search.</comment>
            <decl_stmt><decl><type><name>nsDeque</name></type> <name>DFSPostOrder</name></decl>;</decl_stmt>

            <block>{
                <comment type="line">// Use mSCCIndex temporarily to track the DFS numbering:</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>INDEX_UNREACHED</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>INDEX_TRAVERSING</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>INDEX_NUMBERED</name> <init>= <expr>2</expr></init></decl>;</decl_stmt>

                <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor_clear</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
                <while>while <condition>(<expr>!<call><name><name>etor_clear</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>etor_clear</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> = <name>INDEX_UNREACHED</name></expr>;</expr_stmt>
                }</block></while>

                <decl_stmt><decl><type><name>nsDeque</name></type> <name>stack</name></decl>;</decl_stmt>

                <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor_roots</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
                <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>graph</name>.<name>mRootCount</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>root_pi</name> <init>= <expr><call><name><name>etor_roots</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>stack</name>.<name>Push</name></name><argument_list>(<argument><expr><name>root_pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>

                <while>while <condition>(<expr><call><name><name>stack</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr>(<name>PtrInfo</name>*)<call><name><name>stack</name>.<name>Peek</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> == <name>INDEX_UNREACHED</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> = <name>INDEX_TRAVERSING</name></expr>;</expr_stmt>
                        <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>child</name> <init>= <expr><name><name>pi</name>-&gt;<name>mFirstChild</name></name></expr></init>,
                                            <name>child_end</name> <init>= <expr><name><name>pi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
                             <condition><expr><name>child</name> != <name>child_end</name></expr>;</condition> <incr><expr>++<name>child</name></expr></incr>) <block>{
                            <expr_stmt><expr><call><name><name>stack</name>.<name>Push</name></name><argument_list>(<argument><expr>*<name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name><name>stack</name>.<name>Pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// Somebody else might have numbered it already</comment>
                        <comment type="line">// (since this is depth-first, not breadth-first).</comment>
                        <comment type="line">// This happens if a node is pushed on the stack</comment>
                        <comment type="line">// a second time while it is on the stack in</comment>
                        <comment type="line">// UNREACHED state.</comment>
                        <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> == <name>INDEX_TRAVERSING</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> = <name>INDEX_NUMBERED</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>DFSPostOrder</name>.<name>Push</name></name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></else></if>
                }</block></while>
            }</block>

            <comment type="line">// Put the nodes into strongly-connected components.</comment>
            <block>{
                <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>etor_clear</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
                <while>while <condition>(<expr>!<call><name><name>etor_clear</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>etor_clear</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name> = 0</expr>;</expr_stmt>
                }</block></while>

                <decl_stmt><decl><type><name>PRUint32</name></type> <name>currentSCC</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

                <while>while <condition>(<expr><call><name><name>DFSPostOrder</name>.<name>GetSize</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition> <block>{
                    <expr_stmt><expr><call><name>SetSCCWalker</name><argument_list>(<argument><expr><name>currentSCC</name></expr></argument>)</argument_list></call>.<call><name>Walk</name><argument_list>(<argument><expr>(<name>PtrInfo</name>*)<call><name><name>DFSPostOrder</name>.<name>PopFront</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>++<name>currentSCC</name></expr>;</expr_stmt>
                }</block></while>
            }</block>

            <comment type="line">// Mark any white nodes reachable from other components as</comment>
            <comment type="line">// grey.</comment>
            <block>{
                <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
                <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mColor</name></name> != <name>white</name></expr>)</condition><then>
                        <continue>continue;</continue></then></if>
                    <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>child</name> <init>= <expr><name><name>pi</name>-&gt;<name>mFirstChild</name></name></expr></init>,
                                        <name>child_end</name> <init>= <expr><name><name>pi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
                         <condition><expr><name>child</name> != <name>child_end</name></expr>;</condition> <incr><expr>++<name>child</name></expr></incr>) <block>{
                        <if>if <condition>(<expr><name>(*<name>child</name>)-&gt;<name>mSCCIndex</name></name> != <name><name>pi</name>-&gt;<name>mSCCIndex</name></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>SetNonRootGreyWalker</name><argument_list>()</argument_list></call>.<call><name>Walk</name><argument_list>(<argument><expr>*<name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></for>
                }</block></while>
            }</block>

            <block>{
                <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
                <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name><name>pi</name>-&gt;<name>mColor</name></name> == <name>white</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsCycleCollector: %s %p in component %d\n"
                               "  was not collected due to missing call to "
                               "suspect, failure to unlink,\n"
                               "  or deficiency in traverse that causes "
                               "cycles referenced only from other\n"
                               "  cycles to require multiple rounds of cycle "
                               "collection\n"</expr></argument>,
                               <argument><expr><name><name>pi</name>-&gt;<name>mName</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mPointer</name></name></expr></argument>, <argument><expr><name><name>pi</name>-&gt;<name>mSCCIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></while>
            }</block>
        }</block></then></if>
    }</block>

    <expr_stmt><expr><name>mCollectionInProgress</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name><name>nsIProgrammingLanguage</name>::<name>MAX</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>mRuntimes</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>FinishCycleCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>    
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsCycleCollector</name>::<name>CreateReversedEdges</name></name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Count the edges in the graph.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>edgeCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>countQueue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>countQueue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>countQueue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>e</name> <init>= <expr><name><name>pi</name>-&gt;<name>mFirstChild</name></name></expr></init>, <name>e_end</name> <init>= <expr><name><name>pi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
             <condition><expr><name>e</name> != <name>e_end</name></expr>;</condition> <incr><expr>++<name>e</name></expr>, <expr>++<name>edgeCount</name></expr></incr>) <block>{
        }</block></for>
    }</block></while>

    <comment type="line">// Allocate a pool to hold all of the edges.</comment>
    <expr_stmt><expr><name><name>graph</name>.<name>mReversedEdges</name></name> = new <name><name>ReversedEdge</name><index>[<expr><name>edgeCount</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>graph</name>.<name>mReversedEdges</name></name> == <name>nsnull</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"allocation failure creating reversed edges"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Fill in the reversed edges by scanning all forward edges.</comment>
    <decl_stmt><decl><type><name>ReversedEdge</name> *</type><name>current</name> <init>= <expr><name><name>graph</name>.<name>mReversedEdges</name></name></expr></init></decl>;</decl_stmt>
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>buildQueue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>buildQueue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>buildQueue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>EdgePool</name>::<name>Iterator</name></name></type> <name>e</name> <init>= <expr><name><name>pi</name>-&gt;<name>mFirstChild</name></name></expr></init>, <name>e_end</name> <init>= <expr><name><name>pi</name>-&gt;<name>mLastChild</name></name></expr></init></decl>;</init>
             <condition><expr><name>e</name> != <name>e_end</name></expr>;</condition> <incr><expr>++<name>e</name></expr></incr>) <block>{
            <expr_stmt><expr><name><name>current</name>-&gt;<name>mTarget</name></name> = <name>pi</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current</name>-&gt;<name>mNext</name></name> = <name>(*<name>e</name>)-&gt;<name>mReversedEdges</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>(*<name>e</name>)-&gt;<name>mReversedEdges</name></name> = <name>current</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>current</name></expr>;</expr_stmt>
        }</block></for>
    }</block></while>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>current</name> - <name><name>graph</name>.<name>mReversedEdges</name></name> == <name>edgeCount</name></expr></argument>, <argument><expr>"misallocation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>DestroyReversedEdges</name></name><parameter_list>(<param><decl><type><name>GCGraph</name> &amp;</type><name>graph</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name><name>NodePool</name>::<name>Enumerator</name></name></type> <name>queue</name><parameter_list>(<param><decl><type><name><name>graph</name>.<name>mNodes</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <while>while <condition>(<expr>!<call><name><name>queue</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>PtrInfo</name> *</type><name>pi</name> <init>= <expr><call><name><name>queue</name>.<name>GetNext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pi</name>-&gt;<name>mReversedEdges</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr>delete <name><name>graph</name>.<name>mReversedEdges</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>graph</name>.<name>mReversedEdges</name></name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>ShouldBeFreed</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>mExpectedGarbage</name>.<name>PutEntry</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCycleCollector</name>::<name>WasFreed</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>mExpectedGarbage</name>.<name>RemoveEntry</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Module public API (exported in nsCycleCollector.h)</comment>
<comment type="line">// Just functions that redirect into the singleton, once it's built.</comment>
<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>

<function><type><name>void</name></type> 
<name>nsCycleCollector_registerRuntime</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>, 
                                 <param><decl><type><name>nsCycleCollectionLanguageRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>RegisterRuntime</name></name><argument_list>(<argument><expr><name>langID</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<function><type><name>void</name></type> 
<name>nsCycleCollector_forgetRuntime</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>langID</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>ForgetRuntime</name></name><argument_list>(<argument><expr><name>langID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<function><type><name>PRBool</name></type>
<name>NS_CycleCollectorSuspect</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <return>return <expr><call><name><name>sCollector</name>-&gt;<name>Suspect</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type> 
<name>nsCycleCollector_suspectCurrent</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>res</name> <init>= <expr><call><name><name>sCollector</name>-&gt;<name>Suspect</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>res</name> || <name><name>sCollector</name>-&gt;<name>mParams</name>.<name>mDoNothing</name></name></expr></argument>,
                     <argument><expr>"suspectCurrent should not fail"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


<function><type><name>PRBool</name></type>
<name>NS_CycleCollectorForget</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <return>return <expr><call><name><name>sCollector</name>-&gt;<name>Forget</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type> 
<name>nsCycleCollector_collect</name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Collect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>nsresult</name></type> 
<name>nsCycleCollector_startup</name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>sCollector</name></expr></argument>, <argument><expr>"Forgot to call nsCycleCollector_shutdown?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sCollector</name> = new <call><name>nsCycleCollector</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sCollector</name> ? <name>NS_OK</name> : <name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> 
<name>nsCycleCollector_shutdown</name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>Shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>delete <name>sCollector</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sCollector</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>nsCycleCollector_DEBUG_shouldBeFreed</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>ShouldBeFreed</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>nsCycleCollector_DEBUG_wasFreed</name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>n</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <if>if <condition>(<expr><name>sCollector</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sCollector</name>-&gt;<name>WasFreed</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
