<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00263b9dd80bf86f75365888f44c480e87e7c84c.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla SMIL module.
 *
 * The Initial Developer of the Original Code is Brian Birtles.
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Brian Birtles &lt;birtles@gmail.com&gt;
 *   Daniel Holbert &lt;dholbert@mozilla.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSMILAnimationController.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSMILCompositor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSMILCSSProperty.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSProps.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsComponentManagerUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITimer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISMILAnimationElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMSVGAnimationElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSMILTimedElement.h"</cpp:file></cpp:include>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// nsSMILAnimationController implementation</comment>

<comment type="line">// In my testing the minimum needed for smooth animation is 36 frames per</comment>
<comment type="line">// second which seems like a lot (Flash traditionally uses 14fps).</comment>
<comment type="line">//</comment>
<comment type="line">// Redrawing is synchronous. This is deliberate so that later we can tune the</comment>
<comment type="line">// timer based on how long the callback takes. To achieve 36fps we'd need 28ms</comment>
<comment type="line">// between frames. For now we set the timer interval to be a little less than</comment>
<comment type="line">// this (to allow for the render itself) and then let performance decay as the</comment>
<comment type="line">// image gets more complicated and render times increase.</comment>
<comment type="line">//</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name><name>nsSMILAnimationController</name>::<name>kTimerInterval</name></name> <init>= <expr>22</expr></init></decl>;</decl_stmt>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// ctors, dtors, factory methods</comment>

<constructor><name><name>nsSMILAnimationController</name>::<name>nsSMILAnimationController</name></name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mResampleNeeded</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mDocument</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name><name>mAnimationElementTable</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mChildContainerTable</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsSMILAnimationController</name>::~<name>nsSMILAnimationController</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mTimer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mTimer</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mAnimationElementTable</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr></argument>,
               <argument><expr>"Animation controller shouldn't be tracking any animation"
               " elements when it dies"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>nsSMILAnimationController</name>*</type> <name>NS_NewSMILAnimationController</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDoc</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSMILAnimationController</name>*</type> <name>animationController</name> <init>=
    <expr>new <call><name>nsSMILAnimationController</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>animationController</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>animationController</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>aDoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>animationController</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>animationController</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>animationController</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsSMILAnimationController</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDoc</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mTimer</name> = <call><name>do_CreateInstance</name><argument_list>(<argument><expr>"@mozilla.org/timer;1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mTimer</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Keep track of document, so we can traverse its set of animation elements</comment>
  <expr_stmt><expr><name>mDocument</name> = <name>aDoc</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>Begin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// nsSMILTimeContainer methods:</comment>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>Pause</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>nsSMILTimeContainer</name>::<name>Pause</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mPauseState</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>StopTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>Resume</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>wasPaused</name> <init>= <expr>(<name>mPauseState</name> != 0)</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>nsSMILTimeContainer</name>::<name>Resume</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>wasPaused</name> &amp;&amp; !<name>mPauseState</name> &amp;&amp; <call><name><name>mChildContainerTable</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>StartTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>nsSMILTime</name></type>
<name><name>nsSMILAnimationController</name>::<name>GetParentTime</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <comment type="line">// Our parent time is wallclock time</comment>
  <return>return <expr><call><name>PR_Now</name><argument_list>()</argument_list></call> / <name>PR_USEC_PER_MSEC</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// Animation element registration methods:</comment>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>RegisterAnimationElement</name></name><parameter_list>(
                                  <param><decl><type><name>nsISMILAnimationElement</name>*</type> <name>aAnimationElement</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mAnimationElementTable</name>.<name>PutEntry</name></name><argument_list>(<argument><expr><name>aAnimationElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>UnregisterAnimationElement</name></name><parameter_list>(
                                  <param><decl><type><name>nsISMILAnimationElement</name>*</type> <name>aAnimationElement</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mAnimationElementTable</name>.<name>RemoveEntry</name></name><argument_list>(<argument><expr><name>aAnimationElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// Page show/hide</comment>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>OnPageShow</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>Resume</name><argument_list>(<argument><expr><name><name>nsSMILTimeContainer</name>::<name>PAUSE_PAGEHIDE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>OnPageHide</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>Pause</name><argument_list>(<argument><expr><name><name>nsSMILTimeContainer</name>::<name>PAUSE_PAGEHIDE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// Cycle-collection support</comment>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>Traverse</name></name><parameter_list>(
    <param><decl><type><name>nsCycleCollectionTraversalCallback</name>*</type> <name>aCallback</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Traverse last compositor table</comment>
  <if>if <condition>(<expr><name>mLastCompositorTable</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mLastCompositorTable</name>-&gt;<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>CompositorTableEntryTraverse</name></expr></argument>,
                                           <argument><expr><name>aCallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name><name>nsSMILAnimationController</name>::<name>CompositorTableEntryTraverse</name></name><parameter_list>(
                                      <param><decl><type><name>nsSMILCompositor</name>*</type> <name>aCompositor</name></decl></param>,
                                      <param><decl><type><name>void</name>*</type> <name>aArg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCycleCollectionTraversalCallback</name>*</type> <name>cb</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCycleCollectionTraversalCallback</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aCompositor</name>-&gt;<name>Traverse</name></name><argument_list>(<argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>Unlink</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mLastCompositorTable</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// Timer-related implementation helpers</comment>

<comment type="block">/*static*/</comment> <function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>Notify</name></name><parameter_list>(<param><decl><type><name>nsITimer</name>*</type> <name>timer</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSMILAnimationController</name>*</type> <name>controller</name> <init>= <expr>(<name>nsSMILAnimationController</name>*)<name>aClosure</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>controller</name>-&gt;<name>mTimer</name></name> == <name>timer</name></expr></argument>,
               <argument><expr>"nsSMILAnimationController::Notify called with incorrect timer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>controller</name>-&gt;<name>Sample</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsSMILAnimationController</name>::<name>StartTimer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mTimer</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPauseState</name> == 0</expr></argument>, <argument><expr>"Starting timer but controller is paused"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Run the first sample manually</comment>
  <expr_stmt><expr><call><name>Sample</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//</comment>
  <comment type="line">// XXX Make this self-tuning. Sounds like control theory to me and not</comment>
  <comment type="line">// something I'm familiar with.</comment>
  <comment type="line">//</comment>
  <return>return <expr><call><name><name>mTimer</name>-&gt;<name>InitWithFuncCallback</name></name><argument_list>(<argument><expr><name><name>nsSMILAnimationController</name>::<name>Notify</name></name></expr></argument>,
                                      <argument><expr><name>this</name></expr></argument>,
                                      <argument><expr><name>kTimerInterval</name></expr></argument>,
                                      <argument><expr><name><name>nsITimer</name>::<name>TYPE_REPEATING_SLACK</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsSMILAnimationController</name>::<name>StopTimer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mTimer</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>mTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// Sample-related methods and callbacks</comment>

<function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name>TransferCachedBaseValue</name><parameter_list>(<param><decl><type><name>nsSMILCompositor</name>*</type> <name>aCompositor</name></decl></param>,
                        <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSMILCompositorTable</name>*</type> <name>lastCompositorTable</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsSMILCompositorTable</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsSMILCompositor</name>*</type> <name>lastCompositor</name> <init>=
    <expr><call><name><name>lastCompositorTable</name>-&gt;<name>GetEntry</name></name><argument_list>(<argument><expr><call><name><name>aCompositor</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>lastCompositor</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aCompositor</name>-&gt;<name>StealCachedBaseValue</name></name><argument_list>(<argument><expr><name>lastCompositor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>  
}</block></function>

<function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name>RemoveCompositorFromTable</name><parameter_list>(<param><decl><type><name>nsSMILCompositor</name>*</type> <name>aCompositor</name></decl></param>,
                          <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSMILCompositorTable</name>*</type> <name>lastCompositorTable</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsSMILCompositorTable</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>lastCompositorTable</name>-&gt;<name>RemoveEntry</name></name><argument_list>(<argument><expr><call><name><name>aCompositor</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name>DoClearAnimationEffects</name><parameter_list>(<param><decl><type><name>nsSMILCompositor</name>*</type> <name>aCompositor</name></decl></param>,
                        <param><decl><type><name>void</name>*</type></decl></param> <comment type="block">/*aData*/</comment>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aCompositor</name>-&gt;<name>ClearAnimationEffects</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name>DoComposeAttribute</name><parameter_list>(<param><decl><type><name>nsSMILCompositor</name>*</type> <name>aCompositor</name></decl></param>,
                   <param><decl><type><name>void</name>*</type></decl></param> <comment type="block">/*aData*/</comment>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aCompositor</name>-&gt;<name>ComposeAttribute</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>DoSample</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DoSample</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Skip unchanged time containers</comment>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>DoSample</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSkipUnchangedContainers</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Reset resample flag</comment>
  <expr_stmt><expr><name>mResampleNeeded</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <comment type="line">// STEP 1: Bring model up to date</comment>
  <expr_stmt><expr><call><name>DoMilestoneSamples</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// STEP 2: Sample the child time containers</comment>
  <comment type="line">//</comment>
  <comment type="line">// When we sample the child time containers they will simply record the sample</comment>
  <comment type="line">// time in document time.</comment>
  <decl_stmt><decl><type><name>TimeContainerHashtable</name></type> <name>activeContainers</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>activeContainers</name>.<name>Init</name></name><argument_list>(<argument><expr><call><name><name>mChildContainerTable</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SampleTimeContainerParams</name></type> <name>tcParams</name> <init>= <expr><block>{ <expr>&amp;<name>activeContainers</name></expr>,
                                         <expr><name>aSkipUnchangedContainers</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mChildContainerTable</name>.<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>SampleTimeContainer</name></expr></argument>, <argument><expr>&amp;<name>tcParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// STEP 3: (i)  Sample the timed elements AND</comment>
  <comment type="line">//         (ii) Create a table of compositors</comment>
  <comment type="line">//</comment>
  <comment type="line">// (i) Here we sample the timed elements (fetched from the</comment>
  <comment type="line">// nsISMILAnimationElements) which determine from the active time if the</comment>
  <comment type="line">// element is active and what its simple time etc. is. This information is</comment>
  <comment type="line">// then passed to its time client (nsSMILAnimationFunction).</comment>
  <comment type="line">//</comment>
  <comment type="line">// (ii) During the same loop we also build up a table that contains one</comment>
  <comment type="line">// compositor for each animated attribute and which maps animated elements to</comment>
  <comment type="line">// the corresponding compositor for their target attribute.</comment>
  <comment type="line">//</comment>
  <comment type="line">// Note that this compositor table needs to be allocated on the heap so we can</comment>
  <comment type="line">// store it until the next sample. This lets us find out which elements were</comment>
  <comment type="line">// animated in sample 'n-1' but not in sample 'n' (and hence need to have</comment>
  <comment type="line">// their animation effects removed in sample 'n').</comment>
  <comment type="line">//</comment>
  <comment type="line">// Parts (i) and (ii) are not functionally related but we combine them here to</comment>
  <comment type="line">// save iterating over the animation elements twice.</comment>

  <comment type="line">// Create the compositor table</comment>
  <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsSMILCompositorTable</name></expr></argument>&gt;</argument_list></name></type>
    <name>currentCompositorTable</name><argument_list>(<argument><expr>new <call><name>nsSMILCompositorTable</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>currentCompositorTable</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><call><name><name>currentCompositorTable</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SampleAnimationParams</name></type> <name>saParams</name> <init>= <expr><block>{ <expr>&amp;<name>activeContainers</name></expr>,
                                     <expr><name>currentCompositorTable</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mAnimationElementTable</name>.<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>SampleAnimation</name></expr></argument>,
                                          <argument><expr>&amp;<name>saParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>activeContainers</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// STEP 4: Compare previous sample's compositors against this sample's.</comment>
  <comment type="line">// (Transfer cached base values across, &amp; remove animation effects from </comment>
  <comment type="line">// no-longer-animated targets.)</comment>
  <if>if <condition>(<expr><name>mLastCompositorTable</name></expr>)</condition><then> <block>{
    <comment type="line">// * Transfer over cached base values, from last sample's compositors</comment>
    <expr_stmt><expr><call><name><name>currentCompositorTable</name>-&gt;<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>TransferCachedBaseValue</name></expr></argument>,
                                             <argument><expr><name>mLastCompositorTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// * For each compositor in current sample's hash table, remove entry from</comment>
    <comment type="line">// prev sample's hash table -- we don't need to clear animation</comment>
    <comment type="line">// effects of those compositors, since they're still being animated.</comment>
    <expr_stmt><expr><call><name><name>currentCompositorTable</name>-&gt;<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>RemoveCompositorFromTable</name></expr></argument>,
                                             <argument><expr><name>mLastCompositorTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// * For each entry that remains in prev sample's hash table (i.e. for</comment>
    <comment type="line">// every target that's no longer animated), clear animation effects.</comment>
    <expr_stmt><expr><call><name><name>mLastCompositorTable</name>-&gt;<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>DoClearAnimationEffects</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// STEP 5: Compose currently-animated attributes.</comment>
  <comment type="line">// XXXdholbert: This step traverses our animation targets in an effectively</comment>
  <comment type="line">// random order. For animation from/to 'inherit' values to work correctly</comment>
  <comment type="line">// when the inherited value is *also* being animated, we really should be</comment>
  <comment type="line">// traversing our animated nodes in an ancestors-first order (bug 501183)</comment>
  <expr_stmt><expr><call><name><name>currentCompositorTable</name>-&gt;<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>DoComposeAttribute</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Update last compositor table</comment>
  <expr_stmt><expr><name>mLastCompositorTable</name> = <call><name><name>currentCompositorTable</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mResampleNeeded</name></expr></argument>, <argument><expr>"Resample dirty flag set during sample!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>DoMilestoneSamples</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// We need to sample the timing model but because SMIL operates independently</comment>
  <comment type="line">// of the frame-rate, we can get one sample at t=0s and the next at t=10min.</comment>
  <comment type="line">//</comment>
  <comment type="line">// In between those two sample times a whole string of significant events</comment>
  <comment type="line">// might be expected to take place: events firing, new interdependencies</comment>
  <comment type="line">// between animations resolved and dissolved, etc.</comment>
  <comment type="line">//</comment>
  <comment type="line">// Furthermore, at any given time, we want to sample all the intervals that</comment>
  <comment type="line">// end at that time BEFORE any that begin. This behaviour is implied by SMIL's</comment>
  <comment type="line">// endpoint-exclusive timing model.</comment>
  <comment type="line">//</comment>
  <comment type="line">// So we have the animations (specifically the timed elements) register the</comment>
  <comment type="line">// next significant moment (called a milestone) in their lifetime and then we</comment>
  <comment type="line">// step through the model at each of these moments and sample those animations</comment>
  <comment type="line">// registered for those times. This way events can fire in the correct order,</comment>
  <comment type="line">// dependencies can be resolved etc.</comment>

  <decl_stmt><decl><type><name>nsSMILTime</name></type> <name>sampleTime</name> <init>= <expr><name>LL_MININT</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>PR_TRUE</name></expr>)</condition> <block>{
    <comment type="line">// We want to find any milestones AT OR BEFORE the current sample time so we</comment>
    <comment type="line">// initialise the next milestone to the moment after (1ms after, to be</comment>
    <comment type="line">// precise) the current sample time and see if there are any milestones</comment>
    <comment type="line">// before that. Any other milestones will be dealt with in a subsequent</comment>
    <comment type="line">// sample.</comment>
    <decl_stmt><decl><type><name>nsSMILMilestone</name></type> <name>nextMilestone</name><argument_list>(<argument><expr><call><name>GetCurrentTime</name><argument_list>()</argument_list></call> + 1</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mChildContainerTable</name>.<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>GetNextMilestone</name></expr></argument>, <argument><expr>&amp;<name>nextMilestone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>nextMilestone</name>.<name>mTime</name></name> &gt; <call><name>GetCurrentTime</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>

    <decl_stmt><decl><type><name>GetMilestoneElementsParams</name></type> <name>params</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>params</name>.<name>mMilestone</name></name> = <name>nextMilestone</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mChildContainerTable</name>.<name>EnumerateEntries</name></name><argument_list>(<argument><expr><name>GetMilestoneElements</name></expr></argument>, <argument><expr>&amp;<name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name><name>params</name>.<name>mElements</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// During the course of a sampling we don't want to actually go backwards.</comment>
    <comment type="line">// Due to negative offsets, early ends and the like, a timed element might</comment>
    <comment type="line">// register a milestone that is actually in the past. That's fine, but it's</comment>
    <comment type="line">// still only going to get *sampled* with whatever time we're up to and no</comment>
    <comment type="line">// earlier.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Because we're only performing this clamping at the last moment, the</comment>
    <comment type="line">// animations will still all get sampled in the correct order and</comment>
    <comment type="line">// dependencies will be appropriately resolved.</comment>
    <expr_stmt><expr><name>sampleTime</name> = <call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>nextMilestone</name>.<name>mTime</name></name></expr></argument>, <argument><expr><name>sampleTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsISMILAnimationElement</name>*</type> <name>elem</name> <init>= <expr><name><name>params</name>.<name>mElements</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr>"NULL animation element in list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsSMILTimeContainer</name>*</type> <name>container</name> <init>= <expr><call><name><name>elem</name>-&gt;<name>GetTimeContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>container</name></expr>)</condition><then>
        <comment type="line">// The container may be nsnull if the element has been detached from its</comment>
        <comment type="line">// parent since registering a milestone.</comment>
        <continue>continue;</continue></then></if>

      <decl_stmt><decl><type><name>nsSMILTimeValue</name></type> <name>containerTimeValue</name> <init>=
        <expr><call><name><name>container</name>-&gt;<name>ParentToContainerTime</name></name><argument_list>(<argument><expr><name>sampleTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name><name>containerTimeValue</name>.<name>IsResolved</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="line">// Clamp the converted container time to non-negative values.</comment>
      <decl_stmt><decl><type><name>nsSMILTime</name></type> <name>containerTime</name> <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>containerTimeValue</name>.<name>GetMillis</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>nextMilestone</name>.<name>mIsEnd</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>elem</name>-&gt;<name>TimedElement</name></name><argument_list>()</argument_list></call>.<call><name>SampleEndAt</name><argument_list>(<argument><expr><name>containerTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name><name>elem</name>-&gt;<name>TimedElement</name></name><argument_list>()</argument_list></call>.<call><name>SampleAt</name><argument_list>(<argument><expr><name>containerTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
  }</block></while>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name><name>nsSMILAnimationController</name>::<name>GetNextMilestone</name></name><parameter_list>(<param><decl><type><name>TimeContainerPtrKey</name>*</type> <name>aKey</name></decl></param>,
                                            <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr>"Null hash key for time container hash table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Null time container key in hash table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aData</name></expr></argument>,
      <argument><expr>"Null data pointer during time container enumeration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsSMILMilestone</name>*</type> <name>nextMilestone</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsSMILMilestone</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsSMILTimeContainer</name>*</type> <name>container</name> <init>= <expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>container</name>-&gt;<name>IsPausedByType</name></name><argument_list>(<argument><expr><name><name>nsSMILTimeContainer</name>::<name>PAUSE_BEGIN</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsSMILMilestone</name></type> <name>thisMilestone</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>didGetMilestone</name> <init>=
    <expr><call><name><name>container</name>-&gt;<name>GetNextMilestoneInParentTime</name></name><argument_list>(<argument><expr><name>thisMilestone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>didGetMilestone</name> &amp;&amp; <name>thisMilestone</name> &lt; *<name>nextMilestone</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>nextMilestone</name> = <name>thisMilestone</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name><name>nsSMILAnimationController</name>::<name>GetMilestoneElements</name></name><parameter_list>(<param><decl><type><name>TimeContainerPtrKey</name>*</type> <name>aKey</name></decl></param>,
                                                <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr>"Null hash key for time container hash table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Null time container key in hash table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aData</name></expr></argument>,
      <argument><expr>"Null data pointer during time container enumeration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>GetMilestoneElementsParams</name>*</type> <name>params</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>GetMilestoneElementsParams</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsSMILTimeContainer</name>*</type> <name>container</name> <init>= <expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>container</name>-&gt;<name>IsPausedByType</name></name><argument_list>(<argument><expr><name><name>nsSMILTimeContainer</name>::<name>PAUSE_BEGIN</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>container</name>-&gt;<name>PopMilestoneElementsAtMilestone</name></name><argument_list>(<argument><expr><name><name>params</name>-&gt;<name>mMilestone</name></name></expr></argument>,
                                             <argument><expr><name><name>params</name>-&gt;<name>mElements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name><name>nsSMILAnimationController</name>::<name>SampleTimeContainer</name></name><parameter_list>(<param><decl><type><name>TimeContainerPtrKey</name>*</type> <name>aKey</name></decl></param>,
                                               <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>PL_DHASH_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PL_DHASH_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>PL_DHASH_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SampleTimeContainerParams</name>*</type> <name>params</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>SampleTimeContainerParams</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsSMILTimeContainer</name>*</type> <name>container</name> <init>= <expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>container</name>-&gt;<name>IsPausedByType</name></name><argument_list>(<argument><expr><name><name>nsSMILTimeContainer</name>::<name>PAUSE_BEGIN</name></name></expr></argument>)</argument_list></call> &amp;&amp;
      (<call><name><name>container</name>-&gt;<name>NeedsSample</name></name><argument_list>()</argument_list></call> || !<name><name>params</name>-&gt;<name>mSkipUnchangedContainers</name></name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>container</name>-&gt;<name>ClearMilestones</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>container</name>-&gt;<name>Sample</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>params</name>-&gt;<name>mActiveContainers</name>-&gt;<name>PutEntry</name></name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>PR_CALLBACK</name> <name>PLDHashOperator</name></type>
<name><name>nsSMILAnimationController</name>::<name>SampleAnimation</name></name><parameter_list>(<param><decl><type><name>AnimationElementPtrKey</name>*</type> <name>aKey</name></decl></param>,
                                           <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>PL_DHASH_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PL_DHASH_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aData</name></expr></argument>, <argument><expr><name>PL_DHASH_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsISMILAnimationElement</name>*</type> <name>animElem</name> <init>= <expr><call><name><name>aKey</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SampleAnimationParams</name>*</type> <name>params</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>SampleAnimationParams</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SampleTimedElement</name><argument_list>(<argument><expr><name>animElem</name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>mActiveContainers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddAnimationToCompositorTable</name><argument_list>(<argument><expr><name>animElem</name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>mCompositorTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>SampleTimedElement</name></name><parameter_list>(
  <param><decl><type><name>nsISMILAnimationElement</name>*</type> <name>aElement</name></decl></param>, <param><decl><type><name>TimeContainerHashtable</name>*</type> <name>aActiveContainers</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSMILTimeContainer</name>*</type> <name>timeContainer</name> <init>= <expr><call><name><name>aElement</name>-&gt;<name>GetTimeContainer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>timeContainer</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// We'd like to call timeContainer-&gt;NeedsSample() here and skip all timed</comment>
  <comment type="line">// elements that belong to paused time containers that don't need a sample,</comment>
  <comment type="line">// but that doesn't work because we've already called Sample() on all the time</comment>
  <comment type="line">// containers so the paused ones don't need a sample any more and they'll</comment>
  <comment type="line">// return false.</comment>
  <comment type="line">//</comment>
  <comment type="line">// Instead we build up a hashmap of active time containers during the previous</comment>
  <comment type="line">// step (SampleTimeContainer) and then test here if the container for this</comment>
  <comment type="line">// timed element is in the list.</comment>
  <if>if <condition>(<expr>!<call><name><name>aActiveContainers</name>-&gt;<name>GetEntry</name></name><argument_list>(<argument><expr><name>timeContainer</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsSMILTime</name></type> <name>containerTime</name> <init>= <expr><call><name><name>timeContainer</name>-&gt;<name>GetCurrentTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>aElement</name>-&gt;<name>TimedElement</name></name><argument_list>()</argument_list></call>.<call><name>SampleAt</name><argument_list>(<argument><expr><name>containerTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>AddAnimationToCompositorTable</name></name><parameter_list>(
  <param><decl><type><name>nsISMILAnimationElement</name>*</type> <name>aElement</name></decl></param>, <param><decl><type><name>nsSMILCompositorTable</name>*</type> <name>aCompositorTable</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Add a compositor to the hash table if there's not already one there</comment>
  <decl_stmt><decl><type><name>nsSMILTargetIdentifier</name></type> <name>key</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>GetTargetIdentifierForAnimation</name><argument_list>(<argument><expr><name>aElement</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <comment type="line">// Something's wrong/missing about animation's target; skip this animation</comment>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsSMILAnimationFunction</name>&amp;</type> <name>func</name> <init>= <expr><call><name><name>aElement</name>-&gt;<name>AnimationFunction</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Only add active animation functions. If there are no active animations</comment>
  <comment type="line">// targeting an attribute, no compositor will be created and any previously</comment>
  <comment type="line">// applied animations will be cleared.</comment>
  <if>if <condition>(<expr><call><name><name>func</name>.<name>IsActiveOrFrozen</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Look up the compositor for our target, &amp; add our animation function</comment>
    <comment type="line">// to its list of animation functions.</comment>
    <decl_stmt><decl><type><name>nsSMILCompositor</name>*</type> <name>result</name> <init>= <expr><call><name><name>aCompositorTable</name>-&gt;<name>PutEntry</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>result</name>-&gt;<name>AddAnimationFunction</name></name><argument_list>(<argument><expr>&amp;<name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>func</name>.<name>HasChanged</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Look up the compositor for our target, and force it to skip the</comment>
    <comment type="line">// "nothing's changed so don't bother compositing" optimization for this</comment>
    <comment type="line">// sample. |func| is inactive, but it's probably *newly* inactive (since</comment>
    <comment type="line">// it's got HasChanged() == PR_TRUE), so we need to make sure to recompose</comment>
    <comment type="line">// its target.</comment>
    <decl_stmt><decl><type><name>nsSMILCompositor</name>*</type> <name>result</name> <init>= <expr><call><name><name>aCompositorTable</name>-&gt;<name>PutEntry</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>result</name>-&gt;<name>ToggleForceCompositing</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We've now made sure that |func|'s inactivity will be reflected as of</comment>
    <comment type="line">// this sample. We need to clear its HasChanged() flag so that it won't</comment>
    <comment type="line">// trigger this same clause in future samples (until it changes again).</comment>
    <expr_stmt><expr><call><name><name>func</name>.<name>ClearHasChanged</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
}</block></function>

<comment type="line">// Helper function that, given a nsISMILAnimationElement, looks up its target</comment>
<comment type="line">// element &amp; target attribute and populates a nsSMILTargetIdentifier</comment>
<comment type="line">// for this target.</comment>
<comment type="block">/*static*/</comment> <function><type><name>PRBool</name></type>
<name><name>nsSMILAnimationController</name>::<name>GetTargetIdentifierForAnimation</name></name><parameter_list>(
    <param><decl><type><name>nsISMILAnimationElement</name>*</type> <name>aAnimElem</name></decl></param>, <param><decl><type><name>nsSMILTargetIdentifier</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Look up target (animated) element</comment>
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>targetElem</name> <init>= <expr><call><name><name>aAnimElem</name>-&gt;<name>GetTargetElementContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>targetElem</name></expr>)</condition><then>
    <comment type="line">// Animation has no target elem -- skip it.</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// Look up target (animated) attribute</comment>
  <comment type="line">//</comment>
  <comment type="line">// XXXdholbert As mentioned in SMILANIM section 3.1, attributeName may</comment>
  <comment type="line">// have an XMLNS prefix to indicate the XML namespace. Need to parse</comment>
  <comment type="line">// that somewhere.</comment>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>attributeName</name> <init>= <expr><call><name><name>aAnimElem</name>-&gt;<name>GetTargetAttributeName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>attributeName</name></expr>)</condition><then>
    <comment type="line">// Animation has no target attr -- skip it.</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// Look up target (animated) attribute-type</comment>
  <decl_stmt><decl><type><name>nsSMILTargetAttrType</name></type> <name>attributeType</name> <init>= <expr><call><name><name>aAnimElem</name>-&gt;<name>GetTargetAttributeType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Check if an 'auto' attributeType refers to a CSS property or XML attribute.</comment>
  <comment type="line">// Note that SMIL requires we search for CSS properties first. So if they</comment>
  <comment type="line">// overlap, 'auto' = 'CSS'. (SMILANIM 3.1)</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isCSS</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>attributeType</name> == <name>eSMILTargetAttrType_auto</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSProperty</name></type> <name>prop</name> <init>=
      <expr><call><name><name>nsCSSProps</name>::<name>LookupProperty</name></name><argument_list>(<argument><expr><call><name>nsDependentAtomString</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>isCSS</name> = <call><name><name>nsSMILCSSProperty</name>::<name>IsPropertyAnimatable</name></name><argument_list>(<argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>isCSS</name> = (<name>attributeType</name> == <name>eSMILTargetAttrType_CSS</name>)</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="line">// Construct the key</comment>
  <expr_stmt><expr><name><name>aResult</name>.<name>mElement</name></name> = <name>targetElem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aResult</name>.<name>mAttributeName</name></name> = <name>attributeName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aResult</name>.<name>mIsCSS</name></name> = <name>isCSS</name></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">// Add/remove child time containers</comment>

<function><type><name>nsresult</name></type>
<name><name>nsSMILAnimationController</name>::<name>AddChild</name></name><parameter_list>(<param><decl><type><name>nsSMILTimeContainer</name>&amp;</type> <name>aChild</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>TimeContainerPtrKey</name>*</type> <name>key</name> <init>= <expr><call><name><name>mChildContainerTable</name>.<name>PutEntry</name></name><argument_list>(<argument><expr>&amp;<name>aChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mPauseState</name> &amp;&amp; <call><name><name>mChildContainerTable</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>StartTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsSMILAnimationController</name>::<name>RemoveChild</name></name><parameter_list>(<param><decl><type><name>nsSMILTimeContainer</name>&amp;</type> <name>aChild</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mChildContainerTable</name>.<name>RemoveEntry</name></name><argument_list>(<argument><expr>&amp;<name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mPauseState</name> &amp;&amp; <call><name><name>mChildContainerTable</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>StopTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
</unit>
