<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="003d0d2dd4cc80a2ffe3cf1f617ae071fe3d5f1e.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="line">// vim:cindent:ts=2:et:sw=2:</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   David Baron &lt;dbaron@dbaron.org&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/* class that a parent frame uses to reflow a block frame */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockReflowContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLineLayout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSpaceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFontMetrics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLContainerFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLineBox.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLTableCellElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLBodyElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutUtils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>NOISY_MAX_ELEMENT_SIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>REALLY_NOISY_MAX_ELEMENT_SIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>NOISY_VERTICAL_MARGINS</name></cpp:undef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>NOISY_MAX_ELEMENT_SIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>REALLY_NOISY_MAX_ELEMENT_SIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>NOISY_VERTICAL_MARGINS</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<constructor><name><name>nsBlockReflowContext</name>::<name>nsBlockReflowContext</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aParentRS</name></decl></param>)</parameter_list>
  <member_list>: <call><name>mPresContext</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>)</argument_list></call>,
    <call><name>mOuterReflowState</name><argument_list>(<argument><expr><name>aParentRS</name></expr></argument>)</argument_list></call>,
    <call><name>mMetrics</name><argument_list>()</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><name>mStyleBorder</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStyleMargin</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStylePadding</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></constructor>

<function><type><specifier>static</specifier> <name>nsIFrame</name>*</type> <name>DescendIntoBlockLevelFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>type</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>type</name> == <name><name>nsGkAtoms</name>::<name>columnSetFrame</name></name></expr>)</condition><then>
    <return>return <expr><call><name>DescendIntoBlockLevelFrame</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><name>aFrame</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsBlockReflowContext</name>::<name>ComputeCollapsedTopMargin</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aRS</name></decl></param>,
  <param><decl><type><name>nsCollapsingMargin</name>*</type> <name>aMargin</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aClearanceFrame</name></decl></param>,
  <param><decl><type><name>PRBool</name>*</type> <name>aMayNeedRetry</name></decl></param>, <param><decl><type><name>PRBool</name>*</type> <name>aBlockIsEmpty</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Include frame's top margin</comment>
  <expr_stmt><expr><call><name><name>aMargin</name>-&gt;<name>Include</name></name><argument_list>(<argument><expr><name><name>aRS</name>.<name>mComputedMargin</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// The inclusion of the bottom margin when empty is done by the caller</comment>
  <comment type="line">// since it doesn't need to be done by the top-level (non-recursive)</comment>
  <comment type="line">// caller.</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>aRS</name>.<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": %d =&gt; %d\n"</expr></argument>, <argument><expr><name><name>aRS</name>.<name>mComputedMargin</name>.<name>top</name></name></expr></argument>, <argument><expr><call><name><name>aMargin</name>-&gt;<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>dirtiedLine</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>setBlockIsEmpty</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Calculate the frame's generational top-margin from its child</comment>
  <comment type="line">// blocks. Note that if the frame has a non-zero top-border or</comment>
  <comment type="line">// top-padding then this step is skipped because it will be a margin</comment>
  <comment type="line">// root.  It is also skipped if the frame is a margin root for other</comment>
  <comment type="line">// reasons.</comment>
  <decl_stmt><decl><type><name>void</name>*</type> <name>bf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>DescendIntoBlockLevelFrame</name><argument_list>(<argument><expr><name><name>aRS</name>.<name>frame</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>prescontext</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>0 == <name><name>aRS</name>.<name>mComputedBorderPadding</name>.<name>top</name></name> &amp;&amp;
      <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>frame</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><name>kBlockFrameCID</name></expr></argument>, <argument><expr>&amp;<name>bf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
      !<call><name><name>nsBlockFrame</name>::<name>BlockIsMarginRoot</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// iterate not just through the lines of 'block' but also its</comment>
    <comment type="line">// overflow lines and the normal and overflow lines of its next in</comment>
    <comment type="line">// flows. Note that this will traverse some frames more than once:</comment>
    <comment type="line">// for example, if A contains B and A-&gt;nextinflow contains</comment>
    <comment type="line">// B-&gt;nextinflow, we'll traverse B-&gt;nextinflow twice. But this is</comment>
    <comment type="line">// OK because our traversal is idempotent.</comment>
    <for>for (<init><decl><type><name>nsBlockFrame</name>*</type> <name>block</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>block</name></expr>;</condition> <incr><expr><name>block</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>block</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>) <block>{
      <for>for (<init><decl><type><name>PRBool</name></type> <name>overflowLines</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</init> <condition><expr><name>overflowLines</name> &lt;= <name>PR_TRUE</name></expr>;</condition> <incr><expr>++<name>overflowLines</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name><name>nsBlockFrame</name>::<name>line_iterator</name></name></type> <name>line</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsBlockFrame</name>::<name>line_iterator</name></name></type> <name>line_end</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>anyLines</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>overflowLines</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nsLineList</name>*</type> <name>lines</name> <init>= <expr><call><name><name>block</name>-&gt;<name>GetOverflowLines</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>!<name>lines</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>anyLines</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
          }</block></then> <else>else <block>{
            <expr_stmt><expr><name>line</name> = <call><name><name>lines</name>-&gt;<name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>line_end</name> = <call><name><name>lines</name>-&gt;<name>end</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>line</name> = <call><name><name>block</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>line_end</name> = <call><name><name>block</name>-&gt;<name>end_lines</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <for>for (<init>;</init> <condition><expr><name>anyLines</name> &amp;&amp; <name>line</name> != <name>line_end</name></expr>;</condition> <incr><expr>++<name>line</name></expr></incr>) <block>{
          <if>if <condition>(<expr>!<name>aClearanceFrame</name> &amp;&amp; <call><name><name>line</name>-&gt;<name>HasClearance</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// If we don't have a clearance frame, then we're computing</comment>
            <comment type="line">// the collapsed margin in the first pass, assuming that all</comment>
            <comment type="line">// lines have no clearance. So clear their clearance flags.</comment>
            <expr_stmt><expr><call><name><name>line</name>-&gt;<name>ClearHasClearance</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dirtiedLine</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          }</block></then></if>
          
          <decl_stmt><decl><type><name>PRBool</name></type> <name>isEmpty</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsInline</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>isEmpty</name> = <call><name><name>line</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kid</name> <init>= <expr><name><name>line</name>-&gt;<name>mFirstChild</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>kid</name> == <name>aClearanceFrame</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name><name>line</name>-&gt;<name>SetHasClearance</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>dirtiedLine</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <goto>goto <name>done</name>;</goto>
            }</block></then></if>
            <comment type="line">// Here is where we recur. Now that we have determined that a</comment>
            <comment type="line">// generational collapse is required we need to compute the</comment>
            <comment type="line">// child blocks margin and so in so that we can look into</comment>
            <comment type="line">// it. For its margins to be computed we need to have a reflow</comment>
            <comment type="line">// state for it.</comment>
            
            <comment type="line">// We may have to construct an extra reflow state here if</comment>
            <comment type="line">// we drilled down through a block wrapper. At the moment</comment>
            <comment type="line">// we can only drill down one level so we only have to support</comment>
            <comment type="line">// one extra reflow state.</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>outerReflowState</name> <init>= <expr>&amp;<name>aRS</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>frame</name> != <name><name>aRS</name>.<name>frame</name></name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>frame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> == <name><name>aRS</name>.<name>frame</name></name></expr></argument>,
                           <argument><expr>"Can only drill through one level of block wrapper"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <decl_stmt><decl><type><name>nsSize</name></type> <name>availSpace</name><argument_list>(<argument><expr><call><name><name>aRS</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>aRS</name>.<name>mComputedHeight</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
              <expr_stmt><expr><name>outerReflowState</name> = new <call><name>nsHTMLReflowState</name><argument_list>(<argument><expr><name>prescontext</name></expr></argument>,
                                                       <argument><expr><name>aRS</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>availSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>!<name>outerReflowState</name></expr>)</condition><then>
                <goto>goto <name>done</name>;</goto></then></if>
            }</block></then></if>
            <block>{
              <decl_stmt><decl><type><name>nsSize</name></type> <name>availSpace</name><argument_list>(<argument><expr><call><name><name>outerReflowState</name>-&gt;<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name><name>outerReflowState</name>-&gt;<name>mComputedHeight</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>nsHTMLReflowState</name></type> <name>innerReflowState</name><argument_list>(<argument><expr><name>prescontext</name></expr></argument>,
                                                 <argument><expr>*<name>outerReflowState</name></expr></argument>, <argument><expr><name>kid</name></expr></argument>,
                                                 <argument><expr><name>availSpace</name></expr></argument>)</argument_list></decl>;</decl_stmt>
              <comment type="line">// Record that we're being optimistic by assuming the kid</comment>
              <comment type="line">// has no clearance</comment>
              <if>if <condition>(<expr><call><name><name>kid</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<name>mBreakType</name> != <name>NS_STYLE_CLEAR_NONE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>aMayNeedRetry</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              }</block></then></if>
              <if>if <condition>(<expr><call><name>ComputeCollapsedTopMargin</name><argument_list>(<argument><expr><name>innerReflowState</name></expr></argument>, <argument><expr><name>aMargin</name></expr></argument>, <argument><expr><name>aClearanceFrame</name></expr></argument>, <argument><expr><name>aMayNeedRetry</name></expr></argument>, <argument><expr>&amp;<name>isEmpty</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dirtiedLine</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              }</block></then></if>
              <if>if <condition>(<expr><name>isEmpty</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>aMargin</name>-&gt;<name>Include</name></name><argument_list>(<argument><expr><name><name>innerReflowState</name>.<name>mComputedMargin</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block>
            <if>if <condition>(<expr><name>outerReflowState</name> != &amp;<name>aRS</name></expr>)</condition><then> <block>{
              <expr_stmt><expr>delete <call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>nsHTMLReflowState</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>outerReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></else></if>
          <if>if <condition>(<expr>!<name>isEmpty</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>setBlockIsEmpty</name> &amp;&amp; <name>aBlockIsEmpty</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>setBlockIsEmpty</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <expr_stmt><expr>*<name>aBlockIsEmpty</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
            }</block></then></if>
            <goto>goto <name>done</name>;</goto>
          }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr>!<name>setBlockIsEmpty</name> &amp;&amp; <name>aBlockIsEmpty</name></expr>)</condition><then> <block>{
          <comment type="line">// The first time we reach here is when this is the first block</comment>
          <comment type="line">// and we have processed all its normal lines.</comment>
          <expr_stmt><expr><name>setBlockIsEmpty</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          <comment type="line">// All lines are empty, or we wouldn't be here!</comment>
          <expr_stmt><expr>*<name>aBlockIsEmpty</name> = <call><name><name>aRS</name>.<name>frame</name>-&gt;<name>IsSelfEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></for>
  <label><name>done</name>:</label>
    <empty_stmt>;</empty_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>setBlockIsEmpty</name> &amp;&amp; <name>aBlockIsEmpty</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aBlockIsEmpty</name> = <call><name><name>aRS</name>.<name>frame</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>aRS</name>.<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": =&gt; %d\n"</expr></argument>, <argument><expr><call><name><name>aMargin</name>-&gt;<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>dirtiedLine</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>nsPointDtor</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>nsIAtom</name> *</type><name>aPropertyName</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>aPropertyValue</name></decl></param>, <param><decl><type><name>void</name> *</type><name>aDtorData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsPoint</name> *</type><name>point</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsPoint</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aPropertyValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>delete <name>point</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsBlockReflowContext</name>::<name>ReflowBlock</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>       <name>aSpace</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type>              <name>aApplyTopMargin</name></decl></param>,
                                  <param><decl><type><name>nsCollapsingMargin</name>&amp;</type> <name>aPrevMargin</name></decl></param>,
                                  <param><decl><type><name>nscoord</name></type>             <name>aClearance</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type>              <name>aIsAdjacentWithTop</name></decl></param>,
                                  <param><decl><type><name>nsMargin</name>&amp;</type>           <name>aComputedOffsets</name></decl></param>,
                                  <param><decl><type><name>nsHTMLReflowState</name>&amp;</type>  <name>aFrameRS</name></decl></param>,
                                  <param><decl><type><name>nsReflowStatus</name>&amp;</type>     <name>aFrameReflowStatus</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mFrame</name> = <name><name>aFrameRS</name>.<name>frame</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSpace</name> = <name>aSpace</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>aComputedOffsets</name> = <name><name>aFrameRS</name>.<name>mComputedOffsets</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>NS_STYLE_POSITION_RELATIVE</name> == <name><name>display</name>-&gt;<name>mPosition</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsPropertyTable</name> *</type><name>propTable</name> <init>= <expr><call><name><name>mPresContext</name>-&gt;<name>PropertyTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsPoint</name> *</type><name>offsets</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsPoint</name>*</expr></argument>&gt;</argument_list></name>
                                  <argument_list>(<argument><expr><call><name><name>propTable</name>-&gt;<name>GetProperty</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>computedOffsetProperty</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>offsets</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>offsets</name>-&gt;<name>MoveTo</name></name><argument_list>(<argument><expr><name><name>aComputedOffsets</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>aComputedOffsets</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
      <expr_stmt><expr><name>offsets</name> = new <call><name>nsPoint</name><argument_list>(<argument><expr><name><name>aComputedOffsets</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>aComputedOffsets</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>offsets</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>propTable</name>-&gt;<name>SetProperty</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>computedOffsetProperty</name></name></expr></argument>,
                               <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>nsPointDtor</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>aIsAdjacentWithTop</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aFrameRS</name>.<name>mFlags</name>.<name>mIsTopOfPage</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>  <comment type="line">// make sure this is cleared</comment>
  }</block></then></if>
  <expr_stmt><expr><name>mComputedWidth</name> = <call><name><name>aFrameRS</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aApplyTopMargin</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mTopMargin</name> = <name>aPrevMargin</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>mOuterReflowState</name>.<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": reflowing "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" margin =&gt; %d, clearance =&gt; %d\n"</expr></argument>, <argument><expr><call><name><name>mTopMargin</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aClearance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Adjust the available height if its constrained so that the</comment>
    <comment type="line">// child frame doesn't think it can reflow into its margin area.</comment>
    <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aFrameRS</name>.<name>availableHeight</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>aFrameRS</name>.<name>availableHeight</name></name> -= <call><name><name>mTopMargin</name>.<name>get</name></name><argument_list>()</argument_list></call> + <name>aClearance</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Compute x/y coordinate where reflow will begin. Use the rules</comment>
  <comment type="line">// from 10.3.3 to determine what to apply. At this point in the</comment>
  <comment type="line">// reflow auto left/right margins will have a zero value.</comment>
  <expr_stmt><expr><name>mMargin</name> = <name><name>aFrameRS</name>.<name>mComputedMargin</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStyleBorder</name> = <name><name>aFrameRS</name>.<name>mStyleBorder</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStyleMargin</name> = <name><name>aFrameRS</name>.<name>mStyleMargin</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStylePadding</name> = <name><name>aFrameRS</name>.<name>mStylePadding</name></name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>y</name> <init>= <expr><name><name>mSpace</name>.<name>y</name></name> + <call><name><name>mTopMargin</name>.<name>get</name></name><argument_list>()</argument_list></call> + <name>aClearance</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// If it's a right floated element, then calculate the x-offset</comment>
  <comment type="line">// differently</comment>
  <if>if <condition>(<expr><name>NS_STYLE_FLOAT_RIGHT</name> == <name><name>aFrameRS</name>.<name>mStyleDisplay</name>-&gt;<name>mFloats</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>frameWidth</name></decl>;</decl_stmt>
     
    <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> == <call><name><name>aFrameRS</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Use the current frame width</comment>
      <expr_stmt><expr><name>frameWidth</name> = <call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>width</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>frameWidth</name> = <call><name><name>aFrameRS</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call> +
                   <name><name>aFrameRS</name>.<name>mComputedBorderPadding</name>.<name>left</name></name> +
                   <name><name>aFrameRS</name>.<name>mComputedBorderPadding</name>.<name>right</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// if this is an unconstrained width reflow, then just place the float at the left margin</comment>
    <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> == <name><name>mSpace</name>.<name>width</name></name></expr>)</condition><then>
      <expr_stmt><expr><name>x</name> = <name><name>mSpace</name>.<name>x</name></name></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>x</name> = <call><name><name>mSpace</name>.<name>XMost</name></name><argument_list>()</argument_list></call> - <name><name>mMargin</name>.<name>right</name></name> - <name>frameWidth</name></expr>;</expr_stmt></else></if>

  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>x</name> = <name><name>mSpace</name>.<name>x</name></name> + <name><name>mMargin</name>.<name>left</name></name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>mX</name> = <name>x</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mY</name> = <name>y</name></expr>;</expr_stmt>

   <comment type="line">// Compute the translation to be used for adjusting the spacemanagager</comment>
   <comment type="line">// coordinate system for the frame.  The spacemanager coordinates are</comment>
   <comment type="line">// &lt;b&gt;inside&lt;/b&gt; the callers border+padding, but the x/y coordinates</comment>
   <comment type="line">// are not (recall that frame coordinates are relative to the parents</comment>
   <comment type="line">// origin and that the parents border/padding is &lt;b&gt;inside&lt;/b&gt; the</comment>
   <comment type="line">// parent frame. Therefore we have to subtract out the parents</comment>
   <comment type="line">// border+padding before translating.</comment>
   <decl_stmt><decl><type><name>nscoord</name></type> <name>tx</name> <init>= <expr><name>x</name> - <name><name>mOuterReflowState</name>.<name>mComputedBorderPadding</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>nscoord</name></type> <name>ty</name> <init>= <expr><name>y</name> - <name><name>mOuterReflowState</name>.<name>mComputedBorderPadding</name>.<name>top</name></name></expr></init></decl>;</decl_stmt>
 
  <comment type="line">// If the element is relatively positioned, then adjust x and y accordingly</comment>
  <if>if <condition>(<expr><name>NS_STYLE_POSITION_RELATIVE</name> == <name><name>aFrameRS</name>.<name>mStyleDisplay</name>-&gt;<name>mPosition</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>x</name> += <name><name>aFrameRS</name>.<name>mComputedOffsets</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> += <name><name>aFrameRS</name>.<name>mComputedOffsets</name>.<name>top</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Let frame know that we are reflowing it</comment>
  <expr_stmt><expr><call><name><name>mFrame</name>-&gt;<name>WillReflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Position it and its view (if it has one)</comment>
  <comment type="line">// Note: Use "x" and "y" and not "mX" and "mY" because they more accurately</comment>
  <comment type="line">// represents where we think the block will be placed</comment>
  <comment type="line">// XXXldb That's fine for view positioning, but not for reflow!</comment>
  <expr_stmt><expr><call><name><name>mFrame</name>-&gt;<name>SetPosition</name></name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>nsContainerFrame</name>::<name>PositionFrameView</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>mMetrics</name>.<name>width</name></name> = <call><name>nscoord</name><argument_list>(<argument><expr>0xdeadbeef</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mMetrics</name>.<name>height</name></name> = <call><name>nscoord</name><argument_list>(<argument><expr>0xdeadbeef</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name><name>mOuterReflowState</name>.<name>mSpaceManager</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><name>tx</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>mFrame</name>-&gt;<name>Reflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>mMetrics</name></expr></argument>, <argument><expr><name>aFrameRS</name></expr></argument>, <argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mOuterReflowState</name>.<name>mSpaceManager</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr>-<name>tx</name></expr></argument>, <argument><expr>-<name>ty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr>!<call><name>NS_INLINE_IS_BREAK_BEFORE</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>CRAZY_WIDTH</name><argument_list>(<argument><expr><name><name>mMetrics</name>.<name>width</name></name></expr></argument>)</argument_list></call> || <call><name>CRAZY_HEIGHT</name><argument_list>(<argument><expr><name><name>mMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsBlockReflowContext: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" metrics=%d,%d!\n"</expr></argument>, <argument><expr><name><name>mMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>(<name><name>mMetrics</name>.<name>width</name></name> == <call><name>nscoord</name><argument_list>(<argument><expr>0xdeadbeef</expr></argument>)</argument_list></call>) ||
        (<name><name>mMetrics</name>.<name>height</name></name> == <call><name>nscoord</name><argument_list>(<argument><expr>0xdeadbeef</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsBlockReflowContext: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" didn't set w/h %d,%d!\n"</expr></argument>, <argument><expr><name><name>mMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!(<name>NS_FRAME_OUTSIDE_CHILDREN</name> &amp; <call><name><name>mFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
    <comment type="line">// Provide overflow area for child that doesn't have any</comment>
    <expr_stmt><expr><name><name>mMetrics</name>.<name>mOverflowArea</name>.<name>x</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mMetrics</name>.<name>mOverflowArea</name>.<name>y</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mMetrics</name>.<name>mOverflowArea</name>.<name>width</name></name> = <name><name>mMetrics</name>.<name>width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mMetrics</name>.<name>mOverflowArea</name>.<name>height</name></name> = <name><name>mMetrics</name>.<name>height</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>NS_INLINE_IS_BREAK_BEFORE</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call> ||
      (<call><name><name>mFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_OUT_OF_FLOW</name>)</expr>)</condition><then> <block>{
    <comment type="line">// If frame is complete and has a next-in-flow, we need to delete</comment>
    <comment type="line">// them now. Do not do this when a break-before is signaled because</comment>
    <comment type="line">// the frame is going to get reflowed again (and may end up wanting</comment>
    <comment type="line">// a next-in-flow where it ends up), unless it is an out of flow frame.</comment>
    <if>if <condition>(<expr><call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidNextInFlow</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nsnull</name> != <name>kidNextInFlow</name></expr>)</condition><then> <block>{
        <comment type="line">// Remove all of the childs next-in-flows. Make sure that we ask</comment>
        <comment type="line">// the right parent to do the removal (it's possible that the</comment>
        <comment type="line">// parent is not this because we are executing pullup code).</comment>
        <comment type="line">// Floats will eventually be removed via nsBlockFrame::RemoveFloat</comment>
        <comment type="line">// which detaches the placeholder from the float.</comment>
<comment type="block">/* XXX promote DeleteChildsNextInFlow to nsIFrame to elminate this cast */</comment>
        <expr_stmt><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsHTMLContainerFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>kidNextInFlow</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
          -&gt;<call><name>DeleteNextInFlowChild</name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr><name>kidNextInFlow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Attempt to place the block frame within the available space.  If
 * it fits, apply horizontal positioning (CSS 10.3.3), collapse
 * margins (CSS2 8.3.1). Also apply relative positioning.
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>nsBlockReflowContext</name>::<name>PlaceBlock</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type>                   <name>aForceFit</name></decl></param>,
                                 <param><decl><type><name>nsLineBox</name>*</type>               <name>aLine</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsMargin</name>&amp;</type>          <name>aComputedOffsets</name></decl></param>,
                                 <param><decl><type><name>nsCollapsingMargin</name>&amp;</type>      <name>aBottomMarginResult</name></decl></param>,
                                 <param><decl><type><name>nsRect</name>&amp;</type>                  <name>aInFlowBounds</name></decl></param>,
                                 <param><decl><type><name>nsRect</name>&amp;</type>                  <name>aCombinedRect</name></decl></param>,
                                 <param><decl><type><name>nsReflowStatus</name></type>           <name>aReflowStatus</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Compute collapsed bottom margin value.</comment>
  <if>if <condition>(<expr><call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name>aReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aBottomMarginResult</name> = <name><name>mMetrics</name>.<name>mCarriedOutBottomMargin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aBottomMarginResult</name>.<name>Include</name></name><argument_list>(<argument><expr><name><name>mMargin</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// The used bottom-margin is set to zero above a break.</comment>
    <expr_stmt><expr><call><name><name>aBottomMarginResult</name>.<name>Zero</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name> <init>= <expr><name>mX</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>y</name> <init>= <expr><name>mY</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>backupContainingBlockAdvance</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="line">// Check whether the block's bottom margin collapses with its top</comment>
  <comment type="line">// margin. See CSS 2.1 section 8.3.1; those rules seem to match</comment>
  <comment type="line">// nsBlockFrame::IsEmpty(). Any such block must have zero height so</comment>
  <comment type="line">// check that first. Note that a block can have clearance and still</comment>
  <comment type="line">// have adjoining top/bottom margins, because the clearance goes</comment>
  <comment type="line">// above the top margin.</comment>
  <comment type="line">// Mark the frame as non-dirty; it has been reflowed (or we wouldn't</comment>
  <comment type="line">// be here), and we don't want to assert in CachedIsEmpty()</comment>
  <expr_stmt><expr><call><name><name>mFrame</name>-&gt;<name>RemoveStateBits</name></name><argument_list>(<argument><expr><name>NS_FRAME_IS_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>empty</name> <init>= <expr>0 == <name><name>mMetrics</name>.<name>height</name></name> &amp;&amp; <call><name><name>aLine</name>-&gt;<name>CachedIsEmpty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>empty</name></expr>)</condition><then> <block>{
    <comment type="line">// Collapse the bottom margin with the top margin that was already</comment>
    <comment type="line">// applied.</comment>
    <expr_stmt><expr><call><name><name>aBottomMarginResult</name>.<name>Include</name></name><argument_list>(<argument><expr><name>mTopMargin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>mOuterReflowState</name>.<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" -- collapsing top &amp; bottom margin together; y=%d spaceY=%d\n"</expr></argument>,
           <argument><expr><name>y</name></expr></argument>, <argument><expr><name><name>mSpace</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// Section 8.3.1 of CSS 2.1 says that blocks with adjoining</comment>
    <comment type="line">// top/bottom margins whose top margin collapses with their</comment>
    <comment type="line">// parent's top margin should have their top border-edge at the</comment>
    <comment type="line">// top border-edge of their parent. We actually don't have to do</comment>
    <comment type="line">// anything special to make this happen. In that situation,</comment>
    <comment type="line">// nsBlockFrame::ShouldApplyTopMargin will have returned PR_FALSE,</comment>
    <comment type="line">// and mTopMargin and aClearance will have been zero in</comment>
    <comment type="line">// ReflowBlock.</comment>

    <comment type="line">// If we did apply our top margin, but now we're collapsing it</comment>
    <comment type="line">// into the bottom margin, we need to back up the containing</comment>
    <comment type="line">// block's y-advance by our top margin so that it doesn't get</comment>
    <comment type="line">// counted twice. Note that here we're allowing the line's bounds</comment>
    <comment type="line">// to become different from the block's position; we do this</comment>
    <comment type="line">// because the containing block will place the next line at the</comment>
    <comment type="line">// line's YMost, and it must place the next line at a different</comment>
    <comment type="line">// point from where this empty block will be.</comment>
    <expr_stmt><expr><name>backupContainingBlockAdvance</name> = <call><name><name>mTopMargin</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// See if the frame fit. If it's the first frame or empty then it</comment>
  <comment type="line">// always fits. If the height is unconstrained then it always fits,</comment>
  <comment type="line">// even if there's some sort of integer overflow that makes y +</comment>
  <comment type="line">// mMetrics.height appear to go beyond the available height.</comment>
  <if>if <condition>(<expr>!<name>empty</name> &amp;&amp; !<name>aForceFit</name> &amp;&amp; <name><name>mSpace</name>.<name>height</name></name> != <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>yMost</name> <init>= <expr><name>y</name> - <name>backupContainingBlockAdvance</name> + <name><name>mMetrics</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>yMost</name> &gt; <call><name><name>mSpace</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// didn't fit, we must acquit.</comment>
      <expr_stmt><expr><call><name><name>mFrame</name>-&gt;<name>DidReflow</name></name><argument_list>(<argument><expr><name>mPresContext</name></expr></argument>, <argument><expr>&amp;<name>aReflowState</name></expr></argument>, <argument><expr><name>NS_FRAME_REFLOW_FINISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>aInFlowBounds</name> = <call><name>nsRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name> - <name>backupContainingBlockAdvance</name></expr></argument>,
                         <argument><expr><name><name>mMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Apply CSS relative positioning</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>styleDisp</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>NS_STYLE_POSITION_RELATIVE</name> == <name><name>styleDisp</name>-&gt;<name>mPosition</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>x</name> += <name><name>aComputedOffsets</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> += <name><name>aComputedOffsets</name>.<name>top</name></name></expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="line">// Now place the frame and complete the reflow process</comment>
  <expr_stmt><expr><call><name><name>nsContainerFrame</name>::<name>FinishReflowChild</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name>mPresContext</name></expr></argument>, <argument><expr>&amp;<name>aReflowState</name></expr></argument>, <argument><expr><name>mMetrics</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>aCombinedRect</name> = <name><name>mMetrics</name>.<name>mOverflowArea</name></name> + <call><name>nsPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>
</unit>
