<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="000212f3274481c125b02343b50cf26075cc44b2.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Mozilla SVG project.
 *
 * The Initial Developer of the Original Code is IBM Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NS_SVGUTILS_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_SVGUTILS_H</name></cpp:macro></cpp:define>

<comment type="line">// include math.h to pick up definition of M_SQRT1_2 if the platform defines it</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_USE_MATH_DEFINES</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nscore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRenderingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxRect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxMatrix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSVGMatrix.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>class</name></type> <name>nsIDocument</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsPresContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIContent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsStyleContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsStyleCoord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsFrameList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIFrame</name></decl>;</decl_stmt>
<struct_decl>struct <name>nsStyleSVGPaint</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>nsIDOMSVGElement</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIDOMSVGLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIURI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGOuterSVGFrame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGPreserveAspectRatio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIAtom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGLength2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGElement</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGSVGElement</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsAttrValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>gfxContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>gfxASurface</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>gfxPattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>gfxImageSurface</name></decl>;</decl_stmt>
<struct_decl>struct <name>gfxSize</name>;</struct_decl>
<struct_decl>struct <name>gfxIntSize</name>;</struct_decl>
<struct_decl>struct <name>nsStyleFont</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGEnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsISVGChildFrame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGGeometryFrame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsSVGDisplayContainerFrame</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>mozilla</name> <block>{
<decl_stmt><decl><type><name>namespace</name></type> <name>dom</name> <block>{
<decl_stmt><decl><type><name>class</name></type> <name>Element</name></decl>;</decl_stmt>
}</block></decl></decl_stmt> <comment type="line">// namespace dom</comment>
}</block></decl></decl_stmt> <comment type="line">// namespace mozilla</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// SVG Frame state bits</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_STATE_IS_OUTER_SVG</name></cpp:macro>         <cpp:value>NS_FRAME_STATE_BIT(20)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_STATE_SVG_DIRTY</name></cpp:macro>            <cpp:value>NS_FRAME_STATE_BIT(21)</cpp:value></cpp:define>

<comment type="block">/* are we the child of a non-display container? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_STATE_SVG_NONDISPLAY_CHILD</name></cpp:macro> <cpp:value>NS_FRAME_STATE_BIT(22)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_STATE_SVG_PROPAGATE_TRANSFORM</name></cpp:macro> <cpp:value>NS_FRAME_STATE_BIT(23)</cpp:value></cpp:define>

<comment type="block">/**
 * Byte offsets of channels in a native packed gfxColor or cairo image surface.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IS_BIG_ENDIAN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_A</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_R</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_G</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_B</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_A</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_R</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_G</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GFX_ARGB32_OFFSET_B</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// maximum dimension of an offscreen surface - choose so that</comment>
<comment type="line">// the surface size doesn't overflow a 32-bit signed int using</comment>
<comment type="line">// 4 bytes per pixel; in line with gfxASurface::CheckSurfaceSize</comment>
<comment type="line">// In fact Macs can't even manage that</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_SVG_OFFSCREEN_MAX_DIMENSION</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVG_WSP_DELIM</name></cpp:macro>       <cpp:value>"\x20\x9\xD\xA"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVG_COMMA_WSP_DELIM</name></cpp:macro> <cpp:value>"," SVG_WSP_DELIM</cpp:value></cpp:define>

<function><type><specifier>inline</specifier> <name>PRBool</name></type>
<name>IsSVGWhitespace</name><parameter_list>(<param><decl><type><name>char</name></type> <name>aChar</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>aChar</name> == '\x20' || <name>aChar</name> == '\x9' ||
         <name>aChar</name> == '\xD'  || <name>aChar</name> == '\xA'</expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>PRBool</name></type>
<name>IsSVGWhitespace</name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aChar</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>aChar</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'\x20'</expr></argument>)</argument_list></call> || <name>aChar</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'\x9'</expr></argument>)</argument_list></call> ||
         <name>aChar</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'\xD'</expr></argument>)</argument_list></call>  || <name>aChar</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'\xA'</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Checks the svg enable preference and if a renderer could
 * successfully be created.  Declared as a function instead of a
 * nsSVGUtil method so that files that can't pull in nsSVGUtils.h (due
 * to cairo.h usage) can still query this information.
 */</comment>
<function_decl><type><name>PRBool</name></type> <name>NS_SVGEnabled</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SMIL</name></cpp:ifdef>
<comment type="block">/*
 * Checks the smil enabled preference.  Declared as a function to match
 * NS_SVGEnabled().
 */</comment>
<function_decl><type><name>PRBool</name></type> <name>NS_SMILEnabled</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_SMIL</comment>

<comment type="line">// GRRR WINDOWS HATE HATE HATE</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CLIP_MASK</name></cpp:undef>

<decl_stmt><decl><type><name>class</name></type> <name>nsSVGRenderState</name>
<block>{
<label><name>public</name>:</label>
  <enum>enum <name>RenderMode</name> <block>{ <decl><name>NORMAL</name></decl>, <decl><name>CLIP</name></decl>, <decl><name>CLIP_MASK</name></decl> }</block>;</enum>

  <comment type="block">/**
   * Render SVG to a legacy rendering context
   */</comment>
  <expr_stmt><expr><call><name>nsSVGRenderState</name><argument_list>(<argument><expr><name>nsIRenderingContext</name> *<name>aContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/**
   * Render SVG to a modern rendering context
   */</comment>
  <expr_stmt><expr><call><name>nsSVGRenderState</name><argument_list>(<argument><expr><name>gfxContext</name> *<name>aContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/**
   * Render SVG to a temporary surface
   */</comment>
  <expr_stmt><expr><call><name>nsSVGRenderState</name><argument_list>(<argument><expr><name>gfxASurface</name> *<name>aSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>nsIRenderingContext</name> *</type><name>GetRenderingContext</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function><type><name>gfxContext</name> *</type><name>GetGfxContext</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mGfxContext</name></expr>;</return> }</block></function>

  <function><type><name>void</name></type> <name>SetRenderMode</name><parameter_list>(<param><decl><type><name>RenderMode</name></type> <name>aMode</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mRenderMode</name> = <name>aMode</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>RenderMode</name></type> <name>GetRenderMode</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mRenderMode</name></expr>;</return> }</block></function>

  <function><type><name>void</name></type> <name>SetPaintingToWindow</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aPaintingToWindow</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><name>mPaintingToWindow</name> = <name>aPaintingToWindow</name></expr>;</expr_stmt>
  }</block></function>
  <function><type><name>PRBool</name></type> <name>IsPaintingToWindow</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mPaintingToWindow</name></expr>;</return> }</block></function>

<label><name>private</name>:</label>
  <decl_stmt><decl><type><name>RenderMode</name></type>                    <name>mRenderMode</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIRenderingContext</name>&gt; <name>mRenderingContext</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsRefPtr</name>&lt;<name>gfxContext</name>&gt;          <name>mGfxContext</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                  <name>mPaintingToWindow</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>nsAutoSVGRenderMode</name>
<block>{
<label><name>public</name>:</label>
  <macro><name>nsAutoSVGRenderMode</name><argument_list>(<argument>nsSVGRenderState *aState</argument>,
                      <argument>nsSVGRenderState::RenderMode aMode</argument>)</argument_list></macro> : <macro><name>mState</name><argument_list>(<argument>aState</argument>)</argument_list></macro> <block>{
    <expr_stmt><expr><name>mOriginalMode</name> = <call><name><name>aState</name>-&gt;<name>GetRenderMode</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aState</name>-&gt;<name>SetRenderMode</name></name><argument_list>(<argument><expr><name>aMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
  <expr_stmt><expr>~<macro><name>nsAutoSVGRenderMode</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>mState</name>-&gt;<name>SetRenderMode</name></name><argument_list>(<argument><expr><name>mOriginalMode</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>private</name>:
  <name>nsSVGRenderState</name>            *<name>mState</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsSVGRenderState</name>::<name>RenderMode</name> <name>mOriginalMode</name></expr>;</expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ISVGFILTERPROPERTY_IID</name></cpp:macro> \
<cpp:value>{ 0x9744ee20, 0x1bcf, 0x4c62, \
 { 0x86, 0x7d, 0xd3, 0x7a, 0x91, 0x60, 0x3e, 0xef } }</cpp:value></cpp:define>

<expr_stmt><expr><name>class</name> <name>nsISVGFilterProperty</name> : <name>public</name> <name>nsISupports</name>
<block>{
<expr><name>public</name>:
  <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_ISVGFILTERPROPERTY_IID</argument>)</argument_list></macro>
  <name>virtual</name> <name>void</name> <call><name>Invalidate</name><argument_list>()</argument_list></call> = 0</expr>;
}</block></expr>;</expr_stmt>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsISVGFilterProperty</argument>, <argument>NS_ISVGFILTERPROPERTY_IID</argument>)</argument_list></macro>

<decl_stmt><decl><type><name>class</name></type> <name>nsSVGUtils</name>
<block>{
<label><name>public</name>:</label>
  <comment type="block">/*
   * Get the parent element of an nsIContent
   */</comment>
  <expr_stmt><expr>static <name>mozilla</name>::<name>dom</name>::<name>Element</name> *<call><name>GetParentElement</name><argument_list>(<argument><expr><name>nsIContent</name> *<name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Get the number of CSS px (user units) per em (i.e. the em-height in user
   * units) for an nsIContent
   *
   * XXX document the conditions under which these may fail, and what they
   * return in those cases.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>GetFontSize</name><argument_list>(<argument><expr><name>mozilla</name>::<name>dom</name>::<name>Element</name> *<name>aElement</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>GetFontSize</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>GetFontSize</name><parameter_list>(<param><decl><type><name>nsStyleContext</name> *</type><name>aStyleContext</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/*
   * Get the number of CSS px (user units) per ex (i.e. the x-height in user
   * units) for an nsIContent
   *
   * XXX document the conditions under which these may fail, and what they
   * return in those cases.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>GetFontXHeight</name><argument_list>(<argument><expr><name>mozilla</name>::<name>dom</name>::<name>Element</name> *<name>aElement</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>GetFontXHeight</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>GetFontXHeight</name><parameter_list>(<param><decl><type><name>nsStyleContext</name> *</type><name>aStyleContext</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Converts image data from premultipled to unpremultiplied alpha
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnPremultiplyImageDataAlpha</name><parameter_list>(<param><decl><type><name>PRUint8</name> *</type><name>data</name></decl></param>, 
                                          <param><decl><type><name>PRInt32</name></type> <name>stride</name></decl></param>, 
                                          <param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type><name>rect</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/*
   * Converts image data from unpremultipled to premultiplied alpha
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PremultiplyImageDataAlpha</name><parameter_list>(<param><decl><type><name>PRUint8</name> *</type><name>data</name></decl></param>, 
                                        <param><decl><type><name>PRInt32</name></type> <name>stride</name></decl></param>, 
                                        <param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type><name>rect</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/*
   * Converts image data from premultiplied sRGB to Linear RGB
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConvertImageDataToLinearRGB</name><parameter_list>(<param><decl><type><name>PRUint8</name> *</type><name>data</name></decl></param>, 
                                          <param><decl><type><name>PRInt32</name></type> <name>stride</name></decl></param>, 
                                          <param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type><name>rect</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/*
   * Converts image data from LinearRGB to premultiplied sRGB
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConvertImageDataFromLinearRGB</name><parameter_list>(<param><decl><type><name>PRUint8</name> *</type><name>data</name></decl></param>, 
                                            <param><decl><type><name>PRInt32</name></type> <name>stride</name></decl></param>, 
                                            <param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type><name>rect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Report a localized error message to the error console.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>ReportToConsole</name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>doc</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aWarning</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>PRUnichar</name> **</type><name>aParams</name></decl></param>,
                                  <param><decl><type><name>PRUint32</name></type> <name>aParamsLength</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Converts a nsStyleCoord into a userspace value.  Handles units
   * Factor (straight userspace), Coord (dimensioned), and Percent (of
   * the current SVG viewport)
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>CoordToFloat</name><parameter_list>(<param><decl><type><name>nsPresContext</name> *</type><name>aPresContext</name></decl></param>,
                            <param><decl><type><name>nsSVGElement</name> *</type><name>aContent</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>nsStyleCoord</name> &amp;</type><name>aCoord</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>static</specifier> <name>gfxMatrix</name></type> <name>GetCTM</name><parameter_list>(<param><decl><type><name>nsSVGElement</name> *</type><name>aElement</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aScreenCTM</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Check if this is one of the SVG elements that SVG 1.1 Full says
   * establishes a viewport: svg, symbol, image or foreignObject.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>EstablishesViewport</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>;</function_decl>

  <expr_stmt><expr>static <name>already_AddRefed</name>&lt;<name>nsIDOMSVGElement</name>&gt;
  <call><name>GetNearestViewportElement</name><argument_list>(<argument><expr><name>nsIContent</name> *<name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>static <name>already_AddRefed</name>&lt;<name>nsIDOMSVGElement</name>&gt;
  <call><name>GetFarthestViewportElement</name><argument_list>(<argument><expr><name>nsIContent</name> *<name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Gets the nearest nsSVGInnerSVGFrame or nsSVGOuterSVGFrame frame. aFrame
   * must be an SVG frame. If aFrame is of type nsGkAtoms::svgOuterSVGFrame,
   * returns nsnull.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsSVGDisplayContainerFrame</name>*</type> <name>GetNearestSVGViewport</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  
  <comment type="block">/**
   * Figures out the worst case invalidation area for a frame, taking
   * filters into account.
   * Note that the caller is responsible for making sure that any cached
   * covered regions in the frame tree rooted at aFrame are up to date.
   * @param aRect the area in app units that needs to be invalidated in aFrame
   * @return the rect in app units that should be invalidated, taking
   * filters into account. Will return aRect when no filters are present.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type> <name>FindFilterInvalidation</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Invalidates the area covered by the frame
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateCoveredRegion</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Update the area covered by the frame
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateGraphic</name><parameter_list>(<param><decl><type><name>nsISVGChildFrame</name> *</type><name>aSVGFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Update the filter invalidation region for ancestor frames, if relevant.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NotifyAncestorsOfFilterRegionChange</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* enum for specifying coordinate direction for ObjectSpace/UserSpace */</comment>
  <enum>enum <name>ctxDirection</name> <block>{ <decl><name>X</name></decl>, <decl><name>Y</name></decl>, <decl><name>XY</name></decl> }</block>;</enum>

  <comment type="block">/**
   * Computes sqrt((aWidth^2 + aHeight^2)/2);
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>double</name></type> <name>ComputeNormalizedHypotenuse</name><parameter_list>(<param><decl><type><name>double</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>double</name></type> <name>aHeight</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Computes the input length in terms of object space coordinates.
     Input: rect - bounding box
            length - length to be converted
  */</comment>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>ObjectSpace</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name> &amp;</type><name>aRect</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsSVGLength2</name> *</type><name>aLength</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Computes the input length in terms of user space coordinates.
     Input: content - object to be used for determining user space
     Input: length - length to be converted
  */</comment>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>UserSpace</name><parameter_list>(<param><decl><type><name>nsSVGElement</name> *</type><name>aSVGElement</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsSVGLength2</name> *</type><name>aLength</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Computes the input length in terms of user space coordinates.
     Input: aFrame - object to be used for determining user space
            length - length to be converted
  */</comment>
  <function_decl><type><specifier>static</specifier> <name>float</name></type> <name>UserSpace</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsSVGLength2</name> *</type><name>aLength</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Returns the angle halfway between the two specified angles */</comment>
  <function_decl><type><specifier>static</specifier> <name>float</name></type>
  <name>AngleBisect</name><parameter_list>(<param><decl><type><name>float</name></type> <name>a1</name></decl></param>, <param><decl><type><name>float</name></type> <name>a2</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Find the outermost SVG frame of the passed frame */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsSVGOuterSVGFrame</name> *</type>
  <name>GetOuterSVGFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Get the covered region for a frame. Return null if it's not an SVG frame.
   * @param aRect gets a rectangle in app units
   * @return the outer SVG frame which aRect is relative to
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsIFrame</name>*</type>
  <name>GetOuterSVGFrameAndCoveredRegion</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsRect</name>*</type> <name>aRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Generate a viewbox to viewport tranformation matrix */</comment>
  
  <function_decl><type><specifier>static</specifier> <name>gfxMatrix</name></type>
  <name>GetViewBoxTransform</name><parameter_list>(<param><decl><type><name>nsSVGElement</name>*</type> <name>aElement</name></decl></param>,
                      <param><decl><type><name>float</name></type> <name>aViewportWidth</name></decl></param>, <param><decl><type><name>float</name></type> <name>aViewportHeight</name></decl></param>,
                      <param><decl><type><name>float</name></type> <name>aViewboxX</name></decl></param>, <param><decl><type><name>float</name></type> <name>aViewboxY</name></decl></param>,
                      <param><decl><type><name>float</name></type> <name>aViewboxWidth</name></decl></param>, <param><decl><type><name>float</name></type> <name>aViewboxHeight</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>nsSVGPreserveAspectRatio</name> &amp;</type><name>aPreserveAspectRatio</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Paint SVG frame with SVG effects - aDirtyRect is the area being
   * redrawn, in device pixel coordinates relative to the outer svg */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type>
  <name>PaintFrameWithEffects</name><parameter_list>(<param><decl><type><name>nsSVGRenderState</name> *</type><name>aContext</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>nsIntRect</name> *</type><name>aDirtyRect</name></decl></param>,
                        <param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Hit testing - check if point hits the clipPath of indicated
   * frame.  Returns true if no clipPath set. */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type>
  <name>HitTestClip</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aPoint</name></decl></param>)</parameter_list>;</function_decl>
  
  <comment type="block">/* Hit testing - check if point hits any children of frame. */</comment>

  <function_decl><type><specifier>static</specifier> <name>nsIFrame</name> *</type>
  <name>HitTestChildren</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aPoint</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Returns the CanvasTM of the indicated frame, whether it's a
   * child SVG frame, container SVG frame, or a regular frame.
   * For regular frames, we just return an identity matrix.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxMatrix</name></type> <name>GetCanvasTM</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Tells child frames that something that might affect them has changed
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type>
  <name>NotifyChildrenOfSVGChange</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Get frame's covered region by walking the children and doing union.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type>
  <name>GetCoveredRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsFrameList</name> &amp;</type><name>aFrames</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Convert a rect from device pixel units to app pixel units by inflation.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type>
  <name>ToAppPixelRect</name><parameter_list>(<param><decl><type><name>nsPresContext</name> *</type><name>aPresContext</name></decl></param>,
                 <param><decl><type><name>double</name></type> <name>xmin</name></decl></param>, <param><decl><type><name>double</name></type> <name>ymin</name></decl></param>, <param><decl><type><name>double</name></type> <name>xmax</name></decl></param>, <param><decl><type><name>double</name></type> <name>ymax</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type>
  <name>ToAppPixelRect</name><parameter_list>(<param><decl><type><name>nsPresContext</name> *</type><name>aPresContext</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>rect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Convert a surface size to an integer for use by thebes
   * possibly making it smaller in the process so the surface does not
   * use excessive memory.
   *
   * XXXdholbert Putting impl in header file so that imagelib can call this
   * method.  Once we switch to a libxul-only world, this can go back into
   * the .cpp file.
   *
   * @param aSize the desired surface size
   * @param aResultOverflows true if the desired surface size is too big
   * @return the surface size to use
   */</comment>
  <function><type><specifier>static</specifier> <name>gfxIntSize</name></type> <name>ConvertToSurfaceSize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxSize</name>&amp;</type> <name>aSize</name></decl></param>,
                                  <param><decl><type><name>PRBool</name> *</type><name>aResultOverflows</name></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name>gfxIntSize</name></type> <name>surfaceSize</name><argument_list>(<argument><expr><call><name>ClampToInt</name><argument_list>(<argument><expr><name><name>aSize</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ClampToInt</name><argument_list>(<argument><expr><name><name>aSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>aResultOverflows</name> = <name><name>surfaceSize</name>.<name>width</name></name> != <call><name>NS_round</name><argument_list>(<argument><expr><name><name>aSize</name>.<name>width</name></name></expr></argument>)</argument_list></call> ||
      <name><name>surfaceSize</name>.<name>height</name></name> != <call><name>NS_round</name><argument_list>(<argument><expr><name><name>aSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>gfxASurface</name>::<call><name>CheckSurfaceSize</name><argument_list>(<argument><expr><name>surfaceSize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>surfaceSize</name>.<name>width</name></name> = <call><name>NS_MIN</name><argument_list>(<argument><expr><name>NS_SVG_OFFSCREEN_MAX_DIMENSION</name></expr></argument>,
                                 <argument><expr><name><name>surfaceSize</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>surfaceSize</name>.<name>height</name></name> = <call><name>NS_MIN</name><argument_list>(<argument><expr><name>NS_SVG_OFFSCREEN_MAX_DIMENSION</name></expr></argument>,
                                  <argument><expr><name><name>surfaceSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aResultOverflows</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>surfaceSize</name></expr>;</return>
  }</block></function>

  <comment type="block">/*
   * Convert a nsIDOMSVGMatrix to a gfxMatrix.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxMatrix</name></type>
  <name>ConvertSVGMatrixToThebes</name><parameter_list>(<param><decl><type><name>nsIDOMSVGMatrix</name> *</type><name>aMatrix</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/*
   * Hit test a given rectangle/matrix.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type>
  <name>HitTestRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxMatrix</name> &amp;</type><name>aMatrix</name></decl></param>,
              <param><decl><type><name>float</name></type> <name>aRX</name></decl></param>, <param><decl><type><name>float</name></type> <name>aRY</name></decl></param>, <param><decl><type><name>float</name></type> <name>aRWidth</name></decl></param>, <param><decl><type><name>float</name></type> <name>aRHeight</name></decl></param>,
              <param><decl><type><name>float</name></type> <name>aX</name></decl></param>, <param><decl><type><name>float</name></type> <name>aY</name></decl></param>)</parameter_list>;</function_decl>


  <comment type="block">/**
   * Get the clip rect for the given frame, taking into account the CSS 'clip'
   * property. See:
   * http://www.w3.org/TR/SVG11/masking.html#OverflowAndClipProperties
   * The arguments for aX, aY, aWidth and aHeight should be the dimensions of
   * the viewport established by aFrame.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxRect</name></type>
  <name>GetClipRectForFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                      <param><decl><type><name>float</name></type> <name>aX</name></decl></param>, <param><decl><type><name>float</name></type> <name>aY</name></decl></param>, <param><decl><type><name>float</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>float</name></type> <name>aHeight</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CompositeSurfaceMatrix</name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>aContext</name></decl></param>,
                                     <param><decl><type><name>gfxASurface</name> *</type><name>aSurface</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>gfxMatrix</name> &amp;</type><name>aCTM</name></decl></param>, <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CompositePatternMatrix</name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>aContext</name></decl></param>,
                                     <param><decl><type><name>gfxPattern</name> *</type><name>aPattern</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>gfxMatrix</name> &amp;</type><name>aCTM</name></decl></param>, <param><decl><type><name>float</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>float</name></type> <name>aHeight</name></decl></param>, <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetClipRect</name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>aContext</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>gfxMatrix</name> &amp;</type><name>aCTM</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>gfxRect</name> &amp;</type><name>aRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Restricts aRect to pixels that intersect aGfxRect.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClipToGfxRect</name><parameter_list>(<param><decl><type><name>nsIntRect</name>*</type> <name>aRect</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>aGfxRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Using group opacity instead of fill or stroke opacity on a
   * geometry object seems to be a common authoring mistake.  If we're
   * not applying filters and not both stroking and filling, we can
   * generate the same result without going through the overhead of a
   * push/pop group. */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type>
  <name>CanOptimizeOpacity</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Calculate the maximum expansion of a matrix */</comment>
  <function_decl><type><specifier>static</specifier> <name>float</name></type>
  <name>MaxExpansion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxMatrix</name> &amp;</type><name>aMatrix</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Take the CTM to userspace for an element, and adjust it to a CTM to its
   * object bounding box space if aUnits is SVG_UNIT_TYPE_OBJECTBOUNDINGBOX.
   * (I.e. so that [0,0] is at the top left of its bbox, and [1,1] is at the
   * bottom right of its bbox).
   *
   * If the bbox is empty, this will return a singular matrix.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxMatrix</name></type>
  <name>AdjustMatrixForUnits</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxMatrix</name> &amp;</type><name>aMatrix</name></decl></param>,
                       <param><decl><type><name>nsSVGEnum</name> *</type><name>aUnits</name></decl></param>,
                       <param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Get bounding-box for aFrame. Matrix propagation is disabled so the
   * bounding box is computed in terms of aFrame's own user space.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxRect</name></type> <name>GetBBox</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * Compute a rectangle in userSpaceOnUse or objectBoundingBoxUnits.
   * @param aXYWH pointer to 4 consecutive nsSVGLength2 objects containing
   * the x, y, width and height values in that order
   * @param aBBox the bounding box of the object the rect is relative to;
   * may be null if aUnits is not SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
   * @param aFrame the object in which to interpret user-space units;
   * may be null if aUnits is SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxRect</name></type>
  <name>GetRelativeRect</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>aUnits</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsSVGLength2</name> *</type><name>aXYWH</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>gfxRect</name> &amp;</type><name>aBBox</name></decl></param>, <param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Find the first frame, starting with aStartFrame and going up its
   * parent chain, that is not an svgAFrame.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsIFrame</name>*</type> <name>GetFirstNonAAncestorFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aStartFrame</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <function_decl><type><specifier>static</specifier> <name>void</name></type>
  <name>WritePPM</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>, <param><decl><type><name>gfxImageSurface</name> *</type><name>aSurface</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/**
   * Compute the maximum possible device space stroke extents of a path given
   * the path's device space path extents, its stroke style and its ctm.
   *
   * This is a workaround for the lack of suitable cairo API for getting the
   * tight device space stroke extents of a path. This basically gives us the
   * tightest extents that we can guarantee fully enclose the inked stroke
   * without doing the calculations for the actual tight extents. We exploit
   * the fact that cairo does have an API for getting the tight device space
   * fill/path extents.
   *
   * This should die once bug 478152 is fixed.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxRect</name></type> <name>PathExtentsToMaxStrokeExtents</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>aPathExtents</name></decl></param>,
                                               <param><decl><type><name>nsSVGGeometryFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns true if aContent is an SVG &lt;svg&gt; element that is the child of
   * another non-foreignObject SVG element.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsInnerSVG</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Convert a floating-point value to a 32-bit integer value, clamping to
   * the range of valid integers.
   */</comment>
  <function><type><specifier>static</specifier> <name>PRInt32</name></type> <name>ClampToInt</name><parameter_list>(<param><decl><type><name>double</name></type> <name>aVal</name></decl></param>)</parameter_list>
  <block>{
    <return>return <expr><call><name>NS_lround</name><argument_list>(<argument><expr><call><name>NS_MAX</name><argument_list>(<argument><expr><call><name>double</name><argument_list>(<argument><expr><name>PR_INT32_MIN</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>NS_MIN</name><argument_list>(<argument><expr><call><name>double</name><argument_list>(<argument><expr><name>PR_INT32_MAX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="block">/**
   * Given a nsIContent* that is actually an nsSVGSVGElement*, this method
   * checks whether it currently has a valid viewBox, and returns true if so.
   *
   * No other type of element should be passed to this method.
   * (In debug builds, anything non-&lt;svg&gt; will trigger an abort; in non-debug
   * builds, it will trigger a PR_FALSE return-value as a safe fallback.)
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>RootSVGElementHasViewbox</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIContent</name> *</type><name>aRootSVGElem</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
  <comment type="block">/* Computational (nil) surfaces */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>gfxASurface</name> *</type><name>gThebesComputationalSurface</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
