<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00447a7f80357e4c5e35b08f9dd6b1851c9a24b6.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Novell code.
 *
 * The Initial Developer of the Original Code is Novell Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   robert@ocallahan.org
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NSTEXTFRAMEUTILS_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTEXTFRAMEUTILS_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxFont.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxSkipChars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxTextRunCache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTextFragment.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG_TEXT_NODE_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>nsTextFrameUtils</name> <block>{
<label><name>public</name>:</label>
  <comment type="line">// These constants are used as textrun flags for textframe textruns.</comment>
  <enum>enum <block>{
    <comment type="line">// The following flags are set by TransformText</comment>

    <comment type="line">// the text has at least one untransformed tab character</comment>
    <decl><name>TEXT_HAS_TAB</name>             <init>= <expr>0x010000</expr></init></decl>,
    <comment type="line">// the original text has at least one soft hyphen character</comment>
    <decl><name>TEXT_HAS_SHY</name>             <init>= <expr>0x020000</expr></init></decl>,
    <decl><name>TEXT_WAS_TRANSFORMED</name>     <init>= <expr>0x040000</expr></init></decl>,

    <comment type="line">// The following flags are set by nsTextFrame</comment>

    <decl><name>TEXT_IS_SIMPLE_FLOW</name>      <init>= <expr>0x100000</expr></init></decl>,
    <decl><name>TEXT_INCOMING_WHITESPACE</name> <init>= <expr>0x200000</expr></init></decl>,
    <decl><name>TEXT_TRAILING_WHITESPACE</name> <init>= <expr>0x400000</expr></init></decl>,
    <decl><name>TEXT_IS_UNCACHED</name>         <init>= <expr>0x800000</expr></init></decl>
  }</block>;</enum>

  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type>
  <name>IsPunctuationMark</name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aChar</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns PR_TRUE if aChars/aLength are something that make a space
   * character not be whitespace when they follow the space character.
   * For now, this is true if and only if aChars starts with a ZWJ. (This
   * is what Uniscribe assumes.)
   */</comment>
  <function><type><specifier>static</specifier> <name>PRBool</name></type>
  <name>IsSpaceCombiningSequenceTail</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aChars</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aLength</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><name>aLength</name> &gt; 0 &amp;&amp; <name><name>aChars</name><index>[<expr>0</expr>]</index></name> == 0x200D</expr>;</return> <comment type="line">// ZWJ</comment>
  }</block></function>

  <comment type="block">/**
   * Create a text run from a run of Unicode text. The text may have whitespace
   * compressed. A preformatted tab is sent to the text run as a single space.
   * (Tab spacing must be performed by textframe later.) Certain other
   * characters are discarded.
   * 
   * @param aCompressWhitespace runs of consecutive whitespace (spaces not
   * followed by a diacritical mark, tabs, and newlines) are compressed to a
   * single space character.
   * @param aIncomingWhitespace a flag indicating whether there was whitespace
   * preceding this text. We set it to indicate if there's whitespace
   * preceding the end of this text.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRUnichar</name>*</type> <name>TransformText</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aText</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>,
                                  <param><decl><type><name>PRUnichar</name>*</type> <name>aOutput</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type> <name>aCompressWhitespace</name></decl></param>,
                                  <param><decl><type><name>PRPackedBool</name>*</type> <name>aIncomingWhitespace</name></decl></param>,
                                  <param><decl><type><name>gfxSkipCharsBuilder</name>*</type> <name>aSkipChars</name></decl></param>,
                                  <param><decl><type><name>PRUint32</name>*</type> <name>aAnalysisFlags</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>static</specifier> <name>PRUint8</name>*</type> <name>TransformText</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUint8</name>*</type> <name>aText</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>,
                                <param><decl><type><name>PRUint8</name>*</type> <name>aOutput</name></decl></param>,
                                <param><decl><type><name>PRBool</name></type> <name>aCompressWhitespace</name></decl></param>,
                                <param><decl><type><name>PRPackedBool</name>*</type> <name>aIncomingWhitespace</name></decl></param>,
                                <param><decl><type><name>gfxSkipCharsBuilder</name>*</type> <name>aSkipChars</name></decl></param>,
                                <param><decl><type><name>PRUint32</name>*</type> <name>aAnalysisFlags</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Find a word boundary starting from a given position and proceeding either
   * forwards (aDirection == 1) or backwards (aDirection == -1). The search
   * is limited to a substring of an nsTextFragment, and starts with the
   * first character of the word (the character at aOffset). We return the length
   * of the word.
   * 
   * @param aTextRun a text run which we will use to ensure that we don't
   * return a boundary inside a cluster
   * @param aPosition a character in the substring aOffset/aLength
   * @param aBreakBeforePunctuation if true, then we allow a word break
   * when transitioning from regular word text to punctuation (in content order)
   * @param aBreakAfterPunctuation if true, then we allow a word break
   * when transitioning from punctuation to regular word text (in content order)
   * @param aWordIsWhitespace we set this to true if this word is whitespace
   * 
   * For the above properties, "punctuation" is defined as any ASCII character
   * which is not a letter or a digit. Regular word text is any non-whitespace
   * (here "whitespace" includes non-breaking whitespace).
   * Word break points are the punctuation breaks defined above, plus
   * for Unicode text, whatever intl's wordbreaker identifies, and for
   * ASCII text, boundaries between whitespace and non-whitespace.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRInt32</name></type>
  <name>FindWordBoundary</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsTextFragment</name>*</type> <name>aText</name></decl></param>,
                   <param><decl><type><name>gfxTextRun</name>*</type> <name>aTextRun</name></decl></param>,
                   <param><decl><type><name>gfxSkipCharsIterator</name>*</type> <name>aIterator</name></decl></param>,
                   <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aLength</name></decl></param>,
                   <param><decl><type><name>PRInt32</name></type> <name>aPosition</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aDirection</name></decl></param>,
                   <param><decl><type><name>PRBool</name></type> <name>aBreakBeforePunctuation</name></decl></param>,
                   <param><decl><type><name>PRBool</name></type> <name>aBreakAfterPunctuation</name></decl></param>,
                   <param><decl><type><name>PRBool</name>*</type> <name>aWordIsWhitespace</name></decl></param>)</parameter_list>;</function_decl>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>nsSkipCharsRunIterator</name> <block>{
<label><name>public</name>:</label>
  <enum>enum <name>LengthMode</name> <block>{
    <decl><name>LENGTH_UNSKIPPED_ONLY</name>   <init>= <expr><name>PR_FALSE</name></expr></init></decl>,
    <decl><name>LENGTH_INCLUDES_SKIPPED</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>
  }</block>;</enum>
  <macro><name>nsSkipCharsRunIterator</name><argument_list>(<argument>const gfxSkipCharsIterator&amp; aStart</argument>,
      <argument>LengthMode aLengthIncludesSkipped</argument>, <argument>PRUint32 aLength</argument>)</argument_list></macro>
    : <expr_stmt><expr><call><name>mIterator</name><argument_list>(<argument><expr><name>aStart</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mRemainingLength</name><argument_list>(<argument><expr><name>aLength</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mRunLength</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>,
      <expr><call><name>mVisitSkipped</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>,
      <macro><name>mLengthIncludesSkipped</name><argument_list>(<argument>aLengthIncludesSkipped</argument>)</argument_list></macro> <expr><block>{
  }</block>
  <name>void</name> <macro><name>SetVisitSkipped</name><argument_list>()</argument_list></macro> <block>{ <expr><name>mVisitSkipped</name> = <name>PR_TRUE</name></expr>; }</block>
  <name>void</name> <macro><name>SetOriginalOffset</name><argument_list>(<argument>PRInt32 aOffset</argument>)</argument_list></macro> <block>{
    <expr><call><name><name>mIterator</name>.<name>SetOriginalOffset</name></name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;
  }</block>
  <name>void</name> <macro><name>SetSkippedOffset</name><argument_list>(<argument>PRUint32 aOffset</argument>)</argument_list></macro> <block>{
    <expr><call><name><name>mIterator</name>.<name>SetSkippedOffset</name></name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;
  }</block>

  <comment type="line">// guaranteed to return only positive-length runs</comment>
  <name>PRBool</name> <call><name>NextRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsSkipped</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mSkipped</name></expr>;</return> }</block></expr></expr_stmt>
  <comment type="line">// Always returns something &gt; 0</comment>
  <expr_stmt><expr><name>PRInt32</name> <macro><name>GetRunLength</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mRunLength</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>gfxSkipCharsIterator</name>&amp; <macro><name>GetPos</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mIterator</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRInt32</name> <macro><name>GetOriginalOffset</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>mIterator</name>.<name>GetOriginalOffset</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRUint32</name> <macro><name>GetSkippedOffset</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>mIterator</name>.<name>GetSkippedOffset</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
  <decl_stmt><decl><type><name>gfxSkipCharsIterator</name></type> <name>mIterator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>              <name>mRemainingLength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>              <name>mRunLength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>         <name>mSkipped</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>         <name>mVisitSkipped</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>         <name>mLengthIncludesSkipped</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*NSTEXTFRAMEUTILS_H_*/</comment>
</unit>
