<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="004da2074ddd52bfdbf46958af5bb5f5ff991295.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is Google Inc.
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Darin Fisher &lt;darin@meer.net&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBaseChannel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsChannelProperties.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsURLHelper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNetUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMimeTypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIOService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIHttpEventSink.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIHttpChannel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIChannelEventSink.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIStreamConverterService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContentSniffer.h"</cpp:file></cpp:include>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PLDHashOperator</argument>)</argument_list></macro>
<macro><name>CopyProperties</name><argument_list>(<argument>const nsAString &amp;key</argument>, <argument>nsIVariant *data</argument>, <argument>void *closure</argument>)</argument_list></macro>
<block>{
  <decl_stmt><decl><type><name>nsIWritablePropertyBag</name> *</type><name>bag</name> <init>=
      <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIWritablePropertyBag</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>bag</name>-&gt;<name>SetProperty</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block>

<comment type="line">// This class is used to suspend a request across a function scope.</comment>
<class>class <name>ScopedRequestSuspender</name> <block>{<private type="default">
</private><public>public:
  <constructor><name>ScopedRequestSuspender</name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>)</parameter_list>
    <member_list>: <call><name>mRequest</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call> </member_list><block>{
    <if>if <condition>(<expr><name>mRequest</name> &amp;&amp; <call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>mRequest</name>-&gt;<name>Suspend</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Couldn't suspend pump"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mRequest</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></constructor>
  <destructor><name>~<name>ScopedRequestSuspender</name></name><parameter_list>()</parameter_list> <block>{
    <if>if <condition>(<expr><name>mRequest</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mRequest</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></destructor>
</public><private>private:
  <decl_stmt><decl><type><name>nsIRequest</name> *</type><name>mRequest</name></decl>;</decl_stmt>
</private>}</block>;</class>

<comment type="line">// Used to suspend data events from mPump within a function scope.  This is</comment>
<comment type="line">// usually needed when a function makes callbacks that could process events.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPEND_PUMP_FOR_SCOPE</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>ScopedRequestSuspender pump_suspender__(mPump)</cpp:value></cpp:define>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel</comment>

<constructor><name><name>nsBaseChannel</name>::<name>nsBaseChannel</name></name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mLoadFlags</name><argument_list>(<argument><expr><name>LOAD_NORMAL</name></expr></argument>)</argument_list></call>
  , <call><name>mStatus</name><argument_list>(<argument><expr><name>NS_OK</name></expr></argument>)</argument_list></call>
  , <call><name>mQueriedProgressSink</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>
  , <call><name>mSynthProgressEvents</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
  , <call><name>mWasOpened</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name><name>mContentType</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr><name>UNKNOWN_CONTENT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<function><type><name>nsresult</name></type>
<name><name>nsBaseChannel</name>::<name>Redirect</name></name><parameter_list>(<param><decl><type><name>nsIChannel</name> *</type><name>newChannel</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>redirectFlags</name></decl></param>,
                        <param><decl><type><name>PRBool</name></type> <name>openNewChannel</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SUSPEND_PUMP_FOR_SCOPE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Transfer properties</comment>

  <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetOriginalURI</name></name><argument_list>(<argument><expr><call><name>OriginalURI</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetLoadGroup</name></name><argument_list>(<argument><expr><name>mLoadGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetNotificationCallbacks</name></name><argument_list>(<argument><expr><name>mCallbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetLoadFlags</name></name><argument_list>(<argument><expr><name>mLoadFlags</name> | <name>LOAD_REPLACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWritablePropertyBag</name></expr></argument>&gt;</argument_list></name></type> <name>bag</name> <init>= <expr><call><name>::<name>do_QueryInterface</name></name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>bag</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mPropertyHash</name>.<name>EnumerateRead</name></name><argument_list>(<argument><expr><name>CopyProperties</name></expr></argument>, <argument><expr><call><name><name>bag</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Notify consumer, giving chance to cancel redirect.  For backwards compat,</comment>
  <comment type="line">// we support nsIHttpEventSink if we are an HTTP channel and if this is not</comment>
  <comment type="line">// an internal redirect.</comment>

  <comment type="line">// Global observers. These come first so that other observers don't see</comment>
  <comment type="line">// redirects that get aborted for security reasons anyway.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>gIOService</name></expr></argument>, <argument><expr>"Must have an IO service"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>gIOService</name>-&gt;<name>OnChannelRedirect</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>redirectFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <comment type="line">// Backwards compat for non-internal redirects from a HTTP channel.</comment>
  <if>if <condition>(<expr>!(<name>redirectFlags</name> &amp; <name><name>nsIChannelEventSink</name>::<name>REDIRECT_INTERNAL</name></name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpChannel</name></expr></argument>&gt;</argument_list></name></type> <name>httpChannel</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>httpChannel</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpEventSink</name></expr></argument>&gt;</argument_list></name></type> <name>httpEventSink</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>httpEventSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>httpEventSink</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>httpEventSink</name>-&gt;<name>OnRedirect</name></name><argument_list>(<argument><expr><name>httpChannel</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <return>return <expr><name>rv</name></expr>;</return></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIChannelEventSink</name></expr></argument>&gt;</argument_list></name></type> <name>channelEventSink</name></decl>;</decl_stmt>
  <comment type="line">// Give our consumer a chance to observe/block this redirect.</comment>
  <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>channelEventSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>channelEventSink</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>channelEventSink</name>-&gt;<name>OnChannelRedirect</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>redirectFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>rv</name></expr>;</return></then></if>
  }</block></then></if>

  <comment type="line">// If we fail to open the new channel, then we want to leave this channel</comment>
  <comment type="line">// unaffected, so we defer tearing down our channel until we have succeeded</comment>
  <comment type="line">// with the redirect.</comment>

  <if>if <condition>(<expr><name>openNewChannel</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>newChannel</name>-&gt;<name>AsyncOpen</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>rv</name></expr>;</return></then></if>
  }</block></then></if>

  <comment type="line">// close down this channel</comment>
  <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_BINDING_REDIRECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mListener</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mListenerContext</name> = <name>nsnull</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsBaseChannel</name>::<name>HasContentTypeHint</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>IsPending</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"HasContentTypeHint called too late"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>!<call><name><name>mContentType</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr><name>UNKNOWN_CONTENT_TYPE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBaseChannel</name>::<name>SetContentLength64</name></name><parameter_list>(<param><decl><type><name>PRInt64</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXX: Storing the content-length as a property may not be what we want.</comment>
  <comment type="line">//      It has the drawback of being copied if we redirect this channel.</comment>
  <comment type="line">//      Maybe it is time for nsIChannel2.</comment>
  <expr_stmt><expr><call><name>SetPropertyAsInt64</name><argument_list>(<argument><expr><name>NS_CHANNEL_PROP_CONTENT_LENGTH</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRInt64</name></type>
<name><name>nsBaseChannel</name>::<name>ContentLength64</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetPropertyAsInt64</name><argument_list>(<argument><expr><name>NS_CHANNEL_PROP_CONTENT_LENGTH</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> ? <name>len</name> : -1</expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsBaseChannel</name>::<name>PushStreamConverter</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromType</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>toType</name></decl></param>,
                                   <param><decl><type><name>PRBool</name></type> <name>invalidatesContentLength</name></decl></param>,
                                   <param><decl><type><name>nsIStreamListener</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr>"no listener"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamConverterService</name></expr></argument>&gt;</argument_list></name></type> <name>scs</name> <init>=
      <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_STREAMCONVERTERSERVICE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListener</name></expr></argument>&gt;</argument_list></name></type> <name>converter</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>scs</name>-&gt;<name>AsyncConvertData</name></name><argument_list>(<argument><expr><name>fromType</name></expr></argument>, <argument><expr><name>toType</name></expr></argument>, <argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>,
                             <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>converter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mListener</name> = <name>converter</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>invalidatesContentLength</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>SetContentLength64</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>result</name> = <name>nsnull</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>converter</name>.<name>swap</name></name><argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsBaseChannel</name>::<name>BeginPumpingData</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInputStream</name></expr></argument>&gt;</argument_list></name></type> <name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIChannel</name></expr></argument>&gt;</argument_list></name></type> <name>channel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>OpenContentStream</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>stream</name> || !<name>channel</name></expr></argument>, <argument><expr>"Got both a channel and a stream?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>channel</name></expr>)</condition><then>
      <return>return <expr><call><name>NS_DispatchToCurrentThread</name><argument_list>(<argument><expr>new <call><name>RedirectRunnable</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="line">// By assigning mPump, we flag this channel as pending (see IsPending).  It's</comment>
  <comment type="line">// important that the pending flag is set when we call into the stream (the</comment>
  <comment type="line">// call to AsyncRead results in the stream's AsyncWait method being called)</comment>
  <comment type="line">// and especially when we call into the loadgroup.  Our caller takes care to</comment>
  <comment type="line">// release mPump if we return an error.</comment>
 
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsInputStreamPump</name>::<name>Create</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mPump</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mPump</name>-&gt;<name>AsyncRead</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBaseChannel</name>::<name>HandleAsyncRedirect</name></name><parameter_list>(<param><decl><type><name>nsIChannel</name>*</type> <name>newChannel</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mPump</name></expr></argument>, <argument><expr>"Shouldn't have gotten here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>Redirect</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name><name>nsIChannelEventSink</name>::<name>REDIRECT_INTERNAL</name></name></expr></argument>,
                         <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Notify our consumer ourselves</comment>
    <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStartRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStopRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListener</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListenerContext</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Drop notification callbacks to prevent cycles.</comment>
  <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CallbacksChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsISupports</comment>

<macro><name>NS_IMPL_ISUPPORTS_INHERITED6</name><argument_list>(<argument>nsBaseChannel</argument>,
                             <argument>nsHashPropertyBag</argument>,
                             <argument>nsIRequest</argument>,
                             <argument>nsIChannel</argument>,
                             <argument>nsIInterfaceRequestor</argument>,
                             <argument>nsITransportEventSink</argument>,
                             <argument>nsIRequestObserver</argument>,
                             <argument>nsIStreamListener</argument>)</argument_list></macro>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsIRequest</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetName</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>result</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mURI</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>result</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><call><name><name>mURI</name>-&gt;<name>GetSpec</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>IsPending</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>result</name> = <call><name>IsPending</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetStatus</name></name><parameter_list>(<param><decl><type><name>nsresult</name> *</type><name>status</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mPump</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mPump</name>-&gt;<name>GetStatus</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr>*<name>status</name> = <name>mStatus</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>Cancel</name></name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Ignore redundant cancelation</comment>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <expr_stmt><expr><name>mStatus</name> = <name>status</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mPump</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mPump</name>-&gt;<name>Cancel</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>Suspend</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mPump</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>mPump</name>-&gt;<name>Suspend</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>Resume</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mPump</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>mPump</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetLoadFlags</name></name><parameter_list>(<param><decl><type><name>nsLoadFlags</name> *</type><name>aLoadFlags</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aLoadFlags</name> = <name>mLoadFlags</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetLoadFlags</name></name><parameter_list>(<param><decl><type><name>nsLoadFlags</name></type> <name>aLoadFlags</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mLoadFlags</name> = <name>aLoadFlags</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetLoadGroup</name></name><parameter_list>(<param><decl><type><name>nsILoadGroup</name> **</type><name>aLoadGroup</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aLoadGroup</name> = <name>mLoadGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetLoadGroup</name></name><parameter_list>(<param><decl><type><name>nsILoadGroup</name> *</type><name>aLoadGroup</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mLoadGroup</name> = <name>aLoadGroup</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CallbacksChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsIChannel</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetOriginalURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> **</type><name>aURI</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aURI</name> = <call><name>OriginalURI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetOriginalURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> *</type><name>aURI</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mOriginalURI</name> = <name>aURI</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> **</type><name>aURI</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aURI</name> = <name>mURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetOwner</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>aOwner</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aOwner</name> = <name>mOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetOwner</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>aOwner</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mOwner</name> = <name>aOwner</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetNotificationCallbacks</name></name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name> **</type><name>aCallbacks</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aCallbacks</name> = <name>mCallbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetNotificationCallbacks</name></name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name> *</type><name>aCallbacks</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mCallbacks</name> = <name>aCallbacks</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CallbacksChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>nsBaseChannel</name>::<name>GetSecurityInfo</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>aSecurityInfo</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aSecurityInfo</name> = <name>mSecurityInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetContentType</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>aContentType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>aContentType</name> = <name>mContentType</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetContentType</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>aContentType</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// mContentCharset is unchanged if not parsed</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>dummy</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>net_ParseContentType</name><argument_list>(<argument><expr><name>aContentType</name></expr></argument>, <argument><expr><name>mContentType</name></expr></argument>, <argument><expr><name>mContentCharset</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetContentCharset</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>aContentCharset</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>aContentCharset</name> = <name>mContentCharset</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetContentCharset</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>aContentCharset</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mContentCharset</name> = <name>aContentCharset</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetContentLength</name></name><parameter_list>(<param><decl><type><name>PRInt32</name> *</type><name>aContentLength</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>len</name> <init>= <expr><call><name>ContentLength64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>len</name> &gt; <name>PR_INT32_MAX</name> || <name>len</name> &lt; 0</expr>)</condition><then>
    <expr_stmt><expr>*<name>aContentLength</name> = -1</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>aContentLength</name> = (<name>PRInt32</name>) <name>len</name></expr>;</expr_stmt></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>SetContentLength</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aContentLength</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SetContentLength64</name><argument_list>(<argument><expr><name>aContentLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>Open</name></name><parameter_list>(<param><decl><type><name>nsIInputStream</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mPump</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIChannel</name></expr></argument>&gt;</argument_list></name></type> <name>chan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>OpenContentStream</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>chan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>chan</name> || !*<name>result</name></expr></argument>, <argument><expr>"Got both a channel and a stream?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>chan</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>Redirect</name><argument_list>(<argument><expr><name>chan</name></expr></argument>, <argument><expr><name><name>nsIChannelEventSink</name>::<name>REDIRECT_INTERNAL</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <return>return <expr><name>rv</name></expr>;</return></then></if>
      <expr_stmt><expr><name>rv</name> = <call><name><name>chan</name>-&gt;<name>Open</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_NOT_IMPLEMENTED</name></expr>)</condition><then>
    <return>return <expr><call><name>NS_ImplementChannelOpen</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <expr_stmt><expr><name>mWasOpened</name> = <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>AsyncOpen</name></name><parameter_list>(<param><decl><type><name>nsIStreamListener</name> *</type><name>listener</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mPump</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_ALREADY_OPENED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_ARG</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Ensure that this is an allowed port before proceeding.</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>NS_CheckPortSafety</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Store the listener and context early so that OpenContentStream and the</comment>
  <comment type="line">// stream's AsyncWait method (called by AsyncRead) can have access to them</comment>
  <comment type="line">// via PushStreamConverter and the StreamListener methods.  However, since</comment>
  <comment type="line">// this typically introduces a reference cycle between this and the listener,</comment>
  <comment type="line">// we need to be sure to break the reference if this method does not succeed.</comment>
  <expr_stmt><expr><name>mListener</name> = <name>listener</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mListenerContext</name> = <name>ctxt</name></expr>;</expr_stmt>

  <comment type="line">// This method assigns mPump as a side-effect.  We need to clear mPump if</comment>
  <comment type="line">// this method fails.</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>BeginPumpingData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mPump</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListener</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListenerContext</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// At this point, we are going to return success no matter what.</comment>

  <expr_stmt><expr><name>mWasOpened</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SUSPEND_PUMP_FOR_SCOPE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>AddRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsITransportEventSink</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>OnTransportStatus</name></name><parameter_list>(<param><decl><type><name>nsITransport</name> *</type><name>transport</name></decl></param>, <param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>,
                                 <param><decl><type><name>PRUint64</name></type> <name>progress</name></decl></param>, <param><decl><type><name>PRUint64</name></type> <name>progressMax</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// In some cases, we may wish to suppress transport-layer status events.</comment>

  <if>if <condition>(<expr>!<name>mPump</name> || <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call> || <call><name>HasLoadFlag</name><argument_list>(<argument><expr><name>LOAD_BACKGROUND</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SUSPEND_PUMP_FOR_SCOPE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Lazily fetch mProgressSink</comment>
  <if>if <condition>(<expr>!<name>mProgressSink</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>mQueriedProgressSink</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>mProgressSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mQueriedProgressSink</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mProgressSink</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>statusArg</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>GetStatusArg</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>statusArg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mProgressSink</name>-&gt;<name>OnStatus</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><call><name><name>statusArg</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>progress</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mProgressSink</name>-&gt;<name>OnProgress</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>, <argument><expr><name>progressMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsIInterfaceRequestor</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>GetInterface</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIID</name> &amp;</type><name>iid</name></decl></param>, <param><decl><type><name>void</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_QueryNotificationCallbacks</name><argument_list>(<argument><expr><name>mCallbacks</name></expr></argument>, <argument><expr><name>mLoadGroup</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>*<name>result</name> ? <name>NS_OK</name> : <name>NS_ERROR_NO_INTERFACE</name></expr>;</return> 
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsIRequestObserver</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CallTypeSniffers</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>aClosure</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRUint8</name> *</type><name>aData</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIChannel</name> *</type><name>chan</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIChannel</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIContentSniffer</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>sniffers</name> <init>=
    <expr><call><name><name>gIOService</name>-&gt;<name>GetContentSniffers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name><name>sniffers</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>newType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=
      <expr><name><name>sniffers</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>GetMIMETypeFromContent</name><argument_list>(<argument><expr><name>chan</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>, <argument><expr><name>newType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>newType</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>chan</name>-&gt;<name>SetContentType</name></name><argument_list>(<argument><expr><name>newType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CallUnknownTypeSniffer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>aClosure</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRUint8</name> *</type><name>aData</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIChannel</name> *</type><name>chan</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIChannel</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContentSniffer</name></expr></argument>&gt;</argument_list></name></type> <name>sniffer</name> <init>=
    <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>NS_GENERIC_CONTENT_SNIFFER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sniffer</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>detected</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>sniffer</name>-&gt;<name>GetMIMETypeFromContent</name></name><argument_list>(<argument><expr><name>chan</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>, <argument><expr><name>detected</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>chan</name>-&gt;<name>SetContentType</name></name><argument_list>(<argument><expr><name>detected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>OnStartRequest</name></name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// If our content type is unknown, then use the content type sniffer.  If the</comment>
  <comment type="line">// sniffer is not available for some reason, then we just keep going as-is.</comment>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>mContentType</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr><name>UNKNOWN_CONTENT_TYPE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mPump</name>-&gt;<name>PeekStream</name></name><argument_list>(<argument><expr><name>CallUnknownTypeSniffer</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIChannel</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Now, the general type sniffers. Skip this if we have none.</comment>
  <if>if <condition>(<expr>(<name>mLoadFlags</name> &amp; <name>LOAD_CALL_CONTENT_SNIFFERS</name>) &amp;&amp;
      <call><name><name>gIOService</name>-&gt;<name>GetContentSniffers</name></name><argument_list>()</argument_list></call>.<call><name>Count</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mPump</name>-&gt;<name>PeekStream</name></name><argument_list>(<argument><expr><name>CallTypeSniffers</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIChannel</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SUSPEND_PUMP_FOR_SCOPE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>mListener</name>-&gt;<name>OnStartRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>OnStopRequest</name></name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>,
                             <param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// If both mStatus and status are failure codes, we keep mStatus as-is since</comment>
  <comment type="line">// that is consistent with our GetStatus and Cancel methods.</comment>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>mStatus</name> = <name>status</name></expr>;</expr_stmt></then></if>

  <comment type="line">// Cause IsPending to return false.</comment>
  <expr_stmt><expr><name>mPump</name> = <name>nsnull</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStopRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mListener</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mListenerContext</name> = <name>nsnull</name></expr>;</expr_stmt>

  <comment type="line">// No need to suspend pump in this scope since we will not be receiving</comment>
  <comment type="line">// any more events from it.</comment>

  <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Drop notification callbacks to prevent cycles.</comment>
  <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CallbacksChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsBaseChannel::nsIStreamListener</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBaseChannel</name>::<name>OnDataAvailable</name></name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>,
                               <param><decl><type><name>nsIInputStream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>offset</name></decl></param>,
                               <param><decl><type><name>PRUint32</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SUSPEND_PUMP_FOR_SCOPE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mListener</name>-&gt;<name>OnDataAvailable</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>,
                                           <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mSynthProgressEvents</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRUint64</name></type> <name>prog</name> <init>= <expr><call><name>PRUint64</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> + <name>count</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint64</name></type> <name>progMax</name> <init>= <expr><call><name>ContentLength64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OnTransportStatus</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>nsITransport</name>::<name>STATUS_READING</name></name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>progMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>
</unit>
