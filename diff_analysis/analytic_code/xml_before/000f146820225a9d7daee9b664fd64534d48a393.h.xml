<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="000f146820225a9d7daee9b664fd64534d48a393.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Elika J. Etemad ("fantasai") &lt;fantasai@inkedblade.net&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/* base class #1 for rendering objects that have child lists */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>nsContainerFrame_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsContainerFrame_h___</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSplittableFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutUtils.h"</cpp:file></cpp:include>

<comment type="block">/**
 * Child list name indices
 * @see #GetAdditionalChildListName()
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_CONTAINER_LIST_COUNT_SANS_OC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
  <comment type="line">// for frames that don't use overflow containers</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_CONTAINER_LIST_COUNT_INCL_OC</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
  <comment type="line">// for frames that support overflow containers</comment>

<comment type="line">// Option flags for ReflowChild() and FinishReflowChild()</comment>
<comment type="line">// member functions</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_FRAME_NO_MOVE_VIEW</name></cpp:macro>         <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_FRAME_NO_MOVE_FRAME</name></cpp:macro>        <cpp:value>(0x0002 | NS_FRAME_NO_MOVE_VIEW)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_FRAME_NO_SIZE_VIEW</name></cpp:macro>         <cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_FRAME_NO_VISIBILITY</name></cpp:macro>        <cpp:value>0x0008</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>nsOverflowContinuationTracker</name></decl>;</decl_stmt>

<comment type="block">/**
 * Implementation of a container frame.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsContainerFrame</name> : <name>public</name> <name>nsSplittableFrame</name>
<block>{
<expr><name>public</name>:
  <comment type="line">// nsIFrame overrides</comment>
  <name>NS_IMETHOD</name> <call><name>Init</name><argument_list>(<argument><expr><name>nsIContent</name>* <name>aContent</name></expr></argument>,
                  <argument><expr><name>nsIFrame</name>*   <name>aParent</name></expr></argument>,
                  <argument><expr><name>nsIFrame</name>*   <name>aPrevInFlow</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>NS_IMETHOD</name> <call><name>SetInitialChildList</name><argument_list>(<argument><expr><name>nsIAtom</name>*  <name>aListName</name></expr></argument>,
                                 <argument><expr><name>nsIFrame</name>* <name>aChildList</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>NS_IMETHOD</name> <call><name>AppendFrames</name><argument_list>(<argument><expr><name>nsIAtom</name>*  <name>aListName</name></expr></argument>,
                          <argument><expr><name>nsIFrame</name>* <name>aFrameList</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>NS_IMETHOD</name> <call><name>InsertFrames</name><argument_list>(<argument><expr><name>nsIAtom</name>*  <name>aListName</name></expr></argument>,
                          <argument><expr><name>nsIFrame</name>* <name>aPrevFrame</name></expr></argument>,
                          <argument><expr><name>nsIFrame</name>* <name>aFrameList</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>NS_IMETHOD</name> <call><name>RemoveFrame</name><argument_list>(<argument><expr><name>nsIAtom</name>*  <name>aListName</name></expr></argument>,
                         <argument><expr><name>nsIFrame</name>* <name>aOldFrame</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>virtual</name> <name>nsIFrame</name>* <macro><name>GetFirstChild</name><argument_list>(<argument>nsIAtom* aListName</argument>)</argument_list></macro> const</expr>;
  <expr><name>virtual</name> <name>nsIAtom</name>* <macro><name>GetAdditionalChildListName</name><argument_list>(<argument>PRInt32 aIndex</argument>)</argument_list></macro> const</expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>Destroy</name><argument_list>()</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>ChildIsDirty</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aChild</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>virtual</name> <name>PRBool</name> <macro><name>IsLeaf</name><argument_list>()</argument_list></macro> const</expr>;
  <expr><name>virtual</name> <name>PRBool</name> <macro><name>PeekOffsetNoAmount</name><argument_list>(<argument>PRBool aForward</argument>, <argument>PRInt32* aOffset</argument>)</argument_list></macro></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <macro><name>PeekOffsetCharacter</name><argument_list>(<argument>PRBool aForward</argument>, <argument>PRInt32* aOffset</argument>)</argument_list></macro></expr>;
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr><name>NS_IMETHOD</name> <macro><name>List</name><argument_list>(<argument>FILE* out</argument>, <argument>PRInt32 aIndent</argument>)</argument_list></macro> const</expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  

  <comment type="line">// nsContainerFrame methods</comment>
  <expr><name>virtual</name> <name>void</name> <call><name>DeleteNextInFlowChild</name><argument_list>(<argument><expr><name>nsPresContext</name>* <name>aPresContext</name></expr></argument>,
                                     <argument><expr><name>nsIFrame</name>*       <name>aNextInFlow</name></expr></argument>)</argument_list></call></expr>;

  <expr>static <name>PRInt32</name> <macro><name>LengthOf</name><argument_list>(<argument>nsIFrame* aFrameList</argument>)</argument_list></macro> <block>{
    <expr><name>nsFrameList</name> <call><name>tmp</name><argument_list>(<argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><call><name><name>tmp</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>
  }</block>

  <comment type="line">// Positions the frame's view based on the frame's origin</comment>
  static <name>void</name> <call><name>PositionFrameView</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aKidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Set the view's size and position after its frame has been reflowed.</comment>
  <comment type="line">//</comment>
  <comment type="line">// Flags:</comment>
  <comment type="line">// NS_FRAME_NO_MOVE_VIEW - don't position the frame's view. Set this if you</comment>
  <comment type="line">//    don't want to automatically sync the frame and view</comment>
  <comment type="line">// NS_FRAME_NO_SIZE_VIEW - don't size the view</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SyncFrameViewAfterReflow</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                                       <param><decl><type><name>nsIFrame</name>*</type>       <name>aFrame</name></decl></param>,
                                       <param><decl><type><name>nsIView</name>*</type>        <name>aView</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type>   <name>aCombinedArea</name></decl></param>,
                                       <param><decl><type><name>PRUint32</name></type>        <name>aFlags</name> <init>= <expr>0</expr></init></decl></param>)</parameter_list>;</function_decl>
  
  <comment type="line">// Sets the view's attributes from the frame style.</comment>
  <comment type="line">// - opacity</comment>
  <comment type="line">// - visibility</comment>
  <comment type="line">// - content transparency</comment>
  <comment type="line">// - clip</comment>
  <comment type="line">// Call this when one of these styles changes or when the view has just</comment>
  <comment type="line">// been created.</comment>
  <comment type="line">// @param aStyleContext can be null, in which case the frame's style context is used</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SyncFrameViewProperties</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>  <name>aPresContext</name></decl></param>,
                                      <param><decl><type><name>nsIFrame</name>*</type>        <name>aFrame</name></decl></param>,
                                      <param><decl><type><name>nsStyleContext</name>*</type>  <name>aStyleContext</name></decl></param>,
                                      <param><decl><type><name>nsIView</name>*</type>         <name>aView</name></decl></param>,
                                      <param><decl><type><name>PRUint32</name></type>         <name>aFlags</name> <init>= <expr>0</expr></init></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Returns PR_TRUE if the frame requires a view</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>FrameNeedsView</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  
  <comment type="line">// Used by both nsInlineFrame and nsFirstLetterFrame.</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>DoInlineIntrinsicWidth</name><argument_list>(<argument><expr><name>nsIRenderingContext</name> *<name>aRenderingContext</name></expr></argument>,
                              <argument><expr><name>InlineIntrinsicWidthData</name> *<name>aData</name></expr></argument>,
                              <argument><expr><name>nsLayoutUtils</name>::<name>IntrinsicWidthType</name> <name>aType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="block">/**
   * This is the CSS block concept of computing 'auto' widths, which most
   * classes derived from nsContainerFrame want.
   */</comment>
  <function_decl><type><name>virtual</name> <name>nsSize</name></type> <name>ComputeAutoSize</name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>,
                                 <param><decl><type><name>nsSize</name></type> <name>aCBSize</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aAvailableWidth</name></decl></param>,
                                 <param><decl><type><name>nsSize</name></type> <name>aMargin</name></decl></param>, <param><decl><type><name>nsSize</name></type> <name>aBorder</name></decl></param>,
                                 <param><decl><type><name>nsSize</name></type> <name>aPadding</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aShrinkWrap</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Invokes the WillReflow() function, positions the frame and its view (if
   * requested), and then calls Reflow(). If the reflow succeeds and the child
   * frame is complete, deletes any next-in-flows using DeleteNextInFlowChild()
   *
   * Flags:
   * NS_FRAME_NO_MOVE_VIEW - don't position the frame's view. Set this if you
   *    don't want to automatically sync the frame and view
   * NS_FRAME_NO_MOVE_FRAME - don't move the frame. aX and aY are ignored in this
   *    case. Also implies NS_FRAME_NO_MOVE_VIEW
   */</comment>
  <function_decl><type><name>nsresult</name></type> <name>ReflowChild</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>                      <name>aKidFrame</name></decl></param>,
                       <param><decl><type><name>nsPresContext</name>*</type>                 <name>aPresContext</name></decl></param>,
                       <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>           <name>aDesiredSize</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type>       <name>aReflowState</name></decl></param>,
                       <param><decl><type><name>nscoord</name></type>                        <name>aX</name></decl></param>,
                       <param><decl><type><name>nscoord</name></type>                        <name>aY</name></decl></param>,
                       <param><decl><type><name>PRUint32</name></type>                       <name>aFlags</name></decl></param>,
                       <param><decl><type><name>nsReflowStatus</name>&amp;</type>                <name>aStatus</name></decl></param>,
                       <param><decl><type><name>nsOverflowContinuationTracker</name>*</type> <name>aTracker</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * The second half of frame reflow. Does the following:
   * - sets the frame's bounds
   * - sizes and positions (if requested) the frame's view. If the frame's final
   *   position differs from the current position and the frame itself does not
   *   have a view, then any child frames with views are positioned so they stay
   *   in sync
   * - sets the view's visibility, opacity, content transparency, and clip
   * - invoked the DidReflow() function
   *
   * Flags:
   * NS_FRAME_NO_MOVE_FRAME - don't move the frame. aX and aY are ignored in this
   *    case. Also implies NS_FRAME_NO_MOVE_VIEW
   * NS_FRAME_NO_MOVE_VIEW - don't position the frame's view. Set this if you
   *    don't want to automatically sync the frame and view
   * NS_FRAME_NO_SIZE_VIEW - don't size the frame's view
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>FinishReflowChild</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>                 <name>aKidFrame</name></decl></param>,
                                    <param><decl><type><name>nsPresContext</name>*</type>            <name>aPresContext</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type>  <name>aReflowState</name></decl></param>,
                                    <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>      <name>aDesiredSize</name></decl></param>,
                                    <param><decl><type><name>nscoord</name></type>                   <name>aX</name></decl></param>,
                                    <param><decl><type><name>nscoord</name></type>                   <name>aY</name></decl></param>,
                                    <param><decl><type><name>PRUint32</name></type>                  <name>aFlags</name></decl></param>)</parameter_list>;</function_decl>

  
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PositionChildViews</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// ==========================================================================</comment>
  <comment type="block">/* Overflow containers are continuation frames that hold overflow. They
   * are created when the frame runs out of computed height, but still has
   * too much content to fit in the availableHeight. The parent creates a
   * continuation as usual, but marks it as NS_FRAME_IS_OVERFLOW_CONTAINER
   * and adds it to its next-in-flow's overflow container list, either by
   * adding it directly or by putting it in its own excess overflow containers
   * list (to be drained by the next-in-flow when it calls
   * ReflowOverflowContainerChildren). The parent continues reflow as if
   * the frame was complete once it ran out of computed height, but returns
   * either an NS_FRAME_NOT_COMPLETE or NS_FRAME_OVERFLOW_INCOMPLETE reflow
   * status to request a next-in-flow. The parent's next-in-flow is then
   * responsible for calling ReflowOverflowContainerChildren to (drain and)
   * reflow these overflow continuations. Overflow containers do not affect
   * other frames' size or position during reflow (but do affect their
   * parent's overflow area).
   *
   * Overflow container continuations are different from normal continuations
   * in that
   *   - more than one child of the frame can have its next-in-flow broken
   *     off and pushed into the frame's next-in-flow
   *   - new continuations may need to be spliced into the middle of the list
   *     or deleted continuations slipped out
   *     e.g. A, B, C are all fixed-size containers on one page, all have
   *      overflow beyond availableHeight, and content is dynamically added
   *      and removed from B
   * As a result, it is not possible to simply prepend the new continuations
   * to the old list as with the overflowProperty mechanism. To avoid
   * complicated list splicing, the code assumes only one overflow containers
   * list exists for a given frame: either its own overflowContainersProperty
   * or its prev-in-flow's excessOverflowContainersProperty, not both.
   *
   * The nsOverflowContinuationTracker helper class should be used for tracking
   * overflow containers and adding them to the appropriate list.
   * See nsBlockFrame::Reflow for a sample implementation.
   */</comment>

  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>nsOverflowContinuationTracker</name></decl>;</decl_stmt>

  <comment type="block">/**
   * Reflow overflow container children. They are invisible to normal reflow
   * (i.e. don't affect sizing or placement of other children) and inherit
   * width and horizontal position from their prev-in-flow.
   *
   * This method
   *   1. Pulls excess overflow containers from the prev-in-flow and adds
   *      them to our overflow container list
   *   2. Reflows all our overflow container kids
   *   3. Expands aOverflowRect as necessary to accomodate these children.
   *   4. Sets aStatus's NS_FRAME_OVERFLOW_IS_INCOMPLETE flag (along with
   *      NS_FRAME_REFLOW_NEXTINFLOW as necessary) if any overflow children
   *      are incomplete and
   *   5. Prepends a list of their continuations to our excess overflow
   *      container list, to be drained into our next-in-flow when it is
   *      reflowed.
   *
   * The caller is responsible for tracking any new overflow container
   * continuations it makes, removing them from its child list, and
   * making sure they are stored properly in the overflow container lists.
   * The nsOverflowContinuationTracker helper class should be used for this.
   *
   * (aFlags just gets passed through to ReflowChild)
   */</comment>
  <function_decl><type><name>nsresult</name></type> <name>ReflowOverflowContainerChildren</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>           <name>aPresContext</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                                           <param><decl><type><name>nsRect</name>&amp;</type>                  <name>aOverflowRect</name></decl></param>,
                                           <param><decl><type><name>PRUint32</name></type>                 <name>aFlags</name></decl></param>,
                                           <param><decl><type><name>nsReflowStatus</name>&amp;</type>          <name>aStatus</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Removes aChild without destroying it and without requesting reflow.
   * Continuations are not affected. Checks the primary and overflow
   * or overflow containers and excess overflow containers lists, depending
   * on whether the NS_FRAME_IS_OVERFLOW_CONTAINER flag is set. Does not
   * check any other auxiliary lists.
   * Returns NS_ERROR_UNEXPECTED if we failed to remove aChild.
   * Returns other error codes if we failed to put back a proptable list.
   * If aForceNormal is true, only checks the primary and overflow lists
   * even when the NS_FRAME_IS_OVERFLOW_CONTAINER flag is set.
   */</comment>
  <function_decl><type><name>virtual</name> <name>nsresult</name></type> <name>StealFrame</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                              <param><decl><type><name>nsIFrame</name>*</type>      <name>aChild</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type>         <name>aForceNormal</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Add overflow containers to the display list
   */</comment>
  <function_decl><type><name>void</name></type> <name>DisplayOverflowContainers</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type>   <name>aBuilder</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>           <name>aDirtyRect</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Builds display lists for the children. The background
   * of each child is placed in the Content() list (suitable for inline
   * children and other elements that behave like inlines,
   * but not for in-flow block children of blocks).  DOES NOT
   * paint the background/borders/outline of this frame. This should
   * probably be avoided and eventually removed. It's currently here
   * to emulate what nsContainerFrame::Paint did.
   */</comment>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>BuildDisplayList</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type>   <name>aBuilder</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>           <name>aDirtyRect</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
  <expr_stmt><expr><call><name>nsContainerFrame</name><argument_list>(<argument><expr><name>nsStyleContext</name>* <name>aContext</name></expr></argument>)</argument_list></call> : <macro><name>nsSplittableFrame</name><argument_list>(<argument>aContext</argument>)</argument_list></macro> <block>{}</block>
  ~<call><name>nsContainerFrame</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Builds a display list for non-block children that behave like
   * inlines. This puts the background of each child into the
   * Content() list (suitable for inline children but not for
   * in-flow block children of blocks).
   * @param aForcePseudoStack forces each child into a pseudo-stacking-context
   * so its background and all other display items (except for positioned
   * display items) go into the Content() list.
   */</comment>
  <function_decl><type><name>nsresult</name></type> <name>BuildDisplayListForNonBlockChildren</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type>   <name>aBuilder</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>           <name>aDirtyRect</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>,
                                               <param><decl><type><name>PRUint32</name></type>                <name>aFlags</name> <init>= <expr>0</expr></init></decl></param>)</parameter_list>;</function_decl>


  <comment type="line">// ==========================================================================</comment>
  <comment type="block">/* Overflow Frames are frames that did not fit and must be pulled by
   * our next-in-flow during its reflow. (The same concept for overflow
   * containers is called "excess frames". We should probably make the
   * names match.)
   */</comment>

  <comment type="block">/**
   * Get the frames on the overflow list
   */</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>GetOverflowFrames</name><argument_list>(<argument><expr><name>nsPresContext</name>*  <name>aPresContext</name></expr></argument>,
                              <argument><expr><name>PRBool</name>          <name>aRemoveProperty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <comment type="block">/**
   * Set the overflow list
   */</comment>
  <function_decl><type><name>nsresult</name></type> <name>SetOverflowFrames</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>  <name>aPresContext</name></decl></param>,
                             <param><decl><type><name>nsIFrame</name>*</type>       <name>aOverflowFrames</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Moves any frames on both the prev-in-flow's overflow list and the
   * receiver's overflow to the receiver's child list.
   *
   * Resets the overlist pointers to nsnull, and updates the receiver's child
   * count and content mapping.
   *
   * @return PR_TRUE if any frames were moved and PR_FALSE otherwise
   */</comment>
  <function_decl><type><name>PRBool</name></type> <name>MoveOverflowToChildList</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Push aFromChild and its next siblings to the next-in-flow. Change
   * the geometric parent of each frame that's pushed. If there is no
   * next-in-flow the frames are placed on the overflow list (and the
   * geometric parent is left unchanged).
   *
   * Updates the next-in-flow's child count. Does &lt;b&gt;not&lt;/b&gt; update the
   * pusher's child count.
   *
   * @param   aFromChild the first child frame to push. It is disconnected from
   *            aPrevSibling
   * @param   aPrevSibling aFromChild's previous sibling. Must not be null.
   *            It's an error to push a parent's first child frame
   */</comment>
  <function_decl><type><name>void</name></type> <name>PushChildren</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>  <name>aPresContext</name></decl></param>,
                    <param><decl><type><name>nsIFrame</name>*</type>       <name>aFromChild</name></decl></param>,
                    <param><decl><type><name>nsIFrame</name>*</type>       <name>aPrevSibling</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// ==========================================================================</comment>
  <comment type="block">/*
   * Convenience methods for nsFrameLists stored in the
   * PresContext's proptable
   */</comment>

  <comment type="block">/**
   * Get the PresContext-stored nsFrameList named aPropID for this frame.
   * May return null.
   */</comment>
  <decl_stmt><decl><type><name>nsFrameList</name>*</type> <name>GetPropTableFrames</name><argument_list>(<argument><expr><name>nsPresContext</name>*  <name>aPresContext</name></expr></argument>,
                                  <argument><expr><name>nsIAtom</name>*        <name>aPropID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

  <comment type="block">/**
   * Remove and return the PresContext-stored nsFrameList named aPropID for
   * this frame. May return null.
   */</comment>
  <decl_stmt><decl><type><name>nsFrameList</name>*</type> <name>RemovePropTableFrames</name><argument_list>(<argument><expr><name>nsPresContext</name>*  <name>aPresContext</name></expr></argument>,
                                     <argument><expr><name>nsIAtom</name>*        <name>aPropID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

  <comment type="block">/**
   * Remove aFrame from the PresContext-stored nsFrameList named aPropID
   * for this frame, deleting the list if it is now empty.
   * Return true if the aFrame was successfully removed,
   * Return false otherwise.
   */</comment>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>RemovePropTableFrame</name><argument_list>(<argument><expr><name>nsPresContext</name>*  <name>aPresContext</name></expr></argument>,
                              <argument><expr><name>nsIFrame</name>*       <name>aFrame</name></expr></argument>,
                              <argument><expr><name>nsIAtom</name>*        <name>aPropID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

  <comment type="block">/**
   * Set the PresContext-stored nsFrameList named aPropID for this frame
   * to the given aFrameList, which must not be null.
   */</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>SetPropTableFrames</name><argument_list>(<argument><expr><name>nsPresContext</name>*  <name>aPresContext</name></expr></argument>,
                              <argument><expr><name>nsFrameList</name>*    <name>aFrameList</name></expr></argument>,
                              <argument><expr><name>nsIAtom</name>*        <name>aPropID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <comment type="line">// ==========================================================================</comment>

  <decl_stmt><decl><type><name>nsFrameList</name></type> <name>mFrames</name></decl>;</decl_stmt>
};

<comment type="block">/**
 * Helper class for tracking overflow container continuations during reflow.
 *
 * A frame is related to two sets of overflow containers: those that /are/
 * its own children, and those that are /continuations/ of its children.
 * This tracker walks through those continuations (the frame's NIF's children)
 * and their prev-in-flows (a subset of the frame's normal and overflow
 * container children) in parallel. It allows the reflower to synchronously
 * walk its overflow continuations while it loops through and reflows its
 * children. This makes it possible to insert new continuations at the correct
 * place in the overflow containers list.
 *
 * The reflower is expected to loop through its children in the same order it
 * looped through them the last time (if there was a last time).
 * For each child, the reflower should either
 *   - call Skip for the child if was not reflowed in this pass
 *   - call Insert for the overflow continuation if the child was reflowed
 *     but has incomplete overflow
 *   - call Finished for the child if it was reflowed in this pass but
 *     is either complete or has a normal next-in-flow. This call can
 *     be skipped if the child did not previously have an overflow
 *     continuation.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>nsOverflowContinuationTracker</name> <block>{
<label><name>public</name>:</label>
  <comment type="block">/**
   * Initializes an nsOverflowContinuationTracker to help track overflow
   * continuations of aFrame's children. Typically invoked on 'this'.
   *
   * Don't set aSkipOverflowContainerChildren to PR_FALSE unless you plan
   * to walk your own overflow container children. (Usually they are handled
   * by calling ReflowOverflowContainerChildren.)
   */</comment>
  <macro><name>nsOverflowContinuationTracker</name><argument_list>(<argument>nsPresContext*    aPresContext</argument>,
                                <argument>nsContainerFrame* aFrame</argument>,
                                <argument>PRBool            aSkipOverflowContainerChildren = PR_TRUE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <comment type="block">/**
   * This function adds an overflow continuation to our running list and
   * sets its NS_FRAME_IS_OVERFLOW_CONTAINER flag.
   *
   * aReflowStatus should preferably be specific to the recently-reflowed
   * child and not influenced by any of its siblings' statuses. This
   * function sets the NS_FRAME_IS_DIRTY bit on aOverflowCont if it needs
   * to be reflowed. (Its need for reflow depends on changes to its
   * prev-in-flow, not to its parent--for whom it is invisible, reflow-wise.)
   *
   * The caller MUST disconnect the frame from its parent's child list
   * if it was not previously an NS_FRAME_IS_OVERFLOW_CONTAINER (because
   * StealFrame is much more inefficient than disconnecting in place
   * during Reflow, which the caller is able to do but we are not).
   *
   * The caller MUST NOT disconnect the frame from its parent's
   * child list if it is already an NS_FRAME_IS_OVERFLOW_CONTAINER.
   * (In this case we will disconnect and reconnect it ourselves.)
   */</comment>
  <function_decl><type><name>nsresult</name></type> <name>Insert</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>       <name>aOverflowCont</name></decl></param>,
                  <param><decl><type><name>nsReflowStatus</name>&amp;</type> <name>aReflowStatus</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * This function should be called for each child that is reflowed
   * but no longer has an overflow continuation. It increments our
   * walker and makes sure we drop any dangling pointers to its
   * next-in-flow. This function MUST be called before stealing or
   * deleting aChild's next-in-flow.
   */</comment>
  <function_decl><type><name>void</name></type> <name>Finish</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aChild</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * This function should be called for each child that isn't reflowed.
   * It increments our walker and sets the NS_FRAME_OVERFLOW_INCOMPLETE
   * reflow flag if it encounters an overflow continuation so that our
   * next-in-flow doesn't get prematurely deleted. It MUST be called on
   * each unreflowed child that has an overflow container continuation;
   * it MAY be called on other children, but it isn't necessary (doesn't
   * do anything).
   */</comment>
  <function><type><name>void</name></type> <name>Skip</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>nsReflowStatus</name>&amp;</type> <name>aReflowStatus</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>, <argument><expr>"null ptr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aChild</name> == <name>mSentry</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>StepForward</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aReflowStatus</name> = <call><name>NS_FRAME_MERGE_INCOMPLETE</name><argument_list>(<argument><expr><name>aReflowStatus</name></expr></argument>,
                                                <argument><expr><name>NS_FRAME_OVERFLOW_INCOMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></function>

<label><name>private</name>:</label>

  <function_decl><type><name>void</name></type> <name>SetUpListWalker</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>StepForward</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block">/* We hold a pointer to either the next-in-flow's overflow containers list
     or, if that doesn't exist, our frame's excess overflow containers list.
     We need to make sure that we drop that pointer if the list becomes
     empty and is deleted elsewhere. */</comment>
  <decl_stmt><decl><type><name>nsFrameList</name>*</type> <name>mOverflowContList</name></decl>;</decl_stmt>
  <comment type="block">/* We hold a pointer to the most recently-reflowed child that has an
     overflow container next-in-flow. We do this because it's a known
     good point; this pointer won't be deleted on us. We can use it to
     recover our place in the list. */</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>mPrevOverflowCont</name></decl>;</decl_stmt>
  <comment type="block">/* This is a pointer to the next overflow container's prev-in-flow, which
     is (or should be) a child of our frame. When we hit this, we will need
     to increment this walker to the next overflow container. */</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>mSentry</name></decl>;</decl_stmt>
  <comment type="block">/* Parent of all frames in mOverflowContList. If our mOverflowContList
     is an excessOverflowContainersProperty, then this our frame (the frame
     that was passed in to our constructor). Otherwise this is that frame's
     next-in-flow, and our mOverflowContList is mParent's
     overflowContainersProperty */</comment>
  <decl_stmt><decl><type><name>nsContainerFrame</name>*</type> <name>mParent</name></decl>;</decl_stmt>
  <comment type="block">/* Tells SetUpListWalker whether or not to walk us past any continuations
     of overflow containers. */</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>mSkipOverflowContainerChildren</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* nsContainerFrame_h___ */</comment>
</unit>
