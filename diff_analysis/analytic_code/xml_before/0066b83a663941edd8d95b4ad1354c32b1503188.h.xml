<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0066b83a663941edd8d95b4ad1354c32b1503188.h"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   John Bandhauer &lt;jband@netscape.com&gt; (original author)
 *   Mike Shaver &lt;shaver@mozilla.org&gt;
 *   Mark Hammond &lt;MarkH@ActiveState.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/* All the XPConnect private declarations - only include locally. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>xpcprivate_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xpcprivate_h___</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdbgapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nscore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPCOM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCycleCollectionParticipant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCycleCollector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupports.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClassInfoImpl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIComponentManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIComponentRegistrar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupportsPrimitives.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIGenericFactory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMemory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXPConnect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIInterfaceInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIInterfaceInfoManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXPCScriptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXPCSecurityManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIJSRuntimeService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWeakReference.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIModule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoLock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPTCUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xptinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpcforwards.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpclog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpccomponents.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpcexception.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpcjsid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlong.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prenv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPIDLString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoJSValHolder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/AutoRestore.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIJSContextStack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDeque.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIConsoleService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScriptError.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIExceptionService.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsVariant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPropertyBag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIProperty.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBaseHashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHashKeys.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWrapperCache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXPCScriptNotify.h"</cpp:file></cpp:include>  <comment type="line">// used to notify: ScriptEvaluated</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScriptObjectPrincipal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrincipal.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISecurityCheckedComponent.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIThreadInternal.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>
<comment type="line">// This goop was added because of EXCEPINFO in ThrowCOMError</comment>
<comment type="line">// This include is here, because it needs to occur before the undefines below</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
<comment type="block">/* atlbase.h on WINCE has a bug, in that it tries to use
 * GetProcAddress with a wide string, when that is explicitly not
 * supported.  So we use C++ to overload that here, and implement
 * something that works.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<function_decl><type><specifier>static</specifier> <name>FARPROC</name></type> <name>GetProcAddressA</name><parameter_list>(<param><decl><type><name>HMODULE</name></type> <name>hMod</name></decl></param>, <param><decl><type><name>wchar_t</name> *</type><name>procName</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WINCE */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;atlbase.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oaidl.h"</cpp:file></cpp:include>
<comment type="line">// Nasty MS defines</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GetClassInfo</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GetClassName</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Compile time switches for instrumentation and stuff....</comment>

<comment type="line">// Note that one would not normally turn *any* of these on in a non-DEBUG build.</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_jband</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_jst</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_dbradley</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_shaver_no</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_timeless</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_xpc_hacker</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_brendan</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_XPCNativeWrapper</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_DETECT_LEADING_UPPERCASE_ACCESS_ERRORS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_CHECK_WRAPPER_THREADSAFETY</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_xpc_hacker</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_DUMP_AT_SHUTDOWN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_TRACK_WRAPPER_STATS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_TRACK_SCOPE_STATS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_TRACK_PROTO_STATS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_TRACK_DEFERRED_RELEASES</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_CHECK_WRAPPERS_AT_SHUTDOWN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_CHECK_CLASSINFO_CLAIMS</name></cpp:macro></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_jst</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_ASSERT_CLASSINFO_CLAIMS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="line">//#define DEBUG_stats_jband 1</comment>
<comment type="line">//#define XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING</comment>
<comment type="line">//#define XPC_REPORT_JSCLASS_FLUSHING</comment>
<comment type="line">//#define XPC_TRACK_AUTOMARKINGPTR_STATS</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_dbaron</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_bzbarsky</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="line">// only part of DEBUG_xpc_hacker!</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_DUMP_AT_SHUTDOWN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// conditional forward declarations....</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS</name></cpp:ifdef>
<function_decl><type><name>void</name></type> <name>DEBUG_ReportShadowedMembers</name><parameter_list>(<param><decl><type><name>XPCNativeSet</name>*</type> <name>set</name></decl></param>,
                                 <param><decl><type><name>XPCWrappedNative</name>*</type> <name>wrapper</name></decl></param>,
                                 <param><decl><type><name>XPCWrappedNativeProto</name>*</type> <name>proto</name></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_ReportShadowedMembers</name><parameter_list>(<param><type><name>set</name></type></param>, <param><type><name>wrapper</name></type></param>, <param><type><name>proto</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_CHECK_WRAPPER_THREADSAFETY</name></cpp:ifdef>
<function_decl><type><name>void</name></type> <name>DEBUG_ReportWrapperThreadSafetyError</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>msg</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>XPCWrappedNative</name>*</type> <name>wrapper</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DEBUG_CheckWrapperThreadSafety</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XPCWrappedNative</name>*</type> <name>wrapper</name></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_CheckWrapperThreadSafety</name><parameter_list>(<param><type><name>w</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***************************************************************************/</comment>

<comment type="line">// Defeat possible Windows macro-mangling of the name</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GetClassInfo</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GetClassInfo</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// default initial sizes for maps (hashtables)</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_CONTEXT_MAP_SIZE</name></cpp:macro>                <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_JS_MAP_SIZE</name></cpp:macro>                     <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_JS_CLASS_MAP_SIZE</name></cpp:macro>               <cpp:value>64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_MAP_SIZE</name></cpp:macro>                 <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_PROTO_MAP_SIZE</name></cpp:macro>           <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_DYING_NATIVE_PROTO_MAP_SIZE</name></cpp:macro>     <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_DETACHED_NATIVE_PROTO_MAP_SIZE</name></cpp:macro>  <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_INTERFACE_MAP_SIZE</name></cpp:macro>       <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_SET_MAP_SIZE</name></cpp:macro>             <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_JSCLASS_MAP_SIZE</name></cpp:macro>         <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_THIS_TRANSLATOR_MAP_SIZE</name></cpp:macro>         <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_WRAPPER_MAP_SIZE</name></cpp:macro>         <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_WRAPPER_MAP_SIZE</name></cpp:macro>                 <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// data declarations...</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name>*</type> <name><name>XPC_ARG_FORMATTER_FORMAT_STRINGS</name><index>[]</index></name></decl>;</decl_stmt> <comment type="line">// format strings</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_CONTEXT_STACK_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_RUNTIME_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_EXCEPTION_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_CONSOLE_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_SCRIPT_ERROR_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_ID_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>XPC_XPCONNECT_CONTRACTID</name><index>[]</index></name></decl>;</decl_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// useful macros...</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_STRING_GETTER_BODY</name><parameter_list>(<param><type><name>dest</name></type></param>, <param><type><name>src</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>NS_ENSURE_ARG_POINTER(dest); \
    char* result; \
    if(src) \
        result = (char*) nsMemory::Clone(src, \
                                sizeof(char)*(strlen(src)+1)); \
    else \
        result = nsnull; \
    *dest = result; \
    return (result || !src) ? NS_OK : NS_ERROR_OUT_OF_MEMORY</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRAPPER_SLOTS</name></cpp:macro> <cpp:value>(JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_OBJECT</name></cpp:macro> <cpp:value>((JSObject *)1)</cpp:value></cpp:define>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Auto locking support class...</comment>

<comment type="line">// We PROMISE to never screw this up.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(disable : 4355)</cpp:pragma> <comment type="line">// OK to pass "this" in member initializer</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>PRMonitor</name></type> <name>XPCLock</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>xpc_Wait</name><parameter_list>(<param><decl><type><name>XPCLock</name>*</type> <name>lock</name></decl></param>)</parameter_list> 
    <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr>"xpc_Wait called with null lock!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>PRStatus</name></type> <name>result</name> <init>= 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><call><name>PR_Wait</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_SUCCESS</name> == <name>result</name></expr></argument>, <argument><expr>"bad result from PR_Wait!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>xpc_NotifyAll</name><parameter_list>(<param><decl><type><name>XPCLock</name>*</type> <name>lock</name></decl></param>)</parameter_list> 
    <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr>"xpc_NotifyAll called with null lock!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>PRStatus</name></type> <name>result</name> <init>= 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
        <expr><call><name>PR_NotifyAll</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_SUCCESS</name> == <name>result</name></expr></argument>, <argument><expr>"bad result from PR_NotifyAll!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

<comment type="line">// This is a cloned subset of nsAutoMonitor. We want the use of a monitor -</comment>
<comment type="line">// mostly because we need reenterability - but we also want to support passing</comment>
<comment type="line">// a null monitor in without things blowing up. This is used for wrappers that</comment>
<comment type="line">// are guaranteed to be used only on one thread. We avoid lock overhead by</comment>
<comment type="line">// using a null monitor. By changing this class we can avoid having multiplte</comment>
<comment type="line">// code paths or (conditional) manual calls to PR_{Enter,Exit}Monitor.</comment>
<comment type="line">//</comment>
<comment type="line">// Note that xpconnect only makes *one* monitor and *mostly* holds it locked</comment>
<comment type="line">// only through very small critical sections.</comment>

<expr_stmt><expr><name>class</name> <name>NS_STACK_CLASS</name> <name>XPCAutoLock</name> : <name>public</name> <name>nsAutoLockBase</name> <block>{
<expr><name>public</name>:

    static <name>XPCLock</name>* <macro><name>NewLock</name><argument_list>(<argument>const char* name</argument>)</argument_list></macro>
                        <block>{<return>return <expr><name>nsAutoMonitor</name>::<call><name>NewMonitor</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>}</block>
    static <name>void</name>     <macro><name>DestroyLock</name><argument_list>(<argument>XPCLock* lock</argument>)</argument_list></macro>
                        <block>{<expr><name>nsAutoMonitor</name>::<call><name>DestroyMonitor</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;}</block>

    <macro><name>XPCAutoLock</name><argument_list>(<argument>XPCLock* lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_jband</name></cpp:ifdef>
        : <call><name>nsAutoLockBase</name><argument_list>(<argument><expr><name>lock</name> ? (<name>void</name>*) <name>lock</name> : (<name>void</name>*) <name>this</name></expr></argument>, <argument><expr><name>eAutoMonitor</name></expr></argument>)</argument_list></call></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        : <expr><call><name>nsAutoLockBase</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>eAutoMonitor</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <macro><name>mLock</name><argument_list>(<argument>lock</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <if>if<condition>(<expr><name>mLock</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>PR_EnterMonitor</name><argument_list>(<argument><expr><name>mLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></expr></expr_stmt>

    <expr_stmt><expr>~<macro><name>XPCAutoLock</name><argument_list>()</argument_list></macro>
    <block>{
        <if>if<condition>(<expr><name>mLock</name></expr>)</condition><then>
        <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>PRStatus</name></type> <name>status</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr><call><name>PR_ExitMonitor</name><argument_list>(<argument><expr><name>mLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>status</name> == <name>PR_SUCCESS</name></expr></argument>, <argument><expr>"PR_ExitMonitor failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
    }

private:
    <decl_stmt><decl><type><name>XPCLock</name>*</type>  <name>mLock</name></decl>;</decl_stmt>
    <function><type><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></type>

    <comment type="line">// Not meant to be implemented. This makes it a compiler error to</comment>
    <comment type="line">// construct or assign an XPCAutoLock object incorrectly.</comment>
    <name>XPCAutoLock</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{}</block></function>
    <macro><name>XPCAutoLock</name><argument_list>(<argument>XPCAutoLock&amp;</argument> <comment type="block">/*aMon*/</comment>)</argument_list></macro> <block>{}</block>
    <decl_stmt><decl><type><name>XPCAutoLock</name>&amp;</type> <name>operator</name> <init>=<expr>(<name>XPCAutoLock</name>&amp; <comment type="block">/*aMon*/</comment>) <block>{
        <return>return <expr>*<name>this</name></expr>;</return>
    }</block></expr></init></decl></decl_stmt>

    <comment type="line">// Not meant to be implemented. This makes it a compiler error to</comment>
    <comment type="line">// attempt to create an XPCAutoLock object on the heap.</comment>
    <function><type><specifier>static</specifier> <name>void</name>* <name>operator</name></type> <name>new</name><parameter_list>(<param><decl><type><name>size_t</name></type></decl></param> <comment type="block">/*size*/</comment>)</parameter_list> CPP_THROW_NEW <block>{
        <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></function>
    <function><type><specifier>static</specifier> <name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<param><decl><type><name>void</name>*</type></decl></param> <comment type="block">/*memory*/</comment>)</parameter_list> <block>{}</block></function>
};

<comment type="block">/************************************************/</comment>

<expr_stmt><expr><name>class</name> <name>NS_STACK_CLASS</name> <name>XPCAutoUnlock</name> : <name>public</name> <name>nsAutoUnlockBase</name> <block>{
<expr><name>public</name>:
    <macro><name>XPCAutoUnlock</name><argument_list>(<argument>XPCLock* lock MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <call><name>nsAutoUnlockBase</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>,
          <macro><name>mLock</name><argument_list>(<argument>lock</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <if>if<condition>(<expr><name>mLock</name></expr>)</condition><then>
        <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>PRStatus</name></type> <name>status</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr><call><name>PR_ExitMonitor</name><argument_list>(<argument><expr><name>mLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>status</name> == <name>PR_SUCCESS</name></expr></argument>, <argument><expr>"PR_ExitMonitor failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/></block></then></if>}</block></expr>
    }</block>

    ~<macro><name>XPCAutoUnlock</name><argument_list>()</argument_list></macro>
    <block>{
        <if>if<condition>(<expr><name>mLock</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>PR_EnterMonitor</name><argument_list>(<argument><expr><name>mLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></expr></expr_stmt>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCLock</name>*</type>  <name>mLock</name></decl>;</decl_stmt>
    <function><type><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></type>

    <comment type="line">// Not meant to be implemented. This makes it a compiler error to</comment>
    <comment type="line">// construct or assign an XPCAutoUnlock object incorrectly.</comment>
    <name>XPCAutoUnlock</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{}</block></function>
    <macro><name>XPCAutoUnlock</name><argument_list>(<argument>XPCAutoUnlock&amp;</argument> <comment type="block">/*aMon*/</comment>)</argument_list></macro> <block>{}</block>
    <decl_stmt><decl><type><name>XPCAutoUnlock</name>&amp;</type> <name>operator</name> <init>=<expr>(<name>XPCAutoUnlock</name>&amp; <comment type="block">/*aMon*/</comment>) <block>{
        <return>return <expr>*<name>this</name></expr>;</return>
    }</block></expr></init></decl></decl_stmt>

    <comment type="line">// Not meant to be implemented. This makes it a compiler error to</comment>
    <comment type="line">// attempt to create an XPCAutoUnlock object on the heap.</comment>
    <function><type><specifier>static</specifier> <name>void</name>* <name>operator</name></type> <name>new</name><parameter_list>(<param><decl><type><name>size_t</name></type></decl></param> <comment type="block">/*size*/</comment>)</parameter_list> CPP_THROW_NEW <block>{
        <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></function>
    <function><type><specifier>static</specifier> <name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<param><decl><type><name>void</name>*</type></decl></param> <comment type="block">/*memory*/</comment>)</parameter_list> <block>{}</block></function>
};

<comment type="block">/***************************************************************************
****************************************************************************
*
* Core runtime and context classes...
*
****************************************************************************
***************************************************************************/</comment>

<comment type="line">// We have a general rule internally that getters that return addref'd interface</comment>
<comment type="line">// pointer generally do so using an 'out' parm. When interface pointers are</comment>
<comment type="line">// returned as function call result values they are not addref'd. Exceptions</comment>
<comment type="line">// to this rule are noted explicitly.</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>PRBool</name></type> <name>OBJ_IS_GLOBAL</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRBool</name></type> <name>OBJ_IS_NOT_GLOBAL</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_JS_RUNTIME_SERVICE_CID</name></cpp:macro> \
<cpp:value>{0xb5e65b52, 0x1dd1, 0x11b2, \
    { 0xae, 0x8f, 0xf0, 0x92, 0x8e, 0xd8, 0x84, 0x82 }}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_XPC_THREAD_JSCONTEXT_STACK_CID</name></cpp:macro>  \
<cpp:value>{ 0xff8c4d10, 0x3194, 0x11d3, \
    { 0x98, 0x85, 0x0, 0x60, 0x8, 0x96, 0x24, 0x22 } }</cpp:value></cpp:define>

<expr_stmt><expr><name>class</name> <name>nsXPConnect</name> : <name>public</name> <name>nsIXPConnect</name></expr>,
                    <expr><name>public</name> <name>nsIThreadObserver</name></expr>,
                    <expr><name>public</name> <name>nsSupportsWeakReference</name></expr>,
                    <expr><name>public</name> <name>nsCycleCollectionJSRuntime</name></expr>,
                    <expr><name>public</name> <name>nsCycleCollectionParticipant</name></expr>,
                    <expr><name>public</name> <name>nsIJSRuntimeService</name></expr>,
                    <expr><name>public</name> <name>nsIThreadJSContextStack</name>
<block>{
<expr><name>public</name>:
    <comment type="line">// all the interface method declarations...</comment>
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIXPCONNECT</name>
    <name>NS_DECL_NSITHREADOBSERVER</name>
    <name>NS_DECL_NSIJSRUNTIMESERVICE</name>
    <name>NS_DECL_NSIJSCONTEXTSTACK</name>
    <name>NS_DECL_NSITHREADJSCONTEXTSTACK</name>

    <comment type="line">// non-interface implementation</comment>
<name>public</name>:
    <comment type="line">// These get non-addref'd pointers</comment>
    static <name>nsXPConnect</name>*  <call><name>GetXPConnect</name><argument_list>()</argument_list></call></expr>;
    <expr>static <name>XPCJSRuntime</name>* <call><name>GetRuntimeInstance</name><argument_list>()</argument_list></call></expr>;
    <expr><name>XPCJSRuntime</name>* <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> <block>{<return>return <expr><name>mRuntime</name></expr>;</return></block></expr>}</block>

    <comment type="line">// Gets addref'd pointer</comment>
    static <name>nsresult</name> <call><name>GetInterfaceInfoManager</name><argument_list>(<argument><expr><name>nsIInterfaceInfoSuperManager</name>** <name>iim</name></expr></argument>,
                                            <argument><expr><name>nsXPConnect</name>* <name>xpc</name> = <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>IsISupportsDescendant</name><parameter_list>(<param><decl><type><name>nsIInterfaceInfo</name>*</type> <name>info</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>nsIXPCSecurityManager</name>* <macro><name>GetDefaultSecurityManager</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mDefaultSecurityManager</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>PRUint16</name> <macro><name>GetDefaultSecurityManagerFlags</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mDefaultSecurityManagerFlags</name></expr>;</return>}</block></expr></expr_stmt>

    <comment type="line">// This returns an AddRef'd pointer. It does not do this with an 'out' param</comment>
    <comment type="line">// only because this form is required by the generic module macro:</comment>
    <comment type="line">// NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR</comment>
    <function_decl><type><specifier>static</specifier> <name>nsXPConnect</name>*</type> <name>GetSingleton</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// Called by module code in dll startup</comment>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>InitStatics</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>gSelf</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>gOnceAliveNowDead</name> = <name>JS_FALSE</name></expr>;</expr_stmt> }</block></function>
    <comment type="line">// Called by module code on dll shutdown.</comment>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseXPConnectSingleton</name><parameter_list>()</parameter_list>;</function_decl>

    <expr_stmt><expr><name>virtual</name> ~<call><name>nsXPConnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsShuttingDown</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mShuttingDown</name></expr>;</return>}</block></expr></expr_stmt>

    <function_decl><type><name>nsresult</name></type> <name>GetInfoForIID</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIID</name> *</type> <name>aIID</name></decl></param>, <param><decl><type><name>nsIInterfaceInfo</name>**</type> <name>info</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>nsresult</name></type> <name>GetInfoForName</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>name</name></decl></param>, <param><decl><type><name>nsIInterfaceInfo</name>**</type> <name>info</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// nsCycleCollectionParticipant</comment>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>RootAndUnlinkJSObjects</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>Unlink</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>Unroot</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>Traverse</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>,
                        <param><decl><type><name>nsCycleCollectionTraversalCallback</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>;</function_decl>
    
    <comment type="line">// nsCycleCollectionLanguageRuntime</comment>
    <function_decl><type><name>virtual</name> <name>nsresult</name></type> <name>BeginCycleCollection</name><parameter_list>(<param><decl><type><name>nsCycleCollectionTraversalCallback</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>virtual</name> <name>nsresult</name></type> <name>FinishCycleCollection</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>virtual</name> <name>nsCycleCollectionParticipant</name> *</type><name>ToParticipant</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>virtual</name> <name>void</name></type> <name>CommenceShutdown</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>Collect</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <function_decl><type><name>virtual</name> <name>void</name></type> <name>PrintAllReferencesTo</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// We should not trace XPConnect JS roots when tracing the graph for the</comment>
    <comment type="line">// cycle collector. Those should be traced from the XPCOM objects that hold</comment>
    <comment type="line">// them when we know that they won't be collected by the cycle collector.</comment>
    <function><type><name>PRBool</name></type> <name>ShouldTraceRoots</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>!<name>mCycleCollecting</name></expr>;</return>
    }</block></function>

    <function><type><name>XPCCallContext</name>*</type> <name>GetCycleCollectionContext</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mCycleCollectionContext</name></expr>;</return>
    }</block></function>

    <function_decl><type><name>PRInt32</name></type> <name>GetRequestDepth</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// This returns the singleton nsCycleCollectionParticipant for JSContexts.</comment>
    <function_decl><type><specifier>static</specifier> <name>nsCycleCollectionParticipant</name> *</type><name>JSContextParticipant</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>virtual</name> <name>nsIPrincipal</name>*</type> <name>GetPrincipal</name><argument_list>(<argument><expr><name>JSObject</name>* <name>obj</name></expr></argument>,
                                       <argument><expr><name>PRBool</name> <name>allowShortCircuit</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <function_decl><type><name>void</name></type> <name>RecordTraversal</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <function><type><specifier>static</specifier> <name>PRBool</name></type> <name>ReportAllJSExceptions</name><parameter_list>()</parameter_list>
    <block>{
      <return>return <expr><name>gReportAllJSExceptions</name> &gt; 0</expr>;</return>
    }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsIDispatchEnabled</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>protected</name>:</label>
    <expr_stmt><expr><call><name>nsXPConnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>PRThread</name>*</type> <name>FindMainThread</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <comment type="line">// Singleton instance</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>nsXPConnect</name>*</type>      <name>gSelf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>JSBool</name></type>            <name>gOnceAliveNowDead</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XPCJSRuntime</name>*</type>            <name>mRuntime</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIInterfaceInfoSuperManager</name>&gt; <name>mInterfaceInfoManager</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIXPCSecurityManager</name>*</type>   <name>mDefaultSecurityManager</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type>                 <name>mDefaultSecurityManagerFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>                   <name>mShuttingDown</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCCallContext</name>*</type>          <name>mCycleCollectionContext</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <expr_stmt><expr><name>nsAutoPtr</name>&lt;<name>XPCCallContext</name>&gt; <name>mExplainCycleCollectionContext</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PLDHashTable</name></type>             <name>mJSRoots</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>PRBool</name></type>                   <name>mCycleCollecting</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
    <typedef>typedef <expr_stmt><expr><name>nsBaseHashtable</name>&lt;<name>nsVoidPtrHashKey</name></expr>, <expr><name>nsISupports</name>*</expr>, <expr><name>nsISupports</name>*&gt; <name>ScopeSet</name></expr>;</expr_stmt></typedef>
    <decl_stmt><decl><type><name>ScopeSet</name></type> <name>mScopes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIXPCScriptable</name>&gt; <name>mBackstagePass</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>PRUint32</name></type> <name>gReportAllJSExceptions</name></decl>;</decl_stmt>
};

<comment type="block">/***************************************************************************/</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCRootSetElem</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>XPCRootSetElem</name><argument_list>()</argument_list></macro>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name>mNext</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mSelfp</name> = <name>nsnull</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>

    <expr_stmt><expr>~<macro><name>XPCRootSetElem</name><argument_list>()</argument_list></macro>
    <block>{
        <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mNext</name></expr></argument>, <argument><expr>"Must be unlinked"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mSelfp</name></expr></argument>, <argument><expr>"Must be unlinked"</expr></argument>)</argument_list></call></expr>;
    }</block>

    inline <name>XPCRootSetElem</name>* <macro><name>GetNextRoot</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>mNext</name></expr>;</return> }</block></expr></expr_stmt>
    <function_decl><type><name>void</name></type> <name>AddToRootSet</name><parameter_list>(<param><decl><type><name>JSRuntime</name>*</type> <name>rt</name></decl></param>, <param><decl><type><name>XPCRootSetElem</name>**</type> <name>listHead</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>RemoveFromRootSet</name><parameter_list>(<param><decl><type><name>JSRuntime</name>*</type> <name>rt</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCRootSetElem</name> *</type><name>mNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCRootSetElem</name> **</type><name>mSelfp</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>

<comment type="line">// In the current xpconnect system there can only be one XPCJSRuntime.</comment>
<comment type="line">// So, xpconnect can only be used on one JSRuntime within the process.</comment>

<comment type="line">// no virtuals. no refcounting.</comment>
<decl_stmt><decl><type><name>class</name></type> <name>XPCJSRuntime</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCJSRuntime</name>*</type> <name>newXPCJSRuntime</name><parameter_list>(<param><decl><type><name>nsXPConnect</name>*</type> <name>aXPConnect</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>JSRuntime</name>*     <macro><name>GetJSRuntime</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSRuntime</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsXPConnect</name>*   <macro><name>GetXPConnect</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mXPConnect</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSObject2WrappedJSMap</name>*     <macro><name>GetWrappedJSMap</name><argument_list>()</argument_list></macro>        const
        <block>{<return>return <expr><name>mWrappedJSMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>IID2WrappedJSClassMap</name>*     <macro><name>GetWrappedJSClassMap</name><argument_list>()</argument_list></macro>   const
        <block>{<return>return <expr><name>mWrappedJSClassMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>IID2NativeInterfaceMap</name>* <macro><name>GetIID2NativeInterfaceMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mIID2NativeInterfaceMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>ClassInfo2NativeSetMap</name>* <macro><name>GetClassInfo2NativeSetMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mClassInfo2NativeSetMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>NativeSetMap</name>* <macro><name>GetNativeSetMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mNativeSetMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>IID2ThisTranslatorMap</name>* <macro><name>GetThisTranslatorMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mThisTranslatorMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCNativeScriptableSharedMap</name>* <macro><name>GetNativeScriptableSharedMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mNativeScriptableSharedMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCWrappedNativeProtoMap</name>* <macro><name>GetDyingWrappedNativeProtoMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mDyingWrappedNativeProtoMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCWrappedNativeProtoMap</name>* <macro><name>GetDetachedWrappedNativeProtoMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mDetachedWrappedNativeProtoMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCNativeWrapperMap</name>* <macro><name>GetExplicitNativeWrapperMap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mExplicitNativeWrapperMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCLock</name>* <macro><name>GetMapLock</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mMapLock</name></expr>;</return>}</block></expr></expr_stmt>

    <function_decl><type><name>JSBool</name></type> <name>OnJSContextNew</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>JSBool</name></type> <name>DeferredRelease</name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>obj</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>JSBool</name> <macro><name>GetDoingFinalization</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mDoingFinalization</name></expr>;</return>}</block></expr></expr_stmt>

    <comment type="line">// Mapping of often used strings to jsid atoms that live 'forever'.</comment>
    <comment type="line">//</comment>
    <comment type="line">// To add a new string: add to this list and to XPCJSRuntime::mStrings</comment>
    <comment type="line">// at the top of xpcjsruntime.cpp</comment>
    <enum>enum <block>{
        <decl><name>IDX_CONSTRUCTOR</name>             <init>= <expr>0</expr></init></decl> ,
        <decl><name>IDX_TO_STRING</name></decl>               ,
        <decl><name>IDX_TO_SOURCE</name></decl>               ,
        <decl><name>IDX_LAST_RESULT</name></decl>             ,
        <decl><name>IDX_RETURN_CODE</name></decl>             ,
        <decl><name>IDX_VALUE</name></decl>                   ,
        <decl><name>IDX_QUERY_INTERFACE</name></decl>         ,
        <decl><name>IDX_COMPONENTS</name></decl>              ,
        <decl><name>IDX_WRAPPED_JSOBJECT</name></decl>        ,
        <decl><name>IDX_OBJECT</name></decl>                  ,
        <decl><name>IDX_FUNCTION</name></decl>                ,
        <decl><name>IDX_PROTOTYPE</name></decl>               ,
        <decl><name>IDX_CREATE_INSTANCE</name></decl>         ,
        <decl><name>IDX_ITEM</name></decl>                    ,
        <decl><name>IDX_PROTO</name></decl>                   ,
        <decl><name>IDX_ITERATOR</name></decl>                ,
        <decl><name>IDX_EXPOSEDPROPS</name></decl>            ,
        <decl><name>IDX_TOTAL_COUNT</name></decl> <comment type="line">// just a count of the above</comment>
    }</block>;</enum>

    <decl_stmt><decl><type><name>jsid</name></type> <name>GetStringID</name><argument_list>(<argument><expr><name>uintN</name> <name>index</name></expr></argument>)</argument_list> const
    <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>index</name> &lt; <name>IDX_TOTAL_COUNT</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>mStrIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
    }</block></decl></decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>GetStringJSVal</name><argument_list>(<argument><expr><name>uintN</name> <name>index</name></expr></argument>)</argument_list> const
    <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>index</name> &lt; <name>IDX_TOTAL_COUNT</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>mStrJSVals</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
    }</block></decl></decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>GetStringName</name><argument_list>(<argument><expr><name>uintN</name> <name>index</name></expr></argument>)</argument_list> const
    <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>index</name> &lt; <name>IDX_TOTAL_COUNT</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>mStrings</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
    }</block></decl></decl_stmt>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>data</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>TraceXPConnectRoots</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>rootGlobals</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>AddXPConnectRoots</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                           <param><decl><type><name>nsCycleCollectionTraversalCallback</name>&amp;</type> <name>cb</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>GCCallback</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSGCStatus</name></type> <name>status</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>AddVariantRoot</name><parameter_list>(<param><decl><type><name>XPCTraceableVariant</name>*</type> <name>variant</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>AddWrappedJSRoot</name><parameter_list>(<param><decl><type><name>nsXPCWrappedJS</name>*</type> <name>wrappedJS</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>AddObjectHolderRoot</name><parameter_list>(<param><decl><type><name>XPCJSObjectHolder</name>*</type> <name>holder</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>nsresult</name></type> <name>AddJSHolder</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>aHolder</name></decl></param>, <param><decl><type><name>nsScriptObjectTracer</name>*</type> <name>aTracer</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>nsresult</name></type> <name>RemoveJSHolder</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>aHolder</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>UnrootContextGlobals</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CC</name></cpp:ifdef>
    <function_decl><type><name>void</name></type> <name>RootContextGlobals</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><name>void</name></type> <name>DebugDump</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>SystemIsBeingShutDown</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>PRThread</name>* <macro><name>GetThreadRunningGC</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mThreadRunningGC</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr>~<call><name>XPCJSRuntime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_CHECK_WRAPPERS_AT_SHUTDOWN</name></cpp:ifdef>
   <function><type><name>void</name></type> <name>DEBUG_AddWrappedNative</name><parameter_list>(<param><decl><type><name>nsIXPConnectWrappedNative</name>*</type> <name>wrapper</name></decl></param>)</parameter_list>
        <block>{<decl_stmt><decl><type><name>XPCAutoLock</name></type> <name>lock</name><argument_list>(<argument><expr><call><name>GetMapLock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>JSDHashEntryHdr</name> *</type><name>entry</name> <init>=
            <expr><call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name>DEBUG_WrappedNativeHashtable</name></expr></argument>,
                                 <argument><expr><name>wrapper</name></expr></argument>, <argument><expr><name>JS_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
         <if>if<condition>(<expr><name>entry</name></expr>)</condition><then> <expr_stmt><expr>((<name>JSDHashEntryStub</name> *)<name>entry</name>)-&gt;<name>key</name> = <name>wrapper</name></expr>;</expr_stmt></then></if>}</block></function>

   <function><type><name>void</name></type> <name>DEBUG_RemoveWrappedNative</name><parameter_list>(<param><decl><type><name>nsIXPConnectWrappedNative</name>*</type> <name>wrapper</name></decl></param>)</parameter_list>
        <block>{<decl_stmt><decl><type><name>XPCAutoLock</name></type> <name>lock</name><argument_list>(<argument><expr><call><name>GetMapLock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
         <expr_stmt><expr><call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name>DEBUG_WrappedNativeHashtable</name></expr></argument>,
                              <argument><expr><name>wrapper</name></expr></argument>, <argument><expr><name>JS_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></function>
<label><name>private</name>:</label>
   <decl_stmt><decl><type><name>JSDHashTable</name>*</type> <name>DEBUG_WrappedNativeHashtable</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><name>void</name></type> <name>AddGCCallback</name><parameter_list>(<param><decl><type><name>JSGCCallback</name></type> <name>cb</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>RemoveGCCallback</name><parameter_list>(<param><decl><type><name>JSGCCallback</name></type> <name>cb</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCJSRuntime</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// no implementation</comment>
    <expr_stmt><expr><call><name>XPCJSRuntime</name><argument_list>(<argument><expr><name>nsXPConnect</name>* <name>aXPConnect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The caller must be holding the GC lock</comment>
    <function_decl><type><name>void</name></type> <name>RescheduleWatchdog</name><parameter_list>(<param><decl><type><name>XPCContext</name>*</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WatchdogMain</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type> <name><name>mStrings</name><index>[<expr><name>IDX_TOTAL_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type> <name><name>mStrIDs</name><index>[<expr><name>IDX_TOTAL_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name><name>mStrJSVals</name><index>[<expr><name>IDX_TOTAL_COUNT</name></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsXPConnect</name>*</type> <name>mXPConnect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRuntime</name>*</type>  <name>mJSRuntime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject2WrappedJSMap</name>*</type>   <name>mWrappedJSMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IID2WrappedJSClassMap</name>*</type>   <name>mWrappedJSClassMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IID2NativeInterfaceMap</name>*</type>  <name>mIID2NativeInterfaceMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClassInfo2NativeSetMap</name>*</type>  <name>mClassInfo2NativeSetMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NativeSetMap</name>*</type>            <name>mNativeSetMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IID2ThisTranslatorMap</name>*</type>   <name>mThisTranslatorMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeScriptableSharedMap</name>*</type> <name>mNativeScriptableSharedMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeProtoMap</name>*</type> <name>mDyingWrappedNativeProtoMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeProtoMap</name>*</type> <name>mDetachedWrappedNativeProtoMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeWrapperMap</name>*</type>     <name>mExplicitNativeWrapperMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCLock</name>*</type> <name>mMapLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRThread</name>*</type> <name>mThreadRunningGC</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nsTArray</name>&lt;<name>nsXPCWrappedJS</name>*&gt; <name>mWrappedJSToReleaseArray</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nsTArray</name>&lt;<name>nsISupports</name>*&gt; <name>mNativesToReleaseArray</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>mDoingFinalization</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCRootSetElem</name> *</type><name>mVariantRoots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCRootSetElem</name> *</type><name>mWrappedJSRoots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCRootSetElem</name> *</type><name>mObjectHolderRoots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type> <name>mJSHolders</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>mUnrootedGlobalCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRCondVar</name> *</type><name>mWatchdogWakeup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRThread</name> *</type><name>mWatchdogThread</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nsTArray</name>&lt;<name>JSGCCallback</name>&gt; <name>extraGCCallbacks</name></expr>;</expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCContext is mostly a dumb class to hold JSContext specific data and</comment>
<comment type="line">// maps that let us find wrappers created for the given JSContext.</comment>

<comment type="line">// no virtuals</comment>
<decl_stmt><decl><type><name>class</name></type> <name>XPCContext</name>
<block>{
    <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>XPCJSRuntime</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
    <function><type><specifier>static</specifier> <name>XPCContext</name>*</type> <name>GetXPCContext</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>aJSContext</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aJSContext</name>-&gt;<name>data2</name></name></expr></argument>, <argument><expr>"should already have XPCContext"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>static_cast</name>&lt;<name>XPCContext</name> *&gt;(<name><name>aJSContext</name>-&gt;<name>data2</name></name>)</expr>;</return>
        }</block></function>

    <expr_stmt><expr><name>XPCJSRuntime</name>* <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mRuntime</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>JSContext</name>* <macro><name>GetJSContext</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSContext</name></expr>;</return>}</block></expr></expr_stmt>

    <enum>enum <name>LangType</name> <block>{<decl><name>LANG_UNKNOWN</name></decl>, <decl><name>LANG_JS</name></decl>, <decl><name>LANG_NATIVE</name></decl>}</block>;</enum>
    
    <expr_stmt><expr><name>LangType</name> <macro><name>GetCallingLangType</name><argument_list>()</argument_list></macro> const
        <block>{
            <return>return <expr><name>mCallingLangType</name></expr>;</return>
        }</block></expr></expr_stmt>
    <function><type><name>LangType</name></type> <name>SetCallingLangType</name><parameter_list>(<param><decl><type><name>LangType</name></type> <name>lt</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>LangType</name></type> <name>tmp</name> <init>= <expr><name>mCallingLangType</name></expr></init></decl>;</decl_stmt> 
            <expr_stmt><expr><name>mCallingLangType</name> = <name>lt</name></expr>;</expr_stmt> 
            <return>return <expr><name>tmp</name></expr>;</return>
        }</block></function>
    <expr_stmt><expr><name>JSBool</name> <macro><name>CallerTypeIsJavaScript</name><argument_list>()</argument_list></macro> const 
        <block>{
            <return>return <expr><name>LANG_JS</name> == <name>mCallingLangType</name></expr>;</return>
        }</block></expr></expr_stmt>
    <expr_stmt><expr><name>JSBool</name> <macro><name>CallerTypeIsNative</name><argument_list>()</argument_list></macro> const 
        <block>{
            <return>return <expr><name>LANG_NATIVE</name> == <name>mCallingLangType</name></expr>;</return>
        }</block></expr></expr_stmt>
    <expr_stmt><expr><name>JSBool</name> <macro><name>CallerTypeIsKnown</name><argument_list>()</argument_list></macro> const 
        <block>{
            <return>return <expr><name>LANG_UNKNOWN</name> != <name>mCallingLangType</name></expr>;</return>
        }</block></expr></expr_stmt>

    <function><type><name>nsresult</name></type> <name>GetException</name><parameter_list>(<param><decl><type><name>nsIException</name>**</type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>mException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>e</name> = <name>mException</name></expr>;</expr_stmt>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></function>
    <function><type><name>void</name></type> <name>SetException</name><parameter_list>(<param><decl><type><name>nsIException</name>*</type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mException</name> = <name>e</name></expr>;</expr_stmt>
        }</block></function>

    <function><type><name>nsresult</name></type> <name>GetLastResult</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>mLastResult</name></expr>;</return>}</block></function>
    <function><type><name>void</name></type> <name>SetLastResult</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rc</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mLastResult</name> = <name>rc</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>nsresult</name></type> <name>GetPendingResult</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>mPendingResult</name></expr>;</return>}</block></function>
    <function><type><name>void</name></type> <name>SetPendingResult</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rc</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mPendingResult</name> = <name>rc</name></expr>;</expr_stmt>}</block></function>

    <expr_stmt><expr><name>nsIXPCSecurityManager</name>* <macro><name>GetSecurityManager</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mSecurityManager</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>void</name></type> <name>SetSecurityManager</name><parameter_list>(<param><decl><type><name>nsIXPCSecurityManager</name>*</type> <name>aSecurityManager</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><name>mSecurityManager</name> = <name>aSecurityManager</name></expr>;</expr_stmt>}</block></function>

    <expr_stmt><expr><name>PRUint16</name> <macro><name>GetSecurityManagerFlags</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name>mSecurityManagerFlags</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>void</name></type> <name>SetSecurityManagerFlags</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>f</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><name>mSecurityManagerFlags</name> = <name>f</name></expr>;</expr_stmt>}</block></function>

    <decl_stmt><decl><type><name>nsIXPCSecurityManager</name>*</type> <name>GetAppropriateSecurityManager</name><argument_list>(<argument><expr><name>PRUint16</name> <name>flags</name></expr></argument>)</argument_list> const
        <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>CallerTypeIsKnown</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>"missing caller type set somewhere"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>(<expr>!<call><name>CallerTypeIsJavaScript</name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>nsnull</name></expr>;</return></then></if>
            <if>if<condition>(<expr><name>mSecurityManager</name></expr>)</condition><then>
            <block>{
                <if>if<condition>(<expr><name>flags</name> &amp; <name>mSecurityManagerFlags</name></expr>)</condition><then>
                    <return>return <expr><name>mSecurityManager</name></expr>;</return></then></if>
            }</block></then>
            <else>else
            <block>{
                <decl_stmt><decl><type><name>nsIXPCSecurityManager</name>*</type> <name>mgr</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>nsXPConnect</name>*</type> <name>xpc</name> <init>= <expr><call><name><name>mRuntime</name>-&gt;<name>GetXPConnect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>mgr</name> = <call><name><name>xpc</name>-&gt;<name>GetDefaultSecurityManager</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if<condition>(<expr><name>mgr</name> &amp;&amp; (<name>flags</name> &amp; <call><name><name>xpc</name>-&gt;<name>GetDefaultSecurityManagerFlags</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then>
                    <return>return <expr><name>mgr</name></expr>;</return></then></if>
            }</block></else></if>
            <return>return <expr><name>nsnull</name></expr>;</return>
        }</block></decl></decl_stmt>

    <function_decl><type><name>void</name></type> <name>DebugDump</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>
    <function><type><name>void</name></type> <name>AddScope</name><parameter_list>(<param><decl><type><name>PRCList</name> *</type><name>scope</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>PR_INSERT_AFTER</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr>&amp;<name>mScopes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>RemoveScope</name><parameter_list>(<param><decl><type><name>PRCList</name> *</type><name>scope</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>PR_REMOVE_LINK</name><argument_list>(<argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <expr_stmt><expr>~<call><name>XPCContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// no implementation</comment>
    <expr_stmt><expr><call><name>XPCContext</name><argument_list>(<argument><expr><name>XPCJSRuntime</name>* <name>aRuntime</name></expr></argument>, <argument><expr><name>JSContext</name>* <name>aJSContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><specifier>static</specifier> <name>XPCContext</name>*</type> <name>newXPCContext</name><parameter_list>(<param><decl><type><name>XPCJSRuntime</name>*</type> <name>aRuntime</name></decl></param>,
                                     <param><decl><type><name>JSContext</name>*</type> <name>aJSContext</name></decl></param>)</parameter_list>;</function_decl>
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCJSRuntime</name>*</type> <name>mRuntime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name>*</type>  <name>mJSContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>mLastResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>mPendingResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIXPCSecurityManager</name>*</type> <name>mSecurityManager</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIException</name>*</type> <name>mException</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LangType</name></type> <name>mCallingLangType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type> <name>mSecurityManagerFlags</name></decl>;</decl_stmt>

    <comment type="line">// A linked list of scopes to notify when we are destroyed.</comment>
    <decl_stmt><decl><type><name>PRCList</name></type> <name>mScopes</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_CALLER</name></cpp:macro>  <cpp:value>XPCContext::LANG_NATIVE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CALLER</name></cpp:macro>      <cpp:value>XPCContext::LANG_JS</cpp:value></cpp:define>

<comment type="line">// class to export a JSString as an const nsAString, no refcounting :(</comment>
<expr_stmt><expr><name>class</name> <name>XPCReadableJSStringWrapper</name> : <name>public</name> <name>nsDependentString</name>
<block>{
<expr><name>public</name>:</expr>
    <typedef>typedef <expr_stmt><expr><name>nsDependentString</name>::<name>char_traits</name> <name>char_traits</name></expr>;</expr_stmt></typedef>

    <macro><name>XPCReadableJSStringWrapper</name><argument_list>(<argument>const PRUnichar *chars</argument>, <argument>size_t length</argument>)</argument_list></macro> :
        <macro><name>nsDependentString</name><argument_list>(<argument>chars</argument>, <argument>length</argument>)</argument_list></macro>
    <block>{ }</block></block>

    <call><name>XPCReadableJSStringWrapper</name><argument_list>()</argument_list></call> :
        <macro><name>nsDependentString</name><argument_list>(<argument>char_traits::sEmptyBuffer</argument>, <argument>char_traits::sEmptyBuffer</argument>)</argument_list></macro>
    <block>{ <expr><call><name>SetIsVoid</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>; }</block>

    <name>explicit</name> <call><name>XPCReadableJSStringWrapper</name><argument_list>(<argument><expr><name>JSString</name> *<name>str</name></expr></argument>)</argument_list></call> :
        <macro><name>nsDependentString</name><argument_list>(<argument>reinterpret_cast&lt;const PRUnichar *&gt;(::JS_GetStringChars(str))</argument>,
                          <argument>str-&gt;length()</argument>)</argument_list></macro>
    <block>{ }</block></expr></expr_stmt>
};

<comment type="line">// No virtuals</comment>
<comment type="line">// XPCCallContext is ALWAYS declared as a local variable in some function;</comment>
<comment type="line">// i.e. instance lifetime is always controled by some C++ function returning.</comment>
<comment type="line">//</comment>
<comment type="line">// These things are created frequently in many places. We *intentionally* do</comment>
<comment type="line">// not inialialize all members in order to save on construction overhead.</comment>
<comment type="line">// Some constructor pass more valid params than others. We init what must be</comment>
<comment type="line">// init'd and leave other members undefined. In debug builds the accessors</comment>
<comment type="line">// use a CHECK_STATE macro to track whether or not the object is in a valid</comment>
<comment type="line">// state to answer the question a caller might be asking. As long as this</comment>
<comment type="line">// class is maintained correctly it can do its job without a bunch of added</comment>
<comment type="line">// overhead from useless initializations and non-DEBUG error checking.</comment>
<comment type="line">//</comment>
<comment type="line">// Note that most accessors are inlined.</comment>

<expr_stmt><expr><name>class</name> <name>XPCCallContext</name> : <name>public</name> <name>nsAXPCNativeCallContext</name>
<block>{
<expr><name>public</name>:
    <name>NS_IMETHOD</name> <call><name>GetCallee</name><argument_list>(<argument><expr><name>nsISupports</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetCalleeMethodIndex</name><argument_list>(<argument><expr><name>PRUint16</name> *<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetCalleeWrapper</name><argument_list>(<argument><expr><name>nsIXPConnectWrappedNative</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetJSContext</name><argument_list>(<argument><expr><name>JSContext</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetArgc</name><argument_list>(<argument><expr><name>PRUint32</name> *<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetArgvPtr</name><argument_list>(<argument><expr><name>jsval</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetRetValPtr</name><argument_list>(<argument><expr><name>jsval</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetReturnValueWasSet</name><argument_list>(<argument><expr><name>PRBool</name> *<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <macro><name>SetReturnValueWasSet</name><argument_list>(<argument>PRBool aValue</argument>)</argument_list></macro></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetCalleeInterface</name><argument_list>(<argument><expr><name>nsIInterfaceInfo</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetCalleeClassInfo</name><argument_list>(<argument><expr><name>nsIClassInfo</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetPreviousCallContext</name><argument_list>(<argument><expr><name>nsAXPCNativeCallContext</name> **<name>aResult</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>NS_IMETHOD</name> <call><name>GetLanguage</name><argument_list>(<argument><expr><name>PRUint16</name> *<name>aResult</name></expr></argument>)</argument_list></call></expr>;

    enum <expr><block>{<expr><name>NO_ARGS</name> = (<name>uintN</name>) -1</expr>}</block></expr>;

    <macro><name>XPCCallContext</name><argument_list>(<argument>XPCContext::LangType callerLanguage</argument>,
                   <argument>JSContext* cx    = nsnull</argument>,
                   <argument>JSObject* obj    = nsnull</argument>,
                   <argument>JSObject* funobj = nsnull</argument>,
                   <argument>jsid id          = JSID_VOID</argument>,
                   <argument>uintN argc       = NO_ARGS</argument>,
                   <argument>jsval *argv      = nsnull</argument>,
                   <argument>jsval *rval      = nsnull</argument>)</argument_list></macro>;

    <expr><name>virtual</name> ~<call><name>XPCCallContext</name><argument_list>()</argument_list></call></expr>;

    <expr>inline <name>JSBool</name>                       <macro><name>IsValid</name><argument_list>()</argument_list></macro> const</expr> ;

    <expr>inline <name>nsXPConnect</name>*                 <macro><name>GetXPConnect</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCJSRuntime</name>*                <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCPerThreadData</name>*            <macro><name>GetThreadData</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCContext</name>*                  <macro><name>GetXPCContext</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSContext</name>*                   <macro><name>GetJSContext</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSContext</name>*                   <macro><name>GetSafeJSContext</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSBool</name>                       <macro><name>GetContextPopRequired</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCContext</name>::<name>LangType</name>         <macro><name>GetCallerLanguage</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCContext</name>::<name>LangType</name>         <macro><name>GetPrevCallerLanguage</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCCallContext</name>*              <macro><name>GetPrevCallContext</name><argument_list>()</argument_list></macro> const</expr> ;

    <expr>inline <name>JSObject</name>*                    <macro><name>GetOperandJSObject</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSObject</name>*                    <macro><name>GetCurrentJSObject</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSObject</name>*                    <macro><name>GetFlattenedJSObject</name><argument_list>()</argument_list></macro> const</expr> ;

    <expr>inline <name>nsISupports</name>*                 <macro><name>GetIdentityObject</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCWrappedNative</name>*            <macro><name>GetWrapper</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCWrappedNativeProto</name>*       <macro><name>GetProto</name><argument_list>()</argument_list></macro> const</expr> ;

    <expr>inline <name>JSBool</name>                       <macro><name>CanGetTearOff</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCWrappedNativeTearOff</name>*     <macro><name>GetTearOff</name><argument_list>()</argument_list></macro> const</expr> ;

    <expr>inline <name>XPCNativeScriptableInfo</name>*     <macro><name>GetScriptableInfo</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSBool</name>                       <macro><name>CanGetSet</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCNativeSet</name>*                <macro><name>GetSet</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSBool</name>                       <macro><name>CanGetInterface</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCNativeInterface</name>*          <macro><name>GetInterface</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>XPCNativeMember</name>*             <macro><name>GetMember</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSBool</name>                       <macro><name>HasInterfaceAndMember</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>jsid</name>                         <macro><name>GetName</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSBool</name>                       <macro><name>GetStaticMemberIsLocal</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>uintN</name>                        <macro><name>GetArgc</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>jsval</name>*                       <macro><name>GetArgv</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>jsval</name>*                       <macro><name>GetRetVal</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>JSBool</name>                       <macro><name>GetReturnValueWasSet</name><argument_list>()</argument_list></macro> const</expr> ;

    <expr>inline <name>PRUint16</name>                     <macro><name>GetMethodIndex</name><argument_list>()</argument_list></macro> const</expr> ;
    <expr>inline <name>void</name>                         <macro><name>SetMethodIndex</name><argument_list>(<argument>PRUint16 index</argument>)</argument_list></macro></expr> ;

    <expr>inline <name>JSBool</name>   <macro><name>GetDestroyJSContextInDestructor</name><argument_list>()</argument_list></macro> const</expr>;
    <expr>inline <name>void</name>     <macro><name>SetDestroyJSContextInDestructor</name><argument_list>(<argument>JSBool b</argument>)</argument_list></macro></expr>;

    <expr>inline <name>jsid</name> <macro><name>GetResolveName</name><argument_list>()</argument_list></macro> const</expr>;
    <expr>inline <name>jsid</name> <macro><name>SetResolveName</name><argument_list>(<argument>jsid name</argument>)</argument_list></macro></expr>;

    <expr>inline <name>XPCWrappedNative</name>* <macro><name>GetResolvingWrapper</name><argument_list>()</argument_list></macro> const</expr>;
    <expr>inline <name>XPCWrappedNative</name>* <call><name>SetResolvingWrapper</name><argument_list>(<argument><expr><name>XPCWrappedNative</name>* <name>w</name></expr></argument>)</argument_list></call></expr>;

    <expr>inline <name>void</name> <macro><name>SetRetVal</name><argument_list>(<argument>jsval val</argument>)</argument_list></macro></expr>;

    <expr>inline <name>JSObject</name>* <macro><name>GetCallee</name><argument_list>()</argument_list></macro> const</expr>;
    <expr>inline <name>void</name> <call><name>SetCallee</name><argument_list>(<argument><expr><name>JSObject</name>* <name>callee</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>void</name> <macro><name>SetName</name><argument_list>(<argument>jsid name</argument>)</argument_list></macro></expr>;
    <expr><name>void</name> <macro><name>SetArgsAndResultPtr</name><argument_list>(<argument>uintN argc</argument>, <argument>jsval *argv</argument>, <argument>jsval *rval</argument>)</argument_list></macro></expr>;
    <expr><name>void</name> <macro><name>SetCallInfo</name><argument_list>(<argument>XPCNativeInterface* iface</argument>, <argument>XPCNativeMember* member</argument>,
                     <argument>JSBool isSetter</argument>)</argument_list></macro></expr>;

    <expr><name>nsresult</name>  <call><name>CanCallNow</name><argument_list>()</argument_list></call></expr>;

    <expr><name>void</name> <call><name>SystemIsBeingShutDown</name><argument_list>()</argument_list></call></expr>;

    <expr><name>operator</name> <macro><name>JSContext</name></macro>*() const <block>{<return>return <expr><call><name>GetJSContext</name><argument_list>()</argument_list></call></expr>;</return></block></expr>}</block>

    <name>XPCReadableJSStringWrapper</name> *<macro><name>NewStringWrapper</name><argument_list>(<argument>PRUnichar *str</argument>, <argument>PRUint32 len</argument>)</argument_list></macro></expr>;</expr_stmt>
    <function_decl><type><name>void</name></type> <name>DeleteString</name><parameter_list>(<param><decl><type><name>nsAString</name> *</type><name>string</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>
    <comment type="block">/**
     * Sets the IDispatch information for the context
     * This has to be void* because of icky Microsoft macros that
     * would be introduced if we included the DispatchInterface header
     */</comment>
    <function_decl><type><name>void</name></type> <name>SetIDispatchInfo</name><parameter_list>(<param><decl><type><name>XPCNativeInterface</name>*</type> <name>iface</name></decl></param>, <param><decl><type><name>void</name> *</type> <name>member</name></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>void</name>* <macro><name>GetIDispatchMember</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mIDispatchMember</name></expr>;</return> }</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>private</name>:</label>

    <comment type="line">// no copy ctor or assignment allowed</comment>
    <expr_stmt><expr><call><name>XPCCallContext</name><argument_list>(<argument><expr>const <name>XPCCallContext</name>&amp; <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>
    <decl_stmt><decl><type><name>XPCCallContext</name>&amp;</type> <name>operator</name><init>= <expr>(const <name>XPCCallContext</name>&amp; <name>r</name>)</expr></init></decl>;</decl_stmt> <comment type="line">// not implemented</comment>

    <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>XPCLazyCallContext</name></decl>;</decl_stmt>
    <macro><name>XPCCallContext</name><argument_list>(<argument>XPCContext::LangType callerLanguage</argument>,
                   <argument>JSContext* cx</argument>,
                   <argument>JSBool callBeginRequest</argument>,
                   <argument>JSObject* obj</argument>,
                   <argument>JSObject* currentJSObject</argument>,
                   <argument>XPCWrappedNative* wn</argument>,
                   <argument>XPCWrappedNativeTearOff* tearoff</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name>void</name></type> <name>Init</name><argument_list>(<argument><expr><name>XPCContext</name>::<name>LangType</name> <name>callerLanguage</name></expr></argument>,
              <argument><expr><name>JSBool</name> <name>callBeginRequest</name></expr></argument>,
              <argument><expr><name>JSObject</name>* <name>obj</name></expr></argument>,
              <argument><expr><name>JSObject</name>* <name>funobj</name></expr></argument>,
              <argument><expr><name>JSBool</name> <name>getWrappedNative</name></expr></argument>,
              <argument><expr><name>jsid</name> <name>name</name></expr></argument>,
              <argument><expr><name>uintN</name> <name>argc</name></expr></argument>,
              <argument><expr><name>jsval</name> *<name>argv</name></expr></argument>,
              <argument><expr><name>jsval</name> *<name>rval</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>private</name>:</label>
    <comment type="line">// posible values for mState</comment>
    <enum>enum <name>State</name> <block>{
        <decl><name>INIT_FAILED</name></decl>,
        <decl><name>SYSTEM_SHUTDOWN</name></decl>,
        <decl><name>HAVE_CONTEXT</name></decl>,
        <decl><name>HAVE_OBJECT</name></decl>,
        <decl><name>HAVE_NAME</name></decl>,
        <decl><name>HAVE_ARGS</name></decl>,
        <decl><name>READY_TO_CALL</name></decl>,
        <decl><name>CALL_DONE</name></decl>
    }</block>;</enum>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>CHECK_STATE</name><argument_list>(<argument><expr><name>int</name> <name>s</name></expr></argument>)</argument_list> const <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mState</name> &gt;= <name>s</name></expr></argument>, <argument><expr>"bad state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></decl></decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STATE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>State</name></type>                           <name>mState</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsXPConnect</name>*</type>                    <name>mXPC</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XPCPerThreadData</name>*</type>               <name>mThreadData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCContext</name>*</type>                     <name>mXPCContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name>*</type>                      <name>mJSContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>                          <name>mContextPopRequired</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>                          <name>mDestroyJSContextInDestructor</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>XPCContext</name>::<name>LangType</name>            <name>mCallerLanguage</name></expr>;</expr_stmt>

    <comment type="line">// ctor does not necessarily init the following. BEWARE!</comment>

    <expr_stmt><expr><name>XPCContext</name>::<name>LangType</name>            <name>mPrevCallerLanguage</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>XPCCallContext</name>*</type>                 <name>mPrevCallContext</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type>                       <name>mOperandJSObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                       <name>mCurrentJSObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                       <name>mFlattenedJSObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNative</name>*</type>               <name>mWrapper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeTearOff</name>*</type>        <name>mTearOff</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XPCNativeScriptableInfo</name>*</type>        <name>mScriptableInfo</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XPCNativeSet</name>*</type>                   <name>mSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeInterface</name>*</type>             <name>mInterface</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeMember</name>*</type>                <name>mMember</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsid</name></type>                            <name>mName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>                          <name>mStaticMemberIsLocal</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uintN</name></type>                           <name>mArgc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type>                          <name>mArgv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type>                          <name>mRetVal</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSBool</name></type>                          <name>mReturnValueWasSet</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>void</name>*</type>                           <name>mIDispatchMember</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>PRUint16</name></type>                        <name>mMethodIndex</name></decl>;</decl_stmt>

    <comment type="line">// If not null, this is the function object of the function we're going to</comment>
    <comment type="line">// call.  This member only makes sense when CallerTypeIsNative() on our</comment>
    <comment type="line">// XPCContext returns true.  We're not responsible for rooting this object;</comment>
    <comment type="line">// whoever sets it on us needs to deal with that.</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                       <name>mCallee</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPCCCX_STRING_CACHE_SIZE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

    <comment type="line">// String wrapper entry, holds a string, and a boolean that tells</comment>
    <comment type="line">// whether the string is in use or not.</comment>
    <struct>struct <name>StringWrapperEntry</name>
    <block>{
        <expr_stmt><expr><call><name>StringWrapperEntry</name><argument_list>()</argument_list></call>
            : <macro><name>mInUse</name><argument_list>(<argument>PR_FALSE</argument>)</argument_list></macro>
        <block>{
        }</block>

        <name>XPCReadableJSStringWrapper</name> <name>mString</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>mInUse</name></decl>;</decl_stmt>
    }</block>;</struct>

    <comment type="line">// Reserve space for XPCCCX_STRING_CACHE_SIZE string wrapper</comment>
    <comment type="line">// entries for use on demand. It's important to not make this be</comment>
    <comment type="line">// string class members since we don't want to pay the cost of</comment>
    <comment type="line">// calling the constructors and destructors when the strings</comment>
    <comment type="line">// aren't being used.</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>mStringWrapperData</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>StringWrapperEntry</name></expr></argument>)</argument_list></sizeof> * <name>XPCCCX_STRING_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
};

<decl_stmt><decl><type><name>class</name></type> <name>XPCLazyCallContext</name>
<block>{
<label><name>public</name>:</label>
    <expr_stmt><expr><call><name>XPCLazyCallContext</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>)</argument_list></call>
        : <call><name>mCallBeginRequest</name><argument_list>(<argument><expr><name>DONT_CALL_BEGINREQUEST</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCcx</name><argument_list>(<argument><expr>&amp;<name>ccx</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCcxToDestroy</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
          , <expr><call><name>mCx</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>
          , <expr><call><name>mCallerLanguage</name><argument_list>(<argument><expr><name>JS_CALLER</name></expr></argument>)</argument_list></call></expr>
          , <expr><call><name>mObj</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>
          , <expr><call><name>mCurrentJSObject</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>
          , <expr><call><name>mWrapper</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>
          , <macro><name>mTearOff</name><argument_list>(<argument>nsnull</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{
    }</block>
    <macro><name>XPCLazyCallContext</name><argument_list>(<argument>XPCContext::LangType callerLanguage</argument>, <argument>JSContext* cx</argument>,
                       <argument>JSObject* obj = nsnull</argument>,
                       <argument>JSObject* currentJSObject = nsnull</argument>,
                       <argument>XPCWrappedNative* wrapper = nsnull</argument>,
                       <argument>XPCWrappedNativeTearOff* tearoff = nsnull</argument>)</argument_list></macro>
        : <call><name>mCallBeginRequest</name><argument_list>(<argument><expr><name>callerLanguage</name> == <name>NATIVE_CALLER</name> ?
                            <name>CALL_BEGINREQUEST</name> : <name>DONT_CALL_BEGINREQUEST</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCcx</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCcxToDestroy</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCallerLanguage</name><argument_list>(<argument><expr><name>callerLanguage</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mObj</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mCurrentJSObject</name><argument_list>(<argument><expr><name>currentJSObject</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mWrapper</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>,
          <macro><name>mTearOff</name><argument_list>(<argument>tearoff</argument>)</argument_list></macro>
    <expr><block>{
        <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Need a JS context!"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>callerLanguage</name> == <name>NATIVE_CALLER</name> ||
                     <name>callerLanguage</name> == <name>JS_CALLER</name></expr></argument>,
                     <argument><expr>"Can't deal with unknown caller language!"</expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr><call><name>AssertContextIsTopOfStack</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    ~<macro><name>XPCLazyCallContext</name><argument_list>()</argument_list></macro>
    <block>{
        <if>if<condition>(<expr><name>mCcxToDestroy</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>mCcxToDestroy</name>-&gt;<name/></name>~<call><name>XPCCallContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if<condition>(<expr><name>mCallBeginRequest</name> == <name>CALLED_BEGINREQUEST</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_EndRequest</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></expr></expr_stmt>
    <function_decl><type><name>void</name></type> <name>SetWrapper</name><parameter_list>(<param><decl><type><name>XPCWrappedNative</name>*</type> <name>wrapper</name></decl></param>,
                    <param><decl><type><name>XPCWrappedNativeTearOff</name>*</type> <name>tearoff</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>SetWrapper</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>currentJSObject</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>JSContext</name> *</type><name>GetJSContext</name><parameter_list>()</parameter_list>
    <block>{
        <if>if<condition>(<expr><name>mCcx</name></expr>)</condition><then>
            <return>return <expr><call><name><name>mCcx</name>-&gt;<name>GetJSContext</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <if>if<condition>(<expr><name>mCallBeginRequest</name> == <name>CALL_BEGINREQUEST</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_BeginRequest</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCallBeginRequest</name> = <name>CALLED_BEGINREQUEST</name></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><name>mCx</name></expr>;</return>
    }</block></function>
    <expr_stmt><expr><name>JSObject</name> *<macro><name>GetCurrentJSObject</name><argument_list>()</argument_list></macro> const
    <block>{
        <if>if<condition>(<expr><name>mCcx</name></expr>)</condition><then>
            <return>return <expr><call><name><name>mCcx</name>-&gt;<name>GetCurrentJSObject</name></name><argument_list>()</argument_list></call></expr>;</return></then></if></block></expr></expr_stmt>

        <return>return <expr><name>mCurrentJSObject</name></expr>;</return>
    }</block></decl></decl_stmt>
    <function><type><name>XPCCallContext</name> &amp;</type><name>GetXPCCallContext</name><parameter_list>()</parameter_list>
    <block>{
        <if>if<condition>(<expr>!<name>mCcx</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>mCcxToDestroy</name> = <name>mCcx</name> =
                <macro><name>new</name> <argument_list>(<argument>mData</argument>)</argument_list></macro> <call><name>XPCCallContext</name><argument_list>(<argument><expr><name>mCallerLanguage</name></expr></argument>, <argument><expr><name>mCx</name></expr></argument>,
                                           <argument><expr><name>mCallBeginRequest</name> == <name>CALL_BEGINREQUEST</name></expr></argument>,
                                           <argument><expr><name>mObj</name></expr></argument>,
                                           <argument><expr><name>mCurrentJSObject</name></expr></argument>, <argument><expr><name>mWrapper</name></expr></argument>,
                                           <argument><expr><name>mTearOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>(<expr>!<call><name><name>mCcx</name>-&gt;<name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"This is not supposed to fail!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <return>return <expr>*<name>mCcx</name></expr>;</return>
    }</block></function>

<label><name>private</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssertContextIsTopOfStack</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <enum>enum <block>{
        <decl><name>DONT_CALL_BEGINREQUEST</name></decl>,
        <decl><name>CALL_BEGINREQUEST</name></decl>,
        <decl><name>CALLED_BEGINREQUEST</name></decl>
    }</block> <decl><name>mCallBeginRequest</name></decl>;</enum>

    <decl_stmt><decl><type><name>XPCCallContext</name> *</type><name>mCcx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCCallContext</name> *</type><name>mCcxToDestroy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>XPCContext</name>::<name>LangType</name> <name>mCallerLanguage</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>mObj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>mCurrentJSObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNative</name> *</type><name>mWrapper</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeTearOff</name> *</type><name>mTearOff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>mData</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>XPCCallContext</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
};

<comment type="block">/***************************************************************************
****************************************************************************
*
* Core classes for wrapped native objects for use from JavaScript...
*
****************************************************************************
***************************************************************************/</comment>

<comment type="line">// These are the various JSClasses and callbacks whose use that required</comment>
<comment type="line">// visibility from more than one .cpp file.</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <name>JSExtendedClass</name></type> <name>XPC_WN_NoHelper_JSClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>JSClass</name></type> <name>XPC_WN_NoMods_WithCall_Proto_JSClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>JSClass</name></type> <name>XPC_WN_NoMods_NoCall_Proto_JSClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>JSClass</name></type> <name>XPC_WN_ModsAllowed_WithCall_Proto_JSClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>JSClass</name></type> <name>XPC_WN_ModsAllowed_NoCall_Proto_JSClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>JSClass</name></type> <name>XPC_WN_Tearoff_JSClass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>JSClass</name></type> <name>XPC_WN_NoHelper_Proto_JSClass</name></decl>;</decl_stmt>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>XPC_WN_Equality</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jsval</name> *</type><name>v</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>bp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSObjectOps</name> *</type>
<name>XPC_WN_Proto_GetObjectOps</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSClass</name> *</type><name>clazz</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>XPC_WN_CallMethod</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>,
                  <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>XPC_WN_GetterSetter</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>,
                    <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>xpc_InitWrappedNativeJSOps</name><parameter_list>()</parameter_list>;</function_decl>

<comment type="line">// Maybe this macro should check for class-&gt;enumerate ==</comment>
<comment type="line">// XPC_WN_Shared_Proto_Enumerate or something rather than checking for</comment>
<comment type="line">// 4 classes?</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PROTO_CLASS</name><parameter_list>(<param><type><name>clazz</name></type></param>)</parameter_list></cpp:macro>                                                 \
          <cpp:value>((clazz) == &amp;XPC_WN_NoMods_WithCall_Proto_JSClass ||                \
           (clazz) == &amp;XPC_WN_NoMods_NoCall_Proto_JSClass ||                  \
           (clazz) == &amp;XPC_WN_ModsAllowed_WithCall_Proto_JSClass ||           \
           (clazz) == &amp;XPC_WN_ModsAllowed_NoCall_Proto_JSClass)</cpp:value></cpp:define>

<comment type="line">// NOTE!!!</comment>
<comment type="line">//</comment>
<comment type="line">// If this ever changes,</comment>
<comment type="line">// nsScriptSecurityManager::doGetObjectPrincipal() *must* be updated</comment>
<comment type="line">// also!</comment>
<comment type="line">//</comment>
<comment type="line">// NOTE!!!</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_WRAPPER_CLASS</name><parameter_list>(<param><type><name>clazz</name></type></param>)</parameter_list></cpp:macro>                                               \
    <cpp:value>(((clazz)-&gt;flags &amp; JSCLASS_IS_EXTENDED) &amp;&amp;                                \
     reinterpret_cast&lt;JSExtendedClass*&gt;(clazz)-&gt;equality == XPC_WN_Equality)</cpp:value></cpp:define>

<function><type><specifier>inline</specifier> <name>JSBool</name></type>
<name>DebugCheckWrapperClass</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IS_WRAPPER_CLASS</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"Forgot to check if this is a wrapper?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// If IS_WRAPPER_CLASS for the JSClass of an object is true, the object can be</comment>
<comment type="line">// a slim wrapper, holding a native in its private slot, or a wrappednative</comment>
<comment type="line">// wrapper, holding the XPCWrappedNative in its private slot. A slim wrapper</comment>
<comment type="line">// also holds a pointer to its XPCWrappedNativeProto in a reserved slot, we can</comment>
<comment type="line">// check that slot for a non-void value to distinguish between the two.</comment>

<comment type="line">// Only use these macros if IS_WRAPPER_CLASS(obj-&gt;getClass()) is true.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_WN_WRAPPER_OBJECT</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>(DebugCheckWrapperClass(obj) &amp;&amp;                                           \
     obj-&gt;getSlot(JSSLOT_START(obj-&gt;getClass())).isUndefined())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLIM_WRAPPER_OBJECT</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                                           \
    <cpp:value>(DebugCheckWrapperClass(obj) &amp;&amp;                                           \
     !obj-&gt;getSlot(JSSLOT_START(obj-&gt;getClass())).isUndefined())</cpp:value></cpp:define>

<comment type="line">// Use these macros if IS_WRAPPER_CLASS(obj-&gt;getClass()) might be false.</comment>
<comment type="line">// Avoid calling them if IS_WRAPPER_CLASS(obj-&gt;getClass()) can only be</comment>
<comment type="line">// true, as we'd do a redundant call to IS_WRAPPER_CLASS.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_WN_WRAPPER</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>(IS_WRAPPER_CLASS(obj-&gt;getClass()) &amp;&amp; IS_WN_WRAPPER_OBJECT(obj))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLIM_WRAPPER</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                                                  \
    <cpp:value>(IS_WRAPPER_CLASS(obj-&gt;getClass()) &amp;&amp; IS_SLIM_WRAPPER_OBJECT(obj))</cpp:value></cpp:define>

<comment type="line">// Comes from xpcwrappednativeops.cpp</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>xpc_TraceForValidWrapper</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>XPCWrappedNative</name>*</type> <name>wrapper</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/***************************************************************************/</comment>

<decl_stmt><decl><type><name>namespace</name></type> <name>XPCWrapper</name> <block>{

<enum>enum <name>WrapperType</name> <block>{
    <decl><name>UNKNOWN</name>         <init>= <expr>0</expr></init></decl>,
    <decl><name>NONE</name>            <init>= <expr>0</expr></init></decl>,
    <decl><name>XPCNW_IMPLICIT</name>  <init>= <expr>1 &lt;&lt; 0</expr></init></decl>,
    <decl><name>XPCNW_EXPLICIT</name>  <init>= <expr>1 &lt;&lt; 1</expr></init></decl>,
    <decl><name>XPCNW</name>           <init>= <expr>(<name>XPCNW_IMPLICIT</name> | <name>XPCNW_EXPLICIT</name>)</expr></init></decl>,
    <decl><name>SJOW</name>            <init>= <expr>1 &lt;&lt; 2</expr></init></decl>,
    <comment type="line">// SJOW must be the last wrapper type that can be returned to chrome.</comment>

    <decl><name>XOW</name>             <init>= <expr>1 &lt;&lt; 3</expr></init></decl>,
    <decl><name>COW</name>             <init>= <expr>1 &lt;&lt; 4</expr></init></decl>,
    <decl><name>SOW</name>             <init>= <expr>1 &lt;&lt; 5</expr></init></decl>
}</block>;</enum>

}</block></decl></decl_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCWrappedNativeScope is one-to-one with a JS global object.</comment>

<expr_stmt><expr><name>class</name> <name>XPCWrappedNativeScope</name> : <name>public</name> <name>PRCList</name>
<block>{
<expr><name>public</name>:

    static <name>XPCWrappedNativeScope</name>*
    <call><name>GetNewOrUsed</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>, <argument><expr><name>JSObject</name>* <name>aGlobal</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>XPCJSRuntime</name>*
    <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mRuntime</name></expr>;</return></block></expr>}</block>

    <name>Native2WrappedNativeMap</name>*
    <macro><name>GetWrappedNativeMap</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mWrappedNativeMap</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>WrappedNative2WrapperMap</name>*
    <macro><name>GetWrapperMap</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mWrapperMap</name></expr>;</return>}</block></expr></expr_stmt>

    <decl_stmt><decl><type><name>ClassInfo2WrappedNativeProtoMap</name>*</type>
    <name>GetWrappedNativeProtoMap</name><argument_list>(<argument><expr><name>JSBool</name> <name>aMainThreadOnly</name></expr></argument>)</argument_list> const
        <block>{<return>return <expr><name>aMainThreadOnly</name> ?
                <name>mMainThreadWrappedNativeProtoMap</name> :
                <name>mWrappedNativeProtoMap</name></expr>;</return>}</block></decl></decl_stmt>

    <expr_stmt><expr><name>nsXPCComponents</name>*
    <macro><name>GetComponents</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mComponents</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSObject</name>*
    <macro><name>GetGlobalJSObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mGlobalJSObject</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSObject</name>*
    <macro><name>GetPrototypeJSObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mPrototypeJSObject</name></expr>;</return>}</block></expr></expr_stmt>

    <comment type="line">// Getter for the prototype that we use for wrappers that have no</comment>
    <comment type="line">// helper.</comment>
    <function_decl><type><name>JSObject</name>*</type>
    <name>GetPrototypeNoHelper</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
    <expr_stmt><expr><name>nsIPrincipal</name>*
    <macro><name>GetPrincipal</name><argument_list>()</argument_list></macro> const
    <block>{<return>return <expr><name>mScriptObjectPrincipal</name> ?
         <call><name><name>mScriptObjectPrincipal</name>-&gt;<name>GetPrincipal</name></name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <expr_stmt><expr><name>JSObject</name>*
    <macro><name>GetPrototypeJSFunction</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mPrototypeJSFunction</name></expr>;</return>}</block></expr></expr_stmt>

    <function_decl><type><name>void</name></type> <name>RemoveWrappedNativeProtos</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>XPCWrappedNativeScope</name>*</type>
    <name>FindInJSObjectScope</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>,
                        <param><decl><type><name>JSBool</name></type> <name>OKIfNotInitialized</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl></param>,
                        <name>XPCJSRuntime</name>* <name>runtime</name> = <name>nsnull</name>)</parameter_list>;</function_decl>

    <function><type><specifier>static</specifier> <name>XPCWrappedNativeScope</name>*</type>
    <name>FindInJSObjectScope</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>,
                        <param><decl><type><name>JSBool</name></type> <name>OKIfNotInitialized</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>FindInJSObjectScope</name><argument_list>(<argument><expr><name>ccx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OKIfNotInitialized</name></expr></argument>,
                                   <argument><expr><call><name><name>ccx</name>.<name>GetRuntime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>SystemIsBeingShutDown</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>, <param><decl><type><name>XPCJSRuntime</name>*</type> <name>rt</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>SuspectAllWrappers</name><parameter_list>(<param><decl><type><name>XPCJSRuntime</name>*</type> <name>rt</name></decl></param>, <param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                       <param><decl><type><name>nsCycleCollectionTraversalCallback</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>FinishedMarkPhaseOfGC</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>XPCJSRuntime</name>*</type> <name>rt</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>FinishedFinalizationPhaseOfGC</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>MarkAllWrappedNativesAndProtos</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>ClearAllWrappedNativeSecurityPolicies</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>ASSERT_NoInterfaceSetsAreMarked</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>SweepAllWrappedNativeTearOffs</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>DebugDumpAllScopes</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type>
    <name>DebugDump</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>JSBool</name>
    <macro><name>IsValid</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mRuntime</name> != <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <comment type="block">/**
     * Figures out what type of wrapper to create for obj if it were injected
     * into 'this's scope.
     */</comment>
    <expr_stmt><expr><name>XPCWrapper</name>::<name>WrapperType</name>
    <macro><name>GetWrapperFor</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj</argument>, <argument>XPCWrapper::WrapperType hint</argument>,
                  <argument>XPCWrappedNative **wn</argument>)</argument_list></macro></expr>;</expr_stmt>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
    <name>IsDyingScope</name><parameter_list>(<param><decl><type><name>XPCWrappedNativeScope</name> *</type><name>scope</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>SetComponents</name><parameter_list>(<param><decl><type><name>nsXPCComponents</name>*</type> <name>aComponents</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>SetGlobal</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>aGlobal</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>InitStatics</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>gScopes</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>gDyingScopes</name> = <name>nsnull</name></expr>;</expr_stmt> }</block></function>

    <function><type><name>XPCContext</name> *</type><name>GetContext</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mContext</name></expr>;</return> }</block></function>
    <function><type><name>void</name></type> <name>SetContext</name><parameter_list>(<param><decl><type><name>XPCContext</name> *</type><name>xpcc</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mContext</name> = <name>nsnull</name></expr>;</expr_stmt> }</block></function>

<label><name>protected</name>:</label>
    <expr_stmt><expr><call><name>XPCWrappedNativeScope</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>, <argument><expr><name>JSObject</name>* <name>aGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>virtual</name> ~<call><name>XPCWrappedNativeScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KillDyingScopes</name><parameter_list>()</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name>XPCWrappedNativeScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XPCWrappedNativeScope</name>*</type> <name>gScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XPCWrappedNativeScope</name>*</type> <name>gDyingScopes</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XPCJSRuntime</name>*</type>                    <name>mRuntime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Native2WrappedNativeMap</name>*</type>         <name>mWrappedNativeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClassInfo2WrappedNativeProtoMap</name>*</type> <name>mWrappedNativeProtoMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ClassInfo2WrappedNativeProtoMap</name>*</type> <name>mMainThreadWrappedNativeProtoMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WrappedNative2WrapperMap</name>*</type>        <name>mWrapperMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsXPCComponents</name>*</type>                 <name>mComponents</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeScope</name>*</type>           <name>mNext</name></decl>;</decl_stmt>
    <comment type="line">// The JS global object for this scope.  If non-null, this will be the</comment>
    <comment type="line">// default parent for the XPCWrappedNatives that have us as the scope,</comment>
    <comment type="line">// unless a PreCreate hook overrides it.  Note that this _may_ be null (see</comment>
    <comment type="line">// constructor).</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                        <name>mGlobalJSObject</name></decl>;</decl_stmt>

    <comment type="line">// Cached value of Object.prototype</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                        <name>mPrototypeJSObject</name></decl>;</decl_stmt>
    <comment type="line">// Cached value of Function.prototype</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                        <name>mPrototypeJSFunction</name></decl>;</decl_stmt>
    <comment type="line">// Prototype to use for wrappers with no helper.</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                        <name>mPrototypeNoHelper</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>XPCContext</name>*</type>                      <name>mContext</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
    <comment type="line">// The script object principal instance corresponding to our current global</comment>
    <comment type="line">// JS object.</comment>
    <comment type="line">// XXXbz what happens if someone calls JS_SetPrivate on mGlobalJSObject.</comment>
    <comment type="line">// How do we deal?  Do we need to?  I suspect this isn't worth worrying</comment>
    <comment type="line">// about, since all of our scope objects are verified as not doing that.</comment>
    <decl_stmt><decl><type><name>nsIScriptObjectPrincipal</name>*</type> <name>mScriptObjectPrincipal</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
};

<function_decl><type><name>JSObject</name>*</type> <name>xpc_CloneJSFunction</name><parameter_list>(<param><decl><type><name>XPCCallContext</name> &amp;</type><name>ccx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>funobj</name></decl></param>,
                              <param><decl><type><name>JSObject</name> *</type><name>parent</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeMember represents a single idl declared method, attribute or</comment>
<comment type="line">// constant.</comment>

<comment type="line">// Tight. No virtual methods. Can be bitwise copied (until any resolution done).</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeMember</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>GetCallInfo</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                              <param><decl><type><name>JSObject</name>*</type> <name>funobj</name></decl></param>,
                              <param><decl><type><name>XPCNativeInterface</name>**</type> <name>pInterface</name></decl></param>,
                              <param><decl><type><name>XPCNativeMember</name>**</type>    <name>pMember</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>jsid</name>   <macro><name>GetName</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mName</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>PRUint16</name> <macro><name>GetIndex</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mIndex</name></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>JSBool</name></type> <name>GetConstantValue</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>XPCNativeInterface</name>*</type> <name>iface</name></decl></param>,
                            <param><decl><type><name>jsval</name>*</type> <name>pval</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IsConstant</name><argument_list>()</argument_list></call></expr></argument>,
                      <argument><expr>"Only call this if you're sure this is a constant!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if<condition>(<expr>!<call><name>IsResolved</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>Resolve</name><argument_list>(<argument><expr><name>ccx</name></expr></argument>, <argument><expr><name>iface</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
         <expr_stmt><expr>*<name>pval</name> = <name>mVal</name></expr>;</expr_stmt> <return>return <expr><name>JS_TRUE</name></expr>;</return>}</block></function>

    <function_decl><type><name>JSBool</name></type> <name>NewFunctionObject</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>XPCNativeInterface</name>*</type> <name>iface</name></decl></param>,
                             <param><decl><type><name>JSObject</name> *</type><name>parent</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>pval</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsMethod</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr>0 != (<name>mFlags</name> &amp; <name>METHOD</name>)</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsConstant</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr>0 != (<name>mFlags</name> &amp; <name>CONSTANT</name>)</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsAttribute</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr>0 != (<name>mFlags</name> &amp; <name>GETTER</name>)</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsWritableAttribute</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr>0 != (<name>mFlags</name> &amp; <name>SETTER_TOO</name>)</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsReadOnlyAttribute</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><call><name>IsAttribute</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>IsWritableAttribute</name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>


    <function><type><name>void</name></type> <name>SetName</name><parameter_list>(<param><decl><type><name>jsid</name></type> <name>a</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mName</name> = <name>a</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>void</name></type> <name>SetMethod</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>index</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><name>mVal</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>mFlags</name> = <name>METHOD</name></expr>;</expr_stmt> <expr_stmt><expr><name>mIndex</name> = <name>index</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>void</name></type> <name>SetConstant</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>index</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><name>mVal</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>mFlags</name> = <name>CONSTANT</name></expr>;</expr_stmt> <expr_stmt><expr><name>mIndex</name> = <name>index</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>void</name></type> <name>SetReadOnlyAttribute</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>index</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><name>mVal</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>mFlags</name> = <name>GETTER</name></expr>;</expr_stmt> <expr_stmt><expr><name>mIndex</name> = <name>index</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>void</name></type> <name>SetWritableAttribute</name><parameter_list>()</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mFlags</name> == <name>GETTER</name></expr></argument>,<argument><expr>"bad"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>mFlags</name> = <name>GETTER</name> | <name>SETTER_TOO</name></expr>;</expr_stmt>}</block></function>

    <comment type="block">/* default ctor - leave random contents */</comment>
    <macro><name>XPCNativeMember</name><argument_list>()</argument_list></macro>  <block>{<expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>XPCNativeMember</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block>
    <expr_stmt><expr>~<macro><name>XPCNativeMember</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>XPCNativeMember</name></expr></argument>)</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>DealWithDyingGCThings</name><argument_list>(<argument>JSContext* cx</argument>, <argument>XPCJSRuntime* rt</argument>)</argument_list></macro>
        <block>{<if>if<condition>(<expr><call><name>IsResolved</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_GCTHING</name><argument_list>(<argument><expr><name>mVal</name></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name>JS_IsAboutToBeFinalized</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_GCTHING</name><argument_list>(<argument><expr><name>mVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
           <block>{<expr_stmt><expr><name>mVal</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>mFlags</name> &amp;= ~<name>RESOLVED</name></expr>;</expr_stmt><expr_stmt/>}</block><expr_stmt/></then></if>}</block>

<name>private</name>:
    <name>JSBool</name> <macro><name>IsResolved</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mFlags</name> &amp; <name>RESOLVED</name></expr>;</return>}</block></expr></expr_stmt>
    <function_decl><type><name>JSBool</name></type> <name>Resolve</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>XPCNativeInterface</name>*</type> <name>iface</name></decl></param>)</parameter_list>;</function_decl>

    <enum>enum <block>{
        <decl><name>RESOLVED</name>    <init>= <expr>0x01</expr></init></decl>,
        <decl><name>METHOD</name>      <init>= <expr>0x02</expr></init></decl>,
        <decl><name>CONSTANT</name>    <init>= <expr>0x04</expr></init></decl>,
        <decl><name>GETTER</name>      <init>= <expr>0x08</expr></init></decl>,
        <decl><name>SETTER_TOO</name>  <init>= <expr>0x10</expr></init></decl>
    }</block>;</enum>

<label><name>private</name>:</label>
    <comment type="line">// our only data...</comment>
    <decl_stmt><decl><type><name>jsid</name></type>     <name>mName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type>    <name>mVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type> <name>mIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type> <name>mFlags</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeInterface represents a single idl declared interface. This is</comment>
<comment type="line">// primarily the set of XPCNativeMembers.</comment>

<comment type="line">// Tight. No virtual methods.</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeInterface</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeInterface</name>*</type> <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                            <param><decl><type><specifier>const</specifier> <name>nsIID</name>*</type> <name>iid</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeInterface</name>*</type> <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                            <param><decl><type><name>nsIInterfaceInfo</name>*</type> <name>info</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeInterface</name>*</type> <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                            <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeInterface</name>*</type> <name>GetISupports</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr>inline <name>nsIInterfaceInfo</name>* <macro><name>GetInterfaceInfo</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name><name>mInfo</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr>inline <name>jsid</name>              <macro><name>GetName</name><argument_list>()</argument_list></macro>          const <block>{<return>return <expr><name>mName</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr>inline const <name>nsIID</name>* <macro><name>GetIID</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
    <expr_stmt><expr>inline const <name>char</name>*  <macro><name>GetNameString</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>inline</specifier> <name>XPCNativeMember</name>*</type> <name>FindMember</name><argument_list>(<argument><expr><name>jsid</name> <name>name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>HasAncestor</name><argument_list>(<argument><expr>const <name>nsIID</name>* <name>iid</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>GetMemberName</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>,
                              <argument><expr>const <name>XPCNativeMember</name>* <name>member</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <expr_stmt><expr><name>PRUint16</name> <macro><name>GetMemberCount</name><argument_list>()</argument_list></macro> const
        <block>{<expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>IsMarked</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"bad"</expr></argument>)</argument_list></call></expr>; <return>return <expr><name>mMemberCount</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>XPCNativeMember</name>*</type> <name>GetMemberAt</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>i</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>i</name> &lt; <name>mMemberCount</name></expr></argument>, <argument><expr>"bad index"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr>&amp;<name><name>mMembers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>}</block></function>

    <function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>DealWithDyingGCThings</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>XPCJSRuntime</name>*</type> <name>rt</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>DebugDump</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_IFACE_MARK_FLAG</name></cpp:macro> <cpp:value>((PRUint16)JS_BIT(15))</cpp:value></cpp:define> <comment type="line">// only high bit of 16 is set</comment>

    <function><type><name>void</name></type> <name>Mark</name><parameter_list>()</parameter_list>     <block>{<expr_stmt><expr><name>mMemberCount</name> |= <name>XPC_NATIVE_IFACE_MARK_FLAG</name></expr>;</expr_stmt>}</block></function>
    <function><type><name>void</name></type> <name>Unmark</name><parameter_list>()</parameter_list>   <block>{<expr_stmt><expr><name>mMemberCount</name> &amp;= ~<name>XPC_NATIVE_IFACE_MARK_FLAG</name></expr>;</expr_stmt>}</block></function>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsMarked</name><argument_list>()</argument_list></macro> const
                    <block>{<return>return <expr>0 != (<name>mMemberCount</name> &amp; <name>XPC_NATIVE_IFACE_MARK_FLAG</name>)</expr>;</return>}</block></expr></expr_stmt>

    <comment type="line">// NOP. This is just here to make the AutoMarkingPtr code compile.</comment>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>AutoTrace</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestroyInstance</name><parameter_list>(<param><decl><type><name>XPCNativeInterface</name>*</type> <name>inst</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeInterface</name>*</type> <name>NewInstance</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                           <param><decl><type><name>nsIInterfaceInfo</name>*</type> <name>aInfo</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name>XPCNativeInterface</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// not implemented</comment>
    <macro><name>XPCNativeInterface</name><argument_list>(<argument>nsIInterfaceInfo* aInfo</argument>, <argument>jsid aName</argument>)</argument_list></macro>
        : <expr_stmt><expr><call><name>mInfo</name><argument_list>(<argument><expr><name>aInfo</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mName</name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr>, <macro><name>mMemberCount</name><argument_list>(<argument>0</argument>)</argument_list></macro>
                          <expr><block>{<expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>XPCNativeInterface</name></expr></argument>)</argument_list></call></expr>;}</block>
    ~<macro><name>XPCNativeInterface</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>XPCNativeInterface</name></expr></argument>)</argument_list></call></expr>;}</block>

    <name>void</name>* <name>operator</name> <macro><name>new</name><argument_list>(<argument>size_t</argument>, <argument>void* p</argument>)</argument_list></macro> <name>CPP_THROW_NEW</name> <block>{<return>return <expr><name>p</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><call><name>XPCNativeInterface</name><argument_list>(<argument><expr>const <name>XPCNativeInterface</name>&amp; <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>
    <decl_stmt><decl><type><name>XPCNativeInterface</name>&amp;</type> <name>operator</name><init>= <expr>(const <name>XPCNativeInterface</name>&amp; <name>r</name>)</expr></init></decl>;</decl_stmt> <comment type="line">// not implemented</comment>

<label><name>private</name>:</label>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIInterfaceInfo</name>&gt; <name>mInfo</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jsid</name></type>                       <name>mName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type>          <name>mMemberCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeMember</name></type>   <name><name>mMembers</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt> <comment type="line">// always last - object sized for array</comment>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeSetKey is used to key a XPCNativeSet in a NativeSetMap.</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeSetKey</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>XPCNativeSetKey</name><argument_list>(<argument>XPCNativeSet*       BaseSet  = nsnull</argument>,
                    <argument>XPCNativeInterface* Addition = nsnull</argument>,
                    <argument>PRUint16            Position = 0</argument>)</argument_list></macro>
        : <expr_stmt><expr><call><name>mIsAKey</name><argument_list>(<argument><expr><name>IS_A_KEY</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mPosition</name><argument_list>(<argument><expr><name>Position</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mBaseSet</name><argument_list>(<argument><expr><name>BaseSet</name></expr></argument>)</argument_list></call></expr>,
          <macro><name>mAddition</name><argument_list>(<argument>Addition</argument>)</argument_list></macro> <expr><block>{}</block>
    ~<macro><name>XPCNativeSetKey</name><argument_list>()</argument_list></macro> <block>{}</block>

    <name>XPCNativeSet</name>*           <macro><name>GetBaseSet</name><argument_list>()</argument_list></macro>  const <block>{<return>return <expr><name>mBaseSet</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>XPCNativeInterface</name>*     <macro><name>GetAddition</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mAddition</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>PRUint16</name>                <macro><name>GetPosition</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mPosition</name></expr>;</return>}</block></expr></expr_stmt>

    <comment type="line">// This is a fun little hack...</comment>
    <comment type="line">// We build these keys only on the stack. We use them for lookup in</comment>
    <comment type="line">// NativeSetMap. Becasue we don't want to pay the cost of cloning a key and</comment>
    <comment type="line">// sticking it into the hashtable, when the XPCNativeSet actually</comment>
    <comment type="line">// gets added to the table the 'key' in the table is a pointer to the</comment>
    <comment type="line">// set itself and not this key. Our key compare function expects to get</comment>
    <comment type="line">// a key and a set. When we do external lookups in the map we pass in one</comment>
    <comment type="line">// of these keys and our compare function gets passed a key and a set.</comment>
    <comment type="line">// (see compare_NativeKeyToSet in xpcmaps.cpp). This is all well and good.</comment>
    <comment type="line">// Except, when the table decides to resize itself. Then it tries to use</comment>
    <comment type="line">// our compare function with the 'keys' that are in the hashtable (which are</comment>
    <comment type="line">// really XPCNativeSet objects and not XPCNativeSetKey objects!</comment>
    <comment type="line">//</comment>
    <comment type="line">// So, the hack is to have the compare function assume it is getting a</comment>
    <comment type="line">// XPCNativeSetKey pointer and call this IsAKey method. If that fails then</comment>
    <comment type="line">// it realises that it really has a XPCNativeSet pointer and deals with that</comment>
    <comment type="line">// fact. This is safe because we know that both of these classes have no</comment>
    <comment type="line">// virtual methods and their first data member is a PRUint16. We are</comment>
    <comment type="line">// confident that XPCNativeSet-&gt;mMemberCount will never be 0xffff.</comment>

    <expr_stmt><expr><name>JSBool</name>                  <macro><name>IsAKey</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mIsAKey</name> == <name>IS_A_KEY</name></expr>;</return>}</block></expr></expr_stmt>

    <enum>enum <block>{<decl><name>IS_A_KEY</name> <init>= <expr>0xffff</expr></init></decl>}</block>;</enum>

    <comment type="line">// Allow shallow copy</comment>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>PRUint16</name></type>                <name>mIsAKey</name></decl>;</decl_stmt>    <comment type="line">// must be first data member</comment>
    <decl_stmt><decl><type><name>PRUint16</name></type>                <name>mPosition</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeSet</name>*</type>           <name>mBaseSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeInterface</name>*</type>     <name>mAddition</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeSet represents an ordered collection of XPCNativeInterface pointers.</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeSet</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeSet</name>*</type> <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIID</name>*</type> <name>iid</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeSet</name>*</type> <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                      <param><decl><type><name>nsIClassInfo</name>*</type> <name>classInfo</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeSet</name>*</type> <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                      <param><decl><type><name>XPCNativeSet</name>*</type> <name>otherSet</name></decl></param>,
                                      <param><decl><type><name>XPCNativeInterface</name>*</type> <name>newInterface</name></decl></param>,
                                      <param><decl><type><name>PRUint16</name></type> <name>position</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClearCacheEntryForClassInfo</name><parameter_list>(<param><decl><type><name>nsIClassInfo</name>*</type> <name>classInfo</name></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>FindMember</name><argument_list>(<argument><expr><name>jsid</name> <name>name</name></expr></argument>, <argument><expr><name>XPCNativeMember</name>** <name>pMember</name></expr></argument>,
                             <argument><expr><name>PRUint16</name>* <name>pInterfaceIndex</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>FindMember</name><argument_list>(<argument><expr><name>jsid</name> <name>name</name></expr></argument>, <argument><expr><name>XPCNativeMember</name>** <name>pMember</name></expr></argument>,
                             <argument><expr><name>XPCNativeInterface</name>** <name>pInterface</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>FindMember</name><argument_list>(<argument><expr><name>jsid</name> <name>name</name></expr></argument>,
                             <argument><expr><name>XPCNativeMember</name>** <name>pMember</name></expr></argument>,
                             <argument><expr><name>XPCNativeInterface</name>** <name>pInterface</name></expr></argument>,
                             <argument><expr><name>XPCNativeSet</name>* <name>protoSet</name></expr></argument>,
                             <argument><expr><name>JSBool</name>* <name>pIsLocal</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>HasInterface</name><argument_list>(<argument><expr><name>XPCNativeInterface</name>* <name>aInterface</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>HasInterfaceWithAncestor</name><argument_list>(<argument><expr><name>XPCNativeInterface</name>* <name>aInterface</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>HasInterfaceWithAncestor</name><argument_list>(<argument><expr>const <name>nsIID</name>* <name>iid</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>XPCNativeInterface</name>*</type> <name>FindInterfaceWithIID</name><argument_list>(<argument><expr>const <name>nsIID</name>&amp; <name>iid</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>XPCNativeInterface</name>*</type> <name>FindNamedInterface</name><argument_list>(<argument><expr><name>jsid</name> <name>name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <expr_stmt><expr><name>PRUint16</name> <macro><name>GetMemberCount</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mMemberCount</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>PRUint16</name> <macro><name>GetInterfaceCount</name><argument_list>()</argument_list></macro> const
        <block>{<expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>IsMarked</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"bad"</expr></argument>)</argument_list></call></expr>; <return>return <expr><name>mInterfaceCount</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>XPCNativeInterface</name>**</type> <name>GetInterfaceArray</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>mInterfaces</name></expr>;</return>}</block></function>

    <function><type><name>XPCNativeInterface</name>*</type> <name>GetInterfaceAt</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>i</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>i</name> &lt; <name>mInterfaceCount</name></expr></argument>, <argument><expr>"bad index"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name><name>mInterfaces</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>}</block></function>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>MatchesSetUpToInterface</name><argument_list>(<argument><expr>const <name>XPCNativeSet</name>* <name>other</name></expr></argument>,
                                          <argument><expr><name>XPCNativeInterface</name>* <name>iface</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_NATIVE_SET_MARK_FLAG</name></cpp:macro> <cpp:value>((PRUint16)JS_BIT(15))</cpp:value></cpp:define> <comment type="line">// only high bit of 16 is set</comment>

    <function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>Mark</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// NOP. This is just here to make the AutoMarkingPtr code compile.</comment>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>AutoTrace</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>

<label><name>private</name>:</label>
    <function><type><name>void</name></type> <name>MarkSelfOnly</name><parameter_list>()</parameter_list> <block>{<expr_stmt><expr><name>mInterfaceCount</name> |= <name>XPC_NATIVE_SET_MARK_FLAG</name></expr>;</expr_stmt>}</block></function>
<label><name>public</name>:</label>
    <function><type><name>void</name></type> <name>Unmark</name><parameter_list>()</parameter_list>       <block>{<expr_stmt><expr><name>mInterfaceCount</name> &amp;= ~<name>XPC_NATIVE_SET_MARK_FLAG</name></expr>;</expr_stmt>}</block></function>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsMarked</name><argument_list>()</argument_list></macro> const
                  <block>{<return>return <expr>0 != (<name>mInterfaceCount</name> &amp; <name>XPC_NATIVE_SET_MARK_FLAG</name>)</expr>;</return>}</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>ASSERT_NotMarked</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><name>void</name></type> <name>DebugDump</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestroyInstance</name><parameter_list>(<param><decl><type><name>XPCNativeSet</name>*</type> <name>inst</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeSet</name>*</type> <name>NewInstance</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                     <param><decl><type><name>XPCNativeInterface</name>**</type> <name>array</name></decl></param>,
                                     <param><decl><type><name>PRUint16</name></type> <name>count</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeSet</name>*</type> <name>NewInstanceMutate</name><parameter_list>(<param><decl><type><name>XPCNativeSet</name>*</type>       <name>otherSet</name></decl></param>,
                                           <param><decl><type><name>XPCNativeInterface</name>*</type> <name>newInterface</name></decl></param>,
                                           <param><decl><type><name>PRUint16</name></type>            <name>position</name></decl></param>)</parameter_list>;</function_decl>
    <macro><name>XPCNativeSet</name><argument_list>()</argument_list></macro>  <block>{<expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>XPCNativeSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block>
    <expr_stmt><expr>~<macro><name>XPCNativeSet</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>XPCNativeSet</name></expr></argument>)</argument_list></call></expr>;}</block>
    <name>void</name>* <name>operator</name> <macro><name>new</name><argument_list>(<argument>size_t</argument>, <argument>void* p</argument>)</argument_list></macro> <name>CPP_THROW_NEW</name> <block>{<return>return <expr><name>p</name></expr>;</return>}</block></expr></expr_stmt>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>PRUint16</name></type>                <name>mMemberCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type>                <name>mInterfaceCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeInterface</name>*</type>     <name><name>mInterfaces</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>  <comment type="line">// always last - object sized for array</comment>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeScriptableFlags is a wrapper class that holds the flags returned</comment>
<comment type="line">// from calls to nsIXPCScriptable::GetScriptableFlags(). It has convenience</comment>
<comment type="line">// methods to check for particular bitflags. Since we also use this class as</comment>
<comment type="line">// a member of the gc'd class XPCNativeScriptableShared, this class holds the</comment>
<comment type="line">// bit and exposes the inlined methods to support marking.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_WN_SJSFLAGS_MARK_FLAG</name></cpp:macro> <cpp:value>JS_BIT(31)</cpp:value></cpp:define> <comment type="line">// only high bit of 32 is set</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeScriptableFlags</name>
<block>{
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSUint32</name></type> <name>mFlags</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

    <macro><name>XPCNativeScriptableFlags</name><argument_list>(<argument>JSUint32 flags = 0</argument>)</argument_list></macro> : <macro><name>mFlags</name><argument_list>(<argument>flags</argument>)</argument_list></macro> <block>{}</block>

    <expr_stmt><expr><name>JSUint32</name> <macro><name>GetFlags</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mFlags</name> &amp; ~<name>XPC_WN_SJSFLAGS_MARK_FLAG</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>void</name></type>     <name>SetFlags</name><parameter_list>(<param><decl><type><name>JSUint32</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mFlags</name> = <name>flags</name></expr>;</expr_stmt>}</block></function>

    <expr_stmt><expr><name>operator</name> <macro><name>JSUint32</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>GetFlags</name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <macro><name>XPCNativeScriptableFlags</name><argument_list>(<argument>const XPCNativeScriptableFlags&amp; r</argument>)</argument_list></macro>
        <block>{<expr_stmt><expr><name>mFlags</name> = <call><name><name>r</name>.<name>GetFlags</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>}</block>

    <decl_stmt><decl><type><name>XPCNativeScriptableFlags</name>&amp;</type> <name>operator</name><init>= <expr>(const <name>XPCNativeScriptableFlags</name>&amp; <name>r</name>)
        <block>{<expr><name>mFlags</name> = <call><name><name>r</name>.<name>GetFlags</name></name><argument_list>()</argument_list></call></expr>; <return>return <expr>*<name>this</name></expr>;</return>}</block></expr></init></decl></decl_stmt>

    <function><type><name>void</name></type> <name>Mark</name><parameter_list>()</parameter_list>       <block>{<expr_stmt><expr><name>mFlags</name> |= <name>XPC_WN_SJSFLAGS_MARK_FLAG</name></expr>;</expr_stmt>}</block></function>
    <function><type><name>void</name></type> <name>Unmark</name><parameter_list>()</parameter_list>     <block>{<expr_stmt><expr><name>mFlags</name> &amp;= ~<name>XPC_WN_SJSFLAGS_MARK_FLAG</name></expr>;</expr_stmt>}</block></function>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsMarked</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr>0 != (<name>mFlags</name> &amp; <name>XPC_WN_SJSFLAGS_MARK_FLAG</name>)</expr>;</return>}</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GET_IT</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_IT</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IT</name><parameter_list>(<param><type><name>f_</name></type></param>)</parameter_list></cpp:macro> <cpp:value>const {return 0 != (mFlags &amp; nsIXPCScriptable:: f_ );}</cpp:value></cpp:define>

    <expr_stmt><expr><name>JSBool</name> <macro><name>WantPreCreate</name><argument_list>()</argument_list></macro>                <macro><name>GET_IT</name><argument_list>(<argument>WANT_PRECREATE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantCreate</name><argument_list>()</argument_list></macro>                   <macro><name>GET_IT</name><argument_list>(<argument>WANT_CREATE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantPostCreate</name><argument_list>()</argument_list></macro>               <macro><name>GET_IT</name><argument_list>(<argument>WANT_POSTCREATE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantAddProperty</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_ADDPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantDelProperty</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_DELPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantGetProperty</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_GETPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantSetProperty</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_SETPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantEnumerate</name><argument_list>()</argument_list></macro>                <macro><name>GET_IT</name><argument_list>(<argument>WANT_ENUMERATE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantNewEnumerate</name><argument_list>()</argument_list></macro>             <macro><name>GET_IT</name><argument_list>(<argument>WANT_NEWENUMERATE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantNewResolve</name><argument_list>()</argument_list></macro>               <macro><name>GET_IT</name><argument_list>(<argument>WANT_NEWRESOLVE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantConvert</name><argument_list>()</argument_list></macro>                  <macro><name>GET_IT</name><argument_list>(<argument>WANT_CONVERT</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantFinalize</name><argument_list>()</argument_list></macro>                 <macro><name>GET_IT</name><argument_list>(<argument>WANT_FINALIZE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantCheckAccess</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_CHECKACCESS</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantCall</name><argument_list>()</argument_list></macro>                     <macro><name>GET_IT</name><argument_list>(<argument>WANT_CALL</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantConstruct</name><argument_list>()</argument_list></macro>                <macro><name>GET_IT</name><argument_list>(<argument>WANT_CONSTRUCT</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantHasInstance</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_HASINSTANCE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantTrace</name><argument_list>()</argument_list></macro>                    <macro><name>GET_IT</name><argument_list>(<argument>WANT_TRACE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantEquality</name><argument_list>()</argument_list></macro>                 <macro><name>GET_IT</name><argument_list>(<argument>WANT_EQUALITY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantOuterObject</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_OUTER_OBJECT</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>WantInnerObject</name><argument_list>()</argument_list></macro>              <macro><name>GET_IT</name><argument_list>(<argument>WANT_INNER_OBJECT</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>UseJSStubForAddProperty</name><argument_list>()</argument_list></macro>      <macro><name>GET_IT</name><argument_list>(<argument>USE_JSSTUB_FOR_ADDPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>UseJSStubForDelProperty</name><argument_list>()</argument_list></macro>      <macro><name>GET_IT</name><argument_list>(<argument>USE_JSSTUB_FOR_DELPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>UseJSStubForSetProperty</name><argument_list>()</argument_list></macro>      <macro><name>GET_IT</name><argument_list>(<argument>USE_JSSTUB_FOR_SETPROPERTY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>DontEnumStaticProps</name><argument_list>()</argument_list></macro>          <macro><name>GET_IT</name><argument_list>(<argument>DONT_ENUM_STATIC_PROPS</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>DontEnumQueryInterface</name><argument_list>()</argument_list></macro>       <macro><name>GET_IT</name><argument_list>(<argument>DONT_ENUM_QUERY_INTERFACE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>DontAskInstanceForScriptable</name><argument_list>()</argument_list></macro> <macro><name>GET_IT</name><argument_list>(<argument>DONT_ASK_INSTANCE_FOR_SCRIPTABLE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>ClassInfoInterfacesOnly</name><argument_list>()</argument_list></macro>      <macro><name>GET_IT</name><argument_list>(<argument>CLASSINFO_INTERFACES_ONLY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>AllowPropModsDuringResolve</name><argument_list>()</argument_list></macro>   <macro><name>GET_IT</name><argument_list>(<argument>ALLOW_PROP_MODS_DURING_RESOLVE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>AllowPropModsToPrototype</name><argument_list>()</argument_list></macro>     <macro><name>GET_IT</name><argument_list>(<argument>ALLOW_PROP_MODS_TO_PROTOTYPE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>DontSharePrototype</name><argument_list>()</argument_list></macro>           <macro><name>GET_IT</name><argument_list>(<argument>DONT_SHARE_PROTOTYPE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>DontReflectInterfaceNames</name><argument_list>()</argument_list></macro>    <macro><name>GET_IT</name><argument_list>(<argument>DONT_REFLECT_INTERFACE_NAMES</argument>)</argument_list></macro></expr></expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_IT</name></cpp:undef>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>

<comment type="line">// XPCNativeScriptableShared is used to hold the JSClass and the</comment>
<comment type="line">// associated scriptable flags for XPCWrappedNatives. These are shared across</comment>
<comment type="line">// the runtime and are garbage collected by xpconnect. We *used* to just store</comment>
<comment type="line">// this inside the XPCNativeScriptableInfo (usually owned by instances of</comment>
<comment type="line">// XPCWrappedNativeProto. This had two problems... It was wasteful, and it</comment>
<comment type="line">// was a big problem when wrappers are reparented to different scopes (and</comment>
<comment type="line">// thus different protos (the DOM does this).</comment>

struct <label><name>XPCNativeScriptableSharedJSClass</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSExtendedClass</name>
<block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>interfacesBitmap</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeScriptableShared</name>
<block>{
<label><name>public</name>:</label>
    <expr_stmt><expr>const <name>XPCNativeScriptableFlags</name>&amp; <macro><name>GetFlags</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mFlags</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>PRUint32</name>                        <macro><name>GetInterfacesBitmap</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><name><name>mJSClass</name>.<name>interfacesBitmap</name></name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>JSClass</name>*</type>                        <name>GetJSClass</name><parameter_list>()</parameter_list> <block>{<return>return <expr>&amp;<name><name>mJSClass</name>.<name>base</name></name></expr>;</return>}</block></function>
    <function><type><name>JSClass</name>*</type>                        <name>GetSlimJSClass</name><parameter_list>()</parameter_list>
        <block>{<if>if<condition>(<expr><name>mCanBeSlim</name></expr>)</condition><then> <return>return <expr><call><name>GetJSClass</name><argument_list>()</argument_list></call></expr>;</return></then></if> <return>return <expr><name>nsnull</name></expr>;</return>}</block></function>

    <macro><name>XPCNativeScriptableShared</name><argument_list>(<argument>JSUint32 aFlags</argument>, <argument>char* aName</argument>,
                              <argument>PRUint32 interfacesBitmap</argument>)</argument_list></macro>
        : <expr_stmt><expr><call><name>mFlags</name><argument_list>(<argument><expr><name>aFlags</name></expr></argument>)</argument_list></call></expr>,
          <macro><name>mCanBeSlim</name><argument_list>(<argument>JS_FALSE</argument>)</argument_list></macro>
        <expr><block>{<expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>mJSClass</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mJSClass</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;
         <expr><name><name>mJSClass</name>.<name>base</name>.<name>name</name></name> = <name>aName</name></expr>;  <comment type="line">// take ownership</comment>
         <expr><name><name>mJSClass</name>.<name>interfacesBitmap</name></name> = <name>interfacesBitmap</name></expr>;
         <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>XPCNativeScriptableShared</name></expr></argument>)</argument_list></call></expr>;}</block>

    ~<macro><name>XPCNativeScriptableShared</name><argument_list>()</argument_list></macro>
        <block>{<if>if<condition>(<expr><name><name>mJSClass</name>.<name>base</name>.<name>name</name></name></expr>)</condition><then><expr_stmt><expr><name>nsMemory</name>::<call><name>Free</name><argument_list>(<argument><expr>(<name>void</name>*)<name><name>mJSClass</name>.<name>base</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
         <call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>XPCNativeScriptableShared</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>}</block></decl></decl_stmt>

    <function><type><name>char</name>*</type> <name>TransferNameOwnership</name><parameter_list>()</parameter_list>
        <block>{<decl_stmt><decl><type><name>char</name>*</type> <name>name</name><init>=<expr>(<name>char</name>*)<name><name>mJSClass</name>.<name>base</name>.<name>name</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>mJSClass</name>.<name>base</name>.<name>name</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>name</name></expr>;</return>}</block></function>

    <function_decl><type><name>void</name></type> <name>PopulateJSClass</name><parameter_list>(<param><decl><type><name>JSBool</name></type> <name>isGlobal</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>void</name></type> <name>Mark</name><parameter_list>()</parameter_list>       <block>{<expr_stmt><expr><call><name><name>mFlags</name>.<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>}</block></function>
    <function><type><name>void</name></type> <name>Unmark</name><parameter_list>()</parameter_list>     <block>{<expr_stmt><expr><call><name><name>mFlags</name>.<name>Unmark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>}</block></function>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsMarked</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name><name>mFlags</name>.<name>IsMarked</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCNativeScriptableFlags</name></type> <name>mFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeScriptableSharedJSClass</name></type> <name>mJSClass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>                   <name>mCanBeSlim</name></decl>;</decl_stmt>
};

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeScriptableInfo is used to hold the nsIXPCScriptable state for a</comment>
<comment type="line">// given class or instance.</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCNativeScriptableInfo</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCNativeScriptableInfo</name>*</type>
    <name>Construct</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>isGlobal</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>XPCNativeScriptableCreateInfo</name>*</type> <name>sci</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>nsIXPCScriptable</name>*
    <macro><name>GetCallback</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mCallback</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr>const <name>XPCNativeScriptableFlags</name>&amp;
    <macro><name>GetFlags</name><argument_list>()</argument_list></macro> const      <block>{<return>return <expr><call><name><name>mShared</name>-&gt;<name>GetFlags</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>PRUint32</name>
    <macro><name>GetInterfacesBitmap</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name><name>mShared</name>-&gt;<name>GetInterfacesBitmap</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>JSClass</name>*</type>
    <name>GetJSClass</name><parameter_list>()</parameter_list>          <block>{<return>return <expr><call><name><name>mShared</name>-&gt;<name>GetJSClass</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></function>

    <function><type><name>JSClass</name>*</type>
    <name>GetSlimJSClass</name><parameter_list>()</parameter_list>      <block>{<return>return <expr><call><name><name>mShared</name>-&gt;<name>GetSlimJSClass</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></function>

    <function><type><name>XPCNativeScriptableShared</name>*</type>
    <name>GetScriptableShared</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>mShared</name></expr>;</return>}</block></function>

    <function><type><name>void</name></type>
    <name>SetCallback</name><parameter_list>(<param><decl><type><name>nsIXPCScriptable</name>*</type> <name>s</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mCallback</name> = <name>s</name></expr>;</expr_stmt>}</block></function>
    <decl_stmt><decl><type><name>void</name></type>
    <name>SetCallback</name><argument_list>(<argument><expr><name>already_AddRefed</name>&lt;<name>nsIXPCScriptable</name>&gt; <name>s</name></expr></argument>)</argument_list> <block>{<expr_stmt><expr><name>mCallback</name> = <name>s</name></expr>;</expr_stmt>}</block></decl></decl_stmt>

    <function><type><name>void</name></type>
    <name>SetScriptableShared</name><parameter_list>(<param><decl><type><name>XPCNativeScriptableShared</name>*</type> <name>shared</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mShared</name> = <name>shared</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>void</name></type> <name>Mark</name><parameter_list>()</parameter_list> <block>{<if>if<condition>(<expr><name>mShared</name></expr>)</condition><then> <expr_stmt><expr><call><name><name>mShared</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>}</block></function>

<label><name>protected</name>:</label>
    <expr_stmt><expr><call><name>XPCNativeScriptableInfo</name><argument_list>(<argument><expr><name>nsIXPCScriptable</name>* <name>scriptable</name> = <name>nsnull</name></expr></argument>,
                            <argument><expr><name>XPCNativeScriptableShared</name>* <name>shared</name> = <name>nsnull</name></expr></argument>)</argument_list></call>
        : <call><name>mCallback</name><argument_list>(<argument><expr><name>scriptable</name></expr></argument>)</argument_list></call></expr>, <macro><name>mShared</name><argument_list>(<argument>shared</argument>)</argument_list></macro>
                               <expr><block>{<expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>XPCNativeScriptableInfo</name></expr></argument>)</argument_list></call></expr>;}</block>
<name>public</name>:
    ~<macro><name>XPCNativeScriptableInfo</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>XPCNativeScriptableInfo</name></expr></argument>)</argument_list></call></expr>;}</block>
<name>private</name>:

    <comment type="line">// disable copy ctor and assignment</comment>
    <call><name>XPCNativeScriptableInfo</name><argument_list>(<argument><expr>const <name>XPCNativeScriptableInfo</name>&amp; <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>
    <decl_stmt><decl><type><name>XPCNativeScriptableInfo</name>&amp;</type> <name>operator</name><init>= <expr>(const <name>XPCNativeScriptableInfo</name>&amp; <name>r</name>)</expr></init></decl>;</decl_stmt> <comment type="line">// not implemented</comment>

<label><name>private</name>:</label>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIXPCScriptable</name>&gt;  <name>mCallback</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>XPCNativeScriptableShared</name>*</type>  <name>mShared</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCNativeScriptableCreateInfo is used in creating new wrapper and protos.</comment>
<comment type="line">// it abstracts out the scriptable interface pointer and the flags. After</comment>
<comment type="line">// creation these are factored differently using XPCNativeScriptableInfo.</comment>

<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>XPCNativeScriptableCreateInfo</name>
<block>{
<label><name>public</name>:</label>

    <expr_stmt><expr><call><name>XPCNativeScriptableCreateInfo</name><argument_list>(<argument><expr>const <name>XPCNativeScriptableInfo</name>&amp; <name>si</name></expr></argument>)</argument_list></call>
        : <call><name>mCallback</name><argument_list>(<argument><expr><call><name><name>si</name>.<name>GetCallback</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>mFlags</name><argument_list>(<argument><expr><call><name><name>si</name>.<name>GetFlags</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
          <macro><name>mInterfacesBitmap</name><argument_list>(<argument>si.GetInterfacesBitmap()</argument>)</argument_list></macro> <expr><block>{}</block>

    <macro><name>XPCNativeScriptableCreateInfo</name><argument_list>(<argument>already_AddRefed&lt;nsIXPCScriptable&gt; callback</argument>,
                                  <argument>XPCNativeScriptableFlags flags</argument>,
                                  <argument>PRUint32 interfacesBitmap</argument>)</argument_list></macro>
        : <call><name>mCallback</name><argument_list>(<argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mFlags</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>,
          <macro><name>mInterfacesBitmap</name><argument_list>(<argument>interfacesBitmap</argument>)</argument_list></macro> <expr><block>{}</block>

    <call><name>XPCNativeScriptableCreateInfo</name><argument_list>()</argument_list></call>
        : <call><name>mFlags</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <macro><name>mInterfacesBitmap</name><argument_list>(<argument>0</argument>)</argument_list></macro> <expr><block>{}</block>


    <name>nsIXPCScriptable</name>*
    <macro><name>GetCallback</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mCallback</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr>const <name>XPCNativeScriptableFlags</name>&amp;
    <macro><name>GetFlags</name><argument_list>()</argument_list></macro> const      <block>{<return>return <expr><name>mFlags</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>PRUint32</name>
    <macro><name>GetInterfacesBitmap</name><argument_list>()</argument_list></macro> const     <block>{<return>return <expr><name>mInterfacesBitmap</name></expr>;</return>}</block></expr></expr_stmt>

    <decl_stmt><decl><type><name>void</name></type>
    <name>SetCallback</name><argument_list>(<argument><expr><name>already_AddRefed</name>&lt;<name>nsIXPCScriptable</name>&gt; <name>callback</name></expr></argument>)</argument_list>
        <block>{<expr_stmt><expr><name>mCallback</name> = <name>callback</name></expr>;</expr_stmt>}</block></decl></decl_stmt>

    <function><type><name>void</name></type>
    <name>SetFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XPCNativeScriptableFlags</name>&amp;</type> <name>flags</name></decl></param>)</parameter_list>  <block>{<expr_stmt><expr><name>mFlags</name> = <name>flags</name></expr>;</expr_stmt>}</block></function>

    <function><type><name>void</name></type>
    <name>SetInterfacesBitmap</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>interfacesBitmap</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><name>mInterfacesBitmap</name> = <name>interfacesBitmap</name></expr>;</expr_stmt>}</block></function>

<label><name>private</name>:</label>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIXPCScriptable</name>&gt;  <name>mCallback</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>XPCNativeScriptableFlags</name></type>    <name>mFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type>                    <name>mInterfacesBitmap</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***********************************************/</comment>
<comment type="line">// XPCWrappedNativeProto hold the additional (potentially shared) wrapper data</comment>
<comment type="line">// for XPCWrappedNative whose native objects expose nsIClassInfo.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNKNOWN_OFFSETS</name></cpp:macro> <cpp:value>((QITableEntry*)1)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>XPCWrappedNativeProto</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>XPCWrappedNativeProto</name>*</type>
    <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                 <param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>Scope</name></decl></param>,
                 <param><decl><type><name>nsIClassInfo</name>*</type> <name>ClassInfo</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>XPCNativeScriptableCreateInfo</name>*</type> <name>ScriptableCreateInfo</name></decl></param>,
                 <param><decl><type><name>JSBool</name></type> <name>ForceNoSharing</name></decl></param>,
                 <param><decl><type><name>JSBool</name></type> <name>isGlobal</name></decl></param>,
                 <param><decl><type><name>QITableEntry</name>*</type> <name>offsets</name> <init>= <expr><name>UNKNOWN_OFFSETS</name></expr></init></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>XPCWrappedNativeScope</name>*
    <macro><name>GetScope</name><argument_list>()</argument_list></macro>   const <block>{<return>return <expr><name>mScope</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCJSRuntime</name>*
    <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name><name>mScope</name>-&gt;<name>GetRuntime</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSObject</name>*
    <macro><name>GetJSProtoObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSProtoObject</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>nsIClassInfo</name>*
    <macro><name>GetClassInfo</name><argument_list>()</argument_list></macro>     const <block>{<return>return <expr><name>mClassInfo</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCNativeSet</name>*
    <macro><name>GetSet</name><argument_list>()</argument_list></macro>           const <block>{<return>return <expr><name>mSet</name></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>XPCNativeScriptableInfo</name>*</type>
    <name>GetScriptableInfo</name><parameter_list>()</parameter_list>   <block>{<return>return <expr><name>mScriptableInfo</name></expr>;</return>}</block></function>

    <function><type><name>void</name>**</type>
    <name>GetSecurityInfoAddr</name><parameter_list>()</parameter_list> <block>{<return>return <expr>&amp;<name>mSecurityInfo</name></expr>;</return>}</block></function>

    <expr_stmt><expr><name>JSUint32</name>
    <macro><name>GetClassInfoFlags</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mClassInfoFlags</name></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>QITableEntry</name>*</type>
    <name>GetOffsets</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>InitedOffsets</name><argument_list>()</argument_list></call> ? <name>mOffsets</name> : <name>nsnull</name></expr>;</return>
    }</block></function>
    <function><type><name>QITableEntry</name>*</type>
    <name>GetOffsetsMasked</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mOffsets</name></expr>;</return>
    }</block></function>
    <function><type><name>void</name></type>
    <name>CacheOffsets</name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>identity</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr>static <call><name>NS_DEFINE_IID</name><argument_list>(<argument><expr><name>kThisPtrOffsetsSID</name></expr></argument>, <argument><expr><name>NS_THISPTROFFSETS_SID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <if>if<condition>(<expr><call><name>InitedOffsets</name><argument_list>()</argument_list></call> &amp;&amp; <name>mOffsets</name></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>QITableEntry</name>*</type> <name>offsets</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>identity</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><name>kThisPtrOffsetsSID</name></expr></argument>, <argument><expr>(<name>void</name>**)&amp;<name>offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>offsets</name> == <name>mOffsets</name></expr></argument>,
                         <argument><expr>"We can't deal with objects that have the same "
                         "classinfo but different offset tables."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if<condition>(<expr>!<call><name>InitedOffsets</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <if>if<condition>(<expr><name>mClassInfoFlags</name> &amp; <name>nsIClassInfo</name>::<name>CONTENT_NODE</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>identity</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><name>kThisPtrOffsetsSID</name></expr></argument>, <argument><expr>(<name>void</name>**)&amp;<name>mOffsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>mOffsets</name> = <name>nsnull</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GET_IT</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_IT</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IT</name><parameter_list>(<param><type><name>f_</name></type></param>)</parameter_list></cpp:macro> <cpp:value>const {return !!(mClassInfoFlags &amp; nsIClassInfo:: f_ );}</cpp:value></cpp:define>

    <expr_stmt><expr><name>JSBool</name> <macro><name>ClassIsSingleton</name><argument_list>()</argument_list></macro>           <macro><name>GET_IT</name><argument_list>(<argument>SINGLETON</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>ClassIsThreadSafe</name><argument_list>()</argument_list></macro>          <macro><name>GET_IT</name><argument_list>(<argument>THREADSAFE</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>ClassIsMainThreadOnly</name><argument_list>()</argument_list></macro>      <macro><name>GET_IT</name><argument_list>(<argument>MAIN_THREAD_ONLY</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>ClassIsDOMObject</name><argument_list>()</argument_list></macro>           <macro><name>GET_IT</name><argument_list>(<argument>DOM_OBJECT</argument>)</argument_list></macro>
    <name>JSBool</name> <macro><name>ClassIsPluginObject</name><argument_list>()</argument_list></macro>        <macro><name>GET_IT</name><argument_list>(<argument>PLUGIN_OBJECT</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_IT</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_PROTO_DONT_SHARE</name></cpp:macro> <cpp:value>JS_BIT(31)</cpp:value></cpp:define> <comment type="line">// only high bit of 32 is set</comment>

    <name>JSBool</name>
    <macro><name>IsShared</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr>!(<name>mClassInfoFlags</name> &amp; <name>XPC_PROTO_DONT_SHARE</name>)</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCLock</name>* <macro><name>GetLock</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><call><name>ClassIsThreadSafe</name><argument_list>()</argument_list></call> ? <call><name>GetRuntime</name><argument_list>()</argument_list></call>-&gt;<call><name>GetMapLock</name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>SetScriptableInfo</name><parameter_list>(<param><decl><type><name>XPCNativeScriptableInfo</name>*</type> <name>si</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mScriptableInfo</name></expr></argument>, <argument><expr>"leak here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>mScriptableInfo</name> = <name>si</name></expr>;</expr_stmt>}</block></function>

    <function_decl><type><name>void</name></type> <name>JSProtoObjectFinalized</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>SystemIsBeingShutDown</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>DebugDump</name><parameter_list>(<param><decl><type><name>PRInt16</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>
    <block>{
        <if>if<condition>(<expr><name>mJSProtoObject</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>mJSProtoObject</name></expr></argument>,
                                  <argument><expr>"XPCWrappedNativeProto::mJSProtoObject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if<condition>(<expr><name>mScriptableInfo</name> &amp;&amp; <call><name>JS_IsGCMarkingTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mScriptableInfo</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="line">// NOP. This is just here to make the AutoMarkingPtr code compile.</comment>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>AutoTrace</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>

    <comment type="line">// Yes, we *do* need to mark the mScriptableInfo in both cases.</comment>
    <expr_stmt><expr><name>void</name> <macro><name>Mark</name><argument_list>()</argument_list></macro> const
        <block>{<expr><call><name><name>mSet</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>; 
         <if>if<condition>(<expr><name>mScriptableInfo</name></expr>)</condition><then> <expr_stmt><expr><call><name><name>mScriptableInfo</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>}</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name>void</name> <macro><name>ASSERT_SetNotMarked</name><argument_list>()</argument_list></macro> const <block>{<expr><call><name><name>mSet</name>-&gt;<name>ASSERT_NotMarked</name></name><argument_list>()</argument_list></call></expr>;}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    ~<call><name>XPCWrappedNativeProto</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>protected</name>:</label>
    <comment type="line">// disable copy ctor and assignment</comment>
    <expr_stmt><expr><call><name>XPCWrappedNativeProto</name><argument_list>(<argument><expr>const <name>XPCWrappedNativeProto</name>&amp; <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>
    <decl_stmt><decl><type><name>XPCWrappedNativeProto</name>&amp;</type> <name>operator</name><init>= <expr>(const <name>XPCWrappedNativeProto</name>&amp; <name>r</name>)</expr></init></decl>;</decl_stmt> <comment type="line">// not implemented</comment>

    <comment type="line">// hide ctor</comment>
    <macro><name>XPCWrappedNativeProto</name><argument_list>(<argument>XPCWrappedNativeScope* Scope</argument>,
                          <argument>nsIClassInfo* ClassInfo</argument>,
                          <argument>PRUint32 ClassInfoFlags</argument>,
                          <argument>XPCNativeSet* Set</argument>,
                          <argument>QITableEntry* offsets</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <function_decl><type><name>JSBool</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>isGlobal</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>XPCNativeScriptableCreateInfo</name>*</type> <name>scriptableCreateInfo</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_xpc_hacker</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PRInt32</name></type> <name>gDEBUG_LiveProtoCount</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>private</name>:</label>
    <function><type><name>PRBool</name></type>
    <name>InitedOffsets</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mOffsets</name> != <name>UNKNOWN_OFFSETS</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><name>XPCWrappedNativeScope</name>*</type>   <name>mScope</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                <name>mJSProtoObject</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIClassInfo</name>&gt;   <name>mClassInfo</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type>                 <name>mClassInfoFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeSet</name>*</type>            <name>mSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>*</type>                    <name>mSecurityInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeScriptableInfo</name>*</type> <name>mScriptableInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QITableEntry</name>*</type>            <name>mOffsets</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type> <name>ConstructSlimWrapper</name><parameter_list>(<param><decl><type><name>XPCCallContext</name> &amp;</type><name>ccx</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>p</name></decl></param>,
                                   <param><decl><type><name>nsWrapperCache</name> *</type><name>cache</name></decl></param>,
                                   <param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>xpcScope</name></decl></param>,
                                   <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type> <name>MorphSlimWrapper</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>XPCWrappedNativeProto</name>*</type>
<name>GetSlimWrapperProto</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>const <name>js</name>::<name>Value</name> &amp;<name>v</name> = <call><name><name>obj</name>-&gt;<name>getSlot</name></name><argument_list>(<argument><expr><call><name>JSSLOT_START</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>static_cast</name>&lt;<name>XPCWrappedNativeProto</name>*&gt;(<call><name><name>v</name>.<name>asPrivate</name></name><argument_list>()</argument_list></call>)</expr>;</return>
}</block></function>


<comment type="block">/***********************************************/</comment>
<comment type="line">// XPCWrappedNativeTearOff represents the info needed to make calls to one</comment>
<comment type="line">// interface on the underlying native object of a XPCWrappedNative.</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCWrappedNativeTearOff</name>
<block>{
<label><name>public</name>:</label>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsAvailable</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mInterface</name> == <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsReserved</name><argument_list>()</argument_list></macro>  const <block>{<return>return <expr><name>mInterface</name> == (<name>XPCNativeInterface</name>*)1</expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsValid</name><argument_list>()</argument_list></macro>     const <block>{<return>return <expr>!<call><name>IsAvailable</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>IsReserved</name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>void</name></type>   <name>SetReserved</name><parameter_list>()</parameter_list>       <block>{<expr_stmt><expr><name>mInterface</name> = (<name>XPCNativeInterface</name>*)1</expr>;</expr_stmt>}</block></function>

    <expr_stmt><expr><name>XPCNativeInterface</name>* <macro><name>GetInterface</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mInterface</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsISupports</name>*        <macro><name>GetNative</name><argument_list>()</argument_list></macro>    const <block>{<return>return <expr><name>mNative</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>JSObject</name>*           <macro><name>GetJSObject</name><argument_list>()</argument_list></macro>  const</expr>;</expr_stmt>
    <function><type><name>void</name></type> <name>SetInterface</name><parameter_list>(<param><decl><type><name>XPCNativeInterface</name>*</type>  <name>Interface</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><name>mInterface</name> = <name>Interface</name></expr>;</expr_stmt>}</block></function>
    <function><type><name>void</name></type> <name>SetNative</name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type>  <name>Native</name></decl></param>)</parameter_list>              <block>{<expr_stmt><expr><name>mNative</name> = <name>Native</name></expr>;</expr_stmt>}</block></function>
    <function_decl><type><name>void</name></type> <name>SetJSObject</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type>  <name>JSObj</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>void</name></type> <name>JSObjectFinalized</name><parameter_list>()</parameter_list> <block>{<expr_stmt><expr><call><name>SetJSObject</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></function>

    <expr_stmt><expr><call><name>XPCWrappedNativeTearOff</name><argument_list>()</argument_list></call>
        : <call><name>mInterface</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mNative</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>, <macro><name>mJSObject</name><argument_list>(<argument>nsnull</argument>)</argument_list></macro> <expr><block>{}</block>
    ~<call><name>XPCWrappedNativeTearOff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// NOP. This is just here to make the AutoMarkingPtr code compile.</comment>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>AutoTrace</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list> <block>{}</block></function>

    <function><type><name>void</name></type> <name>Mark</name><parameter_list>()</parameter_list>       <block>{<expr_stmt><expr><name>mJSObject</name> = <call>(<name>JSObject</name>*)<argument_list>(<argument><expr>((<name>jsword</name>)<name>mJSObject</name>) | 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></function>
    <function><type><name>void</name></type> <name>Unmark</name><parameter_list>()</parameter_list>     <block>{<expr_stmt><expr><name>mJSObject</name> = <call>(<name>JSObject</name>*)<argument_list>(<argument><expr>((<name>jsword</name>)<name>mJSObject</name>) &amp; ~1</expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></function>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsMarked</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call>(<name>JSBool</name>)<argument_list>(<argument><expr>((<name>jsword</name>)<name>mJSObject</name>) &amp; 1</expr></argument>)</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>
    <enum>enum <name>JSObject_flags</name>
    <block>{
        <decl><name>IDISPATCH_BIT</name> <init>= <expr>2</expr></init></decl>,
        <decl><name>JSOBJECT_MASK</name> <init>= <expr>3</expr></init></decl>
    }</block>;</enum>
    <function_decl><type><name>void</name></type>                <name>SetIDispatch</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>JSBool</name>              <macro><name>IsIDispatch</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
    <expr_stmt><expr><name>XPCDispInterface</name>*   <macro><name>GetIDispatchInfo</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCWrappedNativeTearOff</name><argument_list>(<argument><expr>const <name>XPCWrappedNativeTearOff</name>&amp; <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>
    <decl_stmt><decl><type><name>XPCWrappedNativeTearOff</name>&amp;</type> <name>operator</name><init>= <expr>(const <name>XPCWrappedNativeTearOff</name>&amp; <name>r</name>)</expr></init></decl>;</decl_stmt> <comment type="line">// not implemented</comment>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCNativeInterface</name>*</type> <name>mInterface</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsISupports</name>*</type>        <name>mNative</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type>           <name>mJSObject</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***********************************************/</comment>
<comment type="line">// XPCWrappedNativeTearOffChunk is a collections of XPCWrappedNativeTearOff</comment>
<comment type="line">// objects. It lets us allocate a set of XPCWrappedNativeTearOff objects and</comment>
<comment type="line">// link the sets - rather than only having the option of linking single</comment>
<comment type="line">// XPCWrappedNativeTearOff objects.</comment>
<comment type="line">//</comment>
<comment type="line">// The value of XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK can be tuned at buildtime</comment>
<comment type="line">// to balance between the code of allocations of additional chunks and the waste</comment>
<comment type="line">// of space for ununsed XPCWrappedNativeTearOff objects.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>XPCWrappedNativeTearOffChunk</name>
<block>{
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>XPCWrappedNative</name></decl>;</decl_stmt>
<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCWrappedNativeTearOffChunk</name><argument_list>()</argument_list></call> : <macro><name>mNextChunk</name><argument_list>(<argument>nsnull</argument>)</argument_list></macro> <block>{}</block>
    ~<macro><name>XPCWrappedNativeTearOffChunk</name><argument_list>()</argument_list></macro> <block>{<expr><name>delete</name> <name>mNextChunk</name></expr>;}</block>

<name>private</name>:
    <name>XPCWrappedNativeTearOff</name> <name><name>mTearOffs</name><index>[<expr><name>XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK</name></expr>]</index></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeTearOffChunk</name>*</type> <name>mNextChunk</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>void</name> *</type><name>xpc_GetJSPrivate</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCWrappedNative the wrapper around one instance of a native xpcom object</comment>
<comment type="line">// to be used from JavaScript.</comment>

<expr_stmt><expr><name>class</name> <name>XPCWrappedNative</name> : <name>public</name> <name>nsIXPConnectWrappedNative</name>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIXPCONNECTJSOBJECTHOLDER</name>
    <name>NS_DECL_NSIXPCONNECTWRAPPEDNATIVE</name>
    <comment type="line">// No need to unlink the JS objects, if the XPCWrappedNative will be cycle</comment>
    <comment type="line">// collected then its mFlatJSObject will be cycle collected too and</comment>
    <comment type="line">// finalization of the mFlatJSObject will unlink the js objects (see</comment>
    <comment type="line">// XPC_WN_NoHelper_Finalize and FlatJSObjectFinalized).</comment>
    <comment type="line">// We also rely on NS_DECL_CYCLE_COLLECTION_CLASS_NO_UNLINK having empty</comment>
    <comment type="line">// Root/Unroot methods, to avoid root/unrooting the JS objects from</comment>
    <comment type="line">// addrefing/releasing the XPCWrappedNative during unlinking, which would</comment>
    <comment type="line">// make the JS objects uncollectable to the JS GC.</comment>
    <name>class</name> <name>NS_CYCLE_COLLECTION_INNERCLASS</name>
     : <name>public</name> <name>nsXPCOMCycleCollectionParticipant</name>
    <block>{
      <macro><name>NS_DECL_CYCLE_COLLECTION_CLASS_BODY_NO_UNLINK</name><argument_list>(<argument>XPCWrappedNative</argument>,
                                                    <argument>XPCWrappedNative</argument>)</argument_list></macro>
      <expr><name>NS_IMETHOD</name> <call><name>RootAndUnlinkJSObjects</name><argument_list>(<argument><expr><name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;
      <expr><name>NS_IMETHOD</name> <macro><name>Unlink</name><argument_list>(<argument>void *p</argument>)</argument_list></macro> <block>{ <return>return <expr><name>NS_OK</name></expr>;</return></block></expr> }</block>
      <name>NS_IMETHOD</name> <macro><name>Unroot</name><argument_list>(<argument>void *p</argument>)</argument_list></macro> <block>{ <return>return <expr><name>NS_OK</name></expr>;</return></block></expr> }</block></expr></expr_stmt>
    };
    <decl_stmt><decl><type><name>NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE</name></type>
    <name>NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB</name><argument_list>(<argument><expr><name>XPCWrappedNative</name></expr></argument>)</argument_list>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
    <name>nsIPrincipal</name>* <name>GetObjectPrincipal</name><argument_list>()</argument_list> const</decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>JSBool</name>
    <macro><name>IsValid</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>nsnull</name> != <name>mFlatJSObject</name></expr>;</return>}</block></expr></expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_SCOPE_WORD</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>((jsword)(s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_SCOPE_MASK</name></cpp:macro>      <cpp:value>((jsword)0x3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_SCOPE_TAG</name></cpp:macro>       <cpp:value>((jsword)0x1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPC_WRAPPER_EXPIRED</name></cpp:macro> <cpp:value>((jsword)0x2)</cpp:value></cpp:define>

    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSBool</name></type>
    <name>IsTaggedScope</name><parameter_list>(<param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>s</name></decl></param>)</parameter_list>
        <block>{<return>return <expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp; <name>XPC_SCOPE_TAG</name></expr>;</return>}</block></function>

    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>XPCWrappedNativeScope</name>*</type>
    <name>TagScope</name><parameter_list>(<param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>s</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>IsTaggedScope</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad pointer!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <return>return <expr><call>(<name>XPCWrappedNativeScope</name>*)<argument_list>(<argument><expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> | <name>XPC_SCOPE_TAG</name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>

    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>XPCWrappedNativeScope</name>*</type>
    <name>UnTagScope</name><parameter_list>(<param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>s</name></decl></param>)</parameter_list>
        <block>{<return>return <expr><call>(<name>XPCWrappedNativeScope</name>*)<argument_list>(<argument><expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp; ~<name>XPC_SCOPE_TAG</name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>

    <expr_stmt><expr>inline <name>JSBool</name>
    <macro><name>IsWrapperExpired</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>mMaybeScope</name></expr></argument>)</argument_list></call> &amp; <name>XPC_WRAPPER_EXPIRED</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name>
    <macro><name>HasProto</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr>!<call><name>IsTaggedScope</name><argument_list>(<argument><expr><name>mMaybeScope</name></expr></argument>)</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCWrappedNativeProto</name>*
    <macro><name>GetProto</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><call><name>HasProto</name><argument_list>()</argument_list></call> ?
         <call>(<name>XPCWrappedNativeProto</name>*)
         <argument_list>(<argument><expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>mMaybeProto</name></expr></argument>)</argument_list></call> &amp; ~<name>XPC_SCOPE_MASK</name></expr></argument>)</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>void</name></type>
    <name>SetProto</name><parameter_list>(<param><decl><type><name>XPCWrappedNativeProto</name>*</type> <name>p</name></decl></param>)</parameter_list>
        <block>{<expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>IsWrapperExpired</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"bad ptr!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>mMaybeProto</name> = <name>p</name></expr>;</expr_stmt>}</block></function>

    <expr_stmt><expr><name>XPCWrappedNativeScope</name>*
    <macro><name>GetScope</name><argument_list>()</argument_list></macro> const
        <block>{<return>return <expr><call><name>GetProto</name><argument_list>()</argument_list></call> ? <call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>GetScope</name><argument_list>()</argument_list></call> :
         <call>(<name>XPCWrappedNativeScope</name>*)
         <argument_list>(<argument><expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>mMaybeScope</name></expr></argument>)</argument_list></call> &amp; ~<name>XPC_SCOPE_MASK</name></expr></argument>)</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>nsISupports</name>*
    <macro><name>GetIdentityObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mIdentity</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSObject</name>*
    <macro><name>GetFlatJSObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mFlatJSObject</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCLock</name>*
    <macro><name>GetLock</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>IsValid</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>HasProto</name><argument_list>()</argument_list></call> ?
                                <call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>GetLock</name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCNativeSet</name>*
    <macro><name>GetSet</name><argument_list>()</argument_list></macro> const <block>{<expr><name>XPCAutoLock</name> <call><name>al</name><argument_list>(<argument><expr><call><name>GetLock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><name>mSet</name></expr>;</return>}</block></expr></expr_stmt>

<label><name>private</name>:</label>
    <function><type><name>void</name></type>
    <name>SetSet</name><parameter_list>(<param><decl><type><name>XPCNativeSet</name>*</type> <name>set</name></decl></param>)</parameter_list> <block>{<decl_stmt><decl><type><name>XPCAutoLock</name></type> <name>al</name><argument_list>(<argument><expr><call><name>GetLock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt> <expr_stmt><expr><name>mSet</name> = <name>set</name></expr>;</expr_stmt>}</block></function>

    <function><type><specifier>inline</specifier> <name>void</name></type>
    <name>ExpireWrapper</name><parameter_list>()</parameter_list>
        <block>{<expr_stmt><expr><name>mMaybeScope</name> = <call>(<name>XPCWrappedNativeScope</name>*)
                       <argument_list>(<argument><expr><call><name>XPC_SCOPE_WORD</name><argument_list>(<argument><expr><name>mMaybeScope</name></expr></argument>)</argument_list></call> | <name>XPC_WRAPPER_EXPIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></function>

<label><name>public</name>:</label>

    <expr_stmt><expr><name>XPCNativeScriptableInfo</name>*
    <macro><name>GetScriptableInfo</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mScriptableInfo</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>nsIXPCScriptable</name>*      <comment type="line">// call this wrong and you deserve to crash</comment>
    <macro><name>GetScriptableCallback</name><argument_list>()</argument_list></macro> const  <block>{<return>return <expr><call><name><name>mScriptableInfo</name>-&gt;<name>GetCallback</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>void</name>**</type>
    <name>GetSecurityInfoAddr</name><parameter_list>()</parameter_list> <block>{<return>return <expr><call><name>HasProto</name><argument_list>()</argument_list></call> ?
                                   <call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>GetSecurityInfoAddr</name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></function>

    <expr_stmt><expr><name>nsIClassInfo</name>*
    <macro><name>GetClassInfo</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>IsValid</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>HasProto</name><argument_list>()</argument_list></call> ?
                            <call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>GetClassInfo</name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name>
    <macro><name>HasSharedProto</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>IsValid</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>HasProto</name><argument_list>()</argument_list></call> &amp;&amp;
                            <call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>IsShared</name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name>
    <macro><name>HasMutatedSet</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>IsValid</name><argument_list>()</argument_list></call> &amp;&amp;
                                  (!<call><name>HasProto</name><argument_list>()</argument_list></call> ||
                                   <call><name>GetSet</name><argument_list>()</argument_list></call> != <call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>GetSet</name><argument_list>()</argument_list></call>)</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>XPCJSRuntime</name>*
    <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> const <block>{<expr><name>XPCWrappedNativeScope</name>* <name>scope</name> = <call><name>GetScope</name><argument_list>()</argument_list></call></expr>;
                        <return>return <expr><name>scope</name> ? <call><name><name>scope</name>-&gt;<name>GetRuntime</name></name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <comment type="block">/**
     * If Object has a nsWrapperCache it should be passed in. If a cache is
     * passed in then cache-&gt;GetWrapper() must be null.
     */</comment>
    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>GetNewOrUsed</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                 <param><decl><type><name>nsISupports</name>*</type> <name>Object</name></decl></param>,
                 <param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>Scope</name></decl></param>,
                 <param><decl><type><name>XPCNativeInterface</name>*</type> <name>Interface</name></decl></param>,
                 <param><decl><type><name>nsWrapperCache</name>*</type> <name>cache</name></decl></param>,
                 <param><decl><type><name>JSBool</name></type> <name>isGlobal</name></decl></param>,
                 <param><decl><type><name>XPCWrappedNative</name>**</type> <name>wrapper</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>Morph</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
          <param><decl><type><name>JSObject</name>*</type> <name>existingJSObject</name></decl></param>,
          <param><decl><type><name>XPCNativeInterface</name>*</type> <name>Interface</name></decl></param>,
          <param><decl><type><name>nsWrapperCache</name> *</type><name>cache</name></decl></param>,
          <param><decl><type><name>XPCWrappedNative</name>**</type> <name>resultWrapper</name></decl></param>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>GetUsedOnly</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                <param><decl><type><name>nsISupports</name>*</type> <name>Object</name></decl></param>,
                <param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>Scope</name></decl></param>,
                <param><decl><type><name>XPCNativeInterface</name>*</type> <name>Interface</name></decl></param>,
                <param><decl><type><name>XPCWrappedNative</name>**</type> <name>wrapper</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// If pobj2 is not null and *pobj2 is not null after the call then *pobj2</comment>
    <comment type="line">// points to an object for which IS_SLIM_WRAPPER_OBJECT is true.</comment>
    <function_decl><type><specifier>static</specifier> <name>XPCWrappedNative</name>*</type>
    <name>GetWrappedNativeOfJSObject</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>,
                               <param><decl><type><name>JSObject</name>*</type> <name>funobj</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>,
                               <name>JSObject</name>** <name>pobj2</name> = <name>nsnull</name>,
                               <name>XPCWrappedNativeTearOff</name>** <name>pTearOff</name> = <name>nsnull</name>)</parameter_list>;</function_decl>
    <function><type><specifier>static</specifier> <name>XPCWrappedNative</name>*</type>
    <name>GetAndMorphWrappedNativeOfJSObject</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj2</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XPCWrappedNative</name>*</type> <name>wrapper</name> <init>=
            <expr><call><name>GetWrappedNativeOfJSObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>&amp;<name>obj2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><name>wrapper</name> || !<name>obj2</name></expr>)</condition><then>
            <return>return <expr><name>wrapper</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IS_SLIM_WRAPPER</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr>"Hmm, someone changed GetWrappedNativeOfJSObject?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SLIM_LOG_WILL_MORPH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>MorphSlimWrapper</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>)</argument_list></call> ?
               (<name>XPCWrappedNative</name>*)<call><name>xpc_GetJSPrivate</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call> :
               <name>nsnull</name></expr>;</return>
    }</block></function>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>ReparentWrapperIfFound</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                           <param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>aOldScope</name></decl></param>,
                           <param><decl><type><name>XPCWrappedNativeScope</name>*</type> <name>aNewScope</name></decl></param>,
                           <param><decl><type><name>JSObject</name>*</type> <name>aNewParent</name></decl></param>,
                           <param><decl><type><name>nsISupports</name>*</type> <name>aCOMObj</name></decl></param>,
                           <param><decl><type><name>XPCWrappedNative</name>**</type> <name>aWrapper</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>FlatJSObjectFinalized</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>SystemIsBeingShutDown</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_DETECT_LEADING_UPPERCASE_ACCESS_ERRORS</name></cpp:ifdef>
    <comment type="line">// This will try to find a member that is of the form "camelCased"</comment>
    <comment type="line">// but was accessed from JS using "CamelCased". This is here to catch</comment>
    <comment type="line">// mistakes caused by the confusion magnet that JS methods are by</comment>
    <comment type="line">// convention 'foo' while C++ members are by convention 'Foo'.</comment>
    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>HandlePossibleNameCaseError</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                <param><decl><type><name>XPCNativeSet</name>*</type> <name>set</name></decl></param>,
                                <param><decl><type><name>XPCNativeInterface</name>*</type> <name>iface</name></decl></param>,
                                <param><decl><type><name>jsid</name></type> <name>name</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>void</name></type>
    <name>HandlePossibleNameCaseError</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                                <param><decl><type><name>XPCNativeSet</name>*</type> <name>set</name></decl></param>,
                                <param><decl><type><name>XPCNativeInterface</name>*</type> <name>iface</name></decl></param>,
                                <param><decl><type><name>jsid</name></type> <name>name</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>HANDLE_POSSIBLE_NAME_CASE_ERROR</name><parameter_list>(<param><type><name>context</name></type></param>, <param><type><name>set</name></type></param>, <param><type><name>iface</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>XPCWrappedNative::HandlePossibleNameCaseError(context, set, iface, name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>HANDLE_POSSIBLE_NAME_CASE_ERROR</name><parameter_list>(<param><type><name>context</name></type></param>, <param><type><name>set</name></type></param>, <param><type><name>iface</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <enum>enum <name>CallMode</name> <block>{<decl><name>CALL_METHOD</name></decl>, <decl><name>CALL_GETTER</name></decl>, <decl><name>CALL_SETTER</name></decl>}</block>;</enum>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>CallMethod</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                             <param><decl><type><name>CallMode</name></type> <name>mode</name> <init>= <expr><name>CALL_METHOD</name></expr></init></decl></param>)</parameter_list>;</function_decl>

    <function><type><specifier>static</specifier> <name>JSBool</name></type> <name>GetAttribute</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>
        <block>{<return>return <expr><call><name>CallMethod</name><argument_list>(<argument><expr><name>ccx</name></expr></argument>, <argument><expr><name>CALL_GETTER</name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>

    <function><type><specifier>static</specifier> <name>JSBool</name></type> <name>SetAttribute</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>
        <block>{<return>return <expr><call><name>CallMethod</name><argument_list>(<argument><expr><name>ccx</name></expr></argument>, <argument><expr><name>CALL_SETTER</name></expr></argument>)</argument_list></call></expr>;</return>}</block></function>

    <function_decl><type><specifier>inline</specifier> <name>JSBool</name></type> <name>HasInterfaceNoQI</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>iid</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>XPCWrappedNativeTearOff</name>*</type> <name>LocateTearOff</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                           <param><decl><type><name>XPCNativeInterface</name>*</type> <name>aInterface</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>XPCWrappedNativeTearOff</name>*</type> <name>FindTearOff</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                         <param><decl><type><name>XPCNativeInterface</name>*</type> <name>aInterface</name></decl></param>,
                                         <param><decl><type><name>JSBool</name></type> <name>needJSObject</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl></param>,
                                         <name>nsresult</name>* <name>pError</name> = <name>nsnull</name>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>void</name> <macro><name>Mark</name><argument_list>()</argument_list></macro> const
    <block>{
        <expr><call><name><name>mSet</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>;
        <if>if<condition>(<expr><name>mScriptableInfo</name></expr>)</condition><then> <expr_stmt><expr><call><name><name>mScriptableInfo</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if></block></expr></expr_stmt>
        <if>if<condition>(<expr><call><name>HasProto</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>Mark</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }

    <comment type="line">// Yes, we *do* need to mark the mScriptableInfo in both cases.</comment>
    inline <function><type><name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>
    <block>{
        <if>if<condition>(<expr><name>mScriptableInfo</name> &amp;&amp; <call><name>JS_IsGCMarkingTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mScriptableInfo</name>-&gt;<name>Mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>HasProto</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>TraceJS</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>wrapper</name> <init>= <expr><call><name>GetWrapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><name>wrapper</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>wrapper</name></expr></argument>, <argument><expr>"XPCWrappedNative::mWrapper"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>TraceOtherWrapper</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>void</name></type> <name>AutoTrace</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// If this got called, we're being kept alive by someone who really</comment>
        <comment type="line">// needs us alive and whole.  Do not let our mFlatJSObject go away.</comment>
        <comment type="line">// This is the only time we should be tracing our mFlatJSObject,</comment>
        <comment type="line">// normally somebody else is doing that. Be careful not to trace the</comment>
        <comment type="line">// bogus INVALID_OBJECT value we can have during init, though.</comment>
        <if>if<condition>(<expr><name>mFlatJSObject</name> &amp;&amp; <name>mFlatJSObject</name> != <name>INVALID_OBJECT</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>mFlatJSObject</name></expr></argument>,
                                  <argument><expr>"XPCWrappedNative::mFlatJSObject"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name>void</name> <macro><name>ASSERT_SetsNotMarked</name><argument_list>()</argument_list></macro> const
        <block>{<expr><call><name><name>mSet</name>-&gt;<name>ASSERT_NotMarked</name></name><argument_list>()</argument_list></call></expr>;
         <if>if<condition>(<expr><call><name>HasProto</name><argument_list>()</argument_list></call></expr>)</condition><then><block>{<expr_stmt><expr><call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>ASSERT_SetNotMarked</name><argument_list>()</argument_list></call></expr>;</expr_stmt><expr_stmt/></block></then></if>}</block></expr></expr_stmt>}

    int <macro><name>DEBUG_CountOfTearoffChunks</name><argument_list>()</argument_list></macro> <expr_stmt><expr>const
        <block>{<expr><name>int</name> <name>i</name> = 0</expr>; <expr>const <name>XPCWrappedNativeTearOffChunk</name>* <name>to</name></expr>;
         <for>for(<init><expr><name>to</name> = &amp;<name>mFirstChunk</name></expr>;</init> <condition><expr><name>to</name></expr>;</condition> <incr><expr><name>to</name> = <name><name>to</name>-&gt;<name>mNextChunk</name></name></expr></incr>) <block>{<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt><expr_stmt/></block></for>}</block></expr></expr_stmt> <return>return <expr><name>i</name></expr>;</return>}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    inline <function_decl><type><name>void</name></type> <name>SweepTearOffs</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// Returns a string that shuld be free'd using JS_smprintf_free (or null).</comment>
    <decl_stmt><decl><type><name>char</name>*</type> <name>ToString</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>,
                   <argument><expr><name>XPCWrappedNativeTearOff</name>* <name>to</name> = <name>nsnull</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GatherProtoScriptableCreateInfo</name><parameter_list>(
                        <param><decl><type><name>nsIClassInfo</name>*</type> <name>classInfo</name></decl></param>,
                        <param><decl><type><name>XPCNativeScriptableCreateInfo</name>&amp;</type> <name>sciProto</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>JSBool</name> <macro><name>HasExternalReference</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mRefCnt</name> &gt; 1</expr>;</return>}</block></expr></expr_stmt>

    <function><type><name>JSBool</name></type> <name>NeedsChromeWrapper</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>!!(<name>mWrapperWord</name> &amp; <name>CHROME_ONLY</name>)</expr>;</return> }</block></function>
    <function><type><name>void</name></type> <name>SetNeedsChromeWrapper</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mWrapperWord</name> |= <name>CHROME_ONLY</name></expr>;</expr_stmt> }</block></function>
    <function><type><name>JSBool</name></type> <name>IsDoubleWrapper</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>!!(<name>mWrapperWord</name> &amp; <name>DOUBLE_WRAPPER</name>)</expr>;</return> }</block></function>
    <function><type><name>void</name></type> <name>SetIsDoubleWrapper</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mWrapperWord</name> |= <name>DOUBLE_WRAPPER</name></expr>;</expr_stmt> }</block></function>

    <function><type><name>JSObject</name>*</type> <name>GetWrapper</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call>(<name>JSObject</name> *) <argument_list>(<argument><expr><name>mWrapperWord</name> &amp; <name>FLAG_MASK</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    <function><type><name>void</name></type> <name>SetWrapper</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>needsChrome</name> <init>= <expr><call><name>NeedsChromeWrapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSBool</name></type> <name>doubleWrapper</name> <init>= <expr><call><name>IsDoubleWrapper</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>mWrapperWord</name> = <call><name>PRWord</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> | <name>doubleWrapper</name> | <name>needsChrome</name></expr>;</expr_stmt>
    }</block></function>

    <function_decl><type><name>void</name></type> <name>NoteTearoffs</name><parameter_list>(<param><decl><type><name>nsCycleCollectionTraversalCallback</name>&amp;</type> <name>cb</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>QITableEntry</name>*</type> <name>GetOffsets</name><parameter_list>()</parameter_list>
    <block>{
        <if>if<condition>(<expr>!<call><name>HasProto</name><argument_list>()</argument_list></call> || !<call><name>GetProto</name><argument_list>()</argument_list></call>-&gt;<call><name>ClassIsDOMObject</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>nsnull</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>XPCWrappedNativeProto</name>*</type> <name>proto</name> <init>= <expr><call><name>GetProto</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>QITableEntry</name>*</type> <name>offsets</name> <init>= <expr><call><name><name>proto</name>-&gt;<name>GetOffsets</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr>!<name>offsets</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr>static <call><name>NS_DEFINE_IID</name><argument_list>(<argument><expr><name>kThisPtrOffsetsSID</name></expr></argument>, <argument><expr><name>NS_THISPTROFFSETS_SID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mIdentity</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><name>kThisPtrOffsetsSID</name></expr></argument>, <argument><expr>(<name>void</name>**)&amp;<name>offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>offsets</name></expr>;</return>
    }</block></function>

    <comment type="line">// Make ctor and dtor protected (rather than private) to placate nsCOMPtr.</comment>
<label><name>protected</name>:</label>
    <expr_stmt><expr><call><name>XPCWrappedNative</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>

    <comment type="line">// This ctor is used if this object will have a proto.</comment>
    <expr_stmt><expr><call><name>XPCWrappedNative</name><argument_list>(<argument><expr><name>already_AddRefed</name>&lt;<name>nsISupports</name>&gt; <name>aIdentity</name></expr></argument>,
                     <argument><expr><name>XPCWrappedNativeProto</name>* <name>aProto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// This ctor is used if this object will NOT have a proto.</comment>
    <expr_stmt><expr><call><name>XPCWrappedNative</name><argument_list>(<argument><expr><name>already_AddRefed</name>&lt;<name>nsISupports</name>&gt; <name>aIdentity</name></expr></argument>,
                     <argument><expr><name>XPCWrappedNativeScope</name>* <name>aScope</name></expr></argument>,
                     <argument><expr><name>XPCNativeSet</name>* <name>aSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>virtual</name> ~<call><name>XPCWrappedNative</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
    <enum>enum <block>{ <decl><name>CHROME_ONLY</name> <init>= <expr><call><name>JS_BIT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>, <decl><name>DOUBLE_WRAPPER</name> <init>= <expr><call><name>JS_BIT</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>, <decl><name>FLAG_MASK</name> <init>= <expr>(<name>PRWord</name>)~(<name>PRWord</name>)0x3</expr></init></decl> }</block>;</enum>

    <function_decl><type><name>void</name></type> <name>TraceOtherWrapper</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>JSBool</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>parent</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>isGlobal</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>XPCNativeScriptableCreateInfo</name>*</type> <name>sci</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>JSBool</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>XPCCallContext</name> &amp;</type><name>ccx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>existingJSObject</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>JSBool</name></type> <name>FinishInit</name><parameter_list>(<param><decl><type><name>XPCCallContext</name> &amp;</type><name>ccx</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>JSBool</name></type> <name>ExtendSet</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>XPCNativeInterface</name>*</type> <name>aInterface</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>nsresult</name></type> <name>InitTearOff</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                         <param><decl><type><name>XPCWrappedNativeTearOff</name>*</type> <name>aTearOff</name></decl></param>,
                         <param><decl><type><name>XPCNativeInterface</name>*</type> <name>aInterface</name></decl></param>,
                         <param><decl><type><name>JSBool</name></type> <name>needJSObject</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>JSBool</name></type> <name>InitTearOffJSObject</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                <param><decl><type><name>XPCWrappedNativeTearOff</name>*</type> <name>to</name></decl></param>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XPCNativeScriptableCreateInfo</name>&amp;</type> <name>GatherScriptableCreateInfo</name><parameter_list>(
                        <param><decl><type><name>nsISupports</name>*</type> <name>obj</name></decl></param>,
                        <param><decl><type><name>nsIClassInfo</name>*</type> <name>classInfo</name></decl></param>,
                        <param><decl><type><name>XPCNativeScriptableCreateInfo</name>&amp;</type> <name>sciProto</name></decl></param>,
                        <param><decl><type><name>XPCNativeScriptableCreateInfo</name>&amp;</type> <name>sciWrapper</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <union>union
    <block>{
        <decl_stmt><decl><type><name>XPCWrappedNativeScope</name>*</type>   <name>mMaybeScope</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>XPCWrappedNativeProto</name>*</type>   <name>mMaybeProto</name></decl>;</decl_stmt>
    }</block>;</union>
    <decl_stmt><decl><type><name>XPCNativeSet</name>*</type>                <name>mSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type>                    <name>mFlatJSObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCNativeScriptableInfo</name>*</type>     <name>mScriptableInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNativeTearOffChunk</name></type> <name>mFirstChunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRWord</name></type>                       <name>mWrapperWord</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_CHECK_WRAPPER_THREADSAFETY</name></cpp:ifdef>
<label><name>public</name>:</label>
    <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIThread</name>&gt;          <name>mThread</name></expr>;</expr_stmt> <comment type="line">// Don't want to overload _mOwningThread</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
};

<comment type="block">/***************************************************************************
****************************************************************************
*
* Core classes for wrapped JSObject for use from native code...
*
****************************************************************************
***************************************************************************/</comment>

<comment type="line">// this interfaces exists so we can refcount nsXPCWrappedJSClass</comment>
<comment type="line">// {2453EBA0-A9B8-11d2-BA64-00805F8A5DD7}</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IXPCONNECT_WRAPPED_JS_CLASS_IID</name></cpp:macro>  \
<cpp:value>{ 0x2453eba0, 0xa9b8, 0x11d2,               \
  { 0xba, 0x64, 0x0, 0x80, 0x5f, 0x8a, 0x5d, 0xd7 } }</cpp:value></cpp:define>

<expr_stmt><expr><name>class</name> <name>nsIXPCWrappedJSClass</name> : <name>public</name> <name>nsISupports</name>
<block>{
<expr><name>public</name>:
    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_IXPCONNECT_WRAPPED_JS_CLASS_IID</argument>)</argument_list></macro>
    <name>NS_IMETHOD</name> <macro><name>DebugDump</name><argument_list>(<argument>PRInt16 depth</argument>)</argument_list></macro> = 0</expr>;
}</block></expr>;</expr_stmt>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsIXPCWrappedJSClass</argument>,
                              <argument>NS_IXPCONNECT_WRAPPED_JS_CLASS_IID</argument>)</argument_list></macro>

<comment type="block">/*************************/</comment>
<comment type="line">// nsXPCWrappedJSClass represents the sharable factored out common code and</comment>
<comment type="line">// data for nsXPCWrappedJS instances for the same interface type.</comment>

<expr_stmt><expr><name>class</name> <name>nsXPCWrappedJSClass</name> : <name>public</name> <name>nsIXPCWrappedJSClass</name>
<block>{
    <comment type="line">// all the interface method declarations...</comment>
    <expr><name>NS_DECL_ISUPPORTS</name>
    <name>NS_IMETHOD</name> <macro><name>DebugDump</name><argument_list>(<argument>PRInt16 depth</argument>)</argument_list></macro></expr>;
<expr><name>public</name>:

    static <name>nsresult</name>
    <macro><name>GetNewOrUsed</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>,
                 <argument>REFNSIID aIID</argument>,
                 <argument>nsXPCWrappedJSClass** clazz</argument>)</argument_list></macro></expr>;

    <expr><name>REFNSIID</name> <macro><name>GetIID</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mIID</name></expr>;</return></block></expr>}</block>
    <name>XPCJSRuntime</name>* <macro><name>GetRuntime</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mRuntime</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsIInterfaceInfo</name>* <macro><name>GetInterfaceInfo</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mInfo</name></expr>;</return>}</block></expr></expr_stmt>
    <function_decl><type><specifier>const</specifier> <name>char</name>*</type> <name>GetInterfaceName</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>IsWrappedJS</name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aPtr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>NS_IMETHOD</name></type> <name>DelegatedQueryInterface</name><parameter_list>(<param><decl><type><name>nsXPCWrappedJS</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>REFNSIID</name></type> <name>aIID</name></decl></param>,
                                       <param><decl><type><name>void</name>**</type> <name>aInstancePtr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>JSObject</name>*</type> <name>GetRootJSObject</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>aJSObj</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>NS_IMETHOD</name></type> <name>CallMethod</name><parameter_list>(<param><decl><type><name>nsXPCWrappedJS</name>*</type> <name>wrapper</name></decl></param>, <param><decl><type><name>uint16</name></type> <name>methodIndex</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>XPTMethodDescriptor</name>*</type> <name>info</name></decl></param>,
                          <param><decl><type><name>nsXPTCMiniVariant</name>*</type> <name>params</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>JSObject</name>*</type>  <name>CallQueryInterfaceOnJSObject</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                            <param><decl><type><name>JSObject</name>*</type> <name>jsobj</name></decl></param>, <param><decl><type><name>REFNSIID</name></type> <name>aIID</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>BuildPropertyEnumerator</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                            <param><decl><type><name>JSObject</name>*</type> <name>aJSObj</name></decl></param>,
                                            <param><decl><type><name>nsISimpleEnumerator</name>**</type> <name>aEnumerate</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>GetNamedPropertyAsVariant</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, 
                                              <param><decl><type><name>JSObject</name>*</type> <name>aJSObj</name></decl></param>,
                                              <param><decl><type><name>jsval</name></type> <name>aName</name></decl></param>, 
                                              <param><decl><type><name>nsIVariant</name>**</type> <name>aResult</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>virtual</name> ~<call><name>nsXPCWrappedJSClass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>CheckForException</name><parameter_list>(<param><decl><type><name>XPCCallContext</name> &amp;</type> <name>ccx</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aPropertyName</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>anInterfaceName</name></decl></param>,
                                      <param><decl><type><name>PRBool</name></type> <name>aForceReport</name></decl></param>)</parameter_list>;</function_decl>
<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>nsXPCWrappedJSClass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// not implemented</comment>
    <macro><name>nsXPCWrappedJSClass</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>, <argument>REFNSIID aIID</argument>,
                        <argument>nsIInterfaceInfo* aInfo</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <function_decl><type><name>JSObject</name>*</type>  <name>NewOutObject</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>JSBool</name></type> <name>IsReflectable</name><argument_list>(<argument><expr><name>uint16</name> <name>i</name></expr></argument>)</argument_list> const
        <block>{<return>return <expr><call>(<name>JSBool</name>)<argument_list>(<argument><expr><name><name>mDescriptors</name><index>[<expr><name>i</name>/32</expr>]</index></name> &amp; (1 &lt;&lt; (<name>i</name>%32))</expr></argument>)</argument_list></call></expr>;</return>}</block></decl></decl_stmt>
    <function><type><name>void</name></type> <name>SetReflectable</name><parameter_list>(<param><decl><type><name>uint16</name></type> <name>i</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{<if>if<condition>(<expr><name>b</name></expr>)</condition><then> <expr_stmt><expr><name><name>mDescriptors</name><index>[<expr><name>i</name>/32</expr>]</index></name> |= (1 &lt;&lt; (<name>i</name>%32))</expr>;</expr_stmt></then>
         <else>else <expr_stmt><expr><name><name>mDescriptors</name><index>[<expr><name>i</name>/32</expr>]</index></name> &amp;= ~(1 &lt;&lt; (<name>i</name>%32))</expr>;</expr_stmt></else></if>}</block></function>

    <enum>enum <name>SizeMode</name> <block>{<decl><name>GET_SIZE</name></decl>, <decl><name>GET_LENGTH</name></decl>}</block>;</enum>

    <function_decl><type><name>JSBool</name></type> <name>GetArraySizeFromParam</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>XPTMethodDescriptor</name>*</type> <name>method</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsXPTParamInfo</name>&amp;</type> <name>param</name></decl></param>,
                                 <param><decl><type><name>uint16</name></type> <name>methodIndex</name></decl></param>,
                                 <param><decl><type><name>uint8</name></type> <name>paramIndex</name></decl></param>,
                                 <param><decl><type><name>SizeMode</name></type> <name>mode</name></decl></param>,
                                 <param><decl><type><name>nsXPTCMiniVariant</name>*</type> <name>params</name></decl></param>,
                                 <param><decl><type><name>JSUint32</name>*</type> <name>result</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>JSBool</name></type> <name>GetInterfaceTypeFromParam</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>XPTMethodDescriptor</name>*</type> <name>method</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsXPTParamInfo</name>&amp;</type> <name>param</name></decl></param>,
                                     <param><decl><type><name>uint16</name></type> <name>methodIndex</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                     <param><decl><type><name>nsXPTCMiniVariant</name>*</type> <name>params</name></decl></param>,
                                     <param><decl><type><name>nsID</name>*</type> <name>result</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>CleanupPointerArray</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>datum_type</name></decl></param>,
                             <param><decl><type><name>JSUint32</name></type> <name>array_count</name></decl></param>,
                             <param><decl><type><name>void</name>**</type> <name>arrayp</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>CleanupPointerTypeObject</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                  <param><decl><type><name>void</name>**</type> <name>pp</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCJSRuntime</name>*</type> <name>mRuntime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIInterfaceInfo</name>*</type> <name>mInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>mName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIID</name></type> <name>mIID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name>*</type> <name>mDescriptors</name></decl>;</decl_stmt>
};

<comment type="block">/*************************/</comment>
<comment type="line">// nsXPCWrappedJS is a wrapper for a single JSObject for use from native code.</comment>
<comment type="line">// nsXPCWrappedJS objects are chained together to represent the various</comment>
<comment type="line">// interface on the single underlying (possibly aggregate) JSObject.</comment>

<expr_stmt><expr><name>class</name> <name>nsXPCWrappedJS</name> : <name>protected</name> <name>nsAutoXPTCStub</name></expr>,
                       <expr><name>public</name> <name>nsIXPConnectWrappedJS</name></expr>,
                       <expr><name>public</name> <name>nsSupportsWeakReference</name></expr>,
                       <expr><name>public</name> <name>nsIPropertyBag</name></expr>,
                       <expr><name>public</name> <name>XPCRootSetElem</name>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIXPCONNECTJSOBJECTHOLDER</name>
    <name>NS_DECL_NSIXPCONNECTWRAPPEDJS</name>
    <name>NS_DECL_NSISUPPORTSWEAKREFERENCE</name>
    <name>NS_DECL_NSIPROPERTYBAG</name>

    <name>class</name> <name>NS_CYCLE_COLLECTION_INNERCLASS</name>
     : <name>public</name> <name>nsXPCOMCycleCollectionParticipant</name>
    <block>{
      <expr><name>NS_IMETHOD</name> <call><name>RootAndUnlinkJSObjects</name><argument_list>(<argument><expr><name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;
      <macro><name>NS_DECL_CYCLE_COLLECTION_CLASS_BODY</name><argument_list>(<argument>nsXPCWrappedJS</argument>, <argument>nsIXPConnectWrappedJS</argument>)</argument_list></macro>
    }</block></expr>;
    <expr><name>NS_CYCLE_COLLECTION_PARTICIPANT_INSTANCE</name>
    <macro><name>NS_DECL_CYCLE_COLLECTION_UNMARK_PURPLE_STUB</name><argument_list>(<argument>nsXPCWrappedJS</argument>)</argument_list></macro>

    <name>NS_IMETHOD</name> <macro><name>CallMethod</name><argument_list>(<argument>PRUint16 methodIndex</argument>,
                          <argument>const XPTMethodDescriptor *info</argument>,
                          <argument>nsXPTCMiniVariant* params</argument>)</argument_list></macro></expr>;

    <comment type="block">/*
    * This is rarely called directly. Instead one usually calls
    * XPCConvert::JSObject2NativeInterface which will handles cases where the
    * JS object is already a wrapped native or a DOM object.
    */</comment>

    <expr>static <name>nsresult</name>
    <macro><name>GetNewOrUsed</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>,
                 <argument>JSObject* aJSObj</argument>,
                 <argument>REFNSIID aIID</argument>,
                 <argument>nsISupports* aOuter</argument>,
                 <argument>nsXPCWrappedJS** wrapper</argument>)</argument_list></macro></expr>;

    <expr><name>nsISomeInterface</name>* <macro><name>GetXPTCStub</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>mXPTCStub</name></expr>;</return></block></expr> }</block>
    <name>JSObject</name>* <macro><name>GetJSObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSObj</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsXPCWrappedJSClass</name>*  <macro><name>GetClass</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mClass</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>REFNSIID</name> <macro><name>GetIID</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>GetClass</name><argument_list>()</argument_list></call>-&gt;<call><name>GetIID</name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsXPCWrappedJS</name>* <macro><name>GetRootWrapper</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mRoot</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsXPCWrappedJS</name>* <macro><name>GetNextWrapper</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mNext</name></expr>;</return>}</block></expr></expr_stmt>

    <function_decl><type><name>nsXPCWrappedJS</name>*</type> <name>Find</name><parameter_list>(<param><decl><type><name>REFNSIID</name></type> <name>aIID</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>nsXPCWrappedJS</name>*</type> <name>FindInherited</name><parameter_list>(<param><decl><type><name>REFNSIID</name></type> <name>aIID</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsValid</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSObj</name> != <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>
    <function_decl><type><name>void</name></type> <name>SystemIsBeingShutDown</name><parameter_list>(<param><decl><type><name>JSRuntime</name>*</type> <name>rt</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// This is used by XPCJSRuntime::GCCallback to find wrappers that no</comment>
    <comment type="line">// longer root their JSObject and are only still alive because they</comment>
    <comment type="line">// were being used via nsSupportsWeakReference at the time when their</comment>
    <comment type="line">// last (outside) reference was released. Wrappers that fit into that</comment>
    <comment type="line">// category are only deleted when we see that their corresponding JSObject</comment>
    <comment type="line">// is to be finalized.</comment>
    <expr_stmt><expr><name>JSBool</name> <macro><name>IsSubjectToFinalization</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><call><name>IsValid</name><argument_list>()</argument_list></call> &amp;&amp; <name>mRefCnt</name> == 1</expr>;</return>}</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSBool</name> <macro><name>IsAggregatedToNative</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name><name>mRoot</name>-&gt;<name>mOuter</name></name> != <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>nsISupports</name>* <macro><name>GetAggregatedNativeObject</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name><name>mRoot</name>-&gt;<name>mOuter</name></name></expr>;</return>}</block></expr></expr_stmt>

    <function_decl><type><name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintTraceName</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bufsize</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>virtual</name> ~<call><name>nsXPCWrappedJS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<label><name>protected</name>:</label>
    <expr_stmt><expr><call><name>nsXPCWrappedJS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// not implemented</comment>
    <expr_stmt><expr><call><name>nsXPCWrappedJS</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>,
                   <argument><expr><name>JSObject</name>* <name>aJSObj</name></expr></argument>,
                   <argument><expr><name>nsXPCWrappedJSClass</name>* <name>aClass</name></expr></argument>,
                   <argument><expr><name>nsXPCWrappedJS</name>* <name>root</name></expr></argument>,
                   <argument><expr><name>nsISupports</name>* <name>aOuter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <function_decl><type><name>void</name></type> <name>Unlink</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>mJSObj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsXPCWrappedJSClass</name>*</type> <name>mClass</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsXPCWrappedJS</name>*</type> <name>mRoot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsXPCWrappedJS</name>*</type> <name>mNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsISupports</name>*</type> <name>mOuter</name></decl>;</decl_stmt>    <comment type="line">// only set in root</comment>
};

<comment type="block">/***************************************************************************/</comment>

<expr_stmt><expr><name>class</name> <name>XPCJSObjectHolder</name> : <name>public</name> <name>nsIXPConnectJSObjectHolder</name></expr>,
                          <expr><name>public</name> <name>XPCRootSetElem</name>
<block>{
<expr><name>public</name>:
    <comment type="line">// all the interface method declarations...</comment>
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIXPCONNECTJSOBJECTHOLDER</name>

    <comment type="line">// non-interface implementation</comment>

<name>public</name>:
    static <name>XPCJSObjectHolder</name>* <call><name>newHolder</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>, <argument><expr><name>JSObject</name>* <name>obj</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>virtual</name> ~<call><name>XPCJSObjectHolder</name><argument_list>()</argument_list></call></expr>;

    <expr><name>void</name> <call><name>TraceJS</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr>static <name>void</name> <macro><name>PrintTraceName</name><argument_list>(<argument>JSTracer* trc</argument>, <argument>char *buf</argument>, <argument>size_t bufsize</argument>)</argument_list></macro></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>private</name>:
    <call><name>XPCJSObjectHolder</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>, <argument><expr><name>JSObject</name>* <name>obj</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>XPCJSObjectHolder</name><argument_list>()</argument_list></call></expr>; <comment type="line">// not implemented</comment>

    <expr><name>JSObject</name>* <name>mJSObj</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************
****************************************************************************
*
* All manner of utility classes follow...
*
****************************************************************************
***************************************************************************/</comment>

<expr_stmt><expr><name>class</name> <name>xpcProperty</name> : <name>public</name> <name>nsIProperty</name>
<block>{
<expr><name>public</name>:
  <name>NS_DECL_ISUPPORTS</name>
  <name>NS_DECL_NSIPROPERTY</name>

  <macro><name>xpcProperty</name><argument_list>(<argument>const PRUnichar* aName</argument>, <argument>PRUint32 aNameLen</argument>, <argument>nsIVariant* aValue</argument>)</argument_list></macro></expr>;
  <expr><name>virtual</name> ~<macro><name>xpcProperty</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>private</name>:
    <name>nsString</name>             <name>mName</name></expr>;
    <expr><name>nsCOMPtr</name>&lt;<name>nsIVariant</name>&gt; <name>mValue</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// data conversion</comment>

<comment type="line">// class here just for static methods</comment>
<decl_stmt><decl><type><name>class</name></type> <name>XPCConvert</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>IsMethodReflectable</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XPTMethodDescriptor</name>&amp;</type> <name>info</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/**
     * Convert a native object into a jsval.
     *
     * @param ccx the context for the whole procedure
     * @param d [out] the resulting jsval
     * @param s the native object we're working with
     * @param type the type of object that s is
     * @param iid the interface of s that we want
     * @param scope the default scope to put on the new JSObject's parent
     *        chain
     * @param pErr [out] relevant error code, if any.
     */</comment>    
    <function><type><specifier>static</specifier> <name>JSBool</name></type> <name>NativeData2JS</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>d</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>s</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>, <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>
    <block>{
        <function_decl><type><name>XPCLazyCallContext</name></type> <name>lccx</name><parameter_list>(<param><decl><type><name>ccx</name></type></decl></param>)</parameter_list>;</function_decl>
        <return>return <expr><call><name>NativeData2JS</name><argument_list>(<argument><expr><name>lccx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>pErr</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>NativeData2JS</name><parameter_list>(<param><decl><type><name>XPCLazyCallContext</name>&amp;</type> <name>lccx</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>d</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>,
                                <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>JSData2Native</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>d</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>s</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                <param><decl><type><name>JSBool</name></type> <name>useAllocator</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/**
     * Convert a native nsISupports into a JSObject.
     *
     * @param ccx the context for the whole procedure
     * @param dest [out] the resulting JSObject
     * @param src the native object we're working with
     * @param iid the interface of src that we want (may be null)
     * @param Interface the interface of src that we want
     * @param cache the wrapper cache for src (may be null, in which case src
     *              will be QI'ed to get the cache)
     * @param scope the default scope to put on the new JSObject's parent chain
     * @param allowNativeWrapper if true, this method may wrap the resulting
     *        JSObject in an XPCNativeWrapper and return that, as needed.
     * @param isGlobal
     * @param pErr [out] relevant error code, if any.
     */</comment>
    <function><type><specifier>static</specifier> <name>JSBool</name></type> <name>NativeInterface2JSObject</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                           <param><decl><type><name>jsval</name>*</type> <name>d</name></decl></param>,
                                           <param><decl><type><name>nsIXPConnectJSObjectHolder</name>**</type> <name>dest</name></decl></param>,
                                           <param><decl><type><name>nsISupports</name>*</type> <name>src</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                           <param><decl><type><name>XPCNativeInterface</name>**</type> <name>Interface</name></decl></param>,
                                           <param><decl><type><name>nsWrapperCache</name> *</type><name>cache</name></decl></param>,
                                           <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>,
                                           <param><decl><type><name>PRBool</name></type> <name>allowNativeWrapper</name></decl></param>,
                                           <param><decl><type><name>PRBool</name></type> <name>isGlobal</name></decl></param>,
                                           <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>
    <block>{
        <function_decl><type><name>XPCLazyCallContext</name></type> <name>lccx</name><parameter_list>(<param><decl><type><name>ccx</name></type></decl></param>)</parameter_list>;</function_decl>
        <return>return <expr><call><name>NativeInterface2JSObject</name><argument_list>(<argument><expr><name>lccx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>, <argument><expr><name>Interface</name></expr></argument>,
                                        <argument><expr><name>cache</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>allowNativeWrapper</name></expr></argument>,
                                        <argument><expr><name>isGlobal</name></expr></argument>, <argument><expr><name>pErr</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>NativeInterface2JSObject</name><parameter_list>(<param><decl><type><name>XPCLazyCallContext</name>&amp;</type> <name>lccx</name></decl></param>,
                                           <param><decl><type><name>jsval</name>*</type> <name>d</name></decl></param>,
                                           <param><decl><type><name>nsIXPConnectJSObjectHolder</name>**</type> <name>dest</name></decl></param>,
                                           <param><decl><type><name>nsISupports</name>*</type> <name>src</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                           <param><decl><type><name>XPCNativeInterface</name>**</type> <name>Interface</name></decl></param>,
                                           <param><decl><type><name>nsWrapperCache</name> *</type><name>cache</name></decl></param>,
                                           <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>,
                                           <param><decl><type><name>PRBool</name></type> <name>allowNativeWrapper</name></decl></param>,
                                           <param><decl><type><name>PRBool</name></type> <name>isGlobal</name></decl></param>,
                                           <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>GetNativeInterfaceFromJSObject</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                                 <param><decl><type><name>void</name>**</type> <name>dest</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>src</name></decl></param>,
                                                 <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>, 
                                                 <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>JSObject2NativeInterface</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                           <param><decl><type><name>void</name>**</type> <name>dest</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>src</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                           <param><decl><type><name>nsISupports</name>*</type> <name>aOuter</name></decl></param>,
                                           <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>GetISupportsFromJSObject</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>nsISupports</name>**</type> <name>iface</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/**
     * Convert a native array into a jsval.
     *
     * @param ccx the context for the whole procedure
     * @param d [out] the resulting jsval
     * @param s the native array we're working with
     * @param type the type of objects in the array
     * @param iid the interface of each object in the array that we want
     * @param count the number of items in the array
     * @param scope the default scope to put on the new JSObjects' parent chain
     * @param pErr [out] relevant error code, if any.
     */</comment>    
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>NativeArray2JS</name><parameter_list>(<param><decl><type><name>XPCLazyCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                 <param><decl><type><name>jsval</name>*</type> <name>d</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>**</type> <name>s</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                 <param><decl><type><name>JSUint32</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>,
                                 <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>JSArray2Native</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>void</name>**</type> <name>d</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>s</name></decl></param>,
                                 <param><decl><type><name>JSUint32</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSUint32</name></type> <name>capacity</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                 <param><decl><type><name>JSBool</name></type> <name>useAllocator</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsID</name>*</type> <name>iid</name></decl></param>,
                                 <param><decl><type><name>uintN</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>NativeStringWithSize2JS</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                                          <param><decl><type><name>jsval</name>*</type> <name>d</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>s</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                          <param><decl><type><name>JSUint32</name></type> <name>count</name></decl></param>,
                                          <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>JSStringWithSize2Native</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>d</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>s</name></decl></param>,
                                          <param><decl><type><name>JSUint32</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSUint32</name></type> <name>capacity</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>nsXPTType</name>&amp;</type> <name>type</name></decl></param>,
                                          <param><decl><type><name>JSBool</name></type> <name>useAllocator</name></decl></param>,
                                          <param><decl><type><name>uintN</name>*</type> <name>pErr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>JSValToXPCException</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                        <param><decl><type><name>jsval</name></type> <name>s</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>ifaceName</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>methodName</name></decl></param>,
                                        <param><decl><type><name>nsIException</name>**</type> <name>exception</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>JSErrorToXPCException</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>message</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>ifaceName</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>methodName</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>JSErrorReport</name>*</type> <name>report</name></decl></param>,
                                          <param><decl><type><name>nsIException</name>**</type> <name>exception</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type> <name>ConstructException</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rv</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>message</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>ifaceName</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>methodName</name></decl></param>,
                                       <param><decl><type><name>nsISupports</name>*</type> <name>data</name></decl></param>,
                                       <param><decl><type><name>nsIException</name>**</type> <name>exception</name></decl></param>,
                                       <param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>,
                                       <param><decl><type><name>jsval</name> *</type><name>jsExceptionPtr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveXPCOMUCStringFinalizer</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCConvert</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented</comment>

}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>

<comment type="line">// readable string conversions, static methods only</comment>
<decl_stmt><decl><type><name>class</name></type> <name>XPCStringConvert</name>
<block>{
<label><name>public</name>:</label>

    <function_decl><type><specifier>static</specifier> <name>jsval</name></type> <name>ReadableToJSVal</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsAString</name> &amp;</type><name>readable</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>XPCReadableJSStringWrapper</name> *</type><name>JSStringToReadable</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                                                          <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownDOMStringFinalizer</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCStringConvert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>         <comment type="line">// not implemented</comment>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>XPC_JSArgumentFormatter</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>,
                        <param><decl><type><name>JSBool</name></type> <name>fromJS</name></decl></param>, <param><decl><type><name>jsval</name> **</type><name>vpp</name></decl></param>, <param><decl><type><name>va_list</name> *</type><name>app</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/***************************************************************************/</comment>
<comment type="line">// code for throwing exceptions into JS</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCThrower</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Throw</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rv</name></decl></param>, <param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Throw</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rv</name></decl></param>, <param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ThrowBadResult</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rv</name></decl></param>, <param><decl><type><name>nsresult</name></type> <name>result</name></decl></param>, <param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ThrowBadParam</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>rv</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>paramNum</name></decl></param>, <param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>ThrowCOMError</name><argument_list>(<argument><expr><name>JSContext</name>* <name>cx</name></expr></argument>, <argument><expr><name>unsigned</name> <name>long</name> <name>COMErrorCode</name></expr></argument>, 
                              <argument><expr><name>nsresult</name> <name>rv</name> = <name>NS_ERROR_XPC_COM_ERROR</name></expr></argument>,
                              <argument><expr>const <name>EXCEPINFO</name> * <name>exception</name> = <name>nsnull</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <function><type><specifier>static</specifier> <name>JSBool</name></type> <name>SetVerbosity</name><parameter_list>(<param><decl><type><name>JSBool</name></type> <name>state</name></decl></param>)</parameter_list>
        <block>{<decl_stmt><decl><type><name>JSBool</name></type> <name>old</name> <init>= <expr><name>sVerbose</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>sVerbose</name> = <name>state</name></expr>;</expr_stmt> <return>return <expr><name>old</name></expr>;</return>}</block></function>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BuildAndThrowException</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>nsresult</name></type> <name>rv</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>sz</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>CheckForPendingException</name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>result</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Verbosify</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>&amp;</type> <name>ccx</name></decl></param>,
                          <param><decl><type><name>char</name>**</type> <name>psz</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>own</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>ThrowExceptionObject</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>nsIException</name>*</type> <name>e</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>sVerbose</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<comment type="block">/***************************************************************************/</comment>

<decl_stmt><decl><type><name>class</name></type> <name>XPCJSStack</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>CreateStack</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>nsIStackFrame</name>**</type> <name>stack</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><specifier>static</specifier> <name>nsresult</name></type>
    <name>CreateStackFrameLocation</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aLanguage</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aFilename</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aFunctionName</name></decl></param>,
                             <param><decl><type><name>PRInt32</name></type> <name>aLineNumber</name></decl></param>,
                             <param><decl><type><name>nsIStackFrame</name>*</type> <name>aCaller</name></decl></param>,
                             <param><decl><type><name>nsIStackFrame</name>**</type> <name>stack</name></decl></param>)</parameter_list>;</function_decl>
<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCJSStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// not implemented</comment>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>

<expr_stmt><expr><name>class</name> <name>nsXPCException</name> :
            <name>public</name> <name>nsIXPCException</name>
<block>{
<expr><name>public</name>:
    <macro><name>NS_DEFINE_STATIC_CID_ACCESSOR</name><argument_list>(<argument>NS_XPCEXCEPTION_CID</argument>)</argument_list></macro>

    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIEXCEPTION</name>
    <name>NS_DECL_NSIXPCEXCEPTION</name>

    static <name>nsresult</name> <macro><name>NewException</name><argument_list>(<argument>const char *aMessage</argument>,
                                 <argument>nsresult aResult</argument>,
                                 <argument>nsIStackFrame *aLocation</argument>,
                                 <argument>nsISupports *aData</argument>,
                                 <argument>nsIException** exception</argument>)</argument_list></macro></expr>;

    <expr>static <name>JSBool</name> <macro><name>NameAndFormatForNSResult</name><argument_list>(<argument>nsresult rv</argument>,
                                           <argument>const char** name</argument>,
                                           <argument>const char** format</argument>)</argument_list></macro></expr>;

    <expr>static <name>void</name>* <call><name>IterateNSResults</name><argument_list>(<argument><expr><name>nsresult</name>* <name>rv</name></expr></argument>,
                                  <argument><expr>const <name>char</name>** <name>name</name></expr></argument>,
                                  <argument><expr>const <name>char</name>** <name>format</name></expr></argument>,
                                  <argument><expr><name>void</name>** <name>iterp</name></expr></argument>)</argument_list></call></expr>;

    <expr>static <name>PRUint32</name> <call><name>GetNSResultCount</name><argument_list>()</argument_list></call></expr>;

    <expr><call><name>nsXPCException</name><argument_list>()</argument_list></call></expr>;
    <expr><name>virtual</name> ~<call><name>nsXPCException</name><argument_list>()</argument_list></call></expr>;

    <expr>static <name>void</name> <macro><name>InitStatics</name><argument_list>()</argument_list></macro> <block>{ <expr><name>sEverMadeOneFromFactory</name> = <name>JS_FALSE</name></expr>; }</block>

<name>protected</name>:
    <name>void</name> <call><name>Reset</name><argument_list>()</argument_list></call></expr>;
<expr><name>private</name>:
    <name>char</name>*           <name>mMessage</name></expr>;
    <expr><name>nsresult</name>        <name>mResult</name></expr>;
    <expr><name>char</name>*           <name>mName</name></expr>;
    <expr><name>nsIStackFrame</name>*  <name>mLocation</name></expr>;
    <expr><name>nsISupports</name>*    <name>mData</name></expr>;
    <expr><name>char</name>*           <name>mFilename</name></expr>;
    <expr><name>int</name>             <name>mLineNumber</name></expr>;
    <expr><name>nsIException</name>*   <name>mInner</name></expr>;
    <expr><name>PRBool</name>          <name>mInitialized</name></expr>;

    <expr><name>nsAutoJSValHolder</name> <name>mThrownJSVal</name></expr>;

    <expr>static <name>JSBool</name> <name>sEverMadeOneFromFactory</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="block">/*
* nsJSID implements nsIJSID. It is also used by nsJSIID and nsJSCID as a
* member (as a hidden implementaion detail) to which they delegate many calls.
*/</comment>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type> <name>xpc_InitJSxIDClassObjects</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>xpc_DestroyJSxIDClassObjects</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>class</name> <name>nsJSID</name> : <name>public</name> <name>nsIJSID</name>
<block>{
<expr><name>public</name>:
    <macro><name>NS_DEFINE_STATIC_CID_ACCESSOR</name><argument_list>(<argument>NS_JS_ID_CID</argument>)</argument_list></macro>

    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIJSID</name>

    <name>PRBool</name> <call><name>InitWithName</name><argument_list>(<argument><expr>const <name>nsID</name>&amp; <name>id</name></expr></argument>, <argument><expr>const <name>char</name> *<name>nameString</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>PRBool</name> <call><name>SetName</name><argument_list>(<argument><expr>const <name>char</name>* <name>name</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>void</name>   <macro><name>SetNameToNoString</name><argument_list>()</argument_list></macro>
        <block>{<expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mName</name></expr></argument>, <argument><expr>"name already set"</expr></argument>)</argument_list></call></expr>; <expr><name>mName</name> = <name>gNoString</name></expr>;}</block>
    <name>PRBool</name> <macro><name>NameIsSet</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>nsnull</name> != <name>mName</name></expr>;</return></block></expr>}</block>
    const <name>nsID</name>&amp; <macro><name>ID</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mID</name></expr>;</return>}</block></expr></expr_stmt>
    <expr_stmt><expr><name>PRBool</name> <macro><name>IsValid</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr>!<call><name><name>mID</name>.<name>Equals</name></name><argument_list>(<argument><expr><call><name>GetInvalidIID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

    <function_decl><type><specifier>static</specifier> <name>nsJSID</name>*</type> <name>NewID</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>str</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name>nsJSID</name>*</type> <name>NewID</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsID</name>&amp;</type> <name>id</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name>nsJSID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>virtual</name> ~<call><name>nsJSID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<label><name>protected</name>:</label>

    <function_decl><type><name>void</name></type> <name>Reset</name><parameter_list>()</parameter_list>;</function_decl>
    <expr_stmt><expr>const <name>nsID</name>&amp; <macro><name>GetInvalidIID</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

<label><name>protected</name>:</label>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>gNoString</name><index>[]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsID</name></type>    <name>mID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type>   <name>mNumber</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type>   <name>mName</name></decl>;</decl_stmt>
};

<comment type="line">// nsJSIID</comment>

<expr_stmt><expr><name>class</name> <name>nsJSIID</name> : <name>public</name> <name>nsIJSIID</name></expr>, <expr><name>public</name> <name>nsIXPCScriptable</name></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
          , <expr><name>public</name> <name>nsISecurityCheckedComponent</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>

    <comment type="line">// we manually delagate these to nsJSID</comment>
    <name>NS_DECL_NSIJSID</name>

    <comment type="line">// we implement the rest...</comment>
    <name>NS_DECL_NSIJSIID</name>
    <name>NS_DECL_NSIXPCSCRIPTABLE</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
    <name>NS_DECL_NSISECURITYCHECKEDCOMPONENT</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    static <name>nsJSIID</name>* <call><name>NewID</name><argument_list>(<argument><expr><name>nsIInterfaceInfo</name>* <name>aInfo</name></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>nsJSIID</name><argument_list>(<argument><expr><name>nsIInterfaceInfo</name>* <name>aInfo</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>nsJSIID</name><argument_list>()</argument_list></call></expr>; <comment type="line">// not implemented</comment>
    <expr><name>virtual</name> ~<call><name>nsJSIID</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <name>nsCOMPtr</name>&lt;<name>nsIInterfaceInfo</name>&gt; <name>mInfo</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="line">// nsJSCID</comment>

<expr_stmt><expr><name>class</name> <name>nsJSCID</name> : <name>public</name> <name>nsIJSCID</name></expr>, <expr><name>public</name> <name>nsIXPCScriptable</name>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>

    <comment type="line">// we manually delagate these to nsJSID</comment>
    <name>NS_DECL_NSIJSID</name>

    <comment type="line">// we implement the rest...</comment>
    <name>NS_DECL_NSIJSCID</name>
    <name>NS_DECL_NSIXPCSCRIPTABLE</name>

    static <name>nsJSCID</name>* <call><name>NewID</name><argument_list>(<argument><expr>const <name>char</name>* <name>str</name></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>nsJSCID</name><argument_list>()</argument_list></call></expr>;
    <expr><name>virtual</name> ~<call><name>nsJSCID</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <name>void</name> <call><name>ResolveName</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <name>nsJSID</name> <name>mDetails</name></expr>;
}</block></expr>;</expr_stmt>


<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XPCJSContextStack is not actually an xpcom object, but xpcom calls are</comment>
<comment type="line">// delegated to it as an implementation detail.</comment>
<struct>struct <name>XPCJSContextInfo</name> <block>{
    <expr_stmt><expr><call><name>XPCJSContextInfo</name><argument_list>(<argument><expr><name>JSContext</name>* <name>aCx</name></expr></argument>)</argument_list></call> :
        <call><name>cx</name><argument_list>(<argument><expr><name>aCx</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>frame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>,
        <macro><name>requestDepth</name><argument_list>(<argument>0</argument>)</argument_list></macro>
    <expr><block>{}</block>
    <name>JSContext</name>* <name>cx</name></expr>;</expr_stmt>

    <comment type="line">// Frame to be restored when this JSContext becomes the topmost</comment>
    <comment type="line">// one.</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>frame</name></decl>;</decl_stmt>

    <comment type="line">// Greater than 0 if a request was suspended</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type> <name>requestDepth</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>class</name></type> <name>XPCJSContextStack</name>
<block>{
<label><name>public</name>:</label>
    <function_decl><type><name>NS_DECL_NSIJSCONTEXTSTACK</name>
    <name>NS_DECL_NSITHREADJSCONTEXTSTACK</name></type>

    <name>XPCJSContextStack</name><parameter_list>()</parameter_list>;</function_decl>
    <expr_stmt><expr><name>virtual</name> ~<call><name>XPCJSContextStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <function_decl><type><name>JSBool</name></type> <name>DEBUG_StackHasJSContext</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type>  <name>aJSContext</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr>const <name>nsTArray</name>&lt;<name>XPCJSContextInfo</name>&gt;* <macro><name>GetStack</name><argument_list>()</argument_list></macro>
    <block>{ <return>return <expr>&amp;<name>mStack</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
    <expr_stmt><expr><name>nsAutoTArray</name>&lt;<name>XPCJSContextInfo</name></expr>, <expr>16&gt; <name>mStack</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSContext</name>*</type>  <name>mSafeJSContext</name></decl>;</decl_stmt>

    <comment type="line">// If non-null, we own it; same as mSafeJSContext if SetSafeJSContext</comment>
    <comment type="line">// not called.</comment>
    <decl_stmt><decl><type><name>JSContext</name>*</type>  <name>mOwnSafeJSContext</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_XPC_JSCONTEXT_STACK_ITERATOR_CID</name></cpp:macro> \
<cpp:value>{ 0x05bae29d, 0x8aef, 0x486d, \
  { 0x84, 0xaa, 0x53, 0xf4, 0x8f, 0x14, 0x68, 0x11 } }</cpp:value></cpp:define>

<expr_stmt><expr><name>class</name> <name>nsXPCJSContextStackIterator</name> : <name>public</name> <name>nsIJSContextStackIterator</name>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIJSCONTEXTSTACKITERATOR</name>

<name>private</name>:
    const <name>nsTArray</name>&lt;<name>XPCJSContextInfo</name>&gt; *<name>mStack</name></expr>;
    <expr><name>PRUint32</name> <name>mPosition</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/**************************************************************/</comment>
<comment type="line">// All of our thread local storage.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BAD_TLS_INDEX</name></cpp:macro> <cpp:value>((PRUint32) -1)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>XPCPerThreadData</name>
<block>{
<label><name>public</name>:</label>
    <comment type="line">// Get the instance of this object for the current thread</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>XPCPerThreadData</name>*</type> <name>GetData</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
    <block>{
        <if>if<condition>(<expr><name>cx</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>, <argument><expr>"Uh, JS context w/o a thread?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if<condition>(<expr><name><name>cx</name>-&gt;<name>thread</name></name> == <name>sMainJSThread</name></expr>)</condition><then>
                <return>return <expr><name>sMainThreadData</name></expr>;</return></then></if>
        }</block></then>
        <else>else <if>if<condition>(<expr><name>sMainThreadData</name> &amp;&amp; <name><name>sMainThreadData</name>-&gt;<name>mThread</name></name> == <call><name>PR_GetCurrentThread</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <return>return <expr><name>sMainThreadData</name></expr>;</return>
        }</block></then></if></else></if>

        <return>return <expr><call><name>GetDataImpl</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupAllThreads</name><parameter_list>()</parameter_list>;</function_decl>

    <expr_stmt><expr>~<call><name>XPCPerThreadData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function><type><name>nsresult</name></type> <name>GetException</name><parameter_list>(<param><decl><type><name>nsIException</name>**</type> <name>aException</name></decl></param>)</parameter_list>
    <block>{
        <if>if<condition>(<expr><call><name>EnsureExceptionManager</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>mExceptionManager</name>-&gt;<name>GetCurrentException</name></name><argument_list>(<argument><expr><name>aException</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>mException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>aException</name> = <name>mException</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <function><type><name>nsresult</name></type> <name>SetException</name><parameter_list>(<param><decl><type><name>nsIException</name>*</type> <name>aException</name></decl></param>)</parameter_list>
    <block>{
        <if>if<condition>(<expr><call><name>EnsureExceptionManager</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>mExceptionManager</name>-&gt;<name>SetCurrentException</name></name><argument_list>(<argument><expr><name>aException</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>aException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mException</name> = <name>aException</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <function><type><name>nsIExceptionManager</name>*</type> <name>GetExceptionManager</name><parameter_list>()</parameter_list>
    <block>{
        <if>if<condition>(<expr><call><name>EnsureExceptionManager</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>mExceptionManager</name></expr>;</return></then></if>
        <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></function>

    <function><type><name>JSBool</name></type> <name>EnsureExceptionManager</name><parameter_list>()</parameter_list>
    <block>{
        <if>if<condition>(<expr><name>mExceptionManager</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <if>if<condition>(<expr><name>mExceptionManagerNotAvailable</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIExceptionService</name>&gt; <name>xs</name> =
            <call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_EXCEPTIONSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>xs</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>xs</name>-&gt;<name>GetCurrentExceptionManager</name></name><argument_list>(<argument><expr>&amp;<name>mExceptionManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><name>mExceptionManager</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>mExceptionManagerNotAvailable</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></function>

    <function><type><name>XPCJSContextStack</name>*</type> <name>GetJSContextStack</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>mJSContextStack</name></expr>;</return>}</block></function>

    <expr_stmt><expr><name>XPCCallContext</name>*  <macro><name>GetCallContext</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mCallContext</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>XPCCallContext</name>*</type>  <name>SetCallContext</name><parameter_list>(<param><decl><type><name>XPCCallContext</name>*</type> <name>ccx</name></decl></param>)</parameter_list>
        <block>{<decl_stmt><decl><type><name>XPCCallContext</name>*</type> <name>old</name> <init>= <expr><name>mCallContext</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>mCallContext</name> = <name>ccx</name></expr>;</expr_stmt> <return>return <expr><name>old</name></expr>;</return>}</block></function>

    <expr_stmt><expr><name>jsid</name> <macro><name>GetResolveName</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mResolveName</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>jsid</name></type> <name>SetResolveName</name><parameter_list>(<param><decl><type><name>jsid</name></type> <name>name</name></decl></param>)</parameter_list>
        <block>{<decl_stmt><decl><type><name>jsid</name></type> <name>old</name> <init>= <expr><name>mResolveName</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>mResolveName</name> = <name>name</name></expr>;</expr_stmt> <return>return <expr><name>old</name></expr>;</return>}</block></function>

    <expr_stmt><expr><name>XPCWrappedNative</name>* <macro><name>GetResolvingWrapper</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mResolvingWrapper</name></expr>;</return>}</block></expr></expr_stmt>
    <function><type><name>XPCWrappedNative</name>*</type> <name>SetResolvingWrapper</name><parameter_list>(<param><decl><type><name>XPCWrappedNative</name>*</type> <name>w</name></decl></param>)</parameter_list>
        <block>{<decl_stmt><decl><type><name>XPCWrappedNative</name>*</type> <name>old</name> <init>= <expr><name>mResolvingWrapper</name></expr></init></decl>;</decl_stmt>
         <expr_stmt><expr><name>mResolvingWrapper</name> = <name>w</name></expr>;</expr_stmt> <return>return <expr><name>old</name></expr>;</return>}</block></function>

    <function_decl><type><name>void</name></type> <name>Cleanup</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>ReleaseNatives</name><parameter_list>()</parameter_list>;</function_decl>

    <expr_stmt><expr><name>PRBool</name> <macro><name>IsValid</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSContextStack</name> != <name>nsnull</name></expr>;</return>}</block></expr></expr_stmt>

    <function><type><specifier>static</specifier> <name>PRLock</name>*</type> <name>GetLock</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>gLock</name></expr>;</return>}</block></function>
    <comment type="line">// Must be called with the threads locked.</comment>
    <function_decl><type><specifier>static</specifier> <name>XPCPerThreadData</name>*</type> <name>IterateThreads</name><parameter_list>(<param><decl><type><name>XPCPerThreadData</name>**</type> <name>iteratorp</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>AutoMarkingPtr</name>**</type>  <name>GetAutoRootsAdr</name><parameter_list>()</parameter_list> <block>{<return>return <expr>&amp;<name>mAutoRoots</name></expr>;</return>}</block></function>

    <function_decl><type><name>void</name></type> <name>TraceJS</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>MarkAutoRootsAfterJSFinalize</name><parameter_list>()</parameter_list>;</function_decl>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>InitStatics</name><parameter_list>()</parameter_list>
        <block>{ <expr_stmt><expr><name>gLock</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>gThreads</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>gTLSIndex</name> = <name>BAD_TLS_INDEX</name></expr>;</expr_stmt> }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_CHECK_WRAPPER_THREADSAFETY</name></cpp:ifdef>
    <function><type><name>JSUint32</name></type>  <name>IncrementWrappedNativeThreadsafetyReportDepth</name><parameter_list>()</parameter_list>
        <block>{<return>return <expr>++<name>mWrappedNativeThreadsafetyReportDepth</name></expr>;</return>}</block></function>
    <function><type><name>void</name></type>      <name>ClearWrappedNativeThreadsafetyReportDepth</name><parameter_list>()</parameter_list>
        <block>{<expr_stmt><expr><name>mWrappedNativeThreadsafetyReportDepth</name> = 0</expr>;</expr_stmt>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>ShutDown</name><parameter_list>()</parameter_list>
        <block>{<expr_stmt><expr><name>sMainJSThread</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>sMainThreadData</name> = <name>nsnull</name></expr>;</expr_stmt>}</block></function>

    <function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsMainThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
        <block>{ <return>return <expr><name><name>cx</name>-&gt;<name>thread</name></name> == <name>sMainJSThread</name></expr>;</return> }</block></function>

<label><name>private</name>:</label>
    <expr_stmt><expr><call><name>XPCPerThreadData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><specifier>static</specifier> <name>XPCPerThreadData</name>*</type> <name>GetDataImpl</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCJSContextStack</name>*</type>   <name>mJSContextStack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCPerThreadData</name>*</type>    <name>mNextThread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCCallContext</name>*</type>      <name>mCallContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type>                 <name>mResolveName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCWrappedNative</name>*</type>    <name>mResolvingWrapper</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsIExceptionManager</name>*</type> <name>mExceptionManager</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIException</name>*</type>        <name>mException</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>               <name>mExceptionManagerNotAvailable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AutoMarkingPtr</name>*</type>      <name>mAutoRoots</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_CHECK_WRAPPER_THREADSAFETY</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSUint32</name></type>             <name>mWrappedNativeThreadsafetyReportDepth</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>PRThread</name>*</type>            <name>mThread</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>PRLock</name>*</type>           <name>gLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XPCPerThreadData</name>*</type> <name>gThreads</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PRUintn</name></type>           <name>gTLSIndex</name></decl>;</decl_stmt>

    <comment type="line">// Cached value of cx-&gt;thread on the main thread. </comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>void</name> *</type><name>sMainJSThread</name></decl>;</decl_stmt>

    <comment type="line">// Cached per thread data for the main thread. Only safe to access</comment>
    <comment type="line">// if cx-&gt;thread == sMainJSThread.</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>XPCPerThreadData</name> *</type><name>sMainThreadData</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScriptSecurityManager.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>class</name> <name>BackstagePass</name> : <name>public</name> <name>nsIScriptObjectPrincipal</name></expr>,
                      <expr><name>public</name> <name>nsIXPCScriptable</name></expr>,
                      <expr><name>public</name> <name>nsIClassInfo</name>
<block>{
<expr><name>public</name>:
  <name>NS_DECL_ISUPPORTS</name>
  <name>NS_DECL_NSIXPCSCRIPTABLE</name>
  <name>NS_DECL_NSICLASSINFO</name>

  <name>virtual</name> <name>nsIPrincipal</name>* <macro><name>GetPrincipal</name><argument_list>()</argument_list></macro> <block>{
    <return>return <expr><name>mPrincipal</name></expr>;</return></block></expr>
  }</block>

  <call><name>BackstagePass</name><argument_list>(<argument><expr><name>nsIPrincipal</name> *<name>prin</name></expr></argument>)</argument_list></call> :
    <macro><name>mPrincipal</name><argument_list>(<argument>prin</argument>)</argument_list></macro>
  <block>{
  }</block>

  <name>virtual</name> ~<macro><name>BackstagePass</name><argument_list>()</argument_list></macro> <block>{ }</block>

<name>private</name>:
  <name>nsCOMPtr</name>&lt;<name>nsIPrincipal</name>&gt; <name>mPrincipal</name></expr>;</expr_stmt>
};

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>class</name> <name>BackstagePass</name> : <name>public</name> <name>nsIXPCScriptable</name></expr>, <expr><name>public</name> <name>nsIClassInfo</name>
<block>{
<expr><name>public</name>:
  <name>NS_DECL_ISUPPORTS</name>
  <name>NS_DECL_NSIXPCSCRIPTABLE</name>
  <name>NS_DECL_NSICLASSINFO</name>

  <macro><name>BackstagePass</name><argument_list>()</argument_list></macro>
  <block>{
  }</block>

  <name>virtual</name> ~<macro><name>BackstagePass</name><argument_list>()</argument_list></macro> <block>{ }</block></expr>
}</block></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>class</name> <name>nsJSRuntimeServiceImpl</name> : <name>public</name> <name>nsIJSRuntimeService</name></expr>,
                               <expr><name>public</name> <name>nsSupportsWeakReference</name>
<block>{
 <expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIJSRUNTIMESERVICE</name>

    <comment type="line">// This returns an AddRef'd pointer. It does not do this with an out param</comment>
    <comment type="line">// only because this form  is required by generic module macro:</comment>
    <comment type="line">// NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR</comment>
    static <name>nsJSRuntimeServiceImpl</name>* <call><name>GetSingleton</name><argument_list>()</argument_list></call></expr>;

    <expr>static <name>void</name> <call><name>FreeSingleton</name><argument_list>()</argument_list></call></expr>;

    <expr><call><name>nsJSRuntimeServiceImpl</name><argument_list>()</argument_list></call></expr>;
    <expr><name>virtual</name> ~<call><name>nsJSRuntimeServiceImpl</name><argument_list>()</argument_list></call></expr>;

    <expr>static <name>void</name> <macro><name>InitStatics</name><argument_list>()</argument_list></macro> <block>{ <expr><name>gJSRuntimeService</name> = <name>nsnull</name></expr>; }</block>
 <name>protected</name>:
    static <name>nsJSRuntimeServiceImpl</name>* <name>gJSRuntimeService</name></expr>;
    <expr><name>nsCOMPtr</name>&lt;<name>nsIXPCScriptable</name>&gt; <name>mBackstagePass</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// 'Components' object</comment>

<expr_stmt><expr><name>class</name> <name>nsXPCComponents</name> : <name>public</name> <name>nsIXPCComponents</name></expr>,
                        <expr><name>public</name> <name>nsIXPCScriptable</name></expr>,
                        <expr><name>public</name> <name>nsIClassInfo</name></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
                      , <expr><name>public</name> <name>nsISecurityCheckedComponent</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSIXPCCOMPONENTS</name>
    <name>NS_DECL_NSIXPCSCRIPTABLE</name>
    <name>NS_DECL_NSICLASSINFO</name>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
    <name>NS_DECL_NSISECURITYCHECKEDCOMPONENT</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>public</name>:
    static <name>JSBool</name>
    <call><name>AttachNewComponentsObject</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>,
                              <argument><expr><name>XPCWrappedNativeScope</name>* <name>aScope</name></expr></argument>,
                              <argument><expr><name>JSObject</name>* <name>aGlobal</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>void</name> <macro><name>SystemIsBeingShutDown</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>ClearMembers</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>virtual</name> ~<call><name>nsXPCComponents</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <call><name>nsXPCComponents</name><argument_list>()</argument_list></call></expr>;
    <expr><name>void</name> <call><name>ClearMembers</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <name>nsXPCComponents_Interfaces</name>*     <name>mInterfaces</name></expr>;
    <expr><name>nsXPCComponents_InterfacesByID</name>* <name>mInterfacesByID</name></expr>;
    <expr><name>nsXPCComponents_Classes</name>*        <name>mClasses</name></expr>;
    <expr><name>nsXPCComponents_ClassesByID</name>*    <name>mClassesByID</name></expr>;
    <expr><name>nsXPCComponents_Results</name>*        <name>mResults</name></expr>;
    <expr><name>nsXPCComponents_ID</name>*             <name>mID</name></expr>;
    <expr><name>nsXPCComponents_Exception</name>*      <name>mException</name></expr>;
    <expr><name>nsXPCComponents_Constructor</name>*    <name>mConstructor</name></expr>;
    <expr><name>nsXPCComponents_Utils</name>*          <name>mUtils</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************/</comment>

<expr_stmt><expr><name>class</name> <name>nsXPCComponents_Interfaces</name> :
            <name>public</name> <name>nsIScriptableInterfaces</name></expr>,
            <expr><name>public</name> <name>nsIXPCScriptable</name></expr>,
            <expr><name>public</name> <name>nsIClassInfo</name></expr>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
          , <expr><name>public</name> <name>nsISecurityCheckedComponent</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><name>public</name>:
    <comment type="line">// all the interface method declarations...</comment>
    <name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSISCRIPTABLEINTERFACES</name>
    <name>NS_DECL_NSIXPCSCRIPTABLE</name>
    <name>NS_DECL_NSICLASSINFO</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
    <name>NS_DECL_NSISECURITYCHECKEDCOMPONENT</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>public</name>:
    <call><name>nsXPCComponents_Interfaces</name><argument_list>()</argument_list></call></expr>;
    <expr><name>virtual</name> ~<call><name>nsXPCComponents_Interfaces</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <name>nsCOMPtr</name>&lt;<name>nsIInterfaceInfoManager</name>&gt; <name>mManager</name></expr>;
}</block></expr>;</expr_stmt>


<comment type="block">/***************************************************************************/</comment>

<function_decl><type><specifier>extern</specifier> <name>JSObject</name>*</type>
<name>xpc_NewIDObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>jsobj</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsID</name>&amp;</type> <name>aID</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>nsID</name>*</type>
<name>xpc_JSObjectToID</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>xpc_JSObjectIsID</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// in xpcdebug.cpp</comment>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>xpc_DumpJSStack</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>showArgs</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>showLocals</name></decl></param>,
                <param><decl><type><name>JSBool</name></type> <name>showThisProps</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>xpc_DumpEvalInJSStackFrame</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSUint32</name></type> <name>frameno</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>text</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>xpc_DumpJSObject</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>xpc_InstallJSDebuggerKeywordHandler</name><parameter_list>(<param><decl><type><name>JSRuntime</name>*</type> <name>rt</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/***************************************************************************/</comment>

<comment type="line">// Definition of nsScriptError, defined here because we lack a place to put</comment>
<comment type="line">// XPCOM objects associated with the JavaScript engine.</comment>
<expr_stmt><expr><name>class</name> <name>nsScriptError</name> : <name>public</name> <name>nsIScriptError</name> <block>{
<expr><name>public</name>:
    <call><name>nsScriptError</name><argument_list>()</argument_list></call></expr>;

    <expr><name>virtual</name> ~<call><name>nsScriptError</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// TODO - do something reasonable on getting null from these babies.</comment>

    <expr><name>NS_DECL_ISUPPORTS</name>
    <name>NS_DECL_NSICONSOLEMESSAGE</name>
    <name>NS_DECL_NSISCRIPTERROR</name>

<name>private</name>:
    <name>nsString</name> <name>mMessage</name></expr>;
    <expr><name>nsString</name> <name>mSourceName</name></expr>;
    <expr><name>PRUint32</name> <name>mLineNumber</name></expr>;
    <expr><name>nsString</name> <name>mSourceLine</name></expr>;
    <expr><name>PRUint32</name> <name>mColumnNumber</name></expr>;
    <expr><name>PRUint32</name> <name>mFlags</name></expr>;
    <expr><name>nsCString</name> <name>mCategory</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// XXX allowing for future notifications to XPCCallContext</comment>

<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoJSRequest</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoJSRequest</name><argument_list>(<argument>XPCCallContext&amp; aCCX MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>mCCX</name><argument_list>(<argument><expr><name>aCCX</name></expr></argument>)</argument_list></call></expr>, <macro><name>mCX</name><argument_list>(<argument>aCCX.GetJSContext()</argument>)</argument_list></macro> <expr><block>{
        <expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><call><name>BeginRequest</name><argument_list>()</argument_list></call></expr>;
    }</block>
    ~<macro><name>AutoJSRequest</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>EndRequest</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>EndRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><name>mCX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_EndRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>
<name>private</name>:
    <name>void</name> <macro><name>BeginRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><call><name>JS_GetContextThread</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_BeginRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt></else></if>
    }</block></expr></expr_stmt>
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>XPCCallContext</name>&amp;</type> <name>mCCX</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mCX</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoJSSuspendRequest</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoJSSuspendRequest</name><argument_list>(<argument>XPCCallContext&amp; aCCX
                         MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <macro><name>mCX</name><argument_list>(<argument>aCCX.GetJSContext()</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SuspendRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <expr_stmt><expr>~<macro><name>AutoJSSuspendRequest</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>ResumeRequest</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>ResumeRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><name>mCX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ResumeRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>, <argument><expr><name>mDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>
<name>private</name>:
    <name>void</name> <macro><name>SuspendRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><call><name>JS_GetContextThread</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>mDepth</name> = <call><name>JS_SuspendRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt></else></if>
    }</block></expr></expr_stmt>
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mCX</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type> <name>mDepth</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoJSSuspendRequestWithNoCallContext</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoJSSuspendRequestWithNoCallContext</name><argument_list>(<argument>JSContext *aCX
                                          MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <macro><name>mCX</name><argument_list>(<argument>aCX</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SuspendRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <expr_stmt><expr>~<macro><name>AutoJSSuspendRequestWithNoCallContext</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>ResumeRequest</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>ResumeRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><name>mCX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ResumeRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>, <argument><expr><name>mDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>
<name>private</name>:
    <name>void</name> <macro><name>SuspendRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><call><name>JS_GetContextThread</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>mDepth</name> = <call><name>JS_SuspendRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt></else></if>
    }</block></expr></expr_stmt>
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mCX</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type> <name>mDepth</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoJSSuspendNonMainThreadRequest</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoJSSuspendNonMainThreadRequest</name><argument_list>(<argument>JSContext *aCX
                                      MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <macro><name>mCX</name><argument_list>(<argument>aCX</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SuspendRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <expr_stmt><expr>~<macro><name>AutoJSSuspendNonMainThreadRequest</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>ResumeRequest</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>ResumeRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if <condition>(<expr><name>mCX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ResumeRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>, <argument><expr><name>mDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>

<name>private</name>:
    <name>void</name> <macro><name>SuspendRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if <condition>(<expr><name>mCX</name> &amp;&amp; !<name>XPCPerThreadData</name>::<call><name>IsMainThread</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>mDepth</name> = <call><name>JS_SuspendRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt></else></if>
    }</block></expr></expr_stmt>

    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCX</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type> <name>mDepth</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
        

<comment type="block">/*****************************************/</comment>

<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoJSRequestWithNoCallContext</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoJSRequestWithNoCallContext</name><argument_list>(<argument>JSContext* aCX
                                   MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <macro><name>mCX</name><argument_list>(<argument>aCX</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BeginRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <expr_stmt><expr>~<macro><name>AutoJSRequestWithNoCallContext</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>EndRequest</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>EndRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><name>mCX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_EndRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>
<name>private</name>:
    <name>void</name> <macro><name>BeginRequest</name><argument_list>()</argument_list></macro> <block>{
        <if>if<condition>(<expr><call><name>JS_GetContextThread</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_BeginRequest</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>mCX</name> = <name>nsnull</name></expr>;</expr_stmt></else></if>
    }</block></expr></expr_stmt>
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mCX</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoJSErrorAndExceptionEater</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoJSErrorAndExceptionEater</name><argument_list>(<argument>JSContext* aCX
                                 MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <expr_stmt><expr><call><name>mCX</name><argument_list>(<argument><expr><name>aCX</name></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mOldErrorReporter</name><argument_list>(<argument><expr><call><name>JS_SetErrorReporter</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
          <macro><name>mOldExceptionState</name><argument_list>(<argument>JS_SaveExceptionState(mCX)</argument>)</argument_list></macro> <expr><block>{
        <expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>
    ~<macro><name>AutoJSErrorAndExceptionEater</name><argument_list>()</argument_list></macro>
    <block>{
        <expr><call><name>JS_SetErrorReporter</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>, <argument><expr><name>mOldErrorReporter</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_RestoreExceptionState</name><argument_list>(<argument><expr><name>mCX</name></expr></argument>, <argument><expr><name>mOldExceptionState</name></expr></argument>)</argument_list></call></expr>;
    }</block>
<name>private</name>:
    <name>JSContext</name>*        <name>mCX</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSErrorReporter</name></type>   <name>mOldErrorReporter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSExceptionState</name>*</type> <name>mOldExceptionState</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/******************************************************************************
 * Handles pre/post script processing and the setting/resetting the error
 * reporter
 */</comment>
<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoScriptEvaluate</name>
<block>{
<label><name>public</name>:</label>
    <comment type="block">/**
     * Saves the JSContext as well as initializing our state
     * @param cx The JSContext, this can be null, we don't do anything then
     */</comment>
    <macro><name>AutoScriptEvaluate</name><argument_list>(<argument>JSContext * cx MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
         : <expr_stmt><expr><call><name>mJSContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mState</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>mErrorReporterSet</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>,
           <expr><call><name>mEvaluated</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>, <macro><name>mContextHasThread</name><argument_list>(<argument>0</argument>)</argument_list></macro> <expr><block>{
        <expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <comment type="block">/**
     * Does the pre script evaluation and sets the error reporter if given
     * This function should only be called once, and will assert if called
     * more than once
     * @param errorReporter the error reporter callback function to set
     */</comment>

    <name>void</name> <macro><name>StartEvaluating</name><argument_list>(<argument>JSErrorReporter errorReporter = nsnull</argument>)</argument_list></macro></expr>;</expr_stmt>
    <comment type="block">/**
     * Does the post script evaluation and resets the error reporter
     */</comment>
    <expr_stmt><expr>~<call><name>AutoScriptEvaluate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mJSContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSExceptionState</name>*</type> <name>mState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mErrorReporterSet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mEvaluated</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsword</name></type> <name>mContextHasThread</name></decl>;</decl_stmt>
    <function_decl><type><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></type>

    <comment type="line">// No copying or assignment allowed</comment>
    <name>AutoScriptEvaluate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>AutoScriptEvaluate</name> &amp;</type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>AutoScriptEvaluate</name> &amp;</type> <name>operator</name> <init>=<expr>(const <name>AutoScriptEvaluate</name> &amp;)</expr></init></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>AutoResolveName</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>AutoResolveName</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>, <argument>jsid name
                    MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <expr_stmt><expr><call><name>mTLS</name><argument_list>(<argument><expr><call><name><name>ccx</name>.<name>GetThreadData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
          <expr><call><name>mOld</name><argument_list>(<argument><expr><call><name><name>mTLS</name>-&gt;<name>SetResolveName</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
          <macro><name>mCheck</name><argument_list>(<argument>name</argument>)</argument_list></macro> <expr><block>{
        <expr><name>MOZILLA_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>
    ~<macro><name>AutoResolveName</name><argument_list>()</argument_list></macro>
        <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <expr><name>jsid</name> <name>old</name> = 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <call><name><name>mTLS</name>-&gt;<name>SetResolveName</name></name><argument_list>(<argument><expr><name>mOld</name></expr></argument>)</argument_list></call></expr>;
            <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>old</name> == <name>mCheck</name></expr></argument>, <argument><expr>"Bad Nesting!"</expr></argument>)</argument_list></call></expr>;
        }</block>

<name>private</name>:
    <name>XPCPerThreadData</name>* <name>mTLS</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jsid</name></type> <name>mOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type> <name>mCheck</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>MOZILLA_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/***************************************************************************/</comment>
<decl_stmt><decl><type><name>class</name></type> <name>XPCMarkableJSVal</name>
<block>{
<label><name>public</name>:</label>
    <macro><name>XPCMarkableJSVal</name><argument_list>(<argument>jsval val</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>mVal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>, <macro><name>mValPtr</name><argument_list>(<argument>&amp;mVal</argument>)</argument_list></macro> <expr><block>{}</block>
    <call><name>XPCMarkableJSVal</name><argument_list>(<argument><expr><name>jsval</name> *<name>pval</name></expr></argument>)</argument_list></call> : <call><name>mVal</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr>, <macro><name>mValPtr</name><argument_list>(<argument>pval</argument>)</argument_list></macro> <expr><block>{}</block>
    ~<macro><name>XPCMarkableJSVal</name><argument_list>()</argument_list></macro> <block>{}</block>
    <name>void</name> <macro><name>Mark</name><argument_list>()</argument_list></macro> <block>{}</block>
    <name>void</name> <macro><name>TraceJS</name><argument_list>(<argument>JSTracer* trc</argument>)</argument_list></macro>
    <block>{
        <expr><call><name>JS_CALL_VALUE_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>*<name>mValPtr</name></expr></argument>, <argument><expr>"XPCMarkableJSVal"</expr></argument>)</argument_list></call></expr>;
    }</block>
    <name>void</name> <macro><name>AutoTrace</name><argument_list>(<argument>JSTracer* trc</argument>)</argument_list></macro> <block>{}</block>
<name>private</name>:
    <call><name>XPCMarkableJSVal</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// not implemented    </comment>
    <decl_stmt><decl><type><name>jsval</name></type>  <name>mVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>mValPtr</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt> 

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// AutoMarkingPtr is the base class for the various AutoMarking pointer types </comment>
<comment type="line">// below. This system allows us to temporarily protect instances of our garbage </comment>
<comment type="line">// collected types after they are constructed but before they are safely </comment>
<comment type="line">// attached to other rooted objects.</comment>
<comment type="line">// This base class has pure virtual support for marking. </comment>

<decl_stmt><decl><type><name>class</name></type> <name>AutoMarkingPtr</name>
<block>{
<label><name>public</name>:</label>
    <expr_stmt><expr><call><name>AutoMarkingPtr</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>)</argument_list></call>
        : <call><name>mNext</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>, <macro><name>mTLS</name><argument_list>(<argument>ccx.GetThreadData()</argument>)</argument_list></macro> <expr><block>{<expr><call><name>Link</name><argument_list>()</argument_list></call></expr>;}</block>
    <call><name>AutoMarkingPtr</name><argument_list>()</argument_list></call>
        : <call><name>mNext</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>, <macro><name>mTLS</name><argument_list>(<argument>nsnull</argument>)</argument_list></macro> <expr><block>{}</block>

    <name>virtual</name> ~<macro><name>AutoMarkingPtr</name><argument_list>()</argument_list></macro> <block>{<expr><call><name>Unlink</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>Init</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>)</argument_list></macro>
        <block>{<expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mTLS</name></expr></argument>, <argument><expr>"Already init'ed!"</expr></argument>)</argument_list></call></expr>;
         <expr><name>mTLS</name> = <call><name><name>ccx</name>.<name>GetThreadData</name></name><argument_list>()</argument_list></call></expr>;
         <expr><call><name>Link</name><argument_list>()</argument_list></call></expr>;}</block>

    <name>void</name> <macro><name>Link</name><argument_list>()</argument_list></macro> 
        <block>{<if>if<condition>(<expr>!<name>mTLS</name></expr>)</condition><then> <return>return;</return></then></if>
         <name>AutoMarkingPtr</name>** <name>list</name> = <call><name><name>mTLS</name>-&gt;<name>GetAutoRootsAdr</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt> 
         <expr_stmt><expr><name>mNext</name> = *<name>list</name></expr>;</expr_stmt> <expr_stmt><expr>*<name>list</name> = <name>this</name></expr>;</expr_stmt>}</block></decl></decl_stmt>

    <function><type><name>void</name></type> <name>Unlink</name><parameter_list>()</parameter_list> 
        <block>{<if>if<condition>(<expr>!<name>mTLS</name></expr>)</condition><then> <return>return;</return></then></if>
         <decl_stmt><decl><type><name>AutoMarkingPtr</name>**</type> <name>cur</name> <init>= <expr><call><name><name>mTLS</name>-&gt;<name>GetAutoRootsAdr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 
         <while>while<condition>(<expr>*<name>cur</name> != <name>this</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>*<name>cur</name></expr></argument>, <argument><expr>"This object not in list!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cur</name> = &amp;<name>(*<name>cur</name>)-&gt;<name>mNext</name></name></expr>;</expr_stmt>
         }</block></while>
         <expr_stmt><expr>*<name>cur</name> = <name>mNext</name></expr>;</expr_stmt>
         <expr_stmt><expr><name>mTLS</name> = <name>nsnull</name></expr>;</expr_stmt>
        }</block></function>

    <function><type><name>AutoMarkingPtr</name>*</type> <name>GetNext</name><parameter_list>()</parameter_list> <block>{<return>return <expr><name>mNext</name></expr>;</return>}</block></function>
    
    <decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>TraceJS</name><argument_list>(<argument><expr><name>JSTracer</name>* <name>trc</name></expr></argument>)</argument_list> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>virtual</name> <name>void</name> <call><name>MarkAfterJSFinalize</name><argument_list>()</argument_list></call> = 0</expr>;</expr_stmt>

<label><name>protected</name>:</label>
    <decl_stmt><decl><type><name>AutoMarkingPtr</name>*</type> <name>mNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>XPCPerThreadData</name>*</type> <name>mTLS</name></decl>;</decl_stmt>
};

<comment type="line">// More joy of macros...</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><parameter_list>(<param><type><name>class_</name></type></param>, <param><type><name>type_</name></type></param>)</parameter_list></cpp:macro>                          \
<cpp:value>class class_ : public AutoMarkingPtr                                         \
{                                                                            \
public:                                                                      \
    class_ ()                                                                \
        : AutoMarkingPtr(), mPtr(nsnull) {}                                  \
    class_ (XPCCallContext&amp; ccx, type_ * ptr = nsnull)                       \
        : AutoMarkingPtr(ccx), mPtr(ptr) {}                                  \
    virtual ~ class_ () {}                                                   \
                                                                             \
    virtual void TraceJS(JSTracer* trc)                                      \
        {if(mPtr) {                                                          \
           mPtr-&gt;TraceJS(trc);                                               \
           mPtr-&gt;AutoTrace(trc);                                             \
         }                                                                   \
         if(mNext) mNext-&gt;TraceJS(trc);}                                     \
                                                                             \
    virtual void MarkAfterJSFinalize()                                       \
        {if(mPtr) mPtr-&gt;Mark();                                              \
         if(mNext) mNext-&gt;MarkAfterJSFinalize();}                            \
                                                                             \
    type_ * get()        const  {return mPtr;}                               \
    operator type_ *()   const  {return mPtr;}                               \
    type_ * operator-&gt;() const  {return mPtr;}                               \
                                                                             \
    class_ &amp; operator =(type_ * p)                                           \
        {NS_ASSERTION(mTLS, "Hasn't been init'ed!");                         \
         mPtr = p; return *this;}                                            \
                                                                             \
protected:                                                                   \
    type_ * mPtr;                                                            \
};</cpp:value></cpp:define>

<comment type="line">// Use the macro above to define our AutoMarking types...</comment>

<macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><argument_list>(<argument>AutoMarkingNativeInterfacePtr</argument>, <argument>XPCNativeInterface</argument>)</argument_list></macro>
<macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><argument_list>(<argument>AutoMarkingNativeSetPtr</argument>, <argument>XPCNativeSet</argument>)</argument_list></macro>
<macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><argument_list>(<argument>AutoMarkingWrappedNativePtr</argument>, <argument>XPCWrappedNative</argument>)</argument_list></macro>
<macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><argument_list>(<argument>AutoMarkingWrappedNativeTearOffPtr</argument>, <argument>XPCWrappedNativeTearOff</argument>)</argument_list></macro>
<macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><argument_list>(<argument>AutoMarkingWrappedNativeProtoPtr</argument>, <argument>XPCWrappedNativeProto</argument>)</argument_list></macro>
<macro><name>DEFINE_AUTO_MARKING_PTR_TYPE</name><argument_list>(<argument>AutoMarkingJSVal</argument>, <argument>XPCMarkableJSVal</argument>)</argument_list></macro>
                                    
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_AUTO_MARKING_ARRAY_PTR_TYPE</name><parameter_list>(<param><type><name>class_</name></type></param>, <param><type><name>type_</name></type></param>)</parameter_list></cpp:macro>                    \
<cpp:value>class class_ : public AutoMarkingPtr                                         \
{                                                                            \
public:                                                                      \
    class_ (XPCCallContext&amp; ccx)                                             \
        : AutoMarkingPtr(ccx), mPtr(nsnull), mCount(0) {}                    \
    class_ (XPCCallContext&amp; ccx, type_** aPtr, PRUint32 aCount,              \
            PRBool aClear = PR_FALSE)                                        \
        : AutoMarkingPtr(ccx), mPtr(aPtr), mCount(aCount)                    \
    {                                                                        \
        if(!mPtr) mCount = 0;                                                \
        else if(aClear) memset(mPtr, 0, mCount*sizeof(type_*));              \
    }                                                                        \
    virtual ~ class_ () {}                                                   \
                                                                             \
    virtual void TraceJS(JSTracer* trc)                                      \
    {                                                                        \
        for(PRUint32 i = 0; i &lt; mCount; ++i)                                 \
        {                                                                    \
            type_* cur = mPtr[i];                                            \
            if(cur)                                                          \
            {                                                                \
                cur-&gt;TraceJS(trc);                                           \
                cur-&gt;AutoTrace(trc);                                         \
            }                                                                \
        }                                                                    \
        if(mNext) mNext-&gt;TraceJS(trc);                                       \
    }                                                                        \
                                                                             \
    virtual void MarkAfterJSFinalize()                                       \
    {                                                                        \
        for(PRUint32 i = 0; i &lt; mCount; ++i)                                 \
        {                                                                    \
            type_* cur = mPtr[i];                                            \
            if(cur)                                                          \
                cur-&gt;Mark();                                                 \
        }                                                                    \
        if(mNext) mNext-&gt;MarkAfterJSFinalize();                              \
    }                                                                        \
                                                                             \
    type_ ** get()       const  {return mPtr;}                               \
    operator type_ **()  const  {return mPtr;}                               \
    type_ ** operator-&gt;() const  {return mPtr;}                              \
                                                                             \
    class_ &amp; operator =(const class_ &amp; inst)                                 \
        {mPtr = inst.mPtr; mCount = inst.mCount; return *this;}              \
                                                                             \
protected:                                                                   \
    type_ ** mPtr;                                                           \
    PRUint32 mCount;                                                         \
};</cpp:value></cpp:define>

<macro><name>DEFINE_AUTO_MARKING_ARRAY_PTR_TYPE</name><argument_list>(<argument>AutoMarkingNativeInterfacePtrArrayPtr</argument>,
                                   <argument>XPCNativeInterface</argument>)</argument_list></macro>
    
<comment type="line">// Note: It looked like I would need one of these AutoMarkingPtr types for</comment>
<comment type="line">// XPCNativeScriptableInfo in order to manage marking its </comment>
<comment type="line">// XPCNativeScriptableShared member during construction. But AFAICT we build</comment>
<comment type="line">// these and bind them to rooted things so immediately that this just is not</comment>
<comment type="line">// needed.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTO_MARK_JSVAL_HELPER2</name><parameter_list>(<param><type><name>tok</name></type></param>, <param><type><name>line</name></type></param>)</parameter_list></cpp:macro> <cpp:value>tok##line</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTO_MARK_JSVAL_HELPER</name><parameter_list>(<param><type><name>tok</name></type></param>, <param><type><name>line</name></type></param>)</parameter_list></cpp:macro> <cpp:value>AUTO_MARK_JSVAL_HELPER2(tok, line)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTO_MARK_JSVAL</name><parameter_list>(<param><type><name>ccx</name></type></param>, <param><type><name>val</name></type></param>)</parameter_list></cpp:macro>                                            \
    <cpp:value>XPCMarkableJSVal AUTO_MARK_JSVAL_HELPER(_val_,__LINE__)(val);            \
    AutoMarkingJSVal AUTO_MARK_JSVAL_HELPER(_automarker_,__LINE__)           \
    (ccx, &amp;AUTO_MARK_JSVAL_HELPER(_val_,__LINE__))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_USE_SECURITY_CHECKED_COMPONENT</name></cpp:ifdef>
<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Allocates a string that grants all access ("AllAccess")</comment>

<function_decl><type><specifier>extern</specifier> <name>char</name>*</type> <name>xpc_CloneAllAccess</name><parameter_list>()</parameter_list>;</function_decl>
<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Returns access if wideName is in list</comment>

<function_decl><type><specifier>extern</specifier> <name>char</name> *</type> <name>xpc_CheckAccessList</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>wideName</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name><name>list</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// in xpcvariant.cpp...</comment>

<comment type="line">// {1809FD50-91E8-11d5-90F9-0010A4E73D9A}</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XPCVARIANT_IID</name></cpp:macro> \
    <cpp:value>{0x1809fd50, 0x91e8, 0x11d5, \
      { 0x90, 0xf9, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a } }</cpp:value></cpp:define>

<expr_stmt><expr><name>class</name> <name>XPCVariant</name> : <name>public</name> <name>nsIVariant</name>
<block>{
<expr><name>public</name>:
    <name>NS_DECL_CYCLE_COLLECTING_ISUPPORTS</name>
    <name>NS_DECL_NSIVARIANT</name>
    <macro><name>NS_DECL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>XPCVariant</argument>)</argument_list></macro>

    <comment type="line">// If this class ever implements nsIWritableVariant, take special care with</comment>
    <comment type="line">// the case when mJSVal is JSVAL_STRING, since we don't own the data in</comment>
    <comment type="line">// that case.</comment>

    <comment type="line">// We #define and iid so that out module local code can use QI to detect </comment>
    <comment type="line">// if a given nsIVariant is in fact an XPCVariant. </comment>
    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>XPCVARIANT_IID</argument>)</argument_list></macro>

    static <name>XPCVariant</name>* <macro><name>newVariant</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>, <argument>jsval aJSVal</argument>)</argument_list></macro></expr>;

    <comment type="block">/**
     * nsIVariant exposes a GetAsJSVal() method, which also returns mJSVal.
     * But if you can, you should call this one, since it can be inlined.
     */</comment>
    <expr><name>jsval</name> <macro><name>GetJSVal</name><argument_list>()</argument_list></macro> const <block>{<return>return <expr><name>mJSVal</name></expr>;</return></block></expr>}</block>

    <macro><name>XPCVariant</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>, <argument>jsval aJSVal</argument>)</argument_list></macro></expr>;</expr_stmt>

    <comment type="block">/**
     * Convert a variant into a jsval.
     *
     * @param ccx the context for the whole procedure
     * @param variant the variant to convert
     * @param scope the default scope to put on the new JSObject's parent chain
     * @param pErr [out] relevant error code, if any.
     * @param pJSVal [out] the resulting jsval.
     */</comment>    
    <function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>VariantDataToJS</name><parameter_list>(<param><decl><type><name>XPCLazyCallContext</name>&amp;</type> <name>lccx</name></decl></param>, 
                                  <param><decl><type><name>nsIVariant</name>*</type> <name>variant</name></decl></param>,
                                  <param><decl><type><name>JSObject</name>*</type> <name>scope</name></decl></param>, <param><decl><type><name>nsresult</name>*</type> <name>pErr</name></decl></param>,
                                  <param><decl><type><name>jsval</name>*</type> <name>pJSVal</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
    <expr_stmt><expr><name>virtual</name> ~<macro><name>XPCVariant</name><argument_list>()</argument_list></macro> <block>{ }</block>

    <name>JSBool</name> <call><name>InitializeData</name><argument_list>(<argument><expr><name>XPCCallContext</name>&amp; <name>ccx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>protected</name>:</label>
    <decl_stmt><decl><type><name>nsDiscriminatedUnion</name></type> <name>mData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type>                <name>mJSVal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>               <name>mReturnRawObject</name></decl>;</decl_stmt>
};

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>XPCVariant</argument>, <argument>XPCVARIANT_IID</argument>)</argument_list></macro>

<expr_stmt><expr><name>class</name> <name>XPCTraceableVariant</name>: <name>public</name> <name>XPCVariant</name></expr>,
                           <expr><name>public</name> <name>XPCRootSetElem</name>
<block>{
<expr><name>public</name>:
    <macro><name>XPCTraceableVariant</name><argument_list>(<argument>XPCCallContext&amp; ccx</argument>, <argument>jsval aJSVal</argument>)</argument_list></macro>
        : <macro><name>XPCVariant</name><argument_list>(<argument>ccx</argument>, <argument>aJSVal</argument>)</argument_list></macro>
    <block>{
        <expr><call><name><name>ccx</name>.<name>GetRuntime</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AddVariantRoot</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>virtual</name> ~<call><name>XPCTraceableVariant</name><argument_list>()</argument_list></call></expr>;

    <expr><name>void</name> <call><name>TraceJS</name><argument_list>(<argument><expr><name>JSTracer</name>* <name>trc</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr>static <name>void</name> <macro><name>PrintTraceName</name><argument_list>(<argument>JSTracer* trc</argument>, <argument>char *buf</argument>, <argument>size_t bufsize</argument>)</argument_list></macro></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>;</expr_stmt>

<comment type="block">/***************************************************************************/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINCIPALHOLDER_IID</name></cpp:macro> \
<cpp:value>{0xbf109f49, 0xf94a, 0x43d8, {0x93, 0xdb, 0xe4, 0x66, 0x49, 0xc5, 0xd9, 0x7d}}</cpp:value></cpp:define>

<expr_stmt><expr><name>class</name> <name>PrincipalHolder</name> : <name>public</name> <name>nsIScriptObjectPrincipal</name>
<block>{
<expr><name>public</name>:
    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>PRINCIPALHOLDER_IID</argument>)</argument_list></macro>

    <call><name>PrincipalHolder</name><argument_list>(<argument><expr><name>nsIPrincipal</name> *<name>holdee</name></expr></argument>)</argument_list></call>
        : <macro><name>mHoldee</name><argument_list>(<argument>holdee</argument>)</argument_list></macro>
    <block>{
    }</block>
    <name>virtual</name> ~<macro><name>PrincipalHolder</name><argument_list>()</argument_list></macro> <block>{ }</block>

    <name>NS_DECL_ISUPPORTS</name>

    <name>nsIPrincipal</name> *<call><name>GetPrincipal</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name>:
    <name>nsCOMPtr</name>&lt;<name>nsIPrincipal</name>&gt; <name>mHoldee</name></expr>;
}</block></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument><expr><name>PrincipalHolder</name></expr></argument>, <argument><expr><name>PRINCIPALHOLDER_IID</name></expr></argument>)</argument_list></call>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !XPCONNECT_STANDALONE */</comment>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Utilities</comment>

inline <name>void</name> *
<macro><name>xpc_GetJSPrivate</name><argument_list>(<argument>JSObject *obj</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>XPCONNECT_STANDALONE</name></cpp:ifndef>

<comment type="line">// Helper for creating a sandbox object to use for evaluating</comment>
<comment type="line">// untrusted code completely separated from all other code in the</comment>
<comment type="line">// system using xpc_EvalInSandbox(). Takes the JSContext on which to</comment>
<comment type="line">// do setup etc on, puts the sandbox object in *vp (which must be</comment>
<comment type="line">// rooted by the caller), and uses the principal that's either</comment>
<comment type="line">// directly passed in prinOrSop or indirectly as an</comment>
<comment type="line">// nsIScriptObjectPrincipal holding the principal. If no principal is</comment>
<comment type="line">// reachable through prinOrSop, a new null principal will be created</comment>
<comment type="line">// and used.</comment>
<function_decl><type><name>nsresult</name></type>
<name>xpc_CreateSandboxObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type> <name>cx</name></decl></param>, <param><decl><type><name>jsval</name> *</type> <name>vp</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>prinOrSop</name></decl></param>)</parameter_list>;</function_decl>

<comment type="line">// Helper for evaluating scripts in a sandbox object created with</comment>
<comment type="line">// xpc_CreateSandboxObject(). The caller is responsible of ensuring</comment>
<comment type="line">// that *rval doesn't get collected during the call or usage after the</comment>
<comment type="line">// call. This helper will use filename and lineNo for error reporting,</comment>
<comment type="line">// and if no filename is provided it will use the codebase from the</comment>
<comment type="line">// principal and line number 1 as a fallback. if returnStringOnly is</comment>
<comment type="line">// true, then the result in *rval, or the exception in cx-&gt;exception</comment>
<comment type="line">// will be coerced into strings. If an exception is thrown converting</comment>
<comment type="line">// an exception to a string, evalInSandbox will return an NS_ERROR_*</comment>
<comment type="line">// result, and cx-&gt;exception will be empty.</comment>
<function_decl><type><name>nsresult</name></type>
<name>xpc_EvalInSandbox</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>sandbox</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>source</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>lineNo</name></decl></param>,
                  <param><decl><type><name>JSVersion</name></type> <name>jsVersion</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>returnStringOnly</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !XPCONNECT_STANDALONE */</comment>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Inlined utilities.</comment>

<function_decl><type><specifier>inline</specifier> <name>JSBool</name></type>
<name>xpc_ForcePropertyResolve</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>inline</specifier> <name>jsid</name></type>
<name>GetRTIdByIndex</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>inline</specifier> <name>jsval</name></type>
<name>GetRTStringByIndex</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>)</parameter_list>;</function_decl>

<comment type="line">// Wrapper for JS_NewObject to mark the new object as system when parent is</comment>
<comment type="line">// also a system object.</comment>
<function_decl><type><specifier>inline</specifier> <name>JSObject</name>*</type>
<name>xpc_NewSystemInheritingJSObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSClass</name> *</type><name>clasp</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>proto</name></decl></param>,
                                <param><decl><type><name>JSObject</name> *</type><name>parent</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>inline</specifier> <name>JSBool</name></type>
<name>xpc_SameScope</name><parameter_list>(<param><decl><type><name>XPCWrappedNativeScope</name> *</type><name>objectscope</name></decl></param>,
              <param><decl><type><name>XPCWrappedNativeScope</name> *</type><name>xpcscope</name></decl></param>,
              <param><decl><type><name>JSBool</name> *</type><name>sameOrigin</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>nsISupports</name> *</type>
<name>XPC_GetIdentityObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XPC_IDISPATCH_SUPPORT</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
<comment type="block">/* defined static near the top here */</comment>
<function><type><name>FARPROC</name></type> <name>GetProcAddressA</name><parameter_list>(<param><decl><type><name>HMODULE</name></type> <name>hMod</name></decl></param>, <param><decl><type><name>wchar_t</name> *</type><name>procName</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>FARPROC</name></type> <name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>wcslen</name><argument_list>(<argument><expr><name>procName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><name>new</name> <name><name>char</name><index>[<expr><name>len</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>) <name><name>procName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>ret</name> = ::<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hMod</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>delete</name> <index>[]</index></type> <name>s</name></decl>;</decl_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WINCE */</comment>


<comment type="line">// IDispatch specific classes</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"XPCDispPrivate.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Inlines use the above - include last.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpcinlines.h"</cpp:file></cpp:include>

<comment type="block">/***************************************************************************/</comment>
<comment type="line">// Maps have inlines that use the above - include last.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xpcmaps.h"</cpp:file></cpp:include>

<comment type="block">/***************************************************************************/</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* xpcprivate_h___ */</comment>
</unit>
