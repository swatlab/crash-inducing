<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00439e0431789bbf86fc02e4b449167491798da8.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Laurent Jouanneau &lt;laurent.jouanneau@disruptive-innovations.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * nsIContentSerializer implementation that can be used with an
 * nsIDocumentEncoder to convert an XML DOM to an XML string that
 * could be parsed into more or less the original DOM.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>nsXMLContentSerializer_h__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsXMLContentSerializer_h__</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContentSerializer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupportsUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIParser.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kIndentStr</name></cpp:macro> <cpp:value>NS_LITERAL_STRING("  ")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kEndTag</name></cpp:macro> <cpp:value>NS_LITERAL_STRING("&lt;/")</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>nsIDOMNode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIAtom</name></decl>;</decl_stmt>

<expr_stmt><expr><name>class</name> <name>nsXMLContentSerializer</name> : <name>public</name> <name>nsIContentSerializer</name> <block>{
 <expr><name>public</name>:
  <call><name>nsXMLContentSerializer</name><argument_list>()</argument_list></call></expr>;
  <expr><name>virtual</name> ~<call><name>nsXMLContentSerializer</name><argument_list>()</argument_list></call></expr>;

  <expr><name>NS_DECL_ISUPPORTS</name>

  <name>NS_IMETHOD</name> <macro><name>Init</name><argument_list>(<argument>PRUint32 flags</argument>, <argument>PRUint32 aWrapColumn</argument>,
                  <argument>const char* aCharSet</argument>, <argument>PRBool aIsCopying</argument>,
                  <argument>PRBool aRewriteEncodingDeclaration</argument>)</argument_list></macro></expr>;

  <expr><name>NS_IMETHOD</name> <macro><name>AppendText</name><argument_list>(<argument>nsIContent* aText</argument>, <argument>PRInt32 aStartOffset</argument>,
                        <argument>PRInt32 aEndOffset</argument>, <argument>nsAString&amp; aStr</argument>)</argument_list></macro></expr>;

  <expr><name>NS_IMETHOD</name> <macro><name>AppendCDATASection</name><argument_list>(<argument>nsIContent* aCDATASection</argument>,
                                <argument>PRInt32 aStartOffset</argument>, <argument>PRInt32 aEndOffset</argument>,
                                <argument>nsAString&amp; aStr</argument>)</argument_list></macro></expr>;

  <expr><name>NS_IMETHOD</name> <macro><name>AppendProcessingInstruction</name><argument_list>(<argument>nsIContent* aPI</argument>,
                                         <argument>PRInt32 aStartOffset</argument>,
                                         <argument>PRInt32 aEndOffset</argument>,
                                         <argument>nsAString&amp; aStr</argument>)</argument_list></macro></expr>;

  <expr><name>NS_IMETHOD</name> <macro><name>AppendComment</name><argument_list>(<argument>nsIContent* aComment</argument>, <argument>PRInt32 aStartOffset</argument>,
                           <argument>PRInt32 aEndOffset</argument>, <argument>nsAString&amp; aStr</argument>)</argument_list></macro></expr>;
  
  <expr><name>NS_IMETHOD</name> <call><name>AppendDoctype</name><argument_list>(<argument><expr><name>nsIContent</name> *<name>aDoctype</name></expr></argument>,
                           <argument><expr><name>nsAString</name>&amp; <name>aStr</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>NS_IMETHOD</name> <call><name>AppendElementStart</name><argument_list>(<argument><expr><name>nsIContent</name> *<name>aElement</name></expr></argument>,
                                <argument><expr><name>nsIContent</name> *<name>aOriginalElement</name></expr></argument>,
                                <argument><expr><name>nsAString</name>&amp; <name>aStr</name></expr></argument>)</argument_list></call></expr>;
  
  <expr><name>NS_IMETHOD</name> <call><name>AppendElementEnd</name><argument_list>(<argument><expr><name>nsIContent</name> *<name>aElement</name></expr></argument>,
                              <argument><expr><name>nsAString</name>&amp; <name>aStr</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>NS_IMETHOD</name> <macro><name>Flush</name><argument_list>(<argument>nsAString&amp; aStr</argument>)</argument_list></macro> <block>{ <return>return <expr><name>NS_OK</name></expr>;</return></block></expr> }</block>

  <name>NS_IMETHOD</name> <call><name>AppendDocumentStart</name><argument_list>(<argument><expr><name>nsIDocument</name> *<name>aDocument</name></expr></argument>,
                                 <argument><expr><name>nsAString</name>&amp; <name>aStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>protected</name>:</label>

  <comment type="block">/**
   * Appends a PRUnichar string and increments the column position
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendToString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aStr</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type> <name>aLength</name></decl></param>,
                              <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Appends a PRUnichar character and increments the column position
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendToString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name>aChar</name></decl></param>,
                              <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Appends a nsAString string and increments the column position
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendToString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                              <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Appends a string by replacing all line-endings
   * by mLineBreak, except in the case of raw output.
   * It increments the column position.
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendToStringConvertLF</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                                       <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Appends a string by wrapping it when necessary.
   * It updates the column position.
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendToStringWrapped</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsASingleFragmentString</name>&amp;</type> <name>aStr</name></decl></param>,
                                     <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Appends a string by formating and wrapping it when necessary
   * It updates the column position.
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendToStringFormatedWrapped</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsASingleFragmentString</name>&amp;</type> <name>aStr</name></decl></param>,
                                             <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// used by AppendToStringWrapped</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>AppendWrapped_WhitespaceSequence</name><argument_list>(
          <argument><expr><name>nsASingleFragmentString</name>::<name>const_char_iterator</name> &amp;<name>aPos</name></expr></argument>,
          <argument><expr>const <name>nsASingleFragmentString</name>::<name>const_char_iterator</name> <name>aEnd</name></expr></argument>,
          <argument><expr>const <name>nsASingleFragmentString</name>::<name>const_char_iterator</name> <name>aSequenceStart</name></expr></argument>,
          <argument><expr><name>nsAString</name> &amp;<name>aOutputStr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="line">// used by AppendToStringFormatedWrapped</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>AppendFormatedWrapped_WhitespaceSequence</name><argument_list>(
          <argument><expr><name>nsASingleFragmentString</name>::<name>const_char_iterator</name> &amp;<name>aPos</name></expr></argument>,
          <argument><expr>const <name>nsASingleFragmentString</name>::<name>const_char_iterator</name> <name>aEnd</name></expr></argument>,
          <argument><expr>const <name>nsASingleFragmentString</name>::<name>const_char_iterator</name> <name>aSequenceStart</name></expr></argument>,
          <argument><expr><name>PRBool</name> &amp;<name>aMayIgnoreStartOfLineWhitespaceSequence</name></expr></argument>,
          <argument><expr><name>nsAString</name> &amp;<name>aOutputStr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="line">// used by AppendToStringWrapped and AppendToStringFormatedWrapped</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>AppendWrapped_NonWhitespaceSequence</name><argument_list>(
          <argument><expr><name>nsASingleFragmentString</name>::<name>const_char_iterator</name> &amp;<name>aPos</name></expr></argument>,
          <argument><expr>const <name>nsASingleFragmentString</name>::<name>const_char_iterator</name> <name>aEnd</name></expr></argument>,
          <argument><expr>const <name>nsASingleFragmentString</name>::<name>const_char_iterator</name> <name>aSequenceStart</name></expr></argument>,
          <argument><expr><name>PRBool</name> &amp;<name>aMayIgnoreStartOfLineWhitespaceSequence</name></expr></argument>,
          <argument><expr><name>PRBool</name> &amp;<name>aSequenceStartAfterAWhiteSpace</name></expr></argument>,
          <argument><expr><name>nsAString</name> &amp;<name>aOutputStr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="block">/**
   * add mLineBreak to the string
   * It updates the column position and other flags.
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendNewLineToString</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>


  <comment type="block">/**
   * Appends a string by translating entities
   * It doesn't increment the column position
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendAndTranslateEntities</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                                          <param><decl><type><name>nsAString</name>&amp;</type> <name>aOutputStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * retrieve the text content of the node and append it to the given string
   * It doesn't increment the column position
   */</comment>
  <function_decl><type><name>nsresult</name></type> <name>AppendTextData</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aNode</name></decl></param>,
                          <param><decl><type><name>PRInt32</name></type> <name>aStartOffset</name></decl></param>,
                          <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                          <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type> <name>aTranslateEntities</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>virtual</name> <name>nsresult</name></type> <name>PushNameSpaceDecl</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aPrefix</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aURI</name></decl></param>,
                                     <param><decl><type><name>nsIContent</name>*</type> <name>aOwner</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>PopNameSpaceDeclsFor</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aOwner</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * The problem that ConfirmPrefix fixes is that anyone can insert nodes
   * through the DOM that have a namespace URI and a random or empty or
   * previously existing prefix that's totally unrelated to the prefixes
   * declared at that point through xmlns attributes.  So what ConfirmPrefix
   * does is ensure that we can map aPrefix to the namespace URI aURI (for
   * example, that the prefix is not already mapped to some other namespace).
   * aPrefix will be adjusted, if necessary, so the value of the prefix
   * _after_ this call is what should be serialized.
   * @param aPrefix the prefix that may need adjusting
   * @param aURI the namespace URI we want aPrefix to point to
   * @param aElement the element we're working with (needed for proper default
   *                 namespace handling)
   * @param aIsAttribute PR_TRUE if we're confirming a prefix for an attribute.
   * @return PR_TRUE if we need to push the (prefix, uri) pair on the namespace
   *                 stack (note that this can happen even if the prefix is
   *                 empty).
   */</comment>
  <function_decl><type><name>PRBool</name></type> <name>ConfirmPrefix</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aPrefix</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aURI</name></decl></param>,
                       <param><decl><type><name>nsIContent</name>*</type> <name>aElement</name></decl></param>,
                       <param><decl><type><name>PRBool</name></type> <name>aIsAttribute</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * GenerateNewPrefix generates a new prefix and writes it to aPrefix
   */</comment>
  <function_decl><type><name>void</name></type> <name>GenerateNewPrefix</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aPrefix</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRUint32</name></type> <name>ScanNamespaceDeclarations</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                     <param><decl><type><name>nsIContent</name> *</type><name>aOriginalElement</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aTagNamespaceURI</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>virtual</name> <name>void</name></type> <name>SerializeAttributes</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>,
                                   <param><decl><type><name>nsIContent</name> *</type><name>aOriginalElement</name></decl></param>,
                                   <param><decl><type><name>nsAString</name>&amp;</type> <name>aTagPrefix</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aTagNamespaceURI</name></decl></param>,
                                   <param><decl><type><name>nsIAtom</name>*</type> <name>aTagName</name></decl></param>,
                                   <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                                   <param><decl><type><name>PRUint32</name></type> <name>aSkipAttr</name></decl></param>,
                                   <param><decl><type><name>PRBool</name></type> <name>aAddNSAttr</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>SerializeAttr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aPrefix</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aName</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aValue</name></decl></param>,
                     <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                     <param><decl><type><name>PRBool</name></type> <name>aDoEscapeEntities</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>IsJavaScript</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type> <name>aContent</name></decl></param>,
                              <param><decl><type><name>nsIAtom</name>*</type> <name>aAttrNameAtom</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type> <name>aAttrNamespaceID</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aValueString</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * This method can be redefined to check if the element can be serialized.
   * It is called when the serialization of the start tag is asked 
   * (AppendElementStart)
   * In this method you can also force the formating
   * by setting aForceFormat to PR_TRUE.
   * @return boolean  PR_TRUE if the element can be output
   */</comment>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>CheckElementStart</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type> <name>aContent</name></decl></param>,
                                   <param><decl><type><name>PRBool</name> &amp;</type> <name>aForceFormat</name></decl></param>,
                                   <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * this method is responsible to finish the start tag,
   * in particulary to append the "greater than" sign
   */</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>AppendEndOfElementStart</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aOriginalElement</name></decl></param>,
                                       <param><decl><type><name>nsIAtom</name> *</type> <name>aName</name></decl></param>,
                                       <param><decl><type><name>PRInt32</name></type> <name>aNamespaceID</name></decl></param>,
                                       <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * This method can be redefine to serialize additional things just after
   * after the serialization ot the start tag.
   * (called at the end of AppendElementStart)
   */</comment>
  <function><type><name>virtual</name> <name>void</name></type> <name>AfterElementStart</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type> <name>aContent</name></decl></param>,
                                 <param><decl><type><name>nsIContent</name> *</type><name>aOriginalElement</name></decl></param>,
                                 <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list> <block>{ }</block></function><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * This method can be redefined to check if the element can be serialized.
   * It is called when the serialization of the end tag is asked 
   * (AppendElementEnd)
   * In this method you can also force the formating
   * by setting aForceFormat to PR_TRUE.
   * @return boolean  PR_TRUE if the element can be output
   */</comment>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>CheckElementEnd</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type> <name>aContent</name></decl></param>,
                                 <param><decl><type><name>PRBool</name> &amp;</type> <name>aForceFormat</name></decl></param>,
                                 <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * This method can be redefine to serialize additional things just after
   * after the serialization ot the end tag.
   * (called at the end of AppendElementStart)
   */</comment>
  <function><type><name>virtual</name> <name>void</name></type> <name>AfterElementEnd</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type> <name>aContent</name></decl></param>,
                               <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list> <block>{ }</block></function><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * Returns PR_TRUE if a line break should be inserted before an element open tag
   */</comment>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>LineBreakBeforeOpen</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNamespaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns PR_TRUE if a line break should be inserted after an element open tag
   */</comment>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>LineBreakAfterOpen</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNamespaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns PR_TRUE if a line break should be inserted after an element close tag
   */</comment>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>LineBreakBeforeClose</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNamespaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns PR_TRUE if a line break should be inserted after an element close tag
   */</comment>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>LineBreakAfterClose</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNamespaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * add intendation. Call only in the case of formating and if the current
   * position is at 0. It updates the column position.
   */</comment>
  <function_decl><type><name>void</name></type> <name>AppendIndentation</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>IncrIndentation</name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>DecrIndentation</name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aName</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Functions to check for newlines that needs to be added between nodes in</comment>
  <comment type="line">// the root of a document. See mAddNewlineForRootNode</comment>
  <function_decl><type><name>void</name></type> <name>MaybeAddNewlineForRootNode</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>MaybeFlagNewlineForRootNode</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aNode</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Functions to check if we enter in or leave from a preformated content</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>MaybeEnterInPreContent</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aNode</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>MaybeLeaveFromPreContent</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aNode</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>mPrefixIndex</name></decl>;</decl_stmt>

  <struct>struct <name>NameSpaceDecl</name> <block>{
    <decl_stmt><decl><type><name>nsString</name></type> <name>mPrefix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsString</name></type> <name>mURI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>mOwner</name></decl>;</decl_stmt>
  }</block>;</struct>

  <expr_stmt><expr><name>nsTArray</name>&lt;<name>NameSpaceDecl</name>&gt; <name>mNameSpaceStack</name></expr>;</expr_stmt>

  <comment type="line">// nsIDocumentEncoder flags</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type>  <name>mFlags</name></decl>;</decl_stmt>

  <comment type="line">// characters to use for line break</comment>
  <decl_stmt><decl><type><name>nsString</name></type>  <name>mLineBreak</name></decl>;</decl_stmt>

  <comment type="line">// The charset that was passed to Init()</comment>
  <decl_stmt><decl><type><name>nsCString</name></type> <name>mCharset</name></decl>;</decl_stmt>
  
  <comment type="line">// current column position on the current line</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type>   <name>mColPos</name></decl>;</decl_stmt>

  <comment type="line">// true = pretty formating should be done (OutputFormated flag)</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mDoFormat</name></decl>;</decl_stmt>

  <comment type="line">// true = no formatting,(OutputRaw flag)</comment>
  <comment type="line">// no newline convertion and no rewrap long lines even if OutputWrap is set.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mDoRaw</name></decl>;</decl_stmt>

  <comment type="line">// true = wrapping should be done (OutputWrap flag)</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mDoWrap</name></decl>;</decl_stmt>

  <comment type="line">// number of maximum column in a line, in the wrap mode</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type>   <name>mMaxColumn</name></decl>;</decl_stmt>

  <comment type="line">// current indent value</comment>
  <decl_stmt><decl><type><name>nsString</name></type>   <name>mIndent</name></decl>;</decl_stmt>

  <comment type="line">// this is the indentation level after the indentation reached</comment>
  <comment type="line">// the maximum length of indentation</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>    <name>mIndentOverflow</name></decl>;</decl_stmt>

  <comment type="line">// says if the indentation has been already added on the current line</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mIsIndentationAddedOnCurrentLine</name></decl>;</decl_stmt>

  <comment type="line">// the string which is currently added is in an attribute</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mInAttribute</name></decl>;</decl_stmt>

  <comment type="line">// true = a newline character should be added. It's only</comment>
  <comment type="line">// useful when serializing root nodes. see MaybeAddNewlineForRootNode and</comment>
  <comment type="line">// MaybeFlagNewlineForRootNode</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mAddNewlineForRootNode</name></decl>;</decl_stmt>

  <comment type="line">// Indicates that a space will be added if and only if content is</comment>
  <comment type="line">// continued on the same line while serializing source.  Otherwise,</comment>
  <comment type="line">// the newline character acts as the whitespace and no space is needed.</comment>
  <comment type="line">// used when mDoFormat = true</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>  <name>mAddSpace</name></decl>;</decl_stmt>

  <comment type="line">// says that if the next string to add contains a newline character at the</comment>
  <comment type="line">// begining, then this newline character should be ignored, because a</comment>
  <comment type="line">// such character has already been added into the output string</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>  <name>mMayIgnoreLineBreakSequence</name></decl>;</decl_stmt>

  <comment type="line">// number of nested elements which have preformated content</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>mPreLevel</name></decl>;</decl_stmt>
};

<function_decl><type><name>nsresult</name></type>
<name>NS_NewXMLContentSerializer</name><parameter_list>(<param><decl><type><name>nsIContentSerializer</name>**</type> <name>aSerializer</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
