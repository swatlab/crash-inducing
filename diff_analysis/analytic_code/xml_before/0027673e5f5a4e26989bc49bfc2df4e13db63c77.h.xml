<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0027673e5f5a4e26989bc49bfc2df4e13db63c77.h"><comment type="block">/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>jsscript_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jsscript_h___</name></cpp:macro></cpp:define>
<comment type="block">/*
 * JS script descriptor.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprvtd.h"</cpp:file></cpp:include>

<macro><name>JS_BEGIN_EXTERN_C</name></macro>

<comment type="block">/*
 * Type of try note associated with each catch or finally block or with for-in
 * loop.
 */</comment>
<typedef>typedef <type><enum>enum <name>JSTryNoteKind</name> <block>{
    <decl><name>JSTN_CATCH</name></decl>,
    <decl><name>JSTN_FINALLY</name></decl>,
    <decl><name>JSTN_ITER</name></decl>
}</block></enum></type> <name>JSTryNoteKind</name>;</typedef>

<comment type="block">/*
 * Exception handling record.
 */</comment>
<struct>struct <name>JSTryNote</name> <block>{
    <decl_stmt><decl><type><name>uint8</name></type>           <name>kind</name></decl>;</decl_stmt>       <comment type="block">/* one of JSTryNoteKind */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>           <name>padding</name></decl>;</decl_stmt>    <comment type="block">/* explicit padding on uint16 boundary */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>          <name>stackDepth</name></decl>;</decl_stmt> <comment type="block">/* stack depth upon exception handler entry */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>start</name></decl>;</decl_stmt>      <comment type="block">/* start of the try statement or for-in loop
                                   relative to script-&gt;main */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>length</name></decl>;</decl_stmt>     <comment type="block">/* length of the try statement or for-in loop */</comment>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>JSTryNoteArray</name> <block>{
    <decl_stmt><decl><type><name>JSTryNote</name>       *</type><name>vector</name></decl>;</decl_stmt>    <comment type="block">/* array of indexed try notes */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>length</name></decl>;</decl_stmt>     <comment type="block">/* count of indexded try notes */</comment>
}</block></struct></type> <name>JSTryNoteArray</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JSObjectArray</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>        **</type><name>vector</name></decl>;</decl_stmt>   <comment type="block">/* array of indexed objects */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>length</name></decl>;</decl_stmt>     <comment type="block">/* count of indexded objects */</comment>
}</block></struct></type> <name>JSObjectArray</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_OBJECT_ARRAY_SIZE</name><parameter_list>(<param><type><name>length</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>(offsetof(JSObjectArray, vector) + sizeof(JSObject *) * (length))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name> &amp;&amp; <name>defined</name> <name>JS_THREADSAFE</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_SCRIPT_OWNER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>JSScript</name> <block>{
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>code</name></decl>;</decl_stmt>      <comment type="block">/* bytecodes and their immediate operands */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>length</name></decl>;</decl_stmt>     <comment type="block">/* length of code vector */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>          <name>version</name></decl>;</decl_stmt>    <comment type="block">/* JS version under which script was compiled */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>          <name>ngvars</name></decl>;</decl_stmt>     <comment type="block">/* declared global var/const/function count */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>           <name>objectsOffset</name></decl>;</decl_stmt>  <comment type="block">/* offset to the array of nested function,
                                       block, scope, xml and one-time regexps
                                       objects or 0 if none */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>           <name>regexpsOffset</name></decl>;</decl_stmt>  <comment type="block">/* offset to the array of to-be-cloned
                                       regexps or 0 if none. */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>           <name>trynotesOffset</name></decl>;</decl_stmt> <comment type="block">/* offset to the array of try notes or
                                       0 if none */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type>main</decl>;</decl_stmt>      <comment type="block">/* main entry point, after predef'ing prolog */</comment>
    <decl_stmt><decl><type><name>JSAtomMap</name></type>       <name>atomMap</name></decl>;</decl_stmt>    <comment type="block">/* maps immediate index to literal struct */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>      *</type><name>filename</name></decl>;</decl_stmt>  <comment type="block">/* source filename or null */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>           <name>lineno</name></decl>;</decl_stmt>     <comment type="block">/* base line number of script */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>           <name>depth</name></decl>;</decl_stmt>      <comment type="block">/* maximum stack depth in slots */</comment>
    <decl_stmt><decl><type><name>JSPrincipals</name>    *</type><name>principals</name></decl>;</decl_stmt><comment type="block">/* principals for this script */</comment>
    <decl_stmt><decl><type><name>JSObject</name>        *</type><name>object</name></decl>;</decl_stmt>    <comment type="block">/* optional Script-class object wrapper */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_SCRIPT_OWNER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSThread</name>        *</type><name>owner</name></decl>;</decl_stmt>     <comment type="block">/* for thread-safe life-cycle assertions */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/* No need to store script-&gt;notes now that it is allocated right after code. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_NOTES</name><parameter_list>(<param><type><name>script</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((jssrcnote*)((script)-&gt;code+(script)-&gt;length))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_SCRIPT_OBJECTS</name><parameter_list>(<param><type><name>script</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>(JS_ASSERT((script)-&gt;objectsOffset != 0),                                 \
     (JSObjectArray *)((uint8 *)(script) + (script)-&gt;objectsOffset))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_SCRIPT_REGEXPS</name><parameter_list>(<param><type><name>script</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>(JS_ASSERT((script)-&gt;regexpsOffset != 0),                                 \
     (JSObjectArray *)((uint8 *)(script) + (script)-&gt;regexpsOffset))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_SCRIPT_TRYNOTES</name><parameter_list>(<param><type><name>script</name></type></param>)</parameter_list></cpp:macro>                                            \
    <cpp:value>(JS_ASSERT((script)-&gt;trynotesOffset != 0),                                \
     (JSTryNoteArray *)((uint8 *)(script) + (script)-&gt;trynotesOffset))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GET_SCRIPT_ATOM</name><parameter_list>(<param><type><name>script</name></type></param>, <param><type><name>index</name></type></param>, <param><type><name>atom</name></type></param>)</parameter_list></cpp:macro>                               \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JSAtomMap *atoms_ = &amp;(script)-&gt;atomMap;                               \
        JS_ASSERT((uint32)(index) &lt; atoms_-&gt;length);                          \
        (atom) = atoms_-&gt;vector[(index)];                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GET_SCRIPT_OBJECT</name><parameter_list>(<param><type><name>script</name></type></param>, <param><type><name>index</name></type></param>, <param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                              \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JSObjectArray *objects_ = JS_SCRIPT_OBJECTS(script);                  \
        JS_ASSERT((uint32)(index) &lt; objects_-&gt;length);                        \
        (obj) = objects_-&gt;vector[(index)];                                    \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GET_SCRIPT_FUNCTION</name><parameter_list>(<param><type><name>script</name></type></param>, <param><type><name>index</name></type></param>, <param><type><name>fun</name></type></param>)</parameter_list></cpp:macro>                            \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JSObject *funobj_;                                                    \
                                                                              \
        JS_GET_SCRIPT_OBJECT(script, index, funobj_);                         \
        JS_ASSERT(HAS_FUNCTION_CLASS(funobj_));                               \
        JS_ASSERT(funobj_ == (JSObject *) STOBJ_GET_PRIVATE(funobj_));        \
        (fun) = (JSFunction *) funobj_;                                       \
        JS_ASSERT(FUN_INTERPRETED(fun));                                      \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GET_SCRIPT_REGEXP</name><parameter_list>(<param><type><name>script</name></type></param>, <param><type><name>index</name></type></param>, <param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>                              \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JSObjectArray *regexps_ = JS_SCRIPT_REGEXPS(script);                  \
        JS_ASSERT((uint32)(index) &lt; regexps_-&gt;length);                        \
        (obj) = regexps_-&gt;vector[(index)];                                    \
        JS_ASSERT(STOBJ_GET_CLASS(obj) == &amp;js_RegExpClass);                   \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/*
 * Check if pc is inside a try block that has finally code. GC calls this to
 * check if it is necessary to schedule generator.close() invocation for an
 * unreachable generator.
 */</comment>
<function_decl><type><name>JSBool</name></type>
<name>js_IsInsideTryWithFinally</name><parameter_list>(<param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>;</function_decl>

<extern>extern JS_FRIEND_DATA(JSClass</extern>) <expr_stmt><expr><name>js_ScriptClass</name></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>JSObject</name> *</type>
<name>js_InitScriptClass</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * On first new context in rt, initialize script runtime state, specifically
 * the script filename table and its lock.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InitRuntimeScriptState</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * On last context destroy for rt, if script filenames are all GC'd, free the
 * script filename table and its lock.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_FinishRuntimeScriptState</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * On JS_DestroyRuntime(rt), forcibly free script filename prefixes and any
 * script filename table entries that have not been GC'd, the latter using
 * js_FinishRuntimeScriptState.
 *
 * This allows script filename prefixes to outlive any context in rt.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_FreeRuntimeScriptState</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>js_SaveScriptFilename</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>js_SaveScriptFilenameRT</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>uint32</name></type>
<name>js_GetScriptFilenameFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_MarkScriptFilename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_MarkScriptFilenames</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>keepAtoms</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_SweepScriptFilenames</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Two successively less primitive ways to make a new JSScript.  The first
 * does *not* call a non-null cx-&gt;runtime-&gt;newScriptHook -- only the second,
 * js_NewScriptFromCG, calls this optional debugger hook.
 *
 * The js_NewScript function can't know whether the script it creates belongs
 * to a function, or is top-level or eval code, but the debugger wants access
 * to the newly made script's function, if any -- so callers of js_NewScript
 * are responsible for notifying the debugger after successfully creating any
 * kind (function or other) of new JSScript.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSScript</name> *</type>
<name>js_NewScript</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>length</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nsrcnotes</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>natoms</name></decl></param>,
             <param><decl><type><name>uint32</name></type> <name>nobjects</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nregexps</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>ntrynotes</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSScript</name> *</type>
<name>js_NewScriptFromCG</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * New-script-hook calling is factored from js_NewScriptFromCG so that it
 * and callers of js_XDRScript can share this code.  In the case of callers
 * of js_XDRScript, the hook should be invoked only after successful decode
 * of any owning function (the fun parameter) or script object (null fun).
 */</comment>
<extern>extern JS_FRIEND_API(void</extern>)
<expr_stmt><expr><call><name>js_CallNewScriptHook</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSScript</name> *<name>script</name></expr></argument>, <argument><expr><name>JSFunction</name> *<name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<extern>extern JS_FRIEND_API(void</extern>)
<expr_stmt><expr><call><name>js_CallDestroyScriptHook</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSScript</name> *<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_DestroyScript</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_TraceScript</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * To perturb as little code as possible, we introduce a js_GetSrcNote lookup
 * cache without adding an explicit cx parameter.  Thus js_GetSrcNote becomes
 * a macro that uses cx from its calls' lexical environments.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_GetSrcNote</name><parameter_list>(<param><type><name>script</name></type></param>,<param><type><name>pc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>js_GetSrcNoteCached(cx, script, pc)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>jssrcnote</name> *</type>
<name>js_GetSrcNoteCached</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* XXX need cx to lock function objects declared by prolog bytecodes. */</comment>
<function_decl><type><specifier>extern</specifier> <name>uintN</name></type>
<name>js_PCToLineNumber</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>jsbytecode</name> *</type>
<name>js_LineNumberToPC</name><parameter_list>(<param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>lineno</name></decl></param>)</parameter_list>;</function_decl>

<extern>extern JS_FRIEND_API(uintN</extern>)
<expr_stmt><expr><call><name>js_GetScriptLineExtent</name><argument_list>(<argument><expr><name>JSScript</name> *<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * If magic is non-null, js_XDRScript succeeds on magic number mismatch but
 * returns false in *magic; it reflects a match via a true *magic out param.
 * If magic is null, js_XDRScript returns false on bad magic number errors,
 * which it reports.
 *
 * NB: callers must call js_CallNewScriptHook after successful JSXDR_DECODE
 * and subsequent set-up of owning function or script object, if any.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_XDRScript</name><parameter_list>(<param><decl><type><name>JSXDRState</name> *</type><name>xdr</name></decl></param>, <param><decl><type><name>JSScript</name> **</type><name>scriptp</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>magic</name></decl></param>)</parameter_list>;</function_decl>

<macro><name>JS_END_EXTERN_C</name></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* jsscript_h___ */</comment>
</unit>
