<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="003f6b0d920b4e2564fc5d14ee7e44a4c4f2ba35.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=99:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS parser.
 *
 * This is a recursive-descent parser for the JavaScript language specified by
 * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
 * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
 * induced by the recursive parsing (not precise syntax trees, see jsparse.h).
 * After tree construction, it rewrites trees to fold constants and evaluate
 * compile-time expressions.  Finally, it calls js_EmitTree (see jsemit.h) to
 * generate bytecode.
 *
 * This parser attempts no error recovery.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsemit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsiter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslibmath.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsxml.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdhash.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Asserts to verify assumptions behind pn_ macros.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_offsetof</name><parameter_list>(<param><type><name>m</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>offsetof(JSParseNode, m)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>pn_offsetof</name><argument_list>(<argument><expr><name>pn_link</name></expr></argument>)</argument_list></call> == <call><name>pn_offsetof</name><argument_list>(<argument><expr><name>dn_uses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>pn_offsetof</name><argument_list>(<argument><expr><name><name>pn_u</name>.<name>name</name>.<name>atom</name></name></expr></argument>)</argument_list></call> == <call><name>pn_offsetof</name><argument_list>(<argument><expr><name><name>pn_u</name>.<name>apair</name>.<name>atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>pn_offsetof</name></cpp:undef>

<comment type="block">/*
 * JS parsers, from lowest to highest precedence.
 *
 * Each parser takes a context, a token stream, and a tree context struct.
 * Each returns a parse node tree or null on error.
 */</comment>

<typedef>typedef <function_decl><type><name>JSParseNode</name> *</type>
<name>JSParser</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>JSParseNode</name> *</type>
<name>JSVariablesParser</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                  <param><decl><type><name>bool</name></type> <name>inLetHead</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>JSParseNode</name> *</type>
<name>JSMemberParser</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
               <param><decl><type><name>JSBool</name></type> <name>allowCallSyntax</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>JSParseNode</name> *</type>
<name>JSPrimaryParser</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>afterDot</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>JSParseNode</name> *</type>
<name>JSParenParser</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
              <param><decl><type><name>JSParseNode</name> *</type><name>pn1</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>genexp</name></decl></param>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>FunctionStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>FunctionExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>Statements</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>Statement</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSVariablesParser</name></type> <name>Variables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>AssignExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>CondExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>OrExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>AndExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>BitOrExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>BitXorExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>BitAndExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>EqExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>RelExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>ShiftExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>AddExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>MulExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParser</name></type> <name>UnaryExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSMemberParser</name></type>  <name>MemberExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSPrimaryParser</name></type> <name>PrimaryExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSParenParser</name></type>   <name>ParenExpr</name></decl>;</decl_stmt>

<comment type="block">/*
 * Insist that the next token be of type tt, or report errno and return null.
 * NB: this macro uses cx and ts from its lexical environment.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUST_MATCH_TOKEN</name><parameter_list>(<param><type><name>tt</name></type></param>, <param><type><name>errno</name></type></param>)</parameter_list></cpp:macro>                                           \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        if (js_GetToken(cx, ts) != tt) {                                      \
            js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, errno); \
            return NULL;                                                      \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>parsenodes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>maxparsenodes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>recyclednodes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name><name>JSParseNode</name>::<name>become</name></name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pn_defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn2</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pn_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnup</name> <init>= <expr>&amp;<name><name>pn2</name>-&gt;<name>pn_lexdef</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>*<name>pnup</name> != <name>pn2</name></expr>)</condition>
            <expr_stmt><expr><name>pnup</name> = &amp;<name>(*<name>pnup</name>)-&gt;<name>pn_link</name></name></expr>;</expr_stmt></while>
        <expr_stmt><expr>*<name>pnup</name> = <name>this</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_link</name> = <name><name>pn2</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_used</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_link</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_used</name></name> = false</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If this is a function node fix up the pn_funbox-&gt;node back-pointer. */</comment>
    <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call> == <name>TOK_FUNCTION</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_arity</name></name> == <name>PN_FUNC</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_funbox</name>-&gt;<name>node</name></name> = <name>this</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>pn_type</name> = <name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn_op</name> = <name><name>pn2</name>-&gt;<name>pn_op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn_arity</name> = <name><name>pn2</name>-&gt;<name>pn_arity</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn_u</name> = <name><name>pn2</name>-&gt;<name>pn_u</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pn2</name>-&gt;<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSParseNode</name>::<name>clear</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>pn_type</name> = <name>TOK_EOF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn_op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn_used</name> = <name>pn_defn</name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name>pn_arity</name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>bool</name></type>
<name><name>JSCompiler</name>::<name>init</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>base</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>,
                 <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tempPoolMark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>js_InitTokenStream</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>tempPoolMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Root atoms and objects allocated for the parsed tree. */</comment>
    <expr_stmt><expr><call><name>JS_KEEP_ATOMS</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_PUSH_TEMP_ROOT_COMPILER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>tempRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<destructor><name><name>JSCompiler</name>::~<name>JSCompiler</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>principals</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JSPRINCIPALS_DROP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>principals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tempRoot</name>.<name>u</name>.<name>compiler</name></name> == <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>tempRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNKEEP_ATOMS</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_CloseTokenStream</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>tempPoolMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>JSCompiler</name>::<name>setPrincipals</name></name><parameter_list>(<param><decl><type><name>JSPrincipals</name> *</type><name>prin</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>principals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>prin</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JSPRINCIPALS_HOLD</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>prin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>principals</name> = <name>prin</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSObjectBox</name> *</type>
<name><name>JSCompiler</name>::<name>newObjectBox</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We use JSContext.tempPool to allocate parsed objects and place them on
     * a list in JSTokenStream to ensure GC safety. Thus the tempPool arenas
     * containing the entries must be alive until we are done with scanning,
     * parsing and code generation for the whole script or top-level function.
     */</comment>
    <decl_stmt><decl><type><name>JSObjectBox</name> *</type><name>objbox</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_TYPE</name><argument_list>(<argument><expr><name>objbox</name></expr></argument>, <argument><expr><name>JSObjectBox</name></expr></argument>, <argument><expr>&amp;<name><name>context</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>objbox</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>objbox</name>-&gt;<name>traceLink</name></name> = <name>traceListHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>traceListHead</name> = <name>objbox</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>objbox</name>-&gt;<name>emitLink</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>objbox</name>-&gt;<name>object</name></name> = <name>obj</name></expr>;</expr_stmt>
    <return>return <expr><name>objbox</name></expr>;</return>
}</block></function>

<function><type><name>JSFunctionBox</name> *</type>
<name><name>JSCompiler</name>::<name>newFunctionBox</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We use JSContext.tempPool to allocate parsed objects and place them on
     * a list in JSTokenStream to ensure GC safety. Thus the tempPool arenas
     * containing the entries must be alive until we are done with scanning,
     * parsing and code generation for the whole script or top-level function.
     */</comment>
    <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_TYPE</name><argument_list>(<argument><expr><name>funbox</name></expr></argument>, <argument><expr><name>JSFunctionBox</name></expr></argument>, <argument><expr>&amp;<name><name>context</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>funbox</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>traceLink</name></name> = <name>traceListHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>traceListHead</name> = <name>funbox</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>emitLink</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>object</name></name> = <name>obj</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>node</name></name> = <name>fn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>siblings</name></name> = <name><name>tc</name>-&gt;<name>functionList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>functionList</name></name> = <name>funbox</name></expr>;</expr_stmt>
    <expr_stmt><expr>++<name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>functionCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>kids</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>parent</name></name> = <name><name>tc</name>-&gt;<name>funbox</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>queued</name></name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>inLoop</name></name> = false</expr>;</expr_stmt>
    <for>for (<init><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name> <init>= <expr><name><name>tc</name>-&gt;<name>topStmt</name></name></expr></init></decl>;</init> <condition><expr><name>stmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>funbox</name>-&gt;<name>inLoop</name></name> = true</expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>level</name></name> = <name><name>tc</name>-&gt;<name>staticLevel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>tcflags</name></name> = <name>TCF_IN_FUNCTION</name> | (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_COMPILE_N_GO</name>)</expr>;</expr_stmt>
    <return>return <expr><name>funbox</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSCompiler</name>::<name>trace</name></name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObjectBox</name> *</type><name>objbox</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tempRoot</name>.<name>u</name>.<name>compiler</name></name> == <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>objbox</name> = <name>traceListHead</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>objbox</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>objbox</name>-&gt;<name>object</name></name></expr></argument>, <argument><expr>"parser.object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>objbox</name> = <name><name>objbox</name>-&gt;<name>traceLink</name></name></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>UnlinkFunctionBoxes</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnlinkFunctionBox</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_funbox</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>funbox</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>funbox</name>-&gt;<name>node</name></name> == <name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funbox</name>-&gt;<name>node</name></name> = <name>NULL</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JSFunctionBox</name> **</type><name>funboxp</name> <init>= <expr>&amp;<name><name>tc</name>-&gt;<name>functionList</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>*<name>funboxp</name></expr>)</condition> <block>{
            <if>if <condition>(<expr>*<name>funboxp</name> == <name>funbox</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>funboxp</name> = <name><name>funbox</name>-&gt;<name>siblings</name></name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>funboxp</name> = &amp;<name>(*<name>funboxp</name>)-&gt;<name>siblings</name></name></expr>;</expr_stmt>
        }</block></while>

        <decl_stmt><decl><type><name>uint16</name></type> <name>oldflags</name> <init>= <expr><name><name>tc</name>-&gt;<name>flags</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>oldlist</name> <init>= <expr><name><name>tc</name>-&gt;<name>functionList</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = (<name>uint16</name>) <name><name>funbox</name>-&gt;<name>tcflags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>functionList</name></name> = <name><name>funbox</name>-&gt;<name>kids</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_body</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funbox</name>-&gt;<name>kids</name></name> = <name><name>tc</name>-&gt;<name>functionList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>functionList</name></name> = <name>oldlist</name></expr>;</expr_stmt>

        <comment type="line">// FIXME: use a funbox freelist (consolidate aleFreeList and nodeList).</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_funbox</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnlinkFunctionBoxes</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
          <case>case <expr><name>PN_NULLARY</name></expr>:
            <return>return;</return>
          </case><case>case <expr><name>PN_UNARY</name></expr>:
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </case><case>case <expr><name>PN_BINARY</name></expr>:
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </case><case>case <expr><name>PN_TERNARY</name></expr>:
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </case><case>case <expr><name>PN_LIST</name></expr>:
            <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pn2</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_head</name></name></expr></init></decl>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>)
                <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <return>return;</return>
          </case><case>case <expr><name>PN_FUNC</name></expr>:
            <expr_stmt><expr><call><name>UnlinkFunctionBox</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </case><case>case <expr><name>PN_NAME</name></expr>:
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>maybeExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </case><case>case <expr><name>PN_NAMESET</name></expr>:
            <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_tree</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </case>}</block></switch>
    }</block></then></if>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>RecycleFuncNameKids</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>RecycleTree</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>next</name></decl>, **<decl><type ref="prev"/><name>head</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Catch back-to-back dup recycles. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn</name> != <name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> = <name><name>pn</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_used</name></name> || <name><name>pn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * JSAtomLists own definition nodes along with their used-node chains.
         * Defer recycling such nodes until we unwind to top level to avoid
         * linkage overhead or (alternatively) unlinking runtime complexity.
         * Yes, this means dead code can contribute to static analysis results!
         *
         * Do recycle kids here, since they are no longer needed.
         */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_next</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RecycleFuncNameKids</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>UnlinkFunctionBoxes</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> = &amp;<name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>nodeList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_next</name></name> = *<name>head</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>head</name> = <name>pn</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
        <expr_stmt><expr><name>recyclednodes</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
    <return>return <expr><name>next</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecycleFuncNameKids</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_FUNC</name></expr>:
        <expr_stmt><expr><call><name>UnlinkFunctionBox</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALL THROUGH */</comment>

      </case><case>case <expr><name>PN_NAME</name></expr>:
        <comment type="block">/*
         * Only a definition node might have a non-null strong pn_expr link
         * to recycle, but we test !pn_used to handle PN_FUNC fall through.
         * Every node with the pn_used flag set has a non-null pn_lexdef
         * weak reference to its definition node.
         */</comment>
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> == <name>TOK_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>NewOrRecycledNode</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>nodeList</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSParseNode</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>nodeList</name></name> = <name><name>pn</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>

        <comment type="block">/* Recycle immediate descendents only, to save work and working set. */</comment>
        <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
          <case>case <expr><name>PN_FUNC</name></expr>:
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_body</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>PN_LIST</name></expr>:
            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
                <while>while <condition>(<expr><name>pn2</name> &amp;&amp; !<name><name>pn2</name>-&gt;<name>pn_used</name></name> &amp;&amp; !<name><name>pn2</name>-&gt;<name>pn_defn</name></name></expr>)</condition>
                    <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt></while>
                <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
                    <do>do <block>{
                        <expr_stmt><expr><name>pn2</name> = <call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block> while <condition>(<expr><name>pn2</name></expr>)</condition>;</do>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr>*<name><name>pn</name>-&gt;<name>pn_tail</name></name> = <name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>nodeList</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>nodeList</name></name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
                    <expr_stmt><expr><name>recyclednodes</name> += <name><name>pn</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break;</break>
                }</block></else></if>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>PN_TERNARY</name></expr>:
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>PN_BINARY</name></expr>:
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_left</name></name> != <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>PN_UNARY</name></expr>:
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>PN_NAME</name></expr>:
            <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <break>break;</break>
          </case><case>case <expr><name>PN_NULLARY</name></expr>:
            <break>break;</break>
        </case>}</block></switch>
    }</block></else></if>
    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
        <expr_stmt><expr><name>parsenodes</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>parsenodes</name> - <name>recyclednodes</name> &gt; <name>maxparsenodes</name></expr>)</condition><then>
            <expr_stmt><expr><name>maxparsenodes</name> = <name>parsenodes</name> - <name>recyclednodes</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_used</name></name> = <name><name>pn</name>-&gt;<name>pn_defn</name></name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>pn</name>-&gt;<name>pn_u</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof <name><name>pn</name>-&gt;<name>pn_u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>InitParseNode</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTokenType</name></type> <name>type</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSParseNodeArity</name></type> <name>arity</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>arity</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_next</name></name> = <name><name>pn</name>-&gt;<name>pn_link</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Allocate a JSParseNode from tc's node freelist or, failing that, from cx's
 * temporary arena.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>NewParseNode</name><parameter_list>(<param><decl><type><name>JSParseNodeArity</name></type> <name>arity</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSToken</name> *</type><name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewOrRecycledNode</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>tp</name> = &amp;<call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr>&amp;<name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>tokenStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitParseNode</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name><name>tp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>, <argument><expr><name>arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name></name> = <name><name>tp</name>-&gt;<name>pos</name></name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>InitNameNodeCommon</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> = <call><name><name>tc</name>-&gt;<name>atTopLevel</name></name><argument_list>()</argument_list></call> ? <name>PND_TOPLEVEL</name> : 0</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>tc</name>-&gt;<name>topStmt</name></name> || <name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BLOCKCHILD</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>NewNameNode</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NAME</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <name>atom</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InitNameNodeCommon</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>NewBinary</name><parameter_list>(<param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>left</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>right</name></decl></param>,
          <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn1</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>left</name> || !<name>right</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/*
     * Flatten a left-associative (left-heavy) tree of a given operator into
     * a list, to reduce js_FoldConstants and js_EmitTree recursion.
     */</comment>
    <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> == <name>tt</name> &amp;&amp;
        <call><name>PN_OP</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> == <name>op</name> &amp;&amp;
        (<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_LEFTASSOC</name>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_arity</name></name> != <name>PN_LIST</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn1</name> = <name><name>left</name>-&gt;<name>pn_left</name></name></expr>, <expr><name>pn2</name> = <name><name>left</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_arity</name></name> = <name>PN_LIST</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>left</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>left</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_PLUS</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_STRCAT</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_NUMBER</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if></else></if>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_STRCAT</name></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NUMBER</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if></else></if>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>left</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>right</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_PLUS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>right</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_STRCAT</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name><name>right</name>-&gt;<name>pn_type</name></name> != <name>TOK_NUMBER</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if></else></if>
        }</block></then></if>
        <return>return <expr><name>left</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Fold constant addition immediately, to conserve node space and, what's
     * more, so js_FoldConstants never sees mixed addition and concatenation
     * operations with more than one leading non-string operand in a PN_LIST
     * generated for expressions such as 1 + 2 + "pt" (which should evaluate
     * to "3pt", not "12pt").
     */</comment>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_PLUS</name> &amp;&amp;
        <name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name> &amp;&amp;
        <name><name>right</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_dval</name></name> += <name><name>right</name>-&gt;<name>pn_dval</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>right</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>left</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>pn</name> = <call><name>NewOrRecycledNode</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>InitParseNode</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>PN_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>left</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>right</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>left</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>right</name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>JSTokenType</name></type>
<name>CheckGetterOrSetter</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>atom</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>atom</name> == <name><name>rt</name>-&gt;<name>atomState</name>.<name>getterAtom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>op</name> = <name>JSOP_GETTER</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>atom</name> == <name><name>rt</name>-&gt;<name>atomState</name>.<name>setterAtom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>op</name> = <name>JSOP_SETTER</name></expr>;</expr_stmt></then>
    <else>else
        <return>return <expr><name>TOK_NAME</name></expr>;</return></else></if></else></if>
    <if>if <condition>(<expr><call><name>js_PeekTokenSameLine</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> != <name>tt</name></expr>)</condition><then>
        <return>return <expr><name>TOK_NAME</name></expr>;</return></then></if>
    <expr_stmt><expr>(<name>void</name>) <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_GETTER_OR_SETTER</name></expr></argument>,
                                    <argument><expr>(<name>op</name> == <name>JSOP_GETTER</name>)
                                    ? <name>js_getter_str</name>
                                    : <name>js_setter_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TOK_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> = <name>op</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>name</name> = <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>name</name> ||
            !<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                                         <argument><expr><name>JSMSG_DEPRECATED_USAGE</name></expr></argument>,
                                         <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>TOK_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>tt</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GenerateBlockId</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>uint32</name>&amp;</type> <name>blockid</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>blockidGen</name></name> == <call><name>JS_BIT</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_NEED_DIET</name></expr></argument>, <argument><expr>"program"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>blockid</name> = <name><name>tc</name>-&gt;<name>blockidGen</name></name>++</expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GenerateBlockIdForStmtNode</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>topStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>STMT_MAYBE_SCOPE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>topStmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_LEXICALSCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>GenerateBlockId</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>blockid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>blockid</name></name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Parse a top-level JS script.
 */</comment>
<function><type><name>JSParseNode</name> *</type>
<name><name>JSCompiler</name>::<name>parse</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>chain</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Protect atoms from being collected by a GC activation, which might
     * - nest on this thread due to out of memory (the so-called "last ditch"
     *   GC attempted within js_NewGCThing), or
     * - run for any reason on another thread if this thread is suspended on
     *   an object lock before it finishes generating bytecode into a script
     *   protected from the GC by a root or a stack frame reference.
     */</comment>
    <function_decl><type><name>JSTreeContext</name></type> <name>tc</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name><name>tc</name>.<name>scopeChain</name></name> = <name>chain</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>GenerateBlockId</name><argument_list>(<argument><expr>&amp;<name>tc</name></expr></argument>, <argument><expr><name><name>tc</name>.<name>bodyid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><call><name>Statements</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TOK_EOF</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>FREE_STATIC_LEVEL</name> == <call><name>JS_BITMASK</name><argument_list>(<argument><expr><name>JSFB_LEVEL_BITS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>SetStaticLevel</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>staticLevel</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Reserve FREE_STATIC_LEVEL (0xffff) in order to reserve FREE_UPVAR_COOKIE
     * (0xffffffff) and other cookies with that level.
     *
     * This is a lot simpler than error-checking every MAKE_UPVAR_COOKIE, and
     * practically speaking it leaves more than enough room for upvars. In fact
     * we might want to split cookie fields giving fewer bits for skip and more
     * for slot, but only based on evidence.
     */</comment>
    <if>if <condition>(<expr><name>staticLevel</name> &gt;= <name>FREE_STATIC_LEVEL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_TOO_DEEP</name></expr></argument>, <argument><expr><name>js_function_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name> = <name>staticLevel</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Compile a top-level script.
 */</comment>
<function><type><name>JSScript</name> *</type>
<name><name>JSCompiler</name>::<name>compileScript</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>scopeChain</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>callerFrame</name></decl></param>,
                          <param><decl><type><name>JSPrincipals</name> *</type><name>principals</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>tcflags</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>,
                          <param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>lineno</name></decl></param>,
                          <param><decl><type><name>JSString</name> *</type><name>source</name></decl></param> <comment type="block">/* = NULL */</comment>)</parameter_list>
<block>{
    <function_decl><type><name>JSCompiler</name></type> <name>jsc</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>principals</name></type></decl></param>, <param><decl><type><name>callerFrame</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>JSArenaPool</name></type> <name>codePool</name></decl>, <decl><type ref="prev"/><name>notePool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>scriptGlobals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
    <function_decl><type><name>void</name> *</type><name>sbrk</name><parameter_list>(<param><decl><type><name>ptrdiff_t</name></type></decl></param>)</parameter_list>, *<name>before</name> = sbrk<parameter_list>(</parameter_list>0</function_decl>)</block>;</function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name>tcflags</name> &amp; ~(<name>TCF_COMPILE_N_GO</name> | <name>TCF_NO_SCRIPT_RVAL</name> |
                            <name>TCF_STATIC_LEVEL_MASK</name>))</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The scripted callerFrame can only be given for compile-and-go scripts
     * and non-zero static level requires callerFrame.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>callerFrame</name></expr></argument>, <argument><expr><name>tcflags</name> &amp; <name>TCF_COMPILE_N_GO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name>TCF_GET_STATIC_LEVEL</name><argument_list>(<argument><expr><name>tcflags</name></expr></argument>)</argument_list></call> != 0</expr></argument>, <argument><expr><name>callerFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name><name>jsc</name>.<name>init</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_INIT_ARENA_POOL</name><argument_list>(<argument><expr>&amp;<name>codePool</name></expr></argument>, <argument><expr>"code"</expr></argument>, <argument><expr>1024</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_INIT_ARENA_POOL</name><argument_list>(<argument><expr>&amp;<name>notePool</name></expr></argument>, <argument><expr>"note"</expr></argument>, <argument><expr>1024</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSCodeGenerator</name></type> <name>cg</name><argument_list>(<argument><expr>&amp;<name>jsc</name></expr></argument>, <argument><expr>&amp;<name>codePool</name></expr></argument>, <argument><expr>&amp;<name>notePool</name></expr></argument>, <argument><expr><name><name>jsc</name>.<name>tokenStream</name>.<name>lineno</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MUST_FLOW_THROUGH</name><argument_list>(<argument><expr>"out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Null script early in case of error, to reduce our code footprint. */</comment>
    <expr_stmt><expr><name>script</name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cg</name>.<name>flags</name></name> |= <call><name>uint16</name><argument_list>(<argument><expr><name>tcflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>.<name>scopeChain</name></name> = <name>scopeChain</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>SetStaticLevel</name><argument_list>(<argument><expr>&amp;<name>cg</name></expr></argument>, <argument><expr><call><name>TCF_GET_STATIC_LEVEL</name><argument_list>(<argument><expr><name>tcflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <comment type="block">/*
     * If funbox is non-null after we create the new script, callerFrame-&gt;fun
     * was saved in the 0th object table entry.
     */</comment>
    <decl_stmt><decl><type><name>JSObjectBox</name> *</type><name>funbox</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>funbox</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>tcflags</name> &amp; <name>TCF_COMPILE_N_GO</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>source</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Save eval program source in script-&gt;atomMap.vector[0] for the
             * eval cache (see obj_eval in jsobj.cpp).
             */</comment>
            <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>atom</name> || !<call><name><name>cg</name>.<name>atomList</name>.<name>add</name></name><argument_list>(<argument><expr>&amp;<name>jsc</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><name>callerFrame</name> &amp;&amp; <name><name>callerFrame</name>-&gt;<name>fun</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * An eval script in a caller frame needs to have its enclosing
             * function captured in case it refers to an upvar, and someone
             * wishes to decompile it while it's running.
             */</comment>
            <expr_stmt><expr><name>funbox</name> = <call><name><name>jsc</name>.<name>newObjectBox</name></name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name><name>callerFrame</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>funbox</name></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
            <expr_stmt><expr><name><name>funbox</name>-&gt;<name>emitLink</name></name> = <name><name>cg</name>.<name>objectList</name>.<name>lastbox</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>.<name>objectList</name>.<name>lastbox</name></name> = <name>funbox</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>.<name>objectList</name>.<name>length</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * Inline Statements to emit as we go to save AST space. We must generate
     * our script-body blockid since we aren't calling Statements.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>bodyid</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GenerateBlockId</name><argument_list>(<argument><expr>&amp;<name>cg</name></expr></argument>, <argument><expr><name>bodyid</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
    <expr_stmt><expr><name><name>cg</name>.<name>bodyid</name></name> = <name>bodyid</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>onlyXML</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>onlyXML</name> = true</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name><name>jsc</name>.<name>tokenStream</name>.<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jsc</name>.<name>tokenStream</name>.<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> &lt;= <name>TOK_EOF</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_EOF</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tt</name> == <name>TOK_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>

        <expr_stmt><expr><name>pn</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>, <argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cg</name>.<name>blockNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>

        <if>if <condition>(<expr><name><name>cg</name>.<name>functionList</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>jsc</name>.<name>analyzeFunctions</name></name><argument_list>(<argument><expr><name><name>cg</name>.<name>functionList</name></name></expr></argument>, <argument><expr><name><name>cg</name>.<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
            <expr_stmt><expr><name><name>cg</name>.<name>functionList</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> != <name>TOK_SEMI</name> ||
            !<name><name>pn</name>-&gt;<name>pn_kid</name></name> ||
            !<call><name>TREE_TYPE_IS_XML</name><argument_list>(<argument><expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>onlyXML</name> = false</expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <comment type="block">/*
     * Prevent XML data theft via &lt;script src="http://victim.com/foo.xml"&gt;.
     * For background, see:
     *
     * https://bugzilla.mozilla.org/show_bug.cgi?id=336551
     */</comment>
    <if>if <condition>(<expr><name>pn</name> &amp;&amp; <name>onlyXML</name> &amp;&amp; (<name>tcflags</name> &amp; <name>TCF_NO_SCRIPT_RVAL</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_XML_WHOLE_PROGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Global variables and regexps share the index space with locals. Due to
     * incremental code generation we need to patch the bytecode to adjust the
     * local references to skip the globals.
     */</comment>
    <expr_stmt><expr><name>scriptGlobals</name> = <name><name>cg</name>.<name>ngvars</name></name> + <name><name>cg</name>.<name>regexpList</name>.<name>length</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>scriptGlobals</name> != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>code</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>slot</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>scriptGlobals</name> &gt;= <name>SLOTNO_LIMIT</name></expr>)</condition><then>
            <goto>goto <name>too_many_slots</name>;</goto></then></if>
        <expr_stmt><expr><name>code</name> = <call><name>CG_BASE</name><argument_list>(<argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>end</name> = <name>code</name> + <call><name>CG_OFFSET</name><argument_list>(<argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>code</name> != <name>end</name></expr>;</condition> <incr><expr><name>code</name> += <name>len</name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>code</name> &lt; <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>code</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> = (<name><name>cs</name>-&gt;<name>length</name></name> &gt; 0)
                  ? (<name>uintN</name>) <name><name>cs</name>-&gt;<name>length</name></name>
                  : <call><name>js_GetVariableBytecodeLength</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call> == <name>JOF_LOCAL</name> ||
                (<call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call> == <name>JOF_SLOTATOM</name>)</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * JSOP_GETARGPROP also has JOF_SLOTATOM type, but it may be
                 * emitted only for a function.
                 */</comment>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call> == <name>JOF_SLOTATOM</name>) ==
                          (<name>op</name> == <name>JSOP_GETLOCALPROP</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>slot</name> = <call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>slot</name> += <name>scriptGlobals</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>slot</name> &gt;= <name>SLOTNO_LIMIT</name></expr>)</condition><then>
                    <goto>goto <name>too_many_slots</name>;</goto></then></if>
                <expr_stmt><expr><call><name>SET_SLOTNO</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Parser growth: %d (%u nodes, %u max, %u unrecycled)\n"</expr></argument>,
           <argument><expr>(<name>char</name> *)<call><name>sbrk</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> - (<name>char</name> *)<name>before</name></expr></argument>,
           <argument><expr><name>parsenodes</name></expr></argument>,
           <argument><expr><name>maxparsenodes</name></expr></argument>,
           <argument><expr><name>parsenodes</name> - <name>recyclednodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>before</name> = <call><name>sbrk</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Nowadays the threaded interpreter needs a stop instruction, so we
     * do have to emit that here.
     */</comment>
    <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>cg</name></expr></argument>, <argument><expr><name>JSOP_STOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METER_PARSENODES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Code-gen growth: %d (%u bytecodes, %u srcnotes)\n"</expr></argument>,
           <argument><expr>(<name>char</name> *)<call><name>sbrk</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> - (<name>char</name> *)<name>before</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cg</name>.<name>noteCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_ARENAMETER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_DumpArenaStats</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>script</name> = <call><name>js_NewScriptFromCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>script</name> &amp;&amp; <name>funbox</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>flags</name></name> |= <name>JSSF_SAVED_CALLER_FUN</name></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_SCOPE_DEPTH_METER</name></cpp:ifdef>
    <if>if <condition>(<expr><name>script</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><name>scopeChain</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>depth</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>(<name>obj</name> = <call><name>OBJ_GET_PARENT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition>
            <expr_stmt><expr>++<name>depth</name></expr>;</expr_stmt></while>
        <expr_stmt><expr><call><name>JS_BASIC_STATS_ACCUM</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>hostenvScopeDepthStats</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name>codePool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name>notePool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>script</name></expr>;</return>

  <label><name>too_many_slots</name>:</label>
    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_TOO_MANY_LOCALS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>script</name> = <name>NULL</name></expr>;</expr_stmt>
    <goto>goto <name>out</name>;</goto>
}

<comment type="block">/*
 * Insist on a final return before control flows out of pn.  Try to be a bit
 * smart about loops: do {...; return e2;} while(0) at the end of a function
 * that contains an early return e1 will get a strict warning.  Similarly for
 * iloops: while (true){...} is treated as though ... returns.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENDS_IN_OTHER</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENDS_IN_RETURN</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENDS_IN_BREAK</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>

static <function><type><name>int</name></type>
<name>HasFinalReturn</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>rv2</name></decl>, <decl><type ref="prev"/><name>hasDefault</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_LC</name></expr>:
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_head</name></name></expr>)</condition><then>
            <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return></then></if>
        <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>TOK_IF</name></expr>:
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then>
            <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return></then></if>
        <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>)</argument_list></call> &amp; <call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>TOK_WHILE</name></expr>:
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_PRIMARY</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name></expr>)</condition><then>
            <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_dval</name></name></expr>)</condition><then>
            <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return></then></if>
        <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return>

      </case><case>case <expr><name>TOK_DO</name></expr>:
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_PRIMARY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FALSE</name></expr>)</condition><then>
                <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name></expr>)</condition><then>
                <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_dval</name></name> == 0</expr>)</condition><then>
                <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
            <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return>

      </case><case>case <expr><name>TOK_FOR</name></expr>:
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> == <name>PN_TERNARY</name> &amp;&amp; !<name><name>pn2</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then>
            <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return></then></if>
        <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return>

      </case><case>case <expr><name>TOK_SWITCH</name></expr>:
        <expr_stmt><expr><name>rv</name> = <name>ENDS_IN_RETURN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hasDefault</name> = <name>ENDS_IN_OTHER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LEXICALSCOPE</name></expr>)</condition><then>
            <expr_stmt><expr><name>pn2</name> = <call><name><name>pn2</name>-&gt;<name>expr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>rv</name> &amp;&amp; <name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name></expr>)</condition><then>
                <expr_stmt><expr><name>hasDefault</name> = <name>ENDS_IN_RETURN</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_head</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv2</name> = <call><name>HasFinalReturn</name><argument_list>(<argument><expr><call><name><name>pn3</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv2</name> == <name>ENDS_IN_OTHER</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>)</condition><then>
                    <comment type="block">/* Falling through to next case or default. */</comment><empty_stmt>;</empty_stmt></then>
                <else>else
                    <expr_stmt><expr><name>rv</name> &amp;= <name>rv2</name></expr>;</expr_stmt></else></if>
            }</block></then></if>
        }</block></for>
        <comment type="block">/* If a final switch has no default case, we judge it harshly. */</comment>
        <expr_stmt><expr><name>rv</name> &amp;= <name>hasDefault</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>

      </case><case>case <expr><name>TOK_BREAK</name></expr>:
        <return>return <expr><name>ENDS_IN_BREAK</name></expr>;</return>

      </case><case>case <expr><name>TOK_WITH</name></expr>:
        <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>TOK_RETURN</name></expr>:
        <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return>

      </case><case>case <expr><name>TOK_COLON</name></expr>:
      </case><case>case <expr><name>TOK_LEXICALSCOPE</name></expr>:
        <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>expr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>TOK_THROW</name></expr>:
        <return>return <expr><name>ENDS_IN_RETURN</name></expr>;</return>

      </case><case>case <expr><name>TOK_TRY</name></expr>:
        <comment type="block">/* If we have a finally block that returns, we are done. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> == <name>ENDS_IN_RETURN</name></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/* Else check the try block and any and all catch statements. */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>)
                <expr_stmt><expr><name>rv</name> &amp;= <call><name>HasFinalReturn</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>
        <return>return <expr><name>rv</name></expr>;</return>

      </case><case>case <expr><name>TOK_CATCH</name></expr>:
        <comment type="block">/* Check this catch block's body. */</comment>
        <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>TOK_LET</name></expr>:
        <comment type="block">/* Non-binary let statements are let declarations. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> != <name>PN_BINARY</name></expr>)</condition><then>
            <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return></then></if>
        <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>;</return>

      </case><default>default:
        <return>return <expr><name>ENDS_IN_OTHER</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ReportBadReturn</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>errnum</name></decl></param>,
                <param><decl><type><name>uintN</name></type> <name>anonerrnum</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>fun</name>-&gt;<name>atom</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>name</name> = <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>errnum</name> = <name>anonerrnum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>name</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
                                       <argument><expr><name>errnum</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CheckFinalReturn</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>HasFinalReturn</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> == <name>ENDS_IN_RETURN</name> ||
           <call><name>ReportBadReturn</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                           <argument><expr><name>JSMSG_NO_RETURN_VALUE</name></expr></argument>, <argument><expr><name>JSMSG_ANON_NO_RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>FunctionBody</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name></type> <name>stmtInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>, <decl><type ref="prev"/><name>firstLine</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_BLOCK</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmtInfo</name>.<name>flags</name></name> = <name>SIF_BODY_BLOCK</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldflags</name> = <name><name>tc</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp;= ~(<name>TCF_RETURN_EXPR</name> | <name>TCF_RETURN_VOID</name>)</expr>;</expr_stmt>

    <comment type="block">/*
     * Save the body's first line, and store it in pn-&gt;pn_pos.begin.lineno
     * later, because we may have not peeked in ts yet, so Statements won't
     * acquire a valid pn-&gt;pn_pos.begin from the current token.
     */</comment>
    <expr_stmt><expr><name>firstLine</name> = <name><name>ts</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_EXPR_CLOSURES</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_FUN_IS_GENERATOR</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ReportBadReturn</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_GENERATOR_RETURN</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_ANON_GENERATOR_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_RETURN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_RETURN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn</name>-&gt;<name>pn_kid</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
        }</block></then></if>
    }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>pn</name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name>.<name>lineno</name></name> = <name>firstLine</name></expr>;</expr_stmt>

        <comment type="block">/* Check for falling off the end of a function that returns a value. */</comment>
        <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp; (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_RETURN_EXPR</name>) &amp;&amp;
            !<call><name>CheckFinalReturn</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name> | (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_FUN_FLAGS</name>)</expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSAtomListElement</name> *</type>
<name>MakePlaceholder</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr>(<name>JSDefinition</name> *)
        <call><name>NewNameNode</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>dn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>ALE_SET_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_defn</name></name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_PLACEHOLDER</name></expr>;</expr_stmt>
    <return>return <expr><name>ale</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>Define</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>let</name> <init>= <expr>false</expr></init></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_defn</name></name></expr></argument>, <argument><expr><call><name><name>pn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSHashEntry</name> **</type><name>hep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomList</name> *</type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>let</name></expr>)</condition><then>
        <expr_stmt><expr><name>ale</name> = (<name>list</name> = &amp;<name><name>tc</name>-&gt;<name>decls</name></name>)-&gt;<call><name>rawLookup</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
        <expr_stmt><expr><name>ale</name> = (<name>list</name> = &amp;<name><name>tc</name>-&gt;<name>lexdeps</name></name>)-&gt;<call><name>rawLookup</name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dn</name> != <name>pn</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnup</name> <init>= <expr>&amp;<name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnu</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uintN</name></type> <name>start</name> <init>= <expr><name>let</name> ? <name><name>pn</name>-&gt;<name>pn_blockid</name></name> : <name><name>tc</name>-&gt;<name>bodyid</name></name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr>(<name>pnu</name> = *<name>pnup</name>) != <name>NULL</name> &amp;&amp; <name><name>pnu</name>-&gt;<name>pn_blockid</name></name> &gt;= <name>start</name></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pnu</name>-&gt;<name>pn_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pnu</name>-&gt;<name>pn_lexdef</name></name> = (<name>JSDefinition</name> *) <name>pn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name><name>pnu</name>-&gt;<name>pn_dflags</name></name> &amp; (<name>PND_ASSIGNED</name> | <name>PND_FUNARG</name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>pnup</name> = &amp;<name><name>pnu</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt>
            }</block></while>

            <if>if <condition>(<expr><name>pnu</name> != <name><name>dn</name>-&gt;<name>dn_uses</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>pnup</name> = <name><name>pn</name>-&gt;<name>dn_uses</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>dn_uses</name></name> = <name><name>dn</name>-&gt;<name>dn_uses</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dn</name>-&gt;<name>dn_uses</name></name> = <name>pnu</name></expr>;</expr_stmt>

                <if>if <condition>(<expr>(!<name>pnu</name> || <name><name>pnu</name>-&gt;<name>pn_blockid</name></name> &lt; <name><name>tc</name>-&gt;<name>bodyid</name></name>) &amp;&amp; <name>list</name> != &amp;<name><name>tc</name>-&gt;<name>decls</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>list</name>-&gt;<name>rawRemove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>ale</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>decls</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>let</name> ? <name><name>JSAtomList</name>::<name>SHADOW</name></name> : <name><name>JSAtomList</name>::<name>UNIQUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name>ALE_SET_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_defn</name></name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp;= ~<name>PND_PLACEHOLDER</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LinkUseToDef</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSDefinition</name> *</type><name>dn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn</name> != <name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_link</name></name> = <name><name>dn</name>-&gt;<name>dn_uses</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>dn_uses</name></name> = <name>pn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_used</name></name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_lexdef</name></name> = <name>dn</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ForgetUse</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnup</name> <init>= <expr>&amp;<call><name><name>pn</name>-&gt;<name>lexdef</name></name><argument_list>()</argument_list></call>-&gt;<name>dn_uses</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnu</name></decl>;</decl_stmt>
    <while>while <condition>(<expr>(<name>pnu</name> = *<name>pnup</name>) != <name>pn</name></expr>)</condition>
        <expr_stmt><expr><name>pnup</name> = &amp;<name><name>pnu</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt></while>
    <expr_stmt><expr>*<name>pnup</name> = <name><name>pn</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_used</name></name> = false</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>MakeAssignment</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>rhs</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lhs</name> <init>= <expr><call><name>NewOrRecycledNode</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>lhs</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>lhs</name> = *<name>pn</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_lexdef</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnup</name> <init>= <expr>&amp;<name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr>*<name>pnup</name> != <name>pn</name></expr>)</condition>
            <expr_stmt><expr><name>pnup</name> = &amp;<name>(*<name>pnup</name>)-&gt;<name>pn_link</name></name></expr>;</expr_stmt></while>
        <expr_stmt><expr>*<name>pnup</name> = <name>lhs</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lhs</name>-&gt;<name>pn_link</name></name> = <name><name>pn</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_link</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_ASSIGN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_BINARY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_used</name></name> = <name><name>pn</name>-&gt;<name>pn_defn</name></name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>lhs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>rhs</name></expr>;</expr_stmt>
    <return>return <expr><name>lhs</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>MakeDefIntoUse</name><parameter_list>(<param><decl><type><name>JSDefinition</name> *</type><name>dn</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * If dn is var, const, or let, and it has an initializer, then we must
     * rewrite it to be an assignment node, whose freshly allocated left-hand
     * side becomes a use of pn.
     */</comment>
    <if>if <condition>(<expr><call><name><name>dn</name>-&gt;<name>isBindingForm</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>rhs</name> <init>= <expr><call><name><name>dn</name>-&gt;<name>expr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>rhs</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lhs</name> <init>= <expr><call><name>MakeAssignment</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>lhs</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <comment type="line">//pn-&gt;dn_uses = lhs;</comment>
            <expr_stmt><expr><name>dn</name> = (<name>JSDefinition</name> *) <name>lhs</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_op</name></name> = (<name><name>js_CodeSpec</name><index>[<expr><name><name>dn</name>-&gt;<name>pn_op</name></name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_SET</name>) ? <name>JSOP_SETNAME</name> : <name>JSOP_NAME</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>dn</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call> == <name><name>JSDefinition</name>::<name>FUNCTION</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>dn</name>-&gt;<name>isTopLevel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_type</name></name> = <name>TOK_NAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_atom</name></name> = <name>atom</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* Now make dn no longer a definition, rather a use of pn. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_atom</name></name> == <name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pnu</name> <init>= <expr><name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</init> <condition><expr><name>pnu</name></expr>;</condition> <incr><expr><name>pnu</name> = <name><name>pnu</name>-&gt;<name>pn_link</name></name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pnu</name>-&gt;<name>pn_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pnu</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pnu</name>-&gt;<name>pn_lexdef</name></name> = (<name>JSDefinition</name> *) <name>pn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name><name>pnu</name>-&gt;<name>pn_dflags</name></name> &amp; (<name>PND_ASSIGNED</name> | <name>PND_FUNARG</name>)</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name><name>dn</name>-&gt;<name>pn_dflags</name></name> &amp; (<name>PND_ASSIGNED</name> | <name>PND_FUNARG</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>dn_uses</name></name> = <name>dn</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_defn</name></name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_used</name></name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_lexdef</name></name> = (<name>JSDefinition</name> *) <name>pn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> &amp;= ~<name>PND_BOUND</name></expr>;</expr_stmt>
    <return>return <expr><name>dn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DefineArg</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>i</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>argpn</name></decl>, *<decl><type ref="prev"/><name>argsbody</name></decl>;</decl_stmt>

    <comment type="block">/* Flag tc so we don't have to lookup arguments on every use. */</comment>
    <if>if <condition>(<expr><name>atom</name> == <name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_PARAM_ARGUMENTS</name></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * Make an argument definition node, distinguished by being in tc-&gt;decls
     * but having TOK_NAME type and JSOP_NOP op. Insert it in a TOK_ARGSBODY
     * list node returned via pn-&gt;pn_body.
     */</comment>
    <expr_stmt><expr><name>argpn</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>argpn</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>argpn</name></expr></argument>)</argument_list></call> == <name>TOK_NAME</name> &amp;&amp; <call><name>PN_OP</name><argument_list>(<argument><expr><name>argpn</name></expr></argument>)</argument_list></call> == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Arguments are initialized by definition. */</comment>
    <expr_stmt><expr><name><name>argpn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_INITIALIZED</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>Define</name><argument_list>(<argument><expr><name>argpn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><name>argsbody</name> = <name><name>pn</name>-&gt;<name>pn_body</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>argsbody</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>argsbody</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>argsbody</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name><name>argsbody</name>-&gt;<name>pn_type</name></name> = <name>TOK_ARGSBODY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argsbody</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>argsbody</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_body</name></name> = <name>argsbody</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>argsbody</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>argpn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>argpn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETARG</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argpn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argpn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Compile a JS function body, which might appear as the value of an event
 * handler attribute in an HTML &lt;INPUT&gt; tag.
 */</comment>
<function><type><name>bool</name></type>
<name><name>JSCompiler</name>::<name>compileFunctionBody</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSFunction</name> *</type><name>fun</name></decl></param>, <param><decl><type><name>JSPrincipals</name> *</type><name>principals</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>JSCompiler</name></type> <name>jsc</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>principals</name></type></decl></param>)</parameter_list>;</function_decl>

    <if>if <condition>(<expr>!<call><name><name>jsc</name>.<name>init</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* No early return from after here until the js_FinishArenaPool calls. */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name></type> <name>codePool</name></decl>, <decl><type ref="prev"/><name>notePool</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_INIT_ARENA_POOL</name><argument_list>(<argument><expr>&amp;<name>codePool</name></expr></argument>, <argument><expr>"code"</expr></argument>, <argument><expr>1024</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_INIT_ARENA_POOL</name><argument_list>(<argument><expr>&amp;<name>notePool</name></expr></argument>, <argument><expr>"note"</expr></argument>, <argument><expr>1024</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSCodeGenerator</name></type> <name>funcg</name><argument_list>(<argument><expr>&amp;<name>jsc</name></expr></argument>, <argument><expr>&amp;<name>codePool</name></expr></argument>, <argument><expr>&amp;<name>notePool</name></expr></argument>, <argument><expr><name><name>jsc</name>.<name>tokenStream</name>.<name>lineno</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>funcg</name>.<name>flags</name></name> |= <name>TCF_IN_FUNCTION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funcg</name>.<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>GenerateBlockId</name><argument_list>(<argument><expr>&amp;<name>funcg</name></expr></argument>, <argument><expr><name><name>funcg</name>.<name>bodyid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* FIXME: make Function format the source for a function definition. */</comment>
    <expr_stmt><expr><name><name>jsc</name>.<name>tokenStream</name>.<name>tokens</name><index>[<expr>0</expr>]</index></name>.<name>type</name> = <name>TOK_NAME</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>fn</name> <init>= <expr><call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_FUNC</name></expr></argument>, <argument><expr>&amp;<name>funcg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>fn</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>uintN</name></type> <name>nargs</name> <init>= <expr><name><name>fun</name>-&gt;<name>nargs</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>nargs</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsuword</name> *</type><name>names</name> <init>= <expr><call><name>js_GetLocalNameArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>names</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>fn</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <for>for (<init><decl><type><name>uintN</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nargs</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>name</name> <init>= <expr><call><name>JS_LOCAL_NAME_TO_ATOM</name><argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name>DefineArg</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>funcg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>fn</name> = <name>NULL</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
            }</block></else></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * Farble the body so that it looks like a block statement to js_EmitTree,
     * which is called from js_EmitFunctionBody (see jsemit.cpp).  After we're
     * done parsing, we must fold constants, analyze any nested functions, and
     * generate code for this function, including a stop opcode at the end.
     */</comment>
    <expr_stmt><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>)</argument_list></call>.<name>type</name> = <name>TOK_LC</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name>fn</name> ? <call><name>FunctionBody</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>, <argument><expr>&amp;<name>funcg</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>, <argument><expr><name>TOK_EOF</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jsc</name>.<name>tokenStream</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>funcg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* js_FoldConstants reported the error already. */</comment>
            <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>funcg</name>.<name>functionList</name></name> &amp;&amp;
                   !<call><name><name>jsc</name>.<name>analyzeFunctions</name></name><argument_list>(<argument><expr><name><name>funcg</name>.<name>functionList</name></name></expr></argument>, <argument><expr><name><name>funcg</name>.<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name><name>fn</name>-&gt;<name>pn_body</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name><name>fn</name>-&gt;<name>pn_body</name></name></expr></argument>)</argument_list></call> == <name>TOK_ARGSBODY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>fn</name>-&gt;<name>pn_body</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name>-&gt;<name>pn_pos</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <name><name>fn</name>-&gt;<name>pn_body</name></name></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name>js_EmitFunctionScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>funcg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
        }</block></else></if></else></if></else></if>
    }</block></then></if>

    <comment type="block">/* Restore saved state and release code generation arenas. */</comment>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name>codePool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name>notePool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pn</name> != <name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Parameter block types for the several Binder functions.  We use a common
 * helper function signature in order to share code among destructuring and
 * simple variable declaration parsers.  In the destructuring case, the binder
 * function is called indirectly from the variable declaration parser by way
 * of CheckDestructuring and its friends.
 */</comment>
<typedef>typedef <type>struct <name>BindData</name></type> <name>BindData</name>;</typedef>

<typedef>typedef <function_decl><type><name>JSBool</name></type>
(*<name>Binder</name>)<parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>BindData</name> <block>{<public type="default">
    <constructor><name>BindData</name><parameter_list>()</parameter_list> <member_list>: <call><name>fresh</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

    <decl_stmt><decl><type><name>JSParseNode</name>     *</type><name>pn</name></decl>;</decl_stmt>        <comment type="block">/* name node for definition processing and
                                   error source coordinates */</comment>
    <decl_stmt><decl><type><name>JSOp</name></type>            <name>op</name></decl>;</decl_stmt>         <comment type="block">/* prolog bytecode or nop */</comment>
    <decl_stmt><decl><type><name>Binder</name></type>          <name>binder</name></decl>;</decl_stmt>     <comment type="block">/* binder, discriminates u */</comment>
    <union>union <block>{<public type="default">
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><name>uintN</name></type>   <name>overflow</name></decl>;</decl_stmt>
        </public>}</block> <decl><name>let</name></decl>;</struct>
    </public>}</block>;</union>
    <decl_stmt><decl><type><name>bool</name></type> <name>fresh</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindLocalVariable</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSFunction</name> *</type><name>fun</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>,
                  <param><decl><type><name>JSLocalKind</name></type> <name>localKind</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>localKind</name> == <name>JSLOCAL_VAR</name> || <name>localKind</name> == <name>JSLOCAL_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Don't bind a variable with the hidden name 'arguments', per ECMA-262.
     * Instead 'var arguments' always restates the predefined property of the
     * activation objects whose name is 'arguments'. Assignment to such a
     * variable must be handled specially.
     */</comment>
    <if>if <condition>(<expr><name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <return>return <expr><call><name>js_AddLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>localKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
<comment type="block">/*
 * Forward declaration to maintain top-down presentation.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>DestructuringExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                  <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindDestructuringArg</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>,
                     <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <comment type="block">/* Flag tc so we don't have to lookup arguments on every use. */</comment>
    <if>if <condition>(<expr><name>atom</name> == <name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_PARAM_ARGUMENTS</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <name><name>data</name>-&gt;<name>pn</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ale</name> &amp;&amp; !<call><name>Define</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSLocalKind</name></type> <name>localKind</name> <init>= <expr><call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>localKind</name> != <name>JSLOCAL_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_DESTRUCT_DUP_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name> <init>= <expr><name><name>tc</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nvars</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>BindLocalVariable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>JSLOCAL_VAR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETLOCAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DESTRUCTURING */</comment>

<function><type><name>JSFunction</name> *</type>
<name><name>JSCompiler</name>::<name>newFunction</name></name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>lambda</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>lambda</name> &amp; ~<name>JSFUN_LAMBDA</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find the global compilation context in order to pre-set the newborn
     * function's parent slot to tc-&gt;scopeChain. If the global context is a
     * compile-and-go one, we leave the pre-set parent intact; otherwise we
     * clear parent and proto.
     */</comment>
    <while>while <condition>(<expr><name><name>tc</name>-&gt;<name>parent</name></name></expr>)</condition>
        <expr_stmt><expr><name>tc</name> = <name><name>tc</name>-&gt;<name>parent</name></name></expr>;</expr_stmt></while>
    <expr_stmt><expr><name>parent</name> = (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>) ? <name>NULL</name> : <name><name>tc</name>-&gt;<name>scopeChain</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>fun</name> = <call><name>js_NewFunction</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>JSFUN_INTERPRETED</name> | <name>lambda</name></expr></argument>,
                         <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>fun</name> &amp;&amp; !(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_COMPILE_N_GO</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>STOBJ_CLEAR_PARENT</name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STOBJ_CLEAR_PROTO</name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>fun</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>MatchOrInsertSemicolon</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_PeekTokenSameLine</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>tt</name> != <name>TOK_EOF</name> &amp;&amp; <name>tt</name> != <name>TOK_EOL</name> &amp;&amp; <name>tt</name> != <name>TOK_SEMI</name> &amp;&amp; <name>tt</name> != <name>TOK_RC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_SEMI_BEFORE_STMNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>(<name>void</name>) <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_SEMI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name><name>JSCompiler</name>::<name>analyzeFunctions</name></name><parameter_list>(<param><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name></decl></param>, <param><decl><type><name>uint16</name>&amp;</type> <name>tcflags</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>markFunArgs</name><argument_list>(<argument><expr><name>funbox</name></expr></argument>, <argument><expr><name>tcflags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name>setFunctionKinds</name><argument_list>(<argument><expr><name>funbox</name></expr></argument>, <argument><expr><name>tcflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Mark as funargs any functions that reach up to one or more upvars across an
 * already-known funarg. The parser will flag the o_m lambda as a funarg in:
 *
 *   function f(o, p) {
 *       o.m = function o_m(a) {
 *           function g() { return p; }
 *           function h() { return a; }
 *           return g() + h();
 *       }
 *   }
 *
 * but without this extra marking phase, function g will not be marked as a
 * funarg since it is called from within its parent scope. But g reaches up to
 * f's parameter p, so if o_m escapes f's activation scope, g does too and
 * cannot use JSOP_GETUPVAR to reach p. In contast function h neither escapes
 * nor uses an upvar "above" o_m's level.
 *
 * If function g itself contained lambdas that contained non-lambdas that reach
 * up above its level, then those non-lambdas would have to be marked too. This
 * process is potentially exponential in the number of functions, but generally
 * not so complex. But it can't be done during a single recursive traversal of
 * the funbox tree, so we must use a work queue.
 *
 * Return the minimal "skipmin" for funbox and its siblings. This is the delta
 * between the static level of the bodies of funbox and its peers (which must
 * be funbox-&gt;level + 1), and the static level of the nearest upvar among all
 * the upvars contained by funbox and its peers. If there are no upvars, return
 * FREE_STATIC_LEVEL. Thus this function never returns 0.
 */</comment>
<function><type><specifier>static</specifier> <name>uintN</name></type>
<name>FindFunArgs</name><parameter_list>(<param><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><name>JSFunctionBoxQueue</name> *</type><name>queue</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>allskipmin</name> <init>= <expr><name>FREE_STATIC_LEVEL</name></expr></init></decl>;</decl_stmt>

    <do>do <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>fn</name> <init>= <expr><name><name>funbox</name>-&gt;<name>node</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr>(<name>JSFunction</name> *) <name><name>funbox</name>-&gt;<name>object</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>fnlevel</name> <init>= <expr><name>level</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * An eval can leak funbox, functions along its ancestor line, and its
         * immediate kids. Since FindFunArgs uses DFS and the parser propagates
         * TCF_FUN_HEAVYWEIGHT bottom up, funbox's ancestor function nodes have
         * already been marked as funargs by this point. Therefore we have to
         * flag only funbox-&gt;node and funbox-&gt;kids' nodes here.
         */</comment>
        <if>if <condition>(<expr><name><name>funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_HEAVYWEIGHT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>fn</name>-&gt;<name>setFunArg</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>JSFunctionBox</name> *</type><name>kid</name> <init>= <expr><name><name>funbox</name>-&gt;<name>kids</name></name></expr></init></decl>;</init> <condition><expr><name>kid</name></expr>;</condition> <incr><expr><name>kid</name> = <name><name>kid</name>-&gt;<name>siblings</name></name></expr></incr>)
                <expr_stmt><expr><call><name><name>kid</name>-&gt;<name>node</name>-&gt;<name>setFunArg</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>

        <comment type="block">/*
         * Compute in skipmin the least distance from fun's static level up to
         * an upvar, whether used directly by fun, or indirectly by a function
         * nested in fun.
         */</comment>
        <decl_stmt><decl><type><name>uintN</name></type> <name>skipmin</name> <init>= <expr><name>FREE_STATIC_LEVEL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>fn</name>-&gt;<name>pn_body</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_UPVARS</name></expr>)</condition><then> <block>{
            <function_decl><type><name>JSAtomList</name></type> <name>upvars</name><parameter_list>(<param><decl><type><name><name>pn</name>-&gt;<name>pn_names</name></name></type></decl></param>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>upvars</name>.<name>count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>JSAtomListIterator</name></type> <name>iter</name><argument_list>(<argument><expr>&amp;<name>upvars</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

            <while>while <condition>(<expr>(<name>ale</name> = <call><name>iter</name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>lexdep</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>resolve</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr>!<call><name><name>lexdep</name>-&gt;<name>isFreeVar</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>uintN</name></type> <name>upvarLevel</name> <init>= <expr><call><name><name>lexdep</name>-&gt;<name>frameLevel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><call><name>int</name><argument_list>(<argument><expr><name>upvarLevel</name></expr></argument>)</argument_list></call> &lt;= <name>fnlevel</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>fn</name>-&gt;<name>setFunArg</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

                    <decl_stmt><decl><type><name>uintN</name></type> <name>skip</name> <init>= <expr>(<name><name>funbox</name>-&gt;<name>level</name></name> + 1) - <name>upvarLevel</name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>skip</name> &lt; <name>skipmin</name></expr>)</condition><then>
                        <expr_stmt><expr><name>skipmin</name> = <name>skip</name></expr>;</expr_stmt></then></if>
                }</block></then></if>
            }</block></while>
        }</block></then></if>

        <comment type="block">/*
         * If this function escapes, whether directly (the parser detects such
         * escapes) or indirectly (because this non-escaping function uses an
         * upvar that reaches across an outer function boundary where the outer
         * function escapes), enqueue it for further analysis, and bump fnlevel
         * to trap any non-escaping children.
         */</comment>
        <if>if <condition>(<expr><call><name><name>fn</name>-&gt;<name>isFunArg</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>queue</name>-&gt;<name>push</name></name><argument_list>(<argument><expr><name>funbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>fnlevel</name> = <call><name>int</name><argument_list>(<argument><expr><name><name>funbox</name>-&gt;<name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * Now process the current function's children, and recalibrate their
         * cumulative skipmin to be relative to the current static level.
         */</comment>
        <if>if <condition>(<expr><name><name>funbox</name>-&gt;<name>kids</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uintN</name></type> <name>kidskipmin</name> <init>= <expr><call><name>FindFunArgs</name><argument_list>(<argument><expr><name><name>funbox</name>-&gt;<name>kids</name></name></expr></argument>, <argument><expr><name>fnlevel</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>kidskipmin</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>kidskipmin</name> != <name>FREE_STATIC_LEVEL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>--<name>kidskipmin</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>kidskipmin</name> != 0 &amp;&amp; <name>kidskipmin</name> &lt; <name>skipmin</name></expr>)</condition><then>
                    <expr_stmt><expr><name>skipmin</name> = <name>kidskipmin</name></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/*
         * Finally, after we've traversed all of the current function's kids,
         * minimize fun's skipmin against our accumulated skipmin. Do likewise
         * with allskipmin, but minimize across funbox and all of its siblings,
         * to compute our return value.
         */</comment>
        <if>if <condition>(<expr><name>skipmin</name> != <name>FREE_STATIC_LEVEL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>skipmin</name></name> = <name>skipmin</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>skipmin</name> &lt; <name>allskipmin</name></expr>)</condition><then>
                <expr_stmt><expr><name>allskipmin</name> = <name>skipmin</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block> while <condition>(<expr>(<name>funbox</name> = <name><name>funbox</name>-&gt;<name>siblings</name></name>) != <name>NULL</name></expr>)</condition>;</do>

    <return>return <expr><name>allskipmin</name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name><name>JSCompiler</name>::<name>markFunArgs</name></name><parameter_list>(<param><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>tcflags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunctionBoxQueue</name></type> <name>queue</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>queue</name>.<name>init</name></name><argument_list>(<argument><expr><name>functionCount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name>FindFunArgs</name><argument_list>(<argument><expr><name>funbox</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>(<name>funbox</name> = <call><name><name>queue</name>.<name>pull</name></name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>fn</name> <init>= <expr><name><name>funbox</name>-&gt;<name>node</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>fn</name>-&gt;<name>isFunArg</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>fn</name>-&gt;<name>pn_body</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_UPVARS</name></expr>)</condition><then> <block>{
            <function_decl><type><name>JSAtomList</name></type> <name>upvars</name><parameter_list>(<param><decl><type><name><name>pn</name>-&gt;<name>pn_names</name></name></type></decl></param>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>upvars</name>.<name>count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>JSAtomListIterator</name></type> <name>iter</name><argument_list>(<argument><expr>&amp;<name>upvars</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

            <while>while <condition>(<expr>(<name>ale</name> = <call><name>iter</name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>lexdep</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>resolve</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr>!<call><name><name>lexdep</name>-&gt;<name>isFreeVar</name></name><argument_list>()</argument_list></call> &amp;&amp;
                    !<call><name><name>lexdep</name>-&gt;<name>isFunArg</name></name><argument_list>()</argument_list></call> &amp;&amp;
                    <call><name><name>lexdep</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call> == <name><name>JSDefinition</name>::<name>FUNCTION</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Mark this formerly-Algol-like function as an escaping
                     * function (i.e., as a funarg), because it is used from a
                     * funarg and therefore can not use JSOP_{GET,CALL}UPVAR to
                     * access upvars.
                     *
                     * Progress is guaranteed because we set the funarg flag
                     * here, which suppresses revisiting this function (thanks
                     * to the !lexdep-&gt;isFunArg() test just above).
                     */</comment>
                    <expr_stmt><expr><call><name><name>lexdep</name>-&gt;<name>setFunArg</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>afunbox</name> <init>= <expr><name><name>lexdep</name>-&gt;<name>pn_funbox</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>queue</name>.<name>push</name></name><argument_list>(<argument><expr><name>afunbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Walk over nested functions again, now that we have
                     * changed the level across which it is unsafe to access
                     * upvars using the runtime dynamic link (frame chain).
                     */</comment>
                    <if>if <condition>(<expr><name><name>afunbox</name>-&gt;<name>kids</name></name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>FindFunArgs</name><argument_list>(<argument><expr><name><name>afunbox</name>-&gt;<name>kids</name></name></expr></argument>, <argument><expr><name><name>afunbox</name>-&gt;<name>level</name></name></expr></argument>, <argument><expr>&amp;<name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></then></if>
            }</block></while>
        }</block></then></if>
    }</block></while>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>MinBlockId</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>id</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>fn</name>-&gt;<name>pn_blockid</name></name> &lt; <name>id</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>fn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>fn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</init> <condition><expr><name>pn</name></expr>;</condition> <incr><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_link</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> &lt; <name>id</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
    }</block></then></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>OneBlockId</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>id</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>fn</name>-&gt;<name>pn_blockid</name></name> != <name>id</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>fn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>fn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</init> <condition><expr><name>pn</name></expr>;</condition> <incr><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_link</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> != <name>id</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
    }</block></then></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSCompiler</name>::<name>setFunctionKinds</name></name><parameter_list>(<param><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name></decl></param>, <param><decl><type><name>uint16</name>&amp;</type> <name>tcflags</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_FUNCTION_METERING</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FUN_METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>JS_RUNTIME_METER(context-&gt;runtime, functionMeter.x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FUN_METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>parent</name> <init>= <expr><name><name>funbox</name>-&gt;<name>parent</name></name></expr></init></decl>;</decl_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>fn</name> <init>= <expr><name><name>funbox</name>-&gt;<name>node</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>funbox</name>-&gt;<name>kids</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>setFunctionKinds</name><argument_list>(<argument><expr><name><name>funbox</name>-&gt;<name>kids</name></name></expr></argument>, <argument><expr><name>tcflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>fn</name>-&gt;<name>pn_body</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr>(<name>JSFunction</name> *) <name><name>funbox</name>-&gt;<name>object</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>allfun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_HEAVYWEIGHT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>heavy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>FUN_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call> == <name>JSFUN_INTERPRETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_UPVARS</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * No lexical dependencies =&gt; null closure, for best performance.
             * A null closure needs no scope chain, but alas we've coupled
             * principals-finding to scope (for good fundamental reasons, but
             * the implementation overloads the parent slot and we should fix
             * that). See, e.g., the JSOP_LAMBDA case in jsinterp.cpp.
             *
             * In more detail: the ES3 spec allows the implementation to create
             * "joined function objects", or not, at its discretion. But real-
             * world implementations always create unique function objects for
             * closures, and this can be detected via mutation. Open question:
             * do popular implementations create unique function objects for
             * null closures?
             *
             * FIXME: bug 476950.
             */</comment>
            <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>nofreeupvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FUN_SET_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>JSFUN_NULL_CLOSURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <function_decl><type><name>JSAtomList</name></type> <name>upvars</name><parameter_list>(<param><decl><type><name><name>pn</name>-&gt;<name>pn_names</name></name></type></decl></param>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>upvars</name>.<name>count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>JSAtomListIterator</name></type> <name>iter</name><argument_list>(<argument><expr>&amp;<name>upvars</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name><name>fn</name>-&gt;<name>isFunArg</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * This function is Algol-like, it never escapes. So long as it
                 * does not assign to outer variables, it needs only an upvars
                 * array in its script and JSOP_{GET,CALL}UPVAR opcodes in its
                 * bytecode to reach up the frame stack at runtime based on
                 * those upvars' cookies.
                 *
                 * Any assignments to upvars from functions called by this one
                 * will be coherent because of the JSOP_{GET,CALL}UPVAR ops,
                 * which load from stack homes when interpreting or from native
                 * stack slots when executing a trace.
                 *
                 * We could add JSOP_SETUPVAR, etc., but it is uncommon for a
                 * nested function to assign to an outer lexical variable, so
                 * we defer adding yet more code footprint in the absence of
                 * evidence motivating these opcodes.
                 */</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>mutation</name> <init>= <expr>!!(<name><name>funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_SETS_OUTER_NAME</name>)</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uintN</name></type> <name>nupvars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Check that at least one outer lexical binding was assigned
                 * to (global variables don't count). This is conservative: we
                 * could limit assignments to those in the current function,
                 * but that's too much work. As with flat closures (handled
                 * below), we optimize for the case where outer bindings are
                 * not reassigned anywhere.
                 */</comment>
                <while>while <condition>(<expr>(<name>ale</name> = <call><name>iter</name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>lexdep</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>resolve</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr>!<call><name><name>lexdep</name>-&gt;<name>isFreeVar</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>lexdep</name>-&gt;<name>frameLevel</name></name><argument_list>()</argument_list></call> &lt;= <name><name>funbox</name>-&gt;<name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr>++<name>nupvars</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name><name>lexdep</name>-&gt;<name>isAssigned</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <break>break;</break></then></if>
                    }</block></then></if>
                }</block></while>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                    <expr_stmt><expr><name>mutation</name> = false</expr>;</expr_stmt></then></if>

                <if>if <condition>(<expr><name>nupvars</name> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>onlyfreevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FUN_SET_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>JSFUN_NULL_CLOSURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr>!<name>mutation</name> &amp;&amp; !(<name><name>funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_IS_GENERATOR</name>)</expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Algol-like functions can read upvars using the dynamic
                     * link (cx-&gt;fp/fp-&gt;down). They do not need to entrain and
                     * search their environment.
                     */</comment>
                    <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>display</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FUN_SET_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>JSFUN_NULL_CLOSURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr>!(<name><name>funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_IS_GENERATOR</name>)</expr>)</condition><then>
                        <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>setupvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></else></if></else></if>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>uintN</name></type> <name>nupvars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * For each lexical dependency from this closure to an outer
                 * binding, analyze whether it is safe to copy the binding's
                 * value into a flat closure slot when the closure is formed.
                 */</comment>
                <while>while <condition>(<expr>(<name>ale</name> = <call><name>iter</name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>lexdep</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>resolve</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr>!<call><name><name>lexdep</name>-&gt;<name>isFreeVar</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr>++<name>nupvars</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Consider the current function (the lambda, innermost
                         * below) using a var x defined two static levels up:
                         *
                         *  function f() {
                         *      // z = g();
                         *      var x = 42;
                         *      function g() {
                         *          return function () { return x; };
                         *      }
                         *      return g();
                         *  }
                         *
                         * So long as (1) the initialization in 'var x = 42'
                         * dominates all uses of g and (2) x is not reassigned,
                         * it is safe to optimize the lambda to a flat closure.
                         * Uncommenting the early call to g makes it unsafe to
                         * so optimize (z could name a global setter that calls
                         * its argument).
                         */</comment>
                        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>afunbox</name> <init>= <expr><name>funbox</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>uintN</name></type> <name>lexdepLevel</name> <init>= <expr><call><name><name>lexdep</name>-&gt;<name>frameLevel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>lexdepLevel</name> &lt;= <name><name>funbox</name>-&gt;<name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <while>while <condition>(<expr><name><name>afunbox</name>-&gt;<name>level</name></name> != <name>lexdepLevel</name></expr>)</condition> <block>{
                            <expr_stmt><expr><name>afunbox</name> = <name><name>afunbox</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>

                            <comment type="block">/*
                             * afunbox can't be null because we are sure
                             * to find a function box whose level == lexdepLevel
                             * before walking off the top of the funbox tree.
                             * See bug 493260 comments 16-18.
                             *
                             * Assert but check anyway, to check future changes
                             * that bind eval upvars in the parser.
                             */</comment>
                            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>afunbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/*
                             * If this function is reaching up across an
                             * enclosing funarg, we cannot make a flat
                             * closure. The display stops working once the
                             * funarg escapes.
                             */</comment>
                            <if>if <condition>(<expr>!<name>afunbox</name> || <call><name><name>afunbox</name>-&gt;<name>node</name>-&gt;<name>isFunArg</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                                <goto>goto <name>break2</name>;</goto></then></if>
                        }</block></while>

                        <comment type="block">/*
                         * If afunbox's function (which is at the same level as
                         * lexdep) is in a loop, pessimistically assume the
                         * variable initializer may be in the same loop. A flat
                         * closure would then be unsafe, as the captured
                         * variable could be assigned after the closure is
                         * created. See bug 493232.
                         */</comment>
                        <if>if <condition>(<expr><name><name>afunbox</name>-&gt;<name>inLoop</name></name></expr>)</condition><then>
                            <break>break;</break></then></if>

                        <comment type="block">/*
                         * with and eval defeat lexical scoping; eval anywhere
                         * in a variable's scope can assign to it. Both defeat
                         * the flat closure optimization. The parser detects
                         * these cases and flags the function heavyweight.
                         */</comment>
                        <if>if <condition>(<expr>(<name><name>afunbox</name>-&gt;<name>parent</name></name> ? <name><name>afunbox</name>-&gt;<name>parent</name>-&gt;<name>tcflags</name></name> : <name>tcflags</name>)
                            &amp; <name>TCF_FUN_HEAVYWEIGHT</name></expr>)</condition><then> <block>{
                            <break>break;</break>
                        }</block></then></if>

                        <comment type="block">/*
                         * If afunbox's function is not a lambda, it will be
                         * hoisted, so it could capture the undefined value
                         * that by default initializes var/let/const
                         * bindings. And if lexdep is a function that comes at
                         * (meaning a function refers to its own name) or
                         * strictly after afunbox, we also break to defeat the
                         * flat closure optimization.
                         */</comment>
                        <decl_stmt><decl><type><name>JSFunction</name> *</type><name>afun</name> <init>= <expr>(<name>JSFunction</name> *) <name><name>afunbox</name>-&gt;<name>object</name></name></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr>!(<name><name>afun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_LAMBDA</name>)</expr>)</condition><then> <block>{
                            <if>if <condition>(<expr><call><name><name>lexdep</name>-&gt;<name>isBindingForm</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                                <break>break;</break></then></if>
                            <if>if <condition>(<expr><name><name>lexdep</name>-&gt;<name>pn_pos</name></name> &gt;= <name><name>afunbox</name>-&gt;<name>node</name>-&gt;<name>pn_pos</name></name></expr>)</condition><then>
                                <break>break;</break></then></if>
                        }</block></then></if>

                        <if>if <condition>(<expr>!<call><name><name>lexdep</name>-&gt;<name>isInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <break>break;</break></then></if>

                        <decl_stmt><decl><type><name><name>JSDefinition</name>::<name>Kind</name></name></type> <name>lexdepKind</name> <init>= <expr><call><name><name>lexdep</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>lexdepKind</name> != <name><name>JSDefinition</name>::<name>CONST</name></name></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr><call><name><name>lexdep</name>-&gt;<name>isAssigned</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                                <break>break;</break></then></if>

                            <comment type="block">/*
                             * Any formal could be mutated behind our back via
                             * the arguments object, so deoptimize if the outer
                             * function uses arguments.
                             *
                             * In a Function constructor call where the final
                             * argument -- the body source for the function to
                             * create -- contains a nested function definition
                             * or expression, afunbox-&gt;parent will be null. The
                             * body source might use |arguments| outside of any
                             * nested functions it may contain, so we have to
                             * check the tcflags parameter that was passed in
                             * from JSCompiler::compileFunctionBody.
                             */</comment>
                            <if>if <condition>(<expr><name>lexdepKind</name> == <name><name>JSDefinition</name>::<name>ARG</name></name> &amp;&amp;
                                ((<name><name>afunbox</name>-&gt;<name>parent</name></name> ? <name><name>afunbox</name>-&gt;<name>parent</name>-&gt;<name>tcflags</name></name> : <name>tcflags</name>) &amp;
                                 <name>TCF_FUN_USES_ARGUMENTS</name>)</expr>)</condition><then> <block>{
                                <break>break;</break>
                            }</block></then></if>
                        }</block></then></if>

                        <comment type="block">/*
                         * Check quick-and-dirty dominance relation. Function
                         * definitions dominate their uses thanks to hoisting.
                         * Other binding forms hoist as undefined, of course,
                         * so check forward-reference and blockid relations.
                         */</comment>
                        <if>if <condition>(<expr><name>lexdepKind</name> != <name><name>JSDefinition</name>::<name>FUNCTION</name></name></expr>)</condition><then> <block>{
                            <comment type="block">/*
                             * Watch out for code such as
                             *
                             *   (function () {
                             *   ...
                             *   var jQuery = ... = function (...) {
                             *       return new jQuery.foo.bar(baz);
                             *   }
                             *   ...
                             *   })();
                             *
                             * where the jQuery var is not reassigned, but of
                             * course is not initialized at the time that the
                             * would-be-flat closure containing the jQuery
                             * upvar is formed.
                             */</comment>
                            <if>if <condition>(<expr><name><name>lexdep</name>-&gt;<name>pn_pos</name>.<name>end</name></name> &gt;= <name><name>afunbox</name>-&gt;<name>node</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>)</condition><then>
                                <break>break;</break></then></if>

                            <if>if <condition>(<expr><call><name><name>lexdep</name>-&gt;<name>isTopLevel</name></name><argument_list>()</argument_list></call>
                                ? !<call><name>MinBlockId</name><argument_list>(<argument><expr><name><name>afunbox</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>lexdep</name>-&gt;<name>pn_blockid</name></name></expr></argument>)</argument_list></call>
                                : !<call><name><name>lexdep</name>-&gt;<name>isBlockChild</name></name><argument_list>()</argument_list></call> ||
                                  !<call><name><name>afunbox</name>-&gt;<name>node</name>-&gt;<name>isBlockChild</name></name><argument_list>()</argument_list></call> ||
                                  !<call><name>OneBlockId</name><argument_list>(<argument><expr><name><name>afunbox</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>lexdep</name>-&gt;<name>pn_blockid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                <break>break;</break>
                            }</block></then></if>
                        }</block></then></if>
                    }</block></then></if>
                }</block></while>

              <label><name>break2</name>:</label>
                <if>if <condition>(<expr><name>nupvars</name> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>onlyfreevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FUN_SET_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>JSFUN_NULL_CLOSURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * We made it all the way through the upvar loop, so it's
                     * safe to optimize to a flat closure.
                     */</comment>
                    <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>flat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FUN_SET_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>JSFUN_FLAT_CLOSURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <switch>switch <condition>(<expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                      <case>case <expr><name>JSOP_DEFFUN</name></expr>:
                        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DEFFUN_FC</name></expr>;</expr_stmt>
                        <break>break;</break>
                      </case><case>case <expr><name>JSOP_DEFLOCALFUN</name></expr>:
                        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DEFLOCALFUN_FC</name></expr>;</expr_stmt>
                        <break>break;</break>
                      </case><case>case <expr><name>JSOP_LAMBDA</name></expr>:
                        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_LAMBDA_FC</name></expr>;</expr_stmt>
                        <break>break;</break>
                      </case><default>default:
                        <comment type="block">/* js_EmitTree's case TOK_FUNCTION: will select op. */</comment>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call> == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </default>}</block></switch>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>FUN_METER</name><argument_list>(<argument><expr><name>badfunarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if></else></if>
            }</block></else></if>
        }</block></else></if></else></if>

        <if>if <condition>(<expr><call><name>FUN_KIND</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call> == <name>JSFUN_INTERPRETED</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_UPVARS</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>parent</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>parent</name>-&gt;<name>tcflags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>
            }</block></then> <else>else <block>{
                <function_decl><type><name>JSAtomList</name></type> <name>upvars</name><parameter_list>(<param><decl><type><name><name>pn</name>-&gt;<name>pn_names</name></name></type></decl></param>)</parameter_list>;</function_decl>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>upvars</name>.<name>count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>JSAtomListIterator</name></type> <name>iter</name><argument_list>(<argument><expr>&amp;<name>upvars</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * One or more upvars cannot be safely snapshot into a flat
                 * closure's dslot (see JSOP_GETDSLOT), so we loop again over
                 * all upvars, and for each non-free upvar, ensure that its
                 * containing function has been flagged as heavyweight.
                 *
                 * The emitter must see TCF_FUN_HEAVYWEIGHT accurately before
                 * generating any code for a tree of nested functions.
                 */</comment>
                <while>while <condition>(<expr>(<name>ale</name> = <call><name>iter</name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                    <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>lexdep</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>resolve</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr>!<call><name><name>lexdep</name>-&gt;<name>isFreeVar</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>afunbox</name> <init>= <expr><name><name>funbox</name>-&gt;<name>parent</name></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>uintN</name></type> <name>lexdepLevel</name> <init>= <expr><call><name><name>lexdep</name>-&gt;<name>frameLevel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                        <while>while <condition>(<expr><name>afunbox</name></expr>)</condition> <block>{
                            <comment type="block">/*
                             * NB: afunbox-&gt;level is the static level of
                             * the definition or expression of the function
                             * parsed into afunbox, not the static level of
                             * its body. Therefore we must add 1 to match
                             * lexdep's level to find the afunbox whose
                             * body contains the lexdep definition.
                             */</comment>
                            <if>if <condition>(<expr><name><name>afunbox</name>-&gt;<name>level</name></name> + 1U == <name>lexdepLevel</name> ||
                                (<name>lexdepLevel</name> == 0 &amp;&amp; <call><name><name>lexdep</name>-&gt;<name>isLet</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
                                <expr_stmt><expr><name><name>afunbox</name>-&gt;<name>tcflags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
                                <break>break;</break>
                            }</block></then></if>
                            <expr_stmt><expr><name>afunbox</name> = <name><name>afunbox</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
                        }</block></while>
                        <if>if <condition>(<expr>!<name>afunbox</name> &amp;&amp; (<name>tcflags</name> &amp; <name>TCF_IN_FUNCTION</name>)</expr>)</condition><then>
                            <expr_stmt><expr><name>tcflags</name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>
                    }</block></then></if>
                }</block></while>
            }</block></else></if>
        }</block></then></if>

        <expr_stmt><expr><name>funbox</name> = <name><name>funbox</name>-&gt;<name>siblings</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>funbox</name></expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>funbox</name>-&gt;<name>parent</name></name> == <name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FUN_METER</name></cpp:undef>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_argument_str</name><index>[]</index></name> <init>= <expr>"argument"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_variable_str</name><index>[]</index></name> <init>= <expr>"variable"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_unknown_str</name><index>[]</index></name>  <init>= <expr>"unknown"</expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name><name>JSDefinition</name>::<name>kindString</name></name><parameter_list>(<param><decl><type><name>Kind</name></type> <name>kind</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>table</name><index>[]</index></name> <init>= <expr><block>{
        <expr><name>js_var_str</name></expr>, <expr><name>js_const_str</name></expr>, <expr><name>js_let_str</name></expr>,
        <expr><name>js_function_str</name></expr>, <expr><name>js_argument_str</name></expr>, <expr><name>js_unknown_str</name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call> &lt;= <call><name>unsigned</name><argument_list>(<argument><expr><name>ARG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>table</name><index>[<expr><name>kind</name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSFunctionBox</name> *</type>
<name>EnterFunction</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>funtc</name></decl></param>,
              <param><decl><type><name>JSAtom</name> *</type><name>funAtom</name> <init>= <expr><name>NULL</name></expr></init></decl></param>, <name>uintN</name> <name>lambda</name> = <name>JSFUN_LAMBDA</name>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newFunction</name></name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>lambda</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>fun</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Create box for fun-&gt;object early to protect against last-ditch GC. */</comment>
    <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newFunctionBox</name></name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>funbox</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Initialize non-default members of funtc. */</comment>
    <expr_stmt><expr><name><name>funtc</name>-&gt;<name>flags</name></name> |= <name><name>funbox</name>-&gt;<name>tcflags</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funtc</name>-&gt;<name>blockidGen</name></name> = <name><name>tc</name>-&gt;<name>blockidGen</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>GenerateBlockId</name><argument_list>(<argument><expr><name>funtc</name></expr></argument>, <argument><expr><name><name>funtc</name>-&gt;<name>bodyid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>funtc</name>-&gt;<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funtc</name>-&gt;<name>funbox</name></name> = <name>funbox</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>funtc</name>-&gt;<name>parent</name></name> = <name>tc</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>SetStaticLevel</name><argument_list>(<argument><expr><name>funtc</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><name>funbox</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>LeaveFunction</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>funtc</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
              <param><decl><type><name>JSAtom</name> *</type><name>funAtom</name> <init>= <expr><name>NULL</name></expr></init></decl></param>, <name>uintN</name> <name>lambda</name> = <name>JSFUN_LAMBDA</name>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockidGen</name></name> = <name><name>funtc</name>-&gt;<name>blockidGen</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name> |= <name><name>funtc</name>-&gt;<name>flags</name></name> &amp; (<name>TCF_FUN_FLAGS</name> | <name>TCF_COMPILE_N_GO</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_INITIALIZED</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>tc</name>-&gt;<name>atTopLevel</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>lambda</name> == 0 &amp;&amp; <name>funAtom</name></expr></argument>,
                 <argument><expr><name><name>fn</name>-&gt;<name>pn_dflags</name></name> &amp; <name>PND_TOPLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>tc</name>-&gt;<name>topStmt</name></name> || <name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BLOCKCHILD</name></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * Propagate unresolved lexical names up to tc-&gt;lexdeps, and save a copy
     * of funtc-&gt;lexdeps in a TOK_UPVARS node wrapping the function's formal
     * params and body. We do this only if there are lexical dependencies not
     * satisfied by the function's declarations, to avoid penalizing functions
     * that use only their arguments and other local bindings.
     */</comment>
    <if>if <condition>(<expr><name><name>funtc</name>-&gt;<name>lexdeps</name>.<name>count</name></name> != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSAtomListIterator</name></type> <name>iter</name><argument_list>(<argument><expr>&amp;<name><name>funtc</name>-&gt;<name>lexdeps</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>foundCallee</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr>(<name>ale</name> = <call><name>iter</name><argument_list>()</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><call><name>ALE_ATOM</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>dn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>atom</name> == <name>funAtom</name> &amp;&amp; <name>lambda</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_CALLEE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>funtc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>CALLEE_UPVAR_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * If this named function expression uses its own name other
                 * than to call itself, flag this function as using arguments,
                 * as if it had used arguments.callee instead of its own name.
                 *
                 * This abuses the plain sense of TCF_FUN_USES_ARGUMENTS, but
                 * we are out of tcflags bits at the moment. If it deoptimizes
                 * code unfairly (see JSCompiler::setFunctionKinds, where this
                 * flag is interpreted in its broader sense, not only to mean
                 * "this function might leak arguments.callee"), we can perhaps
                 * try to work harder to add a TCF_FUN_LEAKS_ITSELF flag and
                 * use that more precisely, both here and for unnamed function
                 * expressions.
                 */</comment>
                <if>if <condition>(<expr><call><name><name>dn</name>-&gt;<name>isFunArg</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name> |= <name>TCF_FUN_USES_ARGUMENTS</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>foundCallee</name> = 1</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <if>if <condition>(<expr>!(<name><name>fn</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_SETS_OUTER_NAME</name>) &amp;&amp;
                <call><name><name>dn</name>-&gt;<name>isAssigned</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Make sure we do not fail to set TCF_FUN_SETS_OUTER_NAME if
                 * any use of dn in funtc assigns. See NoteLValue for the easy
                 * backward-reference case; this is the hard forward-reference
                 * case where we pay a higher price.
                 */</comment>
                <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pnu</name> <init>= <expr><name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</init> <condition><expr><name>pnu</name></expr>;</condition> <incr><expr><name>pnu</name> = <name><name>pnu</name>-&gt;<name>pn_link</name></name></expr></incr>) <block>{
                    <if>if <condition>(<expr><call><name><name>pnu</name>-&gt;<name>isAssigned</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>pnu</name>-&gt;<name>pn_blockid</name></name> &gt;= <name><name>funtc</name>-&gt;<name>bodyid</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name> |= <name>TCF_FUN_SETS_OUTER_NAME</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>

            <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>outer_ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>outer_ale</name></expr>)</condition><then>
                <expr_stmt><expr><name>outer_ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>outer_ale</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Insert dn's uses list at the front of outer_dn's list.
                 *
                 * Without loss of generality or correctness, we allow a dn to
                 * be in inner and outer lexdeps, since the purpose of lexdeps
                 * is one-pass coordination of name use and definition across
                 * functions, and if different dn's are used we'll merge lists
                 * when leaving the inner function.
                 *
                 * The dn == outer_dn case arises with generator expressions
                 * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
                 * case), and nowhere else, currently.
                 */</comment>
                <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>outer_dn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>outer_ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>dn</name> != <name>outer_dn</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnup</name> <init>= <expr>&amp;<name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnu</name></decl>;</decl_stmt>

                    <while>while <condition>(<expr>(<name>pnu</name> = *<name>pnup</name>) != <name>NULL</name></expr>)</condition> <block>{
                        <expr_stmt><expr><name><name>pnu</name>-&gt;<name>pn_lexdef</name></name> = <name>outer_dn</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pnup</name> = &amp;<name><name>pnu</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt>
                    }</block></while>

                    <comment type="block">/*
                     * Make dn be a use that redirects to outer_dn, because we
                     * can't replace dn with outer_dn in all the pn_namesets in
                     * the AST where it may be. Instead we make it forward to
                     * outer_dn. See JSDefinition::resolve.
                     */</comment>
                    <expr_stmt><expr>*<name>pnup</name> = <name><name>outer_dn</name>-&gt;<name>dn_uses</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>outer_dn</name>-&gt;<name>dn_uses</name></name> = <name>dn</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>outer_dn</name>-&gt;<name>pn_dflags</name></name> |= <name><name>dn</name>-&gt;<name>pn_dflags</name></name> &amp; ~<name>PND_PLACEHOLDER</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_defn</name></name> = false</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_used</name></name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_lexdef</name></name> = <name>outer_dn</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <comment type="block">/* Add an outer lexical dependency for ale's definition. */</comment>
                <expr_stmt><expr><name>outer_ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>outer_ale</name></expr>)</condition><then>
                    <return>return <expr>false</expr>;</return></then></if>
                <expr_stmt><expr><call><name>ALE_SET_DEFN</name><argument_list>(<argument><expr><name>outer_ale</name></expr></argument>, <argument><expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>

        <if>if <condition>(<expr><name><name>funtc</name>-&gt;<name>lexdeps</name>.<name>count</name></name> - <name>foundCallee</name> != 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>body</name> <init>= <expr><name><name>fn</name>-&gt;<name>pn_body</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name></name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NAMESET</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>fn</name>-&gt;<name>pn_body</name></name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>

            <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name>-&gt;<name>pn_type</name></name> = <name>TOK_UPVARS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name>-&gt;<name>pn_pos</name></name> = <name><name>body</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>foundCallee</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>funtc</name>-&gt;<name>lexdeps</name>.<name>remove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name>-&gt;<name>pn_names</name></name> = <name><name>funtc</name>-&gt;<name>lexdeps</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name>-&gt;<name>pn_tree</name></name> = <name>body</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>funtc</name>-&gt;<name>lexdeps</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>FunctionDef</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
            <param><decl><type><name>uintN</name></type> <name>lambda</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>body</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>funAtom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>destructuringArg</name> <init>= <expr>false</expr></init>, <name>duplicatedArg</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Make a TOK_FUNCTION node. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
    <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_FUNC</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_body</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If a lambda, give up on JSOP_{GET,CALL}UPVAR usage unless this function
     * is immediately applied (we clear PND_FUNARG if so -- see MemberExpr).
     *
     * Also treat function sub-statements (non-lambda, non-top-level functions)
     * as escaping funargs, since we can't statically analyze their definitions
     * and uses.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>topLevel</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>atTopLevel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> = (<name>lambda</name> || !<name>topLevel</name>) ? <name>PND_FUNARG</name> : 0</expr>;</expr_stmt>

    <comment type="block">/* Scan the optional function name into funAtom. */</comment>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>funAtom</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name>lambda</name> == 0 &amp;&amp; (<name><name>cx</name>-&gt;<name>options</name></name> &amp; <name>JSOPTION_ANONFUNFIX</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>funAtom</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * Record names for function statements in tc-&gt;decls so we know when to
     * avoid optimizing variable references that might name a function.
     */</comment>
    <if>if <condition>(<expr><name>lambda</name> == 0 &amp;&amp; <name>funAtom</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>funAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>JSDefinition</name>::<name>Kind</name></name></type> <name>dn_kind</name> <init>= <expr><call><name><name>dn</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>dn</name>-&gt;<name>pn_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> || <name>dn_kind</name> == <name><name>JSDefinition</name>::<name>CONST</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>name</name> ||
                    !<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                 <argument><expr>(<name>dn_kind</name> != <name><name>JSDefinition</name>::<name>CONST</name></name>)
                                                 ? <name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name>
                                                 : <name>JSREPORT_ERROR</name></expr></argument>,
                                                 <argument><expr><name>JSMSG_REDECLARED_VAR</name></expr></argument>,
                                                 <argument><expr><call><name><name>JSDefinition</name>::<name>kindString</name></name><argument_list>(<argument><expr><name>dn_kind</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>

            <if>if <condition>(<expr><name>topLevel</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ALE_SET_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_defn</name></name> = true</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>dn_uses</name></name> = <name>dn</name></expr>;</expr_stmt>               <comment type="block">/* dn-&gt;dn_uses is now pn_link */</comment>

                <if>if <condition>(<expr>!<call><name>MakeDefIntoUse</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>topLevel</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If this function was used before it was defined, claim the
             * pre-created definition node for this function that PrimaryExpr
             * put in tc-&gt;lexdeps on first forward reference, and recycle pn.
             */</comment>
            <decl_stmt><decl><type><name>JSHashEntry</name> **</type><name>hep</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>rawLookup</name></name><argument_list>(<argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>fn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_type</name></name> = <name>TOK_FUNCTION</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_arity</name></name> = <name>PN_FUNC</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_body</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>rawRemove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>ale</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <name>fn</name></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name>Define</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if></else></if>

        <comment type="block">/*
         * A function nested at top level inside another's body needs only a
         * local variable to bind its name to its value, and not an activation
         * object property (it might also need the activation property, if the
         * outer function contains with statements, e.g., but the stack slot
         * wins when jsemit.c's BindNameToSlot can optimize a JSOP_NAME into a
         * JSOP_GETLOCAL bytecode).
         */</comment>
        <if>if <condition>(<expr><name>topLevel</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_TOPLEVEL</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSLocalKind</name></type> <name>localKind</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Define a local in the outer function so that BindNameToSlot
                 * can properly optimize accesses. Note that we need a local
                 * variable, not an argument, for the function statement. Thus
                 * we add a variable even if a parameter with the given name
                 * already exists.
                 */</comment>
                <expr_stmt><expr><name>localKind</name> = <call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>localKind</name></expr>)</condition> <block>{
                  <case>case <expr><name>JSLOCAL_NONE</name></expr>:
                  </case><case>case <expr><name>JSLOCAL_ARG</name></expr>:
                    <expr_stmt><expr><name>index</name> = <name><name>tc</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nvars</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>js_AddLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>JSLOCAL_VAR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <comment type="block">/* FALL THROUGH */</comment>

                  </case><case>case <expr><name>JSLOCAL_VAR</name></expr>:
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><default>default:<empty_stmt>;</empty_stmt>
                </default>}</block></switch>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Initialize early for possible flags mutation via DestructuringExpr. */</comment>
    <function_decl><type><name>JSTreeContext</name></type> <name>funtc</name><parameter_list>(<param><decl><type><name><name>tc</name>-&gt;<name>compiler</name></name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><call><name>EnterFunction</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>lambda</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>funbox</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr>(<name>JSFunction</name> *) <name><name>funbox</name>-&gt;<name>object</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
    <if>if <condition>(<expr><name>op</name> != <name>JSOP_NOP</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>fun</name>-&gt;<name>flags</name></name> |= (<name>op</name> == <name>JSOP_GETTER</name>) ? <name>JSPROP_GETTER</name> : <name>JSPROP_SETTER</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Now parse formal argument list and compute fun-&gt;nargs. */</comment>
    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_BEFORE_FORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_RP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <do>do <block>{
            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
              <case>case <expr><name>TOK_LB</name></expr>:
              </case><case>case <expr><name>TOK_LC</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>BindData</name></type> <name>data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lhs</name></decl>, *<decl><type ref="prev"/><name>rhs</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>

                <comment type="block">/* See comment below in the TOK_NAME case. */</comment>
                <if>if <condition>(<expr><name>duplicatedArg</name></expr>)</condition><then>
                    <goto>goto <name>report_dup_and_destructuring</name>;</goto></then></if>
                <expr_stmt><expr><name>destructuringArg</name> = true</expr>;</expr_stmt>

                <comment type="block">/*
                 * A destructuring formal parameter turns into one or more
                 * local variables initialized from properties of a single
                 * anonymous positional parameter, so here we must tweak our
                 * binder and its data.
                 */</comment>
                <expr_stmt><expr><name><name>data</name>.<name>pn</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name>.<name>op</name></name> = <name>JSOP_DEFVAR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name>.<name>binder</name></name> = <name>BindDestructuringArg</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lhs</name> = <call><name>DestructuringExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lhs</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>

                <comment type="block">/*
                 * Adjust fun-&gt;nargs to count the single anonymous positional
                 * parameter that is to be destructured.
                 */</comment>
                <expr_stmt><expr><name>slot</name> = <name><name>fun</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_AddLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSLOCAL_ARG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>

                <comment type="block">/*
                 * Synthesize a destructuring assignment from the single
                 * anonymous positional parameter into the destructuring
                 * left-hand-side expression and accumulate it in list.
                 */</comment>
                <expr_stmt><expr><name>rhs</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>emptyAtom</name></name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>rhs</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>rhs</name>-&gt;<name>pn_type</name></name> = <name>TOK_NAME</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rhs</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETARG</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rhs</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>funtc</name>.<name>staticLevel</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rhs</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>item</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_ASSIGN</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>item</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>list</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_type</name></name> = <name>TOK_COMMA</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>list</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>list</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DESTRUCTURING */</comment>

              </case><case>case <expr><name>TOK_NAME</name></expr>:
              <block>{
                <comment type="block">/*
                 * Check for a duplicate parameter name, a "feature" that
                 * ECMA-262 requires. This is a SpiderMonkey strict warning,
                 * soon to be an ES3.1 strict error.
                 *
                 * Further, if any argument is a destructuring pattern, forbid
                 * duplicates. We will report the error either now if we have
                 * seen a destructuring pattern already, or later when we find
                 * the first pattern.
                 */</comment>
                <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp;
                    <call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>JSLOCAL_NONE</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                    <if>if <condition>(<expr><name>destructuringArg</name></expr>)</condition><then>
                        <goto>goto <name>report_dup_and_destructuring</name>;</goto></then></if>
                    <expr_stmt><expr><name>duplicatedArg</name> = true</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name>name</name> ||
                        !<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>funtc</name>.<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><name>NULL</name></expr></argument>,
                                                     <argument><expr><name>JSREPORT_WARNING</name> |
                                                     <name>JSREPORT_STRICT</name></expr></argument>,
                                                     <argument><expr><name>JSMSG_DUPLICATE_FORMAL</name></expr></argument>,
                                                     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <return>return <expr><name>NULL</name></expr>;</return>
                    }</block></then></if>
                }</block></then></if>
                <if>if <condition>(<expr>!<call><name>DefineArg</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name><name>fun</name>-&gt;<name>nargs</name></name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>js_AddLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>JSLOCAL_ARG</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <break>break;</break>
              }</block>

              </case><default>default:
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_MISSING_FORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>
              </default><case>case <expr><name>TOK_ERROR</name></expr>:
                <return>return <expr><name>NULL</name></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
              <label><name>report_dup_and_destructuring</name>:</label>
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_DESTRUCT_DUP_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </case>}</block></switch>
        }</block> while <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_FORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_EXPR_CLOSURES</name></expr></cpp:if>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> != <name>TOK_LC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fun</name>-&gt;<name>flags</name></name> |= <name>JSFUN_EXPR_CLOSURE</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_BEFORE_BODY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>body</name> = <call><name>FunctionBody</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>body</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_EXPR_CLOSURES</name></expr></cpp:if>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_LC</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_AFTER_BODY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>lambda</name> == 0 &amp;&amp; !<call><name>MatchOrInsertSemicolon</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_AFTER_BODY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
    <comment type="block">/*
     * If there were destructuring formal parameters, prepend the initializing
     * comma expression that we synthesized to body.  If the body is a lexical
     * scope node, we must make a special TOK_SEQ node, to prepend the formal
     * parameter destructuring code without bracing the decompilation of the
     * function body's lexical scope.
     */</comment>
    <if>if <condition>(<expr><name>list</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>body</name>-&gt;<name>pn_arity</name></name> != <name>PN_LIST</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>block</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>block</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>block</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>block</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEQ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>block</name>-&gt;<name>pn_pos</name></name> = <name><name>body</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>block</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>body</name> = <name>block</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>item</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>item</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>item</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEMI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>item</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>body</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name>-&gt;<name>pn_kid</name></name> = <name>list</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name>-&gt;<name>pn_next</name></name> = <name><name>body</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>body</name>-&gt;<name>pn_head</name></name> = <name>item</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>body</name>-&gt;<name>pn_tail</name></name> == &amp;<name><name>body</name>-&gt;<name>pn_head</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>body</name>-&gt;<name>pn_tail</name></name> = &amp;<name><name>item</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr>++<name><name>body</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>body</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_DESTRUCT</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we collected flags that indicate nested heavyweight functions, or
     * this function contains heavyweight-making statements (with statement,
     * visible eval call, or assignment to 'arguments'), flag the function as
     * heavyweight (requiring a call object per invocation).
     */</comment>
    <if>if <condition>(<expr><name><name>funtc</name>.<name>flags</name></name> &amp; <name>TCF_FUN_HEAVYWEIGHT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>fun</name>-&gt;<name>flags</name></name> |= <name>JSFUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * If this function is a named statement function not at top-level
         * (i.e. not a top-level function definiton or expression), then our
         * enclosing function, if any, must be heavyweight.
         */</comment>
        <if>if <condition>(<expr>!<name>topLevel</name> &amp;&amp; <name>lambda</name> == 0 &amp;&amp; <name>funAtom</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>
    }</block></else></if>

    <expr_stmt><expr><name>result</name> = <name>pn</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>lambda</name> != 0</expr>)</condition><then> <block>{
        <comment type="block">/*
         * ECMA ed. 3 standard: function expression, possibly anonymous.
         */</comment>
        <expr_stmt><expr><name>op</name> = <name>JSOP_LAMBDA</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>!<name>funAtom</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If this anonymous function definition is *not* embedded within a
         * larger expression, we treat it as an expression statement, not as
         * a function declaration -- and not as a syntax error (as ECMA-262
         * Edition 3 would have it).  Backward compatibility must trump all,
         * unless JSOPTION_ANONFUNFIX is set.
         */</comment>
        <expr_stmt><expr><name>result</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>result</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEMI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>-&gt;<name>pn_pos</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>-&gt;<name>pn_kid</name></name> = <name>pn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>JSOP_LAMBDA</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>!<name>topLevel</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * ECMA ed. 3 extension: a function expression statement not at the
         * top level, e.g., in a compound statement such as the "then" part
         * of an "if" statement, binds a closure only if control reaches that
         * sub-statement.
         */</comment>
        <expr_stmt><expr><name>op</name> = <name>JSOP_DEFFUN</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <expr_stmt><expr><name><name>funbox</name>-&gt;<name>kids</name></name> = <name><name>funtc</name>.<name>functionList</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_funbox</name></name> = <name>funbox</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_body</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>pn_body</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_body</name>-&gt;<name>pn_pos</name></name> = <name><name>body</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_body</name></name> = <name>body</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>LeaveFunction</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>funtc</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>funAtom</name></expr></argument>, <argument><expr><name>lambda</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>FunctionStmt</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>FunctionDef</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>FunctionExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>FunctionDef</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSFUN_LAMBDA</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Parse the statements in a block, creating a TOK_LC node that lists the
 * statements' trees.  If called from block-parsing code, the caller must
 * match { before and } after.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>Statements</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>saveBlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_LC</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>saveBlock</name> = <name><name>tc</name>-&gt;<name>blockNode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockNode</name></name> = <name>pn</name></expr>;</expr_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> &lt;= <name>TOK_EOF</name> || <name>tt</name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp; <name>TSF_EOF</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_UNEXPECTED_EOF</name></expr>;</expr_stmt></then></if>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp; <name>TSF_EOF</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_UNEXPECTED_EOF</name></expr>;</expr_stmt></then></if>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_FUNCTION</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * PNX_FUNCDEFS notifies the emitter that the block contains top-
             * level function definitions that should be processed before the
             * rest of nodes.
             *
             * TCF_HAS_FUNCTION_STMT is for the TOK_LC case in Statement. It
             * is relevant only for function definitions not at top-level,
             * which we call function statements.
             */</comment>
            <if>if <condition>(<expr><call><name><name>tc</name>-&gt;<name>atTopLevel</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_FUNCDEFS</name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_HAS_FUNCTION_STMT</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/*
     * Handle the case where there was a let declaration under this block.  If
     * it replaced tc-&gt;blockNode with a new block node then we must refresh pn
     * and then restore tc-&gt;blockNode.
     */</comment>
    <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>blockNode</name></name> != <name>pn</name></expr>)</condition><then>
        <expr_stmt><expr><name>pn</name> = <name><name>tc</name>-&gt;<name>blockNode</name></name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockNode</name></name> = <name>saveBlock</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>Condition</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_BEFORE_COND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>ParenExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_COND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for (a = b) and warn about possible (a == b) mistype iff b's
     * operator has greater precedence than ==.
     */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name> &amp;&amp;
        <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name> &amp;&amp;
        <name><name>pn</name>-&gt;<name>pn_right</name>-&gt;<name>pn_type</name></name> &gt; <name>TOK_EQOP</name></expr>)</condition><then>
    <block>{
        <if>if <condition>(<expr>!<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                                         <argument><expr><name>JSMSG_EQUAL_AS_ASSIGN</name></expr></argument>,
                                         <argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>MatchLabel</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tt</name> = <call><name>js_PeekTokenSameLine</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>(<name>void</name>) <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>label</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>label</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <name>label</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindLet</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>blockObj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>n</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Top-level 'let' is the same as 'var' currently -- this may change in a
     * successor standard to ES3.1 that specifies 'let'.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>tc</name>-&gt;<name>atTopLevel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pn</name> = <name><name>data</name>-&gt;<name>pn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>blockObj</name> = <name><name>tc</name>-&gt;<name>blockChain</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ale</name> &amp;&amp; <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<name>pn_blockid</name> == <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>name</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                                        <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_REDECLARED_VAR</name></expr></argument>,
                                        <argument><expr>(<name>ale</name> &amp;&amp; <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>isConst</name><argument_list>()</argument_list></call>)
                                        ? <name>js_const_str</name>
                                        : <name>js_variable_str</name></expr></argument>,
                                        <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>n</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>blockObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>n</name> == <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                                    <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name><name>data</name>-&gt;<name>let</name>.<name>overflow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Pass push = true to Define so it pushes an ale ahead of any outer scope.
     * This is balanced by PopStatement, defined immediately below.
     */</comment>
    <if>if <condition>(<expr>!<call><name>Define</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/*
     * Assign block-local index to pn-&gt;pn_cookie right away, encoding it as an
     * upvar cookie whose skip tells the current static level. The emitter will
     * adjust the node's slot based on its stack depth model -- and, for global
     * and eval code, JSCompiler::compileScript will adjust the slot again to
     * include script-&gt;nfixed.
     */</comment>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETLOCAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_LET</name> | <name>PND_BOUND</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Use JSPROP_ENUMERATE to aid the disassembler. Define the let binding's
     * property before storing pn in a reserved slot, since block_reserveSlots
     * depends on OBJ_SCOPE(blockObj)-&gt;entryCount.
     */</comment>
    <if>if <condition>(<expr>!<call><name>js_DefineNativeProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>blockObj</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSVAL_VOID</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSPROP_ENUMERATE</name> |
                                 <name>JSPROP_PERMANENT</name> |
                                 <name>JSPROP_SHARED</name></expr></argument>,
                                 <argument><expr><name>SPROP_HAS_SHORTID</name></expr></argument>, <argument><expr>(<name>int16</name>) <name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Store pn temporarily in what would be reserved slots in a cloned block
     * object (once the prototype's final population is known, after all 'let'
     * bindings for this block have been parsed). We will free these reserved
     * slots in jsemit.cpp:EmitEnterBlock.
     */</comment>
    <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>JSSLOT_FREE</name><argument_list>(<argument><expr>&amp;<name>js_BlockClass</name></expr></argument>)</argument_list></call> + <name>n</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>slot</name> &gt;= <call><name>STOBJ_NSLOTS</name><argument_list>(<argument><expr><name>blockObj</name></expr></argument>)</argument_list></call> &amp;&amp;
        !<call><name>js_GrowSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>blockObj</name></expr></argument>, <argument><expr><name>slot</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>blockObj</name></expr></argument>)</argument_list></call>-&gt;<name>freeslot</name> = <name>slot</name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>STOBJ_SET_SLOT</name><argument_list>(<argument><expr><name>blockObj</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>PRIVATE_TO_JSVAL</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PopStatement</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name> <init>= <expr><name><name>tc</name>-&gt;<name>topStmt</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><name><name>stmt</name>-&gt;<name>blockObj</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSScope</name> *</type><name>scope</name> <init>= <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>scope</name>-&gt;<name>object</name></name> == <name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name> <init>= <expr><name><name>scope</name>-&gt;<name>lastProp</name></name></expr></init></decl>;</init> <condition><expr><name>sprop</name></expr>;</condition> <incr><expr><name>sprop</name> = <name><name>sprop</name>-&gt;<name>parent</name></name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><call><name>JSID_TO_ATOM</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Beware the empty destructuring dummy. */</comment>
            <if>if <condition>(<expr><name>atom</name> == <name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>emptyAtom</name></name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><call><name><name>tc</name>-&gt;<name>decls</name>.<name>remove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
    <expr_stmt><expr><call><name>js_PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>OuterLet</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name><name>stmt</name>-&gt;<name>downScope</name></name></expr>)</condition> <block>{
        <expr_stmt><expr><name>stmt</name> = <call><name>js_LexicalLookup</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>downScope</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>stmt</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
    }</block></while>
    <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindVarOrConst</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name> <init>= <expr><call><name>js_LexicalLookup</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>data</name>-&gt;<name>pn</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>stmt</name> &amp;&amp; <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_WITH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name>-&gt;<name>fresh</name></name> = false</expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr><name><name>data</name>-&gt;<name>op</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>stmt</name> || <name>ale</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><name>ale</name> ? <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>JSDefinition</name>::<name>Kind</name></name></type> <name>dn_kind</name> <init>= <expr><name>dn</name> ? <call><name><name>dn</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call> : <name><name>JSDefinition</name>::<name>VAR</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>dn_kind</name> == <name><name>JSDefinition</name>::<name>ARG</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>name</name> = <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <if>if <condition>(<expr><name>op</name> == <name>JSOP_DEFCONST</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                                            <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_REDECLARED_PARAM</name></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                                             <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                                             <argument><expr><name>JSMSG_VAR_HIDES_ARG</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>bool</name></type> <name>error</name> <init>= <expr>(<name>op</name> == <name>JSOP_DEFCONST</name> ||
                          <name>dn_kind</name> == <name><name>JSDefinition</name>::<name>CONST</name></name> ||
                          (<name>dn_kind</name> == <name><name>JSDefinition</name>::<name>LET</name></name> &amp;&amp;
                           (<name><name>stmt</name>-&gt;<name>type</name></name> != <name>STMT_CATCH</name> || <call><name>OuterLet</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call>)))</expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>
                ? <name>op</name> != <name>JSOP_DEFVAR</name> || <name>dn_kind</name> != <name><name>JSDefinition</name>::<name>VAR</name></name>
                : <name>error</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>name</name> = <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>name</name> ||
                    !<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                                                 <argument><expr>!<name>error</name>
                                                 ? <name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name>
                                                 : <name>JSREPORT_ERROR</name></expr></argument>,
                                                 <argument><expr><name>JSMSG_REDECLARED_VAR</name></expr></argument>,
                                                 <argument><expr><call><name><name>JSDefinition</name>::<name>kindString</name></name><argument_list>(<argument><expr><name>dn_kind</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>Define</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * A var declaration never recreates an existing binding, it restates
         * it and possibly reinitializes its value. Beware that if pn becomes a
         * use of ALE_DEFN(ale), and if we have an initializer for this var or
         * const (typically a const would ;-), then pn must be rewritten into a
         * TOK_ASSIGN node. See Variables, further below.
         *
         * A case such as let (x = 1) { var x = 2; print(x); } is even harder.
         * There the x definition is hoisted but the x = 2 assignment mutates
         * the block-local binding of x.
         */</comment>
        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>data</name>-&gt;<name>fresh</name></name> = false</expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Make pnu be a fresh name node that uses dn. */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnu</name> <init>= <expr><name>pn</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pnu</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pnu</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>

            <expr_stmt><expr><call><name>LinkUseToDef</name><argument_list>(<argument><expr><name>pnu</name></expr></argument>, <argument><expr><name>dn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnu</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
        }</block></then></if>

        <while>while <condition>(<expr><call><name><name>dn</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call> == <name><name>JSDefinition</name>::<name>LET</name></name></expr>)</condition> <block>{
            <do>do <block>{
                <expr_stmt><expr><name>ale</name> = <call><name>ALE_NEXT</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>ale</name> &amp;&amp; <call><name>ALE_ATOM</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call> != <name>atom</name></expr>)</condition>;</do>
            <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>dn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>data</name>-&gt;<name>op</name></name> == <name>JSOP_DEFCONST</name></expr></argument>,
                         <argument><expr><call><name><name>dn</name>-&gt;<name>kind</name></name><argument_list>()</argument_list></call> == <name><name>JSDefinition</name>::<name>CONST</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * A var or const that is shadowed by one or more let bindings of the
         * same name, but that has not been declared until this point, must be
         * hoisted above the let bindings.
         */</comment>
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSHashEntry</name> **</type><name>hep</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>rawLookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>rawRemove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>ale</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name> <init>= <expr><call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

                <comment type="block">/* The token stream may be past the location for pn. */</comment>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_NAME</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>decls</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name><name>JSAtomList</name>::<name>HOIST</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>ALE_SET_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_defn</name></name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp;= ~<name>PND_PLACEHOLDER</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name><name>data</name>-&gt;<name>op</name></name> == <name>JSOP_DEFCONST</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_CONST</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)</expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we are generating global or eval-called-from-global code, bind a
         * "gvar" here, as soon as possible. The JSOP_GETGVAR, etc., ops speed
         * up global variable access by memoizing name-to-slot mappings in the
         * script prolog (via JSOP_DEFVAR/JSOP_DEFCONST). If the memoization
         * can't be done due to a pre-existing property of the same name as the
         * var or const but incompatible attributes/getter/setter/etc, these
         * ops devolve to JSOP_NAME, etc.
         *
         * For now, don't try to lookup eval frame variables at compile time.
         * Seems sub-optimal: why couldn't we find eval-called-from-a-function
         * upvars early and possibly simplify jsemit.cpp:BindNameToSlot?
         */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_COMPILING</name>) &amp;&amp; !<name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>callerFrame</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name> <init>= <expr>(<name>JSCodeGenerator</name> *) <name>tc</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Index atom so we can map fast global number to name. */</comment>
            <expr_stmt><expr><name>ale</name> = <call><name><name>cg</name>-&gt;<name>atomList</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/* Defend against cg-&gt;ngvars 16-bit overflow. */</comment>
            <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>(<name>slot</name> + 1) &gt;&gt; 16</expr>)</condition><then>
                <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

            <if>if <condition>(<expr><call>(<name>uint16</name>)<argument_list>(<argument><expr><name>slot</name> + 1</expr></argument>)</argument_list></call> &gt; <name><name>cg</name>-&gt;<name>ngvars</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>ngvars</name></name> = <call>(<name>uint16</name>)<argument_list>(<argument><expr><name>slot</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETGVAR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name> | <name>PND_GVAR</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_ARGUMENTS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSLocalKind</name></type> <name>localKind</name> <init>= <expr><call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>localKind</name> == <name>JSLOCAL_NONE</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Property not found in current variable scope: we have not seen this
         * variable before. Define a new local variable by adding a property to
         * the function's scope and allocating one slot in the function's vars
         * frame. Any locals declared in a with statement body are handled at
         * runtime, by script prolog JSOP_DEFVAR opcodes generated for global
         * and heavyweight-function-local vars.
         */</comment>
        <expr_stmt><expr><name>localKind</name> = (<name><name>data</name>-&gt;<name>op</name></name> == <name>JSOP_DEFCONST</name>) ? <name>JSLOCAL_CONST</name> : <name>JSLOCAL_VAR</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>uintN</name></type> <name>index</name> <init>= <expr><name><name>tc</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nvars</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>BindLocalVariable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>localKind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETLOCAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>localKind</name> == <name>JSLOCAL_ARG</name></expr>)</condition><then> <block>{
        <comment type="block">/* We checked errors and strict warnings earlier -- see above. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ale</name> &amp;&amp; <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>-&gt;<call><name>kind</name><argument_list>()</argument_list></call> == <name><name>JSDefinition</name>::<name>ARG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* Not an argument, must be a redeclared local var. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>localKind</name> == <name>JSLOCAL_VAR</name> || <name>localKind</name> == <name>JSLOCAL_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>MakeSetCall</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>msg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_CALL</name> || <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_EVAL</name> || <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_APPLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_FUNCTION</name> &amp;&amp; (<name><name>pn2</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_GENEXP_LAMBDA</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETCALL</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>NoteLValue</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>dflag</name> <init>= <expr><name>PND_ASSIGNED</name></expr></init></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_lexdef</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Save the win of PND_INITIALIZED if we can prove 'var x;' and 'x = y'
         * occur as direct kids of the same block with no forward refs to x.
         */</comment>
        <if>if <condition>(<expr>!(<name><name>dn</name>-&gt;<name>pn_dflags</name></name> &amp; (<name>PND_INITIALIZED</name> | <name>PND_CONST</name> | <name>PND_PLACEHOLDER</name>)) &amp;&amp;
            <call><name><name>dn</name>-&gt;<name>isBlockChild</name></name><argument_list>()</argument_list></call> &amp;&amp;
            <call><name><name>pn</name>-&gt;<name>isBlockChild</name></name><argument_list>()</argument_list></call> &amp;&amp;
            <name><name>dn</name>-&gt;<name>pn_blockid</name></name> == <name><name>pn</name>-&gt;<name>pn_blockid</name></name> &amp;&amp;
            <name><name>dn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> &lt;= <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> &amp;&amp;
            <name><name>dn</name>-&gt;<name>dn_uses</name></name> == <name>pn</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dflag</name> = <name>PND_INITIALIZED</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> |= <name>dflag</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>dn</name>-&gt;<name>frameLevel</name></name><argument_list>()</argument_list></call> != <name><name>tc</name>-&gt;<name>staticLevel</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * The above condition takes advantage of the all-ones nature of
             * FREE_UPVAR_COOKIE, and the reserved level FREE_STATIC_LEVEL.
             * We make a stronger assertion by excluding FREE_UPVAR_COOKIE.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_cookie</name></name> != <name>FREE_UPVAR_COOKIE</name></expr></argument>,
                         <argument><expr><call><name><name>dn</name>-&gt;<name>frameLevel</name></name><argument_list>()</argument_list></call> &lt; <name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_SETS_OUTER_NAME</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>dflag</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindDestructuringVar</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
                     <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Destructuring is a form of assignment, so just as for an initialized
     * simple variable, we must check for assignment to 'arguments' and flag
     * the enclosing function (if any) as heavyweight.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>atom</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>data</name>-&gt;<name>pn</name></name> = <name>pn</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>data</name>-&gt;<name>binder</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/*
     * Select the appropriate name-setting opcode, respecting eager selection
     * done by the data-&gt;binder function.
     */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp; <name>PND_BOUND</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = (<name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ARGUMENTS</name>)
                    ? <name>JSOP_SETNAME</name>
                    : (<name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp; <name>PND_GVAR</name>)
                    ? <name>JSOP_SETGVAR</name>
                    : <name>JSOP_SETLOCAL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = (<name><name>data</name>-&gt;<name>op</name></name> == <name>JSOP_DEFCONST</name>)
                    ? <name>JSOP_SETCONST</name>
                    : <name>JSOP_SETNAME</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name><name>data</name>-&gt;<name>op</name></name> == <name>JSOP_DEFCONST</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_CONST</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>NoteLValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>PND_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
 * LHS expression except a destructuring initialiser, and R is on the stack.
 * Because R is already evaluated, the usual LHS-specialized bytecodes won't
 * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
 * then push its property name QN.  At this point the stack looks like
 *
 *   [... R, R[P], QB, QN]
 *
 * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
 * its operands with left-hand side above right-hand side:
 *
 *   [rval, lval, xval]
 *
 * and pops all three values, setting lval[xval] = rval.  But we cannot select
 * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
 * which can be optimized further.  So we select JSOP_SETNAME.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindDestructuringLHS</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
        <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_NAME</name></expr>:
        <expr_stmt><expr><call><name>NoteLValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALL THROUGH */</comment>

      </case><case>case <expr><name>TOK_DOT</name></expr>:
      </case><case>case <expr><name>TOK_LB</name></expr>:
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETNAME</name></expr>;</expr_stmt>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_LP</name></expr>:
        <if>if <condition>(<expr>!<call><name>MakeSetCall</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSMSG_BAD_LEFTSIDE_OF_ASS</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLNAME</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_BINDXMLNAME</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><default>default:
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                                    <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_BAD_LEFTSIDE_OF_ASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    </default>}</block></switch>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>FindPropValData</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>uint32</name></type>          <name>numvars</name></decl>;</decl_stmt>    <comment type="block">/* # of destructuring vars in left side */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>maxstep</name></decl>;</decl_stmt>    <comment type="block">/* max # of steps searching right side */</comment>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>    <name>table</name></decl>;</decl_stmt>      <comment type="block">/* hash table for O(1) right side search */</comment>
</public>}</block></struct></type> <name>FindPropValData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>FindPropValEntry</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type> <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name>     *</type><name>pnkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name>     *</type><name>pnval</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>FindPropValEntry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_PROPERTY_KEY</name><parameter_list>(<param><type><name>pnkey</name></type></param>)</parameter_list></cpp:macro>                                      \
    <cpp:value>JS_ASSERT(((pnkey)-&gt;pn_arity == PN_NULLARY &amp;&amp;                             \
               ((pnkey)-&gt;pn_type == TOK_NUMBER ||                             \
                (pnkey)-&gt;pn_type == TOK_STRING ||                             \
                (pnkey)-&gt;pn_type == TOK_NAME)) ||                             \
               ((pnkey)-&gt;pn_arity == PN_NAME &amp;&amp; (pnkey)-&gt;pn_type == TOK_NAME))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSDHashNumber</name></type>
<name>HashFindPropValKey</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSParseNode</name> *</type><name>pnkey</name> <init>= <expr>(const <name>JSParseNode</name> *)<name>key</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_VALID_PROPERTY_KEY</name><argument_list>(<argument><expr><name>pnkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name><name>pnkey</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name>)
           ? <call>(<name>JSDHashNumber</name>) <argument_list>(<argument><expr><call><name>JSDOUBLE_HI32</name><argument_list>(<argument><expr><name><name>pnkey</name>-&gt;<name>pn_dval</name></name></expr></argument>)</argument_list></call> ^
                              <call><name>JSDOUBLE_LO32</name><argument_list>(<argument><expr><name><name>pnkey</name>-&gt;<name>pn_dval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
           : <call><name>ATOM_HASH</name><argument_list>(<argument><expr><name><name>pnkey</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>MatchFindPropValEntry</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>JSDHashEntryHdr</name> *</type><name>entry</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>FindPropValEntry</name> *</type><name>fpve</name> <init>= <expr>(const <name>FindPropValEntry</name> *)<name>entry</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSParseNode</name> *</type><name>pnkey</name> <init>= <expr>(const <name>JSParseNode</name> *)<name>key</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ASSERT_VALID_PROPERTY_KEY</name><argument_list>(<argument><expr><name>pnkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>pnkey</name>-&gt;<name>pn_type</name></name> == <name><name>fpve</name>-&gt;<name>pnkey</name>-&gt;<name>pn_type</name></name> &amp;&amp;
           ((<name><name>pnkey</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name>)
            ? <name><name>pnkey</name>-&gt;<name>pn_dval</name></name> == <name><name>fpve</name>-&gt;<name>pnkey</name>-&gt;<name>pn_dval</name></name>
            : <name><name>pnkey</name>-&gt;<name>pn_atom</name></name> == <name><name>fpve</name>-&gt;<name>pnkey</name>-&gt;<name>pn_atom</name></name>)</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>JSDHashTableOps</name></type> <name>FindPropValOps</name> <init>= <expr><block>{
    <expr><name>JS_DHashAllocTable</name></expr>,
    <expr><name>JS_DHashFreeTable</name></expr>,
    <expr><name>HashFindPropValKey</name></expr>,
    <expr><name>MatchFindPropValEntry</name></expr>,
    <expr><name>JS_DHashMoveEntryStub</name></expr>,
    <expr><name>JS_DHashClearEntryStub</name></expr>,
    <expr><name>JS_DHashFinalizeStub</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP_HASH_THRESHOLD</name></cpp:macro>     <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG_DESTRUCTURING</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG_OBJECT_INIT</name></cpp:macro>         <cpp:value>20</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>FindPropertyValue</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pnid</name></decl></param>, <param><decl><type><name>FindPropValData</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>FindPropValEntry</name> *</type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnhit</name></decl>, *<decl><type ref="prev"/><name>pnhead</name></decl>, *<decl><type ref="prev"/><name>pnprop</name></decl>, *<decl><type ref="prev"/><name>pnkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>step</name></decl>;</decl_stmt>

    <comment type="block">/* If we have a hash table, use it as the sole source of truth. */</comment>
    <if>if <condition>(<expr><name><name>data</name>-&gt;<name>table</name>.<name>ops</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>entry</name> = (<name>FindPropValEntry</name> *)
                <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>data</name>-&gt;<name>table</name></name></expr></argument>, <argument><expr><name>pnid</name></expr></argument>, <argument><expr><name>JS_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>JS_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>hdr</name></name></expr></argument>)</argument_list></call> ? <name><name>entry</name>-&gt;<name>pnval</name></name> : <name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If pn is not an object initialiser node, we can't do anything here. */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_RC</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/*
     * We must search all the way through pn's list, to handle the case of an
     * id duplicated for two or more property initialisers.
     */</comment>
    <expr_stmt><expr><name>pnhit</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_VALID_PROPERTY_KEY</name><argument_list>(<argument><expr><name>pnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pnhead</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pnid</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>pnprop</name> = <name>pnhead</name></expr>;</init> <condition><expr><name>pnprop</name></expr>;</condition> <incr><expr><name>pnprop</name> = <name><name>pnprop</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pnprop</name>-&gt;<name>pn_type</name></name> == <name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pnprop</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pnkey</name> = <name><name>pnprop</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT_VALID_PROPERTY_KEY</name><argument_list>(<argument><expr><name>pnkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>pnkey</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name> &amp;&amp;
                    <name><name>pnkey</name>-&gt;<name>pn_dval</name></name> == <name><name>pnid</name>-&gt;<name>pn_dval</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pnhit</name> = <name>pnprop</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr>++<name>step</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then> <else>else <block>{
        <for>for (<init><expr><name>pnprop</name> = <name>pnhead</name></expr>;</init> <condition><expr><name>pnprop</name></expr>;</condition> <incr><expr><name>pnprop</name> = <name><name>pnprop</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pnprop</name>-&gt;<name>pn_type</name></name> == <name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pnprop</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pnkey</name> = <name><name>pnprop</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT_VALID_PROPERTY_KEY</name><argument_list>(<argument><expr><name>pnkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>pnkey</name>-&gt;<name>pn_type</name></name> == <name><name>pnid</name>-&gt;<name>pn_type</name></name> &amp;&amp;
                    <name><name>pnkey</name>-&gt;<name>pn_atom</name></name> == <name><name>pnid</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pnhit</name> = <name>pnprop</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr>++<name>step</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></else></if>
    <if>if <condition>(<expr>!<name>pnhit</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Hit via full search -- see whether it's time to create the hash table. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>data</name>-&gt;<name>table</name>.<name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>step</name> &gt; <name><name>data</name>-&gt;<name>maxstep</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>data</name>-&gt;<name>maxstep</name></name> = <name>step</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>step</name> &gt;= <name>STEP_HASH_THRESHOLD</name> &amp;&amp;
            <name><name>data</name>-&gt;<name>numvars</name></name> &gt;= <name>BIG_DESTRUCTURING</name> &amp;&amp;
            <name><name>pn</name>-&gt;<name>pn_count</name></name> &gt;= <name>BIG_OBJECT_INIT</name> &amp;&amp;
            <call><name>JS_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name><name>data</name>-&gt;<name>table</name></name></expr></argument>, <argument><expr>&amp;<name>FindPropValOps</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>,
                              <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FindPropValEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                              <argument><expr><call><name>JS_DHASH_DEFAULT_CAPACITY</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <for>for (<init><expr><name>pn</name> = <name>pnhead</name></expr>;</init> <condition><expr><name>pn</name></expr>;</condition> <incr><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pnprop</name>-&gt;<name>pn_type</name></name> == <name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT_VALID_PROPERTY_KEY</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>entry</name> = (<name>FindPropValEntry</name> *)
                        <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>data</name>-&gt;<name>table</name></name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>,
                                             <argument><expr><name>JS_DHASH_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name>-&gt;<name>pnval</name></name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name><name>pnhit</name>-&gt;<name>pn_right</name></name></expr>;</return>
}</block></function>

<comment type="block">/*
 * If data is null, the caller is AssignExpr and instead of binding variables,
 * we specialize lvalues in the propery value positions of the left-hand side.
 * If right is null, just check for well-formed lvalues.
 *
 * See also UndominateInitializers, immediately below. If you change either of
 * these functions, you might have to change the other to match.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CheckDestructuring</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>,
                   <param><decl><type><name>JSParseNode</name> *</type><name>left</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>right</name></decl></param>,
                   <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FindPropValData</name></type> <name>fpvd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lhs</name></decl>, *<decl><type ref="prev"/><name>rhs</name></decl>, *<decl><type ref="prev"/><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_ARRAYCOMP</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>left</name></expr></argument>,
                                    <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_ARRAY_COMP_LEFTSIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
    <if>if <condition>(<expr><name>right</name> &amp;&amp; <name><name>right</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name> &amp;&amp; (<name><name>right</name>-&gt;<name>pn_xflags</name></name> &amp; <name>PNX_DESTRUCT</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>right</name></expr></argument>,
                                    <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_BAD_OBJECT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>fpvd</name>.<name>table</name>.<name>ops</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lhs</name> = <name><name>left</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rhs</name> = (<name>right</name> &amp;&amp; <name><name>right</name>-&gt;<name>pn_type</name></name> == <name><name>left</name>-&gt;<name>pn_type</name></name>)
              ? <name><name>right</name>-&gt;<name>pn_head</name></name>
              : <name>NULL</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>lhs</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>pn</name> = <name>lhs</name></expr>, <expr><name>pn2</name> = <name>rhs</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then> <block>{
                <comment type="block">/* Skip parenthesization if not in a variable declaration. */</comment>
                <while>while <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
                    <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
                <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
                    <while>while <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
                        <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
                }</block></then></if>
            }</block></then></if>

            <comment type="block">/* Nullary comma is an elision; binary comma is an expression.*/</comment>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_COMMA</name> || <name><name>pn</name>-&gt;<name>pn_arity</name></name> != <name>PN_NULLARY</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><name>data</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name></expr>)</condition><then>
                            <goto>goto <name>no_var_name</name>;</goto></then></if>

                        <expr_stmt><expr><name>ok</name> = <call><name>BindDestructuringVar</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>ok</name> = <call><name>BindDestructuringLHS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <goto>goto <name>out</name>;</goto></then></if>
            }</block></then></if>

            <expr_stmt><expr><name>lhs</name> = <name><name>lhs</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rhs</name></expr>)</condition><then>
                <expr_stmt><expr><name>rhs</name> = <name><name>rhs</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt></then></if>
        }</block></while>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fpvd</name>.<name>numvars</name></name> = <name><name>left</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fpvd</name>.<name>maxstep</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>rhs</name> = <name>NULL</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>lhs</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>lhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name><name>lhs</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then> <block>{
                <comment type="block">/* Skip parenthesization if not in a variable declaration. */</comment>
                <while>while <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
                    <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
            }</block></then></if>

            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>right</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rhs</name> = <call><name>FindPropertyValue</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name><name>lhs</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr>&amp;<name>fpvd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rhs</name> &amp;&amp; !<name>data</name></expr>)</condition><then> <block>{
                        <while>while <condition>(<expr><name><name>rhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
                            <expr_stmt><expr><name>rhs</name> = <name><name>rhs</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
                    }</block></then></if>
                }</block></then></if>

                <expr_stmt><expr><name>ok</name> = <call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>data</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name></expr>)</condition><then>
                    <goto>goto <name>no_var_name</name>;</goto></then></if>

                <expr_stmt><expr><name>ok</name> = <call><name>BindDestructuringVar</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>ok</name> = <call><name>BindDestructuringLHS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
            <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>

            <expr_stmt><expr><name>lhs</name> = <name><name>lhs</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        }</block></while>
    }</block></else></if>

    <comment type="block">/*
     * The catch/finally handler implementation in the interpreter assumes
     * that any operation that introduces a new scope (like a "let" or "with"
     * block) increases the stack depth. This way, it is possible to restore
     * the scope chain based on stack depth of the handler alone. "let" with
     * an empty destructuring pattern like in
     *
     *   let [] = 1;
     *
     * would violate this assumption as the there would be no let locals to
     * store on the stack. To satisfy it we add an empty property to such
     * blocks so that OBJ_BLOCK_COUNT(cx, blockObj), which gives the number of
     * slots, would be always positive.
     *
     * Note that we add such a property even if the block has locals due to
     * later let declarations in it. We optimize for code simplicity here,
     * not the fastest runtime performance with empty [] or {}.
     */</comment>
    <if>if <condition>(<expr><name>data</name> &amp;&amp;
        <name><name>data</name>-&gt;<name>binder</name></name> == <name>BindLet</name> &amp;&amp;
        <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>blockChain</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = !!<call><name>js_DefineNativeProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>blockChain</name></name></expr></argument>,
                                       <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;
                                                    <name>atomState</name>.<name>emptyAtom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>JSVAL_VOID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>JSPROP_ENUMERATE</name> |
                                       <name>JSPROP_PERMANENT</name> |
                                       <name>JSPROP_SHARED</name></expr></argument>,
                                       <argument><expr><name>SPROP_HAS_SHORTID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>

  <label><name>out</name>:</label>
    <if>if <condition>(<expr><name><name>fpvd</name>.<name>table</name>.<name>ops</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_DHashTableFinish</name><argument_list>(<argument><expr>&amp;<name><name>fpvd</name>.<name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>ok</name></expr>;</return>

  <label><name>no_var_name</name>:</label>
    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                <argument><expr><name>JSMSG_NO_VARIABLE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <goto>goto <name>out</name>;</goto>
}</block></function>

<comment type="block">/*
 * This is a greatly pared down version of CheckDestructuring that extends the
 * pn_pos.end source coordinate of each name in a destructuring binding such as
 * 
 *   var [x, y] = [function () y, 42];
 *
 * to cover its corresponding initializer, so that the initialized binding does
 * not appear to dominate any closures in its initializer. See bug 496134.
 *
 * The quick-and-dirty dominance computation in JSCompiler::setFunctionKinds is
 * not very precise. With one-pass SSA construction from structured source code
 * (see "Single-Pass Generation of Static Single Assignment Form for Structured
 * Languages", Brandis and Mssenbck), we could do much better.
 *
 * See CheckDestructuring, immediately above. If you change either of these
 * functions, you might have to change the other to match.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>UndominateInitializers</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>left</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>right</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>FindPropValData</name></type> <name>fpvd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lhs</name></decl>, *<decl><type ref="prev"/><name>rhs</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>left</name>-&gt;<name>pn_type</name></name> != <name>TOK_ARRAYCOMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>right</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name> &amp;&amp; (<name><name>right</name>-&gt;<name>pn_xflags</name></name> &amp; <name>PNX_DESTRUCT</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>right</name></expr></argument>,
                                    <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_BAD_OBJECT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>right</name>-&gt;<name>pn_type</name></name> != <name><name>left</name>-&gt;<name>pn_type</name></name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>fpvd</name>.<name>table</name>.<name>ops</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lhs</name> = <name><name>left</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rhs</name> = <name><name>right</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>lhs</name> &amp;&amp; <name>rhs</name></expr>)</condition> <block>{
            <comment type="block">/* Nullary comma is an elision; binary comma is an expression.*/</comment>
            <if>if <condition>(<expr><name><name>lhs</name>-&gt;<name>pn_type</name></name> != <name>TOK_COMMA</name> || <name><name>lhs</name>-&gt;<name>pn_arity</name></name> != <name>PN_NULLARY</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>lhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>lhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>UndominateInitializers</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>lhs</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>rhs</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>

            <expr_stmt><expr><name>lhs</name> = <name><name>lhs</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rhs</name> = <name><name>rhs</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        }</block></while>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fpvd</name>.<name>numvars</name></name> = <name><name>left</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fpvd</name>.<name>maxstep</name></name> = 0</expr>;</expr_stmt>

        <while>while <condition>(<expr><name>lhs</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>lhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name><name>lhs</name>-&gt;<name>pn_right</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>rhs</name> = <call><name>FindPropertyValue</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name><name>lhs</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr>&amp;<name>fpvd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>rhs</name> &amp;&amp; !<call><name>UndominateInitializers</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><name>rhs</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>rhs</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt></then></if>
            }</block></else></if>

            <expr_stmt><expr><name>lhs</name> = <name><name>lhs</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        }</block></while>
    }</block></else></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>DestructuringExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>BindData</name> *</type><name>data</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                  <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ts</name> = <call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_DESTRUCTURING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_DESTRUCTURING</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Currently used only #if JS_HAS_DESTRUCTURING, in Statement's TOK_FOR case.
 * This function assumes the cloned tree is for use in the same statement and
 * binding context as the original tree.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>CloneParseTree</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>opn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>opn2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewOrRecycledNode</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name><name>opn</name>-&gt;<name>pn_type</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name></name> = <name><name>opn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name><name>opn</name>-&gt;<name>pn_op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_used</name></name> = <name><name>opn</name>-&gt;<name>pn_used</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_defn</name></name> = <name><name>opn</name>-&gt;<name>pn_defn</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name><name>opn</name>-&gt;<name>pn_arity</name></name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NULLCHECK</name><parameter_list>(<param><type><name>e</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>JS_BEGIN_MACRO if (!(e)) return NULL; JS_END_MACRO</cpp:value></cpp:define>

      <case>case <expr><name>PN_FUNC</name></expr>:
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_funbox</name></name> =
                  <call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newFunctionBox</name></name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_funbox</name>-&gt;<name>object</name></name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_body</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_body</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <name><name>opn</name>-&gt;<name>pn_cookie</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> = <name><name>opn</name>-&gt;<name>pn_dflags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <name><name>opn</name>-&gt;<name>pn_blockid</name></name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_LIST</name></expr>:
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>opn2</name> = <name><name>opn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>opn2</name></expr>;</condition> <incr><expr><name>opn2</name> = <name><name>opn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name>pn2</name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name>opn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> = <name><name>opn</name>-&gt;<name>pn_xflags</name></name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_kid1</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_kid2</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_kid3</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>opn</name>-&gt;<name>pn_right</name></name> != <name><name>opn</name>-&gt;<name>pn_left</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_val</name></name> = <name><name>opn</name>-&gt;<name>pn_val</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> = <name><name>opn</name>-&gt;<name>pn_iflags</name></name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_kid</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_num</name></name> = <name><name>opn</name>-&gt;<name>pn_num</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_hidden</name></name> = <name><name>opn</name>-&gt;<name>pn_hidden</name></name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAME</name></expr>:
        <comment type="line">// PN_NAME could mean several arms in pn_u, so copy the whole thing.</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_u</name></name> = <name><name>opn</name>-&gt;<name>pn_u</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>opn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * The old name is a use of its pn_lexdef. Make the clone also be a
             * use of that definition.
             */</comment>
            <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_lexdef</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_link</name></name> = <name><name>dn</name>-&gt;<name>dn_uses</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dn</name>-&gt;<name>dn_uses</name></name> = <name>pn</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>opn</name>-&gt;<name>pn_expr</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_expr</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the old name is a definition, the new one has pn_defn set.
             * Make the old name a use of the new node.
             */</comment>
            <if>if <condition>(<expr><name><name>opn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>opn</name>-&gt;<name>pn_defn</name></name> = false</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LinkUseToDef</name><argument_list>(<argument><expr><name>opn</name></expr></argument>, <argument><expr>(<name>JSDefinition</name> *) <name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAMESET</name></expr>:
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_names</name></name> = <name><name>opn</name>-&gt;<name>pn_names</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NULLCHECK</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_tree</name></name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>opn</name>-&gt;<name>pn_tree</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_NULLARY</name></expr>:
        <comment type="line">// Even PN_NULLARY may have data (apair for E4X -- what a botch).</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_u</name></name> = <name><name>opn</name>-&gt;<name>pn_u</name></name></expr>;</expr_stmt>
        <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NULLCHECK</name></cpp:undef>
    </case>}</block></switch>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DESTRUCTURING */</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>js_with_statement_str</name><index>[]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>ContainsStmt</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pnt</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> == <name>tt</name></expr>)</condition><then>
        <return>return <expr><name>pn</name></expr>;</return></then></if>
    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_LIST</name></expr>:
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><name>pnt</name> = <call><name>ContainsStmt</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pnt</name></expr>)</condition><then>
                <return>return <expr><name>pnt</name></expr>;</return></then></if>
        }</block></for>
        <break>break;</break>
      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <expr_stmt><expr><name>pnt</name> = <call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pnt</name></expr>)</condition><then>
            <return>return <expr><name>pnt</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pnt</name> = <call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pnt</name></expr>)</condition><then>
            <return>return <expr><name>pnt</name></expr>;</return></then></if>
        <return>return <expr><call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</return>
      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <comment type="block">/*
         * Limit recursion if pn is a binary expression, which can't contain a
         * var statement.
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_NOP</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pnt</name> = <call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pnt</name></expr>)</condition><then>
            <return>return <expr><name>pnt</name></expr>;</return></then></if>
        <return>return <expr><call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</return>
      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_NOP</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <return>return <expr><call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</return>
      </case><case>case <expr><name>PN_NAME</name></expr>:
        <return>return <expr><call><name>ContainsStmt</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>maybeExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</return>
      </case><case>case <expr><name>PN_NAMESET</name></expr>:
        <return>return <expr><call><name>ContainsStmt</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_tree</name></name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</return>
      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>ReturnOrYield</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
              <param><decl><type><name>JSParser</name></type> <name>operandParser</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>, <decl><type ref="prev"/><name>tt2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tt</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_RETURN</name> &amp;&amp; !(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_RETURN_OR_YIELD</name></expr></argument>, <argument><expr><name>js_return_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_YIELD</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_IS_GENERATOR</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* This is ugly, but we don't want to require a semicolon. */</comment>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt2</name> = <call><name>js_PeekTokenSameLine</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt2</name> == <name>TOK_ERROR</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>tt2</name> != <name>TOK_EOF</name> &amp;&amp; <name>tt2</name> != <name>TOK_EOL</name> &amp;&amp; <name>tt2</name> != <name>TOK_SEMI</name> &amp;&amp; <name>tt2</name> != <name>TOK_RC</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
        &amp;&amp; (<name>tt</name> != <name>TOK_YIELD</name> ||
            (<name>tt2</name> != <name>tt</name> &amp;&amp; <name>tt2</name> != <name>TOK_RB</name> &amp;&amp; <name>tt2</name> != <name>TOK_RP</name> &amp;&amp;
             <name>tt2</name> != <name>TOK_COLON</name> &amp;&amp; <name>tt2</name> != <name>TOK_COMMA</name>))</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><then> <block>{
        <expr_stmt><expr><name>pn2</name> = <call><name>operandParser</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_RETURN</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_RETURN_EXPR</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_RETURN</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_RETURN_VOID</name></expr>;</expr_stmt></then></if>
    }</block></else></if>

    <if>if <condition>(<expr>(~<name><name>tc</name>-&gt;<name>flags</name></name> &amp; (<name>TCF_RETURN_EXPR</name> | <name>TCF_FUN_IS_GENERATOR</name>)) == 0</expr>)</condition><then> <block>{
        <comment type="block">/* As in Python (see PEP-255), disallow return v; in generators. */</comment>
        <expr_stmt><expr><call><name>ReportBadReturn</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                        <argument><expr><name>JSMSG_BAD_GENERATOR_RETURN</name></expr></argument>,
                        <argument><expr><name>JSMSG_BAD_ANON_GENERATOR_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp;
        (~<name><name>tc</name>-&gt;<name>flags</name></name> &amp; (<name>TCF_RETURN_EXPR</name> | <name>TCF_RETURN_VOID</name>)) == 0 &amp;&amp;
        !<call><name>ReportBadReturn</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                         <argument><expr><name>JSMSG_NO_RETURN_VALUE</name></expr></argument>,
                         <argument><expr><name>JSMSG_ANON_NO_RETURN_VALUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>PushLexicalScope</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                 <param><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObjectBox</name> *</type><name>blockbox</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NAME</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>obj</name> = <call><name>js_NewBlockObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>blockbox</name> = <call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newObjectBox</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>blockbox</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>js_PushBlockScope</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_LEXICALSCOPE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_LEAVEBLOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_objbox</name></name> = <name>blockbox</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>GenerateBlockId</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>blockid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <name><name>stmt</name>-&gt;<name>blockid</name></name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>LetBlock</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>statement</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pnblock</name></decl>, *<decl><type ref="prev"/><name>pnlet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name></type> <name>stmtInfo</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_LET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the let binary node. */</comment>
    <expr_stmt><expr><name>pnlet</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pnlet</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_BEFORE_LET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This is a let block or expression of the form: let (a, b, c) .... */</comment>
    <expr_stmt><expr><name>pnblock</name> = <call><name>PushLexicalScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pnblock</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>pn</name> = <name>pnblock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name> = <name>pnlet</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pnlet</name>-&gt;<name>pn_left</name></name> = <call><name>Variables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>pnlet</name>-&gt;<name>pn_left</name></name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pnlet</name>-&gt;<name>pn_left</name>-&gt;<name>pn_xflags</name></name> = <name>PNX_POPVAR</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_LET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>statement</name> &amp;&amp; !<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_LC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If this is really an expression in let statement guise, then we
         * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
         * the return value of the expression.
         */</comment>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEMI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_num</name></name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pnblock</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>statement</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>statement</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pnlet</name>-&gt;<name>pn_right</name></name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pnlet</name>-&gt;<name>pn_right</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_AFTER_LET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * Change pnblock's opcode to the variant that propagates the last
         * result down after popping the block, and clear statement.
         */</comment>
        <expr_stmt><expr><name><name>pnblock</name>-&gt;<name>pn_op</name></name> = <name>JSOP_LEAVEBLOCKEXPR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pnlet</name>-&gt;<name>pn_right</name></name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pnlet</name>-&gt;<name>pn_right</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></else></if>

    <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_BLOCK_SCOPE */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PushBlocklikeStatement</name><parameter_list>(<param><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl></param>, <param><decl><type><name>JSStmtType</name></type> <name>type</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>GenerateBlockId</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>blockid</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>NewBindingNode</name><parameter_list>(<param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>let</name> <init>= <expr>false</expr></init></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>pn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>pn</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * A let binding at top level becomes a var before we get here, so if
         * pn and tc have the same blockid then that id must not be the bodyid.
         * If pn is a forward placeholder definition from the same or a higher
         * block then we claim it.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>let</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_blockid</name></name> == <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> != <name><name>tc</name>-&gt;<name>bodyid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>pn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_blockid</name></name> &gt;= (<name>let</name> ? <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call> : <name><name>tc</name>-&gt;<name>bodyid</name></name>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>let</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>remove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>pn</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Make a new node for this declarator name (or destructuring pattern). */</comment>
    <expr_stmt><expr><name>pn</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RebindLets</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_LIST</name></expr>:
        <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pn2</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_head</name></name></expr></init></decl>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>)
            <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <break>break;</break>

      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_FUNC</name></expr>:
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_body</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAME</name></expr>:
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>maybeExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> &gt; <name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>blockid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_lexdef</name>-&gt;<name>pn_blockid</name></name> == <name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>blockid</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ForgetUse</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                    <while>while <condition>(<expr>(<name>ale</name> = <call><name>ALE_NEXT</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
                        <if>if <condition>(<expr><call><name>ALE_ATOM</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call> == <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>LinkUseToDef</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr>true</expr>;</return>
                        }</block></then></if>
                    }</block></while>
                }</block></then></if>

                <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>lookup</name></name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ale</name> = <call><name>MakePlaceholder</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>

                    <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_type</name></name> = <name>TOK_NAME</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> |= <name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp; (<name>PND_ASSIGNED</name> | <name>PND_FUNARG</name>)</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>LinkUseToDef</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAMESET</name></expr>:
        <expr_stmt><expr><call><name>RebindLets</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_tree</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case>}</block></switch>

    <return>return <expr>true</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_BLOCK_SCOPE */</comment>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>Statement</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn1</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>, *<decl><type ref="prev"/><name>pn4</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name></type> <name>stmtInfo</name></decl>, *<decl><type ref="prev"/><name>stmt</name></decl>, *<decl><type ref="prev"/><name>stmt2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>label</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CheckGetterOrSetter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_FUNCTION</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_DBLCOLON</name></expr>)</condition><then>
            <goto>goto <name>expression</name>;</goto></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><call><name>FunctionStmt</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>TOK_IF</name></expr>:
        <comment type="block">/* An IF node has three kids: condition, then, and optional else. */</comment>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn1</name> = <call><name>Condition</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_IF</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_ELSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_ELSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn3</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name> = <name>pn1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name> = <name>pn3</name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>

      </case><case>case <expr><name>TOK_SWITCH</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn5</name></decl>, *<decl><type ref="prev"/><name>saveBlock</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSBool</name></type> <name>seenDefault</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_BEFORE_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* pn1 points to the switch's discriminant. */</comment>
        <expr_stmt><expr><name>pn1</name> = <call><name>ParenExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_BEFORE_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
         * because that function states tc-&gt;topStmt-&gt;blockid.
         */</comment>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_SWITCH</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* pn2 is a list of case nodes. The default case has pn_left == NULL */</comment>
        <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>pn2</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>GenerateBlockIdForStmtNode</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>saveBlock</name> = <name><name>tc</name>-&gt;<name>blockNode</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockNode</name></name> = <name>pn2</name></expr>;</expr_stmt>

        <while>while <condition>(<expr>(<name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call>) != <name>TOK_RC</name></expr>)</condition> <block>{
            <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
              <case>case <expr><name>TOK_DEFAULT</name></expr>:
                <if>if <condition>(<expr><name>seenDefault</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_TOO_MANY_DEFAULTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>seenDefault</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>TOK_CASE</name></expr>:
                <expr_stmt><expr><name>pn3</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <if>if <condition>(<expr><name>tt</name> == <name>TOK_CASE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_left</name></name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name><name>pn3</name>-&gt;<name>pn_left</name></name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>pn2</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_count</name></name> == <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_TOO_MANY_CASES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <break>break;</break>

              </case><case>case <expr><name>TOK_ERROR</name></expr>:
                <return>return <expr><name>NULL</name></expr>;</return>

              </case><default>default:
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </default>}</block></switch>
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_COLON</name></expr></argument>, <argument><expr><name>JSMSG_COLON_AFTER_CASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pn4</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn4</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_type</name></name> = <name>TOK_LC</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn4</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call>) != <name>TOK_RC</name> &amp;&amp;
                   <name>tt</name> != <name>TOK_CASE</name> &amp;&amp; <name>tt</name> != <name>TOK_DEFAULT</name></expr>)</condition> <block>{
                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>pn5</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn5</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn5</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>pn4</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>

            <comment type="block">/* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */</comment>
            <if>if <condition>(<expr><name><name>pn4</name>-&gt;<name>pn_head</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn4</name>-&gt;<name>pn_head</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn4</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_right</name></name> = <name>pn4</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/*
         * Handle the case where there was a let declaration in any case in
         * the switch body, but not within an inner block.  If it replaced
         * tc-&gt;blockNode with a new block node then we must refresh pn2 and
         * then restore tc-&gt;blockNode.
         */</comment>
        <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>blockNode</name></name> != <name>pn2</name></expr>)</condition><then>
            <expr_stmt><expr><name>pn2</name> = <name><name>tc</name>-&gt;<name>blockNode</name></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockNode</name></name> = <name>saveBlock</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>TOK_WHILE</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_WHILE_LOOP</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Condition</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>

      </case><case>case <expr><name>TOK_DO</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_DO_LOOP</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_WHILE</name></expr></argument>, <argument><expr><name>JSMSG_WHILE_AFTER_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Condition</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JSVERSION_NUMBER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> != <name>JSVERSION_ECMA_3</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * All legacy and extended versions must do automatic semicolon
             * insertion after do-while.  See the testcase and discussion in
             * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
             */</comment>
            <expr_stmt><expr>(<name>void</name>) <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_SEMI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>pn</name></expr>;</return>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_FOR</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnseq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnlet</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSStmtInfo</name></type> <name>blockInfo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* A FOR node is binary, left is loop control and right is the body. */</comment>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_FOR_LOOP</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_ITER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>eachAtom</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> = <name>JSITER_FOREACH</name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
        <decl_stmt><decl><type><name>bool</name></type> <name>let</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><name>tt</name> == <name>TOK_SEMI</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_FOREACH</name></expr>)</condition><then>
                <goto>goto <name>bad_for_each</name>;</goto></then></if>

            <comment type="block">/* No initializer -- set first kid of left sub-node to null. */</comment>
            <expr_stmt><expr><name>pn1</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * Set pn1 to a var list or an initializing expression.
             *
             * Set the TCF_IN_FOR_INIT flag during parsing of the first clause
             * of the for statement.  This flag will be used by the RelExpr
             * production; if it is set, then the 'in' keyword will not be
             * recognized as an operator, leaving it available to be parsed as
             * part of a for/in loop.
             *
             * A side effect of this restriction is that (unparenthesized)
             * expressions involving an 'in' operator are illegal in the init
             * clause of an ordinary for loop.
             */</comment>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_VAR</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>(<name>void</name>) <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn1</name> = <call><name>Variables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_LET</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>let</name> = true</expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>) <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_LP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pn1</name> = <call><name>LetBlock</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tt</name> = <name>TOK_LEXICALSCOPE</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>pnlet</name> = <call><name>PushLexicalScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>blockInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pnlet</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>blockInfo</name>.<name>flags</name></name> |= <name>SIF_FOR_BLOCK</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pn1</name> = <call><name>Variables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>pn1</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>pn1</name></expr>)</condition><then> <block>{
                    <while>while <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
                        <expr_stmt><expr><name>pn1</name> = <name><name>pn1</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
                }</block></then></if>
            }</block></else></if></else></if>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></else></if>

        <comment type="block">/*
         * We can be sure that it's a for/in loop if there's still an 'in'
         * keyword here, even if JavaScript recognizes 'in' as an operator,
         * as we've excluded 'in' from being parsed in RelExpr by setting
         * the TCF_IN_FOR_INIT flag in our JSTreeContext.
         */</comment>
        <if>if <condition>(<expr><name>pn1</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_IN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> |= <name>JSITER_ENUMERATE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_FOR_IN_LOOP</name></expr>;</expr_stmt>

            <comment type="block">/* Check that the left side of the 'in' is valid. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>TOKEN_TYPE_IS_DECL</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call> || <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call> == <name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>TOKEN_TYPE_IS_DECL</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call>
                ? (<name><name>pn1</name>-&gt;<name>pn_count</name></name> &gt; 1 || <name><name>pn1</name>-&gt;<name>pn_op</name></name> == <name>JSOP_DEFCONST</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                   || (<call><name>JSVERSION_NUMBER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> == <name>JSVERSION_1_7</name> &amp;&amp;
                       <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ITER</name> &amp;&amp;
                       !(<name><name>pn</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_FOREACH</name>) &amp;&amp;
                       (<name><name>pn1</name>-&gt;<name>pn_head</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name> ||
                        (<name><name>pn1</name>-&gt;<name>pn_head</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> &amp;&amp;
                         <name><name>pn1</name>-&gt;<name>pn_head</name>-&gt;<name>pn_count</name></name> != 2) ||
                        (<name><name>pn1</name>-&gt;<name>pn_head</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name> &amp;&amp;
                         (<name><name>pn1</name>-&gt;<name>pn_head</name>-&gt;<name>pn_left</name>-&gt;<name>pn_type</name></name> != <name>TOK_RB</name> ||
                          <name><name>pn1</name>-&gt;<name>pn_head</name>-&gt;<name>pn_left</name>-&gt;<name>pn_count</name></name> != 2))))
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                  )
                : (<name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name> &amp;&amp;
                   <name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_DOT</name> &amp;&amp;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                   ((<call><name>JSVERSION_NUMBER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> == <name>JSVERSION_1_7</name> &amp;&amp;
                     <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ITER</name> &amp;&amp;
                     !(<name><name>pn</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_FOREACH</name>))
                    ? (<name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_RB</name> || <name><name>pn1</name>-&gt;<name>pn_count</name></name> != 2)
                    : (<name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_RB</name> &amp;&amp; <name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_RC</name>)) &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
                   <name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_LP</name> &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
                   (<name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_UNARYOP</name> ||
                    <name><name>pn1</name>-&gt;<name>pn_op</name></name> != <name>JSOP_XMLNAME</name>) &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_LB</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_FOR_LEFTSIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* pn2 points to the name or destructuring pattern on in's left. */</comment>
            <expr_stmt><expr><name>pn2</name> = <name>NULL</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>uintN</name></type> <name>dflag</name> <init>= <expr><name>PND_ASSIGNED</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>TOKEN_TYPE_IS_DECL</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* Tell js_EmitTree(TOK_VAR) that pn1 is part of a for/in. */</comment>
                <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_FORINVAR</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Rewrite 'for (&lt;decl&gt; x = i in o)' where &lt;decl&gt; is 'let',
                 * 'var', or 'const' to hoist the initializer or the entire
                 * decl out of the loop head. TOK_VAR is the type for both
                 * 'var' and 'const'.
                 */</comment>
                <expr_stmt><expr><name>pn2</name> = <name><name>pn1</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp; <call><name><name>pn2</name>-&gt;<name>maybeExpr</name></name><argument_list>()</argument_list></call>)
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                    || <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    )</condition><then> <block>{
                    <expr_stmt><expr><name>pnseq</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pnseq</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>pnseq</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEQ</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pnseq</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                    <if>if <condition>(<expr><name>tt</name> == <name>TOK_LET</name></expr>)</condition><then> <block>{
                        <comment type="block">/*
                         * Hoist just the 'i' from 'for (let x = i in o)' to
                         * before the loop, glued together via pnseq.
                         */</comment>
                        <expr_stmt><expr><name>pn3</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                            <return>return <expr><name>NULL</name></expr>;</return></then></if>
                        <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEMI</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>pn4</name> = <name><name>pn2</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>pn2</name> = <name><name>pn1</name>-&gt;<name>pn_head</name></name> = <name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                        }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <block>{
                            <expr_stmt><expr><name>pn4</name> = <name><name>pn2</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>NULL</name></expr>;</expr_stmt>
                        }</block></else></if>
                        <if>if <condition>(<expr>!<call><name>RebindLets</name><argument_list>(<argument><expr><name>pn4</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <return>return <expr><name>NULL</name></expr>;</return></then></if>
                        <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_pos</name></name> = <name><name>pn4</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_kid</name></name> = <name>pn4</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>pnseq</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_BLOCK_SCOPE */</comment>
                    <block>{
                        <expr_stmt><expr><name>dflag</name> = <name>PND_INITIALIZED</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * All of 'var x = i' is hoisted above 'for (x in o)',
                         * so clear PNX_FORINVAR.
                         *
                         * Request JSOP_POP here since the var is for a simple
                         * name (it is not a destructuring binding's left-hand
                         * side) and it has an initializer.
                         */</comment>
                        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_xflags</name></name> &amp;= ~<name>PNX_FORINVAR</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_POPVAR</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>pnseq</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>pn1</name> = <call><name>CloneParseTree</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
                                <return>return <expr><name>NULL</name></expr>;</return></then></if>
                        }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <block>{
                            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>pn1</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
                                <return>return <expr><name>NULL</name></expr>;</return></then></if>
                            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> = <name>TOK_NAME</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_pos</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
                            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then>
                                <expr_stmt><expr><call><name>LinkUseToDef</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr>(<name>JSDefinition</name> *) <name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                        }</block></else></if>
                        <expr_stmt><expr><name>pn2</name> = <name>pn1</name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
            }</block></then></if>

            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn2</name> = <name>pn1</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LP</name> &amp;&amp;
                    !<call><name>MakeSetCall</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSMSG_BAD_LEFTSIDE_OF_ASS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_UNARYOP</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_BINDXMLNAME</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then></if>

            <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
              <case>case <expr><name>TOK_NAME</name></expr>:
                <comment type="block">/* Beware 'for (arguments in ...)' with or without a 'var'. */</comment>
                <expr_stmt><expr><call><name>NoteLValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>dflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_ASSIGN</name></expr>:
                <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>
              </case><case>case <expr><name>TOK_RB</name></expr>:
              </case><case>case <expr><name>TOK_RC</name></expr>:
                <comment type="block">/* Check for valid lvalues in var-less destructuring for-in. */</comment>
                <if>if <condition>(<expr><name>pn1</name> == <name>pn2</name> &amp;&amp; !<call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>

                <if>if <condition>(<expr><call><name>JSVERSION_NUMBER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> == <name>JSVERSION_1_7</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Destructuring for-in requires [key, value] enumeration
                     * in JS1.7.
                     */</comment>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!(<name><name>pn</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_FOREACH</name>)</expr>)</condition><then>
                        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> |= <name>JSITER_FOREACH</name> | <name>JSITER_KEYVALUE</name></expr>;</expr_stmt></then></if>
                }</block></then></if>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

              </case><default>default:<empty_stmt>;</empty_stmt>
            </default>}</block></switch>

            <comment type="block">/*
             * Parse the object expression as the right operand of 'in', first
             * removing the top statement from the statement-stack if this is a
             * 'for (let x in y)' loop.
             */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>save</name> <init>= <expr><name><name>tc</name>-&gt;<name>topStmt</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>let</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name><name>save</name>-&gt;<name>down</name></name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>pn2</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <if>if <condition>(<expr><name>let</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name>save</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>pn2</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_IN</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn2</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_FOREACH</name></expr>)</condition><then>
                <goto>goto <name>bad_for_each</name>;</goto></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>

            <comment type="block">/* Parse the loop condition or null into pn2. */</comment>
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_SEMI</name></expr></argument>, <argument><expr><name>JSMSG_SEMI_AFTER_FOR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_SEMI</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn2</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>pn2</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></else></if>

            <comment type="block">/* Parse the update expression or null into pn3. */</comment>
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_SEMI</name></expr></argument>, <argument><expr><name>JSMSG_SEMI_AFTER_FOR_COND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_RP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn3</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>pn3</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></else></if>

            <comment type="block">/* Build the FORHEAD node to use as the left kid of pn. */</comment>
            <expr_stmt><expr><name>pn4</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn4</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_type</name></name> = <name>TOK_FORHEAD</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_kid1</name></name> = <name>pn1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_kid2</name></name> = <name>pn2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn4</name>-&gt;<name>pn_kid3</name></name> = <name>pn3</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn4</name></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_FOR_CTRL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Parse the loop body into pn-&gt;pn_right. */</comment>
        <expr_stmt><expr><name>pn2</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>pn2</name></expr>;</expr_stmt>

        <comment type="block">/* Record the absolute line number for source note emission. */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
        <if>if <condition>(<expr><name>pnlet</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pnlet</name>-&gt;<name>pn_expr</name></name> = <name>pn</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>pnlet</name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name>pnseq</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pnseq</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pnseq</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>pnseq</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>

      <label><name>bad_for_each</name>:</label>
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_FOR_EACH_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>TOK_TRY</name></expr>: <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>catchList</name></decl>, *<decl><type ref="prev"/><name>lastCatch</name></decl>;</decl_stmt>

        <comment type="block">/*
         * try nodes are ternary.
         * kid1 is the try Statement
         * kid2 is the catch node list or null
         * kid3 is the finally Statement
         *
         * catch nodes are ternary.
         * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
         * kid2 is the catch guard or null if no guard
         * kid3 is the catch block
         *
         * catch lvalue nodes are either:
         *   TOK_NAME for a single identifier
         *   TOK_RB or TOK_RC for a destructuring left-hand side
         *
         * finally nodes are TOK_LC Statement lists.
         */</comment>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_BEFORE_TRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>PushBlocklikeStatement</name><argument_list>(<argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_TRY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_AFTER_TRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>catchList</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_CATCH</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>catchList</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>catchList</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>catchList</name>-&gt;<name>pn_type</name></name> = <name>TOK_RESERVED</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>catchList</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastCatch</name> = <name>NULL</name></expr>;</expr_stmt>

            <do>do <block>{
                <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnblock</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>BindData</name></type> <name>data</name></decl>;</decl_stmt>

                <comment type="block">/* Check for another catch after unconditional catch. */</comment>
                <if>if <condition>(<expr><name>lastCatch</name> &amp;&amp; !<name><name>lastCatch</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_CATCH_AFTER_GENERAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>

                <comment type="block">/*
                 * Create a lexical scope node around the whole catch clause,
                 * including the head.
                 */</comment>
                <expr_stmt><expr><name>pnblock</name> = <call><name>PushLexicalScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pnblock</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_CATCH</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Legal catch forms are:
                 *   catch (lhs)
                 *   catch (lhs if &lt;boolean_expression&gt;)
                 * where lhs is a name or a destructuring left-hand side.
                 * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
                 */</comment>
                <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pnblock</name>-&gt;<name>pn_expr</name></name> = <name>pn2</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_BEFORE_CATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Contrary to ECMA Ed. 3, the catch variable is lexically
                 * scoped, not a property of a new Object instance.  This is
                 * an intentional change that anticipates ECMA Ed. 4.
                 */</comment>
                <expr_stmt><expr><name><name>data</name>.<name>pn</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name>.<name>op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name>.<name>binder</name></name> = <name>BindLet</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name>.<name>let</name>.<name>overflow</name></name> = <name>JSMSG_TOO_MANY_CATCH_VARS</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                  <case>case <expr><name>TOK_LB</name></expr>:
                  </case><case>case <expr><name>TOK_LC</name></expr>:
                    <expr_stmt><expr><name>pn3</name> = <call><name>DestructuringExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                  </case><case>case <expr><name>TOK_NAME</name></expr>:
                    <expr_stmt><expr><name>label</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pn3</name> = <call><name>NewBindingNode</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>data</name>.<name>pn</name></name> = <name>pn3</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name><name>data</name>.<name>binder</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <break>break;</break>

                  </case><default>default:
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_CATCH_IDENTIFIER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </default>}</block></switch>

                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_kid1</name></name> = <name>pn3</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_CATCH_GUARD</name></expr></cpp:if>
                <comment type="block">/*
                 * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
                 * to avoid conflicting with the JS2/ECMAv4 type annotation
                 * catchguard syntax.
                 */</comment>
                <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_IF</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_kid2</name></name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_CATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_BEFORE_CATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_kid3</name></name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_AFTER_CATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>catchList</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pnblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lastCatch</name> = <name>pn2</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>tt</name> == <name>TOK_CATCH</name></expr>)</condition>;</do>
        }</block></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> = <name>catchList</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>tt</name> == <name>TOK_FINALLY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_BEFORE_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>PushBlocklikeStatement</name><argument_list>(<argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_FINALLY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_AFTER_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr>!<name>catchList</name> &amp;&amp; !<name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_CATCH_OR_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>pn</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>TOK_THROW</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */</comment>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_PeekTokenSameLine</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_EOF</name> || <name>tt</name> == <name>TOK_EOL</name> || <name>tt</name> == <name>TOK_SEMI</name> || <name>tt</name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>pn2</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_THROW</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <break>break;</break>

      <comment type="block">/* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */</comment>
      </case><case>case <expr><name>TOK_CATCH</name></expr>:
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_CATCH_WITHOUT_TRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>

      </case><case>case <expr><name>TOK_FINALLY</name></expr>:
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_FINALLY_WITHOUT_TRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>

      </case><case>case <expr><name>TOK_BREAK</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>MatchLabel</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>label</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>label</name></expr>)</condition><then> <block>{
            <for>for (<init>;</init> <condition>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<name>stmt</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_LABEL_NOT_FOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_LABEL</name> &amp;&amp; <name><name>stmt</name>-&gt;<name>label</name></name> == <name>label</name></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></for>
        }</block></then> <else>else <block>{
            <for>for (<init>;</init> <condition>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<name>stmt</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_TOUGH_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> || <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_SWITCH</name></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></for>
        }</block></else></if>
        <if>if <condition>(<expr><name>label</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_CONTINUE</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>MatchLabel</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>label</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>label</name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>stmt2</name> = <name>NULL</name></expr>;</init> <condition>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<name>stmt</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_LABEL_NOT_FOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_LABEL</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>label</name></name> == <name>label</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>!<name>stmt2</name> || !<call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                        <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                        <argument><expr><name>JSMSG_BAD_CONTINUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>NULL</name></expr>;</return>
                        }</block></then></if>
                        <break>break;</break>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>stmt2</name> = <name>stmt</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
        }</block></then> <else>else <block>{
            <for>for (<init>;</init> <condition>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<name>stmt</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_BAD_CONTINUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></for>
        }</block></else></if>
        <if>if <condition>(<expr><name>label</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_WITH</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_BEFORE_WITH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>ParenExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_WITH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn2</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_WITH</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>

      </case><case>case <expr><name>TOK_VAR</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>Variables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/* Tell js_EmitTree to generate a final POP. */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_POPVAR</name></expr>;</expr_stmt>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_LET</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSObjectBox</name> *</type><name>blockbox</name></decl>;</decl_stmt>

        <comment type="block">/* Check for a let statement or let expression. */</comment>
        <if>if <condition>(<expr><call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_LP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn</name> = <call><name>LetBlock</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn</name> || <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_LEAVEBLOCK</name></expr>)</condition><then>
                <return>return <expr><name>pn</name></expr>;</return></then></if>

            <comment type="block">/* Let expressions require automatic semicolon insertion. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_SEMI</name> ||
                      <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_LEAVEBLOCKEXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/*
         * This is a let declaration. We must be directly under a block per
         * the proposed ES4 specs, but not an implicit block created due to
         * 'for (let ...)'. If we pass this error test, make the enclosing
         * JSStmtInfo be our scope. Further let declarations in this block
         * will find this scope statement and use the same block object.
         *
         * If we are the first let declaration in this block (i.e., when the
         * enclosing maybe-scope JSStmtInfo isn't yet a scope statement) then
         * we also need to set tc-&gt;blockNode to be our TOK_LEXICALSCOPE.
         */</comment>
        <expr_stmt><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>stmt</name> &amp;&amp;
            (!<call><name>STMT_MAYBE_SCOPE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> || (<name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_FOR_BLOCK</name>))</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_LET_DECL_NOT_IN_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>stmt</name> &amp;&amp; (<name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>blockChain</name></name> == <name><name>stmt</name>-&gt;<name>blockObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>obj</name> = <name><name>tc</name>-&gt;<name>blockChain</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<name>stmt</name> || (<name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_BODY_BLOCK</name>)</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * ES4 specifies that let at top level and at body-block scope
                 * does not shadow var, so convert back to var.
                 */</comment>
                <expr_stmt><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> = <name>TOK_VAR</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> = <name>JSOP_DEFVAR</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>pn</name> = <call><name>Variables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_POPVAR</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>

            <comment type="block">/*
             * Some obvious assertions here, but they may help clarify the
             * situation. This stmt is not yet a scope, so it must not be a
             * catch block (catch is a lexical scope by definition).
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>stmt</name> != <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name> ||
                      <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_SWITCH</name> ||
                      <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_TRY</name> ||
                      <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>stmt</name>-&gt;<name>downScope</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Convert the block statement into a scope statement. */</comment>
            <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>js_NewBlockObject</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <expr_stmt><expr><name>blockbox</name> = <call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newObjectBox</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>blockbox</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <comment type="block">/*
             * Insert stmt on the tc-&gt;topScopeStmt/stmtInfo.downScope linked
             * list stack, if it isn't already there.  If it is there, but it
             * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
             * block.
             */</comment>
            <expr_stmt><expr><name><name>stmt</name>-&gt;<name>flags</name></name> |= <name>SIF_SCOPE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name>-&gt;<name>downScope</name></name> = <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name>stmt</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_SCOPE_DEPTH_METERING</name><argument_list>(<argument><expr>++<name><name>tc</name>-&gt;<name>scopeDepth</name></name> &gt; <name><name>tc</name>-&gt;<name>maxScopeDepth</name></name> &amp;&amp;
                                    (<name><name>tc</name>-&gt;<name>maxScopeDepth</name></name> = <name><name>tc</name>-&gt;<name>scopeDepth</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>STOBJ_SET_PARENT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>blockChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockChain</name></name> = <name>obj</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name>-&gt;<name>blockObj</name></name> = <name>obj</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <expr_stmt><expr><name>pn1</name> = <name><name>tc</name>-&gt;<name>blockNode</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pn1</name> || <name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_LEXICALSCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* Create a new lexical scope node for these statements. */</comment>
            <expr_stmt><expr><name>pn1</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NAME</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> = <name>TOK_LEXICALSCOPE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_op</name></name> = <name>JSOP_LEAVEBLOCK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_pos</name></name> = <name><name>tc</name>-&gt;<name>blockNode</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_objbox</name></name> = <name>blockbox</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_expr</name></name> = <name><name>tc</name>-&gt;<name>blockNode</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_blockid</name></name> = <name><name>tc</name>-&gt;<name>blockNode</name>-&gt;<name>pn_blockid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockNode</name></name> = <name>pn1</name></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>pn</name> = <call><name>Variables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> = <name>PNX_POPVAR</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_BLOCK_SCOPE */</comment>

      </case><case>case <expr><name>TOK_RETURN</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>ReturnOrYield</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>Expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_LC</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>oldflags</name> = <name><name>tc</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name> &amp; ~<name>TCF_HAS_FUNCTION_STMT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>PushBlocklikeStatement</name><argument_list>(<argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_BLOCK</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn</name> = <call><name>Statements</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_IN_COMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we contain a function statement and our container is top-level
         * or another block, flag pn to preserve braces when decompiling.
         */</comment>
        <if>if <condition>(<expr>(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_HAS_FUNCTION_STMT</name>) &amp;&amp;
            (!<name><name>tc</name>-&gt;<name>topStmt</name></name> || <name><name>tc</name>-&gt;<name>topStmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_NEEDBRACES</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name> | (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; (<name>TCF_FUN_FLAGS</name> | <name>TCF_RETURN_FLAGS</name>))</expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>TOK_EOL</name></expr>:
      </case><case>case <expr><name>TOK_SEMI</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEMI</name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DEBUGGER_KEYWORD</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_DEBUGGER</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_DEBUGGER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DEBUGGER_KEYWORD */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_DEFAULT</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_NAME</name></expr></argument>)</argument_list></call> ||
            <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name> != <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>xmlAtom</name></name> ||
            !<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_NAME</name></expr></argument>)</argument_list></call> ||
            <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name> != <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>namespaceAtom</name></name> ||
            !<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_ASSIGN</name></expr></argument>)</argument_list></call> ||
            <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_DEFAULT_XML_NAMESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DEFXMLNS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr><name>TOK_ERROR</name></expr>:
        <return>return <expr><name>NULL</name></expr>;</return>

      </case><default>default:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      <label><name>expression</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <if>if <condition>(<expr><call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_COLON</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_LABEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>label</name> = <name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
            <for>for (<init><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</init> <condition><expr><name>stmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_LABEL</name> &amp;&amp; <name><name>stmt</name>-&gt;<name>label</name></name> == <name>label</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_DUPLICATE_LABEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><call><name>ForgetUse</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr>(<name>void</name>) <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Push a label struct and parse the statement. */</comment>
            <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_LABEL</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>label</name></name> = <name>label</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <call><name>Statement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <comment type="block">/* Normalize empty statement to empty block for the decompiler. */</comment>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_SEMI</name> &amp;&amp; !<name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_LC</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_LIST</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* Pop the label, set pn_expr, and return early. */</comment>
            <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_COLON</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>pn</name></expr>;</expr_stmt>
            <return>return <expr><name>pn2</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_SEMI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <comment type="block">/* Check termination of this primitive statement. */</comment>
    <return>return <expr><call><name>MatchOrInsertSemicolon</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> ? <name>pn</name> : <name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>NoteArgumentsUse</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_USES_ARGUMENTS</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>funbox</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>funbox</name>-&gt;<name>node</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_FUNARG</name></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>Variables</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>inLetHead</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>let</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>scopeStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BindData</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The three options here are:
     * - TOK_LET: We are parsing a let declaration.
     * - TOK_LP: We are parsing the head of a let block.
     * - Otherwise, we're parsing var declarations.
     */</comment>
    <expr_stmt><expr><name>tt</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>let</name> = (<name>tt</name> == <name>TOK_LET</name> || <name>tt</name> == <name>TOK_LP</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>let</name> || <name>tt</name> == <name>TOK_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>bool</name></type> <name>popScope</name> <init>= <expr>(<name>inLetHead</name> || (<name>let</name> &amp;&amp; (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FOR_INIT</name>)))</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>save</name> <init>= <expr><name><name>tc</name>-&gt;<name>topStmt</name></name></expr></init>, *<name>saveScope</name> <init>= <expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Make sure that Statement set up the tree context correctly. */</comment>
    <expr_stmt><expr><name>scopeStmt</name> = <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>let</name></expr>)</condition><then> <block>{
        <while>while <condition>(<expr><name>scopeStmt</name> &amp;&amp; !(<name><name>scopeStmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name>)</expr>)</condition> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>STMT_MAYBE_SCOPE</name><argument_list>(<argument><expr><name>scopeStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scopeStmt</name> = <name><name>scopeStmt</name>-&gt;<name>downScope</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>scopeStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>data</name>.<name>op</name></name> = <name>let</name> ? <name>JSOP_NOP</name> : <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name><name>data</name>.<name>op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * SpiderMonkey const is really "write once per initialization evaluation"
     * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
     * this code will change soon.
     */</comment>
    <if>if <condition>(<expr><name>let</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>blockChain</name></name> == <name><name>scopeStmt</name>-&gt;<name>blockObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name>.<name>binder</name></name> = <name>BindLet</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name>.<name>let</name>.<name>overflow</name></name> = <name>JSMSG_TOO_MANY_LOCALS</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>data</name>.<name>binder</name></name> = <name>BindVarOrConst</name></expr>;</expr_stmt>
    }</block></else></if>

    <do>do <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_LB</name> || <name>tt</name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_DESTRUCTURING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn2</name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_DESTRUCTURING</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <if>if <condition>(<expr>!<call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <if>if <condition>(<expr>(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FOR_INIT</name>) &amp;&amp;
                <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_IN</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_ASSIGN</name></expr></argument>, <argument><expr><name>JSMSG_BAD_DESTRUCT_DECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> != <name>JSOP_NOP</name></expr>)</condition><then>
                <goto>goto <name>bad_var_init</name>;</goto></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <if>if <condition>(<expr><name>popScope</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name><name>save</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name><name>saveScope</name>-&gt;<name>downScope</name></name></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>init</name> <init>= <expr><call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <if>if <condition>(<expr><name>popScope</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name>save</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name>saveScope</name></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if>if <condition>(<expr>!<name>init</name> || !<call><name>UndominateInitializers</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <expr_stmt><expr><name>pn2</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_ASSIGN</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DESTRUCTURING */</comment>

        <if>if <condition>(<expr><name>tt</name> != <name>TOK_NAME</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>tt</name> != <name>TOK_ERROR</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_NO_VARIABLE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>atom</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>NewBindingNode</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>let</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>data</name>.<name>op</name></name> == <name>JSOP_DEFCONST</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_CONST</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>data</name>.<name>pn</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>data</name>.<name>binder</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_ASSIGN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> != <name>JSOP_NOP</name></expr>)</condition><then>
                <goto>goto <name>bad_var_init</name>;</goto></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <if>if <condition>(<expr><name>popScope</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name><name>save</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name><name>saveScope</name>-&gt;<name>downScope</name></name></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>init</name> <init>= <expr><call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <if>if <condition>(<expr><name>popScope</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name>save</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name>saveScope</name></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr>!<name>init</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn2</name> = <call><name>MakeAssignment</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>init</name></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = (<call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call> == <name>JSOP_ARGUMENTS</name>)
                         ? <name>JSOP_SETNAME</name>
                         : (<name><name>pn2</name>-&gt;<name>pn_dflags</name></name> &amp; <name>PND_GVAR</name>)
                         ? <name>JSOP_SETGVAR</name>
                         : (<name><name>pn2</name>-&gt;<name>pn_dflags</name></name> &amp; <name>PND_BOUND</name>)
                         ? <name>JSOP_SETLOCAL</name>
                         : (<name><name>data</name>.<name>op</name></name> == <name>JSOP_DEFCONST</name>)
                         ? <name>JSOP_SETCONST</name>
                         : <name>JSOP_SETNAME</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>NoteLValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>data</name>.<name>fresh</name></name> ? <name>PND_INITIALIZED</name> : <name>PND_ASSIGNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* The declarator's position must include the initializer. */</comment>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>init</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr>(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>) &amp;&amp;
                <name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NoteArgumentsUse</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>let</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block> while <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call>-&gt;<name><name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>

<label><name>bad_var_init</name>:</label>
    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                <argument><expr><name>JSMSG_BAD_VAR_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>Expr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn2</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
        <do>do <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
            <expr_stmt><expr><name>pn2</name> = <call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_YIELD</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_GENERATOR_SYNTAX</name></expr></argument>,
                                            <argument><expr><name>js_yield_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>pn2</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call>-&gt;<name><name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>AssignExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_YIELD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <return>return <expr><call><name>ReturnOrYield</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>AssignExpr</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>pn</name> = <call><name>CondExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CheckGetterOrSetter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>tt</name> != <name>TOK_ASSIGN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>pn2</name> = <name>pn</name></expr>;</init> <condition><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_kid</name></name></expr></incr>)
        <continue>continue;</continue></for>
    <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_NAME</name></expr>:
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETNAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NoteLValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>TOK_DOT</name></expr>:
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETPROP</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>TOK_LB</name></expr>:
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETELEM</name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_RB</name></expr>:
      </case><case>case <expr><name>TOK_RC</name></expr>:
        <if>if <condition>(<expr><name>op</name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_DESTRUCT_ASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>pn</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name> || !<call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <return>return <expr><call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_ASSIGN</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_LP</name></expr>:
        <if>if <condition>(<expr>!<call><name>MakeSetCall</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSMSG_BAD_LEFTSIDE_OF_ASS</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLNAME</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETXMLNAME</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </case><default>default:
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_LEFTSIDE_OF_ASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </default>}</block></switch>

    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn3</name> <init>= <expr><call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>pn3</name> &amp;&amp; <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call> == <name>TOK_NAME</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><name><name>pn2</name>-&gt;<name>pn_lexdef</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the definition is not flagged as assigned, we must have imputed
         * the initialized flag to it, to optimize for flat closures. But that
         * optimization uses source coordinates to check dominance relations,
         * so we must extend the end of the definition to cover the right-hand
         * side of this assignment, i.e., the initializer.
         */</comment>
        <if>if <condition>(<expr>!<call><name><name>dn</name>-&gt;<name>isAssigned</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>dn</name>-&gt;<name>isInitialized</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn3</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_ASSIGN</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>CondExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn1</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>OrExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_HOOK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn1</name> = <name>pn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <comment type="block">/*
         * Always accept the 'in' operator in the middle clause of a ternary,
         * where it's unambiguous, even if we might be parsing the init of a
         * for statement.
         */</comment>
        <expr_stmt><expr><name>oldflags</name> = <name><name>tc</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name> | (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_FUN_FLAGS</name>)</expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_COLON</name></expr></argument>, <argument><expr><name>JSMSG_COLON_IN_COND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn3</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn1</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn3</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name> = <name>pn1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name> = <name>pn3</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>OrExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>AndExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_OR</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_OR</name></expr></argument>, <argument><expr><name>JSOP_OR</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>AndExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>AndExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>BitOrExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_AND</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_AND</name></expr></argument>, <argument><expr><name>JSOP_AND</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>BitOrExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>BitOrExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>BitXorExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_BITOR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_BITOR</name></expr></argument>, <argument><expr><name>JSOP_BITOR</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>BitXorExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>BitXorExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>BitAndExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_BITXOR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_BITXOR</name></expr></argument>, <argument><expr><name>JSOP_BITXOR</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>BitAndExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>BitAndExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>EqExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_BITAND</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_BITAND</name></expr></argument>, <argument><expr><name>JSOP_BITAND</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>EqExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>EqExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>RelExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_EQOP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_EQOP</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>RelExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>RelExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>inForInitFlag</name> <init>= <expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FOR_INIT</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Uses of the in operator in ShiftExprs are always unambiguous,
     * so unset the flag that prohibits recognizing it.
     */</comment>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>ShiftExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp;
           (<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_RELOP</name></expr></argument>)</argument_list></call> ||
            <comment type="block">/*
             * Recognize the 'in' token as an operator only if we're not
             * currently in the init expr of a for loop.
             */</comment>
            (<name>inForInitFlag</name> == 0 &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_IN</name></expr></argument>)</argument_list></call>) ||
            <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_INSTANCEOF</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>tt</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>ShiftExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <comment type="block">/* Restore previous state of inForInit flag. */</comment>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>inForInitFlag</name></expr>;</expr_stmt>

    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>ShiftExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>AddExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp; <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_SHOP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_SHOP</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>AddExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>AddExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>MulExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp;
           (<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_PLUS</name></expr></argument>)</argument_list></call> ||
            <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_MINUS</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = (<name>tt</name> == <name>TOK_PLUS</name>) ? <name>JSOP_ADD</name> : <name>JSOP_SUB</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>tt</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>MulExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>MulExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>UnaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pn</name> &amp;&amp;
           (<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_STAR</name></expr></argument>)</argument_list></call> ||
            <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_DIVOP</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>tt</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>UnaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>SetLvalKid</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>kid</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name><name>kid</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
        <expr_stmt><expr><name>kid</name> = <name><name>kid</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
    <if>if <condition>(<expr><name><name>kid</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name> &amp;&amp;
        <name><name>kid</name>-&gt;<name>pn_type</name></name> != <name>TOK_DOT</name> &amp;&amp;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
        (<name><name>kid</name>-&gt;<name>pn_type</name></name> != <name>TOK_LP</name> ||
         (<name><name>kid</name>-&gt;<name>pn_op</name></name> != <name>JSOP_CALL</name> &amp;&amp; <name><name>kid</name>-&gt;<name>pn_op</name></name> != <name>JSOP_EVAL</name> &amp;&amp; <name><name>kid</name>-&gt;<name>pn_op</name></name> != <name>JSOP_APPLY</name>)) &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        (<name><name>kid</name>-&gt;<name>pn_type</name></name> != <name>TOK_UNARYOP</name> || <name><name>kid</name>-&gt;<name>pn_op</name></name> != <name>JSOP_XMLNAME</name>) &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <name><name>kid</name>-&gt;<name>pn_type</name></name> != <name>TOK_LB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_OPERAND</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>kid</name></expr>;</expr_stmt>
    <return>return <expr><name>kid</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>incop_name_str</name><index>[]</index><index>[<expr>10</expr>]</index></name> <init>= <expr><block>{<expr>"increment"</expr>, <expr>"decrement"</expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>SetIncOpKid</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
            <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>kid</name></decl></param>,
            <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>preorder</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>kid</name> = <call><name>SetLvalKid</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>kid</name></expr></argument>, <argument><expr><name><name>incop_name_str</name><index>[<expr><name>tt</name> == <name>TOK_DEC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>kid</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <switch>switch <condition>(<expr><name><name>kid</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_NAME</name></expr>:
        <expr_stmt><expr><name>op</name> = (<name>tt</name> == <name>TOK_INC</name>)
             ? (<name>preorder</name> ? <name>JSOP_INCNAME</name> : <name>JSOP_NAMEINC</name>)
             : (<name>preorder</name> ? <name>JSOP_DECNAME</name> : <name>JSOP_NAMEDEC</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NoteLValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>kid</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_DOT</name></expr>:
        <expr_stmt><expr><name>op</name> = (<name>tt</name> == <name>TOK_INC</name>)
             ? (<name>preorder</name> ? <name>JSOP_INCPROP</name> : <name>JSOP_PROPINC</name>)
             : (<name>preorder</name> ? <name>JSOP_DECPROP</name> : <name>JSOP_PROPDEC</name>)</expr>;</expr_stmt>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_LP</name></expr>:
        <if>if <condition>(<expr>!<call><name>MakeSetCall</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>kid</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSMSG_BAD_INCOP_OPERAND</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
        <if>if <condition>(<expr><name><name>kid</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLNAME</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>kid</name>-&gt;<name>pn_op</name></name> = <name>JSOP_SETXMLNAME</name></expr>;</expr_stmt></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </case><case>case <expr><name>TOK_LB</name></expr>:
        <expr_stmt><expr><name>op</name> = (<name>tt</name> == <name>TOK_INC</name>)
             ? (<name>preorder</name> ? <name>JSOP_INCELEM</name> : <name>JSOP_ELEMINC</name>)
             : (<name>preorder</name> ? <name>JSOP_DECELEM</name> : <name>JSOP_ELEMDEC</name>)</expr>;</expr_stmt>
        <break>break;</break>

      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    </default>}</block></switch>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>UnaryExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_UNARYOP</name></expr>:
      </case><case>case <expr><name>TOK_PLUS</name></expr>:
      </case><case>case <expr><name>TOK_MINUS</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_UNARYOP</name></expr>;</expr_stmt>      <comment type="block">/* PLUS and MINUS are binary */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <call><name>UnaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_INC</name></expr>:
      </case><case>case <expr><name>TOK_DEC</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>MemberExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>SetIncOpKid</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_DELETE</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>UnaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Under ECMA3, deleting any unary expression is valid -- it simply
         * returns true. Here we strip off any parentheses and fold constants
         * before checking for a call expression, in order to rule out delete
         * of a generator expression.
         */</comment>
        <while>while <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
            <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
        <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_LP</name></expr>:
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> != <name>JSOP_SETCALL</name> &amp;&amp;
                !<call><name>MakeSetCall</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JSMSG_BAD_DELETE_OPERAND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_NAME</name></expr>:
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DELNAME</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_ERROR</name></expr>:
        <return>return <expr><name>NULL</name></expr>;</return>

      </case><default>default:
        <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>MemberExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/* Don't look across a newline boundary for a postfix incop. */</comment>
        <if>if <condition>(<expr><call><name>ON_CURRENT_LINE</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pos</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = <call><name>js_PeekTokenSameLine</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_INC</name> || <name>tt</name> == <name>TOK_DEC</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>(<name>void</name>) <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>SetIncOpKid</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>

<comment type="block">/*
 * A dedicated helper for transplanting the comprehension expression E in
 *
 *   [E for (V in I)]   // array comprehension
 *   (E for (V in I))   // generator expression
 *
 * from its initial location in the AST, on the left of the 'for', to its final
 * position on the right. To avoid a separate pass we do this by adjusting the
 * blockids and name binding links that were established when E was parsed.
 *
 * A generator expression desugars like so:
 *
 *   (E for (V in I)) =&gt; (function () { for (var V in I) yield E; })()
 *
 * so the transplanter must adjust static level as well as blockid. E's source
 * coordinates in root-&gt;pn_pos are critical to deciding which binding links to
 * preserve and which to cut.
 *
 * NB: This is not a general tree transplanter -- it knows in particular that
 * the one or more bindings induced by V have not yet been created.
 */</comment>
<class>class <name>CompExprTransplanter</name> <block>{<private type="default">
    <decl_stmt><decl><type><name>JSParseNode</name>     *</type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTreeContext</name>   *</type><name>tc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>genexp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type>           <name>adjust</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type>           <name>funcLevel</name></decl>;</decl_stmt>

  </private><public>public:
    <constructor><name>CompExprTransplanter</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>ge</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>adj</name></decl></param>)</parameter_list>
      <member_list>: <call><name>root</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call>, <call><name>tc</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call>, <call><name>genexp</name><argument_list>(<argument><expr><name>ge</name></expr></argument>)</argument_list></call>, <call><name>adjust</name><argument_list>(<argument><expr><name>adj</name></expr></argument>)</argument_list></call>, <call><name>funcLevel</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>

    <function_decl><type><name>bool</name></type> <name>transplant</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>;</function_decl>
</public>}</block>;</class>

<comment type="block">/*
 * Any definitions nested within the comprehension expression of a generator
 * expression must move "down" one static level, which of course increases the
 * upvar-frame-skip count.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BumpStaticLevel</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> != <name>FREE_UPVAR_COOKIE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>uintN</name></type> <name>level</name> <init>= <expr><call><name>UPVAR_FRAME_SKIP</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>level</name> &gt;= <name><name>tc</name>-&gt;<name>staticLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>level</name> &gt;= <name>FREE_STATIC_LEVEL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSMSG_TOO_DEEP</name></expr></argument>, <argument><expr><name>js_function_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <call><name>MAKE_UPVAR_COOKIE</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><call><name>UPVAR_FRAME_SLOT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustBlockId</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>adjust</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name> || <name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_FUNC</name> || <name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> += <name>adjust</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> &gt;= <name><name>tc</name>-&gt;<name>blockidGen</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockidGen</name></name> = <name><name>pn</name>-&gt;<name>pn_blockid</name></name> + 1</expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>bool</name></type>
<name><name>CompExprTransplanter</name>::<name>transplant</name></name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_LIST</name></expr>:
        <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pn2</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_head</name></name></expr></init></decl>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>)
            <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_pos</name></name> &gt;= <name><name>root</name>-&gt;<name>pn_pos</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>AdjustBlockId</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Binary TOK_COLON nodes can have left == right. See bug 492714. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_right</name></name> != <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_FUNC</name></expr>:
      <block>{
        <comment type="block">/*
         * Only the first level of transplant recursion through functions needs
         * to reparent the funbox, since all descendant functions are correctly
         * linked under the top-most funbox. But every visit to this case needs
         * to update funbox-&gt;level.
         *
         * Recall that funbox-&gt;level is the static level of the code containing
         * the definition or expression of the function and not the static level
         * of the function's body.
         */</comment>
        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_funbox</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>funbox</name>-&gt;<name>level</name></name> = <name><name>tc</name>-&gt;<name>staticLevel</name></name> + <name>funcLevel</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>++<name>funcLevel</name> == 1 &amp;&amp; <name>genexp</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>parent</name> <init>= <expr><name><name>tc</name>-&gt;<name>funbox</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>JSFunctionBox</name> **</type><name>funboxp</name> <init>= <expr>&amp;<name><name>tc</name>-&gt;<name>parent</name>-&gt;<name>functionList</name></name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr>*<name>funboxp</name> != <name>funbox</name></expr>)</condition>
                <expr_stmt><expr><name>funboxp</name> = &amp;<name>(*<name>funboxp</name>)-&gt;<name>siblings</name></name></expr>;</expr_stmt></while>
            <expr_stmt><expr>*<name>funboxp</name> = <name><name>funbox</name>-&gt;<name>siblings</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>funbox</name>-&gt;<name>parent</name></name> = <name>parent</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funbox</name>-&gt;<name>siblings</name></name> = <name><name>parent</name>-&gt;<name>kids</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>parent</name>-&gt;<name>kids</name></name> = <name>funbox</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funbox</name>-&gt;<name>level</name></name> = <name><name>tc</name>-&gt;<name>staticLevel</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
      }</block>

      </case><case>case <expr><name>PN_NAME</name></expr>:
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>maybeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_FUNC</name></expr>)</condition><then>
            <expr_stmt><expr>--<name>funcLevel</name></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>genexp</name> &amp;&amp; !<call><name>BumpStaticLevel</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> == <name>FREE_UPVAR_COOKIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_lexdef</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Adjust the definition's block id only if it is a placeholder not
             * to the left of the root node, and if pn is the last use visited
             * in the comprehension expression (to avoid adjusting the blockid
             * multiple times).
             *
             * Non-placeholder definitions within the comprehension expression
             * will be visited further below.
             */</comment>
            <if>if <condition>(<expr><call><name><name>dn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>dn</name>-&gt;<name>pn_pos</name></name> &gt;= <name><name>root</name>-&gt;<name>pn_pos</name></name> &amp;&amp; <name><name>dn</name>-&gt;<name>dn_uses</name></name> == <name>pn</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>genexp</name> &amp;&amp; !<call><name>BumpStaticLevel</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr>false</expr>;</return></then></if>
                <expr_stmt><expr><call><name>AdjustBlockId</name><argument_list>(<argument><expr><name>dn</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name> <init>= <expr><call><name>js_LexicalLookup</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>stmt</name> || <name>stmt</name> != <name><name>tc</name>-&gt;<name>topStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><name>genexp</name> &amp;&amp; <call><name>PN_OP</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call> != <name>JSOP_CALLEE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name><name>dn</name>-&gt;<name>pn_pos</name></name> &lt; <name><name>root</name>-&gt;<name>pn_pos</name></name> || <call><name><name>dn</name>-&gt;<name>isPlaceholder</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name><name>dn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                        <return>return <expr>false</expr>;</return></then></if>

                    <if>if <condition>(<expr><name><name>dn</name>-&gt;<name>pn_pos</name></name> &gt;= <name><name>root</name>-&gt;<name>pn_pos</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>tc</name>-&gt;<name>parent</name>-&gt;<name>lexdeps</name>.<name>remove</name></name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn2</name> <init>= <expr>(<name>JSDefinition</name> *)
                            <call><name>NewNameNode</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dn</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr>!<name>dn2</name></expr>)</condition><then>
                            <return>return <expr>false</expr>;</return></then></if>

                        <expr_stmt><expr><name><name>dn2</name>-&gt;<name>pn_type</name></name> = <name><name>dn</name>-&gt;<name>pn_type</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>dn2</name>-&gt;<name>pn_pos</name></name> = <name><name>root</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>dn2</name>-&gt;<name>pn_defn</name></name> = true</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>dn2</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_PLACEHOLDER</name></expr>;</expr_stmt>

                        <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnup</name> <init>= <expr>&amp;<name><name>dn</name>-&gt;<name>dn_uses</name></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnu</name></decl>;</decl_stmt>
                        <while>while <condition>(<expr>(<name>pnu</name> = *<name>pnup</name>) != <name>NULL</name> &amp;&amp; <name><name>pnu</name>-&gt;<name>pn_pos</name></name> &gt;= <name><name>root</name>-&gt;<name>pn_pos</name></name></expr>)</condition> <block>{
                            <expr_stmt><expr><name><name>pnu</name>-&gt;<name>pn_lexdef</name></name> = <name>dn2</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>dn2</name>-&gt;<name>pn_dflags</name></name> |= <name><name>pnu</name>-&gt;<name>pn_dflags</name></name> &amp; (<name>PND_ASSIGNED</name> | <name>PND_FUNARG</name>)</expr>;</expr_stmt>
                            <expr_stmt><expr><name>pnup</name> = &amp;<name><name>pnu</name>-&gt;<name>pn_link</name></name></expr>;</expr_stmt>
                        }</block></while>
                        <expr_stmt><expr><name><name>dn2</name>-&gt;<name>dn_uses</name></name> = <name><name>dn</name>-&gt;<name>dn_uses</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>dn</name>-&gt;<name>dn_uses</name></name> = *<name>pnup</name></expr>;</expr_stmt>
                        <expr_stmt><expr>*<name>pnup</name> = <name>NULL</name></expr>;</expr_stmt>

                        <expr_stmt><expr><name>dn</name> = <name>dn2</name></expr>;</expr_stmt>
                    }</block></else></if>

                    <expr_stmt><expr><call><name>ALE_SET_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if></else></if>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_pos</name></name> &gt;= <name><name>root</name>-&gt;<name>pn_pos</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>AdjustBlockId</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAMESET</name></expr>:
        <expr_stmt><expr><call><name>transplant</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case>}</block></switch>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Starting from a |for| keyword after the first array initialiser element or
 * an expression in an open parenthesis, parse the tail of the comprehension
 * or generator expression signified by this |for| keyword in context.
 *
 * Return null on failure, else return the top-most parse node for the array
 * comprehension or generator expression, with a unary node as the body of the
 * (possibly nested) for-loop, initialized by |type, op, kid|.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>ComprehensionTail</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>kid</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>blockid</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                  <param><decl><type><name>JSTokenType</name></type> <name>type</name> <init>= <expr><name>TOK_SEMI</name></expr></init></decl></param>, <name>JSOp</name> <name>op</name> = <name>JSOP_NOP</name>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>context</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenStream</name> *</type><name>ts</name> <init>= <expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uintN</name></type> <name>adjust</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>, **<decl><type ref="prev"/><name>pnp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name></type> <name>stmtInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BindData</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>type</name> == <name>TOK_SEMI</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Generator expression desugars to an immediately applied lambda that
         * yields the next value from a for-in loop (possibly nested, and with
         * optional if guard). Make pn be the TOK_LC body node.
         */</comment>
        <expr_stmt><expr><name>pn</name> = <call><name>PushLexicalScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>adjust</name> = <name><name>pn</name>-&gt;<name>pn_blockid</name></name> - <name>blockid</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> == <name>TOK_ARRAYPUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Make a parse-node and literal object representing the block scope of
         * this array comprehension. Our caller in PrimaryExpr, the TOK_LB case
         * aka the array initialiser case, has passed the blockid to claim for
         * the comprehension's block scope. We allocate that id or one above it
         * here, by calling js_PushLexicalScope.
         *
         * In the case of a comprehension expression that has nested blocks
         * (e.g., let expressions), we will allocate a higher blockid but then
         * slide all blocks "to the right" to make room for the comprehension's
         * block scope.
         */</comment>
        <expr_stmt><expr><name>adjust</name> = <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>PushLexicalScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>blockid</name> &lt;= <name><name>pn</name>-&gt;<name>pn_blockid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>blockid</name> &lt; <name><name>tc</name>-&gt;<name>blockidGen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>bodyid</name></name> &lt; <name>blockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <name><name>stmtInfo</name>.<name>blockid</name></name> = <name>blockid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>adjust</name> &lt; <name>blockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjust</name> = <name>blockid</name> - <name>adjust</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>pnp</name> = &amp;<name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CompExprTransplanter</name></type> <name>transplanter</name><argument_list>(<argument><expr><name>kid</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>type</name> == <name>TOK_SEMI</name></expr></argument>, <argument><expr><name>adjust</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>transplanter</name>.<name>transplant</name></name><argument_list>(<argument><expr><name>kid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>data</name>.<name>pn</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name>.<name>op</name></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name>.<name>binder</name></name> = <name>BindLet</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>data</name>.<name>let</name>.<name>overflow</name></name> = <name>JSMSG_ARRAY_INIT_TOO_BIG</name></expr>;</expr_stmt>

    <do>do <block>{
        <comment type="block">/*
         * FOR node is binary, left is loop control and right is body.  Use
         * index to count each block-local let-variable on the left-hand side
         * of the IN.
         */</comment>
        <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_ITER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_iflags</name></name> = <name>JSITER_ENUMERATE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>eachAtom</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_iflags</name></name> |= <name>JSITER_FOREACH</name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_LP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
          <case>case <expr><name>TOK_LB</name></expr>:
          </case><case>case <expr><name>TOK_LC</name></expr>:
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_DESTRUCTURING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_DESTRUCTURING</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

          </case><case>case <expr><name>TOK_NAME</name></expr>:
            <expr_stmt><expr><name>atom</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
             * JSOP_GETLOCAL here, because we don't yet know the block's depth
             * in the operand stack frame.  The code generator computes that,
             * and it tries to bind all names to slots, so we must let it do
             * the deed.
             */</comment>
            <expr_stmt><expr><name>pn3</name> = <call><name>NewBindingNode</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>

          </case><default>default:
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_NO_VARIABLE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          </default><case>case <expr><name>TOK_ERROR</name></expr>:
            <return>return <expr><name>NULL</name></expr>;</return>
        </case>}</block></switch>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_IN</name></expr></argument>, <argument><expr><name>JSMSG_IN_AFTER_FOR_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn4</name> <init>= <expr><call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>pn4</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_AFTER_FOR_CTRL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
          <case>case <expr><name>TOK_LB</name></expr>:
          </case><case>case <expr><name>TOK_LC</name></expr>:
            <if>if <condition>(<expr>!<call><name>CheckDestructuring</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <if>if <condition>(<expr><call><name>JSVERSION_NUMBER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> == <name>JSVERSION_1_7</name></expr>)</condition><then> <block>{
                <comment type="block">/* Destructuring requires [key, value] enumeration in JS1.7. */</comment>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> != <name>TOK_RB</name> || <name><name>pn3</name>-&gt;<name>pn_count</name></name> != 2</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_BAD_FOR_LEFTSIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_ENUMERATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!(<name><name>pn2</name>-&gt;<name>pn_iflags</name></name> &amp; <name>JSITER_FOREACH</name>)</expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_iflags</name></name> |= <name>JSITER_FOREACH</name> | <name>JSITER_KEYVALUE</name></expr>;</expr_stmt></then></if>
            }</block></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

          </case><case>case <expr><name>TOK_NAME</name></expr>:
            <expr_stmt><expr><name><name>data</name>.<name>pn</name></name> = <name>pn3</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>data</name>.<name>binder</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>

          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>

        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_IN</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>pn4</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr>*<name>pnp</name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pnp</name> = &amp;<name><name>pn2</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_FOR</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_IF</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_kid1</name></name> = <call><name>Condition</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_kid1</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr>*<name>pnp</name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pnp</name> = &amp;<name><name>pn2</name>-&gt;<name>pn_kid2</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_kid</name></name> = <name>kid</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pnp</name> = <name>pn2</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>type</name> == <name>TOK_ARRAYPUSH</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>PopStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>

<comment type="block">/*
 * Starting from a |for| keyword after an expression, parse the comprehension
 * tail completing this generator expression. Wrap the expression at kid in a
 * generator function that is immediately called to evaluate to the generator
 * iterator that is the value of this generator expression.
 *
 * Callers pass a blank unary node via pn, which GeneratorExpr fills in as the
 * yield expression, which ComprehensionTail in turn wraps in a TOK_SEMI-type
 * expression-statement node that constitutes the body of the |for| loop(s) in
 * the generator function.
 *
 * Note how unlike Python, we do not evaluate the expression to the right of
 * the first |in| in the chain of |for| heads. Instead, a generator expression
 * is merely sugar for a generator function expression and its application.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>GeneratorExpr</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>kid</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Initialize pn, connecting it to kid. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_UNARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_YIELD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_YIELD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name></name> = <name><name>kid</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>kid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_hidden</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>

    <comment type="block">/* Make a new node for the desugared generator function. */</comment>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>genfn</name> <init>= <expr><call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_FUNC</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>genfn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_type</name></name> = <name>TOK_FUNCTION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_LAMBDA</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>genfn</name>-&gt;<name>pn_body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_dflags</name></name> = <name>PND_FUNARG</name></expr>;</expr_stmt>

    <block>{
        <function_decl><type><name>JSTreeContext</name></type> <name>gentc</name><parameter_list>(<param><decl><type><name><name>tc</name>-&gt;<name>compiler</name></name></type></decl></param>)</parameter_list>;</function_decl>

        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><call><name>EnterFunction</name><argument_list>(<argument><expr><name>genfn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr>&amp;<name>gentc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>funbox</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/*
         * We assume conservatively that any deoptimization flag in tc-&gt;flags
         * besides TCF_FUN_PARAM_ARGUMENTS can come from the kid. So we
         * propagate these flags into genfn. For code simplicity we also do
         * not detect if the flags were only set in the kid and could be
         * removed from tc-&gt;flags.
         */</comment>
        <expr_stmt><expr><name><name>gentc</name>.<name>flags</name></name> |= <name>TCF_FUN_IS_GENERATOR</name> | <name>TCF_GENEXP_LAMBDA</name> |
                       (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; (<name>TCF_FUN_FLAGS</name> &amp; ~<name>TCF_FUN_PARAM_ARGUMENTS</name>))</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funbox</name>-&gt;<name>tcflags</name></name> |= <name><name>gentc</name>.<name>flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_funbox</name></name> = <name>funbox</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_blockid</name></name> = <name><name>gentc</name>.<name>bodyid</name></name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>body</name> <init>= <expr><call><name>ComprehensionTail</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>gentc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>body</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>genfn</name>-&gt;<name>pn_body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_body</name></name> = <name>body</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>body</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>kid</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>genfn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>body</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>compiler</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>LeaveFunction</name><argument_list>(<argument><expr><name>genfn</name></expr></argument>, <argument><expr>&amp;<name>gentc</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block>

    <comment type="block">/*
     * Our result is a call expression that invokes the anonymous generator
     * function object.
     */</comment>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>result</name> <init>= <expr><call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>pn_type</name></name> = <name>TOK_LP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>pn_op</name></name> = <name>JSOP_CALL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>genfn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>result</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>genfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>js_generator_str</name><index>[]</index></name> <init>= <expr>"generator"</expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATOR_EXPRS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATORS */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ArgumentList</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
             <param><decl><type><name>JSParseNode</name> *</type><name>listNode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>matched</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>matched</name> = <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_RP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>matched</name></expr>)</condition><then> <block>{
        <do>do <block>{
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>argNode</name> <init>= <expr><call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>argNode</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
            <if>if <condition>(<expr><name><name>argNode</name>-&gt;<name>pn_type</name></name> == <name>TOK_YIELD</name> &amp;&amp;
                <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_COMMA</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>argNode</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_GENERATOR_SYNTAX</name></expr></argument>,
                                            <argument><expr><name>js_yield_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
            <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_FOR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>argNode</name> = <call><name>GeneratorExpr</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>argNode</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>argNode</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><name><name>listNode</name>-&gt;<name>pn_count</name></name> &gt; 1 ||
                    <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_COMMA</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>argNode</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_BAD_GENERATOR_SYNTAX</name></expr></argument>,
                                                <argument><expr><name>js_generator_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name><name>listNode</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>argNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <if>if <condition>(<expr><call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> != <name>TOK_RP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_PAREN_AFTER_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Check for an immediately-applied (new'ed) lambda and clear PND_FUNARG. */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>CheckForImmediatelyAppliedLambda</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
        <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_FUNCTION</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_funbox</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>((<name>JSFunction</name> *) <name><name>funbox</name>-&gt;<name>object</name></name>)-&gt;<name>flags</name> &amp; <name>JSFUN_LAMBDA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!(<name><name>funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_FUN_USES_ARGUMENTS</name>)</expr>)</condition><then>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp;= ~<name>PND_FUNARG</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>MemberExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
           <param><decl><type><name>JSBool</name></type> <name>allowCallSyntax</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <comment type="block">/* Check for new expression first. */</comment>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_NEW</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>MemberExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>CheckForImmediatelyAppliedLambda</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NEW</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_LP</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>ArgumentList</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> &gt; <name>ARGC_LIMIT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSMSG_TOO_MANY_CON_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call>-&gt;<name><name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_ANYNAME</name> ||
            <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_AT</name> ||
            <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DBLCOLON</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>NewOrRecycledNode</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_UNARYOP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_XMLNAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> = <name>PN_UNARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_kid</name></name> = <name>pn</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <while>while <condition>(<expr>(<name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call>) &gt; <name>TOK_EOF</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_DOT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name> | <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~(<name>TSF_OPERAND</name> | <name>TSF_KEYWORD_IS_NAME</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>tt</name> = <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>pn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name> = <name><name>pn3</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><call><name>TOKEN_TYPE_IS_XML</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_LB</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_RP</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>group</name> <init>= <expr><name>pn3</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* Recycle the useless TOK_RP node. */</comment>
                    <expr_stmt><expr><name>pn3</name> = <name><name>group</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>group</name>-&gt;<name>pn_kid</name></name> = <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_FILTER</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_FILTER</name></expr>;</expr_stmt>

                    <comment type="block">/* A filtering predicate is like a with statement. */</comment>
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_NAME_AFTER_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></else></if></else></if>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> = <name>PN_BINARY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name> = <name>pn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name> = <name>pn3</name></expr>;</expr_stmt>
            }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_NAME</name></expr></argument>, <argument><expr><name>JSMSG_NAME_AFTER_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>pn</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_DBLDOT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name> | <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~(<name>TSF_OPERAND</name> | <name>TSF_KEYWORD_IS_NAME</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>tt</name> = <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> = <name>TOK_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_op</name></name> = <name>JSOP_QNAMEPART</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr>!<call><name>TOKEN_TYPE_IS_XML</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_NAME_AFTER_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if></else></if>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DESCENDANTS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name> = <name>pn</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name> = <name>pn3</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_LB</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>pn3</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RB</name></expr></argument>, <argument><expr><name>JSMSG_BRACKET_IN_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * Optimize o['p'] to o.p by rewriting pn2, but avoid rewriting
             * o['0'] to use JSOP_GETPROP, to keep fast indexing disjoint in
             * the interpreter from fast property access. However, if the
             * bracketed string is a uint32, we rewrite pn3 to be a number
             * instead of a string.
             */</comment>
            <do>do <block>{
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>jsuint</name></type> <name>index</name></decl>;</decl_stmt>

                    <if>if <condition>(<expr>!<call><name>js_IdIsIndex</name><argument_list>(<argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_DOT</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> = <name>PN_NAME</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>pn</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name> = <name><name>pn3</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> = <name>TOK_NUMBER</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DOUBLE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_dval</name></name> = <name>index</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name> = <name>pn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name> = <name>pn3</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr>0</expr>)</condition>;</do>
        }</block></then> <else>else <if>if <condition>(<expr><name>allowCallSyntax</name> &amp;&amp; <name>tt</name> == <name>TOK_LP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_CALL</name></expr>;</expr_stmt>

            <comment type="block">/* CheckForImmediatelyAppliedLambda skips useless TOK_RP nodes. */</comment>
            <expr_stmt><expr><name>pn</name> = <call><name>CheckForImmediatelyAppliedLambda</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NAME</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>evalAtom</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* Select JSOP_EVAL and flag tc as heavyweight. */</comment>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_EVAL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_GETPROP</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>applyAtom</name></name> ||
                    <name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>callAtom</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* Select JSOP_APPLY given foo.apply(...). */</comment>
                    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_APPLY</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if></else></if>

            <expr_stmt><expr><call><name><name>pn2</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<call><name>ArgumentList</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_count</name></name> &gt; <name>ARGC_LIMIT</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_TOO_MANY_FUN_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>pn</name></expr>;</return>
        }</block></else></if></else></if></else></if></else></if>

        <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>BracketedExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Always accept the 'in' operator in a parenthesized expression,
     * where it's unambiguous, even if we might be parsing the init of a
     * for statement.
     */</comment>
    <expr_stmt><expr><name>oldflags</name> = <name><name>tc</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name> | (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_FUN_FLAGS</name>)</expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>EndBracketedExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>BracketedExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RB</name></expr></argument>, <argument><expr><name>JSMSG_BRACKET_AFTER_ATTR_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
 *
 *      AttributeIdentifier:
 *              @ PropertySelector
 *              @ QualifiedIdentifier
 *              @ [ Expression ]
 *
 *      PropertySelector:
 *              Identifier
 *              *
 *
 *      QualifiedIdentifier:
 *              PropertySelector :: PropertySelector
 *              PropertySelector :: [ Expression ]
 *
 * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
 *
 *      AttributeIdentifier:
 *              @ QualifiedIdentifier
 *              @ [ Expression ]
 *
 *      PropertySelector:
 *              Identifier
 *              *
 *
 *      QualifiedIdentifier:
 *              PropertySelector :: PropertySelector
 *              PropertySelector :: [ Expression ]
 *              PropertySelector
 *
 * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
 * for that rule to result in a name node, but ECMA-357 extends the grammar
 * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
 *
 *      QualifiedIdentifier:
 *              PropertySelector QualifiedSuffix
 *
 *      QualifiedSuffix:
 *              :: PropertySelector
 *              :: [ Expression ]
 *              /nothing/
 *
 * And use this production instead of PrimaryExpression: QualifiedIdentifier:
 *
 *      PrimaryExpression:
 *              Identifier QualifiedSuffix
 *
 * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
 * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>PropertySelector</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_STAR</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_ANYNAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_ANYNAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>starAtom</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_QNAMEPART</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>QualifiedSuffix</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
                <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_DBLCOLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn2</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Left operand of :: must be evaluated if it is an identifier. */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_QNAMEPART</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_STAR</name> || <name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <comment type="block">/* Inline and specialize PropertySelector for JSOP_QNAMECONST. */</comment>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_QNAMECONST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name> = (<name>tt</name> == <name>TOK_STAR</name>)
                       ? <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>starAtom</name></name>
                       : <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name> = <name>pn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_cookie</name></name> = <name>FREE_UPVAR_COOKIE</name></expr>;</expr_stmt>
        <return>return <expr><name>pn2</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>tt</name> != <name>TOK_LB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pn3</name> = <call><name>EndBracketedExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_QNAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> = <name>PN_BINARY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn3</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name> = <name>pn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name> = <name>pn3</name></expr>;</expr_stmt>
    <return>return <expr><name>pn2</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>QualifiedIdentifier</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>PropertySelector</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_DBLCOLON</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Hack for bug 496316. Slowing down E4X won't make it go away, alas. */</comment>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <call><name>QualifiedSuffix</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>AttributeIdentifier</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_AT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_TOATTRNAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_STAR</name> || <name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn2</name> = <call><name>QualifiedIdentifier</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_LB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pn2</name> = <call><name>EndBracketedExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>
    <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Make a TOK_LC unary node whose pn_kid is an expression.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>inTag</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_LC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/*
     * Turn off XML tag mode, but don't restore it after parsing this braced
     * expression.  Instead, simply restore ts's old flags.  This is required
     * because XMLExpr is called both from within a tag, and from within text
     * contained in an element, but outside of any start, end, or point tag.
     */</comment>
    <expr_stmt><expr><name>oldflags</name> = <name><name>ts</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> = <name>oldflags</name> &amp; ~<name>TSF_XMLTAGMODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn2</name> = <call><name>Expr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RC</name></expr></argument>, <argument><expr><name>JSMSG_CURLY_IN_XML_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> = <name>oldflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>inTag</name> ? <name>JSOP_XMLTAGEXPR</name> : <name>JSOP_XMLELTEXPR</name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Make a terminal node for one of TOK_XMLNAME, TOK_XMLATTR, TOK_XMLSPACE,
 * TOK_XMLTEXT, TOK_XMLCDATA, TOK_XMLCOMMENT, or TOK_XMLPI.  When converting
 * parse tree to XML, we preserve a TOK_XMLSPACE node only if it's the sole
 * child of a container tag.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLAtomNode</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSToken</name> *</type><name>tp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>tp</name> = &amp;<call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name><name>tp</name>-&gt;<name>t_op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <name><name>tp</name>-&gt;<name>t_atom</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>tp</name>-&gt;<name>type</name></name> == <name>TOK_XMLPI</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom2</name></name> = <name><name>tp</name>-&gt;<name>t_atom2</name></name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Parse the productions:
 *
 *      XMLNameExpr:
 *              XMLName XMLNameExpr?
 *              { Expr } XMLNameExpr?
 *
 * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
 * a list of names and/or expressions, a single expression, or a single name.
 * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME; if PN_UNARY, pn_type
 * will be TOK_LC.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLNameExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <name>list</name> = <name>NULL</name></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tt</name> == <name>TOK_XMLNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLAtomNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></else></if>

        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>list</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLNAME</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>list</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_xflags</name></name> = <name>PNX_CANTFOLD</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <name>list</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block> while <condition>(<expr>(<name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call>) == <name>TOK_XMLNAME</name> || <name>tt</name> == <name>TOK_LC</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
 * at compile time into a JSXML tree.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FOLDABLE</name><parameter_list>(<param><type><name>pn</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>((pn)-&gt;pn_arity == PN_LIST                    \
                                 ? ((pn)-&gt;pn_xflags &amp; PNX_CANTFOLD) == 0      \
                                 : (pn)-&gt;pn_type != TOK_LC)</cpp:value></cpp:define>

<comment type="block">/*
 * Parse the productions:
 *
 *      XMLTagContent:
 *              XMLNameExpr
 *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
 *              XMLTagContent S XMLNameExpr S? = S? { Expr }
 *
 * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
 * produces a list of name and attribute values and/or braced expressions, a
 * single expression, or a single name.
 *
 * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME for the case where
 * XMLTagContent: XMLNameExpr.  If pn_type is not TOK_XMLNAME but pn_arity is
 * PN_LIST, pn_type will be tagtype.  If PN_UNARY, pn_type will be TOK_LC and
 * we parsed exactly one expression.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLTagContent</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
              <param><decl><type><name>JSTokenType</name></type> <name>tagtype</name></decl></param>, <param><decl><type><name>JSAtom</name> **</type><name>namep</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn</name> = <call><name>XMLNameExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>namep</name> = (<name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NULLARY</name>) ? <name><name>pn</name>-&gt;<name>pn_atom</name></name> : <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_XMLSPACE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> != <name>TOK_XMLNAME</name> &amp;&amp; <name>tt</name> != <name>TOK_LC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <expr_stmt><expr><name>pn2</name> = <call><name>XMLNameExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>list</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_type</name></name> = <name>tagtype</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>list</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>list</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>XML_FOLDABLE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_XMLSPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_ASSIGN</name></expr></argument>, <argument><expr><name>JSMSG_NO_ASSIGN_IN_XML_ATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_XMLSPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLATTR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLAtomNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_XML_ATTR_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></else></if></else></if>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_CHECK_FOR_ERROR_AND_EOF</name><parameter_list>(<param><type><name>tt</name></type></param>,<param><type><name>result</name></type></param>)</parameter_list></cpp:macro>                                \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        if ((tt) &lt;= TOK_EOF) {                                                \
            if ((tt) == TOK_EOF) {                                            \
                js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,     \
                                            JSMSG_END_OF_XML_SOURCE);         \
            }                                                                 \
            return result;                                                    \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLElementOrList</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                 <param><decl><type><name>JSBool</name></type> <name>allowList</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Consume XML element tag content, including the TOK_XMLETAGO (&lt;/) sequence
 * that opens the end tag for the container.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>XMLElementContent</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
                  <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>textAtom</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_XMLTAGMODE</name></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_XMLTEXTMODE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_XMLTEXTMODE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XML_CHECK_FOR_ERROR_AND_EOF</name><argument_list>(<argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tt</name> == <name>TOK_XMLSPACE</name> || <name>tt</name> == <name>TOK_XMLTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>textAtom</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>textAtom</name></expr>)</condition><then> <block>{
            <comment type="block">/* Non-zero-length XML text scanned. */</comment>
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLAtomNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>XML_CHECK_FOR_ERROR_AND_EOF</name><argument_list>(<argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLETAGO</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <if>if <condition>(<expr><name>tt</name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLSTAGO</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLElementOrList</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_xflags</name></name> &amp;= ~<name>PNX_XMLROOT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name><name>pn2</name>-&gt;<name>pn_xflags</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tt</name> == <name>TOK_XMLCDATA</name> || <name>tt</name> == <name>TOK_XMLCOMMENT</name> ||
                      <name>tt</name> == <name>TOK_XMLPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLAtomNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_XMLETAGO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_XMLTAGMODE</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return a PN_LIST node containing an XML or XMLList Initialiser.
 */</comment>
<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLElementOrList</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                 <param><decl><type><name>JSBool</name></type> <name>allowList</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>startAtom</name></decl>, *<decl><type ref="prev"/><name>endAtom</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_XMLSTAGO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_XMLTAGMODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLNAME</name> || <name>tt</name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * XMLElement.  Append the tag and its contents, if any, to pn.
         */</comment>
        <expr_stmt><expr><name>pn2</name> = <call><name>XMLTagContent</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>TOK_XMLSTAGO</name></expr></argument>, <argument><expr>&amp;<name>startAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_XMLSPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLPTAGC</name></expr>)</condition><then> <block>{
            <comment type="block">/* Point tag (/&gt;): recycle pn if pn2 is a list of tag contents. */</comment>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLSTAGO</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLNAME</name> ||
                          <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>XML_FOLDABLE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if>
            }</block></else></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLPTAGC</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_XMLROOT</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* We had better have a tag-close (&gt;) at this point. */</comment>
            <if>if <condition>(<expr><name>tt</name> != <name>TOK_XMLTAGC</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_XML_TAG_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>

            <comment type="block">/* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */</comment>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_XMLSTAGO</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>XML_FOLDABLE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>pn2</name> = <name>pn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then></if>

            <comment type="block">/* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */</comment>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLELEM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>XML_FOLDABLE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_XMLROOT</name></expr>;</expr_stmt>

            <comment type="block">/* Get element contents and delimiting end-tag-open sequence. */</comment>
            <if>if <condition>(<expr>!<call><name>XMLElementContent</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>XML_CHECK_FOR_ERROR_AND_EOF</name><argument_list>(<argument><expr><name>tt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> != <name>TOK_XMLNAME</name> &amp;&amp; <name>tt</name> != <name>TOK_LC</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_XML_TAG_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Parse end tag; check mismatch at compile-time if we can. */</comment>
            <expr_stmt><expr><name>pn2</name> = <call><name>XMLTagContent</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>TOK_XMLETAGO</name></expr></argument>, <argument><expr>&amp;<name>endAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLETAGO</name></expr>)</condition><then> <block>{
                <comment type="block">/* Oops, end tag has attributes! */</comment>
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_XML_TAG_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>endAtom</name> &amp;&amp; <name>startAtom</name> &amp;&amp; <name>endAtom</name> != <name>startAtom</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>startAtom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/* End vs. start tag name mismatch: point to the tag name. */</comment>
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>,
                                            <argument><expr><name>JSREPORT_UC</name> | <name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_XML_TAG_NAME_MISMATCH</name></expr></argument>,
                                            <argument><expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Make a TOK_XMLETAGO list with pn2 as its single child. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLNAME</name> || <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>list</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLETAGO</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>list</name>-&gt;<name>initList</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>XML_FOLDABLE</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>list</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_CANTFOLD</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_XMLSPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_XMLTAGC</name></expr></argument>, <argument><expr><name>JSMSG_BAD_XML_TAG_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Set pn_op now that pn has been updated to its final value. */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_TOXML</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>allowList</name> &amp;&amp; <name>tt</name> == <name>TOK_XMLTAGC</name></expr>)</condition><then> <block>{
        <comment type="block">/* XMLList Initialiser. */</comment>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLLIST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_TOXMLLIST</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_XMLROOT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>XMLElementContent</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_XMLTAGC</name></expr></argument>, <argument><expr><name>JSMSG_BAD_XML_LIST_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_XML_NAME_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></else></if></else></if>

    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_XMLTAGMODE</name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>XMLElementOrListRoot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                     <param><decl><type><name>JSBool</name></type> <name>allowList</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>oldopts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Force XML support to be enabled so that comments and CDATA literals
     * are recognized, instead of &lt;! followed by -- starting an HTML comment
     * to end of line (used in script tags to hide content from old browsers
     * that don't recognize &lt;script&gt;).
     */</comment>
    <expr_stmt><expr><name>oldopts</name> = <call><name>JS_SetOptions</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>options</name></name> | <name>JSOPTION_XML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn</name> = <call><name>XMLElementOrList</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_SetOptions</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>oldopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><name>JSParseNode</name> *</type>
<name><name>JSCompiler</name>::<name>parseXMLText</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>chain</name></decl></param>, <param><decl><type><name>bool</name></type> <name>allowList</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Push a compiler frame if we have no frames, or if the top frame is a
     * lightweight function activation, or if its scope chain doesn't match
     * the one passed to us.
     */</comment>
    <function_decl><type><name>JSTreeContext</name></type> <name>tc</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name><name>tc</name>.<name>scopeChain</name></name> = <name>chain</name></expr>;</expr_stmt>

    <comment type="block">/* Set XML-only mode to turn off special treatment of {expr} in XML. */</comment>
    <expr_stmt><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>-&gt;<name>flags</name> |= <name>TSF_OPERAND</name> | <name>TSF_XMLONLYMODE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name> <init>= <expr><call><name>js_GetToken</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>-&gt;<name>flags</name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>tt</name> != <name>TOK_XMLSTAGO</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_BAD_XML_MARKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>pn</name> = <call><name>XMLElementOrListRoot</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>tc</name></expr></argument>, <argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>TS</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>-&gt;<name>flags</name> &amp;= ~<name>TSF_XMLONLYMODE</name></expr>;</expr_stmt>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XMLSUPPORT */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
<comment type="block">/*
 * Check whether blockid is an active scoping statement in tc. This code is
 * necessary to qualify tc-&gt;decls.lookup() hits in PrimaryExpr's TOK_NAME case
 * (below) where the hits come from Scheme-ish let bindings in for loop heads
 * and let blocks and expressions (not let declarations).
 *
 * Unlike let declarations ("let as the new var"), which is a kind of letrec
 * due to hoisting, let in a for loop head, let block, or let expression acts
 * like Scheme's let: initializers are evaluated without the new let bindings
 * being in scope.
 *
 * Name binding analysis is eager with fixups, rather than multi-pass, and let
 * bindings push on the front of the tc-&gt;decls JSAtomList (either the singular
 * list or on a hash chain -- see JSAtomList::AddHow) in order to shadow outer
 * scope bindings of the same name.
 *
 * This simplifies binding lookup code at the price of a linear search here,
 * but only if code uses let (var predominates), and even then this function's
 * loop iterates more than once only in crazy cases.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>BlockIdInScope</name><parameter_list>(<param><decl><type><name>uintN</name></type> <name>blockid</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>blockid</name> &gt; <call><name><name>tc</name>-&gt;<name>blockid</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <for>for (<init><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name> <init>= <expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr></init></decl>;</init> <condition><expr><name>stmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>downScope</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>blockid</name></name> == <name>blockid</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
    }</block></for>
    <return>return <expr>false</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>PrimaryExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
            <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>afterDot</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
    <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>tt</name> = <call><name>CheckGetterOrSetter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_FUNCTION</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_DBLCOLON</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> = <name>TOK_FUNCTION</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <call><name>QualifiedSuffix</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>pn</name> = <call><name>FunctionExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_LB</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>matched</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsuint</name></type> <name>index</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_RB</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NEWINIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name> = <name><name>tc</name>-&gt;<name>blockidGen</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>matched</name> = <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_RB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>matched</name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name>index</name> == <name>ARRAY_INIT_LIMIT</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_ARRAY_INIT_TOO_BIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>

                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tt</name> = <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>tt</name> == <name>TOK_RB</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_ENDCOMMA</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>

                <if>if <condition>(<expr><name>tt</name> == <name>TOK_COMMA</name></expr>)</condition><then> <block>{
                    <comment type="block">/* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */</comment>
                    <expr_stmt><expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pn2</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_HOLEY</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>pn2</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>tt</name> != <name>TOK_COMMA</name></expr>)</condition><then> <block>{
                    <comment type="block">/* If we didn't already match TOK_COMMA in above case. */</comment>
                    <if>if <condition>(<expr>!<call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <break>break;</break></then></if>
                }</block></then></if>
            }</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
            <comment type="block">/*
             * At this point, (index == 0 &amp;&amp; pn-&gt;pn_count != 0) implies one
             * element initialiser was parsed.
             *
             * An array comprehension of the form:
             *
             *   [i * j for (i in o) for (j in p) if (i != j)]
             *
             * translates to roughly the following let expression:
             *
             *   let (array = new Array, i, j) {
             *     for (i in o) let {
             *       for (j in p)
             *         if (i != j)
             *           array.push(i * j)
             *     }
             *     array
             *   }
             *
             * where array is a nameless block-local variable.  The "roughly"
             * means that an implementation may optimize away the array.push.
             * An array comprehension opens exactly one block scope, no matter
             * how many for heads it contains.
             *
             * Each let () {...} or for (let ...) ... compiles to:
             *
             *   JSOP_ENTERBLOCK &lt;o&gt; ... JSOP_LEAVEBLOCK &lt;n&gt;
             *
             * where &lt;o&gt; is a literal object representing the block scope,
             * with &lt;n&gt; properties, naming each var declared in the block.
             *
             * Each var declaration in a let-block binds a name in &lt;o&gt; at
             * compile time, and allocates a slot on the operand stack at
             * runtime via JSOP_ENTERBLOCK.  A block-local var is accessed
             * by the JSOP_GETLOCAL and JSOP_SETLOCAL ops, and iterated with
             * JSOP_FORLOCAL.  These ops all have an immediate operand, the
             * local slot's stack index from fp-&gt;spbase.
             *
             * The array comprehension iteration step, array.push(i * j) in
             * the example above, is done by &lt;i * j&gt;; JSOP_ARRAYCOMP &lt;array&gt;,
             * where &lt;array&gt; is the index of array's stack slot.
             */</comment>
            <if>if <condition>(<expr><name>index</name> == 0 &amp;&amp;
                <name><name>pn</name>-&gt;<name>pn_count</name></name> != 0 &amp;&amp;
                <call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_FOR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnexp</name></decl>, *<decl><type ref="prev"/><name>pntop</name></decl>;</decl_stmt>

                <comment type="block">/* Relabel pn as an array comprehension node. */</comment>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_ARRAYCOMP</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Remove the comprehension expression from pn's linked list
                 * and save it via pnexp.  We'll re-install it underneath the
                 * ARRAYPUSH node after we parse the rest of the comprehension.
                 */</comment>
                <expr_stmt><expr><name>pnexp</name> = <call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1 || <name><name>pn</name>-&gt;<name>pn_count</name></name> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_tail</name></name> = (--<name><name>pn</name>-&gt;<name>pn_count</name></name> == 1)
                              ? &amp;<name><name>pn</name>-&gt;<name>pn_head</name>-&gt;<name>pn_next</name></name>
                              : &amp;<name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name><name>pn</name>-&gt;<name>pn_tail</name></name> = <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>pntop</name> = <call><name>ComprehensionTail</name><argument_list>(<argument><expr><name>pnexp</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_blockid</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>,
                                          <argument><expr><name>TOK_ARRAYPUSH</name></expr></argument>, <argument><expr><name>JSOP_ARRAYPUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pntop</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pntop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATORS */</comment>

            <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RB</name></expr></argument>, <argument><expr><name>JSMSG_BRACKET_AFTER_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>TOK_LC</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>afterComma</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pnval</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_RC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NEWINIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>afterComma</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>tt</name></expr>)</condition> <block>{
              <case>case <expr><name>TOK_NUMBER</name></expr>:
                <expr_stmt><expr><name>pn3</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>pn3</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_dval</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_dval</name></expr>;</expr_stmt></then></if>
                <break>break;</break>
              </case><case>case <expr><name>TOK_NAME</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
                <block>{
                    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>atom</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>getAtom</name></name></expr>)</condition><then>
                        <expr_stmt><expr><name>op</name> = <name>JSOP_GETTER</name></expr>;</expr_stmt></then>
                    <else>else <if>if <condition>(<expr><name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>setAtom</name></name></expr>)</condition><then>
                        <expr_stmt><expr><name>op</name> = <name>JSOP_SETTER</name></expr>;</expr_stmt></then>
                    <else>else
                        <goto>goto <name>property_name</name>;</goto></else></if></else></if>

                    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_KEYWORD_IS_NAME</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>tt</name> != <name>TOK_NAME</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>property_name</name>;</goto>
                    }</block></then></if>
                    <expr_stmt><expr><name>pn3</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>

                    <comment type="block">/* We have to fake a 'function' token here. */</comment>
                    <expr_stmt><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> = <name>TOK_FUNCTION</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pn2</name> = <call><name>FunctionExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pn2</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_COLON</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>skip</name>;</goto>
                }</block>
              <label><name>property_name</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              </case><case>case <expr><name>TOK_STRING</name></expr>:
                <expr_stmt><expr><name>pn3</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>pn3</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_atom</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt></then></if>
                <break>break;</break>
              </case><case>case <expr><name>TOK_RC</name></expr>:
                <if>if <condition>(<expr><name>afterComma</name> &amp;&amp;
                    !<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                 <argument><expr><name>JSREPORT_WARNING</name> |
                                                 <name>JSREPORT_STRICT</name></expr></argument>,
                                                 <argument><expr><name>JSMSG_TRAILING_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <goto>goto <name>end_obj_init</name>;</goto>
              </case><default>default:
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_PROP_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </default>}</block></switch>

            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>tt</name> = <call><name>CheckGetterOrSetter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>tt</name> == <name>TOK_ERROR</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if>if <condition>(<expr><name>tt</name> != <name>TOK_COLON</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
                <if>if <condition>(<expr><name>tt</name> != <name>TOK_COMMA</name> &amp;&amp; <name>tt</name> != <name>TOK_RC</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_COLON_AFTER_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
                }</block></then></if>

                <comment type="block">/*
                 * Support, e.g., |var {x, y} = o| as destructuring shorthand
                 * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
                 */</comment>
                <expr_stmt><expr><call><name>js_UngetToken</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> |= <name>PNX_DESTRUCT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pnval</name> = <name>pn3</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>pnval</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pnval</name>-&gt;<name>pn_arity</name></name> = <name>PN_NAME</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>InitNameNodeCommon</name><argument_list>(<argument><expr><name>pnval</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>op</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pnval</name> = <call><name>AssignExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><name>pn2</name> = <call><name>NewBinary</name><argument_list>(<argument><expr><name>TOK_COLON</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>pnval</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
          <label><name>skip</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>append</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_RC</name></expr>)</condition><then>
                <goto>goto <name>end_obj_init</name>;</goto></then></if>
            <if>if <condition>(<expr><name>tt</name> != <name>TOK_COMMA</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_CURLY_AFTER_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>afterComma</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        }</block></for>

      <label><name>end_obj_init</name>:</label>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <return>return <expr><name>pn</name></expr>;</return>
      }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_LET</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>LetBlock</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_DEFSHARP</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_num</name></name> = (<name>jsint</name>) <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_dval</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> |= <name>TSF_OPERAND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tt</name> = <call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ts</name>-&gt;<name>flags</name></name> &amp;= ~<name>TSF_OPERAND</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_USESHARP</name> || <name>tt</name> == <name>TOK_DEFSHARP</name> ||
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
            <name>tt</name> == <name>TOK_STAR</name> || <name>tt</name> == <name>TOK_AT</name> ||
            <name>tt</name> == <name>TOK_XMLSTAGO</name> <comment type="block">/* XXXbe could be sharp? */</comment> ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <name>tt</name> == <name>TOK_STRING</name> || <name>tt</name> == <name>TOK_NUMBER</name> || <name>tt</name> == <name>TOK_PRIMARY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_SHARP_VAR_DEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <call><name>PrimaryExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_HAS_SHARPS</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_USESHARP</name></expr>:
        <comment type="block">/* Check for forward/dangling references at runtime, to allow eval. */</comment>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_num</name></name> = (<name>jsint</name>) <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_dval</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_HAS_SHARPS</name></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SHARP_VARS */</comment>

      </case><case>case <expr><name>TOK_LP</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>genexp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn2</name> = <call><name>ParenExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>genexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>genexp</name></expr>)</condition><then>
            <return>return <expr><name>pn2</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MUST_MATCH_TOKEN</name><argument_list>(<argument><expr><name>TOK_RP</name></expr></argument>, <argument><expr><name>JSMSG_PAREN_IN_PAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check if parentheses were unnecessary. */</comment>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name> ||
            (<name><name>js_CodeSpec</name><index>[<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name></expr>]</index></name>.<name>prec</name> &gt;= <name><name>js_CodeSpec</name><index>[<expr><name>JSOP_GETPROP</name></expr>]</index></name>.<name>prec</name> &amp;&amp;
             !<name>afterDot</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name>pn2</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_RP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_STAR</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>QualifiedIdentifier</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_AT</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>AttributeIdentifier</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_XMLSTAGO</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>XMLElementOrListRoot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

      </case><case>case <expr><name>TOK_STRING</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
        <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_XMLCDATA</name></expr>:
      </case><case>case <expr><name>TOK_XMLCOMMENT</name></expr>:
      </case><case>case <expr><name>TOK_XMLPI</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLPI</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom2</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom2</name></expr>;</expr_stmt></then>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt></else></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_NAME</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewNameNode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_atom</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name> == <name>JSOP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_NAME</name></expr>;</expr_stmt>

        <if>if <condition>(<expr>(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; (<name>TCF_IN_FUNCTION</name> | <name>TCF_FUN_PARAM_ARGUMENTS</name>)) == <name>TCF_IN_FUNCTION</name> &amp;&amp;
            <name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Flag arguments usage so we can avoid unsafe optimizations such
             * as formal parameter assignment analysis (because of the hated
             * feature whereby arguments alias formals). We do this even for
             * a reference of the form foo.arguments, which ancient code may
             * still use instead of arguments (more hate).
             */</comment>
            <expr_stmt><expr><call><name>NoteArgumentsUse</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Bind early to JSOP_ARGUMENTS to relieve later code from having
             * to do this work (new rule for the emitter to count on).
             */</comment>
            <if>if <condition>(<expr>!<name>afterDot</name> &amp;&amp; !(<name><name>ts</name>-&gt;<name>flags</name></name> &amp; <name>TSF_DESTRUCTURING</name>) &amp;&amp; !<call><name><name>tc</name>-&gt;<name>inStatement</name></name><argument_list>(<argument><expr><name>STMT_WITH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_ARGUMENTS</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_BOUND</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <if>if <condition>(<expr>(!<name>afterDot</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
                    || <call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> == <name>TOK_DBLCOLON</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   ) &amp;&amp; !(<name><name>ts</name>-&gt;<name>flags</name></name> &amp; <name>TSF_DESTRUCTURING</name>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name> <init>= <expr><call><name>js_LexicalLookup</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>stmt</name> || <name><name>stmt</name>-&gt;<name>type</name></name> != <name>STMT_WITH</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>dn</name></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name> <init>= <expr><call><name><name>tc</name>-&gt;<name>decls</name>.<name>lookup</name></name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>dn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                    <comment type="block">/*
                     * Skip out-of-scope let bindings along an ALE list or hash
                     * chain. These can happen due to |let (x = x) x| block and
                     * expression bindings, where the x on the right of = comes
                     * from an outer scope. See bug 496532.
                     */</comment>
                    <while>while <condition>(<expr><call><name><name>dn</name>-&gt;<name>isLet</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>BlockIdInScope</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_blockid</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                        <do>do <block>{
                            <expr_stmt><expr><name>ale</name> = <call><name>ALE_NEXT</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block> while <condition>(<expr><name>ale</name> &amp;&amp; <call><name>ALE_ATOM</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call> != <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>)</condition>;</do>
                        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                            <break>break;</break></then></if>
                        <expr_stmt><expr><name>dn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                }</block></then></if>

                <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>dn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>ale</name> = <call><name><name>tc</name>-&gt;<name>lexdeps</name>.<name>lookup</name></name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>dn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <comment type="block">/*
                         * No definition before this use in any lexical scope.
                         * Add a mapping in tc-&gt;lexdeps from pn-&gt;pn_atom to a
                         * new node for the forward-referenced definition. This
                         * placeholder definition node will be adopted when we
                         * parse the real defining declaration form, or left as
                         * a free variable definition if we never see the real
                         * definition.
                         */</comment>
                        <expr_stmt><expr><name>ale</name> = <call><name>MakePlaceholder</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                            <return>return <expr><name>NULL</name></expr>;</return></then></if>
                        <expr_stmt><expr><name>dn</name> = <call><name>ALE_DEFN</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * In case this is a forward reference to a function,
                         * we pessimistically set PND_FUNARG if the next token
                         * is not a left parenthesis.
                         *
                         * If the definition eventually parsed into dn is not a
                         * function, this flag won't hurt, and if we do parse a
                         * function with pn's name, then the PND_FUNARG flag is
                         * necessary for safe cx-&gt;display-based optimization of
                         * the closure's static link.
                         */</comment>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> != <name>TOK_LP</name></expr>)</condition><then>
                            <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_FUNARG</name></expr>;</expr_stmt></then></if>
                    }</block></else></if>
                }</block></else></if>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>dn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LinkUseToDef</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>dn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Here we handle the backward function reference case. */</comment>
                <if>if <condition>(<expr><call><name>js_PeekToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> != <name>TOK_LP</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>dn</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_FUNARG</name></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dflags</name></name> |= (<name><name>dn</name>-&gt;<name>pn_dflags</name></name> &amp; <name>PND_FUNARG</name>)</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_DBLCOLON</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>afterDot</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Here PrimaryExpr is called after . or .. followed by a name
                 * followed by ::. This is the only case where a keyword after
                 * . or .. is not treated as a property name.
                 */</comment>
                <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tt</name> = <call><name>js_CheckKeyword</name><argument_list>(<argument><expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>tt</name> == <name>TOK_FUNCTION</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_FUNCTION</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> != <name>TOK_EOF</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                <argument><expr><name>JSMSG_KEYWORD_NOT_NS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if></else></if>
            }</block></then></if>
            <expr_stmt><expr><name>pn</name> = <call><name>QualifiedSuffix</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

      </case><case>case <expr><name>TOK_REGEXP</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/* Token stream ensures that tokenbuf is NUL-terminated. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name><name>ts</name>-&gt;<name>tokenbuf</name>.<name>ptr</name></name> == (<name>jschar</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>obj</name> = <call><name>js_NewRegExpObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>,
                                 <argument><expr><name><name>ts</name>-&gt;<name>tokenbuf</name>.<name>base</name></name></expr></argument>,
                                 <argument><expr><name><name>ts</name>-&gt;<name>tokenbuf</name>.<name>ptr</name></name> - <name><name>ts</name>-&gt;<name>tokenbuf</name>.<name>base</name></name></expr></argument>,
                                 <argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_reflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_COMPILE_N_GO</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>STOBJ_CLEAR_PARENT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>STOBJ_CLEAR_PROTO</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_objbox</name></name> = <call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newObjectBox</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_objbox</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_REGEXP</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_NUMBER</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DOUBLE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_dval</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_PRIMARY</name></expr>:
        <expr_stmt><expr><name>pn</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>t_op</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_ERROR</name></expr>:
        <comment type="block">/* The scanner or one of its subroutines reported the error. */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>

      </case><default>default:
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_SYNTAX_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </default>}</block></switch>
    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSParseNode</name> *</type>
<name>ParenExpr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
          <param><decl><type><name>JSParseNode</name> *</type><name>pn1</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>genexp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenPtr</name></type> <name>begin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name>type</name> == <name>TOK_LP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>begin</name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>begin</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>genexp</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>genexp</name> = <name>JS_FALSE</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pn</name> = <call><name>BracketedExpr</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
    <if>if <condition>(<expr><call><name>js_MatchToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>TOK_FOR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_YIELD</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_GENERATOR_SYNTAX</name></expr></argument>,
                                        <argument><expr><name>js_yield_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_COMMA</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><call><name><name>pn</name>-&gt;<name>last</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_GENERATOR_SYNTAX</name></expr></argument>,
                                        <argument><expr><name>js_generator_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn1</name> = <call><name>NewParseNode</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn1</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>pn</name> = <call><name>GeneratorExpr</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name></name> = <name>begin</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>genexp</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_GetToken</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call> != <name>TOK_RP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_GENERATOR_SYNTAX</name></expr></argument>,
                                            <argument><expr><name>js_generator_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name></name> = <call><name>CURRENT_TOKEN</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call>.<name><name>pos</name>.<name>end</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>genexp</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATOR_EXPRS */</comment>

    <return>return <expr><name>pn</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Fold from one constant type to another.
 * XXX handles only strings and numbers for now
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>FoldType</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTokenType</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> != <name>type</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_NUMBER</name></expr>:
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name>JS_ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_KEY</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name> = <name>d</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_NUMBER</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DOUBLE</name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>

          </case><case>case <expr><name>TOK_STRING</name></expr>:
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>js_NumberToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_STRING</name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>

          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Fold two numeric constants.  Beware that pn1 and pn2 are recycled, unless
 * one of them aliases pn, so you can't safely fetch pn2-&gt;pn_next, e.g., after
 * a successful call to this function.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>FoldBinaryNumeric</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn1</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl></param>,
                  <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>, <decl><type ref="prev"/><name>d2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = <name><name>pn1</name>-&gt;<name>pn_dval</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>d2</name> = <name><name>pn2</name>-&gt;<name>pn_dval</name></name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>JSOP_LSH</name></expr>:
      </case><case>case <expr><name>JSOP_RSH</name></expr>:
        <expr_stmt><expr><name>i</name> = <call><name>js_DoubleToECMAInt32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> = <call><name>js_DoubleToECMAInt32</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> &amp;= 31</expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> = (<name>op</name> == <name>JSOP_LSH</name>) ? <name>i</name> &lt;&lt; <name>j</name> : <name>i</name> &gt;&gt; <name>j</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_URSH</name></expr>:
        <expr_stmt><expr><name>j</name> = <call><name>js_DoubleToECMAInt32</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> &amp;= 31</expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> = <call><name>js_DoubleToECMAUint32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> &gt;&gt; <name>j</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_ADD</name></expr>:
        <expr_stmt><expr><name>d</name> += <name>d2</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_SUB</name></expr>:
        <expr_stmt><expr><name>d</name> -= <name>d2</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_MUL</name></expr>:
        <expr_stmt><expr><name>d</name> *= <name>d2</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_DIV</name></expr>:
        <if>if <condition>(<expr><name>d2</name> == 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <comment type="block">/* XXX MSVC miscompiles such that (NaN == 0) */</comment>
            <if>if <condition>(<expr><call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>d</name> = *<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>jsNaN</name></name></expr>;</expr_stmt></then>
            <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><name>d</name> == 0 || <call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>d</name> = *<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>jsNaN</name></name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr>(<call><name>JSDOUBLE_HI32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> ^ <call><name>JSDOUBLE_HI32</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call>) &gt;&gt; 31</expr>)</condition><then>
                <expr_stmt><expr><name>d</name> = *<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>jsNegativeInfinity</name></name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>d</name> = *<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>jsPositiveInfinity</name></name></expr>;</expr_stmt></else></if></else></if></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>d</name> /= <name>d2</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_MOD</name></expr>:
        <if>if <condition>(<expr><name>d2</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>d</name> = *<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>jsNaN</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>d</name> = <call><name>js_fmod</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>

    <comment type="block">/* Take care to allow pn1 or pn2 to alias pn. */</comment>
    <if>if <condition>(<expr><name>pn1</name> != <name>pn</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>pn2</name> != <name>pn</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_NUMBER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DOUBLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name> = <name>d</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>FoldXMLConstants</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>tt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnp</name></decl>, *<decl><type ref="prev"/><name>pn1</name></decl>, *<decl><type ref="prev"/><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>accum</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTempValueRooter</name></type> <name>tvr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tt</name> = <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pnp</name> = &amp;<name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pn1</name> = *<name>pnp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>accum</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name><name>pn</name>-&gt;<name>pn_xflags</name></name> &amp; <name>PNX_CANTFOLD</name>) == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLETAGO</name></expr>)</condition><then>
            <expr_stmt><expr><name>accum</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>etagoAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLSTAGO</name> || <name>tt</name> == <name>TOK_XMLPTAGC</name></expr>)</condition><then>
            <expr_stmt><expr><name>accum</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>stagoAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>

    <comment type="block">/*
     * GC Rooting here is tricky: for most of the loop, |accum| is safe via
     * the newborn string root. However, when |pn2-&gt;pn_type| is TOK_XMLCDATA,
     * TOK_XMLCOMMENT, or TOK_XMLPI it is knocked out of the newborn root.
     * Therefore, we have to add additonal protection from GC nesting under
     * js_ConcatStrings.
     */</comment>
    <for>for (<init><expr><name>pn2</name> = <name>pn1</name></expr>, <expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
        <comment type="block">/* The parser already rejected end-tags with attributes. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tt</name> != <name>TOK_XMLETAGO</name> || <name>i</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_XMLATTR</name></expr>:
            <if>if <condition>(<expr>!<name>accum</name></expr>)</condition><then>
                <goto>goto <name>cantfold</name>;</goto></then></if>
            <comment type="block">/* FALL THROUGH */</comment>
          </case><case>case <expr><name>TOK_XMLNAME</name></expr>:
          </case><case>case <expr><name>TOK_XMLSPACE</name></expr>:
          </case><case>case <expr><name>TOK_XMLTEXT</name></expr>:
          </case><case>case <expr><name>TOK_STRING</name></expr>:
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then>
                <goto>goto <name>cantfold</name>;</goto></then></if>
            <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>TOK_XMLCDATA</name></expr>:
            <expr_stmt><expr><name>str</name> = <call><name>js_MakeXMLCDATAString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>TOK_XMLCOMMENT</name></expr>:
            <expr_stmt><expr><name>str</name> = <call><name>js_MakeXMLCommentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>TOK_XMLPI</name></expr>:
            <expr_stmt><expr><name>str</name> = <call><name>js_MakeXMLPIString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          <label><name>cantfold</name>:</label>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pnp</name> == <name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>tt</name> == <name>TOK_XMLSTAGO</name> || <name>tt</name> == <name>TOK_XMLPTAGC</name>) &amp;&amp;
                (<name>i</name> &amp; 1) ^ (<name>j</name> &amp; 1)</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendanXXX</name></cpp:ifdef>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"1: %d, %d =&gt; "</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>accum</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>js_FileEscapedString</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"NULL"</expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then> <else>else <if>if <condition>(<expr><name>accum</name> &amp;&amp; <name>pn1</name> != <name>pn2</name></expr>)</condition><then> <block>{
                <while>while <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_next</name></name> != <name>pn2</name></expr>)</condition> <block>{
                    <expr_stmt><expr><name>pn1</name> = <call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>--<name><name>pn</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLTEXT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_op</name></name> = <name>JSOP_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_atom</name></name> = <call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>pn1</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pnp</name> != &amp;<name><name>pn1</name>-&gt;<name>pn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>pnp</name> = <name>pn1</name></expr>;</expr_stmt>
            }</block></then></if></else></if>
            <expr_stmt><expr><name>pnp</name> = &amp;<name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn1</name> = *<name>pnp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>accum</name> = <name>NULL</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </default>}</block></switch>

        <if>if <condition>(<expr><name>accum</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_PUSH_TEMP_ROOT_STRING</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name> = ((<name>tt</name> == <name>TOK_XMLSTAGO</name> || <name>tt</name> == <name>TOK_XMLPTAGC</name>) &amp;&amp; <name>i</name> != 0)
                  ? <call><name>js_AddAttributePart</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>i</name> &amp; 1</expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call>
                  : <call><name>js_ConcatStrings</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendanXXX</name></cpp:ifdef>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"2: %d, %d =&gt; "</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_FileEscapedString</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (%u)\n"</expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr>++<name>j</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>accum</name> = <name>str</name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name>accum</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <name>NULL</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name><name>pn</name>-&gt;<name>pn_xflags</name></name> &amp; <name>PNX_CANTFOLD</name>) == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLPTAGC</name></expr>)</condition><then>
                <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>ptagcAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLSTAGO</name> || <name>tt</name> == <name>TOK_XMLETAGO</name></expr>)</condition><then>
                <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>tagcAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>str</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>accum</name> = <call><name>js_ConcatStrings</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>accum</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pnp</name> == <name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_next</name></name></expr>)</condition> <block>{
            <expr_stmt><expr><name>pn1</name> = <call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>--<name><name>pn</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLTEXT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_op</name></name> = <name>JSOP_STRING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_atom</name></name> = <call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>pn1</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pnp</name> != &amp;<name><name>pn1</name>-&gt;<name>pn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>pnp</name> = <name>pn1</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>pn1</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/*
         * Only one node under pn, and it has been folded: move pn1 onto pn
         * unless pn is an XML root (in which case we need it to tell the code
         * generator to emit a JSOP_TOXML or JSOP_TOXMLLIST op).  If pn is an
         * XML root *and* it's a point-tag, rewrite it to TOK_XMLELEM to avoid
         * extra "&lt;" and "/&gt;" bracketing at runtime.
         */</comment>
        <if>if <condition>(<expr>!(<name><name>pn</name>-&gt;<name>pn_xflags</name></name> &amp; <name>PNX_XMLROOT</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>become</name></name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>TOK_XMLPTAGC</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLELEM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_TOXML</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>StartsWith</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAIL_RECURSE</name><parameter_list>(<param><type><name>pn2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_BEGIN_MACRO pn = (pn2); goto recur; JS_END_MACRO</cpp:value></cpp:define>

<label><name>recur</name>:</label>
    <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> == <name>tt</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_FUNC</name></expr>:
        <return>return  <expr><name>tt</name> == <name>TOK_FUNCTION</name></expr>;</return>
      </case><case>case <expr><name>PN_LIST</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_head</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>TAIL_RECURSE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>TAIL_RECURSE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>TAIL_RECURSE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <comment type="block">/* A parenthesized expression starts with a left parenthesis. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition><then>
            <return>return <expr><name>tt</name> == <name>TOK_LP</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>TAIL_RECURSE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      </case><case>case <expr><name>PN_NAME</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DOT</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DBLDOT</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>TAIL_RECURSE</name><argument_list>(<argument><expr><call><name><name>pn</name>-&gt;<name>expr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      </case><case>case <expr><name>PN_NAMESET</name></expr>:
        <expr_stmt><expr><call><name>TAIL_RECURSE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </case>}</block></switch>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TAIL_RECURSE</name></cpp:undef>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>Boolish</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name></expr>)</condition> <block>{
      <case>case <expr><name>JSOP_DOUBLE</name></expr>:
        <return>return <expr><name><name>pn</name>-&gt;<name>pn_dval</name></name> != 0 &amp;&amp; !<call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>JSOP_STRING</name></expr>:
        <return>return <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call>-&gt;<call><name>length</name><argument_list>()</argument_list></call> != 0</expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
      </case><case>case <expr><name>JSOP_CALL</name></expr>:
      <block>{
        <comment type="block">/*
         * A generator expression as an if or loop condition has no effects, it
         * simply results in a truthy object reference. This condition folding
         * is needed for the decompiler. See bug 442342 and bug 443074.
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> != 1</expr>)</condition><then>
            <break>break;</break></then></if>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name> <init>= <expr><name><name>pn</name>-&gt;<name>pn_head</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_FUNCTION</name></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr>!(<name><name>pn2</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name> &amp; <name>TCF_GENEXP_LAMBDA</name>)</expr>)</condition><then>
            <break>break;</break></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
      }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr><name>JSOP_DEFFUN</name></expr>:
      </case><case>case <expr><name>JSOP_LAMBDA</name></expr>:
      </case><case>case <expr><name>JSOP_THIS</name></expr>:
      </case><case>case <expr><name>JSOP_TRUE</name></expr>:
        <return>return <expr>1</expr>;</return>

      </case><case>case <expr><name>JSOP_NULL</name></expr>:
      </case><case>case <expr><name>JSOP_FALSE</name></expr>:
        <return>return <expr>0</expr>;</return>

      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_FoldConstants</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>inCond</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>pn2</name> <init>= <expr><name>NULL</name></expr></init>, *<name>pn3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return JS_FALSE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_FUNC</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>uint16</name></type> <name>oldflags</name> <init>= <expr><name><name>tc</name>-&gt;<name>flags</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>oldlist</name> <init>= <expr><name><name>tc</name>-&gt;<name>functionList</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = (<name>uint16</name>) <name><name>pn</name>-&gt;<name>pn_funbox</name>-&gt;<name>tcflags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>functionList</name></name> = <name><name>pn</name>-&gt;<name>pn_funbox</name>-&gt;<name>kids</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_body</name></name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_funbox</name>-&gt;<name>kids</name></name> = <name><name>tc</name>-&gt;<name>functionList</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> = <name>oldflags</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>functionList</name></name> = <name>oldlist</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>PN_LIST</name></expr>:
      <block>{
        <comment type="block">/* Propagate inCond through logical connectives. */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>cond</name> <init>= <expr><name>inCond</name> &amp;&amp; (<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_OR</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_AND</name>)</expr></init></decl>;</decl_stmt>

        <comment type="block">/* Save the list head in pn1 for later use. */</comment>
        <for>for (<init><expr><name>pn1</name> = <name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <comment type="block">/* Any kid may be null (e.g. for (;;)). */</comment>
        <expr_stmt><expr><name>pn1</name> = <name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn3</name> = <name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn1</name> &amp;&amp; !<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_IF</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_FORHEAD</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_FORHEAD</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>pn3</name> &amp;&amp; !<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <expr_stmt><expr><name>pn1</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>

        <comment type="block">/* Propagate inCond through logical connectives. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_OR</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_AND</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>inCond</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>inCond</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* First kid may be null (for default case in switch). */</comment>
        <if>if <condition>(<expr><name>pn1</name> &amp;&amp; !<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_WHILE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DO</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <comment type="block">/* Our kid may be null (e.g. return; vs. return e;). */</comment>
        <expr_stmt><expr><name>pn1</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn1</name> &amp;&amp;
            !<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>,
                              <argument><expr>(<name>inCond</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name>) ||
                              <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAME</name></expr>:
        <comment type="block">/*
         * Skip pn1 down along a chain of dotted member expressions to avoid
         * excessive recursion.  Our only goal here is to fold constants (if
         * any) in the primary expression operand to the left of the first
         * dot in the chain.
         */</comment>
        <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_used</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn1</name> = <name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>pn1</name> &amp;&amp; <name><name>pn1</name>-&gt;<name>pn_arity</name></name> == <name>PN_NAME</name> &amp;&amp; !<name><name>pn1</name>-&gt;<name>pn_used</name></name></expr>)</condition>
                <expr_stmt><expr><name>pn1</name> = <name><name>pn1</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt></while>
            <if>if <condition>(<expr><name>pn1</name> &amp;&amp; !<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAMESET</name></expr>:
        <expr_stmt><expr><name>pn1</name> = <name><name>pn</name>-&gt;<name>pn_tree</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_FoldConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_NULLARY</name></expr>:
        <break>break;</break>
    </case>}</block></switch>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_IF</name></expr>:
        <if>if <condition>(<expr><call><name>ContainsStmt</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>TOK_VAR</name></expr></argument>)</argument_list></call> || <call><name>ContainsStmt</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>TOK_VAR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <break>break;</break></then></if>
        <comment type="block">/* FALL THROUGH */</comment>

      </case><case>case <expr><name>TOK_HOOK</name></expr>:
        <comment type="block">/* Reduce 'if (C) T; else E' into T for true C, E for false. */</comment>
        <while>while <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
            <expr_stmt><expr><name>pn1</name> = <name><name>pn1</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
        <switch>switch <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_NUMBER</name></expr>:
            <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_dval</name></name> == 0 || <call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name><name>pn1</name>-&gt;<name>pn_dval</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>pn2</name> = <name>pn3</name></expr>;</expr_stmt></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_STRING</name></expr>:
            <if>if <condition>(<expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn1</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call>-&gt;<call><name>length</name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
                <expr_stmt><expr><name>pn2</name> = <name>pn3</name></expr>;</expr_stmt></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_PRIMARY</name></expr>:
            <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FALSE</name> || <name><name>pn1</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn2</name> = <name>pn3</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <comment type="block">/* FALL THROUGH */</comment>
          </case><default>default:
            <comment type="block">/* Early return to dodge common code that copies pn2 to pn. */</comment>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        </default>}</block></switch>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
        <comment type="block">/* Don't fold a trailing |if (0)| in a generator expression. */</comment>
        <if>if <condition>(<expr>!<name>pn2</name> &amp;&amp; (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_GENEXP_LAMBDA</name>)</expr>)</condition><then>
            <break>break;</break></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * pn2 is the then- or else-statement subtree to compile.  Take
             * care not to expose an object initialiser, which would be parsed
             * as a block, to the Statement parser via eval(uneval(e)) where e
             * is '1 ? {p:2, q:3}[i] : r;' or the like.
             */</comment>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_HOOK</name> &amp;&amp; <call><name>StartsWith</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>TOK_RC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_RP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_UNARY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name> = <name>pn2</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>pn3</name> &amp;&amp; <name>pn3</name> != <name>pn2</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_defn</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>become</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>pn2</name> || (<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_SEMI</name> &amp;&amp; !<name><name>pn</name>-&gt;<name>pn_kid</name></name>)</expr>)</condition><then> <block>{
            <comment type="block">/*
             * False condition and no else, or an empty then-statement was
             * moved up over pn.  Either way, make pn an empty block (not an
             * empty statement, which does not decompile, even when labeled).
             * NB: pn must be a TOK_IF as TOK_HOOK can never have a null kid
             * or an empty statement for a child.
             */</comment>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_LC</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_LIST</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>makeEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn3</name> &amp;&amp; <name>pn3</name> != <name>pn2</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_OR</name></expr>:
      </case><case>case <expr><name>TOK_AND</name></expr>:
        <if>if <condition>(<expr><name>inCond</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>pnp</name> <init>= <expr>&amp;<name><name>pn</name>-&gt;<name>pn_head</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pnp</name> == <name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <do>do <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>cond</name> <init>= <expr><call><name>Boolish</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>cond</name> == (<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_OR</name>)</expr>)</condition><then> <block>{
                        <for>for (<init><expr><name>pn2</name> = <name><name>pn1</name>-&gt;<name>pn_next</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name>pn3</name></expr></incr>) <block>{
                            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr>--<name><name>pn</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_next</name></name> = <name>NULL</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>cond</name> != -1</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>cond</name> == (<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_AND</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr>)</condition><then>
                            <break>break;</break></then></if>
                        <expr_stmt><expr>*<name>pnp</name> = <name><name>pn1</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr>--<name><name>pn</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>pnp</name> = &amp;<name><name>pn1</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block> while <condition>(<expr>(<name>pn1</name> = *<name>pnp</name>) != <name>NULL</name></expr>)</condition>;</do>

                <comment type="line">// We may have to change arity from LIST to BINARY.</comment>
                <expr_stmt><expr><name>pn1</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 2</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pn2</name> = <name><name>pn1</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn1</name>-&gt;<name>pn_next</name></name> = <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_BINARY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_left</name></name> = <name>pn1</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_right</name></name> = <name>pn2</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>become</name></name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>cond</name> <init>= <expr><call><name>Boolish</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>cond</name> == (<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_OR</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>become</name></name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>cond</name> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>cond</name> == (<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_AND</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>become</name></name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></else></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_ASSIGN</name></expr>:
        <comment type="block">/*
         * Compound operators such as *= should be subject to folding, in case
         * the left-hand side is constant, and so that the decompiler produces
         * the same string that you get from decompiling a script or function
         * compiled from that same string.  As with +, += is special.
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_ADD</name></expr>)</condition><then>
            <goto>goto <name>do_binary_op</name>;</goto></then></if>
        <comment type="block">/* FALL THROUGH */</comment>

      </case><case>case <expr><name>TOK_PLUS</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>length2</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>str2</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Any string literal term with all others number or string means
             * this is a concatenation.  If any term is not a string or number
             * literal, we can't fold.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> &gt; 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> &amp; <name>PNX_CANTFOLD</name></expr>)</condition><then>
                <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_xflags</name></name> != <name>PNX_STRCAT</name></expr>)</condition><then>
                <goto>goto <name>do_binary_op</name>;</goto></then></if>

            <comment type="block">/* Ok, we're concatenating: convert non-string constant operands. */</comment>
            <expr_stmt><expr><name>length</name> = 0</expr>;</expr_stmt>
            <for>for (<init><expr><name>pn2</name> = <name>pn1</name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<call><name>FoldType</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>TOK_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <comment type="block">/* XXX fold only if all operands convert to string */</comment>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_STRING</name></expr>)</condition><then>
                    <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>length</name> += <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call>-&gt;<call><name>flatLength</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <comment type="block">/* Allocate a new buffer and string descriptor for the result. */</comment>
            <expr_stmt><expr><name>chars</name> = (<name>jschar</name> *) <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>length</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Fill the buffer, advancing chars and recycling kids as we go. */</comment>
            <for>for (<init><expr><name>pn2</name> = <name>pn1</name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
                <expr_stmt><expr><name>str2</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>length2</name> = <call><name><name>str2</name>-&gt;<name>flatLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><call><name><name>str2</name>-&gt;<name>flatChars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>length2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>chars</name> += <name>length2</name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr>*<name>chars</name> = 0</expr>;</expr_stmt>

            <comment type="block">/* Atomize the result string and mutate pn to refer to it. */</comment>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* Handle a binary string concatenation. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name> || <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSString</name> *</type><name>left</name></decl>, *<decl><type ref="prev"/><name>right</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name>FoldType</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_STRING</name>) ? <name>pn1</name> : <name>pn2</name></expr></argument>,
                          <argument><expr><name>TOK_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> != <name>TOK_STRING</name> || <name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_STRING</name></expr>)</condition><then>
                <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>left</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn1</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>right</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name> = <call><name>js_ConcatStrings</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> = <call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* Can't concatenate string literals, let's try numbers. */</comment>
        <goto>goto <name>do_binary_op</name>;</goto>

      </case><case>case <expr><name>TOK_STAR</name></expr>:
      </case><case>case <expr><name>TOK_SHOP</name></expr>:
      </case><case>case <expr><name>TOK_MINUS</name></expr>:
      </case><case>case <expr><name>TOK_DIVOP</name></expr>:
      <label><name>do_binary_op</name>:</label>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> &gt; 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>pn2</name> = <name>pn1</name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<call><name>FoldType</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>TOK_NUMBER</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></for>
            <for>for (<init><expr><name>pn2</name> = <name>pn1</name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <comment type="block">/* XXX fold only if all operands convert to number */</comment>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NUMBER</name></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></for>
            <if>if <condition>(<expr>!<name>pn2</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>pn2</name> = <name><name>pn1</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>FoldBinaryNumeric</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <while>while <condition>(<expr>(<name>pn2</name> = <name>pn3</name>) != <name>NULL</name></expr>)</condition> <block>{
                    <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>FoldBinaryNumeric</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></while>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>FoldType</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>TOK_NUMBER</name></expr></argument>)</argument_list></call> ||
                !<call><name>FoldType</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>TOK_NUMBER</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>FoldBinaryNumeric</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
        <while>while <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
            <expr_stmt><expr><name>pn1</name> = <name><name>pn1</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>
        <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>

            <comment type="block">/* Operate on one numeric constant. */</comment>
            <expr_stmt><expr><name>d</name> = <name><name>pn1</name>-&gt;<name>pn_dval</name></name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name></expr>)</condition> <block>{
              <case>case <expr><name>JSOP_BITNOT</name></expr>:
                <expr_stmt><expr><name>d</name> = ~<call><name>js_DoubleToECMAInt32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_NEG</name></expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HPUX</name></cpp:ifdef>
                <comment type="block">/*
                 * Negation of a zero doesn't produce a negative
                 * zero on HPUX. Perform the operation by bit
                 * twiddling.
                 */</comment>
                <expr_stmt><expr><call><name>JSDOUBLE_HI32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> ^= <name>JSDOUBLE_HI32_SIGNBIT</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>d</name> = -<name>d</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_POS</name></expr>:
                <break>break;</break>

              </case><case>case <expr><name>JSOP_NOT</name></expr>:
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_PRIMARY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = (<name>d</name> == 0 || <call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call>) ? <name>JSOP_TRUE</name> : <name>JSOP_FALSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><default>default:
                <comment type="block">/* Return early to dodge the common TOK_NUMBER code. */</comment>
                <return>return <expr><name>JS_TRUE</name></expr>;</return>
            </default>}</block></switch>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_NUMBER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DOUBLE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name> = <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_PRIMARY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOT</name> &amp;&amp;
                (<name><name>pn1</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name> ||
                 <name><name>pn1</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FALSE</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>pn</name>-&gt;<name>become</name></name><argument_list>(<argument><expr><name>pn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = (<name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name>) ? <name>JSOP_FALSE</name> : <name>JSOP_TRUE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_XMLELEM</name></expr>:
      </case><case>case <expr><name>TOK_XMLLIST</name></expr>:
      </case><case>case <expr><name>TOK_XMLPTAGC</name></expr>:
      </case><case>case <expr><name>TOK_XMLSTAGO</name></expr>:
      </case><case>case <expr><name>TOK_XMLETAGO</name></expr>:
      </case><case>case <expr><name>TOK_XMLNAME</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLLIST</name> || <name><name>pn</name>-&gt;<name>pn_count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>FoldXMLConstants</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_AT</name></expr>:
        <if>if <condition>(<expr><name><name>pn1</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLNAME</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSObjectBox</name> *</type><name>xmlbox</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>v</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name><name>pn1</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_ToAttributeName</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>xmlbox</name> = <call><name><name>tc</name>-&gt;<name>compiler</name>-&gt;<name>newObjectBox</name></name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>xmlbox</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_XMLNAME</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_OBJECT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_objbox</name></name> = <name>xmlbox</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn1</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>

    <if>if <condition>(<expr><name>inCond</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>cond</name> <init>= <expr><call><name>Boolish</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cond</name> &gt;= 0</expr>)</condition><then> <block>{
            <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
              <case>case <expr><name>PN_LIST</name></expr>:
                <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
                <do>do <block>{
                    <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RecycleTree</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> while <condition>(<expr>(<name>pn2</name> = <name>pn3</name>) != <name>NULL</name></expr>)</condition>;</do>
                <break>break;</break>
              </case><case>case <expr><name>PN_FUNC</name></expr>:
                <expr_stmt><expr><call><name>RecycleFuncNameKids</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>PN_NULLARY</name></expr>:
                <break>break;</break>
              </case><default>default:
                <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"unhandled arity"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </default>}</block></switch>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> = <name>TOK_PRIMARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>cond</name> ? <name>JSOP_TRUE</name> : <name>JSOP_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
</unit>
