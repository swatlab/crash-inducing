<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="005e1501daf575d21847d188e2fbe1c7b45929d6.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=99:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS string type implementation.
 *
 * In order to avoid unnecessary js_LockGCThing/js_UnlockGCThing calls, these
 * native methods store strings (possibly newborn) converted from their 'this'
 * parameter and arguments on the stack: 'this' conversions at argv[-1], arg
 * conversions at their index (argv[0], argv[1]).  This is a legitimate method
 * of rooting things that might lose their newborn root due to subsequent GC
 * allocations in the same native method.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jshash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbuiltins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>      <comment type="block">/* for JS_ARGS_LENGTH_MAX */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsvector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxtinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterpinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobjinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexpinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstrinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsautooplen.h"</cpp:file></cpp:include>        <comment type="line">// generated headers last</comment>

<using>using namespace <name>js</name>;</using>
<using>using namespace <name><name>js</name>::<name>gc</name></name>;</using>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name><name>JSString</name>::<name>MAX_LENGTH</name></name></expr></argument>)</argument_list></call> &lt;= <call><name>size_t</name><argument_list>(<argument><expr><name>JSVAL_INT_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name><name>JSString</name>::<name>MAX_LENGTH</name></name> &lt;= <name>JSVAL_INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>const</specifier> <name>jschar</name> *</type>
<name>js_GetStringChars</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>js_MakeStringImmutable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>str</name>-&gt;<name>flatChars</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>size_t</name></type>
<name>RopeCapacityFor</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>ROPE_DOUBLING_MAX</name> <init>= <expr>1024 * 1024</expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Grow by 12.5% if the buffer is very large. Otherwise, round up to the
     * next power of 2. This is similar to what we do with arrays; see
     * JSObject::ensureDenseArrayElements.
     */</comment>
    <if>if <condition>(<expr><name>length</name> &gt; <name>ROPE_DOUBLING_MAX</name></expr>)</condition><then>
        <return>return <expr><name>length</name> + (<name>length</name> / 8)</expr>;</return></then></if>
    <return>return <expr><call><name>RoundUpPow2</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>jschar</name> *</type>
<name>AllocChars</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>maybecx</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>wholeCapacity</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* +1 for the null char at the end. */</comment>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name><name>JSString</name>::<name>MAX_LENGTH</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof> &lt; <name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr>(<name>wholeCapacity</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>maybecx</name></expr>)</condition><then>
        <return>return <expr>(<name>jschar</name> *)<call><name><name>maybecx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr>(<name>jschar</name> *)<call><name>js_malloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>jschar</name> *</type>
<name><name>JSString</name>::<name>flatten</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>maybecx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isRope</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Perform a depth-first dag traversal, splatting each node's characters
     * into a contiguous buffer. Visit each rope node three times:
     *  1. record position in the buffer and recurse into left child;
     *  2. recurse into the right child;
     *  3. transform the node into a dependent string.
     * To avoid maintaining a stack, tree nodes are mutated to indicate how
     * many times they have been visited. Since ropes can be dags, a node may
     * be encountered multiple times during traversal. However, step 3 above
     * leaves a valid dependent string, so everythings works out.  This
     * algorithm is homomorphic to TypedMarker(JSTracer *, JSString *).
     *
     * While ropes avoid all sorts of quadratic cases with string
     * concatenation, they can't help when ropes are immediately flattened.
     * One idiomatic case that we'd like to keep linear (and has traditionally
     * been linear in SM and other JS engines) is:
     *
     *   while (...) {
     *     s += ...
     *     s.flatten
     *   }
     *
     * To do this, when the buffer for a to-be-flattened rope is allocated, the
     * allocation size is rounded up. Then, if the resulting flat string is the
     * left-hand side of a new rope that gets flattened and there is enough
     * capacity, the rope is flattened into the same buffer, thereby avoiding
     * copying the left-hand side. Clearing the 'extensible' bit turns off this
     * optimization. This is necessary, e.g., when the JSAPI hands out the raw
     * null-terminated char array of a flat string.
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>wholeLength</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>wholeCapacity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>wholeChars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>pos</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>u</name>.<name>left</name>-&gt;<name>isExtensible</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>u</name>.<name>left</name>-&gt;<name>s</name>.<name>capacity</name></name> &gt;= <name>wholeLength</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wholeCapacity</name> = <name><name>u</name>.<name>left</name>-&gt;<name>s</name>.<name>capacity</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>wholeChars</name> = <call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>jschar</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>u</name>.<name>left</name>-&gt;<name>u</name>.<name>chars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> = <name>wholeChars</name> + <call><name><name>u</name>.<name>left</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>u</name>.<name>left</name>-&gt;<name>finishTraversalConversion</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>wholeChars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>visit_right_child</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>wholeCapacity</name> = <call><name>RopeCapacityFor</name><argument_list>(<argument><expr><name>wholeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wholeChars</name> = <call><name>AllocChars</name><argument_list>(<argument><expr><name>maybecx</name></expr></argument>, <argument><expr><name>wholeCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>wholeChars</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>pos</name> = <name>wholeChars</name></expr>;</expr_stmt>
    <label><name>first_visit_node</name>:</label> <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>left</name> <init>= <expr><name><name>str</name>-&gt;<name>u</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Read before clobbered. */</comment>
        <expr_stmt><expr><name><name>str</name>-&gt;<name>u</name>.<name>chars</name></name> = <name>pos</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>left</name>-&gt;<name>isRope</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>left</name>-&gt;<name>s</name>.<name>parent</name></name> = <name>str</name></expr>;</expr_stmt>               <comment type="block">/* Return to this when 'left' done, */</comment>
            <expr_stmt><expr><name><name>left</name>-&gt;<name>lengthAndFlags</name></name> = 0x200</expr>;</expr_stmt>       <comment type="block">/* but goto visit_right_child. */</comment>
            <expr_stmt><expr><name>str</name> = <name>left</name></expr>;</expr_stmt>
            <goto>goto <name>first_visit_node</name>;</goto>
        }</block></then></if>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name><name>left</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PodCopy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>left</name>-&gt;<name>u</name>.<name>chars</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> += <name>len</name></expr>;</expr_stmt>
    }</block>
    <label><name>visit_right_child</name>:</label> <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>right</name> <init>= <expr><name><name>str</name>-&gt;<name>s</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>right</name>-&gt;<name>isRope</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>right</name>-&gt;<name>s</name>.<name>parent</name></name> = <name>str</name></expr>;</expr_stmt>              <comment type="block">/* Return to this node when 'right' done, */</comment>
            <expr_stmt><expr><name><name>right</name>-&gt;<name>lengthAndFlags</name></name> = 0x300</expr>;</expr_stmt>      <comment type="block">/* but goto finish_node. */</comment>
            <expr_stmt><expr><name>str</name> = <name>right</name></expr>;</expr_stmt>
            <goto>goto <name>first_visit_node</name>;</goto>
        }</block></then></if>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name><name>right</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PodCopy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>right</name>-&gt;<name>u</name>.<name>chars</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> += <name>len</name></expr>;</expr_stmt>
    }</block>
    <label><name>finish_node</name>:</label> <block>{
        <if>if <condition>(<expr><name>str</name> == <name>this</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pos</name> == <name>wholeChars</name> + <name>wholeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>pos</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>initFlatExtensible</name><argument_list>(<argument><expr><name>wholeChars</name></expr></argument>, <argument><expr><name>wholeLength</name></expr></argument>, <argument><expr><name>wholeCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>wholeChars</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>size_t</name></type> <name>progress</name> <init>= <expr><name><name>str</name>-&gt;<name>lengthAndFlags</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Read before clobbered. */</comment>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>parent</name> <init>= <expr><name><name>str</name>-&gt;<name>s</name>.<name>parent</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>str</name>-&gt;<name>finishTraversalConversion</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>wholeChars</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str</name> = <name>parent</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>progress</name> == 0x200</expr>)</condition><then>
            <goto>goto <name>visit_right_child</name>;</goto></then></if>
        <goto>goto <name>finish_node</name>;</goto>
    }</block>
}</block></function>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name><name>JSExternalString</name>::<name>TYPE_LIMIT</name></name> == 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>JSStringFinalizeOp</name></type> <name><name>JSExternalString</name>::<name>str_finalizers</name><index>[<expr><name><name>JSExternalString</name>::<name>TYPE_LIMIT</name></name></expr>]</index></name> <init>= <expr><block>{
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>

<function><type><name>JSBool</name> <name>JS_FASTCALL</name></type>
<name>js_Flatten</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name>*</type> <name>str</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>!!<call><name><name>str</name>-&gt;<name>flatten</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_2</name><argument_list>(<argument>extern</argument>, <argument>BOOL</argument>, <argument>js_Flatten</argument>, <argument>CONTEXT</argument>, <argument>STRING</argument>, <argument>0</argument>, <argument>nanojit::ACCSET_STORE_ANY</argument>)</argument_list></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !JS_TRACER */</comment>

<function><type><name>JSString</name> * <name>JS_FASTCALL</name></type>
<name>js_ConcatStrings</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>left</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>right</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>leftLen</name> <init>= <expr><call><name><name>left</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>leftLen</name> == 0</expr>)</condition><then>
        <return>return <expr><name>right</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>rightLen</name> <init>= <expr><call><name><name>right</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rightLen</name> == 0</expr>)</condition><then>
        <return>return <expr><name>left</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>wholeLength</name> <init>= <expr><name>leftLen</name> + <name>rightLen</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>wholeLength</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSShortString</name> *</type><name>shortStr</name> <init>= <expr><call><name>js_NewGCShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>shortStr</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>leftChars</name> <init>= <expr><call><name><name>left</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>leftChars</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>rightChars</name> <init>= <expr><call><name><name>right</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>rightChars</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>jschar</name> *</type><name>buf</name> <init>= <expr><call><name><name>shortStr</name>-&gt;<name>init</name></name><argument_list>(<argument><expr><name>wholeLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>js_short_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>leftChars</name></expr></argument>, <argument><expr><name>leftLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_short_strncpy</name><argument_list>(<argument><expr><name>buf</name> + <name>leftLen</name></expr></argument>, <argument><expr><name>rightChars</name></expr></argument>, <argument><expr><name>rightLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>wholeLength</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <return>return <expr><call><name><name>shortStr</name>-&gt;<name>header</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>wholeLength</name> &gt; <name><name>JSString</name>::<name>MAX_LENGTH</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>CanLeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>newRoot</name> <init>= <expr><call><name>js_NewGCString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>newRoot</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>newRoot</name>-&gt;<name>initRopeNode</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>wholeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>newRoot</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>jschar</name> *</type>
<name><name>JSString</name>::<name>undepend</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>ensureLinear</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>isDependent</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>n</name> = <call><name>dependentLength</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> = (<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>dependentChars</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>initFlat</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <block>{
            <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_RUNTIME_UNMETER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>liveDependentStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_RUNTIME_UNMETER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>totalDependentStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_LOCK_RUNTIME_VOID</name><argument_list>(<argument><expr><name>rt</name></expr></argument>,
                <argument><expr>(<name><name>rt</name>-&gt;<name>strdepLengthSum</name></name> -= (<name>double</name>)<name>n</name>,
                 <name><name>rt</name>-&gt;<name>strdepLengthSquaredSum</name></name> -= (<name>double</name>)<name>n</name> * (<name>double</name>)<name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <return>return <expr><call><name>flatChars</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_MakeStringImmutable</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Flattening a rope may result in a dependent string, so we need to flatten
     * before undepending the string.
     */</comment>
    <if>if <condition>(<expr>!<call><name><name>str</name>-&gt;<name>isFlat</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>str</name>-&gt;<name>undepend</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>, <argument><expr><name>badUndependStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>str</name>-&gt;<name>flatClearExtensible</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSLinearString</name> *</type>
<name>ArgToRootedString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>arg</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>arg</name> &gt;= <name>argc</name></expr>)</condition><then>
        <return>return <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_VOID</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><name>vp</name> += 2 + <name>arg</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>vp</name>-&gt;<name>isObject</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>DefaultValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<call><name><name>vp</name>-&gt;<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>JSTYPE_STRING</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>vp</name>-&gt;<name>isString</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name><name>vp</name>-&gt;<name>toString</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ensureLinear</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>vp</name>-&gt;<name>isBoolean</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>booleanAtoms</name><index>[
                                  <expr>(<name>int</name>)<call><name><name>vp</name>-&gt;<name>toBoolean</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>vp</name>-&gt;<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>nullAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>vp</name>-&gt;<name>isUndefined</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_VOID</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>str</name> = <call><name>NumberToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>vp</name>-&gt;<name>toNumber</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Forward declarations for URI encode/decode and helper routines
 */</comment>
<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_decodeURI</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_decodeURI_Component</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_encodeURI</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_encodeURI_Component</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>OVERLONG_UTF8</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type>
<name>Utf8ToOneUcs4Char</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>uint8</name> *</type><name>utf8Buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>utf8Length</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Contributions from the String class to the set of methods defined for the
 * global object.  escape and unescape used to be defined in the Mocha library,
 * but as ECMA decided to spec them, they've been moved to the core engine
 * and made ECMA-compliant.  (Incomplete escapes are interpreted as literal
 * characters by unescape.)
 */</comment>

<comment type="block">/*
 * Stuff to emulate the old libmocha escape, which took a second argument
 * giving the type of escape to perform.  Retained for compatibility, and
 * copied here to avoid reliance on net.h, mkparse.c/NET_EscapeBytes.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>URL_XALPHAS</name></cpp:macro>     <cpp:value>((uint8) 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>URL_XPALPHAS</name></cpp:macro>    <cpp:value>((uint8) 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>URL_PATH</name></cpp:macro>        <cpp:value>((uint8) 4)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8</name></type> <name><name>urlCharType</name><index>[<expr>256</expr>]</index></name> <init>=
<comment type="block">/*      Bit 0           xalpha          -- the alphas
 *      Bit 1           xpalpha         -- as xalpha but
 *                             converts spaces to plus and plus to %20
 *      Bit 2 ...       path            -- as xalphas but doesn't escape '/'
 */</comment>
    <comment type="block">/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */</comment>
    <expr><block>{    <expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,       <comment type="block">/* 0x */</comment>
         <expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,       <comment type="block">/* 1x */</comment>
         <expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>7</expr>,<expr>4</expr>,<expr>0</expr>,<expr>7</expr>,<expr>7</expr>,<expr>4</expr>,       <comment type="block">/* 2x   !"#$%&amp;'()*+,-./  */</comment>
         <expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,       <comment type="block">/* 3x  0123456789:;&lt;=&gt;?  */</comment>
         <expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,       <comment type="block">/* 4x  @ABCDEFGHIJKLMNO  */</comment>
         <expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>7</expr>,       <comment type="block">/* 5X  PQRSTUVWXYZ[\]^_  */</comment>
         <expr>0</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,       <comment type="block">/* 6x  `abcdefghijklmno  */</comment>
         <expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>7</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,       <comment type="block">/* 7X  pqrstuvwxyz{\}~  DEL */</comment>
         <expr>0</expr>, }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This matches the ECMA escape set when mask is 7 (default.) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_OK</name><parameter_list>(<param><type><name>C</name></type></param>, <param><type><name>mask</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(urlCharType[((uint8) (C))] &amp; (mask))</cpp:value></cpp:define>

<comment type="block">/* See ECMA-262 Edition 3 B.2.1 */</comment>
<function><type><name>JSBool</name></type>
<name>js_str_escape</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>digits</name><index>[]</index></name> <init>= <expr><block>{<expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>,
                           <expr>'8'</expr>, <expr>'9'</expr>, <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr> }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsint</name></type> <name>mask</name> <init>= <expr><name>URL_XALPHAS</name> | <name>URL_XPALPHAS</name> | <name>URL_PATH</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>argc</name> &gt; 1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>JSDOUBLE_IS_FINITE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> ||
            (<name>mask</name> = (<name>jsint</name>)<name>d</name>) != <name>d</name> ||
            <name>mask</name> &amp; ~(<name>URL_XALPHAS</name> | <name>URL_XPALPHAS</name> | <name>URL_PATH</name>)</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>char</name></type> <name><name>numBuf</name><index>[<expr>12</expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>numBuf</name></expr></argument>, <argument><expr>sizeof <name>numBuf</name></expr></argument>, <argument><expr>"%lx"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>) <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSMSG_BAD_STRING_MASK</name></expr></argument>, <argument><expr><name>numBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name> - 2</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Take a first pass and see how big the result string will need to be. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newlength</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>ch</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>ch</name> = <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name>) &lt; 128 &amp;&amp; <call><name>IS_OK</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <if>if <condition>(<expr><name>ch</name> &lt; 256</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>mask</name> == <name>URL_XPALPHAS</name> &amp;&amp; <name>ch</name> == ' '</expr>)</condition><then>
                <continue>continue;</continue></then></if>   <comment type="block">/* The character will be encoded as '+' */</comment>
            <expr_stmt><expr><name>newlength</name> += 2</expr>;</expr_stmt> <comment type="block">/* The character will be encoded as %XX */</comment>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>newlength</name> += 5</expr>;</expr_stmt> <comment type="block">/* The character will be encoded as %uXXXX */</comment>
        }</block></else></if>

        <comment type="block">/*
         * This overflow test works because newlength is incremented by at
         * most 5 on each iteration.
         */</comment>
        <if>if <condition>(<expr><name>newlength</name> &lt; <name>length</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>newlength</name> &gt;= ~(<name>size_t</name>)0 / <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>newchars</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>newlength</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>newchars</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ni</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>ni</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>ch</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>ch</name> = <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name>) &lt; 128 &amp;&amp; <call><name>IS_OK</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> &lt; 256</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>mask</name> == <name>URL_XPALPHAS</name> &amp;&amp; <name>ch</name> == ' '</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = '+'</expr>;</expr_stmt> <comment type="block">/* convert spaces to pluses */</comment>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = '%'</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name><name>digits</name><index>[<expr><name>ch</name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name><name>digits</name><index>[<expr><name>ch</name> &amp; 0xF</expr>]</index></name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = '%'</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = 'u'</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name><name>digits</name><index>[<expr><name>ch</name> &gt;&gt; 12</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name><name>digits</name><index>[<expr>(<name>ch</name> &amp; 0xF00) &gt;&gt; 8</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name><name>digits</name><index>[<expr>(<name>ch</name> &amp; 0xF0) &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name><name>digits</name><index>[<expr><name>ch</name> &amp; 0xF</expr>]</index></name></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ni</name> == <name>newlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>newlength</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>retstr</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>newchars</name></expr></argument>, <argument><expr><name>newlength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>retstr</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>newchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>rval</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_OK</name></cpp:undef>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_escape</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>ComputeThisFromVp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>obj</name> &amp;&amp; <call><name>js_str_escape</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* See ECMA-262 Edition 3 B.2.2 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_unescape</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Don't bother allocating less space for the new string. */</comment>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>newchars</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>length</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>newchars</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>ni</name> <init>= <expr>0</expr></init>, <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>i</name> &lt; <name>length</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>ch</name> <init>= <expr><name><name>chars</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>ch</name> == '%'</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>i</name> + 1 &lt; <name>length</name> &amp;&amp;
                <call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>ch</name> = <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> * 16 + <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>i</name> + 4 &lt; <name>length</name> &amp;&amp; <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> == 'u' &amp;&amp;
                       <call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 2</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp;
                       <call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 3</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 4</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>ch</name> = (((((<call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call> &lt;&lt; 4)
                        + <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 2</expr>]</index></name></expr></argument>)</argument_list></call>) &lt;&lt; 4)
                      + <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 3</expr>]</index></name></expr></argument>)</argument_list></call>) &lt;&lt; 4)
                    + <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name> + 4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> += 5</expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then></if>
        <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name>++</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name><name>newchars</name><index>[<expr><name>ni</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>retstr</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>newchars</name></expr></argument>, <argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>retstr</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>newchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_UNEVAL</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_uneval</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>js_ValueToSource</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name> != 0 ? <name><name>vp</name><index>[<expr>2</expr>]</index></name> : <call><name>UndefinedValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_escape_str</name><index>[]</index></name> <init>= <expr>"escape"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_unescape_str</name><index>[]</index></name> <init>= <expr>"unescape"</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_UNEVAL</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_uneval_str</name><index>[]</index></name> <init>= <expr>"uneval"</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_decodeURI_str</name><index>[]</index></name> <init>= <expr>"decodeURI"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_encodeURI_str</name><index>[]</index></name> <init>= <expr>"encodeURI"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_decodeURIComponent_str</name><index>[]</index></name> <init>= <expr>"decodeURIComponent"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_encodeURIComponent_str</name><index>[]</index></name> <init>= <expr>"encodeURIComponent"</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>string_functions</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_escape_str</name></expr></argument>,             <argument><expr><name>str_escape</name></expr></argument>,                <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_unescape_str</name></expr></argument>,           <argument><expr><name>str_unescape</name></expr></argument>,              <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_UNEVAL</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_uneval_str</name></expr></argument>,             <argument><expr><name>str_uneval</name></expr></argument>,                <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_decodeURI_str</name></expr></argument>,          <argument><expr><name>str_decodeURI</name></expr></argument>,             <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_encodeURI_str</name></expr></argument>,          <argument><expr><name>str_encodeURI</name></expr></argument>,             <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_decodeURIComponent_str</name></expr></argument>, <argument><expr><name>str_decodeURI_Component</name></expr></argument>,   <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_encodeURIComponent_str</name></expr></argument>, <argument><expr><name>str_encodeURI_Component</name></expr></argument>,   <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,

    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>jschar</name></type>      <name><name>js_empty_ucstr</name><index>[]</index></name>  <init>= <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>JSSubString</name></type> <name>js_EmptySubString</name> <init>= <expr><block>{<expr>0</expr>, <expr><name>js_empty_ucstr</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_getProperty</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSID_IS_ATOM</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_StringClass</name></expr>)</condition><then> <block>{
            <comment type="block">/* Follow ECMA-262 by fetching intrinsic length of our string. */</comment>
            <expr_stmt><expr><name>str</name> = <call><name><name>obj</name>-&gt;<name>getPrimitiveThis</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* Preserve compatibility: convert obj to a string primitive. */</comment>
            <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ObjectValue</name><argument_list>(<argument><expr>*<name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>

        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_ELEMENT_ATTRS</name></cpp:macro> <cpp:value>(JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_PERMANENT)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_enumerate</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>str1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name><name>obj</name>-&gt;<name>getPrimitiveThis</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>length</name> = <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>str1</name> = <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str1</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>INT_TO_JSID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>PropertyStub</name></expr></argument>, <argument><expr><name>PropertyStub</name></expr></argument>,
                                 <argument><expr><name>STRING_ELEMENT_ATTRS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <return>return <expr><call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>UndefinedValue</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><name>JSPROP_PERMANENT</name> | <name>JSPROP_READONLY</name> | <name>JSPROP_SHARED</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_resolve</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>,
            <param><decl><type><name>JSObject</name> **</type><name>objp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>JSID_IS_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name><name>obj</name>-&gt;<name>getPrimitiveThis</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name> <init>= <expr><call><name>JSID_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>(<name>size_t</name>)<name>slot</name> &lt; <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>str1</name> <init>= <expr><call><name><name>JSString</name>::<name>getUnitString</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>str1</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>STRING_ELEMENT_ATTRS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr>*<name>objp</name> = <name>obj</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>Class</name></type> <name>js_StringClass</name> <init>= <expr><block>{
    <expr><name>js_String_str</name></expr>,
    <expr><call><name>JSCLASS_HAS_RESERVED_SLOTS</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> | <name>JSCLASS_NEW_RESOLVE</name> |
    <call><name>JSCLASS_HAS_CACHED_PROTO</name><argument_list>(<argument><expr><name>JSProto_String</name></expr></argument>)</argument_list></call></expr>,
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* addProperty */</comment>
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* delProperty */</comment>
    <expr><name>str_getProperty</name></expr>,
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* setProperty */</comment>
    <expr><name>str_enumerate</name></expr>,
    <expr>(<name>JSResolveOp</name>)<name>str_resolve</name></expr>,
    <expr><name>ConvertStub</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMALIZE_THIS</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>vp</name></type></param>,<param><type><name>str</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        if (vp[1].isString()) {                                               \
            str = vp[1].toString();                                           \
        } else {                                                              \
            str = NormalizeThis(cx, vp);                                      \
            if (!str)                                                         \
                return JS_FALSE;                                              \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSString</name> *</type>
<name>NormalizeThis</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>isNullOrUndefined</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>ComputeThisFromVp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/*
     * String.prototype.{toString,toSource,valueOf} throw a TypeError if the
     * this-argument is not a string or a String object. So those methods use
     * js::GetPrimitiveThis which provides that behavior.
     *
     * By standard, the rest of the String methods must ToString the
     * this-argument rather than throw a TypeError. So those methods use
     * NORMALIZE_THIS (and thus NormalizeThis) instead.
     */</comment>
    <if>if <condition>(<expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>isObject</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr>&amp;<name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>toObject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_StringClass</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name> = <call><name><name>obj</name>-&gt;<name>getPrimitiveThis</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>

<comment type="block">/*
 * String.prototype.quote is generic (as are most string methods), unlike
 * toSource, toString, and valueOf.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_quote</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> = <call><name>js_QuoteString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_toSource</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetPrimitiveThis</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>js_QuoteString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>, <argument><expr>"(new String("</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>k</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>j</name> + <name>k</name> + 2</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>t</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>t</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>k</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>)
        <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>
    <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_TOSOURCE */</comment>

<function><type><name>JSBool</name></type>
<name>js_str_toString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetPrimitiveThis</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Java-like string native methods.
 */</comment>

<function><type><specifier>static</specifier> <name>JSString</name> *</type>
<name>SubstringTail</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>length</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>begin</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>end</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>begin</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>begin</name> = 0</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>begin</name> &gt; <name>length</name></expr>)</condition><then>
        <expr_stmt><expr><name>begin</name> = <name>length</name></expr>;</expr_stmt></then></if></else></if>

    <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>end</name> &gt; <name>length</name></expr>)</condition><then>
        <expr_stmt><expr><name>end</name> = <name>length</name></expr>;</expr_stmt></then></if></else></if>
    <if>if <condition>(<expr><name>end</name> &lt; <name>begin</name></expr>)</condition><then> <block>{
        <comment type="block">/* ECMA emulates old JDK1.0 java.lang.String.substring. */</comment>
        <decl_stmt><decl><type><name>jsdouble</name></type> <name>tmp</name> <init>= <expr><name>begin</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>begin</name> = <name>end</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> = <name>tmp</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>begin</name></expr></argument>, <argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>end</name> - <name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_substring</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>begin</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>length</name> = <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>begin</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>argc</name> == 1 || <name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>isUndefined</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> = <name>length</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>end</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>str</name> = <call><name>SubstringTail</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>JSString</name>* <name>JS_FASTCALL</name></type>
<name>js_toLowerCase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>news</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>news</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>JS_TOLOWER</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><name><name>news</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>news</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>news</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_toLowerCase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> = <call><name>js_toLowerCase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_toLocaleLowerCase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Forcefully ignore the first (or any) argument and return toLowerCase(),
     * ECMA has reserved that argument, presumably for defining the locale.
     */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>localeCallbacks</name></name> &amp;&amp; <name><name>cx</name>-&gt;<name>localeCallbacks</name>-&gt;<name>localeToLowerCase</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>cx</name>-&gt;<name>localeCallbacks</name>-&gt;<name>localeToLowerCase</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>Jsvalify</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>str_toLowerCase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSString</name>* <name>JS_FASTCALL</name></type>
<name>js_toUpperCase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>news</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>news</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>JS_TOUPPER</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><name><name>news</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>news</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>news</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_toUpperCase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> = <call><name>js_toUpperCase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_toLocaleUpperCase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Forcefully ignore the first (or any) argument and return toUpperCase(),
     * ECMA has reserved that argument, presumably for defining the locale.
     */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>localeCallbacks</name></name> &amp;&amp; <name><name>cx</name>-&gt;<name>localeCallbacks</name>-&gt;<name>localeToUpperCase</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>cx</name>-&gt;<name>localeCallbacks</name>-&gt;<name>localeToUpperCase</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>Jsvalify</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>str_toUpperCase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_localeCompare</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>thatStr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>thatStr</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>thatStr</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>localeCallbacks</name></name> &amp;&amp; <name><name>cx</name>-&gt;<name>localeCallbacks</name>-&gt;<name>localeCompare</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name>thatStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>cx</name>-&gt;<name>localeCallbacks</name>-&gt;<name>localeCompare</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>thatStr</name></expr></argument>, <argument><expr><call><name>Jsvalify</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>int32</name></type> <name>result</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>CompareStrings</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>thatStr</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_str_charAt</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>isString</name><argument_list>()</argument_list></call> &amp;&amp; <name>argc</name> != 0 &amp;&amp; <name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>isInt32</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = <name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>toInt32</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>size_t</name>)<name>i</name> &gt;= <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <goto>goto <name>out_of_range</name>;</goto></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>d</name> = 0.0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>d</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>d</name> &lt; 0 || <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> &lt;= <name>d</name></expr>)</condition><then>
            <goto>goto <name>out_of_range</name>;</goto></then></if>
        <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <name>d</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>str</name> = <call><name><name>JSString</name>::<name>getUnitString</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<label><name>out_of_range</name>:</label>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_str_charCodeAt</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>isString</name><argument_list>()</argument_list></call> &amp;&amp; <name>argc</name> != 0 &amp;&amp; <name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>isInt32</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = <name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>toInt32</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>size_t</name>)<name>i</name> &gt;= <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <goto>goto <name>out_of_range</name>;</goto></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>d</name> = 0.0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <expr_stmt><expr><name>d</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>d</name> &lt; 0 || <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> &lt;= <name>d</name></expr>)</condition><then>
            <goto>goto <name>out_of_range</name>;</goto></then></if>
        <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <name>d</name></expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>chars</name> = <call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>

<label><name>out_of_range</name>:</label>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setDouble</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>jsint</name></type>
<name>js_BoyerMooreHorspool</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>text</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>textlen</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>patlen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint8</name></type> <name><name>skip</name><index>[<expr><name>sBMHCharSetSize</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0 &lt; <name>patlen</name> &amp;&amp; <name>patlen</name> &lt;= <name>sBMHPatLenMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>jsuint</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>sBMHCharSetSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>skip</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>uint8</name>)<name>patlen</name></expr>;</expr_stmt></for>
    <decl_stmt><decl><type><name>jsuint</name></type> <name>m</name> <init>= <expr><name>patlen</name> - 1</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>jsuint</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>m</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>c</name> <init>= <expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>c</name> &gt;= <name>sBMHCharSetSize</name></expr>)</condition><then>
            <return>return <expr><name>sBMHBadPattern</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>skip</name><index>[<expr><name>c</name></expr>]</index></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>m</name> - <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>jsuint</name></type> <name>k</name> <init>= <expr><name>m</name></expr></init></decl>;</init>
         <condition><expr><name>k</name> &lt; <name>textlen</name></expr>;</condition>
         <incr><expr><name>k</name> += ((<name>c</name> = <name><name>text</name><index>[<expr><name>k</name></expr>]</index></name>) &gt;= <name>sBMHCharSetSize</name>) ? <name>patlen</name> : <name><name>skip</name><index>[<expr><name>c</name></expr>]</index></name></expr></incr>) <block>{
        <for>for (<init><decl><type><name>jsuint</name></type> <name>i</name> <init>= <expr><name>k</name></expr></init>, <name>j</name> <init>= <expr><name>m</name></expr></init></decl>;</init> <condition>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>j</name>--</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>pat</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
                <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsint</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if>  <comment type="block">/* safe: max string size */</comment>
        }</block></for>
    }</block></for>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<struct>struct <name>MemCmp</name> <block>{<public type="default">
    <typedef>typedef <type><name>jsuint</name></type> <name>Extent</name>;</typedef>
    <function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>Extent</name></type> <name>computeExtent</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>jschar</name> *</decl></param>, <param><decl><type><name>jsuint</name></type> <name>patlen</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>patlen</name> - 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>;</return>
    }</block></function>
    <function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type> <name>match</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t</name></decl></param>, <param><decl><type><name>Extent</name></type> <name>extent</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
    }</block></function>
</public>}</block>;</struct>

<struct>struct <name>ManualCmp</name> <block>{<public type="default">
    <typedef>typedef <type><specifier>const</specifier> <name>jschar</name> *</type><name>Extent</name>;</typedef>
    <function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>Extent</name></type> <name>computeExtent</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>patlen</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>pat</name> + <name>patlen</name></expr>;</return>
    }</block></function>
    <function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type> <name>match</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t</name></decl></param>, <param><decl><type><name>Extent</name></type> <name>extent</name></decl></param>)</parameter_list> <block>{
        <for>for (<init>;</init> <condition><expr><name>p</name> != <name>extent</name></expr>;</condition> <incr><expr>++<name>p</name></expr>, <expr>++<name>t</name></expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>p</name> != *<name>t</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>
</public>}</block>;</struct>

<template>template <parameter_list>&lt;<param><type><name>class</name></type> <name>InnerMatch</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>jsint</name></type>
<name>UnrolledMatch</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>text</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>textlen</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>patlen</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>patlen</name> &gt; 0 &amp;&amp; <name>textlen</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>textend</name> <init>= <expr><name>text</name> + <name>textlen</name> - (<name>patlen</name> - 1)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name>p0</name> <init>= <expr>*<name>pat</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *<specifier>const</specifier></type> <name>patNext</name> <init>= <expr><name>pat</name> + 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <typename>typename</typename> <name><name>InnerMatch</name>::<name>Extent</name></name></type> <name>extent</name> <init>= <expr><call><name><name>InnerMatch</name>::<name>computeExtent</name></name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type> <name>fixup</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t</name> <init>= <expr><name>text</name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr>(<name>textend</name> - <name>t</name>) &amp; 7</expr>)</condition> <block>{
      <case>case <expr>0</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 8</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>7</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 7</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>6</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 6</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>5</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 5</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>4</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 4</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>3</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 3</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>2</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 2</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      </case><case>case <expr>1</expr>: <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>fixup</name> = 1</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
    </case>}</block></switch>
    <while>while <condition>(<expr><name>t</name> != <name>textend</name></expr>)</condition> <block>{
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>0</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 1</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 8</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>1</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 2</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 7</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>2</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 3</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 6</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>3</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 4</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 5</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>4</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 5</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 4</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>5</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 6</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 3</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>6</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 7</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 2</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
      <if>if <condition>(<expr><name><name>t</name><index>[<expr>7</expr>]</index></name> == <name>p0</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>t</name> += 8</expr>;</expr_stmt> <expr_stmt><expr><name>fixup</name> = 1</expr>;</expr_stmt> <goto>goto <name>match</name>;</goto> }</block></then></if>
        <expr_stmt><expr><name>t</name> += 8</expr>;</expr_stmt>
        <continue>continue;</continue>
        <do>do <block>{
            <if>if <condition>(<expr>*<name>t</name>++ == <name>p0</name></expr>)</condition><then> <block>{
              <label><name>match</name>:</label>
                <if>if <condition>(<expr>!<call><name><name>InnerMatch</name>::<name>match</name></name><argument_list>(<argument><expr><name>patNext</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>failed_match</name>;</goto></then></if>
                <return>return <expr><name>t</name> - <name>text</name> - 1</expr>;</return>
            }</block></then></if>
          <label><name>failed_match</name>:</label><empty_stmt>;</empty_stmt>
        }</block> while <condition>(<expr>--<name>fixup</name> &gt; 0</expr>)</condition>;</do>
    }</block></while>
    <return>return <expr>-1</expr>;</return>
}</block></function></template>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>jsint</name></type>
<name>StringMatch</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>text</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>textlen</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>patlen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>patlen</name> == 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr><name>textlen</name> &lt; <name>patlen</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/*
     * Given enough registers, the unrolled loop below is faster than the
     * following loop. 32-bit x86 does not have enough registers.
     */</comment>
    <if>if <condition>(<expr><name>patlen</name> == 1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name>p0</name> <init>= <expr>*<name>pat</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>c</name> <init>= <expr><name>text</name></expr></init>, *<name>end</name> <init>= <expr><name>text</name> + <name>textlen</name></expr></init></decl>;</init> <condition><expr><name>c</name> != <name>end</name></expr>;</condition> <incr><expr>++<name>c</name></expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>c</name> == <name>p0</name></expr>)</condition><then>
                <return>return <expr><name>c</name> - <name>text</name></expr>;</return></then></if>
        }</block></for>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If the text or pattern string is short, BMH will be more expensive than
     * the basic linear scan due to initialization cost and a more complex loop
     * body. While the correct threshold is input-dependent, we can make a few
     * conservative observations:
     *  - When |textlen| is "big enough", the initialization time will be
     *    proportionally small, so the worst-case slowdown is minimized.
     *  - When |patlen| is "too small", even the best case for BMH will be
     *    slower than a simple scan for large |textlen| due to the more complex
     *    loop body of BMH.
     * From this, the values for "big enough" and "too small" are determined
     * empirically. See bug 526348.
     */</comment>
    <if>if <condition>(<expr><name>textlen</name> &gt;= 512 &amp;&amp; <name>patlen</name> &gt;= 11 &amp;&amp; <name>patlen</name> &lt;= <name>sBMHPatLenMax</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsint</name></type> <name>index</name> <init>= <expr><call><name>js_BoyerMooreHorspool</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>textlen</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> != <name>sBMHBadPattern</name></expr>)</condition><then>
            <return>return <expr><name>index</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/*
     * For big patterns with large potential overlap we want the SIMD-optimized
     * speed of memcmp. For small patterns, a simple loop is faster.
     *
     * FIXME: Linux memcmp performance is sad and the manual loop is faster.
     */</comment>
    <return>return
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
           <expr><name>patlen</name> &gt; 128 ? <call><name><name>UnrolledMatch</name><argument_list>&lt;<argument><expr><name>MemCmp</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>textlen</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call>
                        :
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                          <call><name><name>UnrolledMatch</name><argument_list>&lt;<argument><expr><name>ManualCmp</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>textlen</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>sRopeMatchThresholdRatioLog2</name> <init>= <expr>5</expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * RopeMatch takes the text to search, the patern to search for in the text.
 * RopeMatch returns false on OOM and otherwise returns the match index through
 * the 'match' outparam (-1 for not found).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RopeMatch</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>textstr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>jsuint</name></type> <name>patlen</name></decl></param>, <param><decl><type><name>jsint</name> *</type><name>match</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>textstr</name>-&gt;<name>isRope</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>patlen</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>match</name> = 0</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> &lt; <name>patlen</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>match</name> = -1</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * List of leaf nodes in the rope. If we run out of memory when trying to
     * append to this list, we can still fall back to StringMatch, so use the
     * system allocator so we don't report OOM in that case.
     */</comment>
    <decl_stmt><decl><type><name><name>Vector</name><argument_list>&lt;<argument><expr><name>JSString</name> *</expr></argument>, <argument><expr>16</expr></argument>, <argument><expr><name>SystemAllocPolicy</name></expr></argument>&gt;</argument_list></name></type> <name>strs</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We don't want to do rope matching if there is a poor node-to-char ratio,
     * since this means spending a lot of time in the match loop below. We also
     * need to build the list of leaf nodes. Do both here: iterate over the
     * nodes so long as there are not too many.
     */</comment>
    <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>textstrlen</name> <init>= <expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>threshold</name> <init>= <expr><name>textstrlen</name> &gt;&gt; <name>sRopeMatchThresholdRatioLog2</name></expr></init></decl>;</decl_stmt>
        <function_decl><type><name>StringSegmentRange</name></type> <name>r</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>!<call><name><name>r</name>.<name>init</name></name><argument_list>(<argument><expr><name>textstr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <while>while <condition>(<expr>!<call><name><name>r</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <if>if <condition>(<expr><name>threshold</name>-- == 0 || !<call><name><name>strs</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>front</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>textstr</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
                    <return>return <expr>false</expr>;</return></then></if>
                <expr_stmt><expr>*<name>match</name> = <call><name>StringMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>textstrlen</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>true</expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name><name>r</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></while>
    }</block>

    <comment type="block">/* Absolute offset from the beginning of the logical string textstr. */</comment>
    <decl_stmt><decl><type><name>jsint</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="line">// TODO: consider branching to a simple loop if patlen == 1</comment>

    <for>for (<init><decl><type><name>JSString</name> **</type><name>outerp</name> <init>= <expr><call><name><name>strs</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>outerp</name> != <call><name><name>strs</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>outerp</name></expr></incr>) <block>{
        <comment type="block">/* First try to match without spanning two nodes. */</comment>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>outer</name> <init>= <expr>*<name>outerp</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>outer</name>-&gt;<name>nonRopeChars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name><name>outer</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsint</name></type> <name>matchResult</name> <init>= <expr><call><name>StringMatch</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>matchResult</name> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>match</name> = <name>pos</name> + <name>matchResult</name></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <comment type="block">/* Test the overlap. */</comment>
        <decl_stmt><decl><type><name>JSString</name> **</type><name>innerp</name> <init>= <expr><name>outerp</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Start searching at the first place where StringMatch wouldn't have
         * found the match.
         */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *<specifier>const</specifier></type> <name>text</name> <init>= <expr><name>chars</name> + (<name>patlen</name> &gt; <name>len</name> ? 0 : <name>len</name> - <name>patlen</name> + 1)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *<specifier>const</specifier></type> <name>textend</name> <init>= <expr><name>chars</name> + <name>len</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name>p0</name> <init>= <expr>*<name>pat</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *<specifier>const</specifier></type> <name>p1</name> <init>= <expr><name>pat</name> + 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *<specifier>const</specifier></type> <name>patend</name> <init>= <expr><name>pat</name> + <name>patlen</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t</name> <init>= <expr><name>text</name></expr></init></decl>;</init> <condition><expr><name>t</name> != <name>textend</name></expr>;</condition> <incr/>) <block>{
            <if>if <condition>(<expr>*<name>t</name>++ != <name>p0</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>ttend</name> <init>= <expr><name>textend</name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pp</name> <init>= <expr><name>p1</name></expr></init>, *<name>tt</name> <init>= <expr><name>t</name></expr></init></decl>;</init> <condition><expr><name>pp</name> != <name>patend</name></expr>;</condition> <incr><expr>++<name>pp</name></expr>, <expr>++<name>tt</name></expr></incr>) <block>{
                <while>while <condition>(<expr><name>tt</name> == <name>ttend</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr>++<name>innerp</name> == <call><name><name>strs</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr>*<name>match</name> = -1</expr>;</expr_stmt>
                        <return>return <expr>true</expr>;</return>
                    }</block></then></if>
                    <decl_stmt><decl><type><name>JSString</name> *</type><name>inner</name> <init>= <expr>*<name>innerp</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>tt</name> = <call><name><name>inner</name>-&gt;<name>nonRopeChars</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ttend</name> = <name>tt</name> + <call><name><name>inner</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></while>
                <if>if <condition>(<expr>*<name>pp</name> != *<name>tt</name></expr>)</condition><then>
                    <goto>goto <name>break_continue</name>;</goto></then></if>
            }</block></for>

            <comment type="block">/* Matched! */</comment>
            <expr_stmt><expr>*<name>match</name> = <name>pos</name> + (<name>t</name> - <name>chars</name>) - 1</expr>;</expr_stmt>  <comment type="block">/* -1 because of *t++ above */</comment>
            <return>return <expr>true</expr>;</return>

          <label><name>break_continue</name>:</label><empty_stmt>;</empty_stmt>
        }</block></for>

        <expr_stmt><expr><name>pos</name> += <name>len</name></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr>*<name>match</name> = -1</expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_indexOf</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{

    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>patstr</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>patstr</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>jsuint</name></type> <name>textlen</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>text</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>text</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>jsuint</name></type> <name>patlen</name> <init>= <expr><call><name><name>patstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name> <init>= <expr><call><name><name>patstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsuint</name></type> <name>start</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>argc</name> &gt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>isInt32</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsint</name></type> <name>i</name> <init>= <expr><name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>toInt32</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>i</name> &lt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>jsuint</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> &gt; <name>textlen</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>start</name> = <name>textlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>textlen</name> = 0</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>start</name> = <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>text</name> += <name>start</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>textlen</name> -= <name>start</name></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>d</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>d</name> &lt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>d</name> &gt; <name>textlen</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>start</name> = <name>textlen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>textlen</name> = 0</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>start</name> = (<name>jsint</name>)<name>d</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>text</name> += <name>start</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>textlen</name> -= <name>start</name></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></else></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><name>jsint</name></type> <name>match</name> <init>= <expr><call><name>StringMatch</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>textlen</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr>(<name>match</name> == -1) ? -1 : <name>start</name> + <name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_lastIndexOf</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>textstr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>textlen</name> <init>= <expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>text</name> <init>= <expr><call><name><name>textstr</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>text</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>patstr</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>patstr</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>patlen</name> <init>= <expr><call><name><name>patstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>pat</name> <init>= <expr><call><name><name>patstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name> <init>= <expr><name>textlen</name> - <name>patlen</name></expr></init></decl>;</decl_stmt> <comment type="line">// Start searching here</comment>
    <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>argc</name> &gt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>isInt32</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsint</name></type> <name>j</name> <init>= <expr><name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>toInt32</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>j</name> &lt;= 0</expr>)</condition><then>
                <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>j</name> &lt; <name>i</name></expr>)</condition><then>
                <expr_stmt><expr><name>i</name> = <name>j</name></expr>;</expr_stmt></then></if></else></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>d</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>d</name> &lt;= 0</expr>)</condition><then>
                    <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>d</name> &lt; <name>i</name></expr>)</condition><then>
                    <expr_stmt><expr><name>i</name> = (<name>jsint</name>)<name>d</name></expr>;</expr_stmt></then></if></else></if>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>patlen</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t</name> <init>= <expr><name>text</name> + <name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>textend</name> <init>= <expr><name>text</name> - 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name>p0</name> <init>= <expr>*<name>pat</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>patNext</name> <init>= <expr><name>pat</name> + 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>patEnd</name> <init>= <expr><name>pat</name> + <name>patlen</name></expr></init></decl>;</decl_stmt>

    <for>for (<init>;</init> <condition><expr><name>t</name> != <name>textend</name></expr>;</condition> <incr><expr>--<name>t</name></expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>t</name> == <name>p0</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t1</name> <init>= <expr><name>t</name> + 1</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>p1</name> <init>= <expr><name>patNext</name></expr></init></decl>;</init> <condition><expr><name>p1</name> != <name>patEnd</name></expr>;</condition> <incr><expr>++<name>p1</name></expr>, <expr>++<name>t1</name></expr></incr>) <block>{
                <if>if <condition>(<expr>*<name>t1</name> != *<name>p1</name></expr>)</condition><then>
                    <goto>goto <name>break_continue</name>;</goto></then></if>
            }</block></for>
            <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><name>t</name> - <name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
      <label><name>break_continue</name>:</label><empty_stmt>;</empty_stmt>
    }</block></for>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>js_TrimString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>trimLeft</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>trimRight</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>begin</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>end</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>trimLeft</name></expr>)</condition><then> <block>{
        <while>while <condition>(<expr><name>begin</name> &lt; <name>length</name> &amp;&amp; <call><name>JS_ISSPACE</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>begin</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>++<name>begin</name></expr>;</expr_stmt></while>
    }</block></then></if>

    <if>if <condition>(<expr><name>trimRight</name></expr>)</condition><then> <block>{
        <while>while <condition>(<expr><name>end</name> &gt; <name>begin</name> &amp;&amp; <call><name>JS_ISSPACE</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>end</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>--<name>end</name></expr>;</expr_stmt></while>
    }</block></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name> - <name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_trim</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_TrimString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_trimLeft</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_TrimString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_trimRight</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_TrimString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Perl-inspired string functions.
 */</comment>

<comment type="block">/* Result of a successfully performed flat match. */</comment>
<class>class <name>FlatMatch</name>
<block>{<private type="default">
    <decl_stmt><decl><type><name>JSLinearString</name>  *</type><name>patstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>    *</type><name>pat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>patlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>           <name>match_</name></decl>;</decl_stmt>

    <class_decl><specifier>friend</specifier> class <name>RegExpGuard</name>;</class_decl>

  </private><public>public:
    <constructor><name>FlatMatch</name><parameter_list>()</parameter_list> <member_list>: <call><name>patstr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor> <comment type="block">/* Old GCC wants this initialization. */</comment>
    <function><type><name>JSString</name> *</type><name>pattern</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name>patstr</name></expr>;</return> }</block></function>
    <function><type><name>size_t</name></type> <name>patternLength</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name>patlen</name></expr>;</return> }</block></function>

    <comment type="block">/*
     * @note    The match is -1 when the match is performed successfully,
     *          but no match is found.
     */</comment>
    <function><type><name>int32</name></type> <name>match</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name>match_</name></expr>;</return> }</block></function>
</public>}</block>;</class>

<comment type="block">/* A regexp and optional associated object. */</comment>
<class>class <name>RegExpPair</name>
<block>{<private type="default">
    <decl_stmt><decl><type><name>JSObject</name>    *</type><name>reobj_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegExp</name>      *</type><name>re_</name></decl>;</decl_stmt>

    <constructor><specifier>explicit</specifier> <name>RegExpPair</name><parameter_list>(<param><decl><type><name>RegExp</name> *</type><name>re</name></decl></param>)</parameter_list><member_list>: <call><name>re_</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
    <class_decl><specifier>friend</specifier> class <name>RegExpGuard</name>;</class_decl>

  </private><public>public:
    <comment type="block">/* @note    May be null. */</comment>
    <function><type><name>JSObject</name> *</type><name>reobj</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name>reobj_</name></expr>;</return> }</block></function>
    <function><type><name>RegExp</name> &amp;</type><name>re</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>re_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr>*<name>re_</name></expr>;</return> }</block></function>
</public>}</block>;</class>

<comment type="block">/*
 * RegExpGuard factors logic out of String regexp operations.
 *
 * @param optarg    Indicates in which argument position RegExp
 *                  flags will be found, if present. This is a Mozilla
 *                  extension and not part of any ECMA spec.
 */</comment>
<class>class <name>RegExpGuard</name>
<block>{<private type="default">
    <constructor_decl><name>RegExpGuard</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>RegExpGuard</name> &amp;</decl></param>)</parameter_list>;</constructor_decl>
    <function_decl><type><name>void</name></type> <name>operator=</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>RegExpGuard</name> &amp;</decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>JSContext</name>   *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegExpPair</name></type>  <name>rep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FlatMatch</name></type>   <name>fm</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Upper bound on the number of characters we are willing to potentially
     * waste on searching for RegExp meta-characters.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_FLAT_PAT_LEN</name> <init>= <expr>256</expr></init></decl>;</decl_stmt>

    <function><type><specifier>static</specifier> <name>JSString</name> *</type><name>flattenPattern</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSLinearString</name> *</type><name>patstr</name></decl></param>)</parameter_list> <block>{
        <function_decl><type><name>JSCharBuffer</name></type> <name>cb</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>reserve</name></name><argument_list>(<argument><expr><call><name><name>patstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jschar</name></type> <name>ESCAPE_CHAR</name> <init>= <expr>'\\'</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>patstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name><name>patstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>it</name> <init>= <expr><name>chars</name></expr></init></decl>;</init> <condition><expr><name>it</name> != <name>chars</name> + <name>len</name></expr>;</condition> <incr><expr>++<name>it</name></expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>RegExp</name>::<name>isMetaChar</name></name><argument_list>(<argument><expr>*<name>it</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>ESCAPE_CHAR</name></expr></argument>)</argument_list></call> || !<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr>*<name>it</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr>*<name>it</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></else></if>
        }</block></for>
        <return>return <expr><call><name>js_NewStringFromCharBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

  </private><public>public:
    <constructor><specifier>explicit</specifier> <name>RegExpGuard</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list> <member_list>: <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>, <call><name>rep</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

    <destructor><name>~<name>RegExpGuard</name></name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>rep</name>.<name>re_</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>rep</name>.<name>re_</name>-&gt;<name>decref</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></destructor>

    <comment type="block">/* init must succeed in order to call tryFlatMatch or normalizeRegExp. */</comment>
    <function><type><name>bool</name></type>
    <name>init</name><parameter_list>(<param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>argc</name> != 0 &amp;&amp; <call><name>VALUE_IS_REGEXP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>rep</name>.<name>reobj_</name></name> = &amp;<name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>toObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rep</name>.<name>re_</name></name> = <call><name><name>RegExp</name>::<name>extractFrom</name></name><argument_list>(<argument><expr><name><name>rep</name>.<name>reobj_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rep</name>.<name>re_</name>-&gt;<name>incref</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>fm</name>.<name>patstr</name></name> = <call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>fm</name>.<name>patstr</name></name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></else></if>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="block">/*
     * Attempt to match |patstr| to |textstr|. A flags argument, metachars in the
     * pattern string, or a lengthy pattern string can thwart this process.
     *
     * @param checkMetaChars    Look for regexp metachars in the pattern string.
     * @return                  Whether flat matching could be used.
     *
     * N.B. tryFlatMatch returns NULL on OOM, so the caller must check cx-&gt;throwing.
     */</comment>
    <function><type><specifier>const</specifier> <name>FlatMatch</name> *</type>
    <name>tryFlatMatch</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>textstr</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>optarg</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>,
                 <param><decl><type><name>bool</name></type> <name>checkMetaChars</name> <init>= <expr>true</expr></init></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>rep</name>.<name>re_</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>fm</name>.<name>pat</name></name> = <call><name><name>fm</name>.<name>patstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fm</name>.<name>patlen</name></name> = <call><name><name>fm</name>.<name>patstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>optarg</name> &lt; <name>argc</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>checkMetaChars</name> &amp;&amp;
            (<name><name>fm</name>.<name>patlen</name></name> &gt; <name>MAX_FLAT_PAT_LEN</name> || <call><name><name>RegExp</name>::<name>hasMetaChars</name></name><argument_list>(<argument><expr><name><name>fm</name>.<name>pat</name></name></expr></argument>, <argument><expr><name><name>fm</name>.<name>patlen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * textstr could be a rope, so we want to avoid flattening it for as
         * long as possible.
         */</comment>
        <if>if <condition>(<expr><call><name><name>textstr</name>-&gt;<name>isRope</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>RopeMatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>, <argument><expr><name><name>fm</name>.<name>pat</name></name></expr></argument>, <argument><expr><name><name>fm</name>.<name>patlen</name></name></expr></argument>, <argument><expr>&amp;<name><name>fm</name>.<name>match_</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>text</name> <init>= <expr><call><name><name>textstr</name>-&gt;<name>nonRopeChars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>textlen</name> <init>= <expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>fm</name>.<name>match_</name></name> = <call><name>StringMatch</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>textlen</name></expr></argument>, <argument><expr><name><name>fm</name>.<name>pat</name></name></expr></argument>, <argument><expr><name><name>fm</name>.<name>patlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr>&amp;<name>fm</name></expr>;</return>
    }</block></function>

    <comment type="block">/* If the pattern is not already a regular expression, make it so. */</comment>
    <function><type><specifier>const</specifier> <name>RegExpPair</name> *</type>
    <name>normalizeRegExp</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>flat</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>optarg</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* If we don't have a RegExp, build RegExp from pattern string. */</comment>
        <if>if <condition>(<expr><name><name>rep</name>.<name>re_</name></name></expr>)</condition><then>
            <return>return <expr>&amp;<name>rep</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>JSString</name> *</type><name>opt</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>optarg</name> &lt; <name>argc</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>opt</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2 + <name>optarg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>opt</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>opt</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>JSString</name> *</type><name>patstr</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>flat</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>patstr</name> = <call><name>flattenPattern</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fm</name>.<name>patstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>patstr</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>patstr</name> = <name><name>fm</name>.<name>patstr</name></name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>patstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>rep</name>.<name>re_</name></name> = <call><name><name>RegExp</name>::<name>createFlagged</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>patstr</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>rep</name>.<name>re_</name></name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>rep</name>.<name>reobj_</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr>&amp;<name>rep</name></expr>;</return>
    }</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUG</name></expr></cpp:if>
    <function><type><name>bool</name></type> <name>hasRegExpPair</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name><name>rep</name>.<name>re_</name></name></expr>;</return> }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</class>

<comment type="block">/* js_ExecuteRegExp indicates success in two ways, based on the 'test' flag. */</comment>
<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
<name>Matched</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>test</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>test</name> ? <call><name><name>v</name>.<name>isTrue</name></name><argument_list>()</argument_list></call> : !<call><name><name>v</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<typedef>typedef <function_decl><type><name>bool</name></type> (*<name>DoMatchCallback</name>)<parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * BitOR-ing these flags allows the DoMatch caller to control when how the
 * RegExp engine is called and when callbacks are fired.
 */</comment>
<enum>enum <name>MatchControlFlags</name> <block>{
   <decl><name>TEST_GLOBAL_BIT</name>         <init>= <expr>0x1</expr></init></decl>, <comment type="block">/* use RegExp.test for global regexps */</comment>
   <decl><name>TEST_SINGLE_BIT</name>         <init>= <expr>0x2</expr></init></decl>, <comment type="block">/* use RegExp.test for non-global regexps */</comment>
   <decl><name>CALLBACK_ON_SINGLE_BIT</name>  <init>= <expr>0x4</expr></init></decl>, <comment type="block">/* fire callback on non-global match */</comment>

   <decl><name>MATCH_ARGS</name>    <init>= <expr><name>TEST_GLOBAL_BIT</name></expr></init></decl>,
   <decl><name>MATCHALL_ARGS</name> <init>= <expr><name>CALLBACK_ON_SINGLE_BIT</name></expr></init></decl>,
   <decl><name>REPLACE_ARGS</name>  <init>= <expr><name>TEST_GLOBAL_BIT</name> | <name>TEST_SINGLE_BIT</name> | <name>CALLBACK_ON_SINGLE_BIT</name></expr></init></decl>
}</block>;</enum>

<comment type="block">/* Factor out looping and matching logic. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DoMatch</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>RegExpPair</name> &amp;</type><name>rep</name></decl></param>,
        <param><decl><type><name>DoMatchCallback</name></type> <name>callback</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><name>MatchControlFlags</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RegExp</name> &amp;</type><name>re</name> <init>= <expr><call><name><name>rep</name>.<name>re</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>re</name>.<name>global</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* global matching ('g') */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>testGlobal</name> <init>= <expr><name>flags</name> &amp; <name>TEST_GLOBAL_BIT</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>rep</name>.<name>reobj</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>rep</name>.<name>reobj</name></name><argument_list>()</argument_list></call>-&gt;<call><name>zeroRegExpLastIndex</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr>0</expr></init>, <name>i</name> <init>= <expr>0</expr></init>, <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>length</name></expr>;</condition> <incr><expr>++<name>count</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name><name>re</name>.<name>execute</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr><name>testGlobal</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>Matched</name><argument_list>(<argument><expr><name>testGlobal</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr>!<call><name>callback</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name><name>res</name>-&gt;<name>matched</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></then> <else>else <block>{
        <comment type="block">/* single match */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>testSingle</name> <init>= <expr>!!(<name>flags</name> &amp; <name>TEST_SINGLE_BIT</name>)</expr></init>,
             <name>callbackOnSingle</name> <init>= <expr>!!(<name>flags</name> &amp; <name>CALLBACK_ON_SINGLE_BIT</name>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>re</name>.<name>execute</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr><name>testSingle</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <if>if <condition>(<expr><name>callbackOnSingle</name> &amp;&amp; <call><name>Matched</name><argument_list>(<argument><expr><name>testSingle</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>callback</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
    }</block></else></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BuildFlatMatchArray</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>textstr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>FlatMatch</name> &amp;</type><name>fm</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <comment type="block">/* For this non-global match, produce a RegExp.exec-style array. */</comment>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>NewSlowEmptyArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setObject</name></name><argument_list>(<argument><expr>*<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>INT_TO_JSID</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><call><name><name>fm</name>.<name>pattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>indexAtom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>Int32Value</name><argument_list>(<argument><expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>inputAtom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>textstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<typedef>typedef <type><name>JSObject</name> **</type><name>MatchArgType</name>;</typedef>

<comment type="block">/*
 * DoMatch will only callback on global matches, hence this function builds
 * only the "array of matches" returned by match on global regexps.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MatchCallback</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>count</name> &lt;= <name>JSID_INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* by max string length */</comment>

    <decl_stmt><decl><type><name>JSObject</name> *&amp;</type><name>arrayobj</name> <init>= <expr>*<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>MatchArgType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>arrayobj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>arrayobj</name> = <call><name>NewDenseEmptyArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>arrayobj</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>Value</name></type> <name>v</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>res</name>-&gt;<name>createLastMatch</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSAutoResolveFlags</name></type> <name>rf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSRESOLVE_QUALIFIED</name> | <name>JSRESOLVE_ASSIGNING</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <return>return <expr>!!<call><name><name>arrayobj</name>-&gt;<name>setProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>INT_TO_JSID</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_match</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>RegExpGuard</name></type> <name>g</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name><name>g</name>.<name>init</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<decl><type><specifier>const</specifier> <name>FlatMatch</name> *</type><name>fm</name> <init>= <expr><call><name><name>g</name>.<name>tryFlatMatch</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
        <return>return <expr><call><name>BuildFlatMatchArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>*<name>fm</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>throwing</name></name></expr>)</condition><then>  <comment type="block">/* from tryFlatMatch */</comment>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>RegExpPair</name> *</type><name>rep</name> <init>= <expr><call><name><name>g</name>.<name>normalizeRegExp</name></name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>rep</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <function_decl><type><name>AutoObjectRooter</name></type> <name>array</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>MatchArgType</name></type> <name>arg</name> <init>= <expr><call><name><name>array</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegExpStatics</name> *</type><name>res</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>regExpStatics</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>DoMatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>*<name>rep</name></expr></argument>, <argument><expr><name>MatchCallback</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>MATCH_ARGS</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* When not global, DoMatch will leave |RegExp.exec()| in *vp. */</comment>
    <if>if <condition>(<expr><call><name><name>rep</name>-&gt;<name>re</name></name><argument_list>()</argument_list></call>.<call><name>global</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setObjectOrNull</name></name><argument_list>(<argument><expr><call><name><name>array</name>.<name>object</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_search</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>RegExpGuard</name></type> <name>g</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name><name>g</name>.<name>init</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<decl><type><specifier>const</specifier> <name>FlatMatch</name> *</type><name>fm</name> <init>= <expr><call><name><name>g</name>.<name>tryFlatMatch</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><call><name><name>fm</name>-&gt;<name>match</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>throwing</name></name></expr>)</condition><then>  <comment type="block">/* from tryFlatMatch */</comment>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><specifier>const</specifier> <name>RegExpPair</name> *</type><name>rep</name> <init>= <expr><call><name><name>g</name>.<name>normalizeRegExp</name></name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>rep</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>RegExpStatics</name> *</type><name>res</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>regExpStatics</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>rep</name>-&gt;<name>re</name></name><argument_list>()</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name><name>vp</name>-&gt;<name>isTrue</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr><call><name><name>res</name>-&gt;<name>matchStart</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setInt32</name></name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<struct>struct <name>ReplaceData</name>
<block>{<public type="default">
    <constructor><name>ReplaceData</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
     <member_list>: <call><name>g</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>, <call><name>cb</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <decl_stmt><decl><type><name>JSString</name>           *</type><name>str</name></decl>;</decl_stmt>           <comment type="block">/* 'this' parameter object as a string */</comment>
    <decl_stmt><decl><type><name>RegExpGuard</name></type>        <name>g</name></decl>;</decl_stmt>              <comment type="block">/* regexp parameter object and private data */</comment>
    <decl_stmt><decl><type><name>JSObject</name>           *</type><name>lambda</name></decl>;</decl_stmt>        <comment type="block">/* replacement function object or null */</comment>
    <decl_stmt><decl><type><name>JSObject</name>           *</type><name>elembase</name></decl>;</decl_stmt>      <comment type="block">/* object for function(a){return b[a]} replace */</comment>
    <decl_stmt><decl><type><name>JSLinearString</name>     *</type><name>repstr</name></decl>;</decl_stmt>        <comment type="block">/* replacement string */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>       *</type><name>dollar</name></decl>;</decl_stmt>        <comment type="block">/* null or pointer to first $ in repstr */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>       *</type><name>dollarEnd</name></decl>;</decl_stmt>     <comment type="block">/* limit pointer for js_strchr_limit */</comment>
    <decl_stmt><decl><type><name>jsint</name></type>              <name>index</name></decl>;</decl_stmt>          <comment type="block">/* index in result of next replacement */</comment>
    <decl_stmt><decl><type><name>jsint</name></type>              <name>leftIndex</name></decl>;</decl_stmt>      <comment type="block">/* left context index in str-&gt;chars */</comment>
    <decl_stmt><decl><type><name>JSSubString</name></type>        <name>dollarStr</name></decl>;</decl_stmt>      <comment type="block">/* for "$$" InterpretDollar result */</comment>
    <decl_stmt><decl><type><name>bool</name></type>               <name>calledBack</name></decl>;</decl_stmt>     <comment type="block">/* record whether callback has been called */</comment>
    <decl_stmt><decl><type><name>InvokeSessionGuard</name></type> <name>session</name></decl>;</decl_stmt>        <comment type="block">/* arguments for repeated lambda Invoke call */</comment>
    <decl_stmt><decl><type><name>InvokeArgsGuard</name></type>    <name>singleShot</name></decl>;</decl_stmt>     <comment type="block">/* arguments for single lambda Invoke call */</comment>
    <decl_stmt><decl><type><name>JSCharBuffer</name></type>       <name>cb</name></decl>;</decl_stmt>             <comment type="block">/* buffer built during DoMatch */</comment>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>InterpretDollar</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>dp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>ep</name></decl></param>,
                <param><decl><type><name>ReplaceData</name> &amp;</type><name>rdata</name></decl></param>, <param><decl><type><name>JSSubString</name> *</type><name>out</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>skip</name></decl></param>,
                <param><decl><type><specifier>volatile</specifier> <name><name>JSContext</name>::<name>DollarPath</name></name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>dp</name> == '$'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there is only a dollar, bail now */</comment>
    <if>if <condition>(<expr><name>dp</name> + 1 &gt;= <name>ep</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* Interpret all Perl match-induced dollar variables. */</comment>
    <decl_stmt><decl><type><name>jschar</name></type> <name>dc</name> <init>= <expr><name><name>dp</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JS7_ISDEC</name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* ECMA-262 Edition 3: 1-9 or 01-99 */</comment>
        <decl_stmt><decl><type><name>uintN</name></type> <name>num</name> <init>= <expr><call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>num</name> &gt; <call><name><name>res</name>-&gt;<name>parenCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name> <init>= <expr><name>dp</name> + 2</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cp</name> &lt; <name>ep</name> &amp;&amp; (<name>dc</name> = *<name>cp</name>, <call><name>JS7_ISDEC</name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uintN</name></type> <name>tmp</name> <init>= <expr>10 * <name>num</name> + <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>tmp</name> &lt;= <call><name><name>res</name>-&gt;<name>parenCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>num</name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>num</name> == 0</expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <expr_stmt><expr>*<name>skip</name> = <name>cp</name> - <name>dp</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>JS_CRASH_UNLESS</name><argument_list>(<argument><expr><name>num</name> &lt;= <call><name><name>res</name>-&gt;<name>parenCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>num</name></expr>)</condition> <block>{
          <case>case <expr>1</expr>: <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_1</name></name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr>2</expr>: <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_2</name></name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr>3</expr>: <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_3</name></name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr>4</expr>: <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_4</name></name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr>5</expr>: <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_5</name></name></expr>;</expr_stmt> <break>break;</break>
          </case><default>default: <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_OTHER</name></name></expr>;</expr_stmt>
        </default>}</block></switch>

        <comment type="block">/* 
         * Note: we index to get the paren with the (1-indexed) pair
         * number, as opposed to a (0-indexed) paren number.
         */</comment>
        <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getParen</name></name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>skip</name> = 2</expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>dc</name></expr>)</condition> <block>{
      <case>case <expr>'$'</expr>:
        <expr_stmt><expr><name><name>rdata</name>.<name>dollarStr</name>.<name>chars</name></name> = <name>dp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>dollarStr</name>.<name>length</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>out</name> = <name><name>rdata</name>.<name>dollarStr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_LITERAL</name></name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
      </case><case>case <expr>'&amp;'</expr>:
        <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getLastMatch</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_AMP</name></name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
      </case><case>case <expr>'+'</expr>:
        <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getLastParen</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_PLUS</name></name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
      </case><case>case <expr>'`'</expr>:
        <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getLeftContext</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_TICK</name></name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
      </case><case>case <expr>'\''</expr>:
        <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getRightContext</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>path</name> = <name><name>JSContext</name>::<name>DOLLAR_QUOT</name></name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    </case>}</block></switch>
    <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FindReplaceLength</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>ReplaceData</name> &amp;</type><name>rdata</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>sizep</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>base</name> <init>= <expr><name><name>rdata</name>.<name>elembase</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>base</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * The base object is used when replace was passed a lambda which looks like
         * 'function(a) { return b[a]; }' for the base object b.  b will not change
         * in the course of the replace unless we end up making a scripted call due
         * to accessing a scripted getter or a value with a scripted toString.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rdata</name>.<name>lambda</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>base</name>-&gt;<name>getOps</name></name><argument_list>()</argument_list></call>-&gt;<name>lookupProperty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>base</name>-&gt;<name>getOps</name></name><argument_list>()</argument_list></call>-&gt;<name>getProperty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Value</name></type> <name>match</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>res</name>-&gt;<name>createLastMatch</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name><name>match</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>str</name>-&gt;<name>isAtomized</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>atom</name> = <call><name>STRING_TO_ATOM</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>atom</name> = <call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></else></if>
        <decl_stmt><decl><type><name>jsid</name></type> <name>id</name> <init>= <expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>JSObject</name> *</type><name>holder</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSProperty</name> *</type><name>prop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>js_LookupPropertyWithFlags</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>JSRESOLVE_QUALIFIED</name></expr></argument>, <argument><expr>&amp;<name>holder</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* Only handle the case where the property exists and is on this object. */</comment>
        <if>if <condition>(<expr><name>prop</name> &amp;&amp; <name>holder</name> == <name>base</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Shape</name> *</type><name>shape</name> <init>= <expr>(<name>Shape</name> *) <name>prop</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>shape</name>-&gt;<name>slot</name></name> != <name>SHAPE_INVALID_SLOT</name> &amp;&amp; <call><name><name>shape</name>-&gt;<name>hasDefaultGetter</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>Value</name></type> <name>value</name> <init>= <expr><call><name><name>base</name>-&gt;<name>getSlot</name></name><argument_list>(<argument><expr><name><name>shape</name>-&gt;<name>slot</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>value</name>.<name>isString</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>rdata</name>.<name>repstr</name></name> = <call><name><name>value</name>.<name>toString</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ensureLinear</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name><name>rdata</name>.<name>repstr</name></name></expr>)</condition><then>
                        <return>return <expr>false</expr>;</return></then></if>
                    <expr_stmt><expr>*<name>sizep</name> = <call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>true</expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/*
         * Couldn't handle this property, fall through and despecialize to the
         * general lambda case.
         */</comment>
        <expr_stmt><expr><name><name>rdata</name>.<name>elembase</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSObject</name> *</type><name>lambda</name> <init>= <expr><name><name>rdata</name>.<name>lambda</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>lambda</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * In the lambda case, not only do we find the replacement string's
         * length, we compute repstr and return it via rdata for use within
         * DoReplace.  The lambda is called with arguments ($&amp;, $1, $2, ...,
         * index, input), i.e., all the properties of a regexp match array.
         * For $&amp;, etc., we must create string jsvals from cx-&gt;regExpStatics.
         * We grab up stack space to keep the newborn strings GC-rooted.
         */</comment>
        <decl_stmt><decl><type><name>uintN</name></type> <name>p</name> <init>= <expr><call><name><name>res</name>-&gt;<name>parenCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>argc</name> <init>= <expr>1 + <name>p</name> + 2</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>InvokeSessionGuard</name> &amp;</type><name>session</name> <init>= <expr><name><name>rdata</name>.<name>session</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>session</name>.<name>started</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>Value</name></type> <name>lambdav</name> <init>= <expr><call><name>ObjectValue</name><argument_list>(<argument><expr>*<name>lambda</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>session</name>.<name>start</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lambdav</name></expr></argument>, <argument><expr><call><name>UndefinedValue</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then></if>

        <function_decl><type><name>PreserveRegExpStatics</name></type> <name>staticsGuard</name><parameter_list>(<param><decl><type><name>res</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>!<call><name><name>staticsGuard</name>.<name>init</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* Push $&amp;, $1, $2, ... */</comment>
        <decl_stmt><decl><type><name>uintN</name></type> <name>argi</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>res</name>-&gt;<name>createLastMatch</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>session</name><index>[<expr><name>argi</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>res</name>-&gt;<name>parenCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name><name>res</name>-&gt;<name>createParen</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr>&amp;<name><name>session</name><index>[<expr><name>argi</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>

        <comment type="block">/* Push match index and input string. */</comment>
        <expr_stmt><expr><name><name>session</name><index>[<expr><name>argi</name>++</expr>]</index></name>.<call><name>setInt32</name><argument_list>(<argument><expr><call><name><name>res</name>-&gt;<name>matchStart</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>session</name><index>[<expr><name>argi</name></expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name><name>session</name>.<name>invoke</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* root repstr: rdata is on the stack, so scanned by conservative gc. */</comment>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>repstr</name> <init>= <expr><call><name>ValueToString_TestForStringInline</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>session</name>.<name>rval</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>repstr</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name><name>rdata</name>.<name>repstr</name></name> = <call><name><name>repstr</name>-&gt;<name>ensureLinear</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>rdata</name>.<name>repstr</name></name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr>*<name>sizep</name> = <call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>repstr</name> <init>= <expr><name><name>rdata</name>.<name>repstr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>replen</name> <init>= <expr><call><name><name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>JSContext</name>::<name>DollarPath</name></name></type> <name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>dp</name> <init>= <expr><name><name>rdata</name>.<name>dollar</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>ep</name> <init>= <expr><name><name>rdata</name>.<name>dollarEnd</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init> <condition><expr><name>dp</name></expr>;</condition> <incr><expr><name>dp</name> = <call><name>js_strchr_limit</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr>'$'</expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>JSSubString</name></type> <name>sub</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>skip</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>InterpretDollar</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>skip</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>replen</name> += <name><name>sub</name>.<name>length</name></name> - <name>skip</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dp</name> += <name>skip</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>dp</name>++</expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr>*<name>sizep</name> = <name>replen</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DoReplace</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>ReplaceData</name> &amp;</type><name>rdata</name></decl></param>, <param><decl><type><name>jschar</name> *</type><name>chars</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>repstr</name> <init>= <expr><name><name>rdata</name>.<name>repstr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>bp</name> <init>= <expr><name>cp</name> = <call><name><name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name><name>JSContext</name>::<name>DollarPath</name></name></type> <name>path</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>dollarPath</name></name> = &amp;<name>path</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name><name>sourceBuf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>blackBox</name></name> = <name>sourceBuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>dp</name> <init>= <expr><name><name>rdata</name>.<name>dollar</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>ep</name> <init>= <expr><name><name>rdata</name>.<name>dollarEnd</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init> <condition><expr><name>dp</name></expr>;</condition> <incr><expr><name>dp</name> = <call><name>js_strchr_limit</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr>'$'</expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>dp</name> - <name>cp</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>chars</name> += <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name> = <name>dp</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JSSubString</name></type> <name>sub</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>skip</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>InterpretDollar</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>skip</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
            <if>if <condition>(<expr>((<call><name>size_t</name><argument_list>(<argument><expr><name><name>sub</name>.<name>chars</name></name></expr></argument>)</argument_list></call> &amp; 0xfffffU) + <name><name>sub</name>.<name>length</name></name>) &gt; 0x100000U</expr>)</condition><then> <block>{
                <comment type="block">/* Going to cross a 0xffffe address, so take a gander at the replace value. */</comment>
                <decl_stmt><decl><type><specifier>volatile</specifier> <name>JSSubString</name></type> <name>vsub</name> <init>= <expr><name>sub</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>volatile</specifier> <specifier>const</specifier> <name>jschar</name> *</type><name>repstrChars</name> <init>= <expr><call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>volatile</specifier> <specifier>const</specifier> <name>jschar</name> *</type><name>repstrDollar</name> <init>= <expr><name><name>rdata</name>.<name>dollar</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>volatile</specifier> <specifier>const</specifier> <name>jschar</name> *</type><name>repstrDollarEnd</name> <init>= <expr><name><name>rdata</name>.<name>dollarEnd</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>cx</name>-&gt;<name>sub</name></name> = &amp;<name>vsub</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cx</name>-&gt;<name>repstrChars</name></name> = &amp;<name>repstrChars</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cx</name>-&gt;<name>repstrDollar</name></name> = &amp;<name>repstrDollar</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cx</name>-&gt;<name>repstrDollarEnd</name></name> = &amp;<name>repstrDollarEnd</name></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>dollarDistance</name> <init>= <expr><name><name>rdata</name>.<name>dollarEnd</name></name> - <name><name>rdata</name>.<name>dollar</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>JS_CRASH_UNLESS</name><argument_list>(<argument><expr><name>dollarDistance</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>volatile</specifier> <name>size_t</name></type> <name>peekLen</name> <init>= <expr><call><name>JS_MIN</name><argument_list>(<argument><expr><call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>128</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>cx</name>-&gt;<name>peekLen</name></name> = &amp;<name>peekLen</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>sourceBuf</name></expr></argument>, <argument><expr><call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>peekLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>len</name> = <name><name>sub</name>.<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name><name>sub</name>.<name>chars</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chars</name> += <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cp</name> += <name>skip</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dp</name> += <name>skip</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>dp</name>++</expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><call><name><name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - (<name>cp</name> - <name>bp</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReplaceRegExpCallback</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ReplaceData</name> &amp;</type><name>rdata</name> <init>= <expr>*<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>ReplaceData</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>rdata</name>.<name>calledBack</name></name> = true</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name><name>rdata</name>.<name>str</name>-&gt;<name>assertIsLinear</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* flattened for regexp */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>leftoff</name> <init>= <expr><name><name>rdata</name>.<name>leftIndex</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>left</name> <init>= <expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>leftoff</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>leftlen</name> <init>= <expr><call><name><name>res</name>-&gt;<name>matchStart</name></name><argument_list>()</argument_list></call> - <name>leftoff</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>rdata</name>.<name>leftIndex</name></name> = <call><name><name>res</name>-&gt;<name>matchLimit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>replen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* silence 'unused' warning */</comment>
    <if>if <condition>(<expr>!<call><name>FindReplaceLength</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>, <argument><expr>&amp;<name>replen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>growth</name> <init>= <expr><name>leftlen</name> + <name>replen</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>rdata</name>.<name>cb</name>.<name>growByUninitialized</name></name><argument_list>(<argument><expr><name>growth</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>rdata</name>.<name>cb</name>.<name>begin</name></name><argument_list>()</argument_list></call> + <name><name>rdata</name>.<name>index</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>rdata</name>.<name>index</name></name> += <name>growth</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>leftlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>chars</name> += <name>leftlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DoReplace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BuildFlatReplacement</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>textstr</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>repstr</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>FlatMatch</name> &amp;</type><name>fm</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>RopeBuilder</name></type> <name>builder</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>size_t</name></type> <name>match</name> <init>= <expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchEnd</name> <init>= <expr><name>match</name> + <call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>textstr</name>-&gt;<name>isRope</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we are replacing over a rope, avoid flattening it by iterating
         * through it, building a new rope.
         */</comment>
        <function_decl><type><name>StringSegmentRange</name></type> <name>r</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>!<call><name><name>r</name>.<name>init</name></name><argument_list>(<argument><expr><name>textstr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>!<call><name><name>r</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name><name>r</name>.<name>front</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>strEnd</name> <init>= <expr><name>pos</name> + <name>len</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>pos</name> <argument_list>&lt; <argument><expr><name>matchEnd</name> &amp;&amp; <name>strEnd</name></expr></argument> &gt;</argument_list></name> <name>match</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * We need to special-case any part of the rope that overlaps
                 * with the replacement string.
                 */</comment>
                <if>if <condition>(<expr><name>match</name> &gt;= <name>pos</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * If this part of the rope overlaps with the left side of
                     * the pattern, then it must be the only one to overlap with
                     * the first character in the pattern, so we include the
                     * replacement string here.
                     */</comment>
                    <decl_stmt><decl><type><name>JSString</name> *</type><name>leftSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>match</name> - <name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name>leftSide</name> ||
                        !<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>leftSide</name></expr></argument>)</argument_list></call> ||
                        !<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>repstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <return>return <expr>false</expr>;</return>
                    }</block></then></if>
                }</block></then></if>

                <comment type="block">/*
                 * If str runs off the end of the matched string, append the
                 * last part of str.
                 */</comment>
                <if>if <condition>(<expr><name>strEnd</name> &gt; <name>matchEnd</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSString</name> *</type><name>rightSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>matchEnd</name> - <name>pos</name></expr></argument>,
                                                                <argument><expr><name>strEnd</name> - <name>matchEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name>rightSide</name> || !<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>rightSide</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr>false</expr>;</return></then></if>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr>false</expr>;</return></then></if>
            }</block></else></if>
            <expr_stmt><expr><name>pos</name> += <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>r</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></while>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>leftSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>leftSide</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>rightSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>, <argument><expr><name>match</name> + <call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - <name>match</name> - <call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>rightSide</name> ||
            !<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>leftSide</name></expr></argument>)</argument_list></call> ||
            !<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>repstr</name></expr></argument>)</argument_list></call> ||
            !<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>rightSide</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>result</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Perform a linear-scan dollar substitution on the replacement text,
 * constructing a result string that looks like:
 *
 *      newstring = string[:matchStart] + dollarSub(replaceValue) + string[matchLimit:]
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>BuildDollarReplacement</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>textstrArg</name></decl></param>, <param><decl><type><name>JSLinearString</name> *</type><name>repstr</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>firstDollar</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>FlatMatch</name> &amp;</type><name>fm</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>textstr</name> <init>= <expr><call><name><name>textstrArg</name>-&gt;<name>ensureLinear</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>textstr</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> &lt;= <name>firstDollar</name> &amp;&amp; <name>firstDollar</name> &lt; <call><name><name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <call><name><name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchStart</name> <init>= <expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>matchLimit</name> <init>= <expr><name>matchStart</name> + <call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Most probably:
     *
     *      len(newstr) &gt;= len(orig) - len(match) + len(replacement)
     *
     * Note that dollar vars _could_ make the resulting text smaller than this.
     */</comment>
    <function_decl><type><name>JSCharBuffer</name></type> <name>newReplaceChars</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name><name>newReplaceChars</name>.<name>reserve</name></name><argument_list>(<argument><expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - <call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call> + <call><name><name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* Move the pre-dollar chunk in bulk. */</comment>
    <expr_stmt><expr><call><name>JS_ALWAYS_TRUE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>firstDollar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Move the rest char-by-char, interpreting dollars as we encounter them. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENSURE</name><parameter_list>(<param><type><name>__cond</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (!(__cond)) return false;</cpp:value></cpp:define>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>repstrLimit</name> <init>= <expr><call><name><name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <call><name><name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>it</name> <init>= <expr><name>firstDollar</name></expr></init></decl>;</init> <condition><expr><name>it</name> &lt; <name>repstrLimit</name></expr>;</condition> <incr><expr>++<name>it</name></expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>it</name> != '$' || <name>it</name> == <name>repstrLimit</name> - 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr>*<name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <switch>switch <condition>(<expr>*(<name>it</name> + 1)</expr>)</condition> <block>{
          <case>case <expr>'$'</expr>: <comment type="block">/* Eat one of the dollars. */</comment>
            <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr>*<name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr>'&amp;'</expr>:
            <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>textstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>matchStart</name></expr></argument>,
                                          <argument><expr><call><name><name>textstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>matchLimit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr>'`'</expr>:
            <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>textstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>textstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>matchStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr>'\''</expr>:
            <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>textstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>matchLimit</name></expr></argument>,
                                          <argument><expr><call><name><name>textstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default: <comment type="block">/* The dollar we saw was not special (no matter what its mother told it). */</comment>
            <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>newReplaceChars</name>.<name>append</name></name><argument_list>(<argument><expr>*<name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </default>}</block></switch>
        <expr_stmt><expr>++<name>it</name></expr>;</expr_stmt> <comment type="block">/* We always eat an extra char in the above switch. */</comment>
    }</block></for>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>leftSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>matchStart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><name>leftSide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>newReplace</name> <init>= <expr><call><name>js_NewStringFromCharBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>newReplaceChars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><name>newReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> &gt;= <name>matchLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>rightSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>textstr</name></expr></argument>, <argument><expr><name>matchLimit</name></expr></argument>,
                                                <argument><expr><call><name><name>textstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - <name>matchLimit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><name>rightSide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>RopeBuilder</name></type> <name>builder</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>ENSURE</name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>leftSide</name></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>newReplace</name></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>rightSide</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ENSURE</name></cpp:undef>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>result</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>str_replace_regexp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>ReplaceData</name> &amp;</type><name>rdata</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>RegExpPair</name> *</type><name>rep</name> <init>= <expr><call><name><name>rdata</name>.<name>g</name>.<name>normalizeRegExp</name></name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>rep</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><name><name>rdata</name>.<name>index</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rdata</name>.<name>leftIndex</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rdata</name>.<name>calledBack</name></name> = false</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>RegExpStatics</name> *</type><name>res</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>regExpStatics</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>DoMatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr>*<name>rep</name></expr></argument>, <argument><expr><name>ReplaceRegExpCallback</name></expr></argument>, <argument><expr>&amp;<name>rdata</name></expr></argument>, <argument><expr><name>REPLACE_ARGS</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr>!<name><name>rdata</name>.<name>calledBack</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Didn't match, so the string is unmodified. */</comment>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSSubString</name></type> <name>sub</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getRightContext</name></name><argument_list>(<argument><expr>&amp;<name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>rdata</name>.<name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name><name>sub</name>.<name>chars</name></name></expr></argument>, <argument><expr><name><name>sub</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>retstr</name> <init>= <expr><call><name>js_NewStringFromCharBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>cb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>retstr</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>str_replace_flat_lambda</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>ReplaceData</name> &amp;</type><name>rdata</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>FlatMatch</name> &amp;</type><name>fm</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>matchStr</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>matchStr</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* lambda(matchStr, matchStart, textstr) */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>lambdaArgc</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call>.<call><name>pushInvokeArgs</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lambdaArgc</name></expr></argument>, <argument><expr>&amp;<name><name>rdata</name>.<name>singleShot</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>CallArgs</name> &amp;</type><name>args</name> <init>= <expr><name><name>rdata</name>.<name>singleShot</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>args</name>.<name>callee</name></name><argument_list>()</argument_list></call>.<call><name>setObject</name><argument_list>(<argument><expr>*<name><name>rdata</name>.<name>lambda</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>args</name>.<name>thisv</name></name><argument_list>()</argument_list></call>.<call><name>setUndefined</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Value</name> *</type><name>sp</name> <init>= <expr><call><name><name>args</name>.<name>argv</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>sp</name><index>[<expr>0</expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name>matchStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><index>[<expr>1</expr>]</index></name>.<call><name>setInt32</name><argument_list>(<argument><expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name><index>[<expr>2</expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>Invoke</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>singleShot</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>repstr</name> <init>= <expr><call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>args</name>.<name>rval</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>repstr</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>leftSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>leftSide</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>matchLimit</name> <init>= <expr><call><name><name>fm</name>.<name>match</name></name><argument_list>()</argument_list></call> + <call><name><name>fm</name>.<name>patternLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>rightSide</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr><name>matchLimit</name></expr></argument>,
                                                <argument><expr><call><name><name>rdata</name>.<name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - <name>matchLimit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>rightSide</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <function_decl><type><name>RopeBuilder</name></type> <name>builder</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!(<call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>leftSide</name></expr></argument>)</argument_list></call> &amp;&amp;
          <call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>repstr</name></expr></argument>)</argument_list></call> &amp;&amp;
          <call><name><name>builder</name>.<name>append</name></name><argument_list>(<argument><expr><name>rightSide</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>result</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name><name>js</name>::<name>str_replace</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>ReplaceData</name></type> <name>rdata</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>optarg</name> <init>= <expr>2</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Extract replacement string/function. */</comment>
    <if>if <condition>(<expr><name>argc</name> &gt;= <name>optarg</name> &amp;&amp; <call><name>js_IsCallable</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>rdata</name>.<name>lambda</name></name> = &amp;<name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>toObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>elembase</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>repstr</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>dollar</name></name> = <name><name>rdata</name>.<name>dollarEnd</name></name> = <name>NULL</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>rdata</name>.<name>lambda</name>-&gt;<name>isFunction</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr><call><name><name>rdata</name>.<name>lambda</name>-&gt;<name>getFunctionPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>fun</name>-&gt;<name>isInterpreted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Pattern match the script to check if it is is indexing into a
                 * particular object, e.g. 'function(a) { return b[a]; }'.  Avoid
                 * calling the script in such cases, which are used by javascript
                 * packers (particularly the popular Dean Edwards packer) to efficiently
                 * encode large scripts.  We only handle the code patterns generated
                 * by such packers here.
                 */</comment>
                <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><name><name>script</name>-&gt;<name>code</name></name></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>Value</name></type> <name>table</name> <init>= <expr><call><name>UndefinedValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>JSOp</name><argument_list>(<argument><expr>*<name>pc</name></expr></argument>)</argument_list></call> == <name>JSOP_GETFCSLOT</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>table</name> = <call><name><name>rdata</name>.<name>lambda</name>-&gt;<name>getFlatClosureUpvar</name></name><argument_list>(<argument><expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <name>JSOP_GETFCSLOT_LENGTH</name></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><call><name><name>table</name>.<name>isObject</name></name><argument_list>()</argument_list></call> &amp;&amp;
                    <call><name>JSOp</name><argument_list>(<argument><expr>*<name>pc</name></expr></argument>)</argument_list></call> == <name>JSOP_GETARG</name> &amp;&amp; <call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
                    <call><name>JSOp</name><argument_list>(<argument><expr>*(<name>pc</name> + <name>JSOP_GETARG_LENGTH</name>)</expr></argument>)</argument_list></call> == <name>JSOP_GETELEM</name> &amp;&amp;
                    <call><name>JSOp</name><argument_list>(<argument><expr>*(<name>pc</name> + <name>JSOP_GETARG_LENGTH</name> + <name>JSOP_GETELEM_LENGTH</name>)</expr></argument>)</argument_list></call> == <name>JSOP_RETURN</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>Class</name> *</type><name>clasp</name> <init>= <expr><call><name><name>table</name>.<name>toObject</name></name><argument_list>()</argument_list></call>.<call><name>getClass</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>clasp</name>-&gt;<name>isNative</name></name><argument_list>()</argument_list></call> &amp;&amp;
                        !<name><name>clasp</name>-&gt;<name>ops</name>.<name>lookupProperty</name></name> &amp;&amp;
                        !<name><name>clasp</name>-&gt;<name>ops</name>.<name>getProperty</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>rdata</name>.<name>elembase</name></name> = &amp;<call><name><name>table</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>rdata</name>.<name>lambda</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>elembase</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>repstr</name></name> = <call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>rdata</name>.<name>repstr</name></name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* We're about to store pointers into the middle of our string. */</comment>
        <if>if <condition>(<expr>!<call><name>js_MakeStringImmutable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>repstr</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name><name>rdata</name>.<name>dollarEnd</name></name> = <call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rdata</name>.<name>dollar</name></name> = <call><name>js_strchr_limit</name><argument_list>(<argument><expr><call><name><name>rdata</name>.<name>repstr</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>'$'</expr></argument>,
                                       <argument><expr><name><name>rdata</name>.<name>dollarEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>!<call><name><name>rdata</name>.<name>g</name>.<name>init</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/*
     * Unlike its |String.prototype| brethren, |replace| doesn't convert
     * its input to a regular expression. (Even if it contains metachars.)
     *
     * However, if the user invokes our (non-standard) |flags| argument
     * extension then we revert to creating a regular expression. Note that
     * this is observable behavior through the side-effect mutation of the
     * |RegExp| statics.
     */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>FlatMatch</name> *</type><name>fm</name> <init>= <expr><call><name><name>rdata</name>.<name>g</name>.<name>tryFlatMatch</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>fm</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>throwing</name></name></expr>)</condition><then>  <comment type="block">/* oom in RopeMatch in tryFlatMatch */</comment>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<call><name><name>rdata</name>.<name>g</name>.<name>hasRegExpPair</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>argc</name> &gt; <name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>str_replace_regexp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>fm</name>-&gt;<name>match</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>rdata</name>.<name>lambda</name></name></expr>)</condition><then>
        <return>return <expr><call><name>str_replace_flat_lambda</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>rdata</name></expr></argument>, <argument><expr>*<name>fm</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* 
     * Note: we could optimize the text.length == pattern.length case if we wanted,
     * even in the presence of dollar metachars.
     */</comment>
    <if>if <condition>(<expr><name><name>rdata</name>.<name>dollar</name></name></expr>)</condition><then>
        <return>return <expr><call><name>BuildDollarReplacement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>repstr</name></name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>dollar</name></name></expr></argument>, <argument><expr>*<name>fm</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><call><name>BuildFlatReplacement</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>str</name></name></expr></argument>, <argument><expr><name><name>rdata</name>.<name>repstr</name></name></expr></argument>, <argument><expr>*<name>fm</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Subroutine used by str_split to find the next split point in str, starting
 * at offset *ip and looking either for the separator substring given by sep, or
 * for the next re match.  In the re case, return the matched separator in *sep,
 * and the possibly updated offset in *ip.
 *
 * Return -2 on error, -1 on end of string, &gt;= 0 for a valid index of the next
 * separator occurrence if found, or str-&gt;length if no separator is found.
 */</comment>
<function><type><specifier>static</specifier> <name>jsint</name></type>
<name>find_split</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RegExpStatics</name> *</type><name>res</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name><name>js</name>::<name>RegExp</name></name> *</type><name>re</name></decl></param>, <param><decl><type><name>jsint</name> *</type><name>ip</name></decl></param>,
           <param><decl><type><name>JSSubString</name> *</type><name>sep</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Stop if past end of string.  If at end of string, we will compare the
     * null char stored there (by js_NewString*) to sep-&gt;chars[j] in the while
     * loop at the end of this function, so that
     *
     *  "ab,".split(',') =&gt; ["ab", ""]
     *
     * and the resulting array converts back to the string "ab," for symmetry.
     * However, we ape Perl and do this only if there is a sufficiently large
     * limit argument (see str_split).
     */</comment>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name> <init>= <expr>*<name>ip</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>(<name>size_t</name>)<name>i</name> &gt; <name>length</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr>-2</expr>;</return></then></if>

    <comment type="block">/*
     * Match a regular expression against the separator at or above index i.
     * Call js_ExecuteRegExp with true for the test argument.  On successful
     * match, get the separator from cx-&gt;regExpStatics.lastMatch.
     */</comment>
    <if>if <condition>(<expr><name>re</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name></type> <name>rval</name></decl>;</decl_stmt>

      <label><name>again</name>:</label>
        <comment type="block">/* JS1.2 deviated from Perl by never matching at end of string. */</comment>
        <expr_stmt><expr><name>index</name> = (<name>size_t</name>)<name>i</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>re</name>-&gt;<name>execute</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>-2</expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name><name>rval</name>.<name>isTrue</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Mismatch: ensure our caller advances i past end of string. */</comment>
            <expr_stmt><expr><name><name>sep</name>-&gt;<name>length</name></name> = 1</expr>;</expr_stmt>
            <return>return <expr><name>length</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>i</name> = (<name>jsint</name>)<name>index</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getLastMatch</name></name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sep</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/*
             * Empty string match: never split on an empty match at the start
             * of a find_split cycle.  Same rule as for an empty global match
             * in DoMatch.
             */</comment>
            <if>if <condition>(<expr><name>i</name> == *<name>ip</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * "Bump-along" to avoid sticking at an empty match, but don't
                 * bump past end of string -- our caller must do that by adding
                 * sep-&gt;length to our return value.
                 */</comment>
                <if>if <condition>(<expr>(<name>size_t</name>)<name>i</name> == <name>length</name></expr>)</condition><then>
                    <return>return <expr>-1</expr>;</return></then></if>
                <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
                <goto>goto <name>again</name>;</goto>
            }</block></then></if>
            <if>if <condition>(<expr>(<name>size_t</name>)<name>i</name> == <name>length</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * If there was a trivial zero-length match at the end of the
                 * split, then we shouldn't output the matched string at the end
                 * of the split array. See ECMA-262 Ed. 3, 15.5.4.14, Step 15.
                 */</comment>
                <expr_stmt><expr><name><name>sep</name>-&gt;<name>chars</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>size_t</name>)<name>i</name> &gt;= <name><name>sep</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>i</name> - <name><name>sep</name>-&gt;<name>length</name></name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Special case: if sep is the empty string, split str into one character
     * substrings.  Let our caller worry about whether to split once at end of
     * string into an empty substring.
     */</comment>
    <if>if <condition>(<expr><name><name>sep</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then>
        <return>return <expr>((<name>size_t</name>)<name>i</name> == <name>length</name>) ? -1 : <name>i</name> + 1</expr>;</return></then></if>

    <comment type="block">/*
     * Now that we know sep is non-empty, search starting at i in str for an
     * occurrence of all of sep's chars.  If we find them, return the index of
     * the first separator char.  Otherwise, return length.
     */</comment>
    <decl_stmt><decl><type><name>jsint</name></type> <name>match</name> <init>= <expr><call><name>StringMatch</name><argument_list>(<argument><expr><name>chars</name> + <name>i</name></expr></argument>, <argument><expr><name>length</name> - <name>i</name></expr></argument>, <argument><expr><name><name>sep</name>-&gt;<name>chars</name></name></expr></argument>, <argument><expr><name><name>sep</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>match</name> == -1 ? <name>length</name> : <name>match</name> + <name>i</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_split</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>Value</name></type> <name>v</name> <init>= <expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>aobj</name> <init>= <expr><call><name>NewDenseCopiedArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>aobj</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setObject</name></name><argument_list>(<argument><expr>*<name>aobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>RegExp</name> *</type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSubString</name> *</type><name>sep</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>VALUE_IS_REGEXP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>re</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>RegExp</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>toObject</name><argument_list>()</argument_list></call>.<call><name>getPrivate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sep</name> = &amp;<name>tmp</name></expr>;</expr_stmt>

        <comment type="block">/* Set a magic value so we can detect a successful re match. */</comment>
        <expr_stmt><expr><name><name>sep</name>-&gt;<name>chars</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sep</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>sepstr</name> <init>= <expr><call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>sepstr</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name>sepstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Point sep at a local copy of sepstr's header because find_split
         * will modify sep-&gt;length.
         */</comment>
        <expr_stmt><expr><name><name>tmp</name>.<name>length</name></name> = <call><name><name>sepstr</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name>.<name>chars</name></name> = <call><name><name>sepstr</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>tmp</name>.<name>chars</name></name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name>re</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sep</name> = &amp;<name>tmp</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Use the second argument as the split limit, if given. */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Avoid warning. */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>limited</name> <init>= <expr>(<name>argc</name> &gt; 1) &amp;&amp; !<name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>isUndefined</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>limited</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* Clamp limit between 0 and 1 + string length. */</comment>
        <expr_stmt><expr><name>limit</name> = <call><name>js_DoubleToECMAUint32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>limit</name> &gt; <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>limit</name> = 1 + <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <function_decl><type><name>AutoValueVector</name></type> <name>splits</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>RegExpStatics</name> *</type><name>res</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>regExpStatics</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name> <init>= <expr><name>i</name> = 0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr>(<name>j</name> = <call><name>find_split</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call>) &gt;= 0</expr>)</condition> <block>{
        <if>if <condition>(<expr><name>limited</name> &amp;&amp; <name>len</name> &gt;= <name>limit</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <decl_stmt><decl><type><name>JSString</name> *</type><name>sub</name> <init>= <expr><call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>j</name> - <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>sub</name> || !<call><name><name>splits</name>.<name>append</name></name><argument_list>(<argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>

        <comment type="block">/*
         * Imitate perl's feature of including parenthesized substrings that
         * matched part of the delimiter in the new array, after the split
         * substring that was delimited.
         */</comment>
        <if>if <condition>(<expr><name>re</name> &amp;&amp; <name><name>sep</name>-&gt;<name>chars</name></name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>uintN</name></type> <name>num</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>num</name> &lt; <call><name><name>res</name>-&gt;<name>parenCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>num</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name>limited</name> &amp;&amp; <name>len</name> &gt;= <name>limit</name></expr>)</condition><then>
                    <break>break;</break></then></if>
                <decl_stmt><decl><type><name>JSSubString</name></type> <name>parsub</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>res</name>-&gt;<name>getParen</name></name><argument_list>(<argument><expr><name>num</name> + 1</expr></argument>, <argument><expr>&amp;<name>parsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sub</name> = <call><name>js_NewStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>parsub</name>.<name>chars</name></name></expr></argument>, <argument><expr><name><name>parsub</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>sub</name> || !<call><name><name>splits</name>.<name>append</name></name><argument_list>(<argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr>false</expr>;</return></then></if>
                <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name><name>sep</name>-&gt;<name>chars</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>i</name> = <name>j</name> + <name><name>sep</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>j</name> == -2</expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSObject</name> *</type><name>aobj</name> <init>= <expr><call><name>NewDenseCopiedArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>splits</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>splits</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>aobj</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setObject</name></name><argument_list>(<argument><expr>*<name>aobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_PERL_SUBSTR</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_substr</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>begin</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>length</name> = <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>begin</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>begin</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>begin</name> += <name>length</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>begin</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>begin</name> = 0</expr>;</expr_stmt></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>begin</name> &gt; <name>length</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>begin</name> = <name>length</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <if>if <condition>(<expr><name>argc</name> == 1 || <name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>isUndefined</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> = <name>length</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>end</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>end</name> += <name>begin</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>end</name> &gt; <name>length</name></expr>)</condition><then>
                <expr_stmt><expr><name>end</name> = <name>length</name></expr>;</expr_stmt></then></if>
        }</block></else></if>

        <expr_stmt><expr><name>str</name> = <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
                                    <argument><expr>(<name>size_t</name>)<name>begin</name></expr></argument>,
                                    <argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>end</name> - <name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_PERL_SUBSTR */</comment>

<comment type="block">/*
 * Python-esque sequence operations.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_concat</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>str2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> *</type><name>argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set vp (aka rval) early to handle the argc == 0 case. */</comment>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>argv</name> = <name>vp</name> + 2</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>str2</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str2</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>setString</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>str</name> = <call><name>js_ConcatStrings</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_slice</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>argc</name> == 1 &amp;&amp; <name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>isString</name><argument_list>()</argument_list></call> &amp;&amp; <name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>isInt32</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>begin</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>toString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>begin</name> = <name><name>vp</name><index>[<expr>2</expr>]</index></name>.<call><name>toInt32</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> = <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>begin</name> &lt;= <name>end</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>length</name> = <name>end</name> - <name>begin</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>length</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>str</name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>str</name> = (<name>length</name> == 1)
                      ? <call><name><name>JSString</name>::<name>getUnitString</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call>
                      : <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>
            <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>argc</name> != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>begin</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>begin</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>begin</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>begin</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>begin</name> += <name>length</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>begin</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>begin</name> = 0</expr>;</expr_stmt></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>begin</name> &gt; <name>length</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>begin</name> = <name>length</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <if>if <condition>(<expr><name>argc</name> == 1 || <name><name>vp</name><index>[<expr>3</expr>]</index></name>.<call><name>isUndefined</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>end</name> = <name>length</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>end</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>end</name> += <name>length</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
                    <expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>end</name> &gt; <name>length</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>end</name> = <name>length</name></expr>;</expr_stmt>
            }</block></then></if></else></if>
            <if>if <condition>(<expr><name>end</name> &lt; <name>begin</name></expr>)</condition><then>
                <expr_stmt><expr><name>end</name> = <name>begin</name></expr>;</expr_stmt></then></if>
        }</block></else></if>

        <expr_stmt><expr><name>str</name> = <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
                                    <argument><expr>(<name>size_t</name>)<name>begin</name></expr></argument>,
                                    <argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>end</name> - <name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_STR_HTML_HELPERS</name></expr></cpp:if>
<comment type="block">/*
 * HTML composition aids.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tagify</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>begin</name></decl></param>, <param><decl><type><name>JSLinearString</name> *</type><name>param</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
       <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>thisstr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NORMALIZE_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>thisstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name><name>thisstr</name>-&gt;<name>ensureLinear</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>end</name></expr>)</condition><then>
        <expr_stmt><expr><name>end</name> = <name>begin</name></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>beglen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>taglen</name> <init>= <expr>1 + <name>beglen</name> + 1</expr></init></decl>;</decl_stmt>                     <comment type="block">/* '&lt;begin' + '&gt;' */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parlen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Avoid warning. */</comment>
    <if>if <condition>(<expr><name>param</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>parlen</name> = <call><name><name>param</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>taglen</name> += 2 + <name>parlen</name> + 1</expr>;</expr_stmt>                       <comment type="block">/* '="param"' */</comment>
    }</block></then></if>
    <decl_stmt><decl><type><name>size_t</name></type> <name>endlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>taglen</name> += <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> + 2 + <name>endlen</name> + 1</expr>;</expr_stmt>           <comment type="block">/* 'str&lt;/end&gt;' */</comment>

    <if>if <condition>(<expr><name>taglen</name> &gt;= ~(<name>size_t</name>)0 / <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>tagbuf</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>taglen</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>tagbuf</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '&lt;'</expr>;</expr_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>beglen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = (<name>jschar</name>)<name><name>begin</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    <if>if <condition>(<expr><name>param</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '='</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '"'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr>&amp;<name><name>tagbuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>param</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>parlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> += <name>parlen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '"'</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '&gt;'</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr>&amp;<name><name>tagbuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> += <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '&lt;'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '/'</expr>;</expr_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>endlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = (<name>jschar</name>)<name><name>end</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name>++</expr>]</index></name> = '&gt;'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>j</name> == <name>taglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tagbuf</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>retstr</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tagbuf</name></expr></argument>, <argument><expr><name>taglen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>retstr</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr>(<name>char</name> *)<name>tagbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>tagify_value</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>begin</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>param</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>param</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_bold</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"b"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_italics</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_fixed</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"tt"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_fontsize</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify_value</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>"font size"</expr></argument>, <argument><expr>"font"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_fontcolor</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify_value</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>"font color"</expr></argument>, <argument><expr>"font"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_link</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify_value</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>"a href"</expr></argument>, <argument><expr>"a"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_anchor</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify_value</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>"a name"</expr></argument>, <argument><expr>"a"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_strike</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"strike"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_small</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"small"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_big</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"big"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_blink</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"blink"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_sup</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"sup"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_sub</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>tagify</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"sub"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_STR_HTML_HELPERS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<function><type><name>JSString</name>* <name>FASTCALL</name></type>
<name>js_String_getelem</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSString</name>*</type> <name>str</name></decl></param>, <param><decl><type><name>int32</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>(<name>size_t</name>)<name>i</name> &gt;= <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>JSString</name>::<name>getUnitString</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>JS_DEFINE_TRCINFO_1</name><argument_list>(<argument>str_concat</argument>,
    <argument>(3, (extern, STRING_RETRY, js_ConcatStrings, CONTEXT, THIS_STRING, STRING,
         1, nanojit::ACCSET_NONE))</argument>)</argument_list></macro>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16</name></type> <name>GENERIC_PRIMITIVE</name> <init>= <expr><name>JSFUN_GENERIC_NATIVE</name> | <name>JSFUN_PRIMITIVE_THIS</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>string_methods</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"quote"</expr></argument>,             <argument><expr><name>str_quote</name></expr></argument>,             <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toSource_str</name></expr></argument>,     <argument><expr><name>str_toSource</name></expr></argument>,          <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Java-like methods. */</comment>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toString_str</name></expr></argument>,     <argument><expr><name>js_str_toString</name></expr></argument>,       <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_valueOf_str</name></expr></argument>,      <argument><expr><name>js_str_toString</name></expr></argument>,       <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toJSON_str</name></expr></argument>,       <argument><expr><name>js_str_toString</name></expr></argument>,       <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"substring"</expr></argument>,         <argument><expr><name>str_substring</name></expr></argument>,         <argument><expr>2</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"toLowerCase"</expr></argument>,       <argument><expr><name>str_toLowerCase</name></expr></argument>,       <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"toUpperCase"</expr></argument>,       <argument><expr><name>str_toUpperCase</name></expr></argument>,       <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"charAt"</expr></argument>,            <argument><expr><name>js_str_charAt</name></expr></argument>,         <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"charCodeAt"</expr></argument>,        <argument><expr><name>js_str_charCodeAt</name></expr></argument>,     <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"indexOf"</expr></argument>,           <argument><expr><name>str_indexOf</name></expr></argument>,           <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"lastIndexOf"</expr></argument>,       <argument><expr><name>str_lastIndexOf</name></expr></argument>,       <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"trim"</expr></argument>,              <argument><expr><name>str_trim</name></expr></argument>,              <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"trimLeft"</expr></argument>,          <argument><expr><name>str_trimLeft</name></expr></argument>,          <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"trimRight"</expr></argument>,         <argument><expr><name>str_trimRight</name></expr></argument>,         <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"toLocaleLowerCase"</expr></argument>, <argument><expr><name>str_toLocaleLowerCase</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"toLocaleUpperCase"</expr></argument>, <argument><expr><name>str_toLocaleUpperCase</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"localeCompare"</expr></argument>,     <argument><expr><name>str_localeCompare</name></expr></argument>,     <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,

    <comment type="block">/* Perl-ish methods (search is actually Python-esque). */</comment>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"match"</expr></argument>,             <argument><expr><name>str_match</name></expr></argument>,             <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"search"</expr></argument>,            <argument><expr><name>str_search</name></expr></argument>,            <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"replace"</expr></argument>,           <argument><expr><name>str_replace</name></expr></argument>,           <argument><expr>2</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"split"</expr></argument>,             <argument><expr><name>str_split</name></expr></argument>,             <argument><expr>2</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_PERL_SUBSTR</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"substr"</expr></argument>,            <argument><expr><name>str_substr</name></expr></argument>,            <argument><expr>2</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Python-esque sequence methods. */</comment>
    <expr><call><name>JS_TN</name><argument_list>(<argument><expr>"concat"</expr></argument>,            <argument><expr><name>str_concat</name></expr></argument>,            <argument><expr>1</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>, <argument><expr>&amp;<name>str_concat_trcinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"slice"</expr></argument>,             <argument><expr><name>str_slice</name></expr></argument>,             <argument><expr>2</expr></argument>,<argument><expr><name>GENERIC_PRIMITIVE</name></expr></argument>)</argument_list></call></expr>,

    <comment type="block">/* HTML string methods. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_STR_HTML_HELPERS</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"bold"</expr></argument>,              <argument><expr><name>str_bold</name></expr></argument>,              <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"italics"</expr></argument>,           <argument><expr><name>str_italics</name></expr></argument>,           <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"fixed"</expr></argument>,             <argument><expr><name>str_fixed</name></expr></argument>,             <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"fontsize"</expr></argument>,          <argument><expr><name>str_fontsize</name></expr></argument>,          <argument><expr>1</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"fontcolor"</expr></argument>,         <argument><expr><name>str_fontcolor</name></expr></argument>,         <argument><expr>1</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"link"</expr></argument>,              <argument><expr><name>str_link</name></expr></argument>,              <argument><expr>1</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"anchor"</expr></argument>,            <argument><expr><name>str_anchor</name></expr></argument>,            <argument><expr>1</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"strike"</expr></argument>,            <argument><expr><name>str_strike</name></expr></argument>,            <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"small"</expr></argument>,             <argument><expr><name>str_small</name></expr></argument>,             <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"big"</expr></argument>,               <argument><expr><name>str_big</name></expr></argument>,               <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"blink"</expr></argument>,             <argument><expr><name>str_blink</name></expr></argument>,             <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"sup"</expr></argument>,               <argument><expr><name>str_sup</name></expr></argument>,               <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"sub"</expr></argument>,               <argument><expr><name>str_sub</name></expr></argument>,               <argument><expr>0</expr></argument>,<argument><expr><name>JSFUN_PRIMITIVE_THIS</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Set up some tools to make it easier to generate large tables. After constant
 * folding, for each n, Rn(0) is the comma-separated list R(0), R(1), ..., R(2^n-1).
 * Similary, Rn(k) (for any k and n) generates the list R(k), R(k+1), ..., R(k+2^n-1).
 * To use this, define R appropriately, then use Rn(0) (for some value of n), then
 * undefine R.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R2</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>R(n),   R((n) + (1 &lt;&lt; 0)),    R((n) + (2 &lt;&lt; 0)),    R((n) + (3 &lt;&lt; 0))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R4</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>R2(n),  R2((n) + (1 &lt;&lt; 2)),   R2((n) + (2 &lt;&lt; 2)),   R2((n) + (3 &lt;&lt; 2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R6</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>R4(n),  R4((n) + (1 &lt;&lt; 4)),   R4((n) + (2 &lt;&lt; 4)),   R4((n) + (3 &lt;&lt; 4))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R8</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>R6(n),  R6((n) + (1 &lt;&lt; 6)),   R6((n) + (2 &lt;&lt; 6)),   R6((n) + (3 &lt;&lt; 6))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R10</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>R8(n),  R8((n) + (1 &lt;&lt; 8)),   R8((n) + (2 &lt;&lt; 8)),   R8((n) + (3 &lt;&lt; 8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R12</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>R10(n), R10((n) + (1 &lt;&lt; 10)), R10((n) + (2 &lt;&lt; 10)), R10((n) + (3 &lt;&lt; 10))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R3</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>R2(n), R2((n) + (1 &lt;&lt; 2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R7</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>R6(n), R6((n) + (1 &lt;&lt; 6))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILD_LENGTH_AND_FLAGS</name><parameter_list>(<param><type><name>length</name></type></param>, <param><type><name>flags</name></type></param>)</parameter_list></cpp:macro>                                 \
    <cpp:value>(((length) &lt;&lt; JSString::LENGTH_SHIFT) | (flags))</cpp:value></cpp:define>

<comment type="block">/*
 * Declare unit strings. Pack the string data itself into the mInlineChars
 * place in the header.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{                                                                \
    BUILD_LENGTH_AND_FLAGS(1, JSString::FLAT | JSString::ATOMIZED),           \
    { (jschar *)(((char *)(unitStringTable + (c))) +                          \
      offsetof(JSString, inlineStorage)) },                                   \
    { {(c), 0x00} } }</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(8)</cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(push, 8)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>JSString</name> <name><name>JSString</name>::<name>unitStringTable</name></name><index>[]</index></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<name>__attribute__</name> <argument_list>(<argument><expr>(<call><name>aligned</name> <argument_list>(<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<init>= <expr><block>{ <macro><name>R8</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(0)</cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(pop)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R</name></cpp:undef>

<comment type="block">/*
 * Declare length-2 strings. We only store strings where both characters are
 * alphanumeric. The lower 10 short chars are the numerals, the next 26 are
 * the lowercase letters, and the next 26 are the uppercase letters.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TO_SMALL_CHAR</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= '0' &amp;&amp; (c) &lt;= '9' ? (c) - '0' :              \
                          (c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z' ? (c) - 'a' + 10 :         \
                          (c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z' ? (c) - 'A' + 36 :         \
                          JSString::INVALID_SMALL_CHAR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name></cpp:macro> <cpp:value>TO_SMALL_CHAR</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>JSString</name>::<name>SmallChar</name></name></type> <name><name>JSString</name>::<name>toSmallChar</name><index>[]</index></name> <init>= <expr><block>{ <macro><name>R7</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R</name></cpp:undef>

<comment type="block">/*
 * This is used when we generate our table of short strings, so the compiler is
 * happier if we use |c| as few times as possible.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FROM_SMALL_CHAR</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) + ((c) &lt; 10 ? '0' :      \
                                   (c) &lt; 36 ? 'a' - 10 : \
                                   'A' - 36))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name></cpp:macro> <cpp:value>FROM_SMALL_CHAR</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name><name>JSString</name>::<name>fromSmallChar</name><index>[]</index></name> <init>= <expr><block>{ <macro><name>R6</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R</name></cpp:undef>

<comment type="block">/*
 * For code-generation ease, length-2 strings are encoded as 12-bit int values,
 * where the upper 6 bits is the first character and the lower 6 bits is the
 * second character.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{                                                                \
    BUILD_LENGTH_AND_FLAGS(2, JSString::FLAT | JSString::ATOMIZED),           \
    { (jschar *)(((char *)(length2StringTable + (c))) +                       \
      offsetof(JSString, inlineStorage)) },                                   \
    { {FROM_SMALL_CHAR((c) &gt;&gt; 6), FROM_SMALL_CHAR((c) &amp; 0x3F), 0x00} } }</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(8)</cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(push, 8)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>JSString</name> <name><name>JSString</name>::<name>length2StringTable</name></name><index>[]</index></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<name>__attribute__</name> <argument_list>(<argument><expr>(<call><name>aligned</name> <argument_list>(<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<init>= <expr><block>{ <macro><name>R12</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(0)</cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(pop)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R</name></cpp:undef>

<comment type="block">/*
 * Declare int strings. Only int strings from 100 to 255 actually have to be
 * generated, since the rest are either unit strings or length-2 strings. To
 * avoid the runtime cost of figuring out where to look for the string for a
 * particular integer, we precompute a table of JSString*s which refer to the
 * correct location of the int string.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{                                                                \
    BUILD_LENGTH_AND_FLAGS(3, JSString::FLAT | JSString::ATOMIZED),           \
    { (jschar *)(((char *)(hundredStringTable + ((c) - 100))) +               \
      offsetof(JSString, inlineStorage)) },                                   \
    { {((c) / 100) + '0', ((c) / 10 % 10) + '0', ((c) % 10) + '0', 0x00} } }</cpp:value></cpp:define>


<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>100 + (1 &lt;&lt; 7) + (1 &lt;&lt; 4) + (1 &lt;&lt; 3) + (1 &lt;&lt; 2) == 256</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(8)</cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(push, 8)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>JSString</name> <name><name>JSString</name>::<name>hundredStringTable</name></name><index>[]</index></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<name>__attribute__</name> <argument_list>(<argument><expr>(<call><name>aligned</name> <argument_list>(<argument><expr>8</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<init>= <expr><block>{ <expr><call><name>R7</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>, <comment type="block">/* 100 through 227 */</comment>
    <expr><call><name>R4</name><argument_list>(<argument><expr>100 + (1 &lt;&lt; 7)</expr></argument>)</argument_list></call></expr>, <comment type="block">/* 228 through 243 */</comment>
    <expr><call><name>R3</name><argument_list>(<argument><expr>100 + (1 &lt;&lt; 7) + (1 &lt;&lt; 4)</expr></argument>)</argument_list></call></expr>, <comment type="block">/* 244 through 251 */</comment>
    <macro><name>R2</name><argument_list>(<argument>100 + (1 &lt;&lt; 7) + (1 &lt;&lt; 4) + (1 &lt;&lt; 3)</argument>)</argument_list></macro> <comment type="block">/* 252 through 255 */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) &lt; 10 ? JSString::unitStringTable + ((c) + '0') :            \
              (c) &lt; 100 ? JSString::length2StringTable +                      \
              ((size_t)TO_SMALL_CHAR(((c) / 10) + '0') &lt;&lt; 6) +                \
              TO_SMALL_CHAR(((c) % 10) + '0') :                               \
              JSString::hundredStringTable + ((c) - 100))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>JSString</name> *<specifier>const</specifier></type> <name><name>JSString</name>::<name>intStringTable</name><index>[]</index></name> <init>= <expr><block>{ <macro><name>R8</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R</name></cpp:undef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(0)</cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> pack(pop)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R4</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R6</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R8</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R10</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R12</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R3</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>R7</name></cpp:undef>

<function><type><name>JSBool</name></type>
<name>js_String</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>argv</name> <init>= <expr><name>vp</name> + 2</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>argc</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>str</name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><call><name>IsConstructing</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>NewBuiltinClassInstance</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_StringClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrimitiveThis</name></name><argument_list>(<argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setObject</name></name><argument_list>(<argument><expr>*<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_fromCharCode</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>argv</name> = <name>vp</name> + 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>argc</name> &lt;= <name>JS_ARGS_LENGTH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> == 1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>code</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>ValueToUint16</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>code</name> &lt; <name>UNIT_STRING_LIMIT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>str</name> = <call><name><name>JSString</name>::<name>unitString</name></name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name>.<call><name>setInt32</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>chars</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>argc</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>code</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>ValueToUint16</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>jschar</name>)<name>code</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>JSString</name>* <name>FASTCALL</name></type>
<name>String_fromCharCode</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>int32</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name> <init>= <expr>(<name>jschar</name>)<name>i</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>c</name> &lt; <name>UNIT_STRING_LIMIT</name></expr>)</condition><then>
        <return>return <expr><call><name><name>JSString</name>::<name>unitString</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>js_NewStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>JS_DEFINE_TRCINFO_1</name><argument_list>(<argument>str_fromCharCode</argument>,
    <argument>(2, (static, STRING_RETRY, String_fromCharCode, CONTEXT, INT32, 1, nanojit::ACCSET_NONE))</argument>)</argument_list></macro>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>string_static_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>JS_TN</name><argument_list>(<argument><expr>"fromCharCode"</expr></argument>, <argument><expr><name>str_fromCharCode</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>str_fromCharCode_trcinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>JSObject</name> *</type>
<name>js_InitStringClass</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>proto</name></decl>;</decl_stmt>

    <comment type="block">/* Define the escape, unescape functions in the global object. */</comment>
    <if>if <condition>(<expr>!<call><name>JS_DefineFunctions</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>string_functions</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>proto</name> = <call><name>js_InitClass</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>js_StringClass</name></expr></argument>, <argument><expr><name>js_String</name></expr></argument>, <argument><expr>1</expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>string_methods</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>string_static_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>proto</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>proto</name>-&gt;<name>setPrimitiveThis</name></name><argument_list>(<argument><expr><call><name>StringValue</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>js_DefineNativeProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>UndefinedValue</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSPROP_READONLY</name> | <name>JSPROP_PERMANENT</name> | <name>JSPROP_SHARED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>proto</name></expr>;</return>
}</block></function>

<function><type><name>JSFlatString</name> *</type>
<name>js_NewString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>length</name> &gt; <name><name>JSString</name>::<name>MAX_LENGTH</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If we can't leave the trace, signal OOM condition, otherwise
             * exit from trace before throwing.
             */</comment>
            <if>if <condition>(<expr>!<call><name>CanLeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>js_NewGCString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>str</name>-&gt;<name>initFlat</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>liveStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>totalStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_RUNTIME_VOID</name><argument_list>(<argument><expr><name>rt</name></expr></argument>,
        <argument><expr>(<name><name>rt</name>-&gt;<name>lengthSum</name></name> += (<name>double</name>)<name>length</name>,
         <name><name>rt</name>-&gt;<name>lengthSquaredSum</name></name> += (<name>double</name>)<name>length</name> * (<name>double</name>)<name>length</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>str</name>-&gt;<name>assertIsFlat</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>JSFlatString</name> *</type>
<name>NewShortString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSShortString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewGCShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>storage</name> <init>= <expr><call><name><name>str</name>-&gt;<name>init</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>js_short_strncpy</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>storage</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <return>return <expr><call><name><name>str</name>-&gt;<name>header</name></name><argument_list>()</argument_list></call>-&gt;<call><name>assertIsFlat</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSFlatString</name> *</type>
<name>NewShortString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSShortString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewGCShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>storage</name> <init>= <expr><call><name><name>str</name>-&gt;<name>init</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>js_CStringsAreUTF8</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>size_t</name></type> <name>oldLength</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr>!<call><name>js_InflateStringToBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>length</name> &lt;= <name>oldLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>storage</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>str</name>-&gt;<name>resetLength</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jschar</name> *</type><name>p</name> <init>= <expr><name>storage</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>n</name>--</expr>)</condition>
            <expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>chars</name>++</expr>;</expr_stmt></while>
        <expr_stmt><expr>*<name>p</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><call><name><name>str</name>-&gt;<name>header</name></name><argument_list>()</argument_list></call>-&gt;<call><name>assertIsFlat</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>sMinWasteSize</name> <init>= <expr>16</expr></init></decl>;</decl_stmt>

<function><type><name>JSFlatString</name> *</type>
<name>js_NewStringFromCharBuffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCharBuffer</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>cb</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>emptyAtom</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>cb</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name><name>JSShortString</name>::<name>MAX_SHORT_STRING_LENGTH</name></name> &lt; <name><name>JSCharBuffer</name>::<name>InlineLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>NewShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cb</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>capacity</name> <init>= <expr><call><name><name>cb</name>.<name>capacity</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>buf</name> <init>= <expr><call><name><name>cb</name>.<name>extractRawBuffer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>buf</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* For medium/big buffers, avoid wasting more than 1/4 of the memory. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>capacity</name> &gt;= <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>capacity</name> &gt; <name>sMinWasteSize</name> &amp;&amp; <name>capacity</name> - <name>length</name> &gt; (<name>length</name> &gt;&gt; 2)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof> * (<name>length</name> + 1)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jschar</name> *</type><name>tmp</name> <init>= <expr>(<name>jschar</name> *)<call><name><name>cx</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>buf</name> = <name>tmp</name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSFlatString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><name>JSLinearString</name> *</type>
<name>js_NewDependentString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>baseArg</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>start</name></decl></param>,
                      <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>ds</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>length</name> == 0</expr>)</condition><then>
        <return>return <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>base</name> <init>= <expr><call><name><name>baseArg</name>-&gt;<name>ensureLinear</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>base</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>length</name> == <call><name><name>base</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>base</name></expr>;</return></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>base</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>start</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>staticStr</name> <init>= <expr><call><name><name>JSString</name>::<name>lookupStaticString</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>staticStr</name></expr>)</condition><then>
        <return>return <expr><name>staticStr</name></expr>;</return></then></if>

    <comment type="block">/* Try to avoid long chains of dependent strings. */</comment>
    <while>while <condition>(<expr><call><name><name>base</name>-&gt;<name>isDependent</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>base</name> = <call><name><name>base</name>-&gt;<name>dependentBase</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></while>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>base</name>-&gt;<name>isFlat</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ds</name> = <call><name>js_NewGCString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ds</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>ds</name>-&gt;<name>initDependent</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>liveDependentStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>totalDependentStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>liveStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>totalStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_RUNTIME_VOID</name><argument_list>(<argument><expr><name>rt</name></expr></argument>,
        <argument><expr>(<name><name>rt</name>-&gt;<name>strdepLengthSum</name></name> += (<name>double</name>)<name>length</name>,
         <name><name>rt</name>-&gt;<name>strdepLengthSquaredSum</name></name> += (<name>double</name>)<name>length</name> * (<name>double</name>)<name>length</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_RUNTIME_VOID</name><argument_list>(<argument><expr><name>rt</name></expr></argument>,
        <argument><expr>(<name><name>rt</name>-&gt;<name>lengthSum</name></name> += (<name>double</name>)<name>length</name>,
         <name><name>rt</name>-&gt;<name>lengthSquaredSum</name></name> += (<name>double</name>)<name>length</name> * (<name>double</name>)<name>length</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>ds</name>-&gt;<name>assertIsLinear</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<function><type><name>void</name></type> <name>printJSStringStats</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name>mean</name></decl>, <decl><type ref="prev"/><name>sigma</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mean</name> = <call><name>JS_MeanAndStdDev</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>totalStrings</name></name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>lengthSum</name></name></expr></argument>,
                            <argument><expr><name><name>rt</name>-&gt;<name>lengthSquaredSum</name></name></expr></argument>, <argument><expr>&amp;<name>sigma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%lu total strings, mean length %g (sigma %g)\n"</expr></argument>,
            <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>rt</name>-&gt;<name>totalStrings</name></name></expr></argument>, <argument><expr><name>mean</name></expr></argument>, <argument><expr><name>sigma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mean</name> = <call><name>JS_MeanAndStdDev</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>totalDependentStrings</name></name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>strdepLengthSum</name></name></expr></argument>,
                            <argument><expr><name><name>rt</name>-&gt;<name>strdepLengthSquaredSum</name></name></expr></argument>, <argument><expr>&amp;<name>sigma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%lu total dependent strings, mean length %g (sigma %g)\n"</expr></argument>,
            <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>rt</name>-&gt;<name>totalDependentStrings</name></name></expr></argument>, <argument><expr><name>mean</name></expr></argument>, <argument><expr><name>sigma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JSFlatString</name> *</type>
<name>js_NewStringCopyN</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>NewShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>news</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>news</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>news</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>news</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSFlatString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>news</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>news</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><name>JSFlatString</name> *</type>
<name>js_NewStringCopyN</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>NewShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name>js_InflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>JSFlatString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><name>JSFlatString</name> *</type>
<name>js_NewStringCopyZ</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>js_strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>JSShortString</name>::<name>fitsIntoShortString</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>NewShortString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr>(<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>news</name> <init>= <expr>(<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>news</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>news</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSFlatString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>news</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>news</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><name>JSFlatString</name> *</type>
<name>js_NewStringCopyZ</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_NewStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>js_ValueToPrintable</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>, <param><decl><type><name>JSAutoByteString</name> *</type><name>bytes</name></decl></param>, <param><decl><type><name>bool</name></type> <name>asSource</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = (<name>asSource</name> ? <name>js_ValueToSource</name> : <name>js_ValueToString</name>)(<name>cx</name>, <name>v</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str</name> = <call><name>js_QuoteString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>bytes</name>-&gt;<name>encode</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSString</name> *</type>
<name>js_ValueToString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name></type> <name>v</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isObject</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>DefaultValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<call><name><name>v</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>JSTYPE_STRING</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isString</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name><name>v</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>v</name>.<name>isInt32</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>js_IntToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>v</name>.<name>toInt32</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>v</name>.<name>isDouble</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>js_NumberToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>v</name>.<name>toDouble</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>v</name>.<name>isBoolean</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>js_BooleanToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>v</name>.<name>toBoolean</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>v</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>nullAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_VOID</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSBool</name></type>
<name>AppendAtom</name><parameter_list>(<param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSCharBuffer</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>atom</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>atom</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This function implements E-262-3 section 9.8, toString. */</comment>
<function><type><name>JSBool</name></type>
<name>js_ValueToCharBuffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>arg</name></decl></param>, <param><decl><type><name>JSCharBuffer</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name></type> <name>v</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isObject</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>DefaultValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<call><name><name>v</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>JSTYPE_STRING</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name><name>v</name>.<name>isString</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name><name>v</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <return>return <expr><call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isNumber</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>js_NumberValueToCharBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isBoolean</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>js_BooleanToCharBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>v</name>.<name>toBoolean</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>AppendAtom</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>nullAtom</name></name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>v</name>.<name>isUndefined</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>AppendAtom</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_VOID</name></expr>]</index></name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSString *</argument>)</argument_list></macro>
<macro><name>js_ValueToSource</name><argument_list>(<argument>JSContext *cx</argument>, <argument>const Value &amp;v</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isUndefined</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>void0Atom</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isString</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>js_QuoteString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>v</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isPrimitive</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Special case to preserve negative zero, _contra_ toString. */</comment>
        <if>if <condition>(<expr><call><name><name>v</name>.<name>isDouble</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr><call><name><name>v</name>.<name>toDouble</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* NB: _ucNstr rather than _ucstr to indicate non-terminated. */</comment>
            <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jschar</name></type> <name><name>js_negzero_ucNstr</name><index>[]</index></name> <init>= <expr><block>{<expr>'-'</expr>, <expr>'0'</expr>}</block></expr></init></decl>;</decl_stmt>

            <return>return <expr><call><name>js_NewStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_negzero_ucNstr</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>toSourceAtom</name></name></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>AutoValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name>js_TryMethod</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<call><name><name>v</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<namespace>namespace <name>js</name> <block>{

<comment type="block">/*
 * str is not necessarily a GC thing here.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
<name>EqualStringsTail</name><parameter_list>(<param><decl><type><name>JSLinearString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length1</name></decl></param>, <param><decl><type><name>JSLinearString</name> *</type><name>str2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s1</name> <init>= <expr><call><name><name>str1</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s1end</name> <init>= <expr><name>s1</name> + <name>length1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s2</name> <init>= <expr><call><name><name>str2</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <do>do <block>{
        <if>if <condition>(<expr>*<name>s1</name> != *<name>s2</name></expr>)</condition><then> <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr>++<name>s1</name></expr>, <expr>++<name>s2</name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>s1</name> != <name>s1end</name></expr>)</condition>;</do>

    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name>EqualStrings</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str2</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>str1</name> == <name>str2</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>result</name> = true</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length1</name> <init>= <expr><call><name><name>str1</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>length1</name> != <call><name><name>str2</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>result</name> = false</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>length1</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>result</name> = true</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>linear1</name> <init>= <expr><call><name><name>str1</name>-&gt;<name>ensureLinear</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>linear1</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>linear2</name> <init>= <expr><call><name><name>str2</name>-&gt;<name>ensureLinear</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>linear2</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr>*<name>result</name> = <call><name>EqualStringsTail</name><argument_list>(<argument><expr><name>linear1</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>, <argument><expr><name>linear2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name>EqualStrings</name><parameter_list>(<param><decl><type><name>JSLinearString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>JSLinearString</name> *</type><name>str2</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>str1</name> == <name>str2</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length1</name> <init>= <expr><call><name><name>str1</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>length1</name> != <call><name><name>str2</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr><name>length1</name> == 0</expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>

    <return>return <expr><call><name>EqualStringsTail</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

}</block></namespace>  <comment type="block">/* namespace js */</comment>

<function><type><name>JSBool</name> <name>JS_FASTCALL</name></type>
<name>js_EqualStringsOnTrace</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>result</name></decl>;</decl_stmt>
    <return>return <expr><call><name>EqualStrings</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call> ? <name>result</name> : <name>JS_NEITHER</name></expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_3</name><argument_list>(<argument>extern</argument>, <argument>BOOL</argument>, <argument>js_EqualStringsOnTrace</argument>,
                     <argument>CONTEXT</argument>, <argument>STRING</argument>, <argument>STRING</argument>, <argument>1</argument>, <argument>nanojit::ACCSET_NONE</argument>)</argument_list></macro>

<namespace>namespace <name>js</name> <block>{

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CompareStringsImpl</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str2</name></decl></param>, <param><decl><type><name>int32</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>str1</name> == <name>str2</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>l1</name> <init>= <expr><call><name><name>str1</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s1</name> <init>= <expr><call><name><name>str1</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>s1</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>l2</name> <init>= <expr><call><name><name>str2</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s2</name> <init>= <expr><call><name><name>str2</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>s2</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>JS_MIN</name><argument_list>(<argument><expr><name>l1</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<decl><type><name>int32</name></type> <name>cmp</name> <init>= <expr><name><name>s1</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>s2</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>)</condition><then> <block>{
            <expr_stmt><expr>*<name>result</name> = <name>cmp</name></expr>;</expr_stmt>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr>*<name>result</name> = <call>(<name>int32</name>)<argument_list>(<argument><expr><name>l1</name> - <name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name>CompareStrings</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str2</name></decl></param>, <param><decl><type><name>int32</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>CompareStringsImpl</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

}</block></namespace>  <comment type="block">/* namespace js */</comment>

<function><type><name>int32</name> <name>JS_FASTCALL</name></type>
<name>js_CompareStringsOnTrace</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int32</name></type> <name>result</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>CompareStringsImpl</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>INT32_MIN</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>result</name> != <name>INT32_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_3</name><argument_list>(<argument>extern</argument>, <argument>INT32</argument>, <argument>js_CompareStringsOnTrace</argument>,
                     <argument>CONTEXT</argument>, <argument>STRING</argument>, <argument>STRING</argument>, <argument>1</argument>, <argument>nanojit::ACCSET_NONE</argument>)</argument_list></macro>

<namespace>namespace <name>js</name> <block>{

<function><type><name>bool</name></type>
<name>StringEqualsAscii</name><parameter_list>(<param><decl><type><name>JSLinearString</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>asciiBytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>asciiBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> != <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name><name>asciiBytes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &lt;= 127</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>length</name> != <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> != <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>unsigned</name><argument_list>(<argument><expr><name><name>asciiBytes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> != <call><name>unsigned</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
    }</block></for>
    <return>return <expr>true</expr>;</return>
}</block></function>

}</block></namespace> <comment type="block">/* namespacejs */</comment>

<function><type><name>size_t</name></type>
<name>js_strlen</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>t</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>t</name> = <name>s</name></expr>;</init> <condition><expr>*<name>t</name> != 0</expr>;</condition> <incr><expr><name>t</name>++</expr></incr>)
        <continue>continue;</continue></for>
    <return>return <expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>t</name> - <name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>jschar</name> *</type>
<name>js_strchr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl></param>, <param><decl><type><name>jschar</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr>*<name>s</name> != 0</expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>s</name> == <name>c</name></expr>)</condition><then>
            <return>return <expr>(<name>jschar</name> *)<name>s</name></expr>;</return></then></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>jschar</name> *</type>
<name>js_strchr_limit</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl></param>, <param><decl><type><name>jschar</name></type> <name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>limit</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name>s</name> &lt; <name>limit</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>s</name> == <name>c</name></expr>)</condition><then>
            <return>return <expr>(<name>jschar</name> *)<name>s</name></expr>;</return></then></if>
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>jschar</name> *</type>
<name>js_InflateString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>lengthp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>, <decl><type ref="prev"/><name>nchars</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>nbytes</name> = *<name>lengthp</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>js_CStringsAreUTF8</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_InflateStringToBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>nchars</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
        <expr_stmt><expr><name>chars</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>nchars</name> + 1) * <sizeof>sizeof <argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name>ok</name> =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <call><name>js_InflateStringToBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr>&amp;<name>nchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>nchars</name> = <name>nbytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>chars</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>nchars</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nchars</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>unsigned</name> <name>char</name>) <name><name>bytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    }</block></else></if>
    <expr_stmt><expr>*<name>lengthp</name> = <name>nchars</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>nchars</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>chars</name></expr>;</return>

  <label><name>bad</name>:</label>
    <comment type="block">/*
     * For compatibility with callers of JS_DecodeBytes we must zero lengthp
     * on errors.
     */</comment>
    <expr_stmt><expr>*<name>lengthp</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * May be called with null cx.
 */</comment>
<function><type><name>char</name> *</type>
<name>js_DeflateString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nchars</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>js_CStringsAreUTF8</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nbytes</name> = <call><name>js_GetDeflatedStringLength</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>nchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nbytes</name> == (<name>size_t</name>) -1</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>bytes</name> = (<name>char</name> *) (<name>cx</name> ? <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>nbytes</name> + 1</expr></argument>)</argument_list></call> : <call><name>js_malloc</name><argument_list>(<argument><expr><name>nbytes</name> + 1</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name>ok</name> =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <call><name>js_DeflateStringToBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>nchars</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>nbytes</name> = <name>nchars</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes</name> = (<name>char</name> *) (<name>cx</name> ? <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>nbytes</name> + 1</expr></argument>)</argument_list></call> : <call><name>js_malloc</name><argument_list>(<argument><expr><name>nbytes</name> + 1</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nbytes</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>) <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    }</block></else></if>
    <expr_stmt><expr><name><name>bytes</name><index>[<expr><name>nbytes</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>bytes</name></expr>;</return>
}</block></function>

<function><type><name>size_t</name></type>
<name>js_GetDeflatedStringLength</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nchars</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>js_CStringsAreUTF8</name></expr>)</condition><then>
        <return>return <expr><name>nchars</name></expr>;</return></then></if>

    <return>return <expr><call><name>js_GetDeflatedUTF8StringLength</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>nchars</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * May be called with null cx through public API, see below.
 */</comment>
<function><type><name>size_t</name></type>
<name>js_GetDeflatedUTF8StringLength</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nchars</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nbytes</name> = <name>nchars</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>end</name> = <name>chars</name> + <name>nchars</name></expr>;</init> <condition><expr><name>chars</name> != <name>end</name></expr>;</condition> <incr><expr><name>chars</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>c</name> = *<name>chars</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>c</name> &lt; 0x80</expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <if>if <condition>(<expr>0xD800 &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
            <comment type="block">/* Surrogate pair. */</comment>
            <expr_stmt><expr><name>chars</name>++</expr>;</expr_stmt>

            <comment type="block">/* nbytes sets 1 length since this is surrogate pair. */</comment>
            <expr_stmt><expr><name>nbytes</name>--</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>c</name> &gt;= 0xDC00 || <name>chars</name> == <name>end</name></expr>)</condition><then>
                <goto>goto <name>bad_surrogate</name>;</goto></then></if>
            <expr_stmt><expr><name>c2</name> = *<name>chars</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>c2</name> <argument_list>&lt; <argument><expr>0xDC00 || <name>c2</name></expr></argument> &gt;</argument_list></name> 0xDFFF</expr>)</condition><then>
                <goto>goto <name>bad_surrogate</name>;</goto></then></if>
            <expr_stmt><expr><name>c</name> = ((<name>c</name> - 0xD800) &lt;&lt; 10) + (<name>c2</name> - 0xDC00) + 0x10000</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>c</name> &gt;&gt;= 11</expr>;</expr_stmt>
        <expr_stmt><expr><name>nbytes</name>++</expr>;</expr_stmt>
        <while>while <condition>(<expr><name>c</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>c</name> &gt;&gt;= 5</expr>;</expr_stmt>
            <expr_stmt><expr><name>nbytes</name>++</expr>;</expr_stmt>
        }</block></while>
    }</block></for>
    <return>return <expr><name>nbytes</name></expr>;</return>

  <label><name>bad_surrogate</name>:</label>
    <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>"0x%x"</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_BAD_SURROGATE_CHAR</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name>size_t</name>) -1</expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_DeflateStringToBuffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>src</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>srclen</name></decl></param>,
                         <param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>dstlenp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>dstlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dstlen</name> = *<name>dstlenp</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>js_CStringsAreUTF8</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>srclen</name> &gt; <name>dstlen</name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>dstlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>) <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
            <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_BUFFER_TOO_SMALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>srclen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>) <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
        <expr_stmt><expr>*<name>dstlenp</name> = <name>srclen</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>js_DeflateStringToUTF8Buffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srclen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstlenp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_DeflateStringToUTF8Buffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>src</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>srclen</name></decl></param>,
                             <param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>dstlenp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>dstlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>origDstlen</name></decl>, <decl><type ref="prev"/><name>utf8Len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type> <name><name>utf8buf</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dstlen</name> = *<name>dstlenp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>origDstlen</name> = <name>dstlen</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>srclen</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>srclen</name>--</expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>c</name> &gt;= 0xDC00) &amp;&amp; (<name>c</name> &lt;= 0xDFFF)</expr>)</condition><then>
            <goto>goto <name>badSurrogate</name>;</goto></then></if>
        <if>if <condition>(<expr><name><name>c</name> <argument_list>&lt; <argument><expr>0xD800 || <name>c</name></expr></argument> &gt;</argument_list></name> 0xDBFF</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>v</name> = <name>c</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>srclen</name> &lt; 1</expr>)</condition><then>
                <goto>goto <name>badSurrogate</name>;</goto></then></if>
            <expr_stmt><expr><name>c2</name> = *<name>src</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>c2</name> &lt; 0xDC00) || (<name>c2</name> &gt; 0xDFFF)</expr>)</condition><then>
                <goto>goto <name>badSurrogate</name>;</goto></then></if>
            <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>srclen</name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> = ((<name>c</name> - 0xD800) &lt;&lt; 10) + (<name>c2</name> - 0xDC00) + 0x10000</expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>v</name> &lt; 0x0080</expr>)</condition><then> <block>{
            <comment type="block">/* no encoding necessary - performance hack */</comment>
            <if>if <condition>(<expr><name>dstlen</name> == 0</expr>)</condition><then>
                <goto>goto <name>bufferTooSmall</name>;</goto></then></if>
            <expr_stmt><expr>*<name>dst</name>++ = (<name>char</name>) <name>v</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>utf8Len</name> = 1</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>utf8Len</name> = <call><name>js_OneUcs4ToUtf8Char</name><argument_list>(<argument><expr><name>utf8buf</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>utf8Len</name> &gt; <name>dstlen</name></expr>)</condition><then>
                <goto>goto <name>bufferTooSmall</name>;</goto></then></if>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>utf8Len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr>*<name>dst</name>++ = (<name>char</name>) <name><name>utf8buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
        }</block></else></if>
        <expr_stmt><expr><name>dstlen</name> -= <name>utf8Len</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<label><name>badSurrogate</name>:</label>
    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
    <comment type="block">/* Delegate error reporting to the measurement function. */</comment>
    <if>if <condition>(<expr><name>cx</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_GetDeflatedStringLength</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>src</name> - 1</expr></argument>, <argument><expr><name>srclen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>

<label><name>bufferTooSmall</name>:</label>
    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_BUFFER_TOO_SMALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_InflateStringToBuffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>srclen</name></decl></param>,
                         <param><decl><type><name>jschar</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>dstlenp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>dstlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>js_CStringsAreUTF8</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>dst</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dstlen</name> = *<name>dstlenp</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>srclen</name> &gt; <name>dstlen</name></expr>)</condition><then> <block>{
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>dstlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                    <expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>unsigned</name> <name>char</name>) <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
                <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>JSMSG_BUFFER_TOO_SMALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>srclen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>unsigned</name> <name>char</name>) <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
        }</block></then></if>
        <expr_stmt><expr>*<name>dstlenp</name> = <name>srclen</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>js_InflateUTF8StringToBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srclen</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstlenp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_InflateUTF8StringToBuffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>srclen</name></decl></param>,
                             <param><decl><type><name>jschar</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>dstlenp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>dstlen</name></decl>, <decl><type ref="prev"/><name>origDstlen</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>v</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dstlen</name> = <name>dst</name> ? *<name>dstlenp</name> : (<name>size_t</name>) -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>origDstlen</name> = <name>dstlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>

    <while>while <condition>(<expr><name>srclen</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>v</name> = (<name>uint8</name>) *<name>src</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>v</name> &amp; 0x80</expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>v</name> &amp; (0x80 &gt;&gt; <name>n</name>)</expr>)</condition>
                <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></while>
            <if>if <condition>(<expr><name>n</name> &gt; <name>srclen</name></expr>)</condition><then>
                <goto>goto <name>bufferTooSmall</name>;</goto></then></if>
            <if>if <condition>(<expr><name>n</name> == 1 || <name>n</name> &gt; 4</expr>)</condition><then>
                <goto>goto <name>badCharacter</name>;</goto></then></if>
            <for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr>(<name><name>src</name><index>[<expr><name>j</name></expr>]</index></name> &amp; 0xC0) != 0x80</expr>)</condition><then>
                    <goto>goto <name>badCharacter</name>;</goto></then></if>
            }</block></for>
            <expr_stmt><expr><name>v</name> = <call><name>Utf8ToOneUcs4Char</name><argument_list>(<argument><expr>(<name>uint8</name> *)<name>src</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>v</name> &gt;= 0x10000</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>v</name> -= 0x10000</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>v</name> &gt; 0xFFFFF || <name>dstlen</name> &lt; 2</expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>"0x%x"</expr></argument>, <argument><expr><name>v</name> + 0x10000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                                                     <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                                     <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                     <argument><expr><name>JSMSG_UTF8_CHAR_TOO_LARGE</name></expr></argument>,
                                                     <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><name>dst</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>dst</name>++ = <call>(<name>jschar</name>)<argument_list>(<argument><expr>(<name>v</name> &gt;&gt; 10) + 0xD800</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>v</name> = <call>(<name>jschar</name>)<argument_list>(<argument><expr>(<name>v</name> &amp; 0x3FF) + 0xDC00</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>dstlen</name>--</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>dstlen</name></expr>)</condition><then>
            <goto>goto <name>bufferTooSmall</name>;</goto></then></if>
        <if>if <condition>(<expr><name>dst</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>dst</name>++ = (<name>jschar</name>) <name>v</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>dstlen</name>--</expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> += <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>src</name> += <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>srclen</name> -= <name>n</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<label><name>badCharacter</name>:</label>
    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                     <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_MALFORMED_UTF8_CHAR</name></expr></argument>,
                                     <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>

<label><name>bufferTooSmall</name>:</label>
    <expr_stmt><expr>*<name>dstlenp</name> = (<name>origDstlen</name> - <name>dstlen</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_BUFFER_TOO_SMALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * From java.lang.Character.java:
 *
 * The character properties are currently encoded into 32 bits in the
 * following manner:
 *
 * 10 bits      signed offset used for converting case
 *  1 bit       if 1, adding the signed offset converts the character to
 *              lowercase
 *  1 bit       if 1, subtracting the signed offset converts the character to
 *              uppercase
 *  1 bit       if 1, character has a titlecase equivalent (possibly itself)
 *  3 bits      0  may not be part of an identifier
 *              1  ignorable control; may continue a Unicode identifier or JS
 *                 identifier
 *              2  may continue a JS identifier but not a Unicode identifier
 *                 (unused)
 *              3  may continue a Unicode identifier or JS identifier
 *              4  is a JS whitespace character
 *              5  may start or continue a JS identifier;
 *                 may continue but not start a Unicode identifier (_)
 *              6  may start or continue a JS identifier but not a Unicode
 *                 identifier ($)
 *              7  may start or continue a Unicode identifier or JS identifier
 *              Thus:
 *                 5, 6, 7 may start a JS identifier
 *                 1, 2, 3, 5, 6, 7 may continue a JS identifier
 *                 7 may start a Unicode identifier
 *                 1, 3, 5, 7 may continue a Unicode identifier
 *                 1 is ignorable within an identifier
 *                 4 is JS whitespace
 *  2 bits      0  this character has no numeric property
 *              1  adding the digit offset to the character code and then
 *                 masking with 0x1F will produce the desired numeric value
 *              2  this character has a "strange" numeric value
 *              3  a JS supradecimal digit: adding the digit offset to the
 *                 character code, then masking with 0x1F, then adding 10
 *                 will produce the desired numeric value
 *  5 bits      digit offset
 *  1 bit       XML 1.0 name start character
 *  1 bit       XML 1.0 name character
 *  2 bits      reserved for future use
 *  5 bits      character type
 */</comment>

<comment type="block">/* The X table has 1024 entries for a total of 1024 bytes. */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8</name></type> <name><name>js_X</name><index>[]</index></name> <init>= <expr><block>{
  <expr>0</expr>,   <expr>1</expr>,   <expr>2</expr>,   <expr>3</expr>,   <expr>4</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>7</expr>,  <comment type="block">/*  0x0000 */</comment>
  <expr>8</expr>,   <expr>9</expr>,  <expr>10</expr>,  <expr>11</expr>,  <expr>12</expr>,  <expr>13</expr>,  <expr>14</expr>,  <expr>15</expr>,  <comment type="block">/*  0x0200 */</comment>
 <expr>16</expr>,  <expr>17</expr>,  <expr>18</expr>,  <expr>19</expr>,  <expr>20</expr>,  <expr>21</expr>,  <expr>22</expr>,  <expr>23</expr>,  <comment type="block">/*  0x0400 */</comment>
 <expr>24</expr>,  <expr>25</expr>,  <expr>26</expr>,  <expr>27</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x0600 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>29</expr>,  <expr>30</expr>,  <expr>31</expr>,  <expr>32</expr>,  <comment type="block">/*  0x0800 */</comment>
 <expr>33</expr>,  <expr>34</expr>,  <expr>35</expr>,  <expr>36</expr>,  <expr>37</expr>,  <expr>38</expr>,  <expr>39</expr>,  <expr>40</expr>,  <comment type="block">/*  0x0A00 */</comment>
 <expr>41</expr>,  <expr>42</expr>,  <expr>43</expr>,  <expr>44</expr>,  <expr>45</expr>,  <expr>46</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x0C00 */</comment>
 <expr>47</expr>,  <expr>48</expr>,  <expr>49</expr>,  <expr>50</expr>,  <expr>51</expr>,  <expr>52</expr>,  <expr>53</expr>,  <expr>28</expr>,  <comment type="block">/*  0x0E00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>54</expr>,  <expr>55</expr>,  <expr>56</expr>,  <expr>57</expr>,  <expr>58</expr>,  <expr>59</expr>,  <comment type="block">/*  0x1000 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x1200 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x1400 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x1600 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x1800 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x1A00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x1C00 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>61</expr>,  <expr>62</expr>,  <expr>63</expr>,  <expr>64</expr>,  <expr>65</expr>,  <expr>66</expr>,  <comment type="block">/*  0x1E00 */</comment>
 <expr>67</expr>,  <expr>68</expr>,  <expr>69</expr>,  <expr>70</expr>,  <expr>71</expr>,  <expr>72</expr>,  <expr>73</expr>,  <expr>74</expr>,  <comment type="block">/*  0x2000 */</comment>
 <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>76</expr>,  <expr>77</expr>,  <expr>78</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x2200 */</comment>
 <expr>79</expr>,  <expr>80</expr>,  <expr>81</expr>,  <expr>82</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>84</expr>,  <expr>85</expr>,  <comment type="block">/*  0x2400 */</comment>
 <expr>86</expr>,  <expr>85</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>87</expr>,  <expr>88</expr>,  <expr>89</expr>,  <expr>28</expr>,  <comment type="block">/*  0x2600 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x2800 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x2A00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x2C00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x2E00 */</comment>
 <expr>90</expr>,  <expr>91</expr>,  <expr>92</expr>,  <expr>93</expr>,  <expr>94</expr>,  <expr>56</expr>,  <expr>95</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3000 */</comment>
 <expr>96</expr>,  <expr>97</expr>,  <expr>98</expr>,  <expr>99</expr>,  <expr>83</expr>, <expr>100</expr>,  <expr>83</expr>, <expr>101</expr>,  <comment type="block">/*  0x3200 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3400 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3600 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3800 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3A00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3C00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x3E00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4000 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4200 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4400 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4600 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4800 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4A00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0x4C00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x4E00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5A00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5C00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x5E00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6A00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6C00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x6E00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7A00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7C00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x7E00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8A00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8C00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x8E00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9A00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0x9C00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>, <expr>102</expr>,  <expr>28</expr>,  <comment type="block">/*  0x9E00 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0xA000 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0xA200 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0xA400 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0xA600 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0xA800 */</comment>
 <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>,  <comment type="block">/*  0xAA00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xAC00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xAE00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xB000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xB200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xB400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xB600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xB800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xBA00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xBC00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xBE00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xC000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xC200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xC400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xC600 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xC800 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xCA00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xCC00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xCE00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xD000 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xD200 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xD400 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>, <expr>103</expr>,  <expr>28</expr>,  <comment type="block">/*  0xD600 */</comment>
<expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <comment type="block">/*  0xD800 */</comment>
<expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <comment type="block">/*  0xDA00 */</comment>
<expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <comment type="block">/*  0xDC00 */</comment>
<expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <comment type="block">/*  0xDE00 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xE000 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xE200 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xE400 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xE600 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xE800 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xEA00 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xEC00 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xEE00 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xF000 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xF200 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xF400 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <comment type="block">/*  0xF600 */</comment>
<expr>105</expr>, <expr>105</expr>, <expr>105</expr>, <expr>105</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <comment type="block">/*  0xF800 */</comment>
<expr>106</expr>,  <expr>28</expr>,  <expr>28</expr>,  <expr>28</expr>, <expr>107</expr>, <expr>108</expr>, <expr>109</expr>, <expr>110</expr>,  <comment type="block">/*  0xFA00 */</comment>
 <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>,  <expr>56</expr>, <expr>111</expr>, <expr>112</expr>, <expr>113</expr>, <expr>114</expr>,  <comment type="block">/*  0xFC00 */</comment>
<expr>115</expr>, <expr>116</expr>,  <expr>56</expr>, <expr>117</expr>, <expr>118</expr>, <expr>119</expr>, <expr>120</expr>, <expr>121</expr>   <comment type="block">/*  0xFE00 */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The Y table has 7808 entries for a total of 7808 bytes. */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8</name></type> <name><name>js_Y</name><index>[]</index></name> <init>= <expr><block>{
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    0 */</comment>
  <expr>0</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>1</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    0 */</comment>
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    0 */</comment>
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    0 */</comment>
  <expr>2</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>4</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*    0 */</comment>
  <expr>5</expr>,   <expr>6</expr>,   <expr>3</expr>,   <expr>7</expr>,   <expr>3</expr>,   <expr>8</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*    0 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,  <comment type="block">/*    0 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>3</expr>,  <comment type="block">/*    0 */</comment>
  <expr>3</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <comment type="block">/*    1 */</comment>
 <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <comment type="block">/*    1 */</comment>
 <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <comment type="block">/*    1 */</comment>
 <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,   <expr>5</expr>,   <expr>3</expr>,   <expr>6</expr>,  <expr>11</expr>,  <expr>12</expr>,  <comment type="block">/*    1 */</comment>
 <expr>11</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <comment type="block">/*    1 */</comment>
 <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <comment type="block">/*    1 */</comment>
 <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <comment type="block">/*    1 */</comment>
 <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,   <expr>5</expr>,   <expr>7</expr>,   <expr>6</expr>,   <expr>7</expr>,   <expr>0</expr>,  <comment type="block">/*    1 */</comment>
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    2 */</comment>
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    2 */</comment>
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    2 */</comment>
  <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,   <expr>0</expr>,  <comment type="block">/*    2 */</comment>
  <expr>2</expr>,   <expr>3</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*    2 */</comment>
 <expr>11</expr>,  <expr>15</expr>,  <expr>16</expr>,   <expr>5</expr>,   <expr>7</expr>,   <expr>8</expr>,  <expr>15</expr>,  <expr>11</expr>,  <comment type="block">/*    2 */</comment>
 <expr>15</expr>,   <expr>7</expr>,  <expr>17</expr>,  <expr>17</expr>,  <expr>11</expr>,  <expr>16</expr>,  <expr>15</expr>,   <expr>3</expr>,  <comment type="block">/*    2 */</comment>
 <expr>11</expr>,  <expr>18</expr>,  <expr>16</expr>,   <expr>6</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,   <expr>3</expr>,  <comment type="block">/*    2 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*    3 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*    3 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,   <expr>7</expr>,  <comment type="block">/*    3 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>16</expr>,  <comment type="block">/*    3 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*    3 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*    3 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,   <expr>7</expr>,  <comment type="block">/*    3 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>22</expr>,  <comment type="block">/*    3 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>25</expr>,  <expr>26</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    4 */</comment>
 <expr>16</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <comment type="block">/*    4 */</comment>
 <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <comment type="block">/*    5 */</comment>
 <expr>24</expr>,  <expr>16</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    5 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    5 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    5 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    5 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    5 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    5 */</comment>
 <expr>27</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>28</expr>,  <comment type="block">/*    5 */</comment>
 <expr>16</expr>,  <expr>29</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>30</expr>,  <expr>23</expr>,  <comment type="block">/*    6 */</comment>
 <expr>24</expr>,  <expr>31</expr>,  <expr>31</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>16</expr>,  <expr>32</expr>,  <expr>32</expr>,  <comment type="block">/*    6 */</comment>
 <expr>33</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>31</expr>,  <expr>34</expr>,  <expr>16</expr>,  <expr>35</expr>,  <expr>36</expr>,  <comment type="block">/*    6 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>35</expr>,  <expr>37</expr>,  <expr>16</expr>,  <expr>38</expr>,  <comment type="block">/*    6 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>38</expr>,  <expr>23</expr>,  <comment type="block">/*    6 */</comment>
 <expr>24</expr>,  <expr>39</expr>,  <expr>40</expr>,  <expr>16</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>39</expr>,  <expr>23</expr>,  <comment type="block">/*    6 */</comment>
 <expr>24</expr>,  <expr>41</expr>,  <expr>41</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>42</expr>,  <comment type="block">/*    6 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>16</expr>,  <expr>40</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*    6 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>43</expr>,  <expr>44</expr>,  <expr>45</expr>,  <expr>43</expr>,  <comment type="block">/*    7 */</comment>
 <expr>44</expr>,  <expr>45</expr>,  <expr>43</expr>,  <expr>44</expr>,  <expr>45</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <comment type="block">/*    7 */</comment>
 <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <comment type="block">/*    7 */</comment>
 <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>16</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    7 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    7 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    7 */</comment>
 <expr>16</expr>,  <expr>43</expr>,  <expr>44</expr>,  <expr>45</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    7 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    7 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    8 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    8 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*    8 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    8 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    8 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    8 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    8 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    8 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    9 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*    9 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>47</expr>,  <expr>48</expr>,  <expr>16</expr>,  <expr>49</expr>,  <expr>49</expr>,  <comment type="block">/*    9 */</comment>
 <expr>50</expr>,  <expr>50</expr>,  <expr>16</expr>,  <expr>51</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*    9 */</comment>
 <expr>49</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>52</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*    9 */</comment>
 <expr>53</expr>,  <expr>54</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>54</expr>,  <comment type="block">/*    9 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>55</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*    9 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*    9 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>56</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   10 */</comment>
 <expr>56</expr>,  <expr>16</expr>,  <expr>57</expr>,  <expr>57</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   10 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>58</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   10 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   10 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   10 */</comment>
 <expr>16</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   10 */</comment>
 <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <comment type="block">/*   10 */</comment>
 <expr>59</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <comment type="block">/*   10 */</comment>
 <expr>59</expr>,  <expr>59</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   11 */</comment>
 <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   11 */</comment>
 <expr>59</expr>,  <expr>59</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   11 */</comment>
 <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>46</expr>,  <comment type="block">/*   11 */</comment>
 <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   11 */</comment>
 <expr>11</expr>,  <expr>11</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   11 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   11 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   11 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   12 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>59</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>3</expr>,  <expr>46</expr>,  <comment type="block">/*   13 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>61</expr>,   <expr>3</expr>,  <comment type="block">/*   14 */</comment>
 <expr>62</expr>,  <expr>62</expr>,  <expr>62</expr>,  <expr>46</expr>,  <expr>63</expr>,  <expr>46</expr>,  <expr>64</expr>,  <expr>64</expr>,  <comment type="block">/*   14 */</comment>
 <expr>16</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   14 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   14 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>46</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   14 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>65</expr>,  <expr>66</expr>,  <expr>66</expr>,  <expr>66</expr>,  <comment type="block">/*   14 */</comment>
 <expr>16</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   14 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   14 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>16</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   15 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>67</expr>,  <expr>68</expr>,  <expr>68</expr>,  <expr>46</expr>,  <comment type="block">/*   15 */</comment>
 <expr>69</expr>,  <expr>70</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>71</expr>,  <expr>72</expr>,  <expr>46</expr>,  <comment type="block">/*   15 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>38</expr>,  <expr>46</expr>,  <expr>38</expr>,  <expr>46</expr>,  <expr>38</expr>,  <expr>46</expr>,  <comment type="block">/*   15 */</comment>
 <expr>38</expr>,  <expr>46</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   15 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   15 */</comment>
 <expr>73</expr>,  <expr>74</expr>,  <expr>16</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   15 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   15 */</comment>
 <expr>46</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <comment type="block">/*   16 */</comment>
 <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>75</expr>,  <expr>46</expr>,  <expr>75</expr>,  <expr>75</expr>,  <comment type="block">/*   16 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   16 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   16 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   16 */</comment>
 <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <expr>20</expr>,  <comment type="block">/*   16 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   16 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   16 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   17 */</comment>
 <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <expr>21</expr>,  <comment type="block">/*   17 */</comment>
 <expr>46</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <comment type="block">/*   17 */</comment>
 <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>74</expr>,  <expr>46</expr>,  <expr>74</expr>,  <expr>74</expr>,  <comment type="block">/*   17 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   17 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   17 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   17 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   17 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>15</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <comment type="block">/*   18 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   18 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   18 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   18 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   18 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   18 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   18 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   18 */</comment>
 <expr>40</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>23</expr>,  <comment type="block">/*   19 */</comment>
 <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   19 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   19 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   19 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   19 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   19 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   19 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   19 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   20 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   20 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   20 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   20 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   20 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   20 */</comment>
 <expr>46</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   20 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   20 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   21 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   21 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>46</expr>,  <comment type="block">/*   21 */</comment>
 <expr>46</expr>,  <expr>59</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*   21 */</comment>
 <expr>46</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <comment type="block">/*   21 */</comment>
 <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <comment type="block">/*   21 */</comment>
 <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <comment type="block">/*   21 */</comment>
 <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <comment type="block">/*   21 */</comment>
 <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>77</expr>,  <expr>16</expr>,  <comment type="block">/*   22 */</comment>
 <expr>46</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   22 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   22 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   22 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   22 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   22 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   22 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,   <expr>3</expr>,  <expr>60</expr>,  <comment type="block">/*   22 */</comment>
  <expr>3</expr>,  <expr>60</expr>,  <expr>60</expr>,   <expr>3</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   23 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   23 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   23 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   23 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   23 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   23 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   23 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   23 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   24 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   24 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   24 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>3</expr>,  <comment type="block">/*   24 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   24 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   24 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   24 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   24 */</comment>
 <expr>59</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   25 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   25 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   25 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   25 */</comment>
 <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <comment type="block">/*   25 */</comment>
 <expr>78</expr>,  <expr>78</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   25 */</comment>
 <expr>60</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   25 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   25 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   26 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*   26 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   27 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*   27 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,   <expr>3</expr>,  <expr>40</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   27 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>79</expr>,  <expr>79</expr>,  <expr>60</expr>,  <comment type="block">/*   27 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>60</expr>,  <comment type="block">/*   27 */</comment>
 <expr>60</expr>,  <expr>15</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   27 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,  <comment type="block">/*   27 */</comment>
  <expr>9</expr>,   <expr>9</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   27 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   28 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   29 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   29 */</comment>
 <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   30 */</comment>
 <expr>60</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   30 */</comment>
 <expr>15</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   30 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   30 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>60</expr>,  <expr>60</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   30 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   30 */</comment>
  <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   30 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   30 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   31 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   31 */</comment>
 <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <comment type="block">/*   32 */</comment>
 <expr>80</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   32 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <comment type="block">/*   32 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   32 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   32 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   32 */</comment>
 <expr>40</expr>,  <expr>40</expr>,   <expr>4</expr>,   <expr>4</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <comment type="block">/*   32 */</comment>
 <expr>19</expr>,  <expr>83</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   32 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*   33 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   33 */</comment>
 <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <comment type="block">/*   34 */</comment>
 <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   34 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   34 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*   34 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   34 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   34 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   34 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   34 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   35 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   35 */</comment>
 <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>60</expr>,  <comment type="block">/*   36 */</comment>
 <expr>60</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   36 */</comment>
 <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   36 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   36 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   36 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   36 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   36 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   36 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   37 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>80</expr>,  <expr>60</expr>,  <comment type="block">/*   37 */</comment>
 <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <comment type="block">/*   38 */</comment>
 <expr>80</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   38 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>80</expr>,  <comment type="block">/*   38 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   38 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   38 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   38 */</comment>
 <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   38 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   38 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   39 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   39 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   39 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   39 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   39 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   39 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   39 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   39 */</comment>
 <expr>60</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   40 */</comment>
 <expr>80</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   40 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <comment type="block">/*   40 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   40 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <comment type="block">/*   40 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   40 */</comment>
 <expr>84</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   40 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   40 */</comment>
 <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   41 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   41 */</comment>
 <expr>60</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   42 */</comment>
 <expr>60</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   42 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <comment type="block">/*   42 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   42 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   42 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   42 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   42 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   42 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   43 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>60</expr>,  <comment type="block">/*   43 */</comment>
 <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>80</expr>,  <comment type="block">/*   44 */</comment>
 <expr>80</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   44 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <comment type="block">/*   44 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*   44 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   44 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   44 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   44 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   44 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   45 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   45 */</comment>
 <expr>80</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   46 */</comment>
 <expr>80</expr>,  <expr>46</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>80</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   46 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>80</expr>,  <comment type="block">/*   46 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   46 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   46 */</comment>
 <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <expr>81</expr>,  <comment type="block">/*   46 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   46 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   46 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,   <expr>3</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   47 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>4</expr>,  <comment type="block">/*   47 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>59</expr>,  <expr>60</expr>,  <comment type="block">/*   48 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>15</expr>,  <comment type="block">/*   48 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,  <comment type="block">/*   48 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   48 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   48 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   48 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   48 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   48 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   49 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   49 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   49 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   49 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   49 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,   <expr>3</expr>,  <comment type="block">/*   49 */</comment>
 <expr>40</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   49 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   49 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>59</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,  <comment type="block">/*   50 */</comment>
  <expr>9</expr>,   <expr>9</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   50 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*   51 */</comment>
  <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*   51 */</comment>
  <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   51 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   51 */</comment>
 <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <expr>78</expr>,  <comment type="block">/*   51 */</comment>
 <expr>78</expr>,  <expr>78</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <comment type="block">/*   51 */</comment>
 <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>15</expr>,  <expr>60</expr>,  <expr>15</expr>,  <expr>60</expr>,  <comment type="block">/*   51 */</comment>
 <expr>15</expr>,  <expr>60</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,  <expr>80</expr>,  <expr>80</expr>,  <comment type="block">/*   51 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   52 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   52 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   52 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   52 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   52 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   52 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   52 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>80</expr>,  <comment type="block">/*   52 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,   <expr>3</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   53 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   53 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>60</expr>,  <comment type="block">/*   53 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   53 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   53 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   53 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   53 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   53 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   54 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   54 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   54 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   54 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   54 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   54 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   54 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <comment type="block">/*   54 */</comment>
 <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>76</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   55 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   55 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   55 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   55 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   55 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   55 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>46</expr>,  <comment type="block">/*   55 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   55 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   56 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   57 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   58 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   59 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   59 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   60 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   61 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   61 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <expr>23</expr>,  <expr>24</expr>,  <comment type="block">/*   62 */</comment>
 <expr>23</expr>,  <expr>24</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   62 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   63 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   63 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   63 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   63 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   63 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   63 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   63 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   63 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   64 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   64 */</comment>
 <expr>16</expr>,  <expr>86</expr>,  <expr>16</expr>,  <expr>86</expr>,  <expr>16</expr>,  <expr>86</expr>,  <expr>16</expr>,  <expr>86</expr>,  <comment type="block">/*   64 */</comment>
 <expr>46</expr>,  <expr>87</expr>,  <expr>46</expr>,  <expr>87</expr>,  <expr>46</expr>,  <expr>87</expr>,  <expr>46</expr>,  <expr>87</expr>,  <comment type="block">/*   64 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   64 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   64 */</comment>
 <expr>88</expr>,  <expr>88</expr>,  <expr>89</expr>,  <expr>89</expr>,  <expr>89</expr>,  <expr>89</expr>,  <expr>90</expr>,  <expr>90</expr>,  <comment type="block">/*   64 */</comment>
 <expr>91</expr>,  <expr>91</expr>,  <expr>92</expr>,  <expr>92</expr>,  <expr>93</expr>,  <expr>93</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   64 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   65 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   65 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   65 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   65 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <expr>86</expr>,  <comment type="block">/*   65 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <expr>87</expr>,  <comment type="block">/*   65 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>16</expr>,  <expr>94</expr>,  <expr>16</expr>,  <expr>46</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   65 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>95</expr>,  <expr>95</expr>,  <expr>96</expr>,  <expr>11</expr>,  <expr>38</expr>,  <expr>11</expr>,  <comment type="block">/*   65 */</comment>
 <expr>11</expr>,  <expr>11</expr>,  <expr>16</expr>,  <expr>94</expr>,  <expr>16</expr>,  <expr>46</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   66 */</comment>
 <expr>97</expr>,  <expr>97</expr>,  <expr>97</expr>,  <expr>97</expr>,  <expr>96</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   66 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   66 */</comment>
 <expr>87</expr>,  <expr>87</expr>,  <expr>98</expr>,  <expr>98</expr>,  <expr>46</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   66 */</comment>
 <expr>86</expr>,  <expr>86</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>99</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   66 */</comment>
 <expr>87</expr>,  <expr>87</expr>, <expr>100</expr>, <expr>100</expr>, <expr>101</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>11</expr>,  <comment type="block">/*   66 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>16</expr>,  <expr>94</expr>,  <expr>16</expr>,  <expr>46</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   66 */</comment>
<expr>102</expr>, <expr>102</expr>, <expr>103</expr>, <expr>103</expr>,  <expr>96</expr>,  <expr>11</expr>,  <expr>11</expr>,  <expr>46</expr>,  <comment type="block">/*   66 */</comment>
  <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,  <comment type="block">/*   67 */</comment>
  <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>,   <expr>2</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <comment type="block">/*   67 */</comment>
  <expr>8</expr>,   <expr>8</expr>,   <expr>8</expr>,   <expr>8</expr>,   <expr>8</expr>,   <expr>8</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*   67 */</comment>
  <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>5</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>5</expr>,  <comment type="block">/*   67 */</comment>
  <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*   67 */</comment>
<expr>105</expr>, <expr>106</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <expr>46</expr>,  <comment type="block">/*   67 */</comment>
  <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*   67 */</comment>
  <expr>3</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>12</expr>,  <comment type="block">/*   67 */</comment>
 <expr>12</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>7</expr>,   <expr>5</expr>,   <expr>6</expr>,  <expr>46</expr>,  <comment type="block">/*   68 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   68 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   68 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   68 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   68 */</comment>
 <expr>46</expr>,  <expr>46</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>, <expr>104</expr>,  <comment type="block">/*   68 */</comment>
 <expr>17</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>17</expr>,  <expr>17</expr>,  <expr>17</expr>,  <expr>17</expr>,  <comment type="block">/*   68 */</comment>
 <expr>17</expr>,  <expr>17</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>5</expr>,   <expr>6</expr>,  <expr>16</expr>,  <comment type="block">/*   68 */</comment>
<expr>107</expr>, <expr>107</expr>, <expr>107</expr>, <expr>107</expr>, <expr>107</expr>, <expr>107</expr>, <expr>107</expr>, <expr>107</expr>,  <comment type="block">/*   69 */</comment>
<expr>107</expr>, <expr>107</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>5</expr>,   <expr>6</expr>,  <expr>46</expr>,  <comment type="block">/*   69 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   69 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   69 */</comment>
  <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,  <comment type="block">/*   69 */</comment>
  <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,   <expr>4</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   69 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   69 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   69 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   70 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   70 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   70 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>79</expr>,  <expr>79</expr>,  <expr>79</expr>,  <comment type="block">/*   70 */</comment>
 <expr>79</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   70 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   70 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   70 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   70 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>38</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>38</expr>,  <comment type="block">/*   71 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>16</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   71 */</comment>
 <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>16</expr>,  <expr>15</expr>,  <expr>38</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   71 */</comment>
 <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   71 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>38</expr>,  <expr>15</expr>,  <expr>38</expr>,  <expr>15</expr>,  <comment type="block">/*   71 */</comment>
 <expr>38</expr>,  <expr>15</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>38</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*   71 */</comment>
 <expr>38</expr>,  <expr>38</expr>,  <expr>15</expr>,  <expr>38</expr>,  <expr>16</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   71 */</comment>
 <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   71 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   72 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   72 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <comment type="block">/*   72 */</comment>
 <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>,  <expr>19</expr>, <expr>108</expr>,  <comment type="block">/*   72 */</comment>
<expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>109</expr>,  <comment type="block">/*   72 */</comment>
<expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>109</expr>, <expr>110</expr>, <expr>110</expr>, <expr>110</expr>, <expr>110</expr>,  <comment type="block">/*   72 */</comment>
<expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>111</expr>,  <comment type="block">/*   72 */</comment>
<expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>111</expr>, <expr>112</expr>, <expr>112</expr>, <expr>112</expr>, <expr>112</expr>,  <comment type="block">/*   72 */</comment>
<expr>113</expr>, <expr>113</expr>, <expr>113</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   73 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   73 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   73 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   73 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   73 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   73 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   73 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   73 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   74 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   74 */</comment>
 <expr>15</expr>,  <expr>15</expr>,   <expr>7</expr>,  <expr>15</expr>,   <expr>7</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   74 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   74 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   74 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   74 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   74 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   74 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   75 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   76 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   76 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   76 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   76 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   76 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <comment type="block">/*   76 */</comment>
  <expr>7</expr>,   <expr>7</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   76 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   76 */</comment>
 <expr>15</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
  <expr>7</expr>,   <expr>7</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
 <expr>15</expr>,   <expr>5</expr>,   <expr>6</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   77 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   78 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   79 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   79 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   79 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   79 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   79 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   79 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   79 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   79 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   80 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   80 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   80 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   80 */</comment>
<expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>,  <comment type="block">/*   80 */</comment>
<expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>,  <comment type="block">/*   80 */</comment>
<expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <comment type="block">/*   80 */</comment>
 <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <comment type="block">/*   80 */</comment>
 <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <expr>82</expr>,  <comment type="block">/*   81 */</comment>
<expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>,  <comment type="block">/*   81 */</comment>
<expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>,  <comment type="block">/*   81 */</comment>
<expr>115</expr>, <expr>115</expr>, <expr>115</expr>, <expr>115</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   81 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   81 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   81 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>, <expr>116</expr>, <expr>116</expr>,  <comment type="block">/*   81 */</comment>
<expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>,  <comment type="block">/*   81 */</comment>
<expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>,  <comment type="block">/*   82 */</comment>
<expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>, <expr>116</expr>,  <comment type="block">/*   82 */</comment>
<expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>,  <comment type="block">/*   82 */</comment>
<expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>,  <comment type="block">/*   82 */</comment>
<expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>, <expr>117</expr>,  <comment type="block">/*   82 */</comment>
<expr>117</expr>, <expr>117</expr>, <expr>118</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   82 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   82 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   82 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   83 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   84 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   84 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   85 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   85 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   85 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   85 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   85 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   85 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   85 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   85 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   86 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   86 */</comment>
 <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   87 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   88 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>15</expr>,  <comment type="block">/*   88 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*   88 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*   88 */</comment>
 <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   88 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   88 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>, <expr>119</expr>, <expr>119</expr>,  <comment type="block">/*   88 */</comment>
<expr>119</expr>, <expr>119</expr>, <expr>119</expr>, <expr>119</expr>, <expr>119</expr>, <expr>119</expr>, <expr>119</expr>, <expr>119</expr>,  <comment type="block">/*   88 */</comment>
<expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>,  <comment type="block">/*   89 */</comment>
<expr>114</expr>, <expr>114</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>83</expr>,  <comment type="block">/*   89 */</comment>
 <expr>83</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>83</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   89 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   89 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   89 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   89 */</comment>
 <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   89 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*   89 */</comment>
  <expr>2</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>15</expr>,  <expr>59</expr>,   <expr>3</expr>, <expr>120</expr>,  <comment type="block">/*   90 */</comment>
  <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,  <comment type="block">/*   90 */</comment>
  <expr>5</expr>,   <expr>6</expr>,  <expr>15</expr>,  <expr>15</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,  <comment type="block">/*   90 */</comment>
  <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>8</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,  <comment type="block">/*   90 */</comment>
 <expr>15</expr>, <expr>121</expr>, <expr>121</expr>, <expr>121</expr>, <expr>121</expr>, <expr>121</expr>, <expr>121</expr>, <expr>121</expr>,  <comment type="block">/*   90 */</comment>
<expr>121</expr>, <expr>121</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <comment type="block">/*   90 */</comment>
  <expr>8</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   90 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <comment type="block">/*   90 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   91 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   92 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   92 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   92 */</comment>
 <expr>46</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>46</expr>,  <comment type="block">/*   92 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   92 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   92 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   92 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   92 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   93 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,   <expr>3</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>59</expr>,  <expr>46</expr>,  <comment type="block">/*   93 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   94 */</comment>
 <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   94 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*   95 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*   95 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   95 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   95 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   95 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   95 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   95 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   95 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   96 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   96 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   96 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   96 */</comment>
 <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <expr>85</expr>,  <comment type="block">/*   96 */</comment>
 <expr>85</expr>,  <expr>85</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   96 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   96 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   96 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   97 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   97 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   97 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   97 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   97 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   97 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   97 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <comment type="block">/*   97 */</comment>
<expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>, <expr>114</expr>,  <comment type="block">/*   98 */</comment>
<expr>114</expr>, <expr>114</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   98 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   98 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   98 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   98 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   98 */</comment>
 <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   98 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   98 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*   99 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*  100 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  100 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <comment type="block">/*  101 */</comment>
 <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*  101 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  102 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  102 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  102 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  102 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  102 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  102 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  102 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  102 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  103 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  103 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  103 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  103 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  103 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  103 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  103 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  103 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>, <expr>122</expr>,  <comment type="block">/*  104 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,  <comment type="block">/*  105 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  106 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  106 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  106 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  106 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  106 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  106 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  106 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  106 */</comment>
 <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>46</expr>,  <comment type="block">/*  107 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  107 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <expr>16</expr>,  <comment type="block">/*  107 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>60</expr>,  <expr>40</expr>,  <comment type="block">/*  107 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  107 */</comment>
 <expr>40</expr>,   <expr>7</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  107 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*  107 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*  107 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  108 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  109 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  109 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  109 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  109 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  109 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  109 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  109 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  109 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  110 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  110 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  110 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  110 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  110 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  110 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  110 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  110 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  111 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,   <expr>5</expr>,   <expr>6</expr>,  <comment type="block">/*  111 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  112 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  112 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  113 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  114 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  114 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  114 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  114 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  114 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  114 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  114 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  114 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  115 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  115 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  115 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  115 */</comment>
 <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>60</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  115 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  115 */</comment>
  <expr>3</expr>,   <expr>8</expr>,   <expr>8</expr>,  <expr>12</expr>,  <expr>12</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,  <comment type="block">/*  115 */</comment>
  <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,  <comment type="block">/*  115 */</comment>
  <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  116 */</comment>
 <expr>46</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>12</expr>,  <expr>12</expr>,  <expr>12</expr>,  <comment type="block">/*  116 */</comment>
  <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>46</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*  116 */</comment>
  <expr>8</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>3</expr>,  <comment type="block">/*  116 */</comment>
  <expr>3</expr>,   <expr>3</expr>,   <expr>7</expr>,   <expr>8</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <expr>46</expr>,  <comment type="block">/*  116 */</comment>
  <expr>3</expr>,   <expr>4</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  116 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  116 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  116 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  117 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>, <expr>104</expr>,  <comment type="block">/*  117 */</comment>
 <expr>46</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>4</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*  118 */</comment>
  <expr>5</expr>,   <expr>6</expr>,   <expr>3</expr>,   <expr>7</expr>,   <expr>3</expr>,   <expr>8</expr>,   <expr>3</expr>,   <expr>3</expr>,  <comment type="block">/*  118 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,   <expr>9</expr>,  <comment type="block">/*  118 */</comment>
  <expr>9</expr>,   <expr>9</expr>,   <expr>3</expr>,   <expr>3</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>3</expr>,  <comment type="block">/*  118 */</comment>
  <expr>3</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <comment type="block">/*  118 */</comment>
 <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <comment type="block">/*  118 */</comment>
 <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,  <comment type="block">/*  118 */</comment>
 <expr>10</expr>,  <expr>10</expr>,  <expr>10</expr>,   <expr>5</expr>,   <expr>3</expr>,   <expr>6</expr>,  <expr>11</expr>,  <expr>12</expr>,  <comment type="block">/*  118 */</comment>
 <expr>11</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <comment type="block">/*  119 */</comment>
 <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <comment type="block">/*  119 */</comment>
 <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,  <comment type="block">/*  119 */</comment>
 <expr>13</expr>,  <expr>13</expr>,  <expr>13</expr>,   <expr>5</expr>,   <expr>7</expr>,   <expr>6</expr>,   <expr>7</expr>,  <expr>46</expr>,  <comment type="block">/*  119 */</comment>
 <expr>46</expr>,   <expr>3</expr>,   <expr>5</expr>,   <expr>6</expr>,   <expr>3</expr>,   <expr>3</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  119 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  119 */</comment>
 <expr>59</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  119 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  119 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>59</expr>,  <expr>59</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  120 */</comment>
 <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <comment type="block">/*  120 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  121 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  121 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <comment type="block">/*  121 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>40</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  121 */</comment>
  <expr>4</expr>,   <expr>4</expr>,   <expr>7</expr>,  <expr>11</expr>,  <expr>15</expr>,   <expr>4</expr>,   <expr>4</expr>,  <expr>46</expr>,  <comment type="block">/*  121 */</comment>
  <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,   <expr>7</expr>,  <expr>15</expr>,  <expr>15</expr>,  <expr>46</expr>,  <comment type="block">/*  121 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <comment type="block">/*  121 */</comment>
 <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>46</expr>,  <expr>15</expr>,  <expr>46</expr>,  <expr>46</expr>   <comment type="block">/*  121 */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The A table has 124 entries for a total of 496 bytes. */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name><name>js_A</name><index>[]</index></name> <init>= <expr><block>{
<expr>0x0001000F</expr>,  <comment type="block">/*    0   Cc, ignorable */</comment>
<expr>0x0004000F</expr>,  <comment type="block">/*    1   Cc, whitespace */</comment>
<expr>0x0004000C</expr>,  <comment type="block">/*    2   Zs, whitespace */</comment>
<expr>0x00000018</expr>,  <comment type="block">/*    3   Po */</comment>
<expr>0x0006001A</expr>,  <comment type="block">/*    4   Sc, currency */</comment>
<expr>0x00000015</expr>,  <comment type="block">/*    5   Ps */</comment>
<expr>0x00000016</expr>,  <comment type="block">/*    6   Pe */</comment>
<expr>0x00000019</expr>,  <comment type="block">/*    7   Sm */</comment>
<expr>0x00000014</expr>,  <comment type="block">/*    8   Pd */</comment>
<expr>0x00036089</expr>,  <comment type="block">/*    9   Nd, identifier part, decimal 16 */</comment>
<expr>0x0827FF81</expr>,  <comment type="block">/*   10   Lu, hasLower (add 32), identifier start, supradecimal 31 */</comment>
<expr>0x0000001B</expr>,  <comment type="block">/*   11   Sk */</comment>
<expr>0x00050017</expr>,  <comment type="block">/*   12   Pc, underscore */</comment>
<expr>0x0817FF82</expr>,  <comment type="block">/*   13   Ll, hasUpper (subtract 32), identifier start, supradecimal 31 */</comment>
<expr>0x0000000C</expr>,  <comment type="block">/*   14   Zs */</comment>
<expr>0x0000001C</expr>,  <comment type="block">/*   15   So */</comment>
<expr>0x00070182</expr>,  <comment type="block">/*   16   Ll, identifier start */</comment>
<expr>0x0000600B</expr>,  <comment type="block">/*   17   No, decimal 16 */</comment>
<expr>0x0000500B</expr>,  <comment type="block">/*   18   No, decimal 8 */</comment>
<expr>0x0000800B</expr>,  <comment type="block">/*   19   No, strange */</comment>
<expr>0x08270181</expr>,  <comment type="block">/*   20   Lu, hasLower (add 32), identifier start */</comment>
<expr>0x08170182</expr>,  <comment type="block">/*   21   Ll, hasUpper (subtract 32), identifier start */</comment>
<expr>0xE1D70182</expr>,  <comment type="block">/*   22   Ll, hasUpper (subtract -121), identifier start */</comment>
<expr>0x00670181</expr>,  <comment type="block">/*   23   Lu, hasLower (add 1), identifier start */</comment>
<expr>0x00570182</expr>,  <comment type="block">/*   24   Ll, hasUpper (subtract 1), identifier start */</comment>
<expr>0xCE670181</expr>,  <comment type="block">/*   25   Lu, hasLower (add -199), identifier start */</comment>
<expr>0x3A170182</expr>,  <comment type="block">/*   26   Ll, hasUpper (subtract 232), identifier start */</comment>
<expr>0xE1E70181</expr>,  <comment type="block">/*   27   Lu, hasLower (add -121), identifier start */</comment>
<expr>0x4B170182</expr>,  <comment type="block">/*   28   Ll, hasUpper (subtract 300), identifier start */</comment>
<expr>0x34A70181</expr>,  <comment type="block">/*   29   Lu, hasLower (add 210), identifier start */</comment>
<expr>0x33A70181</expr>,  <comment type="block">/*   30   Lu, hasLower (add 206), identifier start */</comment>
<expr>0x33670181</expr>,  <comment type="block">/*   31   Lu, hasLower (add 205), identifier start */</comment>
<expr>0x32A70181</expr>,  <comment type="block">/*   32   Lu, hasLower (add 202), identifier start */</comment>
<expr>0x32E70181</expr>,  <comment type="block">/*   33   Lu, hasLower (add 203), identifier start */</comment>
<expr>0x33E70181</expr>,  <comment type="block">/*   34   Lu, hasLower (add 207), identifier start */</comment>
<expr>0x34E70181</expr>,  <comment type="block">/*   35   Lu, hasLower (add 211), identifier start */</comment>
<expr>0x34670181</expr>,  <comment type="block">/*   36   Lu, hasLower (add 209), identifier start */</comment>
<expr>0x35670181</expr>,  <comment type="block">/*   37   Lu, hasLower (add 213), identifier start */</comment>
<expr>0x00070181</expr>,  <comment type="block">/*   38   Lu, identifier start */</comment>
<expr>0x36A70181</expr>,  <comment type="block">/*   39   Lu, hasLower (add 218), identifier start */</comment>
<expr>0x00070185</expr>,  <comment type="block">/*   40   Lo, identifier start */</comment>
<expr>0x36670181</expr>,  <comment type="block">/*   41   Lu, hasLower (add 217), identifier start */</comment>
<expr>0x36E70181</expr>,  <comment type="block">/*   42   Lu, hasLower (add 219), identifier start */</comment>
<expr>0x00AF0181</expr>,  <comment type="block">/*   43   Lu, hasLower (add 2), hasTitle, identifier start */</comment>
<expr>0x007F0183</expr>,  <comment type="block">/*   44   Lt, hasUpper (subtract 1), hasLower (add 1), hasTitle, identifier start */</comment>
<expr>0x009F0182</expr>,  <comment type="block">/*   45   Ll, hasUpper (subtract 2), hasTitle, identifier start */</comment>
<expr>0x00000000</expr>,  <comment type="block">/*   46   unassigned */</comment>
<expr>0x34970182</expr>,  <comment type="block">/*   47   Ll, hasUpper (subtract 210), identifier start */</comment>
<expr>0x33970182</expr>,  <comment type="block">/*   48   Ll, hasUpper (subtract 206), identifier start */</comment>
<expr>0x33570182</expr>,  <comment type="block">/*   49   Ll, hasUpper (subtract 205), identifier start */</comment>
<expr>0x32970182</expr>,  <comment type="block">/*   50   Ll, hasUpper (subtract 202), identifier start */</comment>
<expr>0x32D70182</expr>,  <comment type="block">/*   51   Ll, hasUpper (subtract 203), identifier start */</comment>
<expr>0x33D70182</expr>,  <comment type="block">/*   52   Ll, hasUpper (subtract 207), identifier start */</comment>
<expr>0x34570182</expr>,  <comment type="block">/*   53   Ll, hasUpper (subtract 209), identifier start */</comment>
<expr>0x34D70182</expr>,  <comment type="block">/*   54   Ll, hasUpper (subtract 211), identifier start */</comment>
<expr>0x35570182</expr>,  <comment type="block">/*   55   Ll, hasUpper (subtract 213), identifier start */</comment>
<expr>0x36970182</expr>,  <comment type="block">/*   56   Ll, hasUpper (subtract 218), identifier start */</comment>
<expr>0x36570182</expr>,  <comment type="block">/*   57   Ll, hasUpper (subtract 217), identifier start */</comment>
<expr>0x36D70182</expr>,  <comment type="block">/*   58   Ll, hasUpper (subtract 219), identifier start */</comment>
<expr>0x00070084</expr>,  <comment type="block">/*   59   Lm, identifier start */</comment>
<expr>0x00030086</expr>,  <comment type="block">/*   60   Mn, identifier part */</comment>
<expr>0x09A70181</expr>,  <comment type="block">/*   61   Lu, hasLower (add 38), identifier start */</comment>
<expr>0x09670181</expr>,  <comment type="block">/*   62   Lu, hasLower (add 37), identifier start */</comment>
<expr>0x10270181</expr>,  <comment type="block">/*   63   Lu, hasLower (add 64), identifier start */</comment>
<expr>0x0FE70181</expr>,  <comment type="block">/*   64   Lu, hasLower (add 63), identifier start */</comment>
<expr>0x09970182</expr>,  <comment type="block">/*   65   Ll, hasUpper (subtract 38), identifier start */</comment>
<expr>0x09570182</expr>,  <comment type="block">/*   66   Ll, hasUpper (subtract 37), identifier start */</comment>
<expr>0x10170182</expr>,  <comment type="block">/*   67   Ll, hasUpper (subtract 64), identifier start */</comment>
<expr>0x0FD70182</expr>,  <comment type="block">/*   68   Ll, hasUpper (subtract 63), identifier start */</comment>
<expr>0x0F970182</expr>,  <comment type="block">/*   69   Ll, hasUpper (subtract 62), identifier start */</comment>
<expr>0x0E570182</expr>,  <comment type="block">/*   70   Ll, hasUpper (subtract 57), identifier start */</comment>
<expr>0x0BD70182</expr>,  <comment type="block">/*   71   Ll, hasUpper (subtract 47), identifier start */</comment>
<expr>0x0D970182</expr>,  <comment type="block">/*   72   Ll, hasUpper (subtract 54), identifier start */</comment>
<expr>0x15970182</expr>,  <comment type="block">/*   73   Ll, hasUpper (subtract 86), identifier start */</comment>
<expr>0x14170182</expr>,  <comment type="block">/*   74   Ll, hasUpper (subtract 80), identifier start */</comment>
<expr>0x14270181</expr>,  <comment type="block">/*   75   Lu, hasLower (add 80), identifier start */</comment>
<expr>0x0C270181</expr>,  <comment type="block">/*   76   Lu, hasLower (add 48), identifier start */</comment>
<expr>0x0C170182</expr>,  <comment type="block">/*   77   Ll, hasUpper (subtract 48), identifier start */</comment>
<expr>0x00034089</expr>,  <comment type="block">/*   78   Nd, identifier part, decimal 0 */</comment>
<expr>0x00000087</expr>,  <comment type="block">/*   79   Me */</comment>
<expr>0x00030088</expr>,  <comment type="block">/*   80   Mc, identifier part */</comment>
<expr>0x00037489</expr>,  <comment type="block">/*   81   Nd, identifier part, decimal 26 */</comment>
<expr>0x00005A0B</expr>,  <comment type="block">/*   82   No, decimal 13 */</comment>
<expr>0x00006E0B</expr>,  <comment type="block">/*   83   No, decimal 23 */</comment>
<expr>0x0000740B</expr>,  <comment type="block">/*   84   No, decimal 26 */</comment>
<expr>0x0000000B</expr>,  <comment type="block">/*   85   No */</comment>
<expr>0xFE170182</expr>,  <comment type="block">/*   86   Ll, hasUpper (subtract -8), identifier start */</comment>
<expr>0xFE270181</expr>,  <comment type="block">/*   87   Lu, hasLower (add -8), identifier start */</comment>
<expr>0xED970182</expr>,  <comment type="block">/*   88   Ll, hasUpper (subtract -74), identifier start */</comment>
<expr>0xEA970182</expr>,  <comment type="block">/*   89   Ll, hasUpper (subtract -86), identifier start */</comment>
<expr>0xE7170182</expr>,  <comment type="block">/*   90   Ll, hasUpper (subtract -100), identifier start */</comment>
<expr>0xE0170182</expr>,  <comment type="block">/*   91   Ll, hasUpper (subtract -128), identifier start */</comment>
<expr>0xE4170182</expr>,  <comment type="block">/*   92   Ll, hasUpper (subtract -112), identifier start */</comment>
<expr>0xE0970182</expr>,  <comment type="block">/*   93   Ll, hasUpper (subtract -126), identifier start */</comment>
<expr>0xFDD70182</expr>,  <comment type="block">/*   94   Ll, hasUpper (subtract -9), identifier start */</comment>
<expr>0xEDA70181</expr>,  <comment type="block">/*   95   Lu, hasLower (add -74), identifier start */</comment>
<expr>0xFDE70181</expr>,  <comment type="block">/*   96   Lu, hasLower (add -9), identifier start */</comment>
<expr>0xEAA70181</expr>,  <comment type="block">/*   97   Lu, hasLower (add -86), identifier start */</comment>
<expr>0xE7270181</expr>,  <comment type="block">/*   98   Lu, hasLower (add -100), identifier start */</comment>
<expr>0xFE570182</expr>,  <comment type="block">/*   99   Ll, hasUpper (subtract -7), identifier start */</comment>
<expr>0xE4270181</expr>,  <comment type="block">/*  100   Lu, hasLower (add -112), identifier start */</comment>
<expr>0xFE670181</expr>,  <comment type="block">/*  101   Lu, hasLower (add -7), identifier start */</comment>
<expr>0xE0270181</expr>,  <comment type="block">/*  102   Lu, hasLower (add -128), identifier start */</comment>
<expr>0xE0A70181</expr>,  <comment type="block">/*  103   Lu, hasLower (add -126), identifier start */</comment>
<expr>0x00010010</expr>,  <comment type="block">/*  104   Cf, ignorable */</comment>
<expr>0x0004000D</expr>,  <comment type="block">/*  105   Zl, whitespace */</comment>
<expr>0x0004000E</expr>,  <comment type="block">/*  106   Zp, whitespace */</comment>
<expr>0x0000400B</expr>,  <comment type="block">/*  107   No, decimal 0 */</comment>
<expr>0x0000440B</expr>,  <comment type="block">/*  108   No, decimal 2 */</comment>
<expr>0x0427438A</expr>,  <comment type="block">/*  109   Nl, hasLower (add 16), identifier start, decimal 1 */</comment>
<expr>0x0427818A</expr>,  <comment type="block">/*  110   Nl, hasLower (add 16), identifier start, strange */</comment>
<expr>0x0417638A</expr>,  <comment type="block">/*  111   Nl, hasUpper (subtract 16), identifier start, decimal 17 */</comment>
<expr>0x0417818A</expr>,  <comment type="block">/*  112   Nl, hasUpper (subtract 16), identifier start, strange */</comment>
<expr>0x0007818A</expr>,  <comment type="block">/*  113   Nl, identifier start, strange */</comment>
<expr>0x0000420B</expr>,  <comment type="block">/*  114   No, decimal 1 */</comment>
<expr>0x0000720B</expr>,  <comment type="block">/*  115   No, decimal 25 */</comment>
<expr>0x06A0001C</expr>,  <comment type="block">/*  116   So, hasLower (add 26) */</comment>
<expr>0x0690001C</expr>,  <comment type="block">/*  117   So, hasUpper (subtract 26) */</comment>
<expr>0x00006C0B</expr>,  <comment type="block">/*  118   No, decimal 22 */</comment>
<expr>0x0000560B</expr>,  <comment type="block">/*  119   No, decimal 11 */</comment>
<expr>0x0007738A</expr>,  <comment type="block">/*  120   Nl, identifier start, decimal 25 */</comment>
<expr>0x0007418A</expr>,  <comment type="block">/*  121   Nl, identifier start, decimal 0 */</comment>
<expr>0x00000013</expr>,  <comment type="block">/*  122   Cs */</comment>
<expr>0x00000012</expr>   <comment type="block">/*  123   Co */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name><name>js_uriReservedPlusPound_ucstr</name><index>[]</index></name> <init>=
    <expr><block>{<expr>';'</expr>, <expr>'/'</expr>, <expr>'?'</expr>, <expr>':'</expr>, <expr>'@'</expr>, <expr>'&amp;'</expr>, <expr>'='</expr>, <expr>'+'</expr>, <expr>'$'</expr>, <expr>','</expr>, <expr>'#'</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name></type> <name><name>js_uriUnescaped_ucstr</name><index>[]</index></name> <init>=
    <expr><block>{<expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>, <expr>'8'</expr>, <expr>'9'</expr>,
     <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>, <expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>,
     <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>, <expr>'U'</expr>, <expr>'V'</expr>, <expr>'W'</expr>, <expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>,
     <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>, <expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>,
     <expr>'n'</expr>, <expr>'o'</expr>, <expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>, <expr>'x'</expr>, <expr>'y'</expr>, <expr>'z'</expr>,
     <expr>'-'</expr>, <expr>'_'</expr>, <expr>'.'</expr>, <expr>'!'</expr>, <expr>'~'</expr>, <expr>'*'</expr>, <expr>'\''</expr>, <expr>'('</expr>, <expr>')'</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This table allows efficient testing for the regular expression \w which is
 * defined by ECMA-262 15.10.2.6 to be [0-9A-Z_a-z].
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name><name>js_alnum</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/*       0      1      2      3      4      5      5      7      8      9      */</comment>
<comment type="block">/*  0 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  1 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  2 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  3 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  4 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/*  5 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  6 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/*  7 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/*  8 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/*  9 */</comment> <expr>true</expr>,  <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>true</expr>,  <expr>false</expr>, <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/* 10 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/* 11 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,
<comment type="block">/* 12 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>URI_CHUNK</name></cpp:macro> <cpp:value>64U</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>TransferBufferToString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCharBuffer</name> &amp;</type><name>cb</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>js_NewStringFromCharBuffer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>rval</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return><empty_stmt>;</empty_stmt>
}</block></function>

<comment type="block">/*
 * ECMA 3, 15.1.3 URI Handling Function Properties
 *
 * The following are implementations of the algorithms
 * given in the ECMA specification for the hidden functions
 * 'Encode' and 'Decode'.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>Encode</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>unescapedSet</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>unescapedSet2</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>HexDigits</name><index>[]</index></name> <init>= <expr>"0123456789ABCDEF"</expr></init></decl>;</decl_stmt> <comment type="block">/* NB: uppercase */</comment>

    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>length</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>rval</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <function_decl><type><name>JSCharBuffer</name></type> <name>cb</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>jschar</name></type> <name><name>hexBuf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>hexBuf</name><index>[<expr>0</expr>]</index></name> = '%'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hexBuf</name><index>[<expr>3</expr>]</index></name> = 0</expr>;</expr_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>k</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>c</name> <init>= <expr><name><name>chars</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>js_strchr</name><argument_list>(<argument><expr><name>unescapedSet</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> ||
            (<name>unescapedSet2</name> &amp;&amp; <call><name>js_strchr</name><argument_list>(<argument><expr><name>unescapedSet2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>(<name>c</name> &gt;= 0xDC00) &amp;&amp; (<name>c</name> &lt;= 0xDFFF)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSMSG_BAD_URI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <decl_stmt><decl><type><name>uint32</name></type> <name>v</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>c</name> <argument_list>&lt; <argument><expr>0xD800 || <name>c</name></expr></argument> &gt;</argument_list></name> 0xDBFF</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>v</name> = <name>c</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>k</name>++</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>k</name> == <name>length</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_BAD_URI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <decl_stmt><decl><type><name>jschar</name></type> <name>c2</name> <init>= <expr><name><name>chars</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>(<name>c2</name> &lt; 0xDC00) || (<name>c2</name> &gt; 0xDFFF)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_BAD_URI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>v</name> = ((<name>c</name> - 0xD800) &lt;&lt; 10) + (<name>c2</name> - 0xDC00) + 0x10000</expr>;</expr_stmt>
            }</block></else></if>
            <decl_stmt><decl><type><name>uint8</name></type> <name><name>utf8buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>L</name> <init>= <expr><call><name>js_OneUcs4ToUtf8Char</name><argument_list>(<argument><expr><name>utf8buf</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>L</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>hexBuf</name><index>[<expr>1</expr>]</index></name> = <name><name>HexDigits</name><index>[<expr><name><name>utf8buf</name><index>[<expr><name>j</name></expr>]</index></name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>hexBuf</name><index>[<expr>2</expr>]</index></name> = <name><name>HexDigits</name><index>[<expr><name><name>utf8buf</name><index>[<expr><name>j</name></expr>]</index></name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>hexBuf</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></for>
        }</block></else></if>
    }</block></for>

    <return>return <expr><call><name>TransferBufferToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>Decode</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>reservedSet</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>getChars</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>length</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>rval</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <function_decl><type><name>JSCharBuffer</name></type> <name>cb</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <for>for (<init><decl><type><name>size_t</name></type> <name>k</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>c</name> <init>= <expr><name><name>chars</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>c</name> == '%'</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>size_t</name></type> <name>start</name> <init>= <expr><name>k</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>(<name>k</name> + 2) &gt;= <name>length</name></expr>)</condition><then>
                <goto>goto <name>report_bad_uri</name>;</goto></then></if>
            <if>if <condition>(<expr>!<call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+1</expr>]</index></name></expr></argument>)</argument_list></call> || !<call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>report_bad_uri</name>;</goto></then></if>
            <decl_stmt><decl><type><name>jsuint</name></type> <name>B</name> <init>= <expr><call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+1</expr>]</index></name></expr></argument>)</argument_list></call> * 16 + <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>k</name> += 2</expr>;</expr_stmt>
            <if>if <condition>(<expr>!(<name>B</name> &amp; 0x80)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>c</name> = (<name>jschar</name>)<name>B</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <decl_stmt><decl><type><name>intN</name></type> <name>n</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>B</name> &amp; (0x80 &gt;&gt; <name>n</name>)</expr>)</condition>
                    <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></while>
                <if>if <condition>(<expr><name>n</name> == 1 || <name>n</name> &gt; 4</expr>)</condition><then>
                    <goto>goto <name>report_bad_uri</name>;</goto></then></if>
                <decl_stmt><decl><type><name>uint8</name></type> <name><name>octets</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>octets</name><index>[<expr>0</expr>]</index></name> = (<name>uint8</name>)<name>B</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>k</name> + 3 * (<name>n</name> - 1) &gt;= <name>length</name></expr>)</condition><then>
                    <goto>goto <name>report_bad_uri</name>;</goto></then></if>
                <for>for (<init><decl><type><name>intN</name></type> <name>j</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>k</name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>k</name></expr>]</index></name> != '%'</expr>)</condition><then>
                        <goto>goto <name>report_bad_uri</name>;</goto></then></if>
                    <if>if <condition>(<expr>!<call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+1</expr>]</index></name></expr></argument>)</argument_list></call> || !<call><name>JS7_ISHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>report_bad_uri</name>;</goto></then></if>
                    <expr_stmt><expr><name>B</name> = <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+1</expr>]</index></name></expr></argument>)</argument_list></call> * 16 + <call><name>JS7_UNHEX</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>k</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>(<name>B</name> &amp; 0xC0) != 0x80</expr>)</condition><then>
                        <goto>goto <name>report_bad_uri</name>;</goto></then></if>
                    <expr_stmt><expr><name>k</name> += 2</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>octets</name><index>[<expr><name>j</name></expr>]</index></name> = (<name>char</name>)<name>B</name></expr>;</expr_stmt>
                }</block></for>
                <decl_stmt><decl><type><name>uint32</name></type> <name>v</name> <init>= <expr><call><name>Utf8ToOneUcs4Char</name><argument_list>(<argument><expr><name>octets</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>v</name> &gt;= 0x10000</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>v</name> -= 0x10000</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>v</name> &gt; 0xFFFFF</expr>)</condition><then>
                        <goto>goto <name>report_bad_uri</name>;</goto></then></if>
                    <expr_stmt><expr><name>c</name> = <call>(<name>jschar</name>)<argument_list>(<argument><expr>(<name>v</name> &amp; 0x3FF) + 0xDC00</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>jschar</name></type> <name>H</name> <init>= <expr><call>(<name>jschar</name>)<argument_list>(<argument><expr>(<name>v</name> &gt;&gt; 10) + 0xD800</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>H</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>c</name> = (<name>jschar</name>)<name>v</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
            <if>if <condition>(<expr><call><name>js_strchr</name><argument_list>(<argument><expr><name>reservedSet</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>chars</name> + <name>start</name></expr></argument>, <argument><expr><name>k</name> - <name>start</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name><name>cb</name>.<name>append</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
    }</block></for>

    <return>return <expr><call><name>TransferBufferToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>

  <label><name>report_bad_uri</name>:</label>
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_BAD_URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* FALL THROUGH */</comment>

    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_decodeURI</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>Decode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>js_uriReservedPlusPound_ucstr</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_decodeURI_Component</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>Decode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>js_empty_ucstr</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_encodeURI</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>Encode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>js_uriReservedPlusPound_ucstr</name></expr></argument>, <argument><expr><name>js_uriUnescaped_ucstr</name></expr></argument>,
                  <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>str_encodeURI_Component</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSLinearString</name> *</type><name>str</name> <init>= <expr><call><name>ArgToRootedString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>Encode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>js_uriUnescaped_ucstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Convert one UCS-4 char and write it into a UTF-8 buffer, which must be at
 * least 4 bytes long.  Return the number of UTF-8 bytes of data written.
 */</comment>
<function><type><name>int</name></type>
<name>js_OneUcs4ToUtf8Char</name><parameter_list>(<param><decl><type><name>uint8</name> *</type><name>utf8Buffer</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>ucs4Char</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>utf8Length</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ucs4Char</name> &lt;= 0x10FFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ucs4Char</name> &lt; 0x80</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>utf8Buffer</name> = (<name>uint8</name>)<name>ucs4Char</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>a</name> <init>= <expr><name>ucs4Char</name> &gt;&gt; 11</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>utf8Length</name> = 2</expr>;</expr_stmt>
        <while>while <condition>(<expr><name>a</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>a</name> &gt;&gt;= 5</expr>;</expr_stmt>
            <expr_stmt><expr><name>utf8Length</name>++</expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>i</name> = <name>utf8Length</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>--<name>i</name></expr>)</condition> <block>{
            <expr_stmt><expr><name><name>utf8Buffer</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr>(<name>ucs4Char</name> &amp; 0x3F) | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ucs4Char</name> &gt;&gt;= 6</expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr>*<name>utf8Buffer</name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr>0x100 - (1 &lt;&lt; (8-<name>utf8Length</name>)) + <name>ucs4Char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>utf8Length</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Convert a utf8 character sequence into a UCS-4 character and return that
 * character.  It is assumed that the caller already checked that the sequence
 * is valid.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>Utf8ToOneUcs4Char</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>uint8</name> *</type><name>utf8Buffer</name></decl></param>, <param><decl><type><name>int</name></type> <name>utf8Length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>ucs4Char</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>minucs4Char</name></decl>;</decl_stmt>
    <comment type="block">/* from Unicode 3.1, non-shortest form is illegal */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name><name>minucs4Table</name><index>[]</index></name> <init>= <expr><block>{
        <expr>0x00000080</expr>, <expr>0x00000800</expr>, <expr>0x00010000</expr>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>utf8Length</name> &gt;= 1 &amp;&amp; <name>utf8Length</name> &lt;= 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8Length</name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ucs4Char</name> = *<name>utf8Buffer</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name>ucs4Char</name> &amp; 0x80)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>utf8Buffer</name> &amp; (0x100 - (1 &lt;&lt; (7-<name>utf8Length</name>)))) ==
                  (0x100 - (1 &lt;&lt; (8-<name>utf8Length</name>)))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ucs4Char</name> = *<name>utf8Buffer</name>++ &amp; ((1&lt;&lt;(7-<name>utf8Length</name>))-1)</expr>;</expr_stmt>
        <expr_stmt><expr><name>minucs4Char</name> = <name><name>minucs4Table</name><index>[<expr><name>utf8Length</name>-2</expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr>--<name>utf8Length</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>utf8Buffer</name> &amp; 0xC0) == 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ucs4Char</name> = <name>ucs4Char</name>&lt;&lt;6 | (*<name>utf8Buffer</name>++ &amp; 0x3F)</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><call><name>JS_UNLIKELY</name><argument_list>(<argument><expr><name>ucs4Char</name> &lt; <name>minucs4Char</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ucs4Char</name> = <name>OVERLONG_UTF8</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>ucs4Char</name> == 0xFFFE || <name>ucs4Char</name> == 0xFFFF</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ucs4Char</name> = 0xFFFD</expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></else></if>
    <return>return <expr><name>ucs4Char</name></expr>;</return>
}</block></function>

<namespace>namespace <name>js</name> <block>{

<function><type><name>size_t</name></type>
<name>PutEscapedStringImpl</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bufferSize</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>JSLinearString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>quote</name></decl></param>)</parameter_list>
<block>{
    <enum>enum <block>{
        <decl><name>STOP</name></decl>, <decl><name>FIRST_QUOTE</name></decl>, <decl><name>LAST_QUOTE</name></decl>, <decl><name>CHARS</name></decl>, <decl><name>ESCAPE_START</name></decl>, <decl><name>ESCAPE_MORE</name></decl>
    }</block> <decl><name>state</name></decl>;</enum>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>quote</name> == 0 || <name>quote</name> == '\'' || <name>quote</name> == '"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>buffer</name></expr></argument>, <argument><expr><name>bufferSize</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>!<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>bufferSize</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>buffer</name> = <name>NULL</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>bufferSize</name>--</expr>;</expr_stmt></else></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>charsEnd</name> <init>= <expr><name>chars</name> + <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>state</name> = <name>FIRST_QUOTE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>shift</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>hex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>u</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* to quell GCC warnings */</comment>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{
          <case>case <expr><name>STOP</name></expr>:
            <goto>goto <name>stop</name>;</goto>
          </case><case>case <expr><name>FIRST_QUOTE</name></expr>:
            <expr_stmt><expr><name>state</name> = <name>CHARS</name></expr>;</expr_stmt>
            <goto>goto <name>do_quote</name>;</goto>
          </case><case>case <expr><name>LAST_QUOTE</name></expr>:
            <expr_stmt><expr><name>state</name> = <name>STOP</name></expr>;</expr_stmt>
          <label><name>do_quote</name>:</label>
            <if>if <condition>(<expr><name>quote</name> == 0</expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><name>c</name> = (<name>char</name>)<name>quote</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>CHARS</name></expr>:
            <if>if <condition>(<expr><name>chars</name> == <name>charsEnd</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>state</name> = <name>LAST_QUOTE</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>u</name> = *<name>chars</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>u</name> &lt; ' '</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>u</name> != 0</expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>escape</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>js_EscapeMap</name></expr></argument>, <argument><expr>(<name>int</name>)<name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>escape</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>u</name> = <name><name>escape</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
                        <goto>goto <name>do_escape</name>;</goto>
                    }</block></then></if>
                }</block></then></if>
                <goto>goto <name>do_hex_escape</name>;</goto>
            }</block></then></if>
            <if>if <condition>(<expr><name>u</name> &lt; 127</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>u</name> == <name>quote</name> || <name>u</name> == '\\'</expr>)</condition><then>
                    <goto>goto <name>do_escape</name>;</goto></then></if>
                <expr_stmt><expr><name>c</name> = (<name>char</name>)<name>u</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>u</name> &lt; 0x100</expr>)</condition><then> <block>{
                <goto>goto <name>do_hex_escape</name>;</goto>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>shift</name> = 16</expr>;</expr_stmt>
                <expr_stmt><expr><name>hex</name> = <name>u</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>u</name> = 'u'</expr>;</expr_stmt>
                <goto>goto <name>do_escape</name>;</goto>
            }</block></else></if></else></if>
            <break>break;</break>
          <label><name>do_hex_escape</name>:</label>
            <expr_stmt><expr><name>shift</name> = 8</expr>;</expr_stmt>
            <expr_stmt><expr><name>hex</name> = <name>u</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>u</name> = 'x'</expr>;</expr_stmt>
          <label><name>do_escape</name>:</label>
            <expr_stmt><expr><name>c</name> = '\\'</expr>;</expr_stmt>
            <expr_stmt><expr><name>state</name> = <name>ESCAPE_START</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>ESCAPE_START</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>' ' &lt;= <name>u</name> &amp;&amp; <name>u</name> &lt; 127</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> = (<name>char</name>)<name>u</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>state</name> = <name>ESCAPE_MORE</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>ESCAPE_MORE</name></expr>:
            <if>if <condition>(<expr><name>shift</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>state</name> = <name>CHARS</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>shift</name> -= 4</expr>;</expr_stmt>
            <expr_stmt><expr><name>u</name> = 0xF &amp; (<name>hex</name> &gt;&gt; <name>shift</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> = <call>(<name>char</name>)<argument_list>(<argument><expr><name>u</name> + (<name>u</name> &lt; 10 ? '0' : 'A' - 10)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>
        <if>if <condition>(<expr><name>buffer</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>n</name> &lt;= <name>bufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>n</name> != <name>bufferSize</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>fp</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><call><name>size_t</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
    }</block></for>
  <label><name>stop</name>:</label>
    <if>if <condition>(<expr><name>buffer</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
    <return>return <expr><name>n</name></expr>;</return>
}</block></function>

}</block></namespace> <comment type="block">/* namespace js */</comment>
</unit>
