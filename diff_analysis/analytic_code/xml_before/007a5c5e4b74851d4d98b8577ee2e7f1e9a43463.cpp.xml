<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="007a5c5e4b74851d4d98b8577ee2e7f1e9a43463.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 *   Vladimir Vukicevic &lt;vladimir@pobox.com&gt;
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Rob Arnold &lt;tellrob@gmail.com&gt;
 *   Eric Butler &lt;zantifon@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"base/basictypes.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMXULElement.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_USE_MATH_DEFINES</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prmem.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMCanvasRenderingContext2D.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICanvasRenderingContextInternal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIVariant.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLCanvasElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICanvasElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIInterfaceRequestorUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDOMError.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScriptError.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSParser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICSSStyleRule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsComputedDOMStyle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleSet.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPrintfCString.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsColor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRenderingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGfxCIID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScriptSecurityManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMWindow.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPIDOMWindow.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShellTreeItem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShellTreeNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXPConnect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"imgIEncoder.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxASurface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxImageSurface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxPlatform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxFont.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxTextRunCache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxBlur.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameLoader.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBidiPresUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CanvasUtils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/dom/ContentProcessParent.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/ipc/PDocumentRendererParent.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/ipc/PDocumentRendererShmemParent.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/dom/PIFrameEmbeddingParent.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/ipc/DocumentRendererParent.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/ipc/DocumentRendererShmemParent.h"</cpp:file></cpp:include>
<comment type="line">// windows.h (included by chromium code) defines this, in its infinite wisdom</comment>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>DrawText</name></cpp:undef>

<using>using <name><name>mozilla</name>::<name>ipc</name>::<name>SharedMemory</name></name>;</using>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<using>using namespace <name>mozilla</name>;</using>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro>		<cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI_2</name></cpp:macro>		<cpp:value>1.57079632679489661923</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Float validation stuff */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>DoubleIsFinite</name><parameter_list>(<param><decl><type><name>double</name></type> <name>d</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="line">// NOTE: '!!' casts an int to bool without spamming MSVC warning C4800.</comment>
    <return>return <expr>!!<call><name>_finite</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>finite</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALIDATE</name><parameter_list>(<param><type><name>_f</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>if (!DoubleIsFinite(_f)) return PR_FALSE</cpp:value></cpp:define>

<comment type="block">/* These must take doubles as args, because JSDOUBLE_IS_FINITE expects
 * to take the address of its argument; we can't cast/convert in the
 * macro.
 */</comment>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>FloatValidate</name> <parameter_list>(<param><decl><type><name>double</name></type> <name>f1</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>FloatValidate</name> <parameter_list>(<param><decl><type><name>double</name></type> <name>f1</name></decl></param>, <param><decl><type><name>double</name></type> <name>f2</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>FloatValidate</name> <parameter_list>(<param><decl><type><name>double</name></type> <name>f1</name></decl></param>, <param><decl><type><name>double</name></type> <name>f2</name></decl></param>, <param><decl><type><name>double</name></type> <name>f3</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>FloatValidate</name> <parameter_list>(<param><decl><type><name>double</name></type> <name>f1</name></decl></param>, <param><decl><type><name>double</name></type> <name>f2</name></decl></param>, <param><decl><type><name>double</name></type> <name>f3</name></decl></param>, <param><decl><type><name>double</name></type> <name>f4</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>FloatValidate</name> <parameter_list>(<param><decl><type><name>double</name></type> <name>f1</name></decl></param>, <param><decl><type><name>double</name></type> <name>f2</name></decl></param>, <param><decl><type><name>double</name></type> <name>f3</name></decl></param>, <param><decl><type><name>double</name></type> <name>f4</name></decl></param>, <param><decl><type><name>double</name></type> <name>f5</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>FloatValidate</name> <parameter_list>(<param><decl><type><name>double</name></type> <name>f1</name></decl></param>, <param><decl><type><name>double</name></type> <name>f2</name></decl></param>, <param><decl><type><name>double</name></type> <name>f3</name></decl></param>, <param><decl><type><name>double</name></type> <name>f4</name></decl></param>, <param><decl><type><name>double</name></type> <name>f5</name></decl></param>, <param><decl><type><name>double</name></type> <name>f6</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>VALIDATE</name><argument_list>(<argument><expr><name>f6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VALIDATE</name></cpp:undef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyContext</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>dest</name></decl></param>, <param><decl><type><name>gfxContext</name>*</type> <name>src</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>Multiply</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPath</name></expr></argument>&gt;</argument_list></name></type> <name>path</name> <init>= <expr><call><name><name>src</name>-&gt;<name>CopyPath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>AppendPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pattern</name> <init>= <expr><call><name><name>src</name>-&gt;<name>GetPattern</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetPattern</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetLineWidth</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentLineWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetLineCap</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentLineCap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetLineJoin</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentLineJoin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetMiterLimit</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentMiterLimit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetFillRule</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentFillRule</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>dest</name>-&gt;<name>SetAntialiasMode</name></name><argument_list>(<argument><expr><call><name><name>src</name>-&gt;<name>CurrentAntialiasMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block" format="doxygen">/**
 ** nsCanvasGradient
 **/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_CANVASGRADIENT_PRIVATE_IID</name></cpp:macro> \
    <cpp:value>{ 0x491d39d8, 0x4058, 0x42bd, { 0xac, 0x76, 0x70, 0xd5, 0x62, 0x7f, 0x02, 0x10 } }</cpp:value></cpp:define>
<class>class <name>nsCanvasGradient</name> <super>: <specifier>public</specifier> <name>nsIDOMCanvasGradient</name></super>
<block>{<private type="default">
</private><public>public:
    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_CANVASGRADIENT_PRIVATE_IID</argument>)</argument_list></macro>

    <constructor><name>nsCanvasGradient</name><parameter_list>(<param><decl><type><name>gfxPattern</name>*</type> <name>pat</name></decl></param>)</parameter_list>
        <member_list>: <call><name>mPattern</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>

    <function><type><name>gfxPattern</name>*</type> <name>GetPattern</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mPattern</name></expr>;</return>
    }</block></function>

    <comment type="block">/* nsIDOMCanvasGradient */</comment>
    <function><type><name>NS_IMETHOD</name></type> <name>AddColorStop</name> <parameter_list>(<param><decl><type><name>float</name></type> <name>offset</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>colorstr</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>nscolor</name></type> <name>color</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name><name>offset</name> <argument_list>&lt; <argument><expr>0.0 || <name>offset</name></expr></argument> &gt;</argument_list></name> 1.0</expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_DOM_INDEX_SIZE_ERR</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>nsCSSParser</name></type> <name>parser</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>parser</name>.<name>ParseColorString</name></name><argument_list>(<argument><expr><call><name>nsString</name><argument_list>(<argument><expr><name>colorstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>color</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name><name>mPattern</name>-&gt;<name>AddColorStop</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>gfxRGBA</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <macro><name>NS_DECL_ISUPPORTS</name></macro>

</public><protected>protected:
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>mPattern</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsCanvasGradient</argument>, <argument>NS_CANVASGRADIENT_PRIVATE_IID</argument>)</argument_list></macro>

<macro><name>NS_IMPL_ADDREF</name><argument_list>(<argument>nsCanvasGradient</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE</name><argument_list>(<argument>nsCanvasGradient</argument>)</argument_list></macro>

<macro><name>DOMCI_DATA</name><argument_list>(<argument>CanvasGradient</argument>, <argument>nsCanvasGradient</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument>nsCanvasGradient</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsCanvasGradient</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIDOMCanvasGradient</argument>)</argument_list></macro>
  <macro><name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument>CanvasGradient</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsISupports</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_MAP_END</name></macro>

<comment type="block" format="doxygen">/**
 ** nsCanvasPattern
 **/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_CANVASPATTERN_PRIVATE_IID</name></cpp:macro> \
    <cpp:value>{ 0xb85c6c8a, 0x0624, 0x4530, { 0xb8, 0xee, 0xff, 0xdf, 0x42, 0xe8, 0x21, 0x6d } }</cpp:value></cpp:define>
<class>class <name>nsCanvasPattern</name> <super>: <specifier>public</specifier> <name>nsIDOMCanvasPattern</name></super>
<block>{<private type="default">
</private><public>public:
    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_CANVASPATTERN_PRIVATE_IID</argument>)</argument_list></macro>

    <constructor><name>nsCanvasPattern</name><parameter_list>(<param><decl><type><name>gfxPattern</name>*</type> <name>pat</name></decl></param>,
                    <param><decl><type><name>nsIPrincipal</name>*</type> <name>principalForSecurityCheck</name></decl></param>,
                    <param><decl><type><name>PRBool</name></type> <name>forceWriteOnly</name></decl></param>)</parameter_list>
        <member_list>: <call><name>mPattern</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call>,
          <call><name>mPrincipal</name><argument_list>(<argument><expr><name>principalForSecurityCheck</name></expr></argument>)</argument_list></call>,
          <call><name>mForceWriteOnly</name><argument_list>(<argument><expr><name>forceWriteOnly</name></expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>

    <function><type><name>gfxPattern</name>*</type> <name>GetPattern</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mPattern</name></expr>;</return>
    }</block></function>

    <function><type><name>nsIPrincipal</name>*</type> <name>Principal</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mPrincipal</name></expr>;</return> }</block></function>
    <function><type><name>PRBool</name></type> <name>GetForceWriteOnly</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mForceWriteOnly</name></expr>;</return> }</block></function>

    <macro><name>NS_DECL_ISUPPORTS</name></macro>

</public><protected>protected:
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>mPattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrincipal</name></expr></argument>&gt;</argument_list></name></type> <name>mPrincipal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mForceWriteOnly</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsCanvasPattern</argument>, <argument>NS_CANVASPATTERN_PRIVATE_IID</argument>)</argument_list></macro>

<macro><name>NS_IMPL_ADDREF</name><argument_list>(<argument>nsCanvasPattern</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE</name><argument_list>(<argument>nsCanvasPattern</argument>)</argument_list></macro>

<macro><name>DOMCI_DATA</name><argument_list>(<argument>CanvasPattern</argument>, <argument>nsCanvasPattern</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument>nsCanvasPattern</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsCanvasPattern</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIDOMCanvasPattern</argument>)</argument_list></macro>
  <macro><name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument>CanvasPattern</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsISupports</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_MAP_END</name></macro>

<comment type="block" format="doxygen">/**
 ** nsTextMetrics
 **/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_TEXTMETRICS_PRIVATE_IID</name></cpp:macro> \
    <cpp:value>{ 0xc5b1c2f9, 0xcb4f, 0x4394, { 0xaf, 0xe0, 0xc6, 0x59, 0x33, 0x80, 0x8b, 0xf3 } }</cpp:value></cpp:define>
<class>class <name>nsTextMetrics</name> <super>: <specifier>public</specifier> <name>nsIDOMTextMetrics</name></super>
<block>{<private type="default">
</private><public>public:
    <constructor><name>nsTextMetrics</name><parameter_list>(<param><decl><type><name>float</name></type> <name>w</name></decl></param>)</parameter_list> <member_list>: <call><name>width</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> </member_list><block>{ }</block></constructor>

    <destructor><specifier>virtual</specifier> <name>~<name>nsTextMetrics</name></name><parameter_list>()</parameter_list> <block>{ }</block></destructor>

    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_TEXTMETRICS_PRIVATE_IID</argument>)</argument_list></macro>

    <function><type><name>NS_IMETHOD</name></type> <name>GetWidth</name><parameter_list>(<param><decl><type><name>float</name>*</type> <name>w</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr>*<name>w</name> = <name>width</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <macro><name>NS_DECL_ISUPPORTS</name></macro>

</public><private>private:
    <decl_stmt><decl><type><name>float</name></type> <name>width</name></decl>;</decl_stmt>
</private>}</block>;</class>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsTextMetrics</argument>, <argument>NS_TEXTMETRICS_PRIVATE_IID</argument>)</argument_list></macro>

<macro><name>NS_IMPL_ADDREF</name><argument_list>(<argument>nsTextMetrics</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE</name><argument_list>(<argument>nsTextMetrics</argument>)</argument_list></macro>

<macro><name>DOMCI_DATA</name><argument_list>(<argument>TextMetrics</argument>, <argument>nsTextMetrics</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument>nsTextMetrics</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsTextMetrics</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIDOMTextMetrics</argument>)</argument_list></macro>
  <macro><name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument>TextMetrics</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsISupports</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_MAP_END</name></macro>

<struct_decl>struct <name>nsCanvasBidiProcessor</name>;</struct_decl>

<comment type="block" format="doxygen">/**
 ** nsCanvasRenderingContext2D
 **/</comment>
<class>class <name>nsCanvasRenderingContext2D</name> <super>:
    <specifier>public</specifier> <name>nsIDOMCanvasRenderingContext2D</name>,
    <specifier>public</specifier> <name>nsICanvasRenderingContextInternal</name></super>
<block>{<private type="default">
</private><public>public:
    <constructor_decl><name>nsCanvasRenderingContext2D</name><parameter_list>()</parameter_list>;</constructor_decl>
    <destructor_decl><specifier>virtual</specifier> <name>~<name>nsCanvasRenderingContext2D</name></name><parameter_list>()</parameter_list>;</destructor_decl>

    <function_decl><type><name>nsresult</name></type> <name>Redraw</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// nsICanvasRenderingContextInternal</comment>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>SetCanvasElement</name><parameter_list>(<param><decl><type><name>nsICanvasElement</name>*</type> <name>aParentCanvas</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>SetDimensions</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>width</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>height</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>InitializeWithSurface</name><parameter_list>(<param><decl><type><name>nsIDocShell</name> *</type><name>shell</name></decl></param>, <param><decl><type><name>gfxASurface</name> *</type><name>surface</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>width</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>height</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>Render</name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name><name>gfxPattern</name>::<name>GraphicsFilter</name></name></type> <name>aFilter</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>GetInputStream</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aMimeType</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aEncoderOptions</name></decl></param>,
                              <param><decl><type><name>nsIInputStream</name> **</type><name>aStream</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>GetThebesSurface</name><parameter_list>(<param><decl><type><name>gfxASurface</name> **</type><name>surface</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>SetIsOpaque</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>isOpaque</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>SetIsShmem</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>isShmem</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="line">// this rect is in CSS pixels</comment>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>Redraw</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name> &amp;</type><name>r</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="line">// Swap this back buffer with the front, and copy its contents to the new back.</comment>
    <comment type="line">// x, y, w, and h specify the area of |back| that is dirty.</comment>
    <function_decl><type><name>NS_IMETHOD</name></type> <name>Swap</name><parameter_list>(<param><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>Shmem</name></name>&amp;</type> <name>back</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>x</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>y</name></decl></param>, 
                    <param><decl><type><name>PRInt32</name></type> <name>w</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>h</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// nsISupports interface</comment>
    <macro><name>NS_DECL_ISUPPORTS</name></macro>

    <comment type="line">// nsIDOMCanvasRenderingContext2D interface</comment>
    <macro><name>NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D</name></macro>

    <enum>enum <name>Style</name> <block>{
        <decl><name>STYLE_STROKE</name> <init>= <expr>0</expr></init></decl>,
        <decl><name>STYLE_FILL</name></decl>,
        <decl><name>STYLE_SHADOW</name></decl>,
        <decl><name>STYLE_MAX</name></decl>
    }</block>;</enum>

</public><protected>protected:

    <comment type="block" format="doxygen">/**
     * The number of living nsCanvasRenderingContexts.  When this goes down to
     * 0, we free the premultiply and unpremultiply tables, if they exist.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PRUint32</name></type> <name>sNumLivingContexts</name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/**
     * Lookup table used to speed up GetImageData().
     */</comment>
    <expr_stmt><expr>static <call><name>PRUint8</name> <argument_list>(<argument><expr>*<name>sUnpremultiplyTable</name></expr></argument>)</argument_list></call><index>[<expr>256</expr>]</index></expr>;</expr_stmt>

    <comment type="block" format="doxygen">/**
     * Lookup table used to speed up PutImageData().
     */</comment>
    <expr_stmt><expr>static <call><name>PRUint8</name> <argument_list>(<argument><expr>*<name>sPremultiplyTable</name></expr></argument>)</argument_list></call><index>[<expr>256</expr>]</index></expr>;</expr_stmt>

    <comment type="line">// destroy thebes/image stuff, in preparation for possibly recreating</comment>
    <function_decl><type><name>void</name></type> <name>Destroy</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// Some helpers.  Doesn't modify acolor on failure.</comment>
    <function_decl><type><name>nsresult</name></type> <name>SetStyleFromStringOrInterface</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>aInterface</name></decl></param>, <param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>nsresult</name></type> <name>GetStyleAsStringOrInterface</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>nsISupports</name> **</type><name>aInterface</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aType</name></decl></param>, <param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>StyleColorToString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nscolor</name>&amp;</type> <name>aColor</name></decl></param>, <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>DirtyAllStyles</name><parameter_list>()</parameter_list>;</function_decl>
    <comment type="block" format="doxygen">/**
     * applies the given style as the current source. If the given style is
     * a solid color, aUseGlobalAlpha indicates whether to multiply the alpha
     * by global alpha, and is ignored otherwise.
     */</comment>
    <function_decl><type><name>void</name></type> <name>ApplyStyle</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aUseGlobalAlpha</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl></param>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Creates the unpremultiply lookup table, if it doesn't exist.
     */</comment>
    <function_decl><type><name>void</name></type> <name>EnsureUnpremultiplyTable</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Creates the premultiply lookup table, if it doesn't exist.
     */</comment>
    <function_decl><type><name>void</name></type> <name>EnsurePremultiplyTable</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="line">// Member vars</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>mWidth</name></decl>, <decl><type ref="prev"/><name>mHeight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mValid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mOpaque</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mShmem</name></decl>;</decl_stmt>

    <comment type="line">// We always have a front buffer. We hand the back buffer to the other</comment>
    <comment type="line">// process to render to, and then swap our two buffers when it finishes.</comment>
    <decl_stmt><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>Shmem</name></name></type> <name>mFrontBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>Shmem</name></name></type> <name>mBackBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>mBackSurface</name></decl>;</decl_stmt>

    <comment type="line">// Creates a new mFrontBuffer and mBackBuffer of the correct size.</comment>
    <comment type="line">// Returns false if this wasn't possible, for whatever reason.</comment>
    <function_decl><type><name>bool</name></type> <name>CreateShmemSegments</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>width</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>height</name></decl></param>,
                             <param><decl><type><name><name>gfxASurface</name>::<name>gfxImageFormat</name></name></type> <name>format</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// the canvas element informs us when it's going away,</comment>
    <comment type="line">// so these are not nsCOMPtrs</comment>
    <decl_stmt><decl><type><name>nsICanvasElement</name>*</type> <name>mCanvasElement</name></decl>;</decl_stmt>

    <comment type="line">// If mCanvasElement is not provided, then a docshell is</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>mDocShell</name></decl>;</decl_stmt>

    <comment type="line">// yay thebes</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>mThebes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>mSurface</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mSaveCount</name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/**
     * Flag to avoid duplicate calls to InvalidateFrame. Set to true whenever
     * Redraw is called, reset to false when Render is called.
     */</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mIsEntireFrameInvalid</name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/**
     * Number of times we've invalidated before calling redraw
     */</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mInvalidateCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRUint32</name></type> <name>kCanvasMaxInvalidateCount</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/**
     * Returns true iff a shadow should be drawn along with a
     * drawing operation.
     */</comment>
    <function><type><name>PRBool</name></type> <name>NeedToDrawShadow</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ContextState</name>&amp;</type> <name>state</name> <init>= <expr><call><name>CurrentState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// The spec says we should not draw shadows when the alpha value is 0,</comment>
        <comment type="line">// regardless of the operator being used.</comment>
        <return>return <expr><call><name><name>state</name>.<name>StyleIsColor</name></name><argument_list>(<argument><expr><name>STYLE_SHADOW</name></expr></argument>)</argument_list></call> &amp;&amp;
               <call><name>NS_GET_A</name><argument_list>(<argument><expr><name><name>state</name>.<name>colorStyles</name><index>[<expr><name>STYLE_SHADOW</name></expr>]</index></name></expr></argument>)</argument_list></call> &gt; 0 &amp;&amp;
               (<name><name>state</name>.<name>shadowOffset</name></name> != <call><name>gfxPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> || <name><name>state</name>.<name>shadowBlur</name></name> != 0)</expr>;</return>
    }</block></function>

    <comment type="block" format="doxygen">/**
     * If the current operator is "source" then clear the destination before we
     * draw into it, to simulate the effect of an unbounded source operator.
     */</comment>
    <function><type><name>void</name></type> <name>ClearSurfaceForUnboundedSource</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsOperator</name></name></type> <name>current</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentOperator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>current</name> != <name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_CLEAR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// It doesn't really matter what the source is here, since Paint</comment>
        <comment type="line">// isn't bounded by the source and the mask covers the entire clip</comment>
        <comment type="line">// region.</comment>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Paint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="doxygen">/**
     * Returns true iff the current source is such that global alpha would not
     * be handled correctly without the use of an intermediate surface.
     */</comment>
    <function><type><name>PRBool</name></type> <name>NeedIntermediateSurfaceToHandleGlobalAlpha</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name> != 1.0 &amp;&amp; !<call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>StyleIsColor</name><argument_list>(<argument><expr><name>aWhichStyle</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="doxygen">/**
     * Initializes the drawing of a shadow onto the canvas. The returned context
     * should have the shadow shape drawn onto it, and then ShadowFinalize
     * should be called. The return value is null if an error occurs.
     * @param extents The extents of the shadow object, in device space.
     * @param blur A newly contructed gfxAlphaBoxBlur, made with the default
     *  constructor and left uninitialized.
     * @remark The lifetime of the return value is tied to the lifetime of
     *  the gfxAlphaBoxBlur, so it does not need to be ref counted.
     */</comment>
    <function_decl><type><name>gfxContext</name>*</type> <name>ShadowInitialize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>extents</name></decl></param>, <param><decl><type><name>gfxAlphaBoxBlur</name>&amp;</type> <name>blur</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Completes a shadow drawing operation.
     * @param blur The gfxAlphaBoxBlur that was passed to ShadowInitialize.
     */</comment>
    <function_decl><type><name>void</name></type> <name>ShadowFinalize</name><parameter_list>(<param><decl><type><name>gfxAlphaBoxBlur</name>&amp;</type> <name>blur</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Draws the current path in the given style. Takes care of
     * any shadow drawing and will use intermediate surfaces as needed.
     *
     * If dirtyRect is given, it will contain the device-space dirty
     * rectangle of the draw operation.
     */</comment>
    <function_decl><type><name>nsresult</name></type> <name>DrawPath</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>style</name></decl></param>, <param><decl><type><name>gfxRect</name> *</type><name>dirtyRect</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Draws a rectangle in the given style; used by FillRect and StrokeRect.
     */</comment>
    <function_decl><type><name>nsresult</name></type> <name>DrawRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>rect</name></decl></param>, <param><decl><type><name>Style</name></type> <name>style</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block" format="doxygen">/**
     * Gets the pres shell from either the canvas element or the doc shell
     */</comment>
    <function><type><name>nsIPresShell</name> *</type><name>GetPresShell</name><parameter_list>()</parameter_list> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>content</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>ownerDoc</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetOwnerDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>ownerDoc</name> ? <call><name><name>ownerDoc</name>-&gt;<name>GetPrimaryShell</name></name><argument_list>()</argument_list></call> : <name>nsnull</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>mDocShell</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>shell</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mDocShell</name>-&gt;<name>GetPresShell</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>shell</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
      }</block></then></if>
      <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></function>

    <comment type="line">// text</comment>
    <enum>enum <name>TextAlign</name> <block>{
        <decl><name>TEXT_ALIGN_START</name></decl>,
        <decl><name>TEXT_ALIGN_END</name></decl>,
        <decl><name>TEXT_ALIGN_LEFT</name></decl>,
        <decl><name>TEXT_ALIGN_RIGHT</name></decl>,
        <decl><name>TEXT_ALIGN_CENTER</name></decl>
    }</block>;</enum>

    <enum>enum <name>TextBaseline</name> <block>{
        <decl><name>TEXT_BASELINE_TOP</name></decl>,
        <decl><name>TEXT_BASELINE_HANGING</name></decl>,
        <decl><name>TEXT_BASELINE_MIDDLE</name></decl>,
        <decl><name>TEXT_BASELINE_ALPHABETIC</name></decl>,
        <decl><name>TEXT_BASELINE_IDEOGRAPHIC</name></decl>,
        <decl><name>TEXT_BASELINE_BOTTOM</name></decl>
    }</block>;</enum>

    <function_decl><type><name>gfxFontGroup</name> *</type><name>GetCurrentFontStyle</name><parameter_list>()</parameter_list>;</function_decl>

    <enum>enum <name>TextDrawOperation</name> <block>{
        <decl><name>TEXT_DRAW_OPERATION_FILL</name></decl>,
        <decl><name>TEXT_DRAW_OPERATION_STROKE</name></decl>,
        <decl><name>TEXT_DRAW_OPERATION_MEASURE</name></decl>
    }</block>;</enum>

    <comment type="block">/*
     * Implementation of the fillText, strokeText, and measure functions with
     * the operation abstracted to a flag.
     */</comment>
    <function_decl><type><name>nsresult</name></type> <name>DrawOrMeasureText</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>text</name></decl></param>,
                               <param><decl><type><name>float</name></type> <name>x</name></decl></param>,
                               <param><decl><type><name>float</name></type> <name>y</name></decl></param>,
                               <param><decl><type><name>float</name></type> <name>maxWidth</name></decl></param>,
                               <param><decl><type><name>TextDrawOperation</name></type> <name>op</name></decl></param>,
                               <param><decl><type><name>float</name>*</type> <name>aWidth</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// style handling</comment>
    <comment type="block">/*
     * The previous set style. Is equal to STYLE_MAX when there is no valid
     * previous style.
     */</comment>
    <decl_stmt><decl><type><name>Style</name></type> <name>mLastStyle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type> <name><name>mDirtyStyle</name><index>[<expr><name>STYLE_MAX</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="line">// state stack handling</comment>
    <class>class <name>ContextState</name> <block>{<private type="default">
    </private><public>public:
        <constructor><name>ContextState</name><parameter_list>()</parameter_list> <member_list>: <call><name>shadowOffset</name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr>0.0</expr></argument>)</argument_list></call>,
                         <call><name>globalAlpha</name><argument_list>(<argument><expr>1.0</expr></argument>)</argument_list></call>,
                         <call><name>shadowBlur</name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call>,
                         <call><name>textAlign</name><argument_list>(<argument><expr><name>TEXT_ALIGN_START</name></expr></argument>)</argument_list></call>,
                         <call><name>textBaseline</name><argument_list>(<argument><expr><name>TEXT_BASELINE_ALPHABETIC</name></expr></argument>)</argument_list></call>,
                         <call><name>imageSmoothingEnabled</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>
        </member_list><block>{ }</block></constructor>

        <constructor><name>ContextState</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>ContextState</name>&amp;</type> <name>other</name></decl></param>)</parameter_list>
            <member_list>: <call><name>shadowOffset</name><argument_list>(<argument><expr><name><name>other</name>.<name>shadowOffset</name></name></expr></argument>)</argument_list></call>,
              <call><name>globalAlpha</name><argument_list>(<argument><expr><name><name>other</name>.<name>globalAlpha</name></name></expr></argument>)</argument_list></call>,
              <call><name>shadowBlur</name><argument_list>(<argument><expr><name><name>other</name>.<name>shadowBlur</name></name></expr></argument>)</argument_list></call>,
              <call><name>font</name><argument_list>(<argument><expr><name><name>other</name>.<name>font</name></name></expr></argument>)</argument_list></call>,
              <call><name>fontGroup</name><argument_list>(<argument><expr><name><name>other</name>.<name>fontGroup</name></name></expr></argument>)</argument_list></call>,
              <call><name>textAlign</name><argument_list>(<argument><expr><name><name>other</name>.<name>textAlign</name></name></expr></argument>)</argument_list></call>,
              <call><name>textBaseline</name><argument_list>(<argument><expr><name><name>other</name>.<name>textBaseline</name></name></expr></argument>)</argument_list></call>,
              <call><name>imageSmoothingEnabled</name><argument_list>(<argument><expr><name><name>other</name>.<name>imageSmoothingEnabled</name></name></expr></argument>)</argument_list></call>
        </member_list><block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>STYLE_MAX</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>colorStyles</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>other</name>.<name>colorStyles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gradientStyles</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>other</name>.<name>gradientStyles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>patternStyles</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>other</name>.<name>patternStyles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
        }</block></constructor>

        <function><type><specifier>inline</specifier> <name>void</name></type> <name>SetColorStyle</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>whichStyle</name></decl></param>, <param><decl><type><name>nscolor</name></type> <name>color</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>colorStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>color</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gradientStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>nsnull</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>patternStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>nsnull</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>inline</specifier> <name>void</name></type> <name>SetPatternStyle</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>whichStyle</name></decl></param>, <param><decl><type><name>nsCanvasPattern</name>*</type> <name>pat</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>gradientStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>nsnull</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>patternStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>pat</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>inline</specifier> <name>void</name></type> <name>SetGradientStyle</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>whichStyle</name></decl></param>, <param><decl><type><name>nsCanvasGradient</name>*</type> <name>grad</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><name><name>gradientStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>grad</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>patternStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> = <name>nsnull</name></expr>;</expr_stmt>
        }</block></function>

        <comment type="block" format="doxygen">/**
         * returns true iff the given style is a solid color.
         */</comment>
        <function><type><specifier>inline</specifier> <name>PRBool</name></type> <name>StyleIsColor</name><parameter_list>(<param><decl><type><name>Style</name></type> <name>whichStyle</name></decl></param>)</parameter_list> <specifier>const</specifier>
        <block>{
            <return>return <expr>!(<name><name>patternStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name> ||
                     <name><name>gradientStyles</name><index>[<expr><name>whichStyle</name></expr>]</index></name>)</expr>;</return>
        }</block></function>

        <decl_stmt><decl><type><name>gfxPoint</name></type> <name>shadowOffset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name>globalAlpha</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name>shadowBlur</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>nsString</name></type> <name>font</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxFontGroup</name></expr></argument>&gt;</argument_list></name></type> <name>fontGroup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TextAlign</name></type> <name>textAlign</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TextBaseline</name></type> <name>textBaseline</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>nscolor</name></type> <name><name>colorStyles</name><index>[<expr><name>STYLE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsCanvasGradient</name></expr></argument>&gt;</argument_list></name></type> <name><name>gradientStyles</name><index>[<expr><name>STYLE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsCanvasPattern</name></expr></argument>&gt;</argument_list></name></type> <name><name>patternStyles</name><index>[<expr><name>STYLE_MAX</name></expr>]</index></name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>imageSmoothingEnabled</name></decl>;</decl_stmt>
    </public>}</block>;</class>

    <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>ContextState</name></expr></argument>&gt;</argument_list></name></type> <name>mStyleStack</name></decl>;</decl_stmt>

    <function><type><specifier>inline</specifier> <name>ContextState</name>&amp;</type> <name>CurrentState</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name><name>mStyleStack</name><index>[<expr><name>mSaveCount</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <comment type="line">// other helpers</comment>
    <function><type><name>void</name></type> <name>GetAppUnitsValues</name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>perDevPixel</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type><name>perCSSPixel</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// If we don't have a canvas element, we just return something generic.</comment>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>devPixel</name> <init>= <expr>60</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>cssPixel</name> <init>= <expr>60</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>ps</name> <init>= <expr><call><name>GetPresShell</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsPresContext</name> *</type><name>pc</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<name>ps</name></expr>)</condition><then> <goto>goto <name>FINISH</name>;</goto></then></if>
        <expr_stmt><expr><name>pc</name> = <call><name><name>ps</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then> <goto>goto <name>FINISH</name>;</goto></then></if>
        <expr_stmt><expr><name>devPixel</name> = <call><name><name>pc</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cssPixel</name> = <call><name><name>pc</name>-&gt;<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <label><name>FINISH</name>:</label>
        <if>if <condition>(<expr><name>perDevPixel</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>perDevPixel</name> = <name>devPixel</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>perCSSPixel</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>perCSSPixel</name> = <name>cssPixel</name></expr>;</expr_stmt></then></if>
    }</block></function>

    <struct_decl><specifier>friend</specifier> struct <name>nsCanvasBidiProcessor</name>;</struct_decl>
</protected>}</block>;</class>

<macro><name>NS_IMPL_ADDREF</name><argument_list>(<argument>nsCanvasRenderingContext2D</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE</name><argument_list>(<argument>nsCanvasRenderingContext2D</argument>)</argument_list></macro>

<macro><name>DOMCI_DATA</name><argument_list>(<argument>CanvasRenderingContext2D</argument>, <argument>nsCanvasRenderingContext2D</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument>nsCanvasRenderingContext2D</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIDOMCanvasRenderingContext2D</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsICanvasRenderingContextInternal</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY_AMBIGUOUS</name><argument_list>(<argument>nsISupports</argument>, <argument>nsIDOMCanvasRenderingContext2D</argument>)</argument_list></macro>
  <macro><name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument>CanvasRenderingContext2D</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_INTERFACE_MAP_END</name>

<comment type="block" format="doxygen">/**
 ** CanvasRenderingContext2D impl
 **/</comment>


<comment type="line">// Initialize our static variables.</comment>
<name>PRUint32</name></type> <name><name>nsCanvasRenderingContext2D</name>::<name>sNumLivingContexts</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PRUint8</name> <argument_list>(<argument><expr>*<name><name>nsCanvasRenderingContext2D</name>::<name>sUnpremultiplyTable</name></name></expr></argument>)</argument_list></call><index>[<expr>256</expr>]</index> = <name>nsnull</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRUint8</name> <argument_list>(<argument><expr>*<name><name>nsCanvasRenderingContext2D</name>::<name>sPremultiplyTable</name></name></expr></argument>)</argument_list></call><index>[<expr>256</expr>]</index> = <name>nsnull</name></expr>;</expr_stmt>

<function><type><name>nsresult</name></type>
<name>NS_NewCanvasRenderingContext2D</name><parameter_list>(<param><decl><type><name>nsIDOMCanvasRenderingContext2D</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCanvasRenderingContext2D</name></expr></argument>&gt;</argument_list></name></type> <name>ctx</name> <init>= <expr>new <call><name>nsCanvasRenderingContext2D</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <call><name><name>ctx</name>.<name>forget</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<constructor><name><name>nsCanvasRenderingContext2D</name>::<name>nsCanvasRenderingContext2D</name></name><parameter_list>()</parameter_list>
    <member_list>:  <call><name>mValid</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>, <call><name>mOpaque</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>, <call><name>mCanvasElement</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    ,  <call><name>mSaveCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>, <call><name>mIsEntireFrameInvalid</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>, <call><name>mInvalidateCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    ,  <call><name>mLastStyle</name><argument_list>(<argument><expr><name>STYLE_MAX</name></expr></argument>)</argument_list></call>, <call><name>mStyleStack</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
    , <call><name>mShmem</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</member_list><block>{
    <expr_stmt><expr><name>sNumLivingContexts</name>++</expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsCanvasRenderingContext2D</name>::~<name>nsCanvasRenderingContext2D</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sNumLivingContexts</name>--</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sNumLivingContexts</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete<index>[]</index> <name>sUnpremultiplyTable</name></expr>;</expr_stmt>
        <expr_stmt><expr>delete<index>[]</index> <name>sPremultiplyTable</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sUnpremultiplyTable</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sPremultiplyTable</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Destroy</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>mSurface</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mThebes</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mValid</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIsEntireFrameInvalid</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetStyleFromStringOrInterface</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                                                          <param><decl><type><name>nsISupports</name> *</type><name>aInterface</name></decl></param>,
                                                          <param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscolor</name></type> <name>color</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name><name>aStr</name>.<name>IsVoid</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCSSParser</name></type> <name>parser</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>parser</name>.<name>ParseColorString</name></name><argument_list>(<argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Error reporting happens inside the CSS parser</comment>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>SetColorStyle</name><argument_list>(<argument><expr><name>aWhichStyle</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>mDirtyStyle</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>aInterface</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsCanvasGradient</name></expr></argument>&gt;</argument_list></name></type> <name>grad</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aInterface</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>grad</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>SetGradientStyle</name><argument_list>(<argument><expr><name>aWhichStyle</name></expr></argument>, <argument><expr><name>grad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mDirtyStyle</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsCanvasPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pattern</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aInterface</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pattern</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>SetPatternStyle</name><argument_list>(<argument><expr><name>aWhichStyle</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mDirtyStyle</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>nsContentUtils</name>::<name>ReportToConsole</name></name><argument_list>(
        <argument><expr><name><name>nsContentUtils</name>::<name>eDOM_PROPERTIES</name></name></expr></argument>,
        <argument><expr>"UnexpectedCanvasVariantStyle"</expr></argument>,
        <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>,
        <argument><expr><name>nsnull</name></expr></argument>,
        <argument><expr><call><name>EmptyString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
        <argument><expr><name><name>nsIScriptError</name>::<name>warningFlag</name></name></expr></argument>,
        <argument><expr>"Canvas"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetStyleAsStringOrInterface</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>,
                                                        <param><decl><type><name>nsISupports</name> **</type><name>aInterface</name></decl></param>,
                                                        <param><decl><type><name>PRInt32</name> *</type><name>aType</name></decl></param>,
                                                        <param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>patternStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aStr</name>.<name>SetIsVoid</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aInterface</name> = <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>patternStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>aType</name> = <name>CMG_STYLE_PATTERN</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>gradientStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aStr</name>.<name>SetIsVoid</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aInterface</name> = <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>gradientStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>aType</name> = <name>CMG_STYLE_GRADIENT</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>StyleColorToString</name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>colorStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr></argument>, <argument><expr><name>aStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>aInterface</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>aType</name> = <name>CMG_STYLE_STRING</name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>StyleColorToString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nscolor</name>&amp;</type> <name>aColor</name></decl></param>, <param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>NS_GET_A</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call> == 255</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CopyUTF8toUTF16</name><argument_list>(<argument><expr><call><name>nsPrintfCString</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr>"#%02x%02x%02x"</expr></argument>,
                                        <argument><expr><call><name>NS_GET_R</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>NS_GET_G</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>NS_GET_B</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>aStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// "%0.5f" in nsPrintfCString would use the locale-specific</comment>
        <comment type="line">// decimal separator. That's why we have to do this:</comment>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>alpha</name> <init>= <expr><call><name>NS_GET_A</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call> * 100000 / 255</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CopyUTF8toUTF16</name><argument_list>(<argument><expr><call><name>nsPrintfCString</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr>"rgba(%d, %d, %d, 0.%d)"</expr></argument>,
                                        <argument><expr><call><name>NS_GET_R</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>NS_GET_G</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>NS_GET_B</name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>alpha</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>aStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>DirtyAllStyles</name></name><parameter_list>()</parameter_list>
<block>{
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>STYLE_MAX</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>mDirtyStyle</name><index>[<expr><name>i</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>ApplyStyle</name></name><parameter_list>(<param><decl><type><name>Style</name></type> <name>aWhichStyle</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type> <name>aUseGlobalAlpha</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mLastStyle</name> == <name>aWhichStyle</name> &amp;&amp;
        !<name><name>mDirtyStyle</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name> &amp;&amp;
        <name>aUseGlobalAlpha</name></expr>)</condition><then>
    <block>{
        <comment type="line">// nothing to do, this is already the set style</comment>
        <return>return;</return>
    }</block></then></if>

    <comment type="line">// if not using global alpha, don't optimize with dirty bit</comment>
    <if>if <condition>(<expr><name>aUseGlobalAlpha</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>mDirtyStyle</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>mLastStyle</name> = <name>aWhichStyle</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCanvasPattern</name>*</type> <name>pattern</name> <init>= <expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>patternStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>pattern</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>mCanvasElement</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>CanvasUtils</name>::<name>DoDrawImageSecurityCheck</name></name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>,
                                                  <argument><expr><call><name><name>pattern</name>-&gt;<name>Principal</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                  <argument><expr><call><name><name>pattern</name>-&gt;<name>GetForceWriteOnly</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>gfxPattern</name>*</type> <name>gpat</name> <init>= <expr><call><name><name>pattern</name>-&gt;<name>GetPattern</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>imageSmoothingEnabled</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>gpat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name><name>gfxPattern</name>::<name>FILTER_GOOD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>gpat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name><name>gfxPattern</name>::<name>FILTER_NEAREST</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetPattern</name></name><argument_list>(<argument><expr><name>gpat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>gradientStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>gfxPattern</name>*</type> <name>gpat</name> <init>= <expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>gradientStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name>-&gt;<call><name>GetPattern</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetPattern</name></name><argument_list>(<argument><expr><name>gpat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>gfxRGBA</name></type> <name>color</name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>colorStyles</name><index>[<expr><name>aWhichStyle</name></expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aUseGlobalAlpha</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>color</name>.<name>a</name></name> *= <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Redraw</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mCanvasElement</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>mIsEntireFrameInvalid</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mIsEntireFrameInvalid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><call><name><name>mCanvasElement</name>-&gt;<name>InvalidateFrame</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Redraw</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>r</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mCanvasElement</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>mIsEntireFrameInvalid</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <if>if <condition>(<expr>++<name>mInvalidateCount</name> &gt; <name>kCanvasMaxInvalidateCount</name></expr>)</condition><then>
        <return>return <expr><call><name>Redraw</name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <return>return <expr><call><name><name>mCanvasElement</name>-&gt;<name>InvalidateFrameSubrect</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>CreateShmemSegments</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>width</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>height</name></decl></param>,
                                                <param><decl><type><name><name>gfxASurface</name>::<name>gfxImageFormat</name></name></type> <name>format</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name><name>mozilla</name>::<name>dom</name>::<name>ContentProcessParent</name>::<name>GetSingleton</name></name><argument_list>()</argument_list></call>-&gt;
        <call><name>AllocShmem</name><argument_list>(<argument><expr><name>width</name> * <name>height</name> * 4</expr></argument>, <argument><expr><name><name>SharedMemory</name>::<name>TYPE_BASIC</name></name></expr></argument>,
                   <argument><expr>&amp;<name>mFrontBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name><name>mozilla</name>::<name>dom</name>::<name>ContentProcessParent</name>::<name>GetSingleton</name></name><argument_list>()</argument_list></call>-&gt;
                <call><name>AllocShmem</name><argument_list>(<argument><expr><name>width</name> * <name>height</name> * 4</expr></argument>, <argument><expr><name><name>SharedMemory</name>::<name>TYPE_BASIC</name></name></expr></argument>,
                           <argument><expr>&amp;<name>mBackBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><name>mBackSurface</name> = new <macro><name>gfxImageSurface</name><argument_list>(<argument>mBackBuffer.get&lt;unsigned char&gt;()</argument>,
                                       <argument>gfxIntSize(width, height)</argument>,
                                       <argument>width * 4</argument>, <argument>format</argument>)</argument_list></macro></expr>;</expr_stmt>

    <return>return <expr>true</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetDimensions</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>width</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>height</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>surface</name></decl>;</decl_stmt>

    <comment type="line">// Check that the dimensions are sane</comment>
    <if>if <condition>(<expr><call><name><name>gfxASurface</name>::<name>CheckSurfaceSize</name></name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0xffff</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>gfxASurface</name>::<name>gfxImageFormat</name></name></type> <name>format</name> <init>= <expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mOpaque</name></expr>)</condition><then>
            <expr_stmt><expr><name>format</name> = <name><name>gfxASurface</name>::<name>ImageFormatRGB24</name></name></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
        <if>if <condition>(<expr><name>mShmem</name> &amp;&amp; <call><name>CreateShmemSegments</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <macro><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument>mFrontBuffer.get&lt;unsigned char&gt;()</argument>, <argument>"No front buffer!"</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><name>surface</name> = new <macro><name>gfxImageSurface</name><argument_list>(<argument>mFrontBuffer.get&lt;unsigned char&gt;()</argument>,
                                          <argument>gfxIntSize(width, height)</argument>,
                                          <argument>width * 4</argument>, <argument>format</argument>)</argument_list></macro></expr>;</expr_stmt>
        }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>surface</name> = <call><name><name>gfxPlatform</name>::<name>GetPlatform</name></name><argument_list>()</argument_list></call>-&gt;<call><name>CreateOffscreenSurface</name>
                <argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <if>if <condition>(<expr><name>surface</name> &amp;&amp; <call><name><name>surface</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
            <expr_stmt><expr><name>surface</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <return>return <expr><call><name>InitializeWithSurface</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>surface</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>InitializeWithSurface</name></name><parameter_list>(<param><decl><type><name>nsIDocShell</name> *</type><name>docShell</name></decl></param>, <param><decl><type><name>gfxASurface</name> *</type><name>surface</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>width</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>height</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>docShell</name> ^ !<name>mCanvasElement</name></expr></argument>, <argument><expr>"Cannot set both docshell and canvas element"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mDocShell</name> = <name>docShell</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mWidth</name> = <name>width</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mHeight</name> = <name>height</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mSurface</name> = <name>surface</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mThebes</name> = <name>surface</name> ? new <call><name>gfxContext</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call> : <name>nsnull</name></expr>;</expr_stmt>

    <comment type="block">/* Create dummy surfaces here */</comment>
    <if>if <condition>(<expr><name>mSurface</name> == <name>nsnull</name> || <call><name><name>mSurface</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call> != 0 ||
        <name>mThebes</name> == <name>nsnull</name> || <call><name><name>mThebes</name>-&gt;<name>HasError</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><name>mSurface</name> = new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mThebes</name> = new <call><name>gfxContext</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>mValid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// set up the initial canvas defaults</comment>
    <expr_stmt><expr><call><name><name>mStyleStack</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mSaveCount</name> = 0</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ContextState</name> *</type><name>state</name> <init>= <expr><call><name><name>mStyleStack</name>.<name>AppendElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>globalAlpha</name></name> = 1.0</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name>-&gt;<name>colorStyles</name><index>[<expr><name>STYLE_FILL</name></expr>]</index></name> = <call><name>NS_RGB</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>colorStyles</name><index>[<expr><name>STYLE_STROKE</name></expr>]</index></name> = <call><name>NS_RGB</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>colorStyles</name><index>[<expr><name>STYLE_SHADOW</name></expr>]</index></name> = <call><name>NS_RGBA</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_CLEAR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetLineWidth</name></name><argument_list>(<argument><expr>1.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_OVER</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMiterLimit</name></name><argument_list>(<argument><expr>10.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetLineCap</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>LINE_CAP_BUTT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetLineJoin</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>LINE_JOIN_MITER</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// always force a redraw, because if the surface dimensions were reset</comment>
    <comment type="line">// then the surface became cleared, and we need to redraw everything.</comment>
    <expr_stmt><expr><call><name>Redraw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetIsOpaque</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>isOpaque</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>isOpaque</name> == <name>mOpaque</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mOpaque</name> = <name>isOpaque</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mValid</name></expr>)</condition><then> <block>{
        <comment type="block">/* If we've already been created, let SetDimensions take care of
         * recreating our surface
         */</comment>
        <return>return <expr><call><name>SetDimensions</name><argument_list>(<argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetIsShmem</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>isShmem</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
    <if>if <condition>(<expr><name>isShmem</name> == <name>mShmem</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mShmem</name> = <name>isShmem</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mValid</name></expr>)</condition><then> <block>{
        <comment type="block">/* If we've already been created, let SetDimensions take care of
         * recreating our surface
         */</comment>
        <return>return <expr><call><name>SetDimensions</name><argument_list>(<argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Swap</name></name><parameter_list>(<param><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>Shmem</name></name>&amp;</type> <name>aBack</name></decl></param>, 
                                 <param><decl><type><name>PRInt32</name></type> <name>x</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>y</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>w</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>h</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
    <comment type="line">// Our front buffer is always the correct size. If this back buffer doesn't</comment>
    <comment type="line">// match the front buffer's size, it's out of date (we've resized since</comment>
    <comment type="line">// this message was sent) and we should just ignore it.</comment>
    <if>if <condition>(<expr><call><name><name>mFrontBuffer</name>.<name><name>Size</name><argument_list>&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></name><argument_list>()</argument_list></call> != <call><name><name>aBack</name>.<name><name>Size</name><argument_list>&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// Swap back and front.</comment>
    <comment type="line">// mBackBuffer should be null here, since we've previously sent it to the</comment>
    <comment type="line">// child process.</comment>
    <expr_stmt><expr><name>mBackBuffer</name> = <name>mFrontBuffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFrontBuffer</name> = <name>aBack</name></expr>;</expr_stmt>

    <comment type="line">// do want mozilla::Swap</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmp</name> <init>= <expr><name>mSurface</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mSurface</name> = <name>mBackSurface</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mBackSurface</name> = <name>tmp</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>ctx</name> <init>= <expr>new <call><name>gfxContext</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CopyContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mThebes</name> = <name>ctx</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Redraw</name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Copy the new contents to the old to keep them in sync. </comment>
    <macro><name>memcpy</name><argument_list>(<argument>mBackBuffer.get&lt;unsigned char&gt;()</argument>, <argument>mFrontBuffer.get&lt;unsigned char&gt;()</argument>,
           <argument>mWidth * mHeight * 4</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <comment type="line">// Notify listeners that we've finished drawing</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>ownerDoc</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>content</name></expr>)</condition><then>
        <expr_stmt><expr><name>ownerDoc</name> = <call><name><name>content</name>-&gt;<name>GetOwnerDoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>ownerDoc</name> &amp;&amp; <name>mCanvasElement</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>nsContentUtils</name>::<name>DispatchTrustedEvent</name></name><argument_list>(<argument><expr><name>ownerDoc</name></expr></argument>, <argument><expr><name>mCanvasElement</name></expr></argument>, 
                                             <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"MozAsyncCanvasRender"</expr></argument>)</argument_list></call></expr></argument>,
                                             <comment type="block">/* aCanBubble = */</comment> <argument><expr><name>PR_TRUE</name></expr></argument>, 
                                             <comment type="block">/* aCancelable = */</comment> <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Render</name></name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name><name>gfxPattern</name>::<name>GraphicsFilter</name></name></type> <name>aFilter</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>mValid</name> || !<name>mSurface</name> ||
        <call><name><name>mSurface</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call> ||
        <call><name><name>mThebes</name>-&gt;<name>HasError</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>mSurface</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name>aFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsOperator</name></name></type> <name>op</name> <init>= <expr><call><name><name>ctx</name>-&gt;<name>CurrentOperator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mOpaque</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// XXX I don't want to use PixelSnapped here, but layout doesn't guarantee</comment>
    <comment type="line">// pixel alignment for this stuff!</comment>
    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>PixelSnappedRectangleAndSetPattern</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mOpaque</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>mIsEntireFrameInvalid</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mInvalidateCount</name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetInputStream</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aMimeType</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name>aEncoderOptions</name></decl></param>,
                                           <param><decl><type><name>nsIInputStream</name> **</type><name>aStream</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mValid</name> || !<name>mSurface</name> ||
        <call><name><name>mSurface</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call> ||
        <call><name><name>mThebes</name>-&gt;<name>HasError</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>encoderPrefix</name><index>[]</index></name> <init>= <expr>"@mozilla.org/image/encoder;2?type="</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsAutoArrayPtr</name><argument_list>&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name></type> <name>conid</name><argument_list>(<argument><expr>new (<name><name>std</name>::<name>nothrow</name></name>) <name><name>char</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoderPrefix</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>aMimeType</name></expr></argument>)</argument_list></call> + 1</expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>conid</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>conid</name></expr></argument>, <argument><expr><name>encoderPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>conid</name></expr></argument>, <argument><expr><name>aMimeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>imgIEncoder</name></expr></argument>&gt;</argument_list></name></type> <name>encoder</name> <init>= <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>conid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>encoder</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsAutoArrayPtr</name><argument_list>&lt;<argument><expr><name>PRUint8</name></expr></argument>&gt;</argument_list></name></type> <name>imageBuffer</name><argument_list>(<argument><expr>new (<name><name>std</name>::<name>nothrow</name></name>) <name><name>PRUint8</name><index>[<expr><name>mWidth</name> * <name>mHeight</name> * 4</expr>]</index></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>imageBuffer</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>imgsurf</name> <init>= <expr>new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><call><name><name>imageBuffer</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                            <argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr></argument>,
                                                            <argument><expr><name>mWidth</name> * 4</expr></argument>,
                                                            <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>imgsurf</name> || <call><name><name>imgsurf</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>ctx</name> <init>= <expr>new <call><name>gfxContext</name><argument_list>(<argument><expr><name>imgsurf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ctx</name> || <call><name><name>ctx</name>-&gt;<name>HasError</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetSource</name></name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Paint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name><name>encoder</name>-&gt;<name>InitFromData</name></name><argument_list>(<argument><expr><call><name><name>imageBuffer</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name>mWidth</name> * <name>mHeight</name> * 4</expr></argument>, <argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>, <argument><expr><name>mWidth</name> * 4</expr></argument>,
                               <argument><expr><name><name>imgIEncoder</name>::<name>INPUT_FORMAT_HOSTARGB</name></name></expr></argument>,
                               <argument><expr><call><name>nsDependentString</name><argument_list>(<argument><expr><name>aEncoderOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>, <argument><expr><name>aStream</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// nsCanvasRenderingContext2D impl</comment>
<comment type="line">//</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetCanvasElement</name></name><parameter_list>(<param><decl><type><name>nsICanvasElement</name>*</type> <name>aCanvasElement</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// don't hold a ref to this!</comment>
    <expr_stmt><expr><name>mCanvasElement</name> = <name>aCanvasElement</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetCanvas</name></name><parameter_list>(<param><decl><type><name>nsIDOMHTMLCanvasElement</name> **</type><name>canvas</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mCanvasElement</name> == <name>nsnull</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>canvas</name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>, <argument><expr><name>canvas</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// state</comment>
<comment type="line">//</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Save</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ContextState</name></type> <name>state</name> <init>= <expr><call><name>CurrentState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mStyleStack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mSaveCount</name>++</expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Restore</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mSaveCount</name> == 0</expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mStyleStack</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>mSaveCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mLastStyle</name> = <name>STYLE_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mSaveCount</name>--</expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// transformations</comment>
<comment type="line">//</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Scale</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Scale</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Rotate</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>angle</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Rotate</name></name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Translate</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Transform</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>m11</name></decl></param>, <param><decl><type><name>float</name></type> <name>m12</name></decl></param>, <param><decl><type><name>float</name></type> <name>m21</name></decl></param>, <param><decl><type><name>float</name></type> <name>m22</name></decl></param>, <param><decl><type><name>float</name></type> <name>dx</name></decl></param>, <param><decl><type><name>float</name></type> <name>dy</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>m11</name></expr></argument>,<argument><expr><name>m12</name></expr></argument>,<argument><expr><name>m21</name></expr></argument>,<argument><expr><name>m22</name></expr></argument>,<argument><expr><name>dx</name></expr></argument>,<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <function_decl><type><name>gfxMatrix</name></type> <name>matrix</name><parameter_list>(<param><decl><type><name>m11</name></type></decl></param>, <param><decl><type><name>m12</name></type></decl></param>, <param><decl><type><name>m21</name></type></decl></param>, <param><decl><type><name>m22</name></type></decl></param>, <param><decl><type><name>dx</name></type></decl></param>, <param><decl><type><name>dy</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Multiply</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetTransform</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>m11</name></decl></param>, <param><decl><type><name>float</name></type> <name>m12</name></decl></param>, <param><decl><type><name>float</name></type> <name>m21</name></decl></param>, <param><decl><type><name>float</name></type> <name>m22</name></decl></param>, <param><decl><type><name>float</name></type> <name>dx</name></decl></param>, <param><decl><type><name>float</name></type> <name>dy</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>m11</name></expr></argument>,<argument><expr><name>m12</name></expr></argument>,<argument><expr><name>m21</name></expr></argument>,<argument><expr><name>m22</name></expr></argument>,<argument><expr><name>dx</name></expr></argument>,<argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <function_decl><type><name>gfxMatrix</name></type> <name>matrix</name><parameter_list>(<param><decl><type><name>m11</name></type></decl></param>, <param><decl><type><name>m12</name></type></decl></param>, <param><decl><type><name>m21</name></type></decl></param>, <param><decl><type><name>m22</name></type></decl></param>, <param><decl><type><name>dx</name></type></decl></param>, <param><decl><type><name>dy</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// colors</comment>
<comment type="line">//</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetGlobalAlpha</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>aGlobalAlpha</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>aGlobalAlpha</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <comment type="line">// ignore invalid values, as per spec</comment>
    <if>if <condition>(<expr><name><name>aGlobalAlpha</name> <argument_list>&lt; <argument><expr>0.0 || <name>aGlobalAlpha</name></expr></argument> &gt;</argument_list></name> 1.0</expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name> = <name>aGlobalAlpha</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetGlobalAlpha</name></name><parameter_list>(<param><decl><type><name>float</name> *</type><name>aGlobalAlpha</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aGlobalAlpha</name> = <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetStrokeStyle</name></name><parameter_list>(<param><decl><type><name>nsIVariant</name> *</type><name>aValue</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>aValue</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsString</name></type> <name>str</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type> <name>vtype</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>aValue</name>-&gt;<name>GetDataType</name></name><argument_list>(<argument><expr>&amp;<name>vtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>vtype</name> == <name><name>nsIDataType</name>::<name>VTYPE_INTERFACE</name></name> ||
        <name>vtype</name> == <name><name>nsIDataType</name>::<name>VTYPE_INTERFACE_IS</name></name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>nsIID</name> *</type><name>iid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>sup</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>aValue</name>-&gt;<name>GetAsInterface</name></name><argument_list>(<argument><expr>&amp;<name>iid</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>iid</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>NS_Free</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>str</name>.<name>SetIsVoid</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>SetStrokeStyle_multi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>aValue</name>-&gt;<name>GetAsAString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>SetStrokeStyle_multi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetStrokeStyle</name></name><parameter_list>(<param><decl><type><name>nsIVariant</name> **</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWritableVariant</name></expr></argument>&gt;</argument_list></name></type> <name>wv</name> <init>= <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>NS_VARIANT_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>sup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsString</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetStrokeStyle_multi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>t</name> == <name>CMG_STYLE_STRING</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>wv</name>-&gt;<name>SetAsAString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>t</name> == <name>CMG_STYLE_PATTERN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>wv</name>-&gt;<name>SetAsInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIDOMCanvasPattern</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>t</name> == <name>CMG_STYLE_GRADIENT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>wv</name>-&gt;<name>SetAsInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIDOMCanvasGradient</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Unknown type from GetStroke/FillStyle_multi!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name> = <call><name><name>wv</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetFillStyle</name></name><parameter_list>(<param><decl><type><name>nsIVariant</name> *</type><name>aValue</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>aValue</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsString</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint16</name></type> <name>vtype</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>aValue</name>-&gt;<name>GetDataType</name></name><argument_list>(<argument><expr>&amp;<name>vtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>vtype</name> == <name><name>nsIDataType</name>::<name>VTYPE_INTERFACE</name></name> ||
        <name>vtype</name> == <name><name>nsIDataType</name>::<name>VTYPE_INTERFACE_IS</name></name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>nsIID</name> *</type><name>iid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>sup</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>aValue</name>-&gt;<name>GetAsInterface</name></name><argument_list>(<argument><expr>&amp;<name>iid</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>str</name>.<name>SetIsVoid</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>SetFillStyle_multi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>aValue</name>-&gt;<name>GetAsAString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>SetFillStyle_multi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetFillStyle</name></name><parameter_list>(<param><decl><type><name>nsIVariant</name> **</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWritableVariant</name></expr></argument>&gt;</argument_list></name></type> <name>wv</name> <init>= <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>NS_VARIANT_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>sup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsString</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetFillStyle_multi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>t</name> == <name>CMG_STYLE_STRING</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>wv</name>-&gt;<name>SetAsAString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>t</name> == <name>CMG_STYLE_PATTERN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>wv</name>-&gt;<name>SetAsInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIDOMCanvasPattern</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>t</name> == <name>CMG_STYLE_GRADIENT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>wv</name>-&gt;<name>SetAsInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIDOMCanvasGradient</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>sup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Unknown type from GetStroke/FillStyle_multi!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name> = <call><name><name>wv</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetStrokeStyle_multi</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>aInterface</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>SetStyleFromStringOrInterface</name><argument_list>(<argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>aInterface</name></expr></argument>, <argument><expr><name>STYLE_STROKE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetStrokeStyle_multi</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>nsISupports</name> **</type><name>aInterface</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aType</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>GetStyleAsStringOrInterface</name><argument_list>(<argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>aInterface</name></expr></argument>, <argument><expr><name>aType</name></expr></argument>, <argument><expr><name>STYLE_STROKE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetFillStyle_multi</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>aInterface</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>SetStyleFromStringOrInterface</name><argument_list>(<argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>aInterface</name></expr></argument>, <argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetFillStyle_multi</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>nsISupports</name> **</type><name>aInterface</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aType</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>GetStyleAsStringOrInterface</name><argument_list>(<argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>aInterface</name></expr></argument>, <argument><expr><name>aType</name></expr></argument>, <argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// gradients and patterns</comment>
<comment type="line">//</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>CreateLinearGradient</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x0</name></decl></param>, <param><decl><type><name>float</name></type> <name>y0</name></decl></param>, <param><decl><type><name>float</name></type> <name>x1</name></decl></param>, <param><decl><type><name>float</name></type> <name>y1</name></decl></param>,
                                                 <param><decl><type><name>nsIDOMCanvasGradient</name> **</type><name>_retval</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x0</name></expr></argument>,<argument><expr><name>y0</name></expr></argument>,<argument><expr><name>x1</name></expr></argument>,<argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>gradpat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>gradpat</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCanvasGradient</name></expr></argument>&gt;</argument_list></name></type> <name>grad</name> <init>= <expr>new <call><name>nsCanvasGradient</name><argument_list>(<argument><expr><name>gradpat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>grad</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>_retval</name> = <call><name><name>grad</name>.<name>forget</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>CreateRadialGradient</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x0</name></decl></param>, <param><decl><type><name>float</name></type> <name>y0</name></decl></param>, <param><decl><type><name>float</name></type> <name>r0</name></decl></param>, <param><decl><type><name>float</name></type> <name>x1</name></decl></param>, <param><decl><type><name>float</name></type> <name>y1</name></decl></param>, <param><decl><type><name>float</name></type> <name>r1</name></decl></param>,
                                                 <param><decl><type><name>nsIDOMCanvasGradient</name> **</type><name>_retval</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x0</name></expr></argument>,<argument><expr><name>y0</name></expr></argument>,<argument><expr><name>r0</name></expr></argument>,<argument><expr><name>x1</name></expr></argument>,<argument><expr><name>y1</name></expr></argument>,<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>gradpat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>r0</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>gradpat</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMCanvasGradient</name></expr></argument>&gt;</argument_list></name></type> <name>grad</name> <init>= <expr>new <call><name>nsCanvasGradient</name><argument_list>(<argument><expr><name>gradpat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>grad</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>_retval</name> = <call><name><name>grad</name>.<name>forget</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>CreatePattern</name></name><parameter_list>(<param><decl><type><name>nsIDOMHTMLElement</name> *</type><name>image</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>repeat</name></decl></param>,
                                          <param><decl><type><name>nsIDOMCanvasPattern</name> **</type><name>_retval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxPattern</name>::<name>GraphicsExtend</name></name></type> <name>extend</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>repeat</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> || <call><name><name>repeat</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"repeat"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>extend</name> = <name><name>gfxPattern</name>::<name>EXTEND_REPEAT</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>repeat</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"repeat-x"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// XX</comment>
        <expr_stmt><expr><name>extend</name> = <name><name>gfxPattern</name>::<name>EXTEND_REPEAT</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>repeat</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"repeat-y"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// XX</comment>
        <expr_stmt><expr><name>extend</name> = <name><name>gfxPattern</name>::<name>EXTEND_REPEAT</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>repeat</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"no-repeat"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>extend</name> = <name><name>gfxPattern</name>::<name>EXTEND_NONE</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return>
    }</block></else></if></else></if></else></if></else></if>

    <comment type="line">// The canvas spec says that createPattern should use the first frame</comment>
    <comment type="line">// of animated images</comment>
    <decl_stmt><decl><type><name><name>nsLayoutUtils</name>::<name>SurfaceFromElementResult</name></name></type> <name>res</name> <init>=
        <expr><call><name><name>nsLayoutUtils</name>::<name>SurfaceFromElement</name></name><argument_list>(<argument><expr><name>image</name></expr></argument>, <argument><expr><name><name>nsLayoutUtils</name>::<name>SFE_WANT_FIRST_FRAME</name></name> |
                                                 <name><name>nsLayoutUtils</name>::<name>SFE_WANT_NEW_SURFACE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name><name>res</name>.<name>mSurface</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>thebespat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name><name>res</name>.<name>mSurface</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>thebespat</name>-&gt;<name>SetExtend</name></name><argument_list>(<argument><expr><name>extend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCanvasPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr>new <call><name>nsCanvasPattern</name><argument_list>(<argument><expr><name>thebespat</name></expr></argument>, <argument><expr><name><name>res</name>.<name>mPrincipal</name></name></expr></argument>,
                                                        <argument><expr><name><name>res</name>.<name>mIsWriteOnly</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>pat</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>_retval</name> = <call><name><name>pat</name>.<name>forget</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// shadows</comment>
<comment type="line">//</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetShadowOffsetX</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>shadowOffset</name>.<name>x</name></name> = <name>x</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetShadowOffsetX</name></name><parameter_list>(<param><decl><type><name>float</name> *</type><name>x</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>x</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>shadowOffset</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetShadowOffsetY</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>shadowOffset</name>.<name>y</name></name> = <name>y</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetShadowOffsetY</name></name><parameter_list>(<param><decl><type><name>float</name> *</type><name>y</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>y</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>shadowOffset</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetShadowBlur</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>blur</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>blur</name> &lt; 0.0</expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowBlur</name> = <name>blur</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetShadowBlur</name></name><parameter_list>(<param><decl><type><name>float</name> *</type><name>blur</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>blur</name> = <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowBlur</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetShadowColor</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>colorstr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsCSSParser</name></type> <name>parser</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscolor</name></type> <name>color</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>parser</name>.<name>ParseColorString</name></name><argument_list>(<argument><expr><name>colorstr</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>color</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Error reporting happens inside the CSS parser</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>SetColorStyle</name><argument_list>(<argument><expr><name>STYLE_SHADOW</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>mDirtyStyle</name><index>[<expr><name>STYLE_SHADOW</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetShadowColor</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>color</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>StyleColorToString</name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name><name>colorStyles</name><index>[<expr><name>STYLE_SHADOW</name></expr>]</index></name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>gfxFloat</name></type> <name>SIGMA_MAX</name> <init>= <expr>25</expr></init></decl>;</decl_stmt>

<function><type><name>gfxContext</name>*</type>
<name><name>nsCanvasRenderingContext2D</name>::<name>ShadowInitialize</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>extents</name></decl></param>, <param><decl><type><name>gfxAlphaBoxBlur</name>&amp;</type> <name>blur</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gfxIntSize</name></type> <name>blurRadius</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>sigma</name> <init>= <expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowBlur</name> &gt; 8 ? <call><name>sqrt</name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowBlur</name></expr></argument>)</argument_list></call> : <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowBlur</name> / 2</expr></init></decl>;</decl_stmt>
    <comment type="line">// limit to avoid overly huge temp images</comment>
    <if>if <condition>(<expr><name>sigma</name> &gt; <name>SIGMA_MAX</name></expr>)</condition><then>
        <expr_stmt><expr><name>sigma</name> = <name>SIGMA_MAX</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>blurRadius</name> = <call><name><name>gfxAlphaBoxBlur</name>::<name>CalculateBlurRadius</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>sigma</name></expr></argument>, <argument><expr><name>sigma</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// calculate extents</comment>
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>drawExtents</name> <init>= <expr><name>extents</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// intersect with clip to avoid making overly huge temp images</comment>
    <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>clipExtents</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>GetClipExtents</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// outset by the blur radius so that blurs can leak onto the canvas even</comment>
    <comment type="line">// when the shape is outside the clipping area</comment>
    <expr_stmt><expr><call><name><name>clipExtents</name>.<name>Outset</name></name><argument_list>(<argument><expr><name><name>blurRadius</name>.<name>height</name></name></expr></argument>, <argument><expr><name><name>blurRadius</name>.<name>width</name></name></expr></argument>,
                       <argument><expr><name><name>blurRadius</name>.<name>height</name></name></expr></argument>, <argument><expr><name><name>blurRadius</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>drawExtents</name> = <call><name><name>drawExtents</name>.<name>Intersect</name></name><argument_list>(<argument><expr><name>clipExtents</name> - <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>ctx</name> <init>= <expr><call><name><name>blur</name>.<name>Init</name></name><argument_list>(<argument><expr><name>drawExtents</name></expr></argument>, <argument><expr><name>blurRadius</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then>
        <return>return <expr><name>nsnull</name></expr>;</return></then></if>

    <return>return <expr><name>ctx</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>ShadowFinalize</name></name><parameter_list>(<param><decl><type><name>gfxAlphaBoxBlur</name>&amp;</type> <name>blur</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>STYLE_SHADOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// canvas matrix was already applied, don't apply it twice, but do</comment>
    <comment type="line">// apply the shadow offset</comment>
    <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>shadowOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>blur</name>.<name>Paint</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>DrawPath</name></name><parameter_list>(<param><decl><type><name>Style</name></type> <name>style</name></decl></param>, <param><decl><type><name>gfxRect</name> *</type><name>dirtyRect</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Need an intermediate surface when:
     * - globalAlpha != 1 and gradients/patterns are used (need to paint_with_alpha)
     * - certain operators are used
     */</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>doUseIntermediateSurface</name> <init>= <expr><call><name>NeedIntermediateSurfaceToHandleGlobalAlpha</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>doDrawShadow</name> <init>= <expr><call><name>NeedToDrawShadow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Clear the surface if we need to simulate unbounded SOURCE operator</comment>
    <expr_stmt><expr><call><name>ClearSurfaceForUnboundedSource</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>doDrawShadow</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// calculate extents of path</comment>
        <decl_stmt><decl><type><name>gfxRect</name></type> <name>drawExtents</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>style</name> == <name>STYLE_FILL</name></expr>)</condition><then>
            <expr_stmt><expr><name>drawExtents</name> = <call><name><name>mThebes</name>-&gt;<name>GetUserFillExtent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else <comment type="line">// STYLE_STROKE</comment>
            <expr_stmt><expr><name>drawExtents</name> = <call><name><name>mThebes</name>-&gt;<name>GetUserStrokeExtent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>gfxAlphaBoxBlur</name></type> <name>blur</name></decl>;</decl_stmt>

        <comment type="line">// no need for a ref here, the blur owns the context</comment>
        <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>ctx</name> <init>= <expr><call><name>ShadowInitialize</name><argument_list>(<argument><expr><name>drawExtents</name></expr></argument>, <argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>ctx</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>style</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopyContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>style</name> == <name>STYLE_FILL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Stroke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

            <expr_stmt><expr><call><name>ShadowFinalize</name><argument_list>(<argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>doUseIntermediateSurface</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPath</name></expr></argument>&gt;</argument_list></name></type> <name>path</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CopyPath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// if the path didn't copy correctly then we can't restore it, so bail</comment>
        <if>if <condition>(<expr>!<name>path</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <comment type="line">// draw onto a pushed group</comment>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>PushGroup</name></name><argument_list>(<argument><expr><name><name>gfxASurface</name>::<name>CONTENT_COLOR_ALPHA</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// XXX for some reason clipping messes up the path when push/popping</comment>
        <comment type="line">// copying the path seems to fix it, for unknown reasons</comment>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>AppendPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// don't want operators to be applied twice</comment>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>style</name> == <name>STYLE_FILL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Stroke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

    <comment type="line">// XXX do some more work to calculate the extents of shadows</comment>
    <comment type="line">// XXX handle stroke extents</comment>
    <if>if <condition>(<expr><name>dirtyRect</name> &amp;&amp; <name>style</name> == <name>STYLE_FILL</name> &amp;&amp; !<name>doDrawShadow</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>dirtyRect</name> = <call><name><name>mThebes</name>-&gt;<name>GetUserPathExtent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>doUseIntermediateSurface</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>PopGroupToSource</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>StyleIsColor</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call> ? 1.0 : <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>dirtyRect</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>style</name> != <name>STYLE_FILL</name> || <name>doDrawShadow</name></expr>)</condition><then> <block>{
            <comment type="line">// just use the clip extents</comment>
            <expr_stmt><expr>*<name>dirtyRect</name> = <call><name><name>mThebes</name>-&gt;<name>GetClipExtents</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr>*<name>dirtyRect</name> = <call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr>*<name>dirtyRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// rects</comment>
<comment type="line">//</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>ClearRect</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>w</name></decl></param>, <param><decl><type><name>float</name></type> <name>h</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <function_decl><type><name>gfxContextPathAutoSaveRestore</name></type> <name>pathSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>gfxContextAutoSaveRestore</name></type> <name>autoSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_CLEAR</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>gfxRect</name></type> <name>dirty</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><call><name><name>mThebes</name>-&gt;<name>GetUserPathExtent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>Redraw</name><argument_list>(<argument><expr><name>dirty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>DrawRect</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>rect</name></decl></param>, <param><decl><type><name>Style</name></type> <name>style</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name><name>rect</name>.<name>pos</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>rect</name>.<name>pos</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>rect</name>.<name>size</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>rect</name>.<name>size</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <function_decl><type><name>gfxContextPathAutoSaveRestore</name></type> <name>pathSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><name>rect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>gfxRect</name></type> <name>dirty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>DrawPath</name><argument_list>(<argument><expr><name>style</name></expr></argument>, <argument><expr>&amp;<name>dirty</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name>Redraw</name><argument_list>(<argument><expr><name>dirty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>FillRect</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>w</name></decl></param>, <param><decl><type><name>float</name></type> <name>h</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>DrawRect</name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>StrokeRect</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>w</name></decl></param>, <param><decl><type><name>float</name></type> <name>h</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>DrawRect</name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STYLE_STROKE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// path bits</comment>
<comment type="line">//</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>BeginPath</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>ClosePath</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>ClosePath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Fill</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>dirty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>DrawPath</name><argument_list>(<argument><expr><name>STYLE_FILL</name></expr></argument>, <argument><expr>&amp;<name>dirty</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    <return>return <expr><call><name>Redraw</name><argument_list>(<argument><expr><name>dirty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Stroke</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>dirty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>DrawPath</name><argument_list>(<argument><expr><name>STYLE_STROKE</name></expr></argument>, <argument><expr>&amp;<name>dirty</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    <return>return <expr><call><name>Redraw</name><argument_list>(<argument><expr><name>dirty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Clip</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Clip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>MoveTo</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>MoveTo</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>LineTo</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>LineTo</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>QuadraticCurveTo</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>cpx</name></decl></param>, <param><decl><type><name>float</name></type> <name>cpy</name></decl></param>, <param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>cpx</name></expr></argument>,<argument><expr><name>cpy</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <comment type="line">// we will always have a current point, since beginPath forces</comment>
    <comment type="line">// a moveto(0,0)</comment>
    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>c</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentPoint</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>gfxPoint</name></type> <name>p</name><parameter_list>(<param><decl><type><name>x</name></type></decl></param>,<param><decl><type><name>y</name></type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>gfxPoint</name></type> <name>cp</name><parameter_list>(<param><decl><type><name>cpx</name></type></decl></param>, <param><decl><type><name>cpy</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>CurveTo</name></name><argument_list>(<argument><expr>(<name>c</name>+<name>cp</name>*2)/3.0</expr></argument>, <argument><expr>(<name>p</name>+<name>cp</name>*2)/3.0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>BezierCurveTo</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>cp1x</name></decl></param>, <param><decl><type><name>float</name></type> <name>cp1y</name></decl></param>,
                                          <param><decl><type><name>float</name></type> <name>cp2x</name></decl></param>, <param><decl><type><name>float</name></type> <name>cp2y</name></decl></param>,
                                          <param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>cp1x</name></expr></argument>,<argument><expr><name>cp1y</name></expr></argument>,<argument><expr><name>cp2x</name></expr></argument>,<argument><expr><name>cp2y</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>CurveTo</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>cp1x</name></expr></argument>, <argument><expr><name>cp1y</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>cp2x</name></expr></argument>, <argument><expr><name>cp2y</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>ArcTo</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x1</name></decl></param>, <param><decl><type><name>float</name></type> <name>y1</name></decl></param>, <param><decl><type><name>float</name></type> <name>x2</name></decl></param>, <param><decl><type><name>float</name></type> <name>y2</name></decl></param>, <param><decl><type><name>float</name></type> <name>radius</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x1</name></expr></argument>,<argument><expr><name>y1</name></expr></argument>,<argument><expr><name>x2</name></expr></argument>,<argument><expr><name>y2</name></expr></argument>,<argument><expr><name>radius</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>radius</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_INDEX_SIZE_ERR</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>p0</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentPoint</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>double</name></type> <name>dir</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>cosx</name></decl>, <decl><type ref="prev"/><name>sinx</name></decl>, <decl><type ref="prev"/><name>d</name></decl>, <decl><type ref="prev"/><name>anx</name></decl>, <decl><type ref="prev"/><name>any</name></decl>, <decl><type ref="prev"/><name>bnx</name></decl>, <decl><type ref="prev"/><name>bny</name></decl>, <decl><type ref="prev"/><name>x3</name></decl>, <decl><type ref="prev"/><name>y3</name></decl>, <decl><type ref="prev"/><name>x4</name></decl>, <decl><type ref="prev"/><name>y4</name></decl>, <decl><type ref="prev"/><name>cx</name></decl>, <decl><type ref="prev"/><name>cy</name></decl>, <decl><type ref="prev"/><name>angle0</name></decl>, <decl><type ref="prev"/><name>angle1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>anticlockwise</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>x1</name> == <name><name>p0</name>.<name>x</name></name> &amp;&amp; <name>y1</name> == <name><name>p0</name>.<name>y</name></name>) || (<name>x1</name> == <name>x2</name> &amp;&amp; <name>y1</name> == <name>y2</name>) || <name>radius</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>LineTo</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>dir</name> = (<name>x2</name>-<name>x1</name>)*(<name><name>p0</name>.<name>y</name></name>-<name>y1</name>) + (<name>y2</name>-<name>y1</name>)*(<name>x1</name>-<name><name>p0</name>.<name>x</name></name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dir</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>LineTo</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>a2</name> = (<name><name>p0</name>.<name>x</name></name>-<name>x1</name>)*(<name><name>p0</name>.<name>x</name></name>-<name>x1</name>) + (<name><name>p0</name>.<name>y</name></name>-<name>y1</name>)*(<name><name>p0</name>.<name>y</name></name>-<name>y1</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>b2</name> = (<name>x1</name>-<name>x2</name>)*(<name>x1</name>-<name>x2</name>) + (<name>y1</name>-<name>y2</name>)*(<name>y1</name>-<name>y2</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>c2</name> = (<name><name>p0</name>.<name>x</name></name>-<name>x2</name>)*(<name><name>p0</name>.<name>x</name></name>-<name>x2</name>) + (<name><name>p0</name>.<name>y</name></name>-<name>y2</name>)*(<name><name>p0</name>.<name>y</name></name>-<name>y2</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>cosx</name> = (<name>a2</name>+<name>b2</name>-<name>c2</name>)/(2*<call><name>sqrt</name><argument_list>(<argument><expr><name>a2</name>*<name>b2</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>sinx</name> = <call><name>sqrt</name><argument_list>(<argument><expr>1 - <name>cosx</name>*<name>cosx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = <name>radius</name> / ((1 - <name>cosx</name>) / <name>sinx</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>anx</name> = (<name>x1</name>-<name><name>p0</name>.<name>x</name></name>) / <call><name>sqrt</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>any</name> = (<name>y1</name>-<name><name>p0</name>.<name>y</name></name>) / <call><name>sqrt</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bnx</name> = (<name>x1</name>-<name>x2</name>) / <call><name>sqrt</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bny</name> = (<name>y1</name>-<name>y2</name>) / <call><name>sqrt</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x3</name> = <name>x1</name> - <name>anx</name>*<name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y3</name> = <name>y1</name> - <name>any</name>*<name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>x4</name> = <name>x1</name> - <name>bnx</name>*<name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y4</name> = <name>y1</name> - <name>bny</name>*<name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>anticlockwise</name> = (<name>dir</name> &lt; 0)</expr>;</expr_stmt>
    <expr_stmt><expr><name>cx</name> = <name>x3</name> + <name>any</name>*<name>radius</name>*(<name>anticlockwise</name> ? 1 : -1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>cy</name> = <name>y3</name> - <name>anx</name>*<name>radius</name>*(<name>anticlockwise</name> ? 1 : -1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>angle0</name> = <call><name>atan2</name><argument_list>(<argument><expr>(<name>y3</name>-<name>cy</name>)</expr></argument>, <argument><expr>(<name>x3</name>-<name>cx</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>angle1</name> = <call><name>atan2</name><argument_list>(<argument><expr>(<name>y4</name>-<name>cy</name>)</expr></argument>, <argument><expr>(<name>x4</name>-<name>cx</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>LineTo</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>y3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>anticlockwise</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NegativeArc</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>radius</name></expr></argument>, <argument><expr><name>angle0</name></expr></argument>, <argument><expr><name>angle1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Arc</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>radius</name></expr></argument>, <argument><expr><name>angle0</name></expr></argument>, <argument><expr><name>angle1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Arc</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>r</name></decl></param>, <param><decl><type><name>float</name></type> <name>startAngle</name></decl></param>, <param><decl><type><name>float</name></type> <name>endAngle</name></decl></param>, <param><decl><type><name>int</name></type> <name>ccw</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>,<argument><expr><name>r</name></expr></argument>,<argument><expr><name>startAngle</name></expr></argument>,<argument><expr><name>endAngle</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <function_decl><type><name>gfxPoint</name></type> <name>p</name><parameter_list>(<param><decl><type><name>x</name></type></decl></param>,<param><decl><type><name>y</name></type></decl></param>)</parameter_list>;</function_decl>

    <if>if <condition>(<expr><name>ccw</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NegativeArc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>startAngle</name></expr></argument>, <argument><expr><name>endAngle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Arc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>startAngle</name></expr></argument>, <argument><expr><name>endAngle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>Rect</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>w</name></decl></param>, <param><decl><type><name>float</name></type> <name>h</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// text</comment>
<comment type="line">//</comment>

<comment type="block" format="doxygen">/**
 * Helper function for SetFont that creates a style rule for the given font.
 * @param aFont The CSS font string
 * @param aNode The canvas element
 * @param aResult Pointer in which to place the new style rule.
 * @remark Assumes all pointer arguments are non-null.
 */</comment>
<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>CreateFontStyleRule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aFont</name></decl></param>,
                    <param><decl><type><name>nsINode</name>*</type> <name>aNode</name></decl></param>,
                    <param><decl><type><name>nsICSSStyleRule</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsCSSParser</name></type> <name>parser</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// aFont is to be parsed as the value of a CSS 'font' shorthand,</comment>
    <comment type="line">// and then any line-height setting in that shorthand is to be</comment>
    <comment type="line">// overridden with "normal".  Because of the way style rules are</comment>
    <comment type="line">// stored, it is more efficient to fabricate a text string that</comment>
    <comment type="line">// can be processed in one go with ParseStyleAttribute than to</comment>
    <comment type="line">// make two calls to ParseDeclaration.</comment>

    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>styleAttr</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"font:"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>styleAttr</name>.<name>Append</name></name><argument_list>(<argument><expr><name>aFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>styleAttr</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>";line-height:normal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsIPrincipal</name>*</type> <name>principal</name> <init>= <expr><call><name><name>aNode</name>-&gt;<name>NodePrincipal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>document</name> <init>= <expr><call><name><name>aNode</name>-&gt;<name>GetOwnerDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIURI</name>*</type> <name>docURL</name> <init>= <expr><call><name><name>document</name>-&gt;<name>GetDocumentURI</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIURI</name>*</type> <name>baseURL</name> <init>= <expr><call><name><name>document</name>-&gt;<name>GetDocBaseURI</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>parser</name>.<name>ParseStyleAttribute</name></name><argument_list>(<argument><expr><name>styleAttr</name></expr></argument>, <argument><expr><name>docURL</name></expr></argument>, <argument><expr><name>baseURL</name></expr></argument>,
                                             <argument><expr><name>principal</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>(*<name>aResult</name>)-&gt;<name>RuleMatched</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetFont</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>font</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If font is defined with relative units (e.g. ems) and the parent
     * style context changes in between calls, setting the font to the
     * same value as previous could result in a different computed value,
     * so we cannot have the optimization where we check if the new font
     * string is equal to the old one.
     */</comment>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>content</name> &amp;&amp; !<name>mDocShell</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Canvas element must be an nsIContent and non-null or a docshell must be provided"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsIPresShell</name>*</type> <name>presShell</name> <init>= <expr><call><name>GetPresShell</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>presShell</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>document</name> <init>= <expr><call><name><name>presShell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleRule</name></expr></argument>&gt;</argument_list></name></type> <name>rules</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICSSStyleRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>CreateFontStyleRule</name><argument_list>(<argument><expr><name>font</name></expr></argument>, <argument><expr><name>document</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>rules</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsStyleSet</name>*</type> <name>styleSet</name> <init>= <expr><call><name><name>presShell</name>-&gt;<name>StyleSet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// have to get a parent style context for inherit-like relative</comment>
    <comment type="line">// values (2em, bolder, etc.)</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsStyleContext</name></expr></argument>&gt;</argument_list></name></type> <name>parentContext</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>content</name> &amp;&amp; <call><name><name>content</name>-&gt;<name>IsInDoc</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// inherit from the canvas element</comment>
        <expr_stmt><expr><name>parentContext</name> = <call><name><name>nsComputedDOMStyle</name>::<name>GetStyleContextForElement</name></name><argument_list>(
                <argument><expr><call><name><name>content</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><name>nsnull</name></expr></argument>,
                <argument><expr><name>presShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// otherwise inherit from default (10px sans-serif)</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICSSStyleRule</name></expr></argument>&gt;</argument_list></name></type> <name>parentRule</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>CreateFontStyleRule</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"10px sans-serif"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>document</name></expr></argument>,
                                 <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>parentRule</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIStyleRule</name></expr></argument>&gt;</argument_list></name></type> <name>parentRules</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>parentRules</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>parentRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>parentContext</name> = <call><name><name>styleSet</name>-&gt;<name>ResolveStyleForRules</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>parentRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>parentContext</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsStyleContext</name></expr></argument>&gt;</argument_list></name></type> <name>sc</name> <init>=
        <expr><call><name><name>styleSet</name>-&gt;<name>ResolveStyleForRules</name></name><argument_list>(<argument><expr><name>parentContext</name></expr></argument>, <argument><expr><name>rules</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>sc</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleFont</name>*</type> <name>fontStyle</name> <init>= <expr><call><name><name>sc</name>-&gt;<name>GetStyleFont</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>fontStyle</name></expr></argument>, <argument><expr>"Could not obtain font style"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>language</name> <init>= <expr><call><name><name>sc</name>-&gt;<name>GetStyleVisibility</name></name><argument_list>()</argument_list></call>-&gt;<name>mLanguage</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>language</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>language</name> = <call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetLanguageFromCharset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// use CSS pixels instead of dev pixels to avoid being affected by page zoom</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>aupcp</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// un-zoom the font size to avoid being affected by text-only zoom</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nscoord</name></type> <name>fontSize</name> <init>= <expr><call><name><name>nsStyleFont</name>::<name>UnZoomText</name></name><argument_list>(<argument><expr><call><name><name>parentContext</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>printerFont</name> <init>= <expr>(<call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Type</name><argument_list>()</argument_list></call> == <name><name>nsPresContext</name>::<name>eContext_PrintPreview</name></name> ||
                          <call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Type</name><argument_list>()</argument_list></call> == <name><name>nsPresContext</name>::<name>eContext_Print</name></name>)</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>gfxFontStyle</name></type> <name>style</name><argument_list>(<argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>style</name></name></expr></argument>,
                       <argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>weight</name></name></expr></argument>,
                       <argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>stretch</name></name></expr></argument>,
                       <argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name>fontSize</name></expr></argument>, <argument><expr><call><name>float</name><argument_list>(<argument><expr><name>aupcp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>language</name></expr></argument>,
                       <argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>sizeAdjust</name></name></expr></argument>,
                       <argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>systemFont</name></name></expr></argument>,
                       <argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>familyNameQuirks</name></name></expr></argument>,
                       <argument><expr><name>printerFont</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>fontGroup</name> =
        <call><name><name>gfxPlatform</name>::<name>GetPlatform</name></name><argument_list>()</argument_list></call>-&gt;<call><name>CreateFontGroup</name><argument_list>(<argument><expr><name><name>fontStyle</name>-&gt;<name>mFont</name>.<name>name</name></name></expr></argument>,
                                                    <argument><expr>&amp;<name>style</name></expr></argument>,
                                                    <argument><expr><call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetUserFontSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>fontGroup</name></expr></argument>, <argument><expr>"Could not get font group"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>font</name> = <name>font</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetFont</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>font</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* will initilize the value if not set, else does nothing */</comment>
    <expr_stmt><expr><call><name>GetCurrentFontStyle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>font</name> = <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>font</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetTextAlign</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>ta</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>ta</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"start"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> = <name>TEXT_ALIGN_START</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>ta</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"end"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> = <name>TEXT_ALIGN_END</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>ta</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"left"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> = <name>TEXT_ALIGN_LEFT</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>ta</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"right"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> = <name>TEXT_ALIGN_RIGHT</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>ta</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"center"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> = <name>TEXT_ALIGN_CENTER</name></expr>;</expr_stmt></then>
    <comment type="line">// spec says to not throw error for invalid arg, but do it anyway</comment>
    <else>else
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></else></if></else></if></else></if></else></if></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetTextAlign</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>ta</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name></expr>)</condition>
    <block>{
    <case>case <expr><name>TEXT_ALIGN_START</name></expr>:
        <expr_stmt><expr><call><name><name>ta</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"start"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_ALIGN_END</name></expr>:
        <expr_stmt><expr><call><name><name>ta</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"end"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_ALIGN_LEFT</name></expr>:
        <expr_stmt><expr><call><name><name>ta</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"left"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_ALIGN_RIGHT</name></expr>:
        <expr_stmt><expr><call><name><name>ta</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"right"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_ALIGN_CENTER</name></expr>:
        <expr_stmt><expr><call><name><name>ta</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"center"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"textAlign holds invalid value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    </default>}</block></switch>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetTextBaseline</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>tb</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>tb</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"top"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name> = <name>TEXT_BASELINE_TOP</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>tb</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"hanging"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name> = <name>TEXT_BASELINE_HANGING</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>tb</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"middle"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name> = <name>TEXT_BASELINE_MIDDLE</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>tb</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"alphabetic"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name> = <name>TEXT_BASELINE_ALPHABETIC</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>tb</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"ideographic"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name> = <name>TEXT_BASELINE_IDEOGRAPHIC</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>tb</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"bottom"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name> = <name>TEXT_BASELINE_BOTTOM</name></expr>;</expr_stmt></then>
    <comment type="line">// spec says to not throw error for invalid arg, but do it anyway</comment>
    <else>else
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></else></if></else></if></else></if></else></if></else></if></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetTextBaseline</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>tb</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name></expr>)</condition>
    <block>{
    <case>case <expr><name>TEXT_BASELINE_TOP</name></expr>:
        <expr_stmt><expr><call><name><name>tb</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"top"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_HANGING</name></expr>:
        <expr_stmt><expr><call><name><name>tb</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"hanging"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_MIDDLE</name></expr>:
        <expr_stmt><expr><call><name><name>tb</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"middle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_ALPHABETIC</name></expr>:
        <expr_stmt><expr><call><name><name>tb</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"alphabetic"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_IDEOGRAPHIC</name></expr>:
        <expr_stmt><expr><call><name><name>tb</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"ideographic"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_BOTTOM</name></expr>:
        <expr_stmt><expr><call><name><name>tb</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"bottom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"textBaseline holds invalid value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    </default>}</block></switch>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Helper function that replaces the whitespace characters in a string
 * with U+0020 SPACE. The whitespace characters are defined as U+0020 SPACE,
 * U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), U+000B LINE
 * TABULATION, U+000C FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).
 * @param str The string whose whitespace characters to replace.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>TextReplaceWhitespaceCharacters</name><parameter_list>(<param><decl><type><name>nsAutoString</name>&amp;</type> <name>str</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>str</name>.<name>ReplaceChar</name></name><argument_list>(<argument><expr>"\x09\x0A\x0B\x0C\x0D"</expr></argument>, <argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>FillText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>text</name></decl></param>, <param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>maxWidth</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>DrawOrMeasureText</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>maxWidth</name></expr></argument>, <argument><expr><name>TEXT_DRAW_OPERATION_FILL</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>StrokeText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>text</name></decl></param>, <param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>maxWidth</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>DrawOrMeasureText</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>maxWidth</name></expr></argument>, <argument><expr><name>TEXT_DRAW_OPERATION_STROKE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>MeasureText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>rawText</name></decl></param>,
                                        <param><decl><type><name>nsIDOMTextMetrics</name>**</type> <name>_retval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>float</name></type> <name>width</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>DrawOrMeasureText</name><argument_list>(<argument><expr><name>rawText</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>TEXT_DRAW_OPERATION_MEASURE</name></expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMTextMetrics</name></expr></argument>&gt;</argument_list></name></type> <name>textMetrics</name> <init>= <expr>new <call><name>nsTextMetrics</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>textMetrics</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>_retval</name> = <call><name><name>textMetrics</name>.<name>forget</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Used for nsBidiPresUtils::ProcessText
 */</comment>
<struct>struct <macro><name>NS_STACK_CLASS</name></macro> <name>nsCanvasBidiProcessor</name> <super>: <specifier>public</specifier> <name><name>nsBidiPresUtils</name>::<name>BidiProcessor</name></name></super>
<block>{<public type="default">
    <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetText</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>text</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>length</name></decl></param>, <param><decl><type><name>nsBidiDirection</name></type> <name>direction</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>mTextRun</name> = <call><name><name>gfxTextRunCache</name>::<name>MakeTextRun</name></name><argument_list>(<argument><expr><name>text</name></expr></argument>,
                                                <argument><expr><name>length</name></expr></argument>,
                                                <argument><expr><name>mFontgrp</name></expr></argument>,
                                                <argument><expr><name>mThebes</name></expr></argument>,
                                                <argument><expr><name>mAppUnitsPerDevPixel</name></expr></argument>,
                                                <argument><expr><name>direction</name>==<name>NSBIDI_RTL</name> ? <name><name>gfxTextRunFactory</name>::<name>TEXT_IS_RTL</name></name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>virtual</specifier> <name>nscoord</name></type> <name>GetWidth</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>gfxTextRun</name>::<name>Metrics</name></name></type> <name>textRunMetrics</name> <init>= <expr><call><name><name>mTextRun</name>-&gt;<name>MeasureText</name></name><argument_list>(<argument><expr>0</expr></argument>,
                                                                   <argument><expr><call><name><name>mTextRun</name>-&gt;<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                                   <argument><expr><name>mDoMeasureBoundingBox</name> ?
                                                                       <name><name>gfxFont</name>::<name>TIGHT_INK_EXTENTS</name></name> :
                                                                       <name><name>gfxFont</name>::<name>LOOSE_INK_EXTENTS</name></name></expr></argument>,
                                                                   <argument><expr><name>mThebes</name></expr></argument>,
                                                                   <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// this only measures the height; the total width is gotten from the</comment>
        <comment type="line">// the return value of ProcessText.</comment>
        <if>if <condition>(<expr><name>mDoMeasureBoundingBox</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>textRunMetrics</name>.<name>mBoundingBox</name>.<name>Scale</name></name><argument_list>(<argument><expr>1.0 / <name>mAppUnitsPerDevPixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mBoundingBox</name> = <call><name><name>mBoundingBox</name>.<name>Union</name></name><argument_list>(<argument><expr><name><name>textRunMetrics</name>.<name>mBoundingBox</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nscoord</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>textRunMetrics</name>.<name>mAdvanceWidth</name></name>/<call><name>gfxFloat</name><argument_list>(<argument><expr><name>mAppUnitsPerDevPixel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>virtual</specifier> <name>void</name></type> <name>DrawText</name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>xOffset</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>width</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>gfxPoint</name></type> <name>point</name> <init>= <expr><name>mPt</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>point</name>.<name>x</name></name> += <name>xOffset</name> * <name>mAppUnitsPerDevPixel</name></expr>;</expr_stmt>

        <comment type="line">// offset is given in terms of left side of string</comment>
        <if>if <condition>(<expr><call><name><name>mTextRun</name>-&gt;<name>IsRightToLeft</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>point</name>.<name>x</name></name> += <name>width</name> * <name>mAppUnitsPerDevPixel</name></expr>;</expr_stmt></then></if>

        <comment type="line">// stroke or fill the text depending on operation</comment>
        <if>if <condition>(<expr><name>mOp</name> == <name><name>nsCanvasRenderingContext2D</name>::<name>TEXT_DRAW_OPERATION_STROKE</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mTextRun</name>-&gt;<name>DrawToPath</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>,
                                 <argument><expr><name>point</name></expr></argument>,
                                 <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name><name>mTextRun</name>-&gt;<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>,
                                 <argument><expr><name>nsnull</name></expr></argument>,
                                 <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <comment type="line">// mOp == TEXT_DRAW_OPERATION_FILL</comment>
            <expr_stmt><expr><call><name><name>mTextRun</name>-&gt;<name>Draw</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>,
                           <argument><expr><name>point</name></expr></argument>,
                           <argument><expr>0</expr></argument>,
                           <argument><expr><call><name><name>mTextRun</name>-&gt;<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr><name>nsnull</name></expr></argument>,
                           <argument><expr><name>nsnull</name></expr></argument>,
                           <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <comment type="line">// current text run</comment>
    <decl_stmt><decl><type><name><name>gfxTextRunCache</name>::<name>AutoTextRun</name></name></type> <name>mTextRun</name></decl>;</decl_stmt>

    <comment type="line">// pointer to the context, may not be the canvas's context</comment>
    <comment type="line">// if an intermediate surface is being used</comment>
    <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>mThebes</name></decl>;</decl_stmt>

    <comment type="line">// position of the left side of the string, alphabetic baseline</comment>
    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>mPt</name></decl>;</decl_stmt>

    <comment type="line">// current font</comment>
    <decl_stmt><decl><type><name>gfxFontGroup</name>*</type> <name>mFontgrp</name></decl>;</decl_stmt>

    <comment type="line">// dev pixel conversion factor</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mAppUnitsPerDevPixel</name></decl>;</decl_stmt>

    <comment type="line">// operation (fill or stroke)</comment>
    <decl_stmt><decl><type><name><name>nsCanvasRenderingContext2D</name>::<name>TextDrawOperation</name></name></type> <name>mOp</name></decl>;</decl_stmt>

    <comment type="line">// union of bounding boxes of all runs, needed for shadows</comment>
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>mBoundingBox</name></decl>;</decl_stmt>

    <comment type="line">// true iff the bounding box should be measured</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mDoMeasureBoundingBox</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>nsresult</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>DrawOrMeasureText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aRawText</name></decl></param>,
                                              <param><decl><type><name>float</name></type> <name>aX</name></decl></param>,
                                              <param><decl><type><name>float</name></type> <name>aY</name></decl></param>,
                                              <param><decl><type><name>float</name></type> <name>aMaxWidth</name></decl></param>,
                                              <param><decl><type><name>TextDrawOperation</name></type> <name>aOp</name></decl></param>,
                                              <param><decl><type><name>float</name>*</type> <name>aWidth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr><name>aMaxWidth</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <comment type="line">// spec isn't clear on what should happen if aMaxWidth &lt;= 0, so</comment>
    <comment type="line">// treat it as an invalid argument</comment>
    <comment type="line">// technically, 0 should be an invalid value as well, but 0 is the default</comment>
    <comment type="line">// arg, and there is no way to tell if the default was used</comment>
    <if>if <condition>(<expr><name>aMaxWidth</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>content</name> &amp;&amp; !<name>mDocShell</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Canvas element must be an nsIContent and non-null or a docshell must be provided"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsIPresShell</name>*</type> <name>presShell</name> <init>= <expr><call><name>GetPresShell</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>presShell</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>document</name> <init>= <expr><call><name><name>presShell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsBidiPresUtils</name>*</type> <name>bidiUtils</name> <init>= <expr><call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetBidiUtils</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>bidiUtils</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <comment type="line">// replace all the whitespace characters with U+0020 SPACE</comment>
    <function_decl><type><name>nsAutoString</name></type> <name>textToDraw</name><parameter_list>(<param><decl><type><name>aRawText</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>TextReplaceWhitespaceCharacters</name><argument_list>(<argument><expr><name>textToDraw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// for now, default to ltr if not in doc</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>isRTL</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>content</name> &amp;&amp; <call><name><name>content</name>-&gt;<name>IsInDoc</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// try to find the closest context</comment>
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsStyleContext</name></expr></argument>&gt;</argument_list></name></type> <name>canvasStyle</name> <init>=
            <expr><call><name><name>nsComputedDOMStyle</name>::<name>GetStyleContextForElement</name></name><argument_list>(<argument><expr><call><name><name>content</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                          <argument><expr><name>nsnull</name></expr></argument>,
                                                          <argument><expr><name>presShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>canvasStyle</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>isRTL</name> = <call><name><name>canvasStyle</name>-&gt;<name>GetStyleVisibility</name></name><argument_list>()</argument_list></call>-&gt;<name>mDirection</name> ==
            <name>NS_STYLE_DIRECTION_RTL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>isRTL</name> = <call><name>GET_BIDI_OPTION_DIRECTION</name><argument_list>(<argument><expr><call><name><name>document</name>-&gt;<name>GetBidiOptions</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name>IBMBIDI_TEXTDIRECTION_RTL</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// don't need to take care of these with stroke since Stroke() does that</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>doDrawShadow</name> <init>= <expr><name>aOp</name> == <name>TEXT_DRAW_OPERATION_FILL</name> &amp;&amp; <call><name>NeedToDrawShadow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>doUseIntermediateSurface</name> <init>= <expr><name>aOp</name> == <name>TEXT_DRAW_OPERATION_FILL</name> &amp;&amp;
        <call><name>NeedIntermediateSurfaceToHandleGlobalAlpha</name><argument_list>(<argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Clear the surface if we need to simulate unbounded SOURCE operator</comment>
    <expr_stmt><expr><call><name>ClearSurfaceForUnboundedSource</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCanvasBidiProcessor</name></type> <name>processor</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GetAppUnitsValues</name><argument_list>(<argument><expr>&amp;<name><name>processor</name>.<name>mAppUnitsPerDevPixel</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>processor</name>.<name>mPt</name></name> = <call><name>gfxPoint</name><argument_list>(<argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>processor</name>.<name>mThebes</name></name> = <name>mThebes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>processor</name>.<name>mOp</name></name> = <name>aOp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>processor</name>.<name>mBoundingBox</name></name> = <call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>processor</name>.<name>mDoMeasureBoundingBox</name></name> = <name>doDrawShadow</name> || !<name>mIsEntireFrameInvalid</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>processor</name>.<name>mFontgrp</name></name> = <call><name>GetCurrentFontStyle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>processor</name>.<name>mFontgrp</name></name></expr></argument>, <argument><expr>"font group is null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nscoord</name></type> <name>totalWidth</name></decl>;</decl_stmt>

    <comment type="line">// calls bidi algo twice since it needs the full text width and the</comment>
    <comment type="line">// bounding boxes before rendering anything</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>bidiUtils</name>-&gt;<name>ProcessText</name></name><argument_list>(<argument><expr><call><name><name>textToDraw</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>isRTL</name> ? <name>NSBIDI_RTL</name> : <name>NSBIDI_LTR</name></expr></argument>,
                                <argument><expr><call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>processor</name></expr></argument>,
                                <argument><expr><name><name>nsBidiPresUtils</name>::<name>MODE_MEASURE</name></name></expr></argument>,
                                <argument><expr><name>nsnull</name></expr></argument>,
                                <argument><expr>0</expr></argument>,
                                <argument><expr>&amp;<name>totalWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>aWidth</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>aWidth</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>totalWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// if only measuring, don't need to do any more work</comment>
    <if>if <condition>(<expr><name>aOp</name>==<name>TEXT_DRAW_OPERATION_MEASURE</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// offset pt.x based on text align</comment>
    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>anchorX</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> == <name>TEXT_ALIGN_CENTER</name></expr>)</condition><then>
        <expr_stmt><expr><name>anchorX</name> = .5</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> == <name>TEXT_ALIGN_LEFT</name> ||
             (!<name>isRTL</name> &amp;&amp; <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> == <name>TEXT_ALIGN_START</name>) ||
             (<name>isRTL</name> &amp;&amp; <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textAlign</name> == <name>TEXT_ALIGN_END</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>anchorX</name> = 0</expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>anchorX</name> = 1</expr>;</expr_stmt></else></if></else></if>

    <expr_stmt><expr><name><name>processor</name>.<name>mPt</name>.<name>x</name></name> -= <name>anchorX</name> * <name>totalWidth</name></expr>;</expr_stmt>

    <comment type="line">// offset pt.y based on text baseline</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>processor</name>.<name>mFontgrp</name>-&gt;<name>FontListLength</name></name><argument_list>()</argument_list></call>&gt;0</expr></argument>, <argument><expr>"font group contains no fonts"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>gfxFont</name>::<name>Metrics</name></name>&amp;</type> <name>fontMetrics</name> <init>= <expr><call><name><name>processor</name>.<name>mFontgrp</name>-&gt;<name>GetFontAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>-&gt;<call><name>GetMetrics</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>anchorY</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>textBaseline</name></expr>)</condition>
    <block>{
    <case>case <expr><name>TEXT_BASELINE_TOP</name></expr>:
        <expr_stmt><expr><name>anchorY</name> = <name><name>fontMetrics</name>.<name>emAscent</name></name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_HANGING</name></expr>:
        <expr_stmt><expr><name>anchorY</name> = 0</expr>;</expr_stmt> <comment type="line">// currently unavailable</comment>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_MIDDLE</name></expr>:
        <expr_stmt><expr><name>anchorY</name> = (<name><name>fontMetrics</name>.<name>emAscent</name></name> - <name><name>fontMetrics</name>.<name>emDescent</name></name>) * .5f</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_ALPHABETIC</name></expr>:
        <expr_stmt><expr><name>anchorY</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_IDEOGRAPHIC</name></expr>:
        <expr_stmt><expr><name>anchorY</name> = 0</expr>;</expr_stmt> <comment type="line">// currently unvailable</comment>
        <break>break;</break>
    </case><case>case <expr><name>TEXT_BASELINE_BOTTOM</name></expr>:
        <expr_stmt><expr><name>anchorY</name> = -<name><name>fontMetrics</name>.<name>emDescent</name></name></expr>;</expr_stmt>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"mTextBaseline holds invalid value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    </default>}</block></switch>

    <expr_stmt><expr><name><name>processor</name>.<name>mPt</name>.<name>y</name></name> += <name>anchorY</name></expr>;</expr_stmt>

    <comment type="line">// correct bounding box to get it to be the correct size/position</comment>
    <expr_stmt><expr><name><name>processor</name>.<name>mBoundingBox</name>.<name>size</name>.<name>width</name></name> = <name>totalWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>processor</name>.<name>mBoundingBox</name>.<name>MoveBy</name></name><argument_list>(<argument><expr><name><name>processor</name>.<name>mPt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>processor</name>.<name>mPt</name>.<name>x</name></name> *= <name><name>processor</name>.<name>mAppUnitsPerDevPixel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>processor</name>.<name>mPt</name>.<name>y</name></name> *= <name><name>processor</name>.<name>mAppUnitsPerDevPixel</name></name></expr>;</expr_stmt>

    <comment type="line">// if text is over aMaxWidth, then scale the text horizontally such that its</comment>
    <comment type="line">// width is precisely aMaxWidth</comment>
    <decl_stmt><decl><type><name>gfxContextAutoSaveRestore</name></type> <name>autoSR</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aMaxWidth</name> &gt; 0 &amp;&amp; <name>totalWidth</name> &gt; <name>aMaxWidth</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>autoSR</name>.<name>SetContext</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// translate the anchor point to 0, then scale and translate back</comment>
        <decl_stmt><decl><type><name>gfxPoint</name></type> <name>trans</name><argument_list>(<argument><expr><name>aX</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Scale</name></name><argument_list>(<argument><expr><name>aMaxWidth</name>/<name>totalWidth</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr>-<name>trans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// save the previous bounding box</comment>
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>boundingBox</name> <init>= <expr><name><name>processor</name>.<name>mBoundingBox</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// don't ever need to measure the bounding box twice</comment>
    <expr_stmt><expr><name><name>processor</name>.<name>mDoMeasureBoundingBox</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>doDrawShadow</name></expr>)</condition><then> <block>{
        <comment type="line">// for some reason the box is too tight, probably rounding error</comment>
        <expr_stmt><expr><call><name><name>processor</name>.<name>mBoundingBox</name>.<name>Outset</name></name><argument_list>(<argument><expr>2.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// this is unnecessarily big is max-width scaling is involved, but it</comment>
        <comment type="line">// will still produce correct output</comment>
        <decl_stmt><decl><type><name>gfxRect</name></type> <name>drawExtents</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><name><name>processor</name>.<name>mBoundingBox</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gfxAlphaBoxBlur</name></type> <name>blur</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>ctx</name> <init>= <expr><call><name>ShadowInitialize</name><argument_list>(<argument><expr><name>drawExtents</name></expr></argument>, <argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ctx</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CopyContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>processor</name>.<name>mThebes</name></name> = <name>ctx</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name><name>bidiUtils</name>-&gt;<name>ProcessText</name></name><argument_list>(<argument><expr><call><name><name>textToDraw</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><name>isRTL</name> ? <name>NSBIDI_RTL</name> : <name>NSBIDI_LTR</name></expr></argument>,
                                        <argument><expr><call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><name>processor</name></expr></argument>,
                                        <argument><expr><name><name>nsBidiPresUtils</name>::<name>MODE_DRAW</name></name></expr></argument>,
                                        <argument><expr><name>nsnull</name></expr></argument>,
                                        <argument><expr>0</expr></argument>,
                                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>ShadowFinalize</name><argument_list>(<argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>processor</name>.<name>mThebes</name></name> = <name>mThebes</name></expr>;</expr_stmt>
    }</block></then></if>

    <function_decl><type><name>gfxContextPathAutoSaveRestore</name></type> <name>pathSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>, <param><decl><type><name>PR_FALSE</name></type></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// back up path if stroking</comment>
    <if>if <condition>(<expr><name>aOp</name> == <name><name>nsCanvasRenderingContext2D</name>::<name>TEXT_DRAW_OPERATION_STROKE</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>pathSR</name>.<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
    <comment type="line">// doUseIntermediateSurface is mutually exclusive to op == STROKE</comment>
    <else>else <block>{
        <if>if <condition>(<expr><name>doUseIntermediateSurface</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>PushGroup</name></name><argument_list>(<argument><expr><name><name>gfxASurface</name>::<name>CONTENT_COLOR_ALPHA</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// don't want operators to be applied twice</comment>
            <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>bidiUtils</name>-&gt;<name>ProcessText</name></name><argument_list>(<argument><expr><call><name><name>textToDraw</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>isRTL</name> ? <name>NSBIDI_RTL</name> : <name>NSBIDI_LTR</name></expr></argument>,
                                <argument><expr><call><name><name>presShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>processor</name></expr></argument>,
                                <argument><expr><name><name>nsBidiPresUtils</name>::<name>MODE_DRAW</name></name></expr></argument>,
                                <argument><expr><name>nsnull</name></expr></argument>,
                                <argument><expr>0</expr></argument>,
                                <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// this needs to be restored before function can return</comment>
    <if>if <condition>(<expr><name>doUseIntermediateSurface</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>PopGroupToSource</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>aOp</name> == <name><name>nsCanvasRenderingContext2D</name>::<name>TEXT_DRAW_OPERATION_STROKE</name></name></expr>)</condition><then> <block>{
        <comment type="line">// DrawPath takes care of all shadows and composite oddities</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>DrawPath</name><argument_list>(<argument><expr><name>STYLE_STROKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>doUseIntermediateSurface</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<call><name>StyleIsColor</name><argument_list>(<argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call> ? 1.0 : <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

    <if>if <condition>(<expr><name>aOp</name> == <name><name>nsCanvasRenderingContext2D</name>::<name>TEXT_DRAW_OPERATION_FILL</name></name> &amp;&amp; !<name>doDrawShadow</name></expr>)</condition><then>
        <return>return <expr><call><name>Redraw</name><argument_list>(<argument><expr><call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><name>boundingBox</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><call><name>Redraw</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetMozTextStyle</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>textStyle</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// font and mozTextStyle are the same value</comment>
    <return>return <expr><call><name>SetFont</name><argument_list>(<argument><expr><name>textStyle</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetMozTextStyle</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>textStyle</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// font and mozTextStyle are the same value</comment>
    <return>return <expr><call><name>GetFont</name><argument_list>(<argument><expr><name>textStyle</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>gfxFontGroup</name> *</type><name><name>nsCanvasRenderingContext2D</name>::<name>GetCurrentFontStyle</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// use lazy initilization for the font group since it's rather expensive</comment>
    <if>if<condition>(<expr>!<call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>fontGroup</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>res</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr><call><name>SetMozTextStyle</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"10px sans-serif"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>res</name> == <name>NS_OK</name></expr></argument>, <argument><expr>"Default canvas font is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>fontGroup</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>MozDrawText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>textToDraw</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>textdata</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>textToDraw</name>.<name>GetData</name></name><argument_list>(<argument><expr>&amp;<name>textdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>textrunflags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>aupdp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetAppUnitsValues</name><argument_list>(<argument><expr>&amp;<name>aupdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>gfxTextRunCache</name>::<name>AutoTextRun</name></name></type> <name>textRun</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>textRun</name> = <call><name><name>gfxTextRunCache</name>::<name>MakeTextRun</name></name><argument_list>(<argument><expr><name>textdata</name></expr></argument>,
                                           <argument><expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>GetCurrentFontStyle</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><name>mThebes</name></expr></argument>,
                                           <argument><expr><name>aupdp</name></expr></argument>,
                                           <argument><expr><name>textrunflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr>!<call><name><name>textRun</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>pt</name><argument_list>(<argument><expr>0.0f</expr></argument>,<argument><expr>0.0f</expr></argument>)</argument_list></decl>;</decl_stmt>

    <comment type="line">// Fill color is text color</comment>
    <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>textRun</name>-&gt;<name>Draw</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>,
                  <argument><expr><name>pt</name></expr></argument>,
                  <comment type="block">/* offset = */</comment> <argument><expr>0</expr></argument>,
                  <argument><expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr><name>nsnull</name></expr></argument>,
                  <argument><expr><name>nsnull</name></expr></argument>,
                  <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>Redraw</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>MozMeasureText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>textToMeasure</name></decl></param>, <param><decl><type><name>float</name> *</type><name>retVal</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMTextMetrics</name></expr></argument>&gt;</argument_list></name></type> <name>metrics</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>MeasureText</name><argument_list>(<argument><expr><name>textToMeasure</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>metrics</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>metrics</name>-&gt;<name>GetWidth</name></name><argument_list>(<argument><expr><name>retVal</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>MozPathText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>textToPath</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>textdata</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>textToPath</name>.<name>GetData</name></name><argument_list>(<argument><expr>&amp;<name>textdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>textrunflags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>aupdp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetAppUnitsValues</name><argument_list>(<argument><expr>&amp;<name>aupdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>gfxTextRunCache</name>::<name>AutoTextRun</name></name></type> <name>textRun</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>textRun</name> = <call><name><name>gfxTextRunCache</name>::<name>MakeTextRun</name></name><argument_list>(<argument><expr><name>textdata</name></expr></argument>,
                                           <argument><expr><call><name><name>textToPath</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>GetCurrentFontStyle</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><name>mThebes</name></expr></argument>,
                                           <argument><expr><name>aupdp</name></expr></argument>,
                                           <argument><expr><name>textrunflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr>!<call><name><name>textRun</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>pt</name><argument_list>(<argument><expr>0.0f</expr></argument>,<argument><expr>0.0f</expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>textRun</name>-&gt;<name>DrawToPath</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>,
                        <argument><expr><name>pt</name></expr></argument>,
                        <comment type="block">/* offset = */</comment> <argument><expr>0</expr></argument>,
                        <argument><expr><call><name><name>textToPath</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>MozTextAlongPath</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>textToDraw</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>stroke</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Most of this code is copied from its svg equivalent</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxFlattenedPath</name></expr></argument>&gt;</argument_list></name></type> <name>path</name><argument_list>(<argument><expr><call><name><name>mThebes</name>-&gt;<name>GetFlattenedPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>textdata</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>textToDraw</name>.<name>GetData</name></name><argument_list>(<argument><expr>&amp;<name>textdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>textrunflags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>aupdp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetAppUnitsValues</name><argument_list>(<argument><expr>&amp;<name>aupdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>gfxTextRunCache</name>::<name>AutoTextRun</name></name></type> <name>textRun</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>textRun</name> = <call><name><name>gfxTextRunCache</name>::<name>MakeTextRun</name></name><argument_list>(<argument><expr><name>textdata</name></expr></argument>,
                                           <argument><expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>GetCurrentFontStyle</name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr><name>mThebes</name></expr></argument>,
                                           <argument><expr><name>aupdp</name></expr></argument>,
                                           <argument><expr><name>textrunflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr>!<call><name><name>textRun</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <struct>struct <name>PathChar</name>
    <block>{<public type="default">
        <decl_stmt><decl><type><name>PRBool</name></type> <name>draw</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gfxFloat</name></type> <name>angle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>gfxPoint</name></type> <name>pos</name></decl>;</decl_stmt>
        <constructor><name>PathChar</name><parameter_list>()</parameter_list> <member_list>: <call><name>draw</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>, <call><name>angle</name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call>, <call><name>pos</name><argument_list>(<argument><expr>0.0</expr></argument>,<argument><expr>0.0</expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
    </public>}</block>;</struct>

    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>length</name> <init>= <expr><call><name><name>path</name>-&gt;<name>GetLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>strLength</name> <init>= <expr><call><name><name>textToDraw</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PathChar</name> *</type><name>cp</name> <init>= <expr>new <name><name>PathChar</name><index>[<expr><name>strLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>cp</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>position</name><argument_list>(<argument><expr>0.0</expr></argument>,<argument><expr>0.0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>x</name> <init>= <expr><name><name>position</name>.<name>x</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>strLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
        <decl_stmt><decl><type><name>gfxFloat</name></type> <name>halfAdvance</name> <init>= <expr><call><name><name>textRun</name>-&gt;<name>GetAdvanceWidth</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> / (2.0 * <name>aupdp</name>)</expr></init></decl>;</decl_stmt>

        <comment type="line">// Check for end of path</comment>
        <if>if<condition>(<expr><name>x</name> + <name>halfAdvance</name> &gt; <name>length</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <if>if<condition>(<expr><name>x</name> + <name>halfAdvance</name> &gt;= 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>draw</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>gfxPoint</name></type> <name>pt</name> <init>= <expr><call><name><name>path</name>-&gt;<name>FindPoint</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name> + <name>halfAdvance</name></expr></argument>, <argument><expr><name><name>position</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;(<name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>angle</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pos</name> = <name>pt</name> - <call><name>gfxPoint</name><argument_list>(<argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>angle</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> * <name>halfAdvance</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>x</name> += 2 * <name>halfAdvance</name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name>stroke</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>STYLE_STROKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>ApplyStyle</name><argument_list>(<argument><expr><name>STYLE_FILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <for>for(<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>strLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
        <comment type="line">// Skip non-visible characters</comment>
        <if>if<condition>(<expr>!<name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>draw</name></expr>)</condition><then> <continue>continue;</continue></then></if>

        <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>rot</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>rot</name>.<name>Rotate</name></name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>angle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Multiply</name></name><argument_list>(<argument><expr><name>rot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>rot</name>.<name>Invert</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>rot</name>.<name>Scale</name></name><argument_list>(<argument><expr><name>aupdp</name></expr></argument>,<argument><expr><name>aupdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>gfxPoint</name></type> <name>pt</name> <init>= <expr><call><name><name>rot</name>.<name>Transform</name></name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if<condition>(<expr><name>stroke</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>textRun</name>-&gt;<name>DrawToPath</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>textRun</name>-&gt;<name>Draw</name></name><argument_list>(<argument><expr><name>mThebes</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name>stroke</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Stroke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr>delete <index>[]</index> <name>cp</name></expr>;</expr_stmt>

    <return>return <expr><call><name>Redraw</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// line caps/joins</comment>
<comment type="line">//</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetLineWidth</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>width</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetLineWidth</name></name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetLineWidth</name></name><parameter_list>(<param><decl><type><name>float</name> *</type><name>width</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>d</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentLineWidth</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>width</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetLineCap</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>capstyle</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsLineCap</name></name></type> <name>cap</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>capstyle</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"butt"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>cap</name> = <name><name>gfxContext</name>::<name>LINE_CAP_BUTT</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>capstyle</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"round"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>cap</name> = <name><name>gfxContext</name>::<name>LINE_CAP_ROUND</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>capstyle</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"square"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>cap</name> = <name><name>gfxContext</name>::<name>LINE_CAP_SQUARE</name></name></expr>;</expr_stmt></then>
    <else>else
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return></else></if></else></if></else></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetLineCap</name></name><argument_list>(<argument><expr><name>cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetLineCap</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>capstyle</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsLineCap</name></name></type> <name>cap</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentLineCap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cap</name> == <name><name>gfxContext</name>::<name>LINE_CAP_BUTT</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>capstyle</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"butt"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>cap</name> == <name><name>gfxContext</name>::<name>LINE_CAP_ROUND</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>capstyle</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"round"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>cap</name> == <name><name>gfxContext</name>::<name>LINE_CAP_SQUARE</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>capstyle</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"square"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></else></if></else></if></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetLineJoin</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>joinstyle</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsLineJoin</name></name></type> <name>j</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>joinstyle</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"round"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>j</name> = <name><name>gfxContext</name>::<name>LINE_JOIN_ROUND</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>joinstyle</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"bevel"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>j</name> = <name><name>gfxContext</name>::<name>LINE_JOIN_BEVEL</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>joinstyle</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"miter"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>j</name> = <name><name>gfxContext</name>::<name>LINE_JOIN_MITER</name></name></expr>;</expr_stmt></then>
    <else>else
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return></else></if></else></if></else></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetLineJoin</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetLineJoin</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>joinstyle</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsLineJoin</name></name></type> <name>j</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentLineJoin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>j</name> == <name><name>gfxContext</name>::<name>LINE_JOIN_ROUND</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>joinstyle</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"round"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>j</name> == <name><name>gfxContext</name>::<name>LINE_JOIN_BEVEL</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>joinstyle</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"bevel"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>j</name> == <name><name>gfxContext</name>::<name>LINE_JOIN_MITER</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>joinstyle</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"miter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></else></if></else></if></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetMiterLimit</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>miter</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>miter</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetMiterLimit</name></name><argument_list>(<argument><expr><name>miter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetMiterLimit</name></name><parameter_list>(<param><decl><type><name>float</name> *</type><name>miter</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gfxFloat</name></type> <name>d</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentMiterLimit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>miter</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>IsPointInPath</name></name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>retVal</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>retVal</name> = <call><name><name>mThebes</name>-&gt;<name>PointInFill</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>,<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
<comment type="block">/* A simple bitblt for self copies that ensures that we don't overwrite any
 * area before we've read from it. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitblt</name><parameter_list>(<param><decl><type><name>gfxImageSurface</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>src_x</name></decl></param>, <param><decl><type><name>int</name></type> <name>src_y</name></decl></param>, <param><decl><type><name>int</name></type> <name>width</name></decl></param>, <param><decl><type><name>int</name></type> <name>height</name></decl></param>,
                <param><decl><type><name>int</name></type> <name>dest_x</name></decl></param>, <param><decl><type><name>int</name></type> <name>dest_y</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name> <init>= <expr><call><name><name>s</name>-&gt;<name>Data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stride</name> <init>= <expr><call><name><name>s</name>-&gt;<name>Stride</name></name><argument_list>()</argument_list></call>/4</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name> *</type><name>dest</name> <init>= <expr>(<name>unsigned</name> <name>int</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name> *</type><name>src</name>  <init>= <expr>(<name>unsigned</name> <name>int</name> *)<name>data</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>surface_width</name>  <init>= <expr><call><name><name>s</name>-&gt;<name>Width</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>surface_height</name> <init>= <expr><call><name><name>s</name>-&gt;<name>Height</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* clip to the surface size */</comment>
    <if>if <condition>(<expr><name>src_x</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dest_x</name> += -<name>src_x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>width</name>  -= -<name>src_x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>src_x</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>src_y</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dest_y</name> += -<name>src_y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>height</name> -= -<name>src_y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>src_y</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>dest_x</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>src_x</name> += -<name>dest_x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>width</name> -= -<name>dest_x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dest_x</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>dest_y</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>src_y</name>  += -<name>dest_y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>height</name> -= -<name>dest_y</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dest_y</name>  = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*XXX: we might want to check for overflow? */</comment>
    <if>if <condition>(<expr><name>src_x</name> + <name>width</name> &gt; <name>surface_width</name></expr>)</condition><then>
        <expr_stmt><expr><name>width</name> = <name>surface_width</name> - <name>src_x</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>dest_x</name> + <name>width</name> &gt; <name>surface_width</name></expr>)</condition><then>
        <expr_stmt><expr><name>width</name> = <name>surface_width</name> - <name>dest_x</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>src_y</name> + <name>height</name> &gt; <name>surface_height</name></expr>)</condition><then>
        <expr_stmt><expr><name>height</name> = <name>surface_height</name> - <name>src_y</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>dest_y</name> + <name>height</name> &gt; <name>surface_height</name></expr>)</condition><then>
        <expr_stmt><expr><name>height</name> = <name>surface_height</name> - <name>dest_y</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>dest_x</name> &lt; <name>src_x</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>dest_y</name> &lt; <name>src_y</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dest</name> = <name>dest</name> + <name>dest_y</name>*<name>stride</name> + <name>dest_x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>src</name>  = <name>src</name>  +  <name>src_y</name>*<name>stride</name> + <name>src_x</name></expr>;</expr_stmt>
            <comment type="block">/* copy right to left, top to bottom */</comment>
            <for>for (<init><expr><name>y</name>=0</expr>;</init> <condition><expr><name>y</name>&lt;<name>height</name></expr>;</condition> <incr><expr><name>y</name>++</expr></incr>) <block>{
                <for>for (<init><expr><name>x</name>=0</expr>;</init> <condition><expr><name>x</name>&lt;<name>width</name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
                    <expr_stmt><expr>*<name>dest</name>++ = *<name>src</name>++</expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>dest</name> += <name>stride</name> - <name>width</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>src</name>  += <name>stride</name> - <name>width</name></expr>;</expr_stmt>
            }</block></for>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>dest</name> = <name>dest</name> + (<name>dest_y</name>+<name>height</name>-1)*<name>stride</name> + <name>dest_x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>src</name>  = <name>src</name>  + (<name>src_y</name> +<name>height</name>-1)*<name>stride</name> + <name>src_x</name></expr>;</expr_stmt>
            <comment type="block">/* copy right to left, bottom to top */</comment>
            <for>for (<init><expr><name>y</name>=0</expr>;</init> <condition><expr><name>y</name>&lt;<name>height</name></expr>;</condition> <incr><expr><name>y</name>++</expr></incr>) <block>{
                <for>for (<init><expr><name>x</name>=0</expr>;</init> <condition><expr><name>x</name>&lt;<name>width</name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
                    <expr_stmt><expr>*<name>dest</name>++ = *<name>src</name>++</expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>dest</name> += -<name>stride</name> - <name>width</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>src</name>  += -<name>stride</name> - <name>width</name></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name>dest_y</name> &lt; <name>src_y</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dest</name> = <name>dest</name> + <name>dest_y</name>*<name>stride</name> + (<name>dest_x</name>+<name>width</name>-1)</expr>;</expr_stmt>
            <expr_stmt><expr><name>src</name>  = <name>src</name>  +  <name>src_y</name>*<name>stride</name> + (<name>src_x</name> +<name>width</name>-1)</expr>;</expr_stmt>
            <comment type="block">/* copy left to right, top to bottom */</comment>
            <for>for (<init><expr><name>y</name>=0</expr>;</init> <condition><expr><name>y</name>&lt;<name>height</name></expr>;</condition> <incr><expr><name>y</name>++</expr></incr>) <block>{
                <for>for (<init><expr><name>x</name>=0</expr>;</init> <condition><expr><name>x</name>&lt;<name>width</name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
                    <expr_stmt><expr>*<name>dest</name>-- = *<name>src</name>--</expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>dest</name> += <name>stride</name> + <name>width</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>src</name>  += <name>stride</name> + <name>width</name></expr>;</expr_stmt>
            }</block></for>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>dest</name> = <name>dest</name> + (<name>dest_y</name>+<name>height</name>-1)*<name>stride</name> + (<name>dest_x</name>+<name>width</name>-1)</expr>;</expr_stmt>
            <expr_stmt><expr><name>src</name>  = <name>src</name>  + (<name>src_y</name> +<name>height</name>-1)*<name>stride</name> + (<name>src_x</name> +<name>width</name>-1)</expr>;</expr_stmt>
            <comment type="block">/* copy left to right, bottom to top */</comment>
            <for>for (<init><expr><name>y</name>=0</expr>;</init> <condition><expr><name>y</name>&lt;<name>height</name></expr>;</condition> <incr><expr><name>y</name>++</expr></incr>) <block>{
                <for>for (<init><expr><name>x</name>=0</expr>;</init> <condition><expr><name>x</name>&lt;<name>width</name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
                    <expr_stmt><expr>*<name>dest</name>-- = *<name>src</name>--</expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>dest</name> += -<name>stride</name> + <name>width</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>src</name>  += -<name>stride</name> + <name>width</name></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
    }</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//</comment>
<comment type="line">// image</comment>
<comment type="line">//</comment>

<comment type="line">// drawImage(in HTMLImageElement image, in float dx, in float dy);</comment>
<comment type="line">//   -- render image from 0,0 at dx,dy top-left coords</comment>
<comment type="line">// drawImage(in HTMLImageElement image, in float dx, in float dy, in float sw, in float sh);</comment>
<comment type="line">//   -- render image from 0,0 at dx,dy top-left coords clipping it to sw,sh</comment>
<comment type="line">// drawImage(in HTMLImageElement image, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh);</comment>
<comment type="line">//   -- render the region defined by (sx,sy,sw,wh) in image-local space into the region (dx,dy,dw,dh) on the canvas</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>DrawImage</name></name><parameter_list>(<param><decl><type><name>nsIDOMElement</name> *</type><name>imgElt</name></decl></param>, <param><decl><type><name>float</name></type> <name>a1</name></decl></param>,
                                      <param><decl><type><name>float</name></type> <name>a2</name></decl></param>, <param><decl><type><name>float</name></type> <name>a3</name></decl></param>, <param><decl><type><name>float</name></type> <name>a4</name></decl></param>, <param><decl><type><name>float</name></type> <name>a5</name></decl></param>,
                                      <param><decl><type><name>float</name></type> <name>a6</name></decl></param>, <param><decl><type><name>float</name></type> <name>a7</name></decl></param>, <param><decl><type><name>float</name></type> <name>a8</name></decl></param>,
                                      <param><decl><type><name>PRUint8</name></type> <name>optional_argc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG</name><argument_list>(<argument><expr><name>imgElt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>dirty</name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr>0.0</expr></argument>, <argument><expr>0.0</expr></argument>, <argument><expr>0.0</expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>double</name></type> <name>sx</name></decl>,<decl><type ref="prev"/><name>sy</name></decl>,<decl><type ref="prev"/><name>sw</name></decl>,<decl><type ref="prev"/><name>sh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dx</name></decl>,<decl><type ref="prev"/><name>dy</name></decl>,<decl><type ref="prev"/><name>dw</name></decl>,<decl><type ref="prev"/><name>dh</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPath</name></expr></argument>&gt;</argument_list></name></type> <name>path</name></decl>;</decl_stmt>

    <comment type="line">// The canvas spec says that drawImage should draw the first frame</comment>
    <comment type="line">// of animated images</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>sfeFlags</name> <init>= <expr><name><name>nsLayoutUtils</name>::<name>SFE_WANT_FIRST_FRAME</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsLayoutUtils</name>::<name>SurfaceFromElementResult</name></name></type> <name>res</name> <init>=
        <expr><call><name><name>nsLayoutUtils</name>::<name>SurfaceFromElement</name></name><argument_list>(<argument><expr><name>imgElt</name></expr></argument>, <argument><expr><name>sfeFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name><name>res</name>.<name>mSurface</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <comment type="line">// On non-CE, force a copy if we're using drawImage with our destination</comment>
    <comment type="line">// as a source to work around some Cairo self-copy semantics issues.</comment>
    <if>if <condition>(<expr><name><name>res</name>.<name>mSurface</name></name> == <name>mSurface</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sfeFlags</name> |= <name><name>nsLayoutUtils</name>::<name>SFE_WANT_NEW_SURFACE</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> = <call><name><name>nsLayoutUtils</name>::<name>SurfaceFromElement</name></name><argument_list>(<argument><expr><name>imgElt</name></expr></argument>, <argument><expr><name>sfeFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>res</name>.<name>mSurface</name></name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>imgsurf</name> <init>= <expr><name><name>res</name>.<name>mSurface</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrincipal</name></expr></argument>&gt;</argument_list></name></type> <name>principal</name> <init>= <expr><name><name>res</name>.<name>mPrincipal</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gfxIntSize</name></type> <name>imgSize</name> <init>= <expr><name><name>res</name>.<name>mSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>forceWriteOnly</name> <init>= <expr><name><name>res</name>.<name>mIsWriteOnly</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mCanvasElement</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>CanvasUtils</name>::<name>DoDrawImageSecurityCheck</name></name><argument_list>(<argument><expr><name>mCanvasElement</name></expr></argument>, <argument><expr><name>principal</name></expr></argument>, <argument><expr><name>forceWriteOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <function_decl><type><name>gfxContextPathAutoSaveRestore</name></type> <name>pathSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>, <param><decl><type><name>PR_FALSE</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>optional_argc</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dx</name> = <name>a1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dy</name> = <name>a2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sx</name> = <name>sy</name> = 0.0</expr>;</expr_stmt>
        <expr_stmt><expr><name>dw</name> = <name>sw</name> = (<name>double</name>) <name><name>imgSize</name>.<name>width</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dh</name> = <name>sh</name> = (<name>double</name>) <name><name>imgSize</name>.<name>height</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>optional_argc</name> == 2</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dx</name> = <name>a1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dy</name> = <name>a2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dw</name> = <name>a3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dh</name> = <name>a4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sx</name> = <name>sy</name> = 0.0</expr>;</expr_stmt>
        <expr_stmt><expr><name>sw</name> = (<name>double</name>) <name><name>imgSize</name>.<name>width</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sh</name> = (<name>double</name>) <name><name>imgSize</name>.<name>height</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>optional_argc</name> == 6</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sx</name> = <name>a1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sy</name> = <name>a2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sw</name> = <name>a3</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sh</name> = <name>a4</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dx</name> = <name>a5</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dy</name> = <name>a6</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dw</name> = <name>a7</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dh</name> = <name>a8</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_INVALID_ARG</name></expr>;</expr_stmt>
        <goto>goto <name>FINISH</name>;</goto>
    }</block></else></if></else></if></else></if>

    <if>if <condition>(<expr><name>dw</name> == 0.0 || <name>dh</name> == 0.0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
        <comment type="line">// not really failure, but nothing to do --</comment>
        <comment type="line">// and noone likes a divide-by-zero</comment>
        <goto>goto <name>FINISH</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>FloatValidate</name><argument_list>(<argument><expr><name>sx</name></expr></argument>, <argument><expr><name>sy</name></expr></argument>, <argument><expr><name>sw</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>)</argument_list></call> || !<call><name>FloatValidate</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>dh</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</expr_stmt>
        <goto>goto <name>FINISH</name>;</goto>
    }</block></then></if>

    <comment type="line">// check args</comment>
    <if>if <condition>(<expr><name>sx</name> &lt; 0.0 || <name>sy</name> &lt; 0.0 ||
        <macro><name>sw</name></macro> &lt; 0.0 || <name>sw</name> &gt; (<name>double</name>) <name><name>imgSize</name>.<name>width</name></name> ||
        <macro><name>sh</name></macro> &lt; 0.0 || <name>sh</name> &gt; (<name>double</name>) <name><name>imgSize</name>.<name>height</name></name> ||
        <name>dw</name> &lt; 0.0 || <name>dh</name> &lt; 0.0</expr>)</condition><then>
    <block>{
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_DOM_INDEX_SIZE_ERR</name></expr>;</expr_stmt>
        <goto>goto <name>FINISH</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>matrix</name>.<name>Translate</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>sx</name></expr></argument>, <argument><expr><name>sy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>matrix</name>.<name>Scale</name></name><argument_list>(<argument><expr><name>sw</name>/<name>dw</name></expr></argument>, <argument><expr><name>sh</name>/<name>dh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
    <comment type="block">/* cairo doesn't have consistent semantics for drawing a surface onto
     * itself. Specifically, pixman will not preserve the contents when doing
     * the copy. So to get the desired semantics a temporary copy would be needed.
     * Instead we optimize opaque self copies here */</comment>
    <block>{
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>csurf</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>csurf</name> == <name>imgsurf</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>imgsurf</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>gfxASurface</name>::<name>SurfaceTypeImage</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>gfxImageSurface</name> *</type><name>surf</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>gfxImageSurface</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>imgsurf</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsOperator</name></name></type> <name>op</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentOperator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PRBool</name></type> <name>opaque</name></decl>, <decl><type ref="prev"/><name>unscaled</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>opaque</name>  = <call><name><name>surf</name>-&gt;<name>Format</name></name><argument_list>()</argument_list></call> == <name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name> &amp;&amp;
                    (<name>op</name> == <name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>opaque</name> |= <call><name><name>surf</name>-&gt;<name>Format</name></name><argument_list>()</argument_list></call> == <name><name>gfxASurface</name>::<name>ImageFormatRGB24</name></name>  &amp;&amp;
                    (<name>op</name> == <name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name> || <name>op</name> == <name><name>gfxContext</name>::<name>OPERATOR_OVER</name></name>)</expr>;</expr_stmt>

                <expr_stmt><expr><name>unscaled</name> = <name>sw</name> == <name>dw</name> &amp;&amp; <name>sh</name> == <name>dh</name></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>opaque</name> &amp;&amp; <name>unscaled</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>bitblt</name><argument_list>(<argument><expr><name>surf</name></expr></argument>, <argument><expr><name>sx</name></expr></argument>, <argument><expr><name>sy</name></expr></argument>, <argument><expr><name>sw</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
                    <goto>goto <name>FINISH</name>;</goto>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>pattern</name> = new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>imgsurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pattern</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>imageSmoothingEnabled</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>pattern</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name><name>gfxPattern</name>::<name>FILTER_GOOD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>pattern</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name><name>gfxPattern</name>::<name>FILTER_NEAREST</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><call><name><name>pathSR</name>.<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Clear the surface if we need to simulate unbounded SOURCE operator</comment>
    <expr_stmt><expr><call><name>ClearSurfaceForUnboundedSource</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <block>{
        <function_decl><type><name>gfxContextAutoSaveRestore</name></type> <name>autoSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>dx</name></expr></argument>, <argument><expr><name>dy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetPattern</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>gfxRect</name></type> <name>clip</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>dh</name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>NeedToDrawShadow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>gfxRect</name></type> <name>drawExtents</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><name>clip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>gfxAlphaBoxBlur</name></type> <name>blur</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>ctx</name> <init>= <expr><call><name>ShadowInitialize</name><argument_list>(<argument><expr><name>drawExtents</name></expr></argument>, <argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>ctx</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>CopyContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Clip</name></name><argument_list>(<argument><expr><name>clip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Paint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ShadowFinalize</name><argument_list>(<argument><expr><name>blur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetPattern</name></name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Clip</name></name><argument_list>(<argument><expr><name>clip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>dirty</name> = <call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><name>clip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>globalAlpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>1</expr></cpp:if>
    <comment type="line">// XXX cairo bug workaround; force a clip update on mThebes.</comment>
    <comment type="line">// Otherwise, a pixman clip gets left around somewhere, and pixman</comment>
    <comment type="line">// (Render) does source clipping as well -- so we end up</comment>
    <comment type="line">// compositing with an incorrect clip.  This only seems to affect</comment>
    <comment type="line">// fallback cases, which happen when we have CSS scaling going on.</comment>
    <comment type="line">// This will blow away the current path, but we already blew it</comment>
    <comment type="line">// away in this function earlier.</comment>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>UpdateSurfaceClip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>FINISH</name>:</label>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>rv</name> = <call><name>Redraw</name><argument_list>(<argument><expr><name>dirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetGlobalCompositeOperation</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsOperator</name></name></type> <name>thebes_op</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CANVAS_OP_TO_THEBES_OP</name><parameter_list>(<param><type><name>cvsop</name></type></param>,<param><type><name>thebesop</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>if (op.EqualsLiteral(cvsop))   \
        thebes_op = gfxContext::OPERATOR_##thebesop;</cpp:value></cpp:define>

    <comment type="line">// XXX "darker" isn't really correct</comment>
    <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"clear"</argument>, <argument>CLEAR</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"copy"</argument>, <argument>SOURCE</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"darker"</argument>, <argument>SATURATE</argument>)</argument_list></macro>  <comment type="line">// XXX</comment>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-atop"</argument>, <argument>DEST_ATOP</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-in"</argument>, <argument>DEST_IN</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-out"</argument>, <argument>DEST_OUT</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-over"</argument>, <argument>DEST_OVER</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"lighter"</argument>, <argument>ADD</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-atop"</argument>, <argument>ATOP</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-in"</argument>, <argument>IN</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-out"</argument>, <argument>OUT</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-over"</argument>, <argument>OVER</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"xor"</argument>, <argument>XOR</argument>)</argument_list></macro>
    <comment type="line">// not part of spec, kept here for compat</comment>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"over"</argument>, <argument>OVER</argument>)</argument_list></macro>
    <else>else <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return></else>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CANVAS_OP_TO_THEBES_OP</name></cpp:undef>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name>thebes_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else>
    <return>return <expr><name>NS_OK</name></expr>;</return></else></else></else></else></else></else></else></else></else></else></else></else>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetGlobalCompositeOperation</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>gfxContext</name>::<name>GraphicsOperator</name></name></type> <name>thebes_op</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>CurrentOperator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CANVAS_OP_TO_THEBES_OP</name><parameter_list>(<param><type><name>cvsop</name></type></param>,<param><type><name>thebesop</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>if (thebes_op == gfxContext::OPERATOR_##thebesop) \
        op.AssignLiteral(cvsop);</cpp:value></cpp:define>

    <comment type="line">// XXX "darker" isn't really correct</comment>
    <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"clear"</argument>, <argument>CLEAR</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"copy"</argument>, <argument>SOURCE</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"darker"</argument>, <argument>SATURATE</argument>)</argument_list></macro>  <comment type="line">// XXX</comment>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-atop"</argument>, <argument>DEST_ATOP</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-in"</argument>, <argument>DEST_IN</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-out"</argument>, <argument>DEST_OUT</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"destination-over"</argument>, <argument>DEST_OVER</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"lighter"</argument>, <argument>ADD</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-atop"</argument>, <argument>ATOP</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-in"</argument>, <argument>IN</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-out"</argument>, <argument>OUT</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"source-over"</argument>, <argument>OVER</argument>)</argument_list></macro>
    <else>else <macro><name>CANVAS_OP_TO_THEBES_OP</name><argument_list>(<argument>"xor"</argument>, <argument>XOR</argument>)</argument_list></macro>
    <else>else <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></else>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CANVAS_OP_TO_THEBES_OP</name></cpp:undef>

    <return>return <expr><name>NS_OK</name></expr>;</return></else></else></else></else></else></else></else></else></else></else></else></else>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>FlushLayoutForTree</name><parameter_list>(<param><decl><type><name>nsIDOMWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsPIDOMWindow</name></expr></argument>&gt;</argument_list></name></type> <name>piWin</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>piWin</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <comment type="line">// Note that because FlushPendingNotifications flushes parents, this</comment>
    <comment type="line">// is O(N^2) in docshell tree depth.  However, the docshell tree is</comment>
    <comment type="line">// usually pretty shallow.</comment>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>domDoc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>GetDocument</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocument</name></expr></argument>&gt;</argument_list></name></type> <name>doc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>doc</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>doc</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShellTreeNode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name> <init>=
        <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>piWin</name>-&gt;<name>GetDocShell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>node</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>i_end</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>node</name>-&gt;<name>GetChildCount</name></name><argument_list>(<argument><expr>&amp;<name>i_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>i_end</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShellTreeItem</name></expr></argument>&gt;</argument_list></name></type> <name>item</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>node</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMWindow</name></expr></argument>&gt;</argument_list></name></type> <name>win</name> <init>= <expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>win</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>FlushLayoutForTree</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>DrawWindow</name></name><parameter_list>(<param><decl><type><name>nsIDOMWindow</name>*</type> <name>aWindow</name></decl></param>, <param><decl><type><name>float</name></type> <name>aX</name></decl></param>, <param><decl><type><name>float</name></type> <name>aY</name></decl></param>,
                                       <param><decl><type><name>float</name></type> <name>aW</name></decl></param>, <param><decl><type><name>float</name></type> <name>aH</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aBGColor</name></decl></param>,
                                       <param><decl><type><name>PRUint32</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG</name><argument_list>(<argument><expr><name>aWindow</name> != <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// protect against too-large surfaces that will cause allocation</comment>
    <comment type="line">// or overflow issues</comment>
    <if>if <condition>(<expr>!<call><name><name>gfxASurface</name>::<name>CheckSurfaceSize</name></name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><call><name>PRInt32</name><argument_list>(<argument><expr><name>aW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PRInt32</name><argument_list>(<argument><expr><name>aH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr>0xffff</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <comment type="line">// We can't allow web apps to call this until we fix at least the</comment>
    <comment type="line">// following potential security issues:</comment>
    <comment type="line">// -- rendering cross-domain IFRAMEs and then extracting the results</comment>
    <comment type="line">// -- rendering the user's theme and then extracting the results</comment>
    <comment type="line">// -- rendering native anonymous content (e.g., file input paths;</comment>
    <comment type="line">// scrollbars should be allowed)</comment>
    <if>if <condition>(<expr>!<call><name><name>nsContentUtils</name>::<name>IsCallerTrustedForRead</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// not permitted to use DrawWindow</comment>
      <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <return>return <expr><name>NS_ERROR_DOM_SECURITY_ERR</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Flush layout updates</comment>
    <if>if <condition>(<expr>!(<name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_DO_NOT_FLUSH</name></name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>FlushLayoutForTree</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type> <name>presContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsPIDOMWindow</name></expr></argument>&gt;</argument_list></name></type> <name>win</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>win</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsIDocShell</name>*</type> <name>docshell</name> <init>= <expr><call><name><name>win</name>-&gt;<name>GetDocShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>docshell</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>docshell</name>-&gt;<name>GetPresContext</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>presContext</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nscolor</name></type> <name>bgColor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSParser</name></type> <name>parser</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>parser</name>.<name>ParseColorString</name></name><argument_list>(<argument><expr><call><name>PromiseFlatString</name><argument_list>(<argument><expr><name>aBGColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>bgColor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsIPresShell</name>*</type> <name>presShell</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>presShell</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsRect</name></type> <name>r</name><argument_list>(<argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aX</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aY</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aW</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>renderDocFlags</name> <init>= <expr><name><name>nsIPresShell</name>::<name>RENDER_IGNORE_VIEWPORT_SCROLLING</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_DRAW_CARET</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>renderDocFlags</name> |= <name><name>nsIPresShell</name>::<name>RENDER_CARET</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_DRAW_VIEW</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>renderDocFlags</name> &amp;= ~<name><name>nsIPresShell</name>::<name>RENDER_IGNORE_VIEWPORT_SCROLLING</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_USE_WIDGET_LAYERS</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>renderDocFlags</name> |= <name><name>nsIPresShell</name>::<name>RENDER_USE_WIDGET_LAYERS</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>presShell</name>-&gt;<name>RenderDocument</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>renderDocFlags</name></expr></argument>, <argument><expr><name>bgColor</name></expr></argument>, <argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// get rid of the pattern surface ref, just in case</comment>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><call><name>gfxRGBA</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// note that aX and aY are coordinates in the document that</comment>
    <comment type="line">// we're drawing; aX and aY are drawn to 0,0 in current user</comment>
    <comment type="line">// space.</comment>
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>damageRect</name> <init>= <expr><call><name><name>mThebes</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aW</name></expr></argument>, <argument><expr><name>aH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Redraw</name><argument_list>(<argument><expr><name>damageRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>AsyncDrawXULElement</name></name><parameter_list>(<param><decl><type><name>nsIDOMXULElement</name>*</type> <name>aElem</name></decl></param>, <param><decl><type><name>float</name></type> <name>aX</name></decl></param>, <param><decl><type><name>float</name></type> <name>aY</name></decl></param>,
                                                <param><decl><type><name>float</name></type> <name>aW</name></decl></param>, <param><decl><type><name>float</name></type> <name>aH</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aBGColor</name></decl></param>,
                                                <param><decl><type><name>PRUint32</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG</name><argument_list>(<argument><expr><name>aElem</name> != <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We can't allow web apps to call this until we fix at least the</comment>
    <comment type="line">// following potential security issues:</comment>
    <comment type="line">// -- rendering cross-domain IFRAMEs and then extracting the results</comment>
    <comment type="line">// -- rendering the user's theme and then extracting the results</comment>
    <comment type="line">// -- rendering native anonymous content (e.g., file input paths;</comment>
    <comment type="line">// scrollbars should be allowed)</comment>
    <if>if <condition>(<expr>!<call><name><name>nsContentUtils</name>::<name>IsCallerTrustedForRead</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// not permitted to use DrawWindow</comment>
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <return>return <expr><name>NS_ERROR_DOM_SECURITY_ERR</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFrameLoaderOwner</name></expr></argument>&gt;</argument_list></name></type> <name>loaderOwner</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>loaderOwner</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsFrameLoader</name></expr></argument>&gt;</argument_list></name></type> <name>frameloader</name> <init>= <expr><call><name><name>loaderOwner</name>-&gt;<name>GetFrameLoader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>frameloader</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>mozilla</name>::<name>dom</name>::<name>PIFrameEmbeddingParent</name></name> *</type><name>child</name> <init>= <expr><call><name><name>frameloader</name>-&gt;<name>GetChildProcess</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>child</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMWindow</name></expr></argument>&gt;</argument_list></name></type> <name>window</name> <init>=
            <expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><call><name><name>frameloader</name>-&gt;<name>GetExistingDocShell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>window</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <return>return <expr><call><name>DrawWindow</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr><name>aW</name></expr></argument>, <argument><expr><name>aH</name></expr></argument>, <argument><expr><name>aBGColor</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="line">// protect against too-large surfaces that will cause allocation</comment>
    <comment type="line">// or overflow issues</comment>
    <if>if <condition>(<expr>!<call><name><name>gfxASurface</name>::<name>CheckSurfaceSize</name></name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>aW</name></expr></argument>, <argument><expr><name>aH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0xffff</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>flush</name> <init>=
        <expr>(<name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_DO_NOT_FLUSH</name></name>) == 0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>renderDocFlags</name> <init>= <expr><name><name>nsIPresShell</name>::<name>RENDER_IGNORE_VIEWPORT_SCROLLING</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_DRAW_CARET</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>renderDocFlags</name> |= <name><name>nsIPresShell</name>::<name>RENDER_CARET</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>flags</name> &amp; <name><name>nsIDOMCanvasRenderingContext2D</name>::<name>DRAWWINDOW_DRAW_VIEW</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>renderDocFlags</name> &amp;= ~<name><name>nsIPresShell</name>::<name>RENDER_IGNORE_VIEWPORT_SCROLLING</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>x</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aX</name></expr></argument>)</argument_list></call></expr></init>,
            <name>y</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aY</name></expr></argument>)</argument_list></call></expr></init>,
            <name>w</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aW</name></expr></argument>)</argument_list></call></expr></init>,
            <name>h</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>aH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mShmem</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name><name>mBackBuffer</name>.<name>IsWritable</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>PDocumentRendererShmemParent</name></name> *</type><name>pdocrender</name> <init>=
            <expr><call><name><name>child</name>-&gt;<name>SendPDocumentRendererShmemConstructor</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>,
                                                         <argument><expr><call><name>nsString</name><argument_list>(<argument><expr><name>aBGColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                                         <argument><expr><name>renderDocFlags</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>,
                                                         <argument><expr><call><name><name>mThebes</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                         <argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>,
                                                         <argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>pdocrender</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>DocumentRendererShmemParent</name></name> *</type><name>docrender</name> <init>= 
            <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name><name>mozilla</name>::<name>ipc</name>::<name>DocumentRendererShmemParent</name></name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>pdocrender</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>docrender</name>-&gt;<name>SetCanvas</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>PDocumentRendererParent</name></name> *</type><name>pdocrender</name> <init>=
            <expr><call><name><name>child</name>-&gt;<name>SendPDocumentRendererConstructor</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>,
                                                    <argument><expr><call><name>nsString</name><argument_list>(<argument><expr><name>aBGColor</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><name>renderDocFlags</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>pdocrender</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>mozilla</name>::<name>ipc</name>::<name>DocumentRendererParent</name></name> *</type><name>docrender</name> <init>=
            <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name><name>mozilla</name>::<name>ipc</name>::<name>DocumentRendererParent</name></name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>pdocrender</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>docrender</name>-&gt;<name>SetCanvasContext</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mThebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMWindow</name></expr></argument>&gt;</argument_list></name></type> <name>window</name> <init>=
        <expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><call><name><name>frameloader</name>-&gt;<name>GetExistingDocShell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>window</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <return>return <expr><call><name>DrawWindow</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr><name>aW</name></expr></argument>, <argument><expr><name>aH</name></expr></argument>, <argument><expr><name>aBGColor</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// device pixel getting/setting</comment>
<comment type="line">//</comment>
<extern>extern "C" <block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSBool</argument>)</argument_list></macro>
<macro><name>js_CoerceArrayToCanvasImageData</name><argument_list>(<argument>JSObject *obj</argument>, <argument>jsuint offset</argument>, <argument>jsuint count</argument>,
                                <argument>JSUint8 *dest</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSObject *</argument>)</argument_list></macro>
<macro><name>js_NewArrayObjectWithCapacity</name><argument_list>(<argument>JSContext *cx</argument>, <argument>jsuint capacity</argument>, <argument>jsval **vector</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
}</block></extern>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>EnsureUnpremultiplyTable</name></name><parameter_list>()</parameter_list> <block>{
  <if>if <condition>(<expr><name>sUnpremultiplyTable</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// Infallably alloc the unpremultiply table.</comment>
  <expr_stmt><expr><name>sUnpremultiplyTable</name> = new <name><name>PRUint8</name><index>[<expr>256</expr>]</index><index>[<expr>256</expr>]</index></name></expr>;</expr_stmt>

  <comment type="line">// It's important that the array be indexed first by alpha and then by rgb</comment>
  <comment type="line">// value.  When we unpremultiply a pixel, we're guaranteed to do three</comment>
  <comment type="line">// lookups with the same alpha; indexing by alpha first makes it likely that</comment>
  <comment type="line">// those three lookups will be close to one another in memory, thus</comment>
  <comment type="line">// increasing the chance of a cache hit.</comment>

  <comment type="line">// a == 0 case</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>c</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt;= 255</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>sUnpremultiplyTable</name><index>[<expr>0</expr>]</index><index>[<expr><name>c</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
  }</block></for>

  <for>for (<init><decl><type><name>int</name></type> <name>a</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>a</name> &lt;= 255</expr>;</condition> <incr><expr><name>a</name>++</expr></incr>) <block>{
    <for>for (<init><decl><type><name>int</name></type> <name>c</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt;= 255</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name><name>sUnpremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>c</name></expr>]</index></name> = <call>(<name>PRUint8</name>)<argument_list>(<argument><expr>(<name>c</name> * 255) / <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></for>
}</block></function>


<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetImageData</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* Should never be called -- GetImageData_explicit is the QS entry point */</comment>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetImageData_explicit</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>x</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>y</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>w</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>h</name></decl></param>,
                                                  <param><decl><type><name>PRUint8</name> *</type><name>aData</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aDataLen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mValid</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>mCanvasElement</name> &amp;&amp; <call><name><name>mCanvasElement</name>-&gt;<name>IsWriteOnly</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>nsContentUtils</name>::<name>IsCallerTrustedForRead</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// XXX ERRMSG we need to report an error to developers here! (bug 329026)</comment>
        <return>return <expr><name>NS_ERROR_DOM_SECURITY_ERR</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>CanvasUtils</name>::<name>CheckSaneSubrectSize</name></name> <argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><name>w</name> * <name>h</name> * 4</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aDataLen</name> != <name>len</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <comment type="block">/* Copy the surface contents to the buffer */</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmpsurf</name> <init>= <expr>new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><name>aData</name></expr></argument>,
                                                            <argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>,
                                                            <argument><expr><name>w</name> * 4</expr></argument>,
                                                            <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>tmpsurf</name> || <call><name><name>tmpsurf</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmpctx</name> <init>= <expr>new <call><name>gfxContext</name><argument_list>(<argument><expr><name>tmpsurf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>tmpctx</name> || <call><name><name>tmpctx</name>-&gt;<name>HasError</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>tmpctx</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tmpctx</name>-&gt;<name>SetSource</name></name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr>-(<name>int</name>)<name>x</name></expr></argument>, <argument><expr>-(<name>int</name>)<name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tmpctx</name>-&gt;<name>Paint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// make sure sUnpremultiplyTable has been created</comment>
    <expr_stmt><expr><call><name>EnsureUnpremultiplyTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// NOTE! dst is the same as src, and this relies on reading</comment>
    <comment type="line">// from src and advancing that ptr before writing to dst.</comment>
    <decl_stmt><decl><type><name>PRUint8</name> *</type><name>src</name> <init>= <expr><name>aData</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint8</name> *</type><name>dst</name> <init>= <expr><name>aData</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>h</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>w</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <comment type="line">// XXX Is there some useful swizzle MMX we can use here?</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IS_LITTLE_ENDIAN</name></cpp:ifdef>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>b</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>g</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>r</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>a</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>a</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>r</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>g</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>b</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="line">// Convert to non-premultiplied color</comment>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sUnpremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>r</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sUnpremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>g</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sUnpremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>b</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name>a</name></expr>;</expr_stmt>
        }</block></for>
    }</block></for>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>EnsurePremultiplyTable</name></name><parameter_list>()</parameter_list> <block>{
  <if>if <condition>(<expr><name>sPremultiplyTable</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// Infallably alloc the premultiply table.</comment>
  <expr_stmt><expr><name>sPremultiplyTable</name> = new <name><name>PRUint8</name><index>[<expr>256</expr>]</index><index>[<expr>256</expr>]</index></name></expr>;</expr_stmt>

  <comment type="line">// Like the unpremultiply table, it's important that we index the premultiply</comment>
  <comment type="line">// table with the alpha value as the first index to ensure good cache</comment>
  <comment type="line">// performance.</comment>

  <for>for (<init><decl><type><name>int</name></type> <name>a</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>a</name> &lt;= 255</expr>;</condition> <incr><expr><name>a</name>++</expr></incr>) <block>{
    <for>for (<init><decl><type><name>int</name></type> <name>c</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>c</name> &lt;= 255</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>c</name></expr>]</index></name> = (<name>a</name> * <name>c</name> + 254) / 255</expr>;</expr_stmt>
    }</block></for>
  }</block></for>
}</block></function>

<comment type="line">// void putImageData (in ImageData d, in float x, in float y);</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>PutImageData</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* Should never be called -- PutImageData_explicit is the QS entry point */</comment>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>PutImageData_explicit</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>x</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>y</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>w</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>h</name></decl></param>,
                                                  <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>aData</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aDataLen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mValid</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name><name>CanvasUtils</name>::<name>CheckSaneSubrectSize</name></name> <argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>mWidth</name></expr></argument>, <argument><expr><name>mHeight</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><name>w</name> * <name>h</name> * 4</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aDataLen</name> != <name>len</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>imgsurf</name> <init>= <expr>new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>,
                                                            <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>imgsurf</name> || <call><name><name>imgsurf</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <comment type="line">// ensure premultiply table has been created</comment>
    <expr_stmt><expr><call><name>EnsurePremultiplyTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint8</name> *</type><name>src</name> <init>= <expr><name>aData</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint8</name> *</type><name>dst</name> <init>= <expr><call><name><name>imgsurf</name>-&gt;<name>Data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>h</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
        <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>w</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>r</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>g</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>b</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PRUint8</name></type> <name>a</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>

            <comment type="line">// Convert to premultiplied color (losslessly if the input came from getImageData)</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IS_LITTLE_ENDIAN</name></cpp:ifdef>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>b</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>g</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>r</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name>a</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr>*<name>dst</name>++ = <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>r</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>g</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>dst</name>++ = <name><name>sPremultiplyTable</name><index>[<expr><name>a</name></expr>]</index><index>[<expr><name>b</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></for>
    }</block></for>

    <function_decl><type><name>gfxContextPathAutoSaveRestore</name></type> <name>pathSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>gfxContextAutoSaveRestore</name></type> <name>autoSR</name><parameter_list>(<param><decl><type><name>mThebes</name></type></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// ignore clipping region, as per spec</comment>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>ResetClip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetSource</name></name><argument_list>(<argument><expr><name>imgsurf</name></expr></argument>, <argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mThebes</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>Redraw</name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetThebesSurface</name></name><parameter_list>(<param><decl><type><name>gfxASurface</name> **</type><name>surface</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mSurface</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>surface</name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>surface</name> = <call><name><name>mSurface</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>CreateImageData</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* Should never be called; handled entirely in the quickstub */</comment>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>GetMozImageSmoothingEnabled</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>retVal</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>retVal</name> = <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>imageSmoothingEnabled</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasRenderingContext2D</name>::<name>SetMozImageSmoothingEnabled</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>val</name> != <call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>imageSmoothingEnabled</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CurrentState</name><argument_list>()</argument_list></call>.<name>imageSmoothingEnabled</name> = <name>val</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DirtyAllStyles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
</unit>
