<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00310b9bd3aff1ce4c265e7d53c455d036d129fb.c"><comment type="block">/* cairo - a vector graphics library with display and print output
 *
 * Copyright Â© 2004 Red Hat, Inc.
 * Copyright Â© 2005 Red Hat, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it either under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation
 * (the "LGPL") or, at your option, under the terms of the Mozilla
 * Public License Version 1.1 (the "MPL"). If you do not alter this
 * notice, a recipient may use your version of this file under either
 * the MPL or the LGPL.
 *
 * You should have received a copy of the LGPL along with this library
 * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * You should have received a copy of the MPL along with this library
 * in the file COPYING-MPL-1.1
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
 * OF ANY KIND, either express or implied. See the LGPL or the MPL for
 * the specific language governing rights and limitations.
 *
 * The Original Code is the cairo graphics library.
 *
 * The Initial Developer of the Original Code is Red Hat, Inc.
 *
 * Contributor(s):
 *      Keith Packard &lt;keithp@keithp.com&gt;
 *	Graydon Hoare &lt;graydon@redhat.com&gt;
 *	Carl Worth &lt;cworth@cworth.org&gt;
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cairoint.h"</cpp:file></cpp:include>

<comment type="block">/*
 * An entry can be in one of three states:
 *
 * FREE: Entry has never been used, terminates all searches.
 *       Appears in the table as a %NULL pointer.
 *
 * DEAD: Entry had been live in the past. A dead entry can be reused
 *       but does not terminate a search for an exact entry.
 *       Appears in the table as a pointer to DEAD_ENTRY.
 *
 * LIVE: Entry is currently being used.
 *       Appears in the table as any non-%NULL, non-DEAD_ENTRY pointer.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>cairo_hash_entry_t</name></type> <name>dead_entry</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEAD_ENTRY</name></cpp:macro> <cpp:value>(&amp;dead_entry)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTRY_IS_FREE</name><parameter_list>(<param><type><name>entry</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((entry) == NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTRY_IS_DEAD</name><parameter_list>(<param><type><name>entry</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((entry) == DEAD_ENTRY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTRY_IS_LIVE</name><parameter_list>(<param><type><name>entry</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((entry) &amp;&amp; ! ENTRY_IS_DEAD(entry))</cpp:value></cpp:define>

<comment type="block">/* We expect keys will not be destroyed frequently, so our table does not
 * contain any explicit shrinking code nor any chain-coalescing code for
 * entries randomly deleted by memory pressure (except during rehashing, of
 * course). These assumptions are potentially bad, but they make the
 * implementation straightforward.
 *
 * Revisit later if evidence appears that we're using excessive memory from
 * a mostly-dead table.
 *
 * This table is open-addressed with double hashing. Each table size is a
 * prime chosen to be a little more than double the high water mark for a
 * given arrangement, so the tables should remain &lt; 50% full. The table
 * size makes for the "first" hash modulus; a second prime (2 less than the
 * first prime) serves as the "second" hash modulus, which is co-prime and
 * thus guarantees a complete permutation of table indices.
 *
 * This structure, and accompanying table, is borrowed/modified from the
 * file xserver/render/glyph.c in the freedesktop.org x server, with
 * permission (and suggested modification of doubling sizes) by Keith
 * Packard.
 */</comment>

<typedef>typedef <type><struct>struct <name>_cairo_hash_table_arrangement</name> <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>high_water_mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rehash</name></decl>;</decl_stmt>
}</block></struct></type> <name>cairo_hash_table_arrangement_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>cairo_hash_table_arrangement_t</name></type> <name><name>hash_table_arrangements</name> <index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr>16</expr>,		<expr>43</expr>,		<expr>41</expr>		}</block></expr>,
    <expr><block>{ <expr>32</expr>,		<expr>73</expr>,		<expr>71</expr>		}</block></expr>,
    <expr><block>{ <expr>64</expr>,		<expr>151</expr>,		<expr>149</expr>		}</block></expr>,
    <expr><block>{ <expr>128</expr>,		<expr>283</expr>,		<expr>281</expr>		}</block></expr>,
    <expr><block>{ <expr>256</expr>,		<expr>571</expr>,		<expr>569</expr>		}</block></expr>,
    <expr><block>{ <expr>512</expr>,		<expr>1153</expr>,		<expr>1151</expr>		}</block></expr>,
    <expr><block>{ <expr>1024</expr>,		<expr>2269</expr>,		<expr>2267</expr>		}</block></expr>,
    <expr><block>{ <expr>2048</expr>,		<expr>4519</expr>,		<expr>4517</expr>		}</block></expr>,
    <expr><block>{ <expr>4096</expr>,		<expr>9013</expr>,		<expr>9011</expr>		}</block></expr>,
    <expr><block>{ <expr>8192</expr>,		<expr>18043</expr>,		<expr>18041</expr>		}</block></expr>,
    <expr><block>{ <expr>16384</expr>,		<expr>36109</expr>,		<expr>36107</expr>		}</block></expr>,
    <expr><block>{ <expr>32768</expr>,		<expr>72091</expr>,		<expr>72089</expr>		}</block></expr>,
    <expr><block>{ <expr>65536</expr>,		<expr>144409</expr>,		<expr>144407</expr>		}</block></expr>,
    <expr><block>{ <expr>131072</expr>,		<expr>288361</expr>,		<expr>288359</expr>		}</block></expr>,
    <expr><block>{ <expr>262144</expr>,		<expr>576883</expr>,		<expr>576881</expr>		}</block></expr>,
    <expr><block>{ <expr>524288</expr>,		<expr>1153459</expr>,	<expr>1153457</expr>		}</block></expr>,
    <expr><block>{ <expr>1048576</expr>,		<expr>2307163</expr>,	<expr>2307161</expr>		}</block></expr>,
    <expr><block>{ <expr>2097152</expr>,		<expr>4613893</expr>,	<expr>4613891</expr>		}</block></expr>,
    <expr><block>{ <expr>4194304</expr>,		<expr>9227641</expr>,	<expr>9227639</expr>		}</block></expr>,
    <expr><block>{ <expr>8388608</expr>,		<expr>18455029</expr>,	<expr>18455027</expr>	}</block></expr>,
    <expr><block>{ <expr>16777216</expr>,		<expr>36911011</expr>,	<expr>36911009</expr>	}</block></expr>,
    <expr><block>{ <expr>33554432</expr>,		<expr>73819861</expr>,	<expr>73819859</expr> 	}</block></expr>,
    <expr><block>{ <expr>67108864</expr>,		<expr>147639589</expr>,	<expr>147639587</expr>	}</block></expr>,
    <expr><block>{ <expr>134217728</expr>,	<expr>295279081</expr>,	<expr>295279079</expr>	}</block></expr>,
    <expr><block>{ <expr>268435456</expr>,	<expr>590559793</expr>,	<expr>590559791</expr>	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_HASH_TABLE_ARRANGEMENTS</name></cpp:macro> <cpp:value>ARRAY_LENGTH (hash_table_arrangements)</cpp:value></cpp:define>

<struct>struct <name>_cairo_hash_table</name> <block>{
    <decl_stmt><decl><type><name>cairo_hash_keys_equal_func_t</name></type> <name>keys_equal</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>cairo_hash_table_arrangement_t</name> *</type><name>arrangement</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entries</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>live_entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>iterating</name></decl>;</decl_stmt>   <comment type="block">/* Iterating, no insert, no resize */</comment>
}</block>;</struct>

<comment type="block">/**
 * _cairo_hash_table_create:
 * @keys_equal: a function to return %TRUE if two keys are equal
 *
 * Creates a new hash table which will use the keys_equal() function
 * to compare hash keys. Data is provided to the hash table in the
 * form of user-derived versions of #cairo_hash_entry_t. A hash entry
 * must be able to hold both a key (including a hash code) and a
 * value. Sometimes only the key will be necessary, (as in
 * _cairo_hash_table_remove), and other times both a key and a value
 * will be necessary, (as in _cairo_hash_table_insert).
 *
 * See #cairo_hash_entry_t for more details.
 *
 * Return value: the new hash table or %NULL if out of memory.
 **/</comment>
<function><type><name>cairo_hash_table_t</name> *</type>
<name>_cairo_hash_table_create</name> <parameter_list>(<param><decl><type><name>cairo_hash_keys_equal_func_t</name></type> <name>keys_equal</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hash_table</name> = <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cairo_hash_table_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hash_table</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>_cairo_error_throw</name> <argument_list>(<argument><expr><name>CAIRO_STATUS_NO_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>keys_equal</name></name> = <name>keys_equal</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>arrangement</name></name> = &amp;<name><name>hash_table_arrangements</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>entries</name></name> = <call><name>calloc</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>size</name></name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cairo_hash_entry_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>hash_table</name>-&gt;<name>entries</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>_cairo_error_throw</name> <argument_list>(<argument><expr><name>CAIRO_STATUS_NO_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>iterating</name></name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>hash_table</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_destroy:
 * @hash_table: an empty hash table to destroy
 *
 * Immediately destroys the given hash table, freeing all resources
 * associated with it.
 *
 * WARNING: The hash_table must have no live entries in it before
 * _cairo_hash_table_destroy is called. It is a fatal error otherwise,
 * and this function will halt. The rationale for this behavior is to
 * avoid memory leaks and to avoid needless complication of the API
 * with destroy notifiy callbacks.
 *
 * WARNING: The hash_table must have no running iterators in it when
 * _cairo_hash_table_destroy is called. It is a fatal error otherwise,
 * and this function will halt.
 **/</comment>
<function><type><name>void</name></type>
<name>_cairo_hash_table_destroy</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>hash_table</name> == <name>NULL</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <comment type="block">/* The hash table must be empty. Otherwise, halt. */</comment>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* No iterators can be running. Otherwise, halt. */</comment>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>iterating</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>entries</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_lookup_internal:
 *
 * @hash_table: a #cairo_hash_table_t to search
 * @key: the key to search on
 * @hash_code: the hash_code for @key
 * @key_unique: If %TRUE, then caller asserts that no key already
 * exists that will compare equal to #key, so search can be
 * optimized. If unsure, set to %FALSE and the code will always work.
 *
 * Search the hashtable for a live entry for which
 * hash_table-&gt;keys_equal returns true. If no such entry exists then
 * return the first available (free or dead entry).
 *
 * If the key_unique flag is set, then the search will never call
 * hash_table-&gt;keys_equal and will act as if it always returned
 * false. This is useful as a performance optimization in special
 * circumstances where the caller knows that there is no existing
 * entry in the hash table with a matching key.
 *
 * Return value: The matching entry in the hash table (if
 * any). Otherwise, the first available entry. The caller should check
 * entry-&gt;state to check whether a match was found or not.
 **/</comment>
<function><type><specifier>static</specifier> <name>cairo_hash_entry_t</name> **</type>
<name>_cairo_hash_table_lookup_internal</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl></param>,
				   <param><decl><type><name>cairo_hash_entry_t</name> *</type><name>key</name></decl></param>,
				   <param><decl><type><name>cairo_bool_t</name></type>	       <name>key_is_unique</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry</name></decl>, **<decl><type ref="prev"/><name>first_available</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>step</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>table_size</name> = <name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>size</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>idx</name> = <name><name>key</name>-&gt;<name>hash</name></name> % <name>table_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>table_size</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
	<expr_stmt><expr><name>entry</name> = &amp;<name><name>hash_table</name>-&gt;<name>entries</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>ENTRY_IS_FREE</name><argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
	    <return>return <expr><name>entry</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>ENTRY_IS_DEAD</name><argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<block>{
	    <if>if <condition>(<expr><name>key_is_unique</name></expr>)</condition><then> <block>{
		<return>return <expr><name>entry</name></expr>;</return>
	    }</block></then> <else>else <block>{
		<if>if <condition>(<expr>! <name>first_available</name></expr>)</condition><then>
		    <expr_stmt><expr><name>first_available</name> = <name>entry</name></expr>;</expr_stmt></then></if>
	    }</block></else></if>
	}</block></then>
	<else>else <comment type="block">/* ENTRY_IS_LIVE(*entry) */</comment>
	<block>{
	    <if>if <condition>(<expr>! <name>key_is_unique</name></expr>)</condition><then>
		<if>if <condition>(<expr><call><name><name>hash_table</name>-&gt;<name>keys_equal</name></name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <return>return <expr><name>entry</name></expr>;</return></then></if></then></if>
	}</block></else></if></else></if>

	<if>if <condition>(<expr><name>step</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>step</name> = <name><name>key</name>-&gt;<name>hash</name></name> % <name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>rehash</name></name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>step</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>step</name> = 1</expr>;</expr_stmt></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>idx</name> += <name>step</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>idx</name> &gt;= <name>table_size</name></expr>)</condition><then>
	    <expr_stmt><expr><name>idx</name> -= <name>table_size</name></expr>;</expr_stmt></then></if>
    }</block></for>

    <comment type="block">/*
     * The table should not have permitted you to get here if you were just
     * looking for a free slot: there should have been room.
     */</comment>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>key_is_unique</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>first_available</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_resize:
 * @hash_table: a hash table
 *
 * Resize the hash table if the number of entries has gotten much
 * bigger or smaller than the ideal number of entries for the current
 * size.
 *
 * Return value: %CAIRO_STATUS_SUCCESS if successful or
 * %CAIRO_STATUS_NO_MEMORY if out of memory.
 **/</comment>
<function><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_hash_table_resize</name>  <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_hash_table_t</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>new_size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <comment type="block">/* This keeps the hash table between 25% and 50% full. */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>high</name> <init>= <expr><name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>high_water_mark</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>low</name> <init>= <expr><name>high</name> &gt;&gt; 2</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name> &gt;= <name>low</name> &amp;&amp; <name><name>hash_table</name>-&gt;<name>live_entries</name></name> &lt;= <name>high</name></expr>)</condition><then>
	<return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return></then></if>

    <expr_stmt><expr><name>tmp</name> = *<name>hash_table</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name> &gt; <name>high</name></expr>)</condition><then>
    <block>{
	<expr_stmt><expr><name><name>tmp</name>.<name>arrangement</name></name> = <name><name>hash_table</name>-&gt;<name>arrangement</name></name> + 1</expr>;</expr_stmt>
	<comment type="block">/* This code is being abused if we can't make a table big enough. */</comment>
	<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>tmp</name>.<name>arrangement</name></name> - <name>hash_table_arrangements</name> &lt;
		<name>NUM_HASH_TABLE_ARRANGEMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <comment type="block">/* hash_table-&gt;live_entries &lt; low */</comment>
    <block>{
	<comment type="block">/* Can't shrink if we're at the smallest size */</comment>
	<if>if <condition>(<expr><name><name>hash_table</name>-&gt;<name>arrangement</name></name> == &amp;<name><name>hash_table_arrangements</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
	    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>tmp</name>.<name>arrangement</name></name> = <name><name>hash_table</name>-&gt;<name>arrangement</name></name> - 1</expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>new_size</name> = <name><name>tmp</name>.<name>arrangement</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmp</name>.<name>entries</name></name> = <call><name>calloc</name> <argument_list>(<argument><expr><name>new_size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cairo_hash_entry_t</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>tmp</name>.<name>entries</name></name> == <name>NULL</name></expr>)</condition><then>
	<return>return <expr><call><name>_cairo_error</name> <argument_list>(<argument><expr><name>CAIRO_STATUS_NO_MEMORY</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
	<if>if <condition>(<expr><call><name>ENTRY_IS_LIVE</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>entry</name> = <call><name>_cairo_hash_table_lookup_internal</name> <argument_list>(<argument><expr>&amp;<name>tmp</name></expr></argument>,
						       <argument><expr><name><name>hash_table</name>-&gt;<name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						       <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><call><name>ENTRY_IS_FREE</name><argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr>*<name>entry</name> = <name><name>hash_table</name>-&gt;<name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	}</block></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>entries</name></name> = <name><name>tmp</name>.<name>entries</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>arrangement</name></name> = <name><name>tmp</name>.<name>arrangement</name></name></expr>;</expr_stmt>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_lookup:
 * @hash_table: a hash table
 * @key: the key of interest
 * @entry_return: pointer for return value.
 *
 * Performs a lookup in @hash_table looking for an entry which has a
 * key that matches @key, (as determined by the keys_equal() function
 * passed to _cairo_hash_table_create).
 *
 * Return value: %TRUE if there is an entry in the hash table that
 * matches the given key, (which will now be in *entry_return). %FALSE
 * otherwise, (in which case *entry_return will be %NULL).
 **/</comment>
<function><type><name>cairo_bool_t</name></type>
<name>_cairo_hash_table_lookup</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl></param>,
			  <param><decl><type><name>cairo_hash_entry_t</name> *</type><name>key</name></decl></param>,
			  <param><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry_return</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* See if we have an entry in the table already. */</comment>
    <expr_stmt><expr><name>entry</name> = <call><name>_cairo_hash_table_lookup_internal</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ENTRY_IS_LIVE</name><argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr>*<name>entry_return</name> = *<name>entry</name></expr>;</expr_stmt>
	<return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>entry_return</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_random_entry:
 * @hash_table: a hash table
 * @predicate: a predicate function, or %NULL for any entry.
 *
 * Find a random entry in the hash table satisfying the given
 * @predicate. A %NULL @predicate is taken as equivalent to a function
 * which always returns %TRUE, (eg. any entry in the table will do).
 *
 * We use the same algorithm as the lookup algorithm to walk over the
 * entries in the hash table in a pseudo-random order. Walking
 * linearly would favor entries following gaps in the hash table. We
 * could also call rand() repeatedly, which works well for almost-full
 * tables, but degrades when the table is almost empty, or predicate
 * returns %TRUE for most entries.
 *
 * Return value: a random live entry or %NULL if there are no entries
 * that match the given predicate. In particular, if predicate is
 * %NULL, a %NULL return value indicates that the table is empty.
 **/</comment>
<function><type><name>void</name> *</type>
<name>_cairo_hash_table_random_entry</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name>	   *</type><name>hash_table</name></decl></param>,
				<param><decl><type><name>cairo_hash_predicate_func_t</name></type> <name>predicate</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>step</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>table_size</name> = <name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>size</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>hash</name> = <call><name>rand</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> = <name>hash</name> % <name>table_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>table_size</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
	<expr_stmt><expr><name>entry</name> = &amp;<name><name>hash_table</name>-&gt;<name>entries</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>ENTRY_IS_LIVE</name> <argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call> &amp;&amp;
	    (<name>predicate</name> == <name>NULL</name> || <call><name>predicate</name> <argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
	<block>{
	    <return>return <expr>*<name>entry</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>step</name> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>step</name> = <name>hash</name> % <name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>rehash</name></name></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>step</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name>step</name> = 1</expr>;</expr_stmt></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>idx</name> += <name>step</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>idx</name> &gt;= <name>table_size</name></expr>)</condition><then>
	    <expr_stmt><expr><name>idx</name> -= <name>table_size</name></expr>;</expr_stmt></then></if>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_insert:
 * @hash_table: a hash table
 * @key_and_value: an entry to be inserted
 *
 * Insert the entry #key_and_value into the hash table.
 *
 * WARNING: It is a fatal error if an entry exists in the hash table
 * with a matching key, (this function will halt).
 *
 * WARNING: It is a fatal error to insert an element while
 * an iterator is running
 *
 * Instead of using insert to replace an entry, consider just editing
 * the entry obtained with _cairo_hash_table_lookup. Or if absolutely
 * necessary, use _cairo_hash_table_remove first.
 *
 * Return value: %CAIRO_STATUS_SUCCESS if successful or
 * %CAIRO_STATUS_NO_MEMORY if insufficient memory is available.
 **/</comment>
<function><type><name>cairo_status_t</name></type>
<name>_cairo_hash_table_insert</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl></param>,
			  <param><decl><type><name>cairo_hash_entry_t</name> *</type><name>key_and_value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry</name></decl>;</decl_stmt>

    <comment type="block">/* Insert is illegal while an iterator is running. */</comment>
    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>hash_table</name>-&gt;<name>iterating</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entry</name> = <call><name>_cairo_hash_table_lookup_internal</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>,
					       <argument><expr><name>key_and_value</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ENTRY_IS_LIVE</name><argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
	<comment type="block">/* User is being bad, let's crash. */</comment>
	<expr_stmt><expr><name>ASSERT_NOT_REACHED</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>*<name>entry</name> = <name>key_and_value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name>++</expr>;</expr_stmt>

    <expr_stmt><expr><name>status</name> = <call><name>_cairo_hash_table_resize</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name></expr>)</condition><then> <block>{
	<comment type="block">/* abort the insert... */</comment>
	<expr_stmt><expr>*<name>entry</name> = <name>DEAD_ENTRY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name>--</expr>;</expr_stmt>
	<return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_remove:
 * @hash_table: a hash table
 * @key: key of entry to be removed
 *
 * Remove an entry from the hash table which has a key that matches
 * @key, if any (as determined by the keys_equal() function passed to
 * _cairo_hash_table_create).
 *
 * Return value: %CAIRO_STATUS_SUCCESS if successful or
 * %CAIRO_STATUS_NO_MEMORY if out of memory.
 **/</comment>
<function><type><name>void</name></type>
<name>_cairo_hash_table_remove</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name> *</type><name>hash_table</name></decl></param>,
			  <param><decl><type><name>cairo_hash_entry_t</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> **</type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>entry</name> = <call><name>_cairo_hash_table_lookup_internal</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>! <call><name>ENTRY_IS_LIVE</name><argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	<return>return;</return></then></if>

    <expr_stmt><expr>*<name>entry</name> = <name>DEAD_ENTRY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_table</name>-&gt;<name>live_entries</name></name>--</expr>;</expr_stmt>

    <comment type="block">/* Check for table resize. Don't do this when iterating as this will
     * reorder elements of the table and cause the iteration to potentially
     * skip some elements. */</comment>
    <if>if <condition>(<expr><name><name>hash_table</name>-&gt;<name>iterating</name></name> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* This call _can_ fail, but only in failing to allocate new
	 * memory to shrink the hash table. It does leave the table in a
	 * consistent state, and we've already succeeded in removing the
	 * entry, so we don't examine the failure status of this call. */</comment>
	<expr_stmt><expr><call><name>_cairo_hash_table_resize</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/**
 * _cairo_hash_table_foreach:
 * @hash_table: a hash table
 * @hash_callback: function to be called for each live entry
 * @closure: additional argument to be passed to @hash_callback
 *
 * Call @hash_callback for each live entry in the hash table, in a
 * non-specified order.
 *
 * Entries in @hash_table may be removed by code executed from @hash_callback.
 *
 * Entries may not be inserted to @hash_table, nor may @hash_table
 * be destroyed by code executed from @hash_callback. The relevant
 * functions will halt in these cases.
 **/</comment>
<function><type><name>void</name></type>
<name>_cairo_hash_table_foreach</name> <parameter_list>(<param><decl><type><name>cairo_hash_table_t</name>	      *</type><name>hash_table</name></decl></param>,
			   <param><decl><type><name>cairo_hash_callback_func_t</name></type>  <name>hash_callback</name></decl></param>,
			   <param><decl><type><name>void</name>			      *</type><name>closure</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_hash_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>hash_table</name> == <name>NULL</name></expr>)</condition><then>
	<return>return;</return></then></if>

    <comment type="block">/* Mark the table for iteration */</comment>
    <expr_stmt><expr>++<name><name>hash_table</name>-&gt;<name>iterating</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>hash_table</name>-&gt;<name>arrangement</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><name>entry</name> = <name><name>hash_table</name>-&gt;<name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>ENTRY_IS_LIVE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
	    <expr_stmt><expr><call><name>hash_callback</name> <argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <comment type="block">/* If some elements were deleted during the iteration,
     * the table may need resizing. Just do this every time
     * as the check is inexpensive.
     */</comment>
    <if>if <condition>(<expr>--<name><name>hash_table</name>-&gt;<name>iterating</name></name> == 0</expr>)</condition><then> <block>{
	<comment type="block">/* Should we fail to shrink the hash table, it is left unaltered,
	 * and we don't need to propagate the error status. */</comment>
	<expr_stmt><expr><call><name>_cairo_hash_table_resize</name> <argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
</unit>
