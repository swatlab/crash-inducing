<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="006122199d7f0bedb273c7d5f206c8a8a2ddab10.h"><comment type="block">/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Corporation code.
 *
 * The Initial Developer of the Original Code is Mozilla Foundation.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Robert O'Callahan &lt;robert@ocallahan.org&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRAMELAYERBUILDER_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRAMELAYERBUILDER_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTHashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHashKeys.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFrame.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayListBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayItem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>gfxContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>mozilla</name> <block>{

<decl_stmt><decl><type><name>namespace</name></type> <name>layers</name> <block>{
<decl_stmt><decl><type><name>class</name></type> <name>Layer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ThebesLayer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LayerManager</name></decl>;</decl_stmt>
}</block></decl></decl_stmt>

<enum>enum <name>LayerState</name> <block>{
  <decl><name>LAYER_NONE</name></decl>,
  <decl><name>LAYER_INACTIVE</name></decl>,
  <decl><name>LAYER_ACTIVE</name></decl>
}</block>;</enum>

<comment type="block">/**
 * The FrameLayerBuilder belongs to an nsDisplayListBuilder and is
 * responsible for converting display lists into layer trees.
 * 
 * The most important API in this class is BuildContainerLayerFor. This
 * method takes a display list as input and constructs a ContainerLayer
 * with child layers that render the contents of the display list. It
 * also updates userdata for the retained layer manager, and
 * DisplayItemDataProperty data for frames, to record the relationship
 * between frames and layers.
 * 
 * That data enables us to retain layer trees. When constructing a
 * ContainerLayer, we first check to see if there's an existing
 * ContainerLayer for the same frame that can be recycled. If we recycle
 * it, we also try to reuse its existing ThebesLayer children to render
 * the display items without layers of their own. The idea is that by
 * recycling layers deterministically, we can ensure that when nothing
 * changes in a display list, we will reuse the existing layers without
 * changes.
 * 
 * We expose a GetLeafLayerFor method that can be called by display items
 * that make their own layers (e.g. canvas and video); this method
 * locates the last layer used to render the display item, if any, and
 * return it as a candidate for recycling.
 * 
 * FrameLayerBuilder sets up ThebesLayers so that 0,0 in the Thebes layer
 * corresponds to the (pixel-snapped) top-left of the aActiveScrolledRoot.
 * It sets up ContainerLayers so that 0,0 in the container layer
 * corresponds to the snapped top-left of the display list reference frame.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>FrameLayerBuilder</name> <block>{
<label><name>public</name>:</label>
  <typedef>typedef <expr_stmt><expr><name>layers</name>::<name>Layer</name> <name>Layer</name></expr>;</expr_stmt></typedef> 
  <typedef>typedef <expr_stmt><expr><name>layers</name>::<name>ThebesLayer</name> <name>ThebesLayer</name></expr>;</expr_stmt></typedef>
  <typedef>typedef <expr_stmt><expr><name>layers</name>::<name>LayerManager</name> <name>LayerManager</name></expr>;</expr_stmt></typedef>

  <expr_stmt><expr><call><name>FrameLayerBuilder</name><argument_list>()</argument_list></call> :
    <call><name>mRetainingManager</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>mInvalidateAllThebesContent</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>,
    <macro><name>mInvalidateAllLayers</name><argument_list>(<argument>PR_FALSE</argument>)</argument_list></macro>
  <expr><block>{
    <expr><call><name><name>mNewDisplayItemData</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;
    <expr><call><name><name>mThebesLayerItems</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;
  }</block>

  <comment type="block">/**
   * Call this to notify that we are about to start a transaction on the
   * retained layer manager aManager.
   */</comment>
  <name>void</name> <call><name>WillBeginRetainedLayerTransaction</name><argument_list>(<argument><expr><name>LayerManager</name>* <name>aManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Call this just before we end a transaction on aManager. If aManager
   * is not the retained layer manager then it must be a temporary layer
   * manager that will not be used again.
   */</comment>
  <function_decl><type><name>void</name></type> <name>WillEndTransaction</name><parameter_list>(<param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Call this after we end a transaction on aManager. If aManager
   * is not the retained layer manager then it must be a temporary layer
   * manager that will not be used again.
   */</comment>
  <function_decl><type><name>void</name></type> <name>DidEndTransaction</name><parameter_list>(<param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Build a container layer for a display item that contains a child
   * list, either reusing an existing one or creating a new one. It
   * sets the container layer children to layers which together render
   * the contents of the display list. It reuses existing layers from
   * the retained layer manager if possible.
   * aContainer may be null, in which case we construct a root layer.
   * This gets called by display list code. It calls BuildLayer on the
   * items in the display list, making items with their own layers
   * children of the new container, and assigning all other items to
   * ThebesLayer children created and managed by the FrameLayerBuilder.
   * Returns a layer with clip rect cleared; it is the
   * caller's responsibility to add any clip rect and set the visible
   * region.
   */</comment>
  <expr_stmt><expr><name>already_AddRefed</name>&lt;<name>Layer</name>&gt; <call><name>BuildContainerLayerFor</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                                 <argument><expr><name>LayerManager</name>* <name>aManager</name></expr></argument>,
                                                 <argument><expr><name>nsIFrame</name>* <name>aContainerFrame</name></expr></argument>,
                                                 <argument><expr><name>nsDisplayItem</name>* <name>aContainerItem</name></expr></argument>,
                                                 <argument><expr>const <name>nsDisplayList</name>&amp; <name>aChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Get a retained layer for a display item that needs to create its own
   * layer for rendering (i.e. under nsDisplayItem::BuildLayer). Returns
   * null if no retained layer is available, which usually means that this
   * display item didn't have a layer before so the caller will
   * need to create one.
   * Returns a layer with clip rect cleared; it is the
   * caller's responsibility to add any clip rect and set the visible
   * region.
   */</comment>
  <function_decl><type><name>Layer</name>*</type> <name>GetLeafLayerFor</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                         <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>,
                         <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Call this during invalidation if aFrame has
   * the NS_FRAME_HAS_CONTAINER_LAYER state bit. Only the nearest
   * ancestor frame of the damaged frame that has
   * NS_FRAME_HAS_CONTAINER_LAYER needs to be invalidated this way.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateThebesLayerContents</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                            <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Call this to force *all* retained layer contents to be discarded at
   * the next paint.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateAllThebesLayerContents</name><parameter_list>(<param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Call this to force all retained layers to be discarded and recreated at
   * the next paint.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateAllLayers</name><parameter_list>(<param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Call this to determine if a frame has a dedicated (non-Thebes) layer
   * for the given display item key.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>HasDedicatedLayer</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aDisplayItemKey</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * This callback must be provided to EndTransaction. The callback data
   * must be the nsDisplayListBuilder containing this FrameLayerBuilder.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DrawThebesLayer</name><parameter_list>(<param><decl><type><name>ThebesLayer</name>*</type> <name>aLayer</name></decl></param>,
                              <param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToDraw</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToInvalidate</name></decl></param>,
                              <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <comment type="block">/**
   * Dumps this FrameLayerBuilder's retained layer manager's retained
   * layer tree to stderr.
   */</comment>
  <function_decl><type><name>void</name></type> <name>DumpRetainedLayerTree</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/******* PRIVATE METHODS to FrameLayerBuilder.cpp ********/</comment>
  <comment type="block">/* These are only in the public section because they need
   * to be called by file-scope helper functions in FrameLayerBuilder.cpp.
   */</comment>
  
  <comment type="block">/**
   * Record aItem as a display item that is rendered by aLayer.
   */</comment>
  <function_decl><type><name>void</name></type> <name>AddLayerDisplayItem</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Record aItem as a display item that is rendered by the ThebesLayer
   * aLayer, with aClipRect, where aContainerLayerFrame is the frame
   * for the container layer this ThebesItem belongs to.
   * aItem must have an underlying frame.
   */</comment>
  <function_decl><type><name>void</name></type> <name>AddThebesDisplayItem</name><parameter_list>(<param><decl><type><name>ThebesLayer</name>*</type> <name>aLayer</name></decl></param>,
                            <param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                            <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>aClipRect</name></decl></param>,
                            <param><decl><type><name>nsIFrame</name>*</type> <name>aContainerLayerFrame</name></decl></param>,
                            <param><decl><type><name>LayerState</name></type> <name>aLayerState</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Given a frame and a display item key that uniquely identifies a
   * display item for the frame, find the layer that was last used to
   * render that display item. Returns null if there is no such layer.
   * This could be a dedicated layer for the display item, or a ThebesLayer
   * that renders many display items.
   */</comment>
  <function_decl><type><name>Layer</name>*</type> <name>GetOldLayerFor</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aDisplayItemKey</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
  <comment type="block">/**
   * We store an array of these for each frame that is associated with
   * one or more retained layers. Each DisplayItemData records the layer
   * used to render one of the frame's display items.
   */</comment>
  <decl_stmt><decl><type><name>class</name></type> <name>DisplayItemData</name> <block>{
  <label><name>public</name>:</label>
    <macro><name>DisplayItemData</name><argument_list>(<argument>Layer* aLayer</argument>, <argument>PRUint32 aKey</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>mLayer</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr>, <macro><name>mDisplayItemKey</name><argument_list>(<argument>aKey</argument>)</argument_list></macro> <expr><block>{}</block>

    <name>nsRefPtr</name>&lt;<name>Layer</name>&gt; <name>mLayer</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type>        <name>mDisplayItemKey</name></decl>;</decl_stmt>
  }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InternalDestroyDisplayItemData</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                             <param><decl><type><name>void</name>*</type> <name>aPropertyValue</name></decl></param>,
                                             <param><decl><type><name>PRBool</name></type> <name>aRemoveFromFramesWithLayers</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestroyDisplayItemData</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aPropertyValue</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * For DisplayItemDataProperty, the property value *is* an
   * nsTArray&lt;DisplayItemData&gt;, not a pointer to an array. This works
   * because sizeof(nsTArray&lt;T&gt;) == sizeof(void*).
   */</comment>
  <macro><name>NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR</name><argument_list>(<argument>DisplayItemDataProperty</argument>,
                                               <argument>DestroyDisplayItemData</argument>)</argument_list></macro>

  <comment type="block">/**
   * We accumulate DisplayItemData elements in a hashtable during
   * the paint process, and store them in the frame property only when
   * paint is complete. This is the hashentry for that hashtable.
   */</comment>
  <expr_stmt><expr><name>class</name> <name>DisplayItemDataEntry</name> : <name>public</name> <name>nsPtrHashKey</name>&lt;<name>nsIFrame</name>&gt; <block>{
  <expr><name>public</name>:
    <call><name>DisplayItemDataEntry</name><argument_list>(<argument><expr>const <name>nsIFrame</name> *<name>key</name></expr></argument>)</argument_list></call> : <name>nsPtrHashKey</name>&lt;<name>nsIFrame</name>&gt;(<name>key</name>) <block>{}</block>
    <call><name>DisplayItemDataEntry</name><argument_list>(<argument><expr>const <name>DisplayItemDataEntry</name> &amp;<name>toCopy</name></expr></argument>)</argument_list></call> :
      <name>nsPtrHashKey</name>&lt;<name>nsIFrame</name>&gt;(<name><name>toCopy</name>.<name>mKey</name></name>)</expr>, <macro><name>mData</name><argument_list>(<argument>toCopy.mData</argument>)</argument_list></macro>
    <expr><block>{
      <expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Should never be called, since we ALLOW_MEMMOVE"</expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>PRBool</name> <call><name>HasContainerLayer</name><argument_list>()</argument_list></call></expr>;

    <expr><name>nsTArray</name>&lt;<name>DisplayItemData</name>&gt; <name>mData</name></expr>;

    enum <expr><block>{ <expr><name>ALLOW_MEMMOVE</name> = <name>PR_TRUE</name></expr> }</block></expr>;
  }</block></expr>;</expr_stmt>

  <comment type="block">/**
   * We store one of these for each display item associated with a
   * ThebesLayer, in a hashtable that maps each ThebesLayer to an array
   * of ClippedDisplayItems. (ThebesLayerItemsEntry is the hash entry
   * for that hashtable.)
   * These are only stored during the paint process, so that the
   * DrawThebesLayer callback can figure out which items to draw for the
   * ThebesLayer.
   * mItem always has an underlying frame.
   */</comment>
  <struct>struct <name>ClippedDisplayItem</name> <block>{
    <expr_stmt><expr><call><name>ClippedDisplayItem</name><argument_list>(<argument><expr><name>nsDisplayItem</name>* <name>aItem</name></expr></argument>, <argument><expr>const <name>nsRect</name>* <name>aClipRect</name></expr></argument>)</argument_list></call>
      : <call><name>mItem</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr>, <macro><name>mHasClipRect</name><argument_list>(<argument>aClipRect != nsnull</argument>)</argument_list></macro>
    <expr><block>{
      <if>if <condition>(<expr><name>mHasClipRect</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mClipRect</name> = *<name>aClipRect</name></expr>;</expr_stmt>
      <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>

    <name>nsDisplayItem</name>* <name>mItem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nsRefPtr</name>&lt;<name>LayerManager</name>&gt; <name>mTempLayerManager</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type>         <name>mClipRect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type>   <name>mHasClipRect</name></decl>;</decl_stmt>
  }</block>;</struct>

  <comment type="block">/**
   * We accumulate ClippedDisplayItem elements in a hashtable during
   * the paint process. This is the hashentry for that hashtable.
   */</comment>
  <expr_stmt><expr><name>class</name> <name>ThebesLayerItemsEntry</name> : <name>public</name> <name>nsPtrHashKey</name>&lt;<name>ThebesLayer</name>&gt; <block>{
  <expr><name>public</name>:
    <call><name>ThebesLayerItemsEntry</name><argument_list>(<argument><expr>const <name>ThebesLayer</name> *<name>key</name></expr></argument>)</argument_list></call> : <name>nsPtrHashKey</name>&lt;<name>ThebesLayer</name>&gt;(<name>key</name>) <block>{}</block>
    <call><name>ThebesLayerItemsEntry</name><argument_list>(<argument><expr>const <name>ThebesLayerItemsEntry</name> &amp;<name>toCopy</name></expr></argument>)</argument_list></call> :
      <name>nsPtrHashKey</name>&lt;<name>ThebesLayer</name>&gt;(<name><name>toCopy</name>.<name>mKey</name></name>)</expr>, <macro><name>mItems</name><argument_list>(<argument>toCopy.mItems</argument>)</argument_list></macro>
    <expr><block>{
      <expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Should never be called, since we ALLOW_MEMMOVE"</expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>nsTArray</name>&lt;<name>ClippedDisplayItem</name>&gt; <name>mItems</name></expr>;
    <expr><name>nsIFrame</name>* <name>mContainerLayerFrame</name></expr>;

    enum <expr><block>{ <expr><name>ALLOW_MEMMOVE</name> = <name>PR_TRUE</name></expr> }</block></expr>;
  }</block></expr>;</expr_stmt>

  <function_decl><type><name>void</name></type> <name>RemoveThebesItemsForLayerSubtree</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><specifier>static</specifier> <name>PLDHashOperator</name></type> <name>UpdateDisplayItemDataForFrame</name><argument_list>(<argument><expr><name>nsPtrHashKey</name>&lt;<name>nsIFrame</name>&gt;* <name>aEntry</name></expr></argument>,
                                                       <argument><expr><name>void</name>* <name>aUserArg</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <function_decl><type><specifier>static</specifier> <name>PLDHashOperator</name></type> <name>StoreNewDisplayItemData</name><parameter_list>(<param><decl><type><name>DisplayItemDataEntry</name>*</type> <name>aEntry</name></decl></param>,
                                                 <param><decl><type><name>void</name>*</type> <name>aUserArg</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * The layer manager belonging to the widget that is being retained
   * across paints.
   */</comment>
  <decl_stmt><decl><type><name>LayerManager</name>*</type>                       <name>mRetainingManager</name></decl>;</decl_stmt>
  <comment type="block">/**
   * A map from frames to a list of (display item key, layer) pairs that
   * describes what layers various parts of the frame are assigned to.
   */</comment>
  <expr_stmt><expr><name>nsTHashtable</name>&lt;<name>DisplayItemDataEntry</name>&gt;  <name>mNewDisplayItemData</name></expr>;</expr_stmt>
  <comment type="block">/**
   * A map from ThebesLayers to the list of display items (plus
   * clipping data) to be rendered in the layer.
   */</comment>
  <expr_stmt><expr><name>nsTHashtable</name>&lt;<name>ThebesLayerItemsEntry</name>&gt; <name>mThebesLayerItems</name></expr>;</expr_stmt>
  <comment type="block">/**
   * Indicates that the contents of all ThebesLayers should be rerendered
   * during this paint.
   */</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                        <name>mInvalidateAllThebesContent</name></decl>;</decl_stmt>
  <comment type="block">/**
   * Indicates that the entire layer tree should be rerendered
   * during this paint.
   */</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                        <name>mInvalidateAllLayers</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FRAMELAYERBUILDER_H_ */</comment>
</unit>
