<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00359a28f12a76ee658dc5a6e4d0c7a06464fa0c.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=99:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
 * May 28, 2008.
 *
 * The Initial Developer of the Original Code is
 *   Brendan Eich &lt;brendan@mozilla.org&gt;
 *
 * Contributor(s):
 *   David Anderson &lt;danderson@mozilla.com&gt;
 *   David Mandelin &lt;dmandelin@mozilla.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslibmath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsiter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsxml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"assembler/assembler/MacroAssemblerCodeRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"assembler/assembler/CodeLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"assembler/assembler/RepatchBuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsiter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"methodjit/StubCalls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstracer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertycache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"methodjit/MonoIC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsanalyze.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterpinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertycacheinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscopeinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscriptinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstrinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobjinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxtinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatominlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StubCalls-inl.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsautooplen.h"</cpp:file></cpp:include>

<using>using namespace <name>js</name>;</using>
<using>using namespace <name><name>js</name>::<name>mjit</name></name>;</using>
<using>using namespace <name>JSC</name>;</using>

<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>FindExceptionHandler</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<label><name>top</name>:</label>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>throwing</name></name> &amp;&amp; <name><name>script</name>-&gt;<name>trynotesOffset</name></name></expr>)</condition><then> <block>{
        <comment type="line">// The PC is updated before every stub call, so we can use it here.</comment>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>offset</name> <init>= <expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> - <name><name>script</name>-&gt;<name>main</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>JSTryNoteArray</name> *</type><name>tnarray</name> <init>= <expr><call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>tnarray</name>-&gt;<name>length</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>JSTryNote</name> *</type><name>tn</name> <init>= <expr>&amp;<name><name>tnarray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> &lt; <name><name>script</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// The following if condition actually tests two separate conditions:</comment>
            <comment type="line">//   (1) offset - tn-&gt;start &gt;= tn-&gt;length</comment>
            <comment type="line">//       means the PC is not in the range of this try note, so we</comment>
            <comment type="line">//       should continue searching, after considering:</comment>
            <comment type="line">//   (2) offset - tn-&gt;start == tn-&gt;length</comment>
            <comment type="line">//       means the PC is at the first op of the exception handler</comment>
            <comment type="line">//       for this try note. This happens when an exception is thrown</comment>
            <comment type="line">//       during recording: the interpreter sets the PC to the handler</comment>
            <comment type="line">//       and then exits. In this case, we are in fact at the right</comment>
            <comment type="line">//       exception handler. </comment>
            <comment type="line">//      </comment>
            <comment type="line">//       Hypothetically, the op we are at might have thrown an</comment>
            <comment type="line">//       exception, in which case this would not be the right handler.</comment>
            <comment type="line">//       But the first ops of exception handlers generated by our</comment>
            <comment type="line">//       bytecode compiler cannot throw, so this is not possible.</comment>
            <if>if <condition>(<expr><name>offset</name> - <name><name>tn</name>-&gt;<name>start</name></name> &gt; <name><name>tn</name>-&gt;<name>length</name></name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <if>if <condition>(<expr><name><name>tn</name>-&gt;<name>stackDepth</name></name> &gt; <name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <call><name><name>fp</name>-&gt;<name>base</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><name><name>script</name>-&gt;<name>main</name></name> + <name><name>tn</name>-&gt;<name>start</name></name> + <name><name>tn</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name>js_UnwindScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tn</name>-&gt;<name>stackDepth</name></name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> == <call><name><name>fp</name>-&gt;<name>base</name></name><argument_list>()</argument_list></call> + <name><name>tn</name>-&gt;<name>stackDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><name><name>tn</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
                <case>case <expr><name>JSTRY_CATCH</name></expr>:
                  <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>js_GetOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call> == <name>JSOP_ENTERBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
                  <comment type="block">/* Catch cannot intercept the closing of a generator. */</comment>
                  <if>if <condition>(<expr><call><name>JS_UNLIKELY</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>exception</name>.<name>isMagic</name></name><argument_list>(<argument><expr><name>JS_GENERATOR_CLOSING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                      <break>break;</break></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                  <comment type="block">/*
                   * Don't clear cx-&gt;throwing to save cx-&gt;exception from GC
                   * until it is pushed to the stack via [exception] in the
                   * catch block.
                   */</comment>
                  <return>return <expr><name>pc</name></expr>;</return>

                </case><case>case <expr><name>JSTRY_FINALLY</name></expr>:
                  <comment type="block">/*
                   * Push (true, exception) pair for finally to indicate that
                   * [retsub] should rethrow the exception.
                   */</comment>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name><index>[<expr>0</expr>]</index></name>.<call><name>setBoolean</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name><index>[<expr>1</expr>]</index></name> = <name><name>cx</name>-&gt;<name>exception</name></name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> += 2</expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                  <return>return <expr><name>pc</name></expr>;</return>

                </case><case>case <expr><name>JSTRY_ITER</name></expr>:
                <block>{
                  <comment type="block">/*
                   * This is similar to JSOP_ENDITER in the interpreter loop,
                   * except the code now uses the stack slot normally used by
                   * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
                   * adjustment and regs.sp[1] after, to save and restore the
                   * pending exception.
                   */</comment>
                  <function_decl><type><name>AutoValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name><name>cx</name>-&gt;<name>exception</name></name></type></decl></param>)</parameter_list>;</function_decl>
                  <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>js_GetOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call> == <name>JSOP_ENDITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>ok</name> = !!<call><name>js_CloseIterator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name><index>[<expr>-1</expr>]</index></name>.<call><name>toObject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> -= 1</expr>;</expr_stmt>
                  <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                      <goto>goto <name>top</name>;</goto></then></if>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>cx</name>-&gt;<name>exception</name></name> = <call><name><name>tvr</name>.<name>value</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block>
            </case>}</block></switch>
        }</block></for>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Clean up a frame and return.  popFrame indicates whether to additionally pop
 * the frame and store the return value on the caller's stack.  The frame will
 * normally be popped by the caller on return from a call into JIT code,
 * so must be popped here when that caller code will not execute.  This can be
 * either because of a call into an un-JITable script, or because the call is
 * throwing an exception.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InlineReturn</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>fp</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call> != <name><name>f</name>.<name>entryFp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>js_IsActiveWithOrBlock</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<call><name><name>fp</name>-&gt;<name>scopeChain</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Value</name> *</type><name>newsp</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>actualArgs</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>newsp</name><index>[<expr>-1</expr>]</index></name> = <call><name><name>fp</name>-&gt;<name>returnValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call>.<call><name>popInlineFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>prev</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>SlowCall</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>vp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> - (<name>argc</name> + 2)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>Invoke</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name>InvokeArgsAlreadyOnTheStack</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>SlowNew</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> *</type><name>vp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> - (<name>argc</name> + 2)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>InvokeConstructor</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>InvokeArgsAlreadyOnTheStack</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
 * This function must only be called after the early prologue, since it depends
 * on fp-&gt;exec.fun.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>RemovePartialFrame</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>prev</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>prev</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> *</type><name>newsp</name> <init>= <expr>(<name>Value</name> *)<name>fp</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call>.<call><name>popInlineFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>newsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * HitStackQuota is called after the early prologue pushing the new frame would
 * overflow f.stackLimit.
 */</comment>
<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>HitStackQuota</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Include space to push another frame. */</comment>
    <decl_stmt><decl><type><name>uintN</name></type> <name>nvals</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>script</name><argument_list>()</argument_list></call>-&gt;<name>nslots</name> + <name>VALUES_PER_STACK_FRAME</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> == <call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>base</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>f</name>.<name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call>.<call><name>bumpCommitAndLimit</name><argument_list>(<argument><expr><name><name>f</name>.<name>entryFp</name></name></expr></argument>, <argument><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>, <argument><expr>&amp;<name><name>f</name>.<name>stackLimit</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>

    <comment type="block">/* Remove the current partially-constructed frame before throwing. */</comment>
    <expr_stmt><expr><call><name>RemovePartialFrame</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_ReportOverRecursed</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * This function must only be called after the early prologue, since it depends
 * on fp-&gt;exec.fun.
 */</comment>
<function><type><name>void</name> * <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>FixupArity</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nactual</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>oldfp</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nactual</name> != <call><name><name>oldfp</name>-&gt;<name>numFormalArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Grossssss! *move* the stack frame. If this ends up being perf-critical,
     * we can figure out how to spot-optimize it. Be careful to touch only the
     * members that have been initialized by initCallFrameCallerHalf and the
     * early prologue.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>flags</name>         <init>= <expr><call><name><name>oldfp</name>-&gt;<name>isConstructingFlag</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name>      <init>= <expr><call><name><name>oldfp</name>-&gt;<name>fun</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>ncode</name>          <init>= <expr><call><name><name>oldfp</name>-&gt;<name>nativeReturnAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Pop the inline frame. */</comment>
    <expr_stmt><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call> = <call><name><name>oldfp</name>-&gt;<name>prev</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> = (<name>Value</name>*) <name>oldfp</name></expr>;</expr_stmt>

    <comment type="block">/* Reserve enough space for a callee frame. */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>newfp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call>.<call><name>getInlineFrameWithinLimit</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>Value</name>*) <name>oldfp</name></expr></argument>, <argument><expr><name>nactual</name></expr></argument>,
                                                                <argument><expr><name>fun</name></expr></argument>, <argument><expr><call><name><name>fun</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>,
                                                                <argument><expr><name><name>f</name>.<name>entryFp</name></name></expr></argument>, <argument><expr>&amp;<name><name>f</name>.<name>stackLimit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>newfp</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Reset the part of the stack frame set by the caller. */</comment>
    <expr_stmt><expr><call><name><name>newfp</name>-&gt;<name>initCallFrameCallerHalf</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>nactual</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reset the part of the stack frame set by the prologue up to now. */</comment>
    <expr_stmt><expr><call><name><name>newfp</name>-&gt;<name>initCallFrameEarlyPrologue</name></name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>ncode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The caller takes care of assigning fp to regs. */</comment>
    <return>return <expr><name>newfp</name></expr>;</return>
}</block></function>

<function><type><name>void</name> * <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>CompileFunction</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nactual</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * We have a partially constructed frame. That's not really good enough to
     * compile though because we could throw, so get a full, adjusted frame.
     */</comment>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Since we can only use members set by initCallFrameCallerHalf,
     * we must carefully extract the callee from the nactual.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name> &amp;</type><name>callee</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>formalArgsEnd</name></name><argument_list>()</argument_list></call><index>[<expr>-(<call><name>int</name><argument_list>(<argument><expr><name>nactual</name></expr></argument>)</argument_list></call> + 2)</expr>]</index>.<call><name>toObject</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr><call><name><name>callee</name>.<name>getFunctionPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><call><name><name>fun</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * FixupArity/RemovePartialFrame expect to be called after the early
     * prologue. Pass the existing value for ncode, it has already been set
     * by the jit code calling into this stub.
     */</comment>
    <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>initCallFrameEarlyPrologue</name></name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>nativeReturnAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Empty script does nothing. */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>callingNew</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>isConstructing</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>script</name>-&gt;<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RemovePartialFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Value</name> *</type><name>vp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> - (<name>nactual</name> + 2)</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>callingNew</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>vp</name><index>[<expr>0</expr>]</index></name> = <name><name>vp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>vp</name><index>[<expr>0</expr>]</index></name>.<call><name>setUndefined</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>nactual</name> != <call><name><name>fp</name>-&gt;<name>numFormalArgs</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>fp</name> = (<name>JSStackFrame</name> *)<call><name>FixupArity</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>nactual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/* Finish frame initialization. */</comment>
    <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>initCallFrameLatePrologue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* These would have been initialized by the prologue. */</comment>
    <expr_stmt><expr><name><name>f</name>.<name>regs</name>.<name>fp</name></name> = <name>fp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> = <call><name><name>fp</name>-&gt;<name>base</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name>.<name>regs</name>.<name>pc</name></name> = <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>fun</name>-&gt;<name>isHeavyweight</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>js_GetCallObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>CompileStatus</name></type> <name>status</name> <init>= <expr><call><name>CanMethodJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>status</name> == <name>Compile_Okay</name></expr>)</condition><then>
        <return>return <expr><call><name><name>script</name>-&gt;<name>getJIT</name></name><argument_list>(<argument><expr><name>callingNew</name></expr></argument>)</argument_list></call>-&gt;<name>invokeEntry</name></expr>;</return></then></if>

    <comment type="block">/* Function did not compile... interpret it. */</comment>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name>Interpret</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>UncachedInlineCall</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flags</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pret</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> *</type><name>vp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> - (<name>argc</name> + 2)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> &amp;</type><name>callee</name> <init>= <expr><call><name><name>vp</name>-&gt;<name>toObject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>newfun</name> <init>= <expr><call><name><name>callee</name>.<name>getFunctionPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>newscript</name> <init>= <expr><call><name><name>newfun</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get pointer to new frame/slots, prepare arguments. */</comment>
    <decl_stmt><decl><type><name>StackSpace</name> &amp;</type><name>stack</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>newfp</name> <init>= <expr><call><name><name>stack</name>.<name>getInlineFrameWithinLimit</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>,
                                                          <argument><expr><name>newfun</name></expr></argument>, <argument><expr><name>newscript</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>,
                                                          <argument><expr><name><name>f</name>.<name>entryFp</name></name></expr></argument>, <argument><expr>&amp;<name><name>f</name>.<name>stackLimit</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JS_UNLIKELY</name><argument_list>(<argument><expr>!<name>newfp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>isPrimitive</name><argument_list>()</argument_list></call> &amp;&amp; !(<name>flags</name> &amp; <name>JSFRAME_CONSTRUCTING</name>)</expr></argument>,
                 <argument><expr><call><name>IsSaneThisObject</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name>.<call><name>toObject</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize frame, locals. */</comment>
    <expr_stmt><expr><call><name><name>newfp</name>-&gt;<name>initCallFrame</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>, <argument><expr><name>newfun</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetValueRangeToUndefined</name><argument_list>(<argument><expr><call><name><name>newfp</name>-&gt;<name>slots</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>newscript</name>-&gt;<name>nfixed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Officially push the frame. */</comment>
    <expr_stmt><expr><call><name><name>stack</name>.<name>pushInlineFrame</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>newscript</name></expr></argument>, <argument><expr><name>newfp</name></expr></argument>, <argument><expr>&amp;<name><name>f</name>.<name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>newfp</name> == <name><name>f</name>.<name>regs</name>.<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scope with a call object parented by callee's parent. */</comment>
    <if>if <condition>(<expr><call><name><name>newfun</name>-&gt;<name>isHeavyweight</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>js_GetCallObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>newfp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* Try to compile if not already compiled. */</comment>
    <if>if <condition>(<expr><call><name><name>newscript</name>-&gt;<name>getJITStatus</name></name><argument_list>(<argument><expr><call><name><name>newfp</name>-&gt;<name>isConstructing</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name>JITScript_None</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>mjit</name>::<name>TryCompile</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>newfp</name></expr></argument>)</argument_list></call> == <name>Compile_Error</name></expr>)</condition><then> <block>{
            <comment type="block">/* A runtime exception was thrown, get out. */</comment>
            <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If newscript was successfully compiled, run it. */</comment>
    <if>if <condition>(<decl><type><name>JITScript</name> *</type><name>jit</name> <init>= <expr><call><name><name>newscript</name>-&gt;<name>getJIT</name></name><argument_list>(<argument><expr><call><name><name>newfp</name>-&gt;<name>isConstructing</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then> <block>{
        <expr_stmt><expr>*<name>pret</name> = <name><name>jit</name>-&gt;<name>invokeEntry</name></name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Otherwise, run newscript in the interpreter. */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr>!!<call><name>Interpret</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>*<name>pret</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><name>void</name> * <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>UncachedNew</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>UncachedCallResult</name></type> <name>ucr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UncachedNewHelper</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr>&amp;<name>ucr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>ucr</name>.<name>codeAddr</name></name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>stubs</name>::<name>UncachedNewHelper</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>UncachedCallResult</name> *</type><name>ucr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>ucr</name>-&gt;<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> *</type><name>vp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> - (<name>argc</name> + 2)</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Try to do a fast inline call before the general Invoke path. */</comment>
    <if>if <condition>(<expr><call><name>IsFunctionObject</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>, <argument><expr>&amp;<name><name>ucr</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>ucr</name>-&gt;<name>fun</name>-&gt;<name>isInterpreted</name></name><argument_list>()</argument_list></call> &amp;&amp; 
        !<call><name><name>ucr</name>-&gt;<name>fun</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call>-&gt;<call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><name><name>ucr</name>-&gt;<name>callee</name></name> = &amp;<call><name><name>vp</name>-&gt;<name>toObject</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>UncachedInlineCall</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>JSFRAME_CONSTRUCTING</name></expr></argument>, <argument><expr>&amp;<name><name>ucr</name>-&gt;<name>codeAddr</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name>InvokeConstructor</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>InvokeArgsAlreadyOnTheStack</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
}</block></function>

<function><type><name>void</name> * <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>UncachedCall</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>UncachedCallResult</name></type> <name>ucr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UncachedCallHelper</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr>&amp;<name>ucr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>ucr</name>.<name>codeAddr</name></name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>stubs</name>::<name>UncachedCallHelper</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>UncachedCallResult</name> *</type><name>ucr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>ucr</name>-&gt;<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> *</type><name>vp</name> <init>= <expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> - (<name>argc</name> + 2)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>IsFunctionObject</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>, <argument><expr>&amp;<name><name>ucr</name>-&gt;<name>callee</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ucr</name>-&gt;<name>callee</name></name> = &amp;<call><name><name>vp</name>-&gt;<name>toObject</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ucr</name>-&gt;<name>fun</name></name> = <call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>ucr</name>-&gt;<name>callee</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>ucr</name>-&gt;<name>fun</name>-&gt;<name>isInterpreted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>ucr</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setUndefined</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> = <name>vp</name> + 1</expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name>UncachedInlineCall</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name><name>ucr</name>-&gt;<name>codeAddr</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return;</return>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>ucr</name>-&gt;<name>fun</name>-&gt;<name>isNative</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>CallJSNative</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>ucr</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return;</return>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>Invoke</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name>InvokeArgsAlreadyOnTheStack</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return;</return>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>PutCallObject</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasCallObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_PutCallObject</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>PutActivationObjects</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasCallObj</name><argument_list>()</argument_list></call> || <call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasArgsObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>js</name>::<name>PutActivationObjects</name></name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<extern>extern "C" <function><type><name>void</name> *</type>
<name>js_InternalThrow</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Make sure sp is up to date.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>regs</name></name> == &amp;<name><name>f</name>.<name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Call the throw hook if necessary</comment>
    <decl_stmt><decl><type><name>JSThrowHook</name></type> <name>handler</name> <init>= <expr><name><name>f</name>.<name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>throwHook</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>handler</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>Value</name></type> <name>rval</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>handler</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>script</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>, <argument><expr><call><name>Jsvalify</name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>throwHookData</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>JSTRAP_ERROR</name></expr>:
            <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>

          </case><case>case <expr><name>JSTRAP_RETURN</name></expr>:
            <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>setReturnValue</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>JS_FUNC_TO_DATA_PTR</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>,
                   <argument><expr><call><name>JS_METHODJIT_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name><name>trampolines</name>.<name>forceReturn</name></name></expr></argument>)</argument_list></call></expr>;</return>

          </case><case>case <expr><name>JSTRAP_THROW</name></expr>:
            <expr_stmt><expr><name><name>cx</name>-&gt;<name>exception</name></name> = <name>rval</name></expr>;</expr_stmt>
            <break>break;</break>

          </case><default>default:
            <break>break;</break>
        </default>}</block></switch>
    }</block></then></if>

    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>pc</name> = <call><name>FindExceptionHandler</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pc</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <comment type="line">// If on the 'topmost' frame (where topmost means the first frame</comment>
        <comment type="line">// called into through js_Interpret). In this case, we still unwind,</comment>
        <comment type="line">// but we shouldn't return from a JS function, because we're not in a</comment>
        <comment type="line">// JS function.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>lastFrame</name> <init>= <expr>(<name><name>f</name>.<name>entryFp</name></name> == <call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>js_UnwindScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>throwing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// For consistency with Interpret(), always run the script epilogue.</comment>
        <comment type="line">// This simplifies interactions with RunTracer(), since it can assume</comment>
        <comment type="line">// no matter how a function exited (error or not), that the epilogue</comment>
        <comment type="line">// does not need to be run.</comment>
        <expr_stmt><expr><call><name>ScriptEpilogue</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>lastFrame</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> == <name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>.<name>regs</name>.<name>sp</name></name> == <name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>script</name>-&gt;<name>nativeCodeForPC</name></name><argument_list>(<argument><expr><call><name><name>fp</name>-&gt;<name>isConstructing</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function></extern>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>GetCallObject</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>fun</name><argument_list>()</argument_list></call>-&gt;<call><name>isHeavyweight</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>js_GetCallObject</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>CreateThis</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>proto</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>callee</name> <init>= <expr>&amp;<call><name><name>fp</name>-&gt;<name>callee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>js_CreateThisForFunctionWithProto</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>formalArgs</name></name><argument_list>()</argument_list></call><index>[<expr>-1</expr>]</index>.<call><name>setObject</name><argument_list>(<argument><expr>*<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>EnterScript</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSInterpreterHook</name></type> <name>hook</name> <init>= <expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>callHook</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JS_UNLIKELY</name><argument_list>(<argument><expr><name>hook</name> != <name>NULL</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>fp</name>-&gt;<name>isExecuteFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>setHookData</name></name><argument_list>(<argument><expr><call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>callHookData</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>Probes</name>::<name>enterJSFun</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>maybeFun</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name> <name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>LeaveScript</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>Probes</name>::<name>exitJSFun</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>maybeFun</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSInterpreterHook</name></type> <name>hook</name> <init>= <expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>callHook</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>hook</name> &amp;&amp; <call><name><name>fp</name>-&gt;<name>hasHookData</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>fp</name>-&gt;<name>isExecuteFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><name>JS_TRUE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr>&amp;<name>ok</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>hookData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>

<comment type="block">/*
 * Called when an error is in progress and the topmost frame could not handle
 * it. This will unwind to a given frame, or find and align to an exception
 * handler in the process.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>HandleErrorInExcessFrame</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>stopFp</name></decl></param>, <param><decl><type><name>bool</name></type> <name>searchedTopmostFrame</name> <init>= <expr>true</expr></init></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Callers of this called either Interpret() or JaegerShot(), which would
     * have searched for exception handlers already. If we see stopFp, just
     * return false. Otherwise, pop the frame, since it's guaranteed useless.
     *
     * Note that this also guarantees ScriptEpilogue() has been called.
     */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>searchedTopmostFrame</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>fp</name> == <name>stopFp</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Remove the bottom frame. */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>returnOK</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>fp</name> = <call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear imacros. */</comment>
        <if>if <condition>(<expr><call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> = <call><name><name>fp</name>-&gt;<name>imacropc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>clearImacropc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there's an exception and a handler, set the pc and leave. */</comment>
        <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>throwing</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><call><name>FindExceptionHandler</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>pc</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> = <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>returnOK</name> = true</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/* Don't unwind if this was the entry frame. */</comment>
        <if>if <condition>(<expr><name>fp</name> == <name>stopFp</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <comment type="block">/* Unwind and return. */</comment>
        <expr_stmt><expr><name>returnOK</name> &amp;= <call><name>bool</name><argument_list>(<argument><expr><call><name>js_UnwindScope</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>returnOK</name> || <name><name>cx</name>-&gt;<name>throwing</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>returnOK</name> = <call><name>ScriptEpilogue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>returnOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>&amp;<name><name>f</name>.<name>regs</name></name> == <name><name>cx</name>-&gt;<name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>returnOK</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call> == <name>stopFp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>returnOK</name></expr>;</return>
}</block></function>

<comment type="block">/* Returns whether the current PC has method JIT'd code. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> *</type>
<name>AtSafePoint</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>script</name>-&gt;<name>maybeNativeCodeForPC</name></name><argument_list>(<argument><expr><call><name><name>fp</name>-&gt;<name>isConstructing</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Interprets until either a safe point is reached that has method JIT'd
 * code, or the current frame tries to return.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSBool</name></type>
<name>PartialInterpret</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>fp</name>-&gt;<name>finishedInInterpreter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call> ||
              !<call><name><name>script</name>-&gt;<name>maybeNativeCodeForPC</name></name><argument_list>(<argument><expr><call><name><name>fp</name>-&gt;<name>isConstructing</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><name>JS_TRUE</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>Interpret</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>JSINTERP_SAFEPOINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSOP_NOP</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Returns whether the current PC would return, popping the frame. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSOp</name></type>
<name>FrameIsFinished</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr><call><name>JSOp</name><argument_list>(<argument><expr>*<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr>(<name>op</name> == <name>JSOP_RETURN</name> ||
            <name>op</name> == <name>JSOP_RETRVAL</name> ||
            <name>op</name> == <name>JSOP_STOP</name>)
        ? <name>op</name>
        : <name>JSOP_NOP</name></expr>;</return>
}</block></function>


<comment type="block">/* Simulate an inline_return by advancing the pc. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>AdvanceReturnPC</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_CALL</name> ||
              *<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_NEW</name> ||
              *<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_EVAL</name> ||
              *<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_APPLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> += <name>JSOP_CALL_LENGTH</name></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
 * Given a frame that is about to return, make sure its return value and
 * activation objects are fixed up. Then, pop the frame and advance the
 * current PC. Note that while we could enter the JIT at this point, the
 * logic would still be necessary for the interpreter, so it's easier
 * (and faster) to finish frames in C++ even if at a safe point here.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HandleFinishedFrame</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>entryFrame</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>FrameIsFinished</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * This is the most difficult and complicated piece of the tracer
     * integration, and historically has been very buggy. The problem is that
     * although this frame has to be popped (see RemoveExcessFrames), it may
     * be at a JSOP_RETURN opcode, and it might not have ever been executed.
     * That is, fp-&gt;rval may not be set to the top of the stack, and if it
     * has, the stack has already been decremented. Note that fp-&gt;rval is not
     * the only problem: the epilogue may never have been executed.
     *
     * Here are the edge cases and whether the frame has been exited cleanly:
     *  1. No: A trace exited directly before a RETURN op, and the
     *         interpreter never ran.
     *  2. Yes: The interpreter exited cleanly.
     *  3. No: The interpreter exited on a safe point. LEAVE_ON_SAFE_POINT
     *         is not used in between JSOP_RETURN and advancing the PC,
     *         therefore, it cannot have been run if at a safe point.
     *  4. No: Somewhere in the RunTracer call tree, we removed a frame,
     *         and we returned to a JSOP_RETURN opcode. Note carefully
     *         that in this situation, FrameIsFinished() returns true!
     *  5. Yes: The function exited in the method JIT. However, in this
     *         case, we'll never enter HandleFinishedFrame(): we always
     *         immediately pop JIT'd frames.
     *
     * Since the only scenario where this fixup is NOT needed is a normal exit
     * from the interpreter, we can cleanly check for this scenario by checking
     * a bit it sets in the frame.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>returnOK</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>finishedInInterpreter</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSOp</name><argument_list>(<argument><expr>*<name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call> == <name>JSOP_RETURN</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>setReturnValue</name><argument_list>(<argument><expr><name><name>f</name>.<name>regs</name>.<name>sp</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name>returnOK</name> = <call><name>ScriptEpilogue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>isFunctionFrame</name><argument_list>()</argument_list></call> &amp;&amp;
                 !<call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>isEvalFrame</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>!<call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasCallObj</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call> != <name>entryFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AdvanceReturnPC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>returnOK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Given a frame newer than the entry frame, try to finish it. If it's at a
 * return position, pop the frame. If it's at a safe point, execute it in
 * Jaeger code. Otherwise, try to interpret until a safe point.
 *
 * While this function is guaranteed to make progress, it may not actually
 * finish or pop the current frame. It can either:
 *   1) Finalize a finished frame, or
 *   2) Finish and finalize the frame in the Method JIT, or
 *   3) Interpret, which can:
 *     a) Propagate an error, or
 *     b) Finish the frame, but not finalize it, or
 *     c) Abruptly leave at any point in the frame, or in a newer frame
 *        pushed by a call, that has method JIT'd code.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>EvaluateExcessFrame</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>entryFrame</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * A "finished" frame is when the interpreter rested on a STOP,
     * RETURN, RETRVAL, etc. We check for finished frames BEFORE looking
     * for a safe point. If the frame was finished, we could have already
     * called ScriptEpilogue(), and entering the JIT could call it twice.
     */</comment>
    <if>if <condition>(<expr>!<call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>FrameIsFinished</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>HandleFinishedFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<decl><type><name>void</name> *</type><name>ncode</name> <init>= <expr><call><name>AtSafePoint</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JaegerShotAtSafePoint</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ncode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><call><name>InlineReturn</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AdvanceReturnPC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>PartialInterpret</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Evaluate frames newer than the entry frame until all are gone. This will
 * always leave f.regs.fp == entryFrame.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FinishExcessFrames</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>entryFrame</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call> != <name>entryFrame</name> || <call><name><name>entryFrame</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name>EvaluateExcessFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>HandleErrorInExcessFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then></if>
    }</block></while>

    <return>return <expr>true</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_MONOIC</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateTraceHintSingle</name><parameter_list>(<param><decl><type><name><name>JSC</name>::<name>CodeLocationJump</name></name></type> <name>jump</name></decl></param>, <param><decl><type><name><name>JSC</name>::<name>CodeLocationLabel</name></name></type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Hack: The value that will be patched is before the executable address,
     * so to get protection right, just unprotect the general region around
     * the jump.
     */</comment>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>addr</name> <init>= <expr>(<name>uint8</name> *)(<call><name><name>jump</name>.<name>executableAddress</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>JSC</name>::<name>RepatchBuffer</name></name></type> <name>repatch</name><argument_list>(<argument><expr><name>addr</name> - 64</expr></argument>, <argument><expr>128</expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>repatch</name>.<name>relink</name></name><argument_list>(<argument><expr><name>jump</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JaegerSpew</name><argument_list>(<argument><expr><name>JSpew_PICs</name></expr></argument>, <argument><expr>"relinking trace hint %p to %p\n"</expr></argument>,
               <argument><expr><call><name><name>jump</name>.<name>executableAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>target</name>.<name>executableAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisableTraceHint</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name><name>ic</name>::<name>TraceICInfo</name></name> &amp;</type><name>tic</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>UpdateTraceHintSingle</name><argument_list>(<argument><expr><name><name>tic</name>.<name>traceHint</name></name></expr></argument>, <argument><expr><name><name>tic</name>.<name>jumpTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>tic</name>.<name>hasSlowTraceHint</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>UpdateTraceHintSingle</name><argument_list>(<argument><expr><name><name>tic</name>.<name>slowTraceHint</name></name></expr></argument>, <argument><expr><name><name>tic</name>.<name>jumpTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnableTraceHintAt</name><parameter_list>(<param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name><name>js</name>::<name>mjit</name>::<name>JITScript</name></name> *</type><name>jit</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>uint16_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> &lt; <name><name>jit</name>-&gt;<name>nTraceICs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>ic</name>::<name>TraceICInfo</name></name> &amp;</type><name>tic</name> <init>= <expr><name><name>jit</name>-&gt;<name>traceICs</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tic</name>.<name>jumpTargetPC</name></name> == <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JaegerSpew</name><argument_list>(<argument><expr><name>JSpew_PICs</name></expr></argument>, <argument><expr>"Enabling trace IC %u in script %p\n"</expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>UpdateTraceHintSingle</name><argument_list>(<argument><expr><name><name>tic</name>.<name>traceHint</name></name></expr></argument>, <argument><expr><name><name>tic</name>.<name>stubEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>tic</name>.<name>hasSlowTraceHint</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>UpdateTraceHintSingle</name><argument_list>(<argument><expr><name><name>tic</name>.<name>slowTraceHint</name></name></expr></argument>, <argument><expr><name><name>tic</name>.<name>stubEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name><name>js</name>::<name>mjit</name>::<name>EnableTraceHint</name></name><parameter_list>(<param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>uint16_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_MONOIC</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>jitNormal</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>EnableTraceHintAt</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>jitNormal</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>jitCtor</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>EnableTraceHintAt</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>jitCtor</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_MONOIC</name></expr></cpp:if>
<function><type><name>void</name> *</type>
<name>RunTracer</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name><name>ic</name>::<name>TraceICInfo</name></name> &amp;</type><name>tic</name></decl></param>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>void</name> *
<name>RunTracer</name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name><name>f</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>entryFrame</name> <init>= <expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TracePointAction</name></type> <name>tpa</name></decl>;</decl_stmt>

    <comment type="block">/* :TODO: nuke PIC? */</comment>
    <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>traceJitEnabled</name></name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/*
     * Force initialization of the entry frame's scope chain and return value,
     * if necessary.  The tracer can query the scope chain without needing to
     * check the HAS_SCOPECHAIN flag, and the frame is guaranteed to have the
     * correct return value stored if we trace/interpret through to the end
     * of the frame.
     */</comment>
    <expr_stmt><expr><call><name><name>entryFrame</name>-&gt;<name>scopeChain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entryFrame</name>-&gt;<name>returnValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>blacklist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>inlineCallCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> **</type><name>traceData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name> *</type><name>traceEpoch</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_MONOIC</name></expr></cpp:if>
    <expr_stmt><expr><name>traceData</name> = &amp;<name><name>tic</name>.<name>traceData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>traceEpoch</name> = &amp;<name><name>tic</name>.<name>traceEpoch</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>traceData</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>traceEpoch</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>tpa</name> = <call><name>MonitorTracePoint</name><argument_list>(<argument><expr><name><name>f</name>.<name>cx</name></name></expr></argument>, <argument><expr><name>inlineCallCount</name></expr></argument>, <argument><expr>&amp;<name>blacklist</name></expr></argument>, <argument><expr><name>traceData</name></expr></argument>, <argument><expr><name>traceEpoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>TRACE_RECORDER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_MONOIC</name></expr></cpp:if>
    <if>if <condition>(<expr><name>blacklist</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>DisableTraceHint</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>tic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Even though ExecuteTree() bypasses the interpreter, it should propagate</comment>
    <comment type="line">// error failures correctly.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>throwing</name></name></expr></argument>, <argument><expr><name>tpa</name> == <name>TPA_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call> = <call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call> == <call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>tpa</name></expr>)</condition> <block>{
      <case>case <expr><name>TPA_Nothing</name></expr>:
        <return>return <expr><name>NULL</name></expr>;</return>

      </case><case>case <expr><name>TPA_Error</name></expr>:
        <if>if <condition>(<expr>!<call><name>HandleErrorInExcessFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>, <argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>finishedInInterpreter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasImacropc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TPA_RanStuff</name></expr>:
      </case><case>case <expr><name>TPA_Recorded</name></expr>:
        <break>break;</break>
    </case>}</block></switch>

    <comment type="block">/*
     * The tracer could have dropped us off on any frame at any position.
     * Well, it could not have removed frames (recursion is disabled).
     *
     * Frames after the entryFrame cannot be entered via JaegerShotAtSafePoint()
     * unless each is at a safe point. We can JaegerShotAtSafePoint these
     * frames individually, but we must unwind to the entryFrame.
     *
     * Note carefully that JaegerShotAtSafePoint can resume methods at
     * arbitrary safe points whereas JaegerShot cannot.
     *
     * If we land on entryFrame without a safe point in sight, we'll end up
     * at the RETURN op. This is an edge case with two paths:
     *
     * 1) The entryFrame is the last inline frame. If it fell on a RETURN,
     *    move the return value down.
     * 2) The entryFrame is NOT the last inline frame. Pop the frame.
     *
     * In both cases, we hijack the stub to return to InjectJaegerReturn. This
     * moves |oldFp-&gt;rval| into the scripted return registers.
     */</comment>

  <label><name>restart</name>:</label>
    <comment type="block">/* Step 1. Finish frames created after the entry frame. */</comment>
    <if>if <condition>(<expr>!<call><name>FinishExcessFrames</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* IMacros are guaranteed to have been removed by now. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>.<name>fp</name></name><argument_list>()</argument_list></call> == <name>entryFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>entryFrame</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Step 2. If entryFrame is done, use a special path to return to EnterMethodJIT(). */</comment>
    <if>if <condition>(<expr><call><name>FrameIsFinished</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>HandleFinishedFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>void</name> *</type><name>retPtr</name> <init>= <expr><call><name>JS_FUNC_TO_DATA_PTR</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>, <argument><expr><name>InjectJaegerReturn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<call><name><name>f</name>.<name>returnAddressLocation</name></name><argument_list>()</argument_list></call> = <name>retPtr</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Step 3. If entryFrame is at a safe point, just leave. */</comment>
    <if>if <condition>(<decl><type><name>void</name> *</type><name>ncode</name> <init>= <expr><call><name>AtSafePoint</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
        <return>return <expr><name>ncode</name></expr>;</return></then></if>

    <comment type="block">/* Step 4. Do a partial interp, then restart the whole process. */</comment>
    <if>if <condition>(<expr>!<call><name>PartialInterpret</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>HandleErrorInExcessFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entryFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>THROWV</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <goto>goto <name>restart</name>;</goto>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_TRACER */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_TRACER</name></expr></cpp:if>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_MONOIC</name></expr></cpp:if>
<function><type><name>void</name> *<name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>InvokeTracer</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>, <param><decl><type><name><name>ic</name>::<name>TraceICInfo</name></name> *</type><name>tic</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>RunTracer</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>*<name>tic</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>void</name> *<name>JS_FASTCALL</name></type>
<name><name>stubs</name>::<name>InvokeTracer</name></name><parameter_list>(<param><decl><type><name>VMFrame</name> &amp;</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>RunTracer</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_MONOIC */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_TRACER */</comment>

</unit>
