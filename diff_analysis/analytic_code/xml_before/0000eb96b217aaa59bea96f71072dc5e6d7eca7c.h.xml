<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0000eb96b217aaa59bea96f71072dc5e6d7eca7c.h"><comment type="block">/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * PR assertion checker.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>jsutil_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jsutil_h___</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<function_decl><type><name>JS_BEGIN_EXTERN_C</name>

<comment type="block">/*
 * JS_Assert is present even in release builds, for the benefit of applications
 * that build DEBUG and link against a non-DEBUG SpiderMonkey library.
 */</comment>
<specifier>extern</specifier></type> <name>JS_PUBLIC_API</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
JS_Assert<parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>JSIntn</name></type> <name>ln</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ASSERT</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                                                       \
    <cpp:value>((expr) ? (void)0 : JS_Assert(#expr, __FILE__, __LINE__))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ASSERT_IF</name><parameter_list>(<param><type><name>cond</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                                              \
    <cpp:value>((!(cond) || (expr)) ? (void)0 : JS_Assert(#expr, __FILE__, __LINE__))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_NOT_REACHED</name><parameter_list>(<param><type><name>reason</name></type></param>)</parameter_list></cpp:macro>                                                \
    <cpp:value>JS_Assert(reason, __FILE__, __LINE__)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ASSERT</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ASSERT_IF</name><parameter_list>(<param><type><name>cond</name></type></param>,<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_NOT_REACHED</name><parameter_list>(<param><type><name>reason</name></type></param>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(DEBUG) */</comment>

<comment type="block">/*
 * Compile-time assert. "cond" must be a constant expression.
 * The macro can be used only in places where an "extern" declaration is
 * allowed.
 */</comment>

<comment type="block">/*
 * Sun Studio C++ compiler has a bug
 * "sizeof expression not accepted as size of array parameter"
 * The bug number is 6688515. It is not public yet.
 * Turn off this assert for Sun Studio until this bug is fixed.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STATIC_ASSERT</name><parameter_list>(<param><type><name>cond</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COUNTER__</name></cpp:ifdef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STATIC_ASSERT_GLUE1</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x##y</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STATIC_ASSERT_GLUE</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_STATIC_ASSERT_GLUE1(x,y)</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STATIC_ASSERT</name><parameter_list>(<param><type><name>cond</name></type></param>)</parameter_list></cpp:macro>                                            \
        <cpp:value>typedef int JS_STATIC_ASSERT_GLUE(js_static_assert, __COUNTER__)[(cond) ? 1 : -1]</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STATIC_ASSERT</name><parameter_list>(<param><type><name>cond</name></type></param>)</parameter_list></cpp:macro> <cpp:value>extern void js_static_assert(int arg[(cond) ? 1 : -1])</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STATIC_ASSERT_IF</name><parameter_list>(<param><type><name>cond</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_STATIC_ASSERT(!(cond) || (expr))</cpp:value></cpp:define>

<comment type="block">/*
 * Abort the process in a non-graceful manner. This will cause a core file,
 * call to the debugger or other moral equivalent as well as causing the
 * entire process to stop.
 */</comment>
<extern>extern JS_PUBLIC_API(void</extern>) <expr_stmt><expr><call><name>JS_Abort</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_BASIC_STATS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_SCOPE_DEPTH_METER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_BASIC_STATS</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>JSBasicStats</name> <block>{
    <decl_stmt><decl><type><name>uint32</name></type>      <name>num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>      <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>      <name>sum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>      <name>sqsum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>      <name>logscale</name></decl>;</decl_stmt>           <comment type="block">/* logarithmic scale: 0 (linear), 2, 10 */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>      <name><name>hist</name><index>[<expr>11</expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>JSBasicStats</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_INIT_STATIC_BASIC_STATS</name></cpp:macro>  <cpp:value>{0,0,0,0,0,{0,0,0,0,0,0,0,0,0,0,0}}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_BASIC_STATS_INIT</name><parameter_list>(<param><type><name>bs</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>memset((bs), 0, sizeof(JSBasicStats))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_BASIC_STATS_ACCUM</name><parameter_list>(<param><type><name>bs</name></type></param>,<param><type><name>val</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>JS_BasicStatsAccum(bs, val)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_MeanAndStdDevBS</name><parameter_list>(<param><type><name>bs</name></type></param>,<param><type><name>sigma</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>JS_MeanAndStdDev((bs)-&gt;num, (bs)-&gt;sum, (bs)-&gt;sqsum, sigma)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>JS_BasicStatsAccum</name><parameter_list>(<param><decl><type><name>JSBasicStats</name> *</type><name>bs</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>val</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>double</name></type>
<name>JS_MeanAndStdDev</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>num</name></decl></param>, <param><decl><type><name>double</name></type> <name>sum</name></decl></param>, <param><decl><type><name>double</name></type> <name>sqsum</name></decl></param>, <param><decl><type><name>double</name> *</type><name>sigma</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>JS_DumpBasicStats</name><parameter_list>(<param><decl><type><name>JSBasicStats</name> *</type><name>bs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>title</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>JS_DumpHistogram</name><parameter_list>(<param><decl><type><name>JSBasicStats</name> *</type><name>bs</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_BASIC_STATS_ACCUM</name><parameter_list>(<param><type><name>bs</name></type></param>,<param><type><name>val</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_BASIC_STATS */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_notme</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type>struct <name>JSCallsite</name></type> <name>JSCallsite</name>;</typedef>

<struct>struct <name>JSCallsite</name> <block>{
    <decl_stmt><decl><type><name>uint32</name></type>      <name>pc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>library</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCallsite</name>  *</type><name>parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCallsite</name>  *</type><name>siblings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCallsite</name>  *</type><name>kids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>        *</type><name>handy</name></decl>;</decl_stmt>
}</block>;</struct>

<extern>extern JS_FRIEND_API(JSCallsite *</extern>)
<macro><name>JS_Backtrace</name><argument_list>(<argument>int skip</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<extern>extern JS_FRIEND_API(void</extern>)
<expr_stmt><expr><call><name>JS_DumpBacktrace</name><argument_list>(<argument><expr><name>JSCallsite</name> *<name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>void</name>*</type> <name>js_malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>bytes</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>)</condition><then> <comment type="block">/* for asyncFree */</comment>
        <expr_stmt><expr><name>bytes</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
    <return>return <expr><call><name>malloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>void</name>*</type> <name>js_calloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>bytes</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>)</condition><then> <comment type="block">/* for asyncFree */</comment>
        <expr_stmt><expr><name>bytes</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
    <return>return <expr><call><name>calloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>void</name>*</type> <name>js_realloc</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>bytes</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>)</condition><then> <comment type="block">/* for asyncFree */</comment>
        <expr_stmt><expr><name>bytes</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
    <return>return <expr><call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>void</name></type> <name>js_free</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><name>JS_END_EXTERN_C</name>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>

<comment type="block">/**
 * The following classes are designed to cause assertions to detect
 * inadvertent use of guard objects as temporaries.  In other words,
 * when we have a guard object whose only purpose is its constructor and
 * destructor (and is never otherwise referenced), the intended use
 * might be:
 *     JSAutoTempValueRooter tvr(cx, 1, &amp;val);
 * but is is easy to accidentally write:
 *     JSAutoTempValueRooter(cx, 1, &amp;val);
 * which compiles just fine, but runs the destructor well before the
 * intended time.
 *
 * They work by adding (#ifdef DEBUG) an additional parameter to the
 * guard object's constructor, with a default value, so that users of
 * the guard object's API do not need to do anything.  The default value
 * of this parameter is a temporary object.  C++ (ISO/IEC 14882:1998),
 * section 12.2 [class.temporary], clauses 4 and 5 seem to assume a
 * guarantee that temporaries are destroyed in the reverse of their
 * construction order, but I actually can't find a statement that that
 * is true in the general case (beyond the two specific cases mentioned
 * there).  However, it seems to be true.
 *
 * These classes are intended to be used only via the macros immediately
 * below them:
 *   JS_DECL_USE_GUARD_OBJECT_NOTIFIER declares (ifdef DEBUG) a member
 *     variable, and should be put where a declaration of a private
 *     member variable would be placed.
 *   JS_GUARD_OBJECT_NOTIFIER_PARAM should be placed at the end of the
 *     parameters to each constructor of the guard object; it declares
 *     (ifdef DEBUG) an additional parameter.
 *   JS_GUARD_OBJECT_NOTIFIER_INIT is a statement that belongs in each
 *     constructor.  It uses the parameter declared by
 *     JS_GUARD_OBJECT_NOTIFIER_PARAM.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<name>class</name></type> <name>JSGuardObjectNotifier</name>
<block>{
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>bool</name>*</type> <name>mStatementDone</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
    <expr_stmt><expr><call><name>JSGuardObjectNotifier</name><argument_list>()</argument_list></call> : <macro><name>mStatementDone</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <block>{}</block>

    ~<macro><name>JSGuardObjectNotifier</name><argument_list>()</argument_list></macro> <block>{
        <expr>*<name>mStatementDone</name> = <name>true</name></expr>;
    }</block>

    <name>void</name> <macro><name>SetStatementDone</name><argument_list>(<argument>bool *aStatementDone</argument>)</argument_list></macro> <block>{
        <expr><name>mStatementDone</name> = <name>aStatementDone</name></expr>;
    }</block></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>JSGuardObjectNotificationReceiver</name>
<block>{
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>bool</name></type> <name>mStatementDone</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
    <expr_stmt><expr><call><name>JSGuardObjectNotificationReceiver</name><argument_list>()</argument_list></call> : <macro><name>mStatementDone</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block>

    ~<macro><name>JSGuardObjectNotificationReceiver</name><argument_list>()</argument_list></macro> <block>{
        <comment type="block">/*
         * Assert that the guard object was not used as a temporary.
         * (Note that this assert might also fire if Init is not called
         * because the guard object's implementation is not using the
         * above macros correctly.)
         */</comment>
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>mStatementDone</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>Init</name><argument_list>(<argument>const JSGuardObjectNotifier &amp;aNotifier</argument>)</argument_list></macro> <block>{
        <comment type="block">/*
         * aNotifier is passed as a const reference so that we can pass a
         * temporary, but we really intend it as non-const
         */</comment>
        <expr><name>const_cast</name>&lt;<name>JSGuardObjectNotifier</name>&amp;&gt;<call><name>(<name>aNotifier</name>).
            <name>SetStatementDone</name></name><argument_list>(<argument><expr>&amp;<name>mStatementDone</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></cpp:macro> \
    <cpp:value>JSGuardObjectNotificationReceiver _mCheckNotUsedAsTemporary;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GUARD_OBJECT_NOTIFIER_PARAM</name></cpp:macro> \
    <cpp:value>, const JSGuardObjectNotifier&amp; _notifier = JSGuardObjectNotifier()</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></cpp:macro> \
    <cpp:value>JS_BEGIN_MACRO _mCheckNotUsedAsTemporary.Init(_notifier); JS_END_MACRO</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* defined(DEBUG) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GUARD_OBJECT_NOTIFIER_PARAM</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></cpp:macro> <cpp:value>JS_BEGIN_MACRO JS_END_MACRO</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(DEBUG) */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__cplusplus) */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* jsutil_h___ */</comment>
</unit>
