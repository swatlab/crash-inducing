<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0053edc47bde6dbecc9f90f45d0c10879702a629.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla FastLoad code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2001
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Brendan Eich &lt;brendan@mozilla.org&gt; (original author)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nscore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsEnumeratorUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMemory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPIDLString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIComponentManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILocalFile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISeekableStream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISerializable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIStreamBufferAccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClassInfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBinaryStream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFastLoadFile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsInt64.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_UNIX</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METERING</name></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_MUX</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>METERING</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>       <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MUX</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trace_mux</name><parameter_list>(<param><decl><type><name>char</name></type> <name>mode</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> *</type><name>tfp</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>tfp</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>tfn</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tfn</name></expr></argument>, <argument><expr>"/tmp/mux.%ctrace"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tfp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>tfn</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>tfp</name></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>tfp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IOLBF</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>tfp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE_MUX</name><parameter_list>(<param><type><name>args</name></type></param>)</parameter_list></cpp:macro> <cpp:value>trace_mux args</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE_MUX</name><parameter_list>(<param><type><name>args</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Fletcher's 16-bit checksum, using 32-bit two's-complement arithmetic.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOLD_ONES_COMPLEMENT_CARRY</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>((X) = ((X) &amp; 0xffff) + ((X) &gt;&gt; 16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONES_COMPLEMENT_ACCUMULATE</name><parameter_list>(<param><type><name>X</name></type></param>,<param><type><name>Y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(X) += (Y); if ((X) &amp; 0x80000000)     \
                                        FOLD_ONES_COMPLEMENT_CARRY(X)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLETCHER_ACCUMULATE</name><parameter_list>(<param><type><name>A</name></type></param>,<param><type><name>B</name></type></param>,<param><type><name>U</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>ONES_COMPLEMENT_ACCUMULATE(A, U);     \
                                        ONES_COMPLEMENT_ACCUMULATE(B, A)</cpp:value></cpp:define>

<function><type><name>PRUint32</name></type>
<name>NS_AccumulateFastLoadChecksum</name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>aChecksum</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>PRUint8</name>*</type> <name>aBuffer</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aLastBuffer</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>C</name> <init>= <expr>*<name>aChecksum</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>A</name> <init>= <expr><name>C</name> &amp; 0xffff</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>B</name> <init>= <expr><name>C</name> &gt;&gt; 16</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint16</name></type> <name>U</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aLength</name> &gt;= 4</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>odd</name> <init>= <expr><call><name>PRWord</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>)</argument_list></call> &amp; 1</expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>PRWord</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>)</argument_list></call> &amp; 3</expr>)</condition> <block>{
          <case>case <expr>3</expr>:
            <expr_stmt><expr><name>U</name> = (<name><name>aBuffer</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | <name><name>aBuffer</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>U</name> = <name><name>aBuffer</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>aBuffer</name> += 3</expr>;</expr_stmt>
            <expr_stmt><expr><name>aLength</name> -= 3</expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr>2</expr>:
            <expr_stmt><expr><name>U</name> = (<name><name>aBuffer</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | <name><name>aBuffer</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>U</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>aBuffer</name> += 2</expr>;</expr_stmt>
            <expr_stmt><expr><name>aLength</name> -= 2</expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr>1</expr>:
            <expr_stmt><expr><name>U</name> = *<name>aBuffer</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>aLength</name>--</expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>

        <decl_stmt><decl><type><name>PRUint32</name></type> <name>W</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>odd</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>aLength</name> &gt; 3</expr>)</condition> <block>{
                <expr_stmt><expr><name>W</name> = *<call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>PRUint32</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> &lt;&lt;= 8</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IS_BIG_ENDIAN</name></cpp:ifdef>
                <expr_stmt><expr><name>U</name> |= <name>W</name> &gt;&gt; 24</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <call><name>PRUint16</name><argument_list>(<argument><expr><name>W</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <name>W</name> &amp; 0xff</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>U</name> |= <name>W</name> &amp; 0xff</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <call><name>PRUint16</name><argument_list>(<argument><expr><name>W</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <call><name>NS_SWAP16</name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <name>W</name> &gt;&gt; 24</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>aBuffer</name> += 4</expr>;</expr_stmt>
                <expr_stmt><expr><name>aLength</name> -= 4</expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>aBuffer</name>--</expr>;</expr_stmt>      <comment type="line">// we're odd, we didn't checksum the last byte</comment>
            <expr_stmt><expr><name>aLength</name>++</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <while>while <condition>(<expr><name>aLength</name> &gt; 3</expr>)</condition> <block>{
                <expr_stmt><expr><name>W</name> = *<call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>PRUint32</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IS_BIG_ENDIAN</name></cpp:ifdef>
                <expr_stmt><expr><name>U</name> = <name>W</name> &gt;&gt; 16</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <call><name>PRUint16</name><argument_list>(<argument><expr><name>W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><name>U</name> = <call><name>NS_SWAP16</name><argument_list>(<argument><expr><name>W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <name>W</name> &gt;&gt; 16</expr>;</expr_stmt>
                <expr_stmt><expr><name>U</name> = <call><name>NS_SWAP16</name><argument_list>(<argument><expr><name>W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>aBuffer</name> += 4</expr>;</expr_stmt>
                <expr_stmt><expr><name>aLength</name> -= 4</expr>;</expr_stmt>
            }</block></while>
        }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>aLastBuffer</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aLength</name> &lt;= 4</expr></argument>, <argument><expr>"aLength botch"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>aLength</name></expr>)</condition> <block>{
          <case>case <expr>4</expr>:
            <expr_stmt><expr><name>U</name> = (<name><name>aBuffer</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | <name><name>aBuffer</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>U</name> = (<name><name>aBuffer</name><index>[<expr>2</expr>]</index></name> &lt;&lt; 8) | <name><name>aBuffer</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr>3</expr>:
            <expr_stmt><expr><name>U</name> = (<name><name>aBuffer</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | <name><name>aBuffer</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>U</name> = <name><name>aBuffer</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr>2</expr>:
            <expr_stmt><expr><name>U</name> = (<name><name>aBuffer</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | <name><name>aBuffer</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr>1</expr>:
            <expr_stmt><expr><name>U</name> = <name><name>aBuffer</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLETCHER_ACCUMULATE</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>

        <expr_stmt><expr><name>aLength</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <while>while <condition>(<expr><name>A</name> &gt;&gt; 16</expr>)</condition>
        <expr_stmt><expr><call><name>FOLD_ONES_COMPLEMENT_CARRY</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <while>while <condition>(<expr><name>B</name> &gt;&gt; 16</expr>)</condition>
        <expr_stmt><expr><call><name>FOLD_ONES_COMPLEMENT_CARRY</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>

    <expr_stmt><expr>*<name>aChecksum</name> = (<name>B</name> &lt;&lt; 16) | <name>A</name></expr>;</expr_stmt>
    <return>return <expr><name>aLength</name></expr>;</return>
}</block></function>

<function><type><name>PRUint32</name></type>
<name>NS_AddFastLoadChecksums</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>sum1</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>sum2</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>sum2ByteCount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>A1</name> <init>= <expr><name>sum1</name> &amp; 0xffff</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>B1</name> <init>= <expr><name>sum1</name> &gt;&gt; 16</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>A2</name> <init>= <expr><name>sum2</name> &amp; 0xffff</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>B2</name> <init>= <expr><name>sum2</name> &gt;&gt; 16</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>A</name> <init>= <expr><name>A1</name> + <name>A2</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>A</name> &gt;&gt; 16</expr>)</condition>
        <expr_stmt><expr><call><name>FOLD_ONES_COMPLEMENT_CARRY</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>B</name> <init>= <expr><name>B2</name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>n</name> <init>= <expr>(<name>sum2ByteCount</name> + 1) / 2</expr></init></decl>;</init> <condition><expr><name>n</name> != 0</expr>;</condition> <incr><expr><name>n</name>--</expr></incr>)
        <expr_stmt><expr><call><name>ONES_COMPLEMENT_ACCUMULATE</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>B1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <while>while <condition>(<expr><name>B</name> &gt;&gt; 16</expr>)</condition>
        <expr_stmt><expr><call><name>FOLD_ONES_COMPLEMENT_CARRY</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>

    <return>return <expr>(<name>B</name> &lt;&lt; 16) | <name>A</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FOLD_ONES_COMPLEMENT_CARRY</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ONES_COMPLEMENT_ACCUMULATE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLETCHER_ACCUMULATE</name></cpp:undef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>magic</name><index>[]</index></name> <init>= <expr><name>MFL_FILE_MAGIC</name></expr></init></decl>;</decl_stmt>

<comment type="line">// -------------------------- nsFastLoadFileReader --------------------------</comment>

<decl_stmt><decl><type><name>nsID</name></type> <name><name>nsFastLoadFileReader</name>::<name>nsFastLoadFooter</name>::<name>gDummyID</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>nsFastLoadFileReader</name>::<name>nsObjectMapEntry</name></name></type>
    <name><name>nsFastLoadFileReader</name>::<name>nsFastLoadFooter</name>::<name>gDummySharpObjectEntry</name></name></decl>;</decl_stmt>

<macro><name>NS_IMPL_ISUPPORTS_INHERITED5</name><argument_list>(<argument>nsFastLoadFileReader</argument>,
                             <argument>nsBinaryInputStream</argument>,
                             <argument>nsIObjectInputStream</argument>,
                             <argument>nsIFastLoadFileControl</argument>,
                             <argument>nsIFastLoadReadControl</argument>,
                             <argument>nsISeekableStream</argument>,
                             <argument>nsIFastLoadFileReader</argument>)</argument_list></macro>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadHeader</name></name><parameter_list>(<param><decl><type><name>nsFastLoadHeader</name> *</type><name>aHeader</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>bytesRead</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Read</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHeader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>sizeof *<name>aHeader</name></expr></argument>, <argument><expr>&amp;<name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>bytesRead</name> != sizeof *<name>aHeader</name> ||
        <call><name>memcmp</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mMagic</name></name></expr></argument>, <argument><expr><name>magic</name></expr></argument>, <argument><expr><name>MFL_FILE_MAGIC_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>aHeader</name>-&gt;<name>mChecksum</name></name>     = <call><name>NS_SWAP32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mChecksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeader</name>-&gt;<name>mVersion</name></name>      = <call><name>NS_SWAP32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeader</name>-&gt;<name>mFooterOffset</name></name> = <call><name>NS_SWAP32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mFooterOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aHeader</name>-&gt;<name>mFileSize</name></name>     = <call><name>NS_SWAP32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mFileSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsIFastLoadFileControl methods:</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>GetChecksum</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>aChecksum</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aChecksum</name> = <name><name>mHeader</name>.<name>mChecksum</name></name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<struct>struct <name>nsStringMapEntry</name> <super>: <specifier>public</specifier> <name>PLDHashEntryHdr</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type>     <name>mString</name></decl>;</decl_stmt>            <comment type="line">// key, must come first</comment>
    <decl_stmt><decl><type><name>nsISupports</name>*</type>    <name>mURI</name></decl>;</decl_stmt>               <comment type="line">// for SelectMuxedDocument return value</comment>
</public>}</block>;</struct>

<struct>struct <name>nsDocumentMapEntry</name> <super>: <specifier>public</specifier> <name>nsStringMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>PRUint32</name></type>    <name>mInitialSegmentOffset</name></decl>;</decl_stmt>  <comment type="line">// offset of URI's first segment in file</comment>
</public>}</block>;</struct>

<struct>struct <name>nsDocumentMapReadEntry</name> <super>: <specifier>public</specifier> <name>nsDocumentMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>PRUint32</name></type>    <name>mNextSegmentOffset</name></decl>;</decl_stmt>     <comment type="line">// offset of URI's next segment to read</comment>
    <macro><name>PRUint32</name></macro>    <label><name>mBytesLeft</name> :</label> <expr_stmt><expr>31</expr>,        <comment type="line">// bytes remaining in current segment</comment>
                <expr><name>mNeedToSeek</name> : 1</expr>;</expr_stmt>        <comment type="line">// flag to defer Seek from Select to</comment>
                                        <comment type="line">// Read, in case there is no Read before</comment>
                                        <comment type="line">// another entry is Selected (to improve</comment>
                                        <comment type="line">// input stream buffer utilization)</comment>
    <decl_stmt><decl><type><name>PRInt64</name></type>     <name>mSaveOffset</name></decl>;</decl_stmt>            <comment type="line">// in case demux schedule differs from</comment>
                                        <comment type="line">// mux schedule</comment>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>strmap_ClearEntry</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>, <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsStringMapEntry</name>*</type> <name>entry</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsStringMapEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mString</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr>(<name>void</name>*) <name><name>entry</name>-&gt;<name>mString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mURI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_DHashClearEntryStub</name><argument_list>(<argument><expr><name>aTable</name></expr></argument>, <argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PLDHashTableOps</name></type> <name>strmap_DHashTableOps</name> <init>= <expr><block>{
    <expr><name>PL_DHashAllocTable</name></expr>,
    <expr><name>PL_DHashFreeTable</name></expr>,
    <expr><name>PL_DHashStringKey</name></expr>,
    <expr><name>PL_DHashMatchStringKey</name></expr>,
    <expr><name>PL_DHashMoveEntryStub</name></expr>,
    <expr><name>strmap_ClearEntry</name></expr>,
    <expr><name>PL_DHashFinalizeStub</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="line">// An nsObjectMapEntry holds a strong reference to an XPCOM object, unless the</comment>
<comment type="line">// mObject member, when cast to NSFastLoadOID, has its MFL_OBJECT_DEF_TAG bit</comment>
<comment type="line">// set.  NB: we rely on the fact that an nsISupports* is never an odd pointer.</comment>
<struct>struct <name>nsObjectMapEntry</name> <super>: <specifier>public</specifier> <name>PLDHashEntryHdr</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>nsISupports</name>*</type>            <name>mObject</name></decl>;</decl_stmt>        <comment type="line">// key, must come first</comment>
</public>}</block>;</struct>

<comment type="line">// Fast mapping from URI object pointer back to spec-indexed document info.</comment>
<struct>struct <name>nsURIMapReadEntry</name> <super>: <specifier>public</specifier> <name>nsObjectMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>mDocMapEntry</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>objmap_ClearEntry</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>, <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsObjectMapEntry</name>*</type> <name>entry</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsObjectMapEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Ignore tagged object ids stored as object pointer keys (the updater</comment>
    <comment type="line">// code does this).</comment>
    <if>if <condition>(<expr>(<call><name>NS_PTR_TO_INT32</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mObject</name></name></expr></argument>)</argument_list></call> &amp; <name>MFL_OBJECT_DEF_TAG</name>) == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mObject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>PL_DHashClearEntryStub</name><argument_list>(<argument><expr><name>aTable</name></expr></argument>, <argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PLDHashTableOps</name></type> <name>objmap_DHashTableOps</name> <init>= <expr><block>{
    <expr><name>PL_DHashAllocTable</name></expr>,
    <expr><name>PL_DHashFreeTable</name></expr>,
    <expr><name>PL_DHashVoidPtrKeyStub</name></expr>,
    <expr><name>PL_DHashMatchEntryStub</name></expr>,
    <expr><name>PL_DHashMoveEntryStub</name></expr>,
    <expr><name>objmap_ClearEntry</name></expr>,
    <expr><name>PL_DHashFinalizeStub</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>HasMuxedDocument</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aURISpec</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>docMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapReadEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mDocumentMap</name></name></expr></argument>, <argument><expr><name>aURISpec</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>aResult</name> = <call><name>PL_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr><name>docMapEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>StartMuxedDocument</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aURI</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aURISpec</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>docMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapReadEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mDocumentMap</name></name></expr></argument>, <argument><expr><name>aURISpec</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the spec isn't in the map, return NS_ERROR_NOT_AVAILABLE so the</comment>
    <comment type="line">// FastLoad service can try for a file update.</comment>
    <if>if <condition>(<expr><call><name>PL_DHASH_ENTRY_IS_FREE</name><argument_list>(<argument><expr><name>docMapEntry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>key</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsURIMapReadEntry</name>*</type> <name>uriMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsURIMapReadEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mURIMap</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>uriMapEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name> == <name>nsnull</name></expr></argument>,
                 <argument><expr>"URI mapped to two different specs?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>docMapEntry</name>-&gt;<name>mURI</name></name> = <name>aURI</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name><name>docMapEntry</name>-&gt;<name>mURI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mObject</name></name> = <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name><name>uriMapEntry</name>-&gt;<name>mObject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name> = <name>docMapEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('r', "start %p (%p) %s\n", <name>aURI</name>, <call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>aURISpec</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>SelectMuxedDocument</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aURI</name></decl></param>,
                                          <param><decl><type><name>nsISupports</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="line">// Find the given URI's entry and select it for more reading.</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>key</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsURIMapReadEntry</name>*</type> <name>uriMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsURIMapReadEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mURIMap</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the URI isn't in the map, return NS_ERROR_NOT_AVAILABLE so the</comment>
    <comment type="line">// FastLoad service can try selecting the file updater.</comment>
    <if>if <condition>(<expr><call><name>PL_DHASH_ENTRY_IS_FREE</name><argument_list>(<argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <comment type="line">// If we're interrupting another document's segment, save its offset so</comment>
    <comment type="line">// we can seek back when it's reselected.  If prevDocMapEntry-&gt;mNeedToSeek</comment>
    <comment type="line">// is set, that means the stream is not positioned for prevDocMapEntry, to</comment>
    <comment type="line">// avoid buffer thrashing.  See below in this function for more.</comment>
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>prevDocMapEntry</name> <init>= <expr><name>mCurrentDocumentMapEntry</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>prevDocMapEntry</name> &amp;&amp;
        <name><name>prevDocMapEntry</name>-&gt;<name>mBytesLeft</name></name> &amp;&amp;
        !<name><name>prevDocMapEntry</name>-&gt;<name>mNeedToSeek</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>Tell</name><argument_list>(<argument><expr>&amp;<name><name>prevDocMapEntry</name>-&gt;<name>mSaveOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="line">// It turns out we get a fair amount of redundant select calls, thanks to</comment>
    <comment type="line">// non-blocking hunks of data from the parser that are devoid of scripts.</comment>
    <comment type="line">// As more data gets FastLoaded, the number of these useless selects will</comment>
    <comment type="line">// decline.</comment>
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>docMapEntry</name> <init>= <expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>docMapEntry</name> == <name>prevDocMapEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('r', "select prev %s same as current!\n",
                   <name><name>docMapEntry</name>-&gt;<name>mString</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>

    <comment type="line">// Invariant: docMapEntry-&gt;mBytesLeft implies docMapEntry-&gt;mSaveOffset has</comment>
    <comment type="line">// been set non-zero by the Tell call above.</comment>
    <else>else <if>if <condition>(<expr><name><name>docMapEntry</name>-&gt;<name>mBytesLeft</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>docMapEntry</name>-&gt;<name>mSaveOffset</name></name> != 0</expr></argument>,
                     <argument><expr>"reselecting from multiplex at unsaved offset?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Defer Seek till Read, in case of "ping-pong" Selects without any</comment>
        <comment type="line">// intervening Reads, to avoid dumping the underlying mInputStream's</comment>
        <comment type="line">// input buffer for cases where alternate "pongs" fall in the same</comment>
        <comment type="line">// buffer.</comment>
        <expr_stmt><expr><name><name>docMapEntry</name>-&gt;<name>mNeedToSeek</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>prevDocMapEntry</name> ? <name><name>prevDocMapEntry</name>-&gt;<name>mURI</name></name> : <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>docMapEntry</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MUX</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PRInt64</name></type> <name>currentSegmentOffset</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Tell</name><argument_list>(<argument><expr>&amp;<name>currentSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>trace_mux</name><argument_list>(<argument><expr>'r'</expr></argument>, <argument><expr>"select %p (%p) offset %ld\n"</expr></argument>,
              <argument><expr><name>aURI</name></expr></argument>, <argument><expr><call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>long</name>) <name>currentSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>EndMuxedDocument</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aURI</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>key</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsURIMapReadEntry</name>*</type> <name>uriMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsURIMapReadEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mURIMap</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the URI isn't in the map, return NS_ERROR_NOT_AVAILABLE so the</comment>
    <comment type="line">// FastLoad service can try to end a select on its file updater.</comment>
    <if>if <condition>(<expr><call><name>PL_DHASH_ENTRY_IS_FREE</name><argument_list>(<argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <comment type="line">// Drop our ref to the URI object that was passed to StartMuxedDocument,</comment>
    <comment type="line">// we no longer need it, and we do not want to extend its lifetime.</comment>
    <if>if <condition>(<expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name>-&gt;<name>mURI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Shrink the table if half the entries are removed sentinels.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>size</name> <init>= <expr><call><name>PL_DHASH_TABLE_SIZE</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mURIMap</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>mFooter</name>.<name>mURIMap</name>.<name>removedCount</name></name> &gt;= (<name>size</name> &gt;&gt; 2)</expr>)</condition><then>
        <expr_stmt><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mURIMap</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>PL_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>PL_DHashTableRawRemove</name><argument_list>(<argument><expr>&amp;<name><name>mFooter</name>.<name>mURIMap</name></name></expr></argument>, <argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('r', "end %p (%p)\n", <name>aURI</name>, <call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>Read</name></name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>aBuffer</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type><name>aBytesRead</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>entry</name> <init>= <expr><name>mCurrentDocumentMapEntry</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
        <comment type="line">// Don't call our Seek wrapper, as it clears mCurrentDocumentMapEntry.</comment>
        <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mNeedToSeek</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mSaveOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mNeedToSeek</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// Loop to handle empty segments, which may be generated by the</comment>
        <comment type="line">// writer, given Start A; Start B; Select A; Select B; write B data;</comment>
        <comment type="line">// multiplexing schedules, which do tend to occur given non-blocking</comment>
        <comment type="line">// i/o with LIFO scheduling.  XXXbe investigate LIFO issues</comment>
        <while>while <condition>(<expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> == 0</expr>)</condition> <block>{
            <comment type="line">// Check for unexpected end of multiplexed stream.</comment>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mNextSegmentOffset</name></name> != 0</expr></argument>,
                         <argument><expr>"document demuxed from FastLoad file more than once?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mNextSegmentOffset</name></name> == 0</expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mNextSegmentOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Clear mCurrentDocumentMapEntry temporarily to avoid recursion.</comment>
            <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>nsnull</name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>mNextSegmentOffset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRUint32</name></type> <name>bytesLeft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name>bytesLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> = <name>bytesLeft</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>entry</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> &gt;= 8</expr></argument>, <argument><expr>"demux segment length botch!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> -= 8</expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>count</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name>mFileLen</name> - <name>mFilePos</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>mFileData</name>+<name>mFilePos</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aBytesRead</name> = <name>count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFilePos</name> += <name>count</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> &gt;= *<name>aBytesRead</name></expr></argument>, <argument><expr>"demux Read underflow!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> -= *<name>aBytesRead</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
        <comment type="line">// Invariant: !entry-&gt;mBytesLeft implies entry-&gt;mSaveOffset == 0.</comment>
        <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> == 0</expr>)</condition><then>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSaveOffset</name></name> = 0</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadSegments</name></name><parameter_list>(<param><decl><type><name>nsWriteSegmentFun</name></type> <name>aWriter</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>,
                                   <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>entry</name> <init>= <expr><name>mCurrentDocumentMapEntry</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>entry</name> || (!<name><name>entry</name>-&gt;<name>mNeedToSeek</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>mBytesLeft</name></name> != 0)</expr></argument>,
                 <argument><expr>"ReadSegments called from above nsFastLoadFileReader layer?!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>count</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name>mFileLen</name> - <name>mFilePos</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Errors returned from the writer get ignored.</comment>
    <expr_stmt><expr><call><name>aWriter</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>, <argument><expr>(<name>char</name>*)(<name>mFileData</name> + <name>mFilePos</name>)</expr></argument>, <argument><expr>0</expr></argument>,
            <argument><expr><name>count</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFilePos</name> += <name>count</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> &gt;= *<name>aResult</name></expr></argument>,
                     <argument><expr>"demux ReadSegments underflow!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> -= *<name>aResult</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
        <comment type="line">// Invariant: !entry-&gt;mBytesLeft implies entry-&gt;mSaveOffset == 0.</comment>
        <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> == 0</expr>)</condition><then>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSaveOffset</name></name> = 0</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ComputeChecksum</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>checksum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <comment type="line">// Skip first 2 fields.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>pos</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>, <argument><expr><name>mVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_AccumulateFastLoadChecksum</name><argument_list>(<argument><expr>&amp;<name>checksum</name></expr></argument>,
                                  <argument><expr><name>mFileData</name> + <name>pos</name></expr></argument>,
                                  <argument><expr><name>mFileLen</name> - <name>pos</name></expr></argument>,
                                  <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aResult</name> = <name>checksum</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>GetDependencies</name></name><parameter_list>(<param><decl><type><name>nsISimpleEnumerator</name>* *</type><name>aDependencies</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>NS_NewArrayEnumerator</name><argument_list>(<argument><expr><name>aDependencies</name></expr></argument>, <argument><expr><name><name>mFooter</name>.<name>mDependencies</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadFooter</name></name><parameter_list>(<param><decl><type><name>nsFastLoadFooter</name> *</type><name>aFooter</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ReadFooterPrefix</name><argument_list>(<argument><expr><name>aFooter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>aFooter</name>-&gt;<name>mIDMap</name></name> = new <name><name>nsID</name><index>[<expr><name><name>aFooter</name>-&gt;<name>mNumIDs</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>aFooter</name>-&gt;<name>mIDMap</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>n</name> = <name><name>aFooter</name>-&gt;<name>mNumIDs</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>ReadSlowID</name><argument_list>(<argument><expr>&amp;<name><name>aFooter</name>-&gt;<name>mIDMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></for>

    <expr_stmt><expr><name><name>aFooter</name>-&gt;<name>mObjectMap</name></name> = new <name><name>nsObjectMapEntry</name><index>[<expr><name><name>aFooter</name>-&gt;<name>mNumSharpObjects</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>aFooter</name>-&gt;<name>mObjectMap</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>n</name> = <name><name>aFooter</name>-&gt;<name>mNumSharpObjects</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsObjectMapEntry</name>*</type> <name>entry</name> <init>= <expr>&amp;<name><name>aFooter</name>-&gt;<name>mObjectMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>ReadSharpObjectInfo</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mReadObject</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSkipOffset</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSaveStrongRefCnt</name></name> = <name><name>entry</name>-&gt;<name>mStrongRefCnt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSaveWeakRefCnt</name></name> = <name><name>entry</name>-&gt;<name>mWeakRefCnt</name></name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name><name>aFooter</name>-&gt;<name>mDocumentMap</name></name></expr></argument>, <argument><expr>&amp;<name>strmap_DHashTableOps</name></expr></argument>,
                           <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsDocumentMapReadEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                           <argument><expr><name><name>aFooter</name>-&gt;<name>mNumMuxedDocuments</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>aFooter</name>-&gt;<name>mDocumentMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name><name>aFooter</name>-&gt;<name>mURIMap</name></name></expr></argument>, <argument><expr>&amp;<name>objmap_DHashTableOps</name></expr></argument>,
                           <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsURIMapReadEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                           <argument><expr><name><name>aFooter</name>-&gt;<name>mNumMuxedDocuments</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>aFooter</name>-&gt;<name>mURIMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>n</name> = <name><name>aFooter</name>-&gt;<name>mNumMuxedDocuments</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsFastLoadMuxedDocumentInfo</name></type> <name>info</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>ReadMuxedDocumentInfo</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>entry</name> <init>=
            <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapReadEntry</name>*</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>aFooter</name>-&gt;<name>mDocumentMap</name></name></expr></argument>,
                                             <argument><expr><name><name>info</name>.<name>mURISpec</name></name></expr></argument>,
                                             <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr>(<name>void</name>*) <name><name>info</name>.<name>mURISpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name><name>entry</name>-&gt;<name>mString</name></name></expr></argument>, <argument><expr>"duplicate URISpec in MuxedDocumentMap"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mString</name></name> = <name><name>info</name>.<name>mURISpec</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mURI</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mInitialSegmentOffset</name></name> = <name><name>info</name>.<name>mInitialSegmentOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mNextSegmentOffset</name></name> = <name><name>info</name>.<name>mInitialSegmentOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mBytesLeft</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mNeedToSeek</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSaveOffset</name></name> = 0</expr>;</expr_stmt>
    }</block></for>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupportsArray</name></expr></argument>&gt;</argument_list></name></type> <name>readDeps</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>NS_NewISupportsArray</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>readDeps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>filename</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>n</name> = <name><name>aFooter</name>-&gt;<name>mNumDependencies</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>ReadCString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>PRInt64</name></type> <name>fastLoadMtime</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>Read64</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>PRUint64</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>&amp;<name>fastLoadMtime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILocalFile</name></expr></argument>&gt;</argument_list></name></type> <name>file</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>NS_NewNativeLocalFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>PRInt64</name></type> <name>currentMtime</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>file</name>-&gt;<name>GetLastModifiedTime</name></name><argument_list>(<argument><expr>&amp;<name>currentMtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr><call><name>LL_NE</name><argument_list>(<argument><expr><name>fastLoadMtime</name></expr></argument>, <argument><expr><name>currentMtime</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>path</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>file</name>-&gt;<name>GetNativePath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s mtime changed, invalidating FastLoad file\n"</expr></argument>,
                   <argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>rv</name> = <call><name><name>readDeps</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></for>

    <expr_stmt><expr><name><name>aFooter</name>-&gt;<name>mDependencies</name></name> = <name>readDeps</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadFooterPrefix</name></name><parameter_list>(<param><decl><type><name>nsFastLoadFooterPrefix</name> *</type><name>aFooterPrefix</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aFooterPrefix</name>-&gt;<name>mNumIDs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aFooterPrefix</name>-&gt;<name>mNumSharpObjects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aFooterPrefix</name>-&gt;<name>mNumMuxedDocuments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aFooterPrefix</name>-&gt;<name>mNumDependencies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadSlowID</name></name><parameter_list>(<param><decl><type><name>nsID</name> *</type><name>aID</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aID</name>-&gt;<name>m0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read16</name><argument_list>(<argument><expr>&amp;<name><name>aID</name>-&gt;<name>m1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read16</name><argument_list>(<argument><expr>&amp;<name><name>aID</name>-&gt;<name>m2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>bytesRead</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>Read</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>aID</name>-&gt;<name>m3</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>sizeof <name><name>aID</name>-&gt;<name>m3</name></name></expr></argument>, <argument><expr>&amp;<name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>bytesRead</name> != sizeof <name><name>aID</name>-&gt;<name>m3</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadFastID</name></name><parameter_list>(<param><decl><type><name>NSFastLoadID</name> *</type><name>aID</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>Read32</name><argument_list>(<argument><expr><name>aID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>*<name>aID</name> ^= <name>MFL_ID_XOR_KEY</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadSharpObjectInfo</name></name><parameter_list>(<param><decl><type><name>nsFastLoadSharpObjectInfo</name> *</type><name>aInfo</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aInfo</name>-&gt;<name>mCIDOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aInfo</name>-&gt;<name>mCIDOffset</name></name> != 0</expr></argument>,
                 <argument><expr>"fastload reader: mCIDOffset cannot be zero!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Read16</name><argument_list>(<argument><expr>&amp;<name><name>aInfo</name>-&gt;<name>mStrongRefCnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read16</name><argument_list>(<argument><expr>&amp;<name><name>aInfo</name>-&gt;<name>mWeakRefCnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadMuxedDocumentInfo</name></name><parameter_list>(<param><decl><type><name>nsFastLoadMuxedDocumentInfo</name> *</type><name>aInfo</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>spec</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ReadCString</name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name><name>aInfo</name>-&gt;<name>mInitialSegmentOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>aInfo</name>-&gt;<name>mURISpec</name></name> = <call><name>ToNewCString</name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>Open</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILocalFile</name></expr></argument>&gt;</argument_list></name></type> <name>localFile</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mFile</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    <expr_stmt><expr><name>rv</name> = <call><name><name>localFile</name>-&gt;<name>OpenNSPRFileDesc</name></name><argument_list>(<argument><expr><name>PR_RDONLY</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>mFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRInt64</name></type> <name>size</name> <init>= <expr><call><name>PR_Available64</name><argument_list>(<argument><expr><name>mFd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>size</name> &gt;= <name>PR_INT32_MAX</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FILE_TOO_BIG</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mFileLen</name> = (<name>PRUint32</name>) <name>size</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mFileMap</name> = <call><name>PR_CreateFileMap</name><argument_list>(<argument><expr><name>mFd</name></expr></argument>, <argument><expr><name>mFileLen</name></expr></argument>, <argument><expr><name>PR_PROT_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mFileMap</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mFileData</name> = (<name>PRUint8</name>*) <call><name>PR_MemMap</name><argument_list>(<argument><expr><name>mFileMap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>mFileLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mFileLen</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SOLARIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>madvise</name><argument_list>(<argument><expr><name>mFileData</name></expr></argument>, <argument><expr><name>mFileLen</name></expr></argument>, <argument><expr><name>MADV_WILLNEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>rv</name> = <call><name>ReadHeader</name><argument_list>(<argument><expr>&amp;<name>mHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>mHeader</name>.<name>mVersion</name></name> != <name>MFL_FILE_VERSION</name> ||
        <name><name>mHeader</name>.<name>mFooterOffset</name></name> == 0 || 
        <call><name>memcmp</name><argument_list>(<argument><expr><name><name>mHeader</name>.<name>mMagic</name></name></expr></argument>, <argument><expr><name>magic</name></expr></argument>, <argument><expr><name>MFL_FILE_MAGIC_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>
    
    <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name><name>mHeader</name>.<name>mFooterOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ReadFooter</name><argument_list>(<argument><expr>&amp;<name>mFooter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>Close</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Give up our strong "keepalive" references, in case not all objects that</comment>
    <comment type="line">// were deserialized were fully re-connected.</comment>
    <comment type="line">//</comment>
    <comment type="line">// This happens for sure when an nsFastLoadFileUpdater is created and wraps</comment>
    <comment type="line">// an nsFastLoadFileReader whose data was already deserialized by an earlier</comment>
    <comment type="line">// FastLoad episode.  The reader is useful in the second such episode during</comment>
    <comment type="line">// a session not so much for reading objects as for its footer information,</comment>
    <comment type="line">// which primes the updater's tables so that after the update completes, the</comment>
    <comment type="line">// FastLoad file has a superset footer.</comment>
    <if>if <condition>(<expr><name>mFd</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>mFileData</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>PR_MemUnmap</name><argument_list>(<argument><expr><name>mFileData</name></expr></argument>, <argument><expr><name>mFileLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>mFileData</name> = <name>nsnull</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mFileMap</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>PR_CloseFileMap</name><argument_list>(<argument><expr><name>mFileMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>mFileMap</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PR_Close</name><argument_list>(<argument><expr><name>mFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mFd</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr>!<name><name>mFooter</name>.<name>mObjectMap</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>n</name> <init>= <expr><name><name>mFooter</name>.<name>mNumSharpObjects</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsObjectMapEntry</name>*</type> <name>entry</name> <init>= <expr>&amp;<name><name>mFooter</name>.<name>mObjectMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mReadObject</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>mFooter</name>.<name>mNumSharpObjects</name></name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>DeserializeObject</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>* *</type><name>aObject</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>fastCID</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ReadFastID</name><argument_list>(<argument><expr>&amp;<name>fastCID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>nsID</name>&amp;</type> <name>slowCID</name> <init>= <expr><call><name><name>mFooter</name>.<name>GetID</name></name><argument_list>(<argument><expr><name>fastCID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>object</name><argument_list>(<argument><expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>slowCID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISerializable</name></expr></argument>&gt;</argument_list></name></type> <name>serializable</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>serializable</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>serializable</name>-&gt;<name>Read</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aObject</name> = <name>object</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadObject</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIsStrongRef</name></decl></param>, <param><decl><type><name>nsISupports</name>* *</type><name>aObject</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NSFastLoadOID</name></type> <name>oid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Read32</name><argument_list>(<argument><expr>&amp;<name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    <expr_stmt><expr><name>oid</name> ^= <name>MFL_OID_XOR_KEY</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>object</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>oid</name> == <name>MFL_DULL_OBJECT_OID</name></expr>)</condition><then> <block>{
        <comment type="line">// A very dull object, defined at point of single (strong) reference.</comment>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aIsStrongRef</name></expr></argument>, <argument><expr>"dull object read via weak ref!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>DeserializeObject</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>oid</name> &amp; <name>MFL_WEAK_REF_TAG</name>) ==
                     (<name>aIsStrongRef</name> ? 0 : <name>MFL_WEAK_REF_TAG</name>)</expr></argument>,
                     <argument><expr>"strong vs. weak ref deserialization mismatch!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>nsObjectMapEntry</name>*</type> <name>entry</name> <init>= <expr>&amp;<call><name><name>mFooter</name>.<name>GetSharpObjectEntry</name></name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check whether we've already deserialized the object for this OID.</comment>
        <expr_stmt><expr><name>object</name> = <name><name>entry</name>-&gt;<name>mReadObject</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>object</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>saveDocMapEntry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>PRUint32</name></type> <name>saveOffset32</name> <init>= <expr><name>mFilePos</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mCIDOffset</name></name> != <name>saveOffset32</name></expr>)</condition><then> <block>{
                <comment type="line">// We skipped deserialization of this object from its position</comment>
                <comment type="line">// earlier in the input stream, presumably due to the reference</comment>
                <comment type="line">// there being an nsFastLoadPtr, or (more likely) because the</comment>
                <comment type="line">// object was muxed in another document, and deserialization</comment>
                <comment type="line">// order does not match serialization order.  So we must seek</comment>
                <comment type="line">// back and read it now.</comment>
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mCIDOffset</name></name> &lt; <name>saveOffset32</name></expr></argument>,
                             <argument><expr>"out of order object?!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Ape our Seek wrapper by clearing mCurrentDocumentMapEntry.</comment>
                <comment type="line">// This allows for a skipped object to be referenced from two</comment>
                <comment type="line">// or more multiplexed documents in the FastLoad file.</comment>
                <expr_stmt><expr><name>saveDocMapEntry</name> = <name>mCurrentDocumentMapEntry</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>nsnull</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mCIDOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name>DeserializeObject</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mCIDOffset</name></name> != <name>saveOffset32</name></expr>)</condition><then> <block>{
                <comment type="line">// Save the "skip offset" in case we need to skip this object</comment>
                <comment type="line">// definition when reading forward, later on.</comment>
                <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSkipOffset</name></name> = <name>mFilePos</name></expr>;</expr_stmt>
                <comment type="line">// Restore stream offset and mCurrentDocumentMapEntry in case</comment>
                <comment type="line">// we're still reading forward through a part of the multiplex</comment>
                <comment type="line">// to get object definitions eagerly.</comment>
                <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name>saveOffset32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>saveDocMapEntry</name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// Save object until all refs have been deserialized.</comment>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mReadObject</name></name> = <name>object</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">// What if we are at a definition that's already been read?  This</comment>
            <comment type="line">// case arises when a sharp object's def is serialized before its</comment>
            <comment type="line">// refs, while a non-defining ref is deserialized before the def.</comment>
            <comment type="line">// We must skip over the object definition.</comment>
            <if>if <condition>(<expr><name>oid</name> &amp; <name>MFL_OBJECT_DEF_TAG</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mSkipOffset</name></name> != 0</expr></argument>, <argument><expr>"impossible! see above"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Since we are seeking within a muxed segment, we must adjust</comment>
                <comment type="line">// mBytesLeft, so that Seek called from Read will be triggered</comment>
                <comment type="line">// when mBytesLeft goes to zero.</comment>
                <decl_stmt><decl><type><name>PRUint32</name></type> <name>currentOffset</name> <init>= <expr><name>mFilePos</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mSkipOffset</name></name> &gt; (<name>PRUint32</name>)<name>currentOffset</name></expr></argument>,
                             <argument><expr>"skipping backwards from object?!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mCurrentDocumentMapEntry</name>-&gt;<name>mBytesLeft</name></name> &gt;=
                             <name><name>entry</name>-&gt;<name>mSkipOffset</name></name> - (<name>PRUint32</name>)<name>currentOffset</name></expr></argument>,
                             <argument><expr>"skipped object buffer underflow!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>mCurrentDocumentMapEntry</name>-&gt;<name>mBytesLeft</name></name> -=
                    <name><name>entry</name>-&gt;<name>mSkipOffset</name></name> - (<name>PRUint32</name>)<name>currentOffset</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mSkipOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>

        <if>if <condition>(<expr><name>aIsStrongRef</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mStrongRefCnt</name></name> != 0</expr></argument>,
                         <argument><expr>"mStrongRefCnt underflow!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>--<name><name>entry</name>-&gt;<name>mStrongRefCnt</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>MFL_GET_WEAK_REFCNT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> != 0</expr></argument>,
                         <argument><expr>"mWeakRefCnt underflow!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MFL_DROP_WEAK_REFCNT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mStrongRefCnt</name></name> == 0 &amp;&amp; <call><name>MFL_GET_WEAK_REFCNT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mReadObject</name></name> = <name>nsnull</name></expr>;</expr_stmt></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>oid</name> &amp; <name>MFL_QUERY_INTERFACE_TAG</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>iid</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ReadFastID</name><argument_list>(<argument><expr>&amp;<name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>object</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name><name>mFooter</name>.<name>GetID</name></name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>void</name>**</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr>*<name>aObject</name> = <name>object</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>ReadID</name></name><parameter_list>(<param><decl><type><name>nsID</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>fastID</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ReadFastID</name><argument_list>(<argument><expr>&amp;<name>fastID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <call><name><name>mFooter</name>.<name>GetID</name></name><argument_list>(<argument><expr><name>fastID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>Seek</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aWhence</name></decl></param>, <param><decl><type><name>PRInt64</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aWhence</name> == <name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>, <argument><expr>"Only NS_SEEK_SET seeks are supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SeekTo</name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>Tell</name></name><parameter_list>(<param><decl><type><name>PRInt64</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aResult</name> = <name>mFilePos</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileReader</name>::<name>SetEOF</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Refusing to truncate a memory-mapped file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<function><type><name>NS_COM</name> <name>nsresult</name></type>
<name>NS_NewFastLoadFileReader</name><parameter_list>(<param><decl><type><name>nsIObjectInputStream</name>* *</type><name>aResult</name></decl></param>, <param><decl><type><name>nsIFile</name> *</type><name>aFile</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsFastLoadFileReader</name>*</type> <name>reader</name> <init>= <expr>new <call><name>nsFastLoadFileReader</name><argument_list>(<argument><expr><name>aFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>reader</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// Stabilize reader's refcnt.</comment>
    <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObjectInputStream</name></expr></argument>&gt;</argument_list></name></type> <name>stream</name><parameter_list>(<param><decl><type><name>reader</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>reader</name>-&gt;<name>Open</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>stream</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// -------------------------- nsFastLoadFileWriter --------------------------</comment>

<macro><name>NS_IMPL_ISUPPORTS_INHERITED4</name><argument_list>(<argument>nsFastLoadFileWriter</argument>,
                             <argument>nsBinaryOutputStream</argument>,
                             <argument>nsIObjectOutputStream</argument>,
                             <argument>nsIFastLoadFileControl</argument>,
                             <argument>nsIFastLoadWriteControl</argument>,
                             <argument>nsISeekableStream</argument>)</argument_list></macro>

<struct>struct <name>nsIDMapEntry</name> <super>: <specifier>public</specifier> <name>PLDHashEntryHdr</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>NSFastLoadID</name></type>    <name>mFastID</name></decl>;</decl_stmt>            <comment type="line">// 1 + nsFastLoadFooter::mIDMap index</comment>
    <decl_stmt><decl><type><name>nsID</name></type>            <name>mSlowID</name></decl>;</decl_stmt>            <comment type="line">// key, used by PLDHashTableOps below</comment>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PLDHashNumber</name></type>
<name>idmap_HashKey</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>aKey</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsID</name> *</type><name>idp</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsID</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><name><name>idp</name>-&gt;<name>m0</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>idmap_MatchEntry</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>aKey</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsIDMapEntry</name>*</type> <name>entry</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsIDMapEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsID</name> *</type><name>idp</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsID</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>mSlowID</name></name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PLDHashTableOps</name></type> <name>idmap_DHashTableOps</name> <init>= <expr><block>{
    <expr><name>PL_DHashAllocTable</name></expr>,
    <expr><name>PL_DHashFreeTable</name></expr>,
    <expr><name>idmap_HashKey</name></expr>,
    <expr><name>idmap_MatchEntry</name></expr>,
    <expr><name>PL_DHashMoveEntryStub</name></expr>,
    <expr><name>PL_DHashClearEntryStub</name></expr>,
    <expr><name>PL_DHashFinalizeStub</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>MapID</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsID</name>&amp;</type> <name>aSlowID</name></decl></param>, <param><decl><type><name>NSFastLoadID</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsIDMapEntry</name>*</type> <name>entry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIDMapEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mIDMap</name></expr></argument>, <argument><expr>&amp;<name>aSlowID</name></expr></argument>, <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>mFastID</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mFastID</name></name> = <name><name>mIDMap</name>.<name>entryCount</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mSlowID</name></name> = <name>aSlowID</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name><name>entry</name>-&gt;<name>mFastID</name></name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteHeader</name></name><parameter_list>(<param><decl><type><name>nsFastLoadHeader</name> *</type><name>aHeader</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>bytesWritten</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Write</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mMagic</name></name></expr></argument>, <argument><expr><name>MFL_FILE_MAGIC_SIZE</name></expr></argument>, <argument><expr>&amp;<name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>bytesWritten</name> != <name>MFL_FILE_MAGIC_SIZE</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mChecksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mFooterOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aHeader</name>-&gt;<name>mFileSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsIFastLoadFileControl methods:</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>GetChecksum</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>aChecksum</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>mHeader</name>.<name>mChecksum</name></name> == 0</expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>aChecksum</name> = <name><name>mHeader</name>.<name>mChecksum</name></name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<struct>struct <name>nsDocumentMapWriteEntry</name> <super>: <specifier>public</specifier> <name>nsDocumentMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>PRUint32</name></type>    <name>mCurrentSegmentOffset</name></decl>;</decl_stmt>      <comment type="line">// last written segment's offset</comment>
</public>}</block>;</struct>

<comment type="line">// Fast mapping from URI object pointer back to spec-indexed document info.</comment>
<comment type="line">// We also may need the slow mapping from mURISpec to nsDocumentMapWriteEntry,</comment>
<comment type="line">// because the writer's mDocumentMap double hash table may grow "behind the</comment>
<comment type="line">// back of" each mURIMap entry's mDocMapEntry member.</comment>
<struct>struct <name>nsURIMapWriteEntry</name> <super>: <specifier>public</specifier> <name>nsObjectMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>mDocMapEntry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type>                 <name>mGeneration</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type>              <name>mURISpec</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>HasMuxedDocument</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aURISpec</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>docMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mDocumentMap</name></expr></argument>, <argument><expr><name>aURISpec</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>aResult</name> = <call><name>PL_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr><name>docMapEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>StartMuxedDocument</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aURI</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aURISpec</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Save mDocumentMap table generation and mCurrentDocumentMapEntry key in</comment>
    <comment type="line">// case the hash table grows during the PL_DHASH_ADD operation.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>saveGeneration</name> <init>= <expr><name><name>mDocumentMap</name>.<name>generation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>saveURISpec</name> <init>= <expr><name>mCurrentDocumentMapEntry</name>
                              ? <name><name>mCurrentDocumentMapEntry</name>-&gt;<name>mString</name></name>
                              : <name>nsnull</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>docMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mDocumentMap</name></expr></argument>, <argument><expr><name>aURISpec</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>docMapEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// If the generation number changed, refresh mCurrentDocumentMapEntry.</comment>
    <if>if <condition>(<expr><name>mCurrentDocumentMapEntry</name> &amp;&amp; <name><name>mDocumentMap</name>.<name>generation</name></name> != <name>saveGeneration</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> =
            <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mDocumentMap</name></expr></argument>, <argument><expr><name>saveURISpec</name></expr></argument>,
                                             <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>PL_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr><name>mCurrentDocumentMapEntry</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr>"mCurrentDocumentMapEntry lost during table growth?!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Refresh saveGeneration for use below when initializing uriMapEntry.</comment>
        <expr_stmt><expr><name>saveGeneration</name> = <name><name>mDocumentMap</name>.<name>generation</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>NS_WARN_IF_FALSE</name><argument_list>(<argument><expr><name><name>docMapEntry</name>-&gt;<name>mString</name></name> == <name>nsnull</name></expr></argument>,
                     <argument><expr>"redundant multiplexed document?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>docMapEntry</name>-&gt;<name>mString</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>void</name>*</type> <name>spec</name> <init>= <expr><call><name><name>nsMemory</name>::<name>Clone</name></name><argument_list>(<argument><expr><name>aURISpec</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>aURISpec</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>spec</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>docMapEntry</name>-&gt;<name>mString</name></name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>docMapEntry</name>-&gt;<name>mURI</name></name> = <name>aURI</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name><name>docMapEntry</name>-&gt;<name>mURI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>key</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsURIMapWriteEntry</name>*</type> <name>uriMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsURIMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>uriMapEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name> == <name>nsnull</name></expr></argument>,
                 <argument><expr>"URI mapped to two different specs?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mObject</name></name> = <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name><name>uriMapEntry</name>-&gt;<name>mObject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name> = <name>docMapEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mGeneration</name></name> = <name>saveGeneration</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mURISpec</name></name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('w', "start %p (%p) %s\n", <name>aURI</name>, <call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>aURISpec</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>SelectMuxedDocument</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aURI</name></decl></param>,
                                          <param><decl><type><name>nsISupports</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Capture the current file offset (XXXbe maintain our own via Write?)</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt64</name></type> <name>currentSegmentOffset</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Tell</name></name><argument_list>(<argument><expr>&amp;<name>currentSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>currentSegmentOffset32</name> <init>= <expr><name>currentSegmentOffset</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Look for an existing entry keyed by aURI, added by StartMuxedDocument.</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>key</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsURIMapWriteEntry</name>*</type> <name>uriMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsURIMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>PL_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"SelectMuxedDocument without prior StartMuxedDocument?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>PL_DHASH_ENTRY_IS_FREE</name><argument_list>(<argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <comment type="line">// Beware that uriMapEntry-&gt;mDocMapEntry may be stale, if an mDocumentMap</comment>
    <comment type="line">// addition caused that table to grow.  We save the mDocumentMap generation</comment>
    <comment type="line">// in each uriMapEntry and compare it to the current generation, rehashing</comment>
    <comment type="line">// uriMapEntry-&gt;mURISpec if necessary.</comment>

    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>docMapEntry</name> <init>= <expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>uriMapEntry</name>-&gt;<name>mGeneration</name></name> != <name><name>mDocumentMap</name>.<name>generation</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>docMapEntry</name> =
            <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mDocumentMap</name></expr></argument>,
                                             <argument><expr><name><name>uriMapEntry</name>-&gt;<name>mURISpec</name></name></expr></argument>,
                                             <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>PL_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr><name>docMapEntry</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"lost mDocMapEntry!?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name> = <name>docMapEntry</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uriMapEntry</name>-&gt;<name>mGeneration</name></name> = <name><name>mDocumentMap</name>.<name>generation</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// If there is a muxed document segment open, close it now by setting its</comment>
    <comment type="line">// length, stored in the second PRUint32 of the segment.</comment>
    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>prevDocMapEntry</name> <init>= <expr><name>mCurrentDocumentMapEntry</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>prevDocMapEntry</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>prevDocMapEntry</name> == <name>docMapEntry</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('w', "select prev %s same as current!\n",
                       <name><name>prevDocMapEntry</name>-&gt;<name>mString</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>aResult</name> = <name><name>docMapEntry</name>-&gt;<name>mURI</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>PRUint32</name></type> <name>prevSegmentOffset</name> <init>= <expr><name><name>prevDocMapEntry</name>-&gt;<name>mCurrentSegmentOffset</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('w', "select prev %s offset %lu\n",
                   <name><name>prevDocMapEntry</name>-&gt;<name>mString</name></name>, <name>prevSegmentOffset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                   <argument><expr><name>prevSegmentOffset</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <comment type="line">// The length counts all bytes in the segment, including the header</comment>
        <comment type="line">// that contains [nextSegmentOffset, length].</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name>currentSegmentOffset32</name> - <name>prevSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <comment type="line">// Seek back to the current offset only if we are not going to seek</comment>
        <comment type="line">// back to *this* entry's last "current" segment offset and write its</comment>
        <comment type="line">// next segment offset at the first PRUint32 of the segment.</comment>
        <if>if <condition>(<expr>!<name><name>docMapEntry</name>-&gt;<name>mInitialSegmentOffset</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                       <argument><expr><name>currentSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// If this entry was newly added, set its key and initial segment offset.</comment>
    <comment type="line">// Otherwise, seek back to write the next segment offset of the previous</comment>
    <comment type="line">// segment for this document in the multiplex.</comment>
    <if>if <condition>(<expr>!<name><name>docMapEntry</name>-&gt;<name>mInitialSegmentOffset</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>docMapEntry</name>-&gt;<name>mInitialSegmentOffset</name></name> = <name>currentSegmentOffset32</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                   <argument><expr><name><name>docMapEntry</name>-&gt;<name>mCurrentSegmentOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name>currentSegmentOffset32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                   <argument><expr><name>currentSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></else></if>

    <comment type="line">// Update this document's current segment offset so we can later fix its</comment>
    <comment type="line">// next segment offset (unless it is last, in which case we leave the zero</comment>
    <comment type="line">// placeholder as a terminator).</comment>
    <expr_stmt><expr><name><name>docMapEntry</name>-&gt;<name>mCurrentSegmentOffset</name></name> = <name>currentSegmentOffset32</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="line">// nextSegmentOffset placeholder</comment>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="line">// length placeholder</comment>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>prevDocMapEntry</name> ? <name><name>prevDocMapEntry</name>-&gt;<name>mURI</name></name> : <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>docMapEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('w', "select %p (%p) offset %lu\n",
               <name>aURI</name>, <call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>currentSegmentOffset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>EndMuxedDocument</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aURI</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>key</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsURIMapWriteEntry</name>*</type> <name>uriMapEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsURIMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>PL_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the URI isn't in the map, nsFastLoadFileWriter::StartMuxedDocument</comment>
    <comment type="line">// must have been called with a redundant URI, *and* its caller must have</comment>
    <comment type="line">// ignored the NS_ERROR_UNEXPECTED it returned in that case.</comment>
    <if>if <condition>(<expr><call><name>PL_DHASH_ENTRY_IS_FREE</name><argument_list>(<argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('w', "bad end %p (%p)\n", <name>aURI</name>, <call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Drop our ref to the URI object that was passed to StartMuxedDocument,</comment>
    <comment type="line">// we no longer need it, and we do not want to extend its lifetime.</comment>
    <if>if <condition>(<expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name><name>uriMapEntry</name>-&gt;<name>mDocMapEntry</name>-&gt;<name>mURI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Shrink the table if half the entries are removed sentinels.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>size</name> <init>= <expr><call><name>PL_DHASH_TABLE_SIZE</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>mURIMap</name>.<name>removedCount</name></name> &gt;= (<name>size</name> &gt;&gt; 2)</expr>)</condition><then>
        <expr_stmt><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>PL_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>PL_DHashTableRawRemove</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>, <argument><expr><name>uriMapEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><call><name>TRACE_MUX</name><argument_list>(<argument><expr>('w', "end %p (%p)\n", <name>aURI</name>, <call><name><name>key</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<struct>struct <name>nsDependencyMapEntry</name> <super>: <specifier>public</specifier> <name>nsStringMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>PRInt64</name></type> <name>mLastModified</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>AddDependency</name></name><parameter_list>(<param><decl><type><name>nsIFile</name>*</type> <name>aFile</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aFile</name>-&gt;<name>GetNativePath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsDependencyMapEntry</name>*</type> <name>entry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDependencyMapEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mDependencyMap</name></expr></argument>, <argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                         <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name><name>entry</name>-&gt;<name>mString</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>ToNewCString</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mString</name></name> = <name>tmp</name></expr>;</expr_stmt>

        <comment type="line">// If we can't get the last modified time from aFile, assume it does</comment>
        <comment type="line">// not exist, or is otherwise inaccessible to us (due to permissions),</comment>
        <comment type="line">// remove the dependency, and suppress the failure.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Otherwise, we would end up aborting the fastload process due to a</comment>
        <comment type="line">// missing .js or .xul or other file on every startup.</comment>

        <expr_stmt><expr><name>rv</name> = <call><name><name>aFile</name>-&gt;<name>GetLastModifiedTime</name></name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>mLastModified</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mDependencyMap</name></expr></argument>, <argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PL_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteFooterPrefix</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsFastLoadFooterPrefix</name>&amp;</type> <name>aFooterPrefix</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aFooterPrefix</name>.<name>mNumIDs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aFooterPrefix</name>.<name>mNumSharpObjects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aFooterPrefix</name>.<name>mNumMuxedDocuments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aFooterPrefix</name>.<name>mNumDependencies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteSlowID</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsID</name>&amp;</type> <name>aID</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aID</name>.<name>m0</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write16</name><argument_list>(<argument><expr><name><name>aID</name>.<name>m1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write16</name><argument_list>(<argument><expr><name><name>aID</name>.<name>m2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>bytesWritten</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>Write</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>aID</name>.<name>m3</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>sizeof <name><name>aID</name>.<name>m3</name></name></expr></argument>,
               <argument><expr>&amp;<name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>bytesWritten</name> != sizeof <name><name>aID</name>.<name>m3</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteFastID</name></name><parameter_list>(<param><decl><type><name>NSFastLoadID</name></type> <name>aID</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>Write32</name><argument_list>(<argument><expr><name>aID</name> ^ <name>MFL_ID_XOR_KEY</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteSharpObjectInfo</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsFastLoadSharpObjectInfo</name>&amp;</type> <name>aInfo</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aInfo</name>.<name>mCIDOffset</name></name> != 0</expr></argument>,
                 <argument><expr>"fastload writer: mCIDOffset cannot be zero!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aInfo</name>.<name>mCIDOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write16</name><argument_list>(<argument><expr><name><name>aInfo</name>.<name>mStrongRefCnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write16</name><argument_list>(<argument><expr><name><name>aInfo</name>.<name>mWeakRefCnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteMuxedDocumentInfo</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsFastLoadMuxedDocumentInfo</name>&amp;</type> <name>aInfo</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>WriteStringZ</name><argument_list>(<argument><expr><name><name>aInfo</name>.<name>mURISpec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>aInfo</name>.<name>mInitialSegmentOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PLDHashOperator</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>IDMapEnumerate</name></name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>,
                                     <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>,
                                     <param><decl><type><name>PRUint32</name></type> <name>aNumber</name></decl></param>,
                                     <param><decl><type><name>void</name> *</type><name>aData</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsIDMapEntry</name>*</type> <name>entry</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIDMapEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr><name><name>entry</name>-&gt;<name>mFastID</name></name> - 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsID</name>*</type> <name>vector</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsID</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>index</name> &lt; <name><name>aTable</name>-&gt;<name>entryCount</name></name></expr></argument>, <argument><expr>"bad nsIDMap index!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vector</name><index>[<expr><name>index</name></expr>]</index></name> = <name><name>entry</name>-&gt;<name>mSlowID</name></name></expr>;</expr_stmt>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<struct>struct <name>nsSharpObjectMapEntry</name> <super>: <specifier>public</specifier> <name>nsObjectMapEntry</name></super> <block>{<public type="default">
    <decl_stmt><decl><type><name>NSFastLoadOID</name></type>               <name>mOID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsFastLoadSharpObjectInfo</name></type>   <name>mInfo</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>PLDHashOperator</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>ObjectMapEnumerate</name></name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>,
                                         <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>,
                                         <param><decl><type><name>PRUint32</name></type> <name>aNumber</name></decl></param>,
                                         <param><decl><type><name>void</name> *</type><name>aData</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsSharpObjectMapEntry</name>*</type> <name>entry</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsSharpObjectMapEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr><call><name>MFL_OID_TO_SHARP_INDEX</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mOID</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsFastLoadSharpObjectInfo</name>*</type> <name>vector</name> <init>=
        <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsFastLoadSharpObjectInfo</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>index</name> &lt; <name><name>aTable</name>-&gt;<name>entryCount</name></name></expr></argument>, <argument><expr>"bad nsObjectMap index!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vector</name><index>[<expr><name>index</name></expr>]</index></name> = <name><name>entry</name>-&gt;<name>mInfo</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mInfo</name>.<name>mStrongRefCnt</name></name></expr></argument>, <argument><expr>"no strong ref in serialization!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Ignore tagged object ids stored as object pointer keys (the updater</comment>
    <comment type="line">// code does this).</comment>
    <if>if <condition>(<expr>(<call><name>NS_PTR_TO_INT32</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mObject</name></name></expr></argument>)</argument_list></call> &amp; <name>MFL_OBJECT_DEF_TAG</name>) == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mObject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>PLDHashOperator</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>DocumentMapEnumerate</name></name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>,
                                           <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>,
                                           <param><decl><type><name>PRUint32</name></type> <name>aNumber</name></decl></param>,
                                           <param><decl><type><name>void</name> *</type><name>aData</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsFastLoadFileWriter</name>*</type> <name>writer</name> <init>=
        <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsFastLoadFileWriter</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>aTable</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>entry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name>*</type> <name>rvp</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsresult</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsFastLoadMuxedDocumentInfo</name></type> <name>info</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>info</name>.<name>mURISpec</name></name> = <name><name>entry</name>-&gt;<name>mString</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name>.<name>mInitialSegmentOffset</name></name> = <name><name>entry</name>-&gt;<name>mInitialSegmentOffset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>rvp</name> = <call><name><name>writer</name>-&gt;<name>WriteMuxedDocumentInfo</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>NS_FAILED</name><argument_list>(<argument><expr>*<name>rvp</name></expr></argument>)</argument_list></call> ? <name>PL_DHASH_STOP</name> : <name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>PLDHashOperator</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>DependencyMapEnumerate</name></name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>,
                                             <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>,
                                             <param><decl><type><name>PRUint32</name></type> <name>aNumber</name></decl></param>,
                                             <param><decl><type><name>void</name> *</type><name>aData</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsFastLoadFileWriter</name>*</type> <name>writer</name> <init>=
        <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsFastLoadFileWriter</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>aTable</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsDependencyMapEntry</name>*</type> <name>entry</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDependencyMapEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name>*</type> <name>rvp</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsresult</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>rvp</name> = <call><name><name>writer</name>-&gt;<name>WriteStringZ</name></name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr>*<name>rvp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>*<name>rvp</name> = <call><name><name>writer</name>-&gt;<name>Write64</name></name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mLastModified</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>NS_FAILED</name><argument_list>(<argument><expr>*<name>rvp</name></expr></argument>)</argument_list></call> ? <name>PL_DHASH_STOP</name> :<name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteFooter</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsFastLoadFooterPrefix</name></type> <name>footerPrefix</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>footerPrefix</name>.<name>mNumIDs</name></name> = <name><name>mIDMap</name>.<name>entryCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>footerPrefix</name>.<name>mNumSharpObjects</name></name> = <name><name>mObjectMap</name>.<name>entryCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>footerPrefix</name>.<name>mNumMuxedDocuments</name></name> = <name><name>mDocumentMap</name>.<name>entryCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>footerPrefix</name>.<name>mNumDependencies</name></name> = <name><name>mDependencyMap</name>.<name>entryCount</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>WriteFooterPrefix</name><argument_list>(<argument><expr><name>footerPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Enumerate mIDMap into a vector indexed by mFastID and write it.</comment>
    <decl_stmt><decl><type><name>nsID</name>*</type> <name>idvec</name> <init>= <expr>new <name><name>nsID</name><index>[<expr><name><name>footerPrefix</name>.<name>mNumIDs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>idvec</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><name>count</name> = <call><name>PL_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name>mIDMap</name></expr></argument>, <argument><expr><name>IDMapEnumerate</name></expr></argument>, <argument><expr><name>idvec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>count</name> == <name><name>footerPrefix</name>.<name>mNumIDs</name></name></expr></argument>, <argument><expr>"bad mIDMap enumeration!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>WriteSlowID</name><argument_list>(<argument><expr><name><name>idvec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>

    <expr_stmt><expr>delete<index>[]</index> <name>idvec</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Enumerate mObjectMap into a vector indexed by mOID and write it.</comment>
    <decl_stmt><decl><type><name>nsFastLoadSharpObjectInfo</name>*</type> <name>objvec</name> <init>=
        <expr>new <name><name>nsFastLoadSharpObjectInfo</name><index>[<expr><name><name>footerPrefix</name>.<name>mNumSharpObjects</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>objvec</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>objvec</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>footerPrefix</name>.<name>mNumSharpObjects</name></name> *
                      <sizeof>sizeof<argument_list>(<argument><expr><name>nsFastLoadSharpObjectInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>count</name> = <call><name>PL_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name>mObjectMap</name></expr></argument>, <argument><expr><name>ObjectMapEnumerate</name></expr></argument>, <argument><expr><name>objvec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>count</name> == <name><name>footerPrefix</name>.<name>mNumSharpObjects</name></name></expr></argument>,
                 <argument><expr>"bad mObjectMap enumeration!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>WriteSharpObjectInfo</name><argument_list>(<argument><expr><name><name>objvec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>

    <expr_stmt><expr>delete<index>[]</index> <name>objvec</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Enumerate mDocumentMap, writing nsFastLoadMuxedDocumentInfo records</comment>
    <expr_stmt><expr><name>count</name> = <call><name>PL_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name>mDocumentMap</name></expr></argument>, <argument><expr><name>DocumentMapEnumerate</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>count</name> == <name><name>footerPrefix</name>.<name>mNumMuxedDocuments</name></name></expr></argument>,
                 <argument><expr>"bad mDocumentMap enumeration!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Write out make-like file dependencies.</comment>
    <expr_stmt><expr><name>count</name> = <call><name>PL_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name>mDependencyMap</name></expr></argument>, <argument><expr><name>DependencyMapEnumerate</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>Init</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>mIDMap</name></expr></argument>, <argument><expr>&amp;<name>idmap_DHashTableOps</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsIDMapEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PL_DHASH_MIN_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>mIDMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>mObjectMap</name></expr></argument>, <argument><expr>&amp;<name>objmap_DHashTableOps</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsSharpObjectMapEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PL_DHASH_MIN_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>mObjectMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>mDocumentMap</name></expr></argument>, <argument><expr>&amp;<name>strmap_DHashTableOps</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsDocumentMapWriteEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                           <argument><expr><name>PL_DHASH_MIN_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>mDocumentMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>mURIMap</name></expr></argument>, <argument><expr>&amp;<name>objmap_DHashTableOps</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsURIMapWriteEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PL_DHASH_MIN_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>mURIMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>mDependencyMap</name></expr></argument>, <argument><expr>&amp;<name>strmap_DHashTableOps</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>this</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsDependencyMapEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PL_DHASH_MIN_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>mDependencyMap</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>Open</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name>Init</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MFL_CHECKSUM_BUFSIZE</name></cpp:macro>    <cpp:value>(6 * 8192)</cpp:value></cpp:define>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>Close</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>mHeader</name>.<name>mMagic</name></name></expr></argument>, <argument><expr><name>magic</name></expr></argument>, <argument><expr><name>MFL_FILE_MAGIC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mHeader</name>.<name>mChecksum</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mHeader</name>.<name>mVersion</name></name> = <name>MFL_FILE_VERSION</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRInt64</name></type> <name>footerOffset</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Tell</name></name><argument_list>(<argument><expr>&amp;<name>footerOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LL_L2UI</name><argument_list>(<argument><expr><name><name>mHeader</name>.<name>mFooterOffset</name></name></expr></argument>, <argument><expr><name>footerOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// If there is a muxed document segment open, close it now by setting its</comment>
    <comment type="line">// length, stored in the second PRUint32 of the segment.</comment>
    <if>if <condition>(<expr><name>mCurrentDocumentMapEntry</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>currentSegmentOffset</name> <init>=
            <expr><name><name>mCurrentDocumentMapEntry</name>-&gt;<name>mCurrentSegmentOffset</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                   <argument><expr><name>currentSegmentOffset</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name><name>mHeader</name>.<name>mFooterOffset</name></name> - <name>currentSegmentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <comment type="line">// Seek back to the current offset to write the footer.</comment>
        <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                   <argument><expr><name><name>mHeader</name>.<name>mFooterOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>WriteFooter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>PRInt64</name></type> <name>fileSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Tell</name></name><argument_list>(<argument><expr>&amp;<name>fileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LL_L2UI</name><argument_list>(<argument><expr><name><name>mHeader</name>.<name>mFileSize</name></name></expr></argument>, <argument><expr><name>fileSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>WriteHeader</name><argument_list>(<argument><expr>&amp;<name>mHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Now compute the checksum, using mFileIO to get an input stream on the</comment>
    <comment type="line">// underlying FastLoad file.</comment>
    <if>if <condition>(<expr><name>mFileIO</name></expr>)</condition><then> <block>{
        <comment type="line">// Get the unbuffered output stream, which flushes the buffered header</comment>
        <comment type="line">// so we can read and checksum it along with the rest of the file, and</comment>
        <comment type="line">// which allows us to write the checksum directly.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIOutputStream</name></expr></argument>&gt;</argument_list></name></type> <name>output</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>mBufferAccess</name>-&gt;<name>GetUnbufferedStream</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || !<name>output</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInputStream</name></expr></argument>&gt;</argument_list></name></type> <name>input</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>mFileIO</name>-&gt;<name>GetInputStream</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
 
        <comment type="line">// Seek the input stream to right after checksum/magic.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISeekableStream</name></expr></argument>&gt;</argument_list></name></type> <name>seekable</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>seekable</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                            <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>, <argument><expr><name>mVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MFL_CHECKSUM_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>rem</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>checksum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <comment type="line">// Ok, we're finally ready to checksum the FastLoad file we just wrote!</comment>
        <while>while <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name> =
                            <call><name><name>input</name>-&gt;<name>Read</name></name><argument_list>(<argument><expr><name>buf</name> + <name>rem</name></expr></argument>, <argument><expr>sizeof <name>buf</name> - <name>rem</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
               <name>len</name></expr>)</condition> <block>{
            <expr_stmt><expr><name>len</name> += <name>rem</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rem</name> = <call><name>NS_AccumulateFastLoadChecksum</name><argument_list>(<argument><expr>&amp;<name>checksum</name></expr></argument>,
                                                <argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>PRUint8</name>*</expr></argument>&gt;</argument_list></name>
                                                                <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>len</name></expr></argument>,
                                                <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rem</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> + <name>len</name> - <name>rem</name></expr></argument>, <argument><expr><name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></while>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>rem</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_AccumulateFastLoadChecksum</name><argument_list>(<argument><expr>&amp;<name>checksum</name></expr></argument>,
                                          <argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>PRUint8</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>rem</name></expr></argument>,
                                          <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// Store the checksum in the FastLoad file header and remember it via</comment>
        <comment type="line">// mHeader.mChecksum, for GetChecksum.</comment>
        <expr_stmt><expr><name>seekable</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>seekable</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                            <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>, <argument><expr><name>mChecksum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>mHeader</name>.<name>mChecksum</name></name> = <name>checksum</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>checksum</name> = <call><name>NS_SWAP32</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>bytesWritten</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>output</name>-&gt;<name>Write</name></name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>&amp;<name>checksum</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr>sizeof <name>checksum</name></expr></argument>,
                           <argument><expr>&amp;<name>bytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>bytesWritten</name> != sizeof <name>checksum</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><call><name><name>mOutputStream</name>-&gt;<name>Close</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Pseudo-tag used as flag between WriteSingleRefObject and WriteObjectCommon.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MFL_SINGLE_REF_PSEUDO_TAG</name></cpp:macro>       <cpp:value>PR_BIT(MFL_OBJECT_TAG_BITS)</cpp:value></cpp:define>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteObjectCommon</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aObject</name></decl></param>,
                                        <param><decl><type><name>PRBool</name></type> <name>aIsStrongRef</name></decl></param>,
                                        <param><decl><type><name>PRUint32</name></type> <name>aTags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsrefcnt</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<call><name>NS_PTR_TO_INT32</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call> &amp; <name>MFL_OBJECT_DEF_TAG</name>) == 0</expr></argument>,
                 <argument><expr>"odd nsISupports*, oh no!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Here be manual refcounting dragons!</comment>
    <expr_stmt><expr><name>rc</name> = <call><name><name>aObject</name>-&gt;<name>AddRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rc</name> != 0</expr></argument>, <argument><expr>"bad refcnt when writing aObject!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>NSFastLoadOID</name></type> <name>oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIClassInfo</name></expr></argument>&gt;</argument_list></name></type> <name>classInfo</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>rc</name> == 2 &amp;&amp; (<name>aTags</name> &amp; <name>MFL_SINGLE_REF_PSEUDO_TAG</name>)</expr>)</condition><then> <block>{
        <comment type="line">// Dull object: only one strong ref and no weak refs in serialization.</comment>
        <comment type="line">// Conservative: we don't trust the caller if there are more than two</comment>
        <comment type="line">// refs (one from the AddRef above, one from the data structure that's</comment>
        <comment type="line">// being serialized).</comment>
        <expr_stmt><expr><name>oid</name> = <name>MFL_DULL_OBJECT_OID</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>aObject</name>-&gt;<name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// Object is presumed to be multiply connected through some combo of</comment>
        <comment type="line">// strong and weak refs.  Hold onto it via mObjectMap.</comment>
        <decl_stmt><decl><type><name>nsSharpObjectMapEntry</name>*</type> <name>entry</name> <init>=
            <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsSharpObjectMapEntry</name>*</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mObjectMap</name></expr></argument>, <argument><expr><name>aObject</name></expr></argument>,
                                             <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>aObject</name>-&gt;<name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>!<name><name>entry</name>-&gt;<name>mObject</name></name></expr>)</condition><then> <block>{
            <comment type="line">// First time we've seen this object address: add it to mObjectMap</comment>
            <comment type="line">// and serialize the object at the current stream offset.</comment>
            <decl_stmt><decl><type><name>PRInt64</name></type> <name>thisOffset</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>Tell</name><argument_list>(<argument><expr>&amp;<name>thisOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>aObject</name>-&gt;<name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <comment type="line">// NB: aObject was already held, and mObject is a raw nsISupports*.</comment>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mObject</name></name> = <name>aObject</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>oid</name> = (<name><name>mObjectMap</name>.<name>entryCount</name></name> &lt;&lt; <name>MFL_OBJECT_TAG_BITS</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mOID</name></name> = <name>oid</name></expr>;</expr_stmt>

            <comment type="line">// NB: the (32-bit, fast) CID and object data follow the OID.</comment>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mInfo</name>.<name>mCIDOffset</name></name> = <name>thisOffset</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mInfo</name>.<name>mStrongRefCnt</name></name> = <name>aIsStrongRef</name> ? 1 : 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>mInfo</name>.<name>mWeakRefCnt</name></name>   = <name>aIsStrongRef</name> ? 0 : 1</expr>;</expr_stmt>

            <comment type="line">// Record in oid the fact that we're defining this object in the</comment>
            <comment type="line">// stream, and get the object's class info here, so we can take</comment>
            <comment type="line">// note of singletons in order to avoid reserializing them when</comment>
            <comment type="line">// updating after reading.</comment>
            <expr_stmt><expr><name>oid</name> |= <name>MFL_OBJECT_DEF_TAG</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>classInfo</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>classInfo</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"aObject must implement nsIClassInfo"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>PRUint32</name></type> <name>flags</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>classInfo</name>-&gt;<name>GetFlags</name></name><argument_list>(<argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
                (<name>flags</name> &amp; <name><name>nsIClassInfo</name>::<name>SINGLETON</name></name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>MFL_SET_SINGLETON_FLAG</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>mInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <comment type="line">// Already serialized, recover oid and update the desired refcnt.</comment>
            <expr_stmt><expr><name>oid</name> = <name><name>entry</name>-&gt;<name>mOID</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>aIsStrongRef</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>++<name><name>entry</name>-&gt;<name>mInfo</name>.<name>mStrongRefCnt</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>mInfo</name>.<name>mStrongRefCnt</name></name> != 0</expr></argument>,
                             <argument><expr>"mStrongRefCnt overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>MFL_BUMP_WEAK_REFCNT</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>mInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>MFL_GET_WEAK_REFCNT</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>mInfo</name></name></expr></argument>)</argument_list></call> != 0</expr></argument>,
                             <argument><expr>"mWeakRefCnt overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name><name>aObject</name>-&gt;<name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>aIsStrongRef</name></expr>)</condition><then>
        <expr_stmt><expr><name>oid</name> |= <name>MFL_WEAK_REF_TAG</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>oid</name> |= (<name>aTags</name> &amp; <name>MFL_QUERY_INTERFACE_TAG</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr><name>oid</name> ^ <name>MFL_OID_XOR_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>oid</name> &amp; <name>MFL_OBJECT_DEF_TAG</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISerializable</name></expr></argument>&gt;</argument_list></name></type> <name>serializable</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>serializable</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"aObject must implement nsISerializable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>nsCID</name></type> <name>slowCID</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>classInfo</name>-&gt;<name>GetClassIDNoAlloc</name></name><argument_list>(<argument><expr>&amp;<name>slowCID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>fastCID</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>MapID</name><argument_list>(<argument><expr><name>slowCID</name></expr></argument>, <argument><expr>&amp;<name>fastCID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>WriteFastID</name><argument_list>(<argument><expr><name>fastCID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>serializable</name>-&gt;<name>Write</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteObject</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aObject</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsStrongRef</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>rootObject</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>rootObject</name>.<name>get</name></name><argument_list>()</argument_list></call> == <name>aObject</name></expr></argument>,
                 <argument><expr>"bad call to WriteObject -- call WriteCompoundObject!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>WriteObjectCommon</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>, <argument><expr><name>aIsStrongRef</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteSingleRefObject</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aObject</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>rootObject</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>rootObject</name>.<name>get</name></name><argument_list>()</argument_list></call> == <name>aObject</name></expr></argument>,
                 <argument><expr>"bad call to WriteSingleRefObject -- call WriteCompoundObject!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>WriteObjectCommon</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>MFL_SINGLE_REF_PSEUDO_TAG</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteCompoundObject</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>aObject</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>aIID</name></decl></param>,
                                          <param><decl><type><name>PRBool</name></type> <name>aIsStrongRef</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>rootObject</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    
    <comment type="line">// We could assert that |rootObject != aObject|, but that would prevent</comment>
    <comment type="line">// callers who don't know whether they're dealing with the primary</comment>
    <comment type="line">// nsISupports pointer (e.g., they don't know which implementation of</comment>
    <comment type="line">// nsIURI they have) from using this function.</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>roundtrip</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>rootObject</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><name>aIID</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>roundtrip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>roundtrip</name>.<name>get</name></name><argument_list>()</argument_list></call> == <name>aObject</name></expr></argument>,
                 <argument><expr>"bad aggregation or multiple inheritance detected by call to "
                 "WriteCompoundObject!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>rv</name> = <call><name>WriteObjectCommon</name><argument_list>(<argument><expr><name>rootObject</name></expr></argument>, <argument><expr><name>aIsStrongRef</name></expr></argument>, <argument><expr><name>MFL_QUERY_INTERFACE_TAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>iid</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>MapID</name><argument_list>(<argument><expr><name>aIID</name></expr></argument>, <argument><expr>&amp;<name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name>WriteFastID</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>WriteID</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsID</name>&amp;</type> <name>aID</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>fastID</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>MapID</name><argument_list>(<argument><expr><name>aID</name></expr></argument>, <argument><expr>&amp;<name>fastID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name>WriteFastID</name><argument_list>(<argument><expr><name>fastID</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>Seek</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aWhence</name></decl></param>, <param><decl><type><name>PRInt64</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mCurrentDocumentMapEntry</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name>aWhence</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>Tell</name></name><parameter_list>(<param><decl><type><name>PRInt64</name> *</type><name>aResult</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>mSeekableOutput</name>-&gt;<name>Tell</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>SetEOF</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name><name>mSeekableOutput</name>-&gt;<name>SetEOF</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileWriter</name>::<name>SetOutputStream</name></name><parameter_list>(<param><decl><type><name>nsIOutputStream</name> *</type><name>aStream</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>nsBinaryOutputStream</name>::<name>SetOutputStream</name></name><argument_list>(<argument><expr><name>aStream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mSeekableOutput</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mOutputStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_COM</name> <name>nsresult</name></type>
<name>NS_NewFastLoadFileWriter</name><parameter_list>(<param><decl><type><name>nsIObjectOutputStream</name>* *</type><name>aResult</name></decl></param>,
                         <param><decl><type><name>nsIOutputStream</name>*</type> <name>aDestStream</name></decl></param>,
                         <param><decl><type><name>nsIFastLoadFileIO</name>*</type> <name>aFileIO</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsFastLoadFileWriter</name>*</type> <name>writer</name> <init>=
        <expr>new <call><name>nsFastLoadFileWriter</name><argument_list>(<argument><expr><name>aDestStream</name></expr></argument>, <argument><expr><name>aFileIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>writer</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// Stabilize writer's refcnt.</comment>
    <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObjectOutputStream</name></expr></argument>&gt;</argument_list></name></type> <name>stream</name><parameter_list>(<param><decl><type><name>writer</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>writer</name>-&gt;<name>Open</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>stream</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// -------------------------- nsFastLoadFileUpdater --------------------------</comment>

<macro><name>NS_IMPL_ISUPPORTS_INHERITED0</name><argument_list>(<argument>nsFastLoadFileUpdater</argument>,
                             <argument>nsFastLoadFileWriter</argument>)</argument_list></macro>

<function><type><name>PLDHashOperator</name></type>
<name><name>nsFastLoadFileUpdater</name>::<name>CopyReadDocumentMapEntryToUpdater</name></name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>aTable</name></decl></param>,
                                                         <param><decl><type><name>PLDHashEntryHdr</name> *</type><name>aHdr</name></decl></param>,
                                                         <param><decl><type><name>PRUint32</name></type> <name>aNumber</name></decl></param>,
                                                         <param><decl><type><name>void</name> *</type><name>aData</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>readEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapReadEntry</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsFastLoadFileUpdater</name>*</type> <name>updater</name> <init>=
        <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsFastLoadFileUpdater</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>void</name>*</type> <name>spec</name> <init>= <expr><call><name><name>nsMemory</name>::<name>Clone</name></name><argument_list>(<argument><expr><name><name>readEntry</name>-&gt;<name>mString</name></name></expr></argument>,
                                 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>readEntry</name>-&gt;<name>mString</name></name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>spec</name></expr>)</condition><then>
        <return>return <expr><name>PL_DHASH_STOP</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsDocumentMapWriteEntry</name>*</type> <name>writeEntry</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDocumentMapWriteEntry</name>*</expr></argument>&gt;</argument_list></name>
                   <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>updater</name>-&gt;<name>mDocumentMap</name></name></expr></argument>, <argument><expr><name>spec</name></expr></argument>,
                                         <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>writeEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PL_DHASH_STOP</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mString</name></name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mURI</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mInitialSegmentOffset</name></name> = <name><name>readEntry</name>-&gt;<name>mInitialSegmentOffset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mCurrentSegmentOffset</name></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFastLoadFileUpdater</name>::<name>Open</name></name><parameter_list>(<param><decl><type><name>nsFastLoadFileReader</name>*</type> <name>aReader</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>nsFastLoadFileWriter</name>::<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

    <comment type="line">// Map from dense, zero-based, uint32 NSFastLoadID in reader to 16-byte</comment>
    <comment type="line">// nsID in updater.</comment>
    <decl_stmt><decl><type><name>nsID</name>*</type> <name>readIDMap</name> <init>= <expr><name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mIDMap</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>n</name> = <name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mNumIDs</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>NSFastLoadID</name></type> <name>fastID</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>MapID</name><argument_list>(<argument><expr><name><name>readIDMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>fastID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>fastID</name> == <name>i</name> + 1</expr></argument>, <argument><expr>"huh?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></for>

    <comment type="line">// Map from reader dense, zero-based MFL_OID_TO_SHARP_INDEX(oid) to sharp</comment>
    <comment type="line">// object offset and refcnt information in updater.</comment>
    <decl_stmt><decl><type><name><name>nsFastLoadFileReader</name>::<name>nsObjectMapEntry</name></name>*</type> <name>readObjectMap</name> <init>=
        <expr><name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mObjectMap</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Prepare to save aReader state in case we need to seek back and read a</comment>
    <comment type="line">// singleton object that might otherwise get written by this updater.</comment>
    <decl_stmt><decl><type><name>nsDocumentMapReadEntry</name>*</type> <name>saveDocMapEntry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt64</name></type> <name>saveOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>n</name> = <name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mNumSharpObjects</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name><name>nsFastLoadFileReader</name>::<name>nsObjectMapEntry</name></name>*</type> <name>readEntry</name> <init>= <expr>&amp;<name><name>readObjectMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>readEntry</name>-&gt;<name>mCIDOffset</name></name> != 0</expr></argument>,
                     <argument><expr>"fastload updater: mCIDOffset cannot be zero!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If the reader didn't read this object but it's a singleton, we must</comment>
        <comment type="line">// "deserialize" it now, to discover its one and only root nsISupports</comment>
        <comment type="line">// address.  The object already exists in memory if it was created at</comment>
        <comment type="line">// startup without resort to the FastLoad file.  The canonical example</comment>
        <comment type="line">// is the system principal object held by all XUL JS scripts.</comment>

        <decl_stmt><decl><type><name>nsISupports</name>*</type> <name>obj</name> <init>= <expr><name><name>readEntry</name>-&gt;<name>mReadObject</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>obj</name> &amp;&amp; <call><name>MFL_GET_SINGLETON_FLAG</name><argument_list>(<argument><expr><name>readEntry</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>saveDocMapEntry</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name><name>aReader</name>-&gt;<name>Tell</name></name><argument_list>(<argument><expr>&amp;<name>saveOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>rv</name></expr>;</return></then></if>

                <expr_stmt><expr><name>saveDocMapEntry</name> = <name><name>aReader</name>-&gt;<name>mCurrentDocumentMapEntry</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>aReader</name>-&gt;<name>mCurrentDocumentMapEntry</name></name> = <name>nsnull</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>aReader</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                                     <argument><expr><name><name>readEntry</name>-&gt;<name>mCIDOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>aReader</name>
                 -&gt;<name>DeserializeObject</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name><name>readEntry</name>-&gt;<name>mReadObject</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
            <expr_stmt><expr><name>obj</name> = <name><name>readEntry</name>-&gt;<name>mReadObject</name></name></expr>;</expr_stmt>

            <comment type="line">// Don't forget to set mSkipOffset in case someone calls the reader</comment>
            <comment type="line">// to "deserialize" (yet again) the object we just read.</comment>
            <comment type="line">//</comment>
            <comment type="line">// Say the singleton is the system principal, and the FastLoad file</comment>
            <comment type="line">// contains data for navigator.xul including scripts and functions.</comment>
            <comment type="line">// If we update the FastLoad file to contain data for messenger.xul</comment>
            <comment type="line">// in a separate session started via mozilla -mail, *and during the</comment>
            <comment type="line">// same FastLoad episode in this session* race to open a navigator</comment>
            <comment type="line">// window, we will attempt to read all objects serialized in the</comment>
            <comment type="line">// navigator.xul portion of the FastLoad file.</comment>
            <comment type="line">//</comment>
            <comment type="line">// mSkipOffset must be set in such a case so the reader can skip</comment>
            <comment type="line">// the system principal's serialized data, because the updater for</comment>
            <comment type="line">// messenger.xul being opened here has already read it.</comment>

            <expr_stmt><expr><name>rv</name> = <call><name><name>aReader</name>-&gt;<name>Tell</name></name><argument_list>(<argument><expr>&amp;<name><name>readEntry</name>-&gt;<name>mSkipOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then></if>

        <decl_stmt><decl><type><name>NSFastLoadOID</name></type> <name>oid</name> <init>= <expr><call><name>MFL_SHARP_INDEX_TO_OID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name>*</type> <name>key</name> <init>= <expr><name>obj</name>
                    ? <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>
                    : <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>(<name>oid</name> | <name>MFL_OBJECT_DEF_TAG</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>nsSharpObjectMapEntry</name>*</type> <name>writeEntry</name> <init>=
            <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsSharpObjectMapEntry</name>*</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>mObjectMap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
                                             <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>writeEntry</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

        <comment type="line">// Hold the object if there is one, so that objmap_ClearEntry can</comment>
        <comment type="line">// release the reference.</comment>
        <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mObject</name></name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>nsISupports</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mOID</name></name> = <name>oid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mInfo</name>.<name>mCIDOffset</name></name> = <name><name>readEntry</name>-&gt;<name>mCIDOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mInfo</name>.<name>mStrongRefCnt</name></name> = <name><name>readEntry</name>-&gt;<name>mSaveStrongRefCnt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>writeEntry</name>-&gt;<name>mInfo</name>.<name>mWeakRefCnt</name></name> = <name><name>readEntry</name>-&gt;<name>mSaveWeakRefCnt</name></name></expr>;</expr_stmt>
    }</block></for>

    <comment type="line">// If we had to read any singletons, restore aReader's saved state.</comment>
    <if>if <condition>(<expr><name>saveDocMapEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>aReader</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>, <argument><expr><name>saveOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>aReader</name>-&gt;<name>mCurrentDocumentMapEntry</name></name> = <name>saveDocMapEntry</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Copy URI spec string and initial segment offset in FastLoad file from</comment>
    <comment type="line">// nsDocumentMapReadEntry in reader to nsDocumentMapWriteEntry in updater.</comment>
    <comment type="line">// If we didn't enumerate all entries, we ran out of memory.</comment>
    <expr_stmt><expr><name>n</name> = <call><name>PL_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mDocumentMap</name></name></expr></argument>,
                               <argument><expr><name>CopyReadDocumentMapEntryToUpdater</name></expr></argument>,
                               <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>n</name> != <name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mDocumentMap</name>.<name>entryCount</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// Copy source filename dependencies from reader to updater.</comment>
    <decl_stmt><decl><type><name>nsISupportsArray</name>*</type> <name>readDeps</name> <init>= <expr><name><name>aReader</name>-&gt;<name>mFooter</name>.<name>mDependencies</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>readDeps</name>-&gt;<name>Count</name></name><argument_list>(<argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFile</name></expr></argument>&gt;</argument_list></name></type> <name>file</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>readDeps</name>-&gt;<name>GetElementAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>AddDependency</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></for>

    <comment type="line">// Seek to the reader's footer offset so we overwrite the footer.  First,</comment>
    <comment type="line">// update the header to have a zero mFooterOffset, which will invalidate</comment>
    <comment type="line">// the FastLoad file on next startup read attempt, should we crash before</comment>
    <comment type="line">// completing this update.</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                               <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>nsFastLoadHeader</name></expr></argument>, <argument><expr><name>mFooterOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>Write32</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mSeekableOutput</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>,
                               <argument><expr><name><name>aReader</name>-&gt;<name>mHeader</name>.<name>mFooterOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsFastLoadFileUpdater</name>::<name>Close</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Call base-class Close implementation, which uses mFileIO.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>nsFastLoadFileWriter</name>::<name>Close</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Break degenerate cycle from this-&gt;mFileIO to this.</comment>
    <expr_stmt><expr><name>mFileIO</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_COM</name> <name>nsresult</name></type>
<name>NS_NewFastLoadFileUpdater</name><parameter_list>(<param><decl><type><name>nsIObjectOutputStream</name>* *</type><name>aResult</name></decl></param>,
                          <param><decl><type><name>nsIFastLoadFileIO</name> *</type><name>aFileIO</name></decl></param>,
                          <param><decl><type><name>nsIObjectInputStream</name>*</type> <name>aReaderAsStream</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Make sure that aReaderAsStream is an nsFastLoadFileReader.</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFastLoadFileReader</name></expr></argument>&gt;</argument_list></name></type> <name>reader</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aReaderAsStream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>reader</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIOutputStream</name></expr></argument>&gt;</argument_list></name></type> <name>output</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aFileIO</name>-&gt;<name>GetOutputStream</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsFastLoadFileUpdater</name>*</type> <name>updater</name> <init>= <expr>new <call><name>nsFastLoadFileUpdater</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>aFileIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>updater</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// Stabilize updater's refcnt.</comment>
    <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObjectOutputStream</name></expr></argument>&gt;</argument_list></name></type> <name>stream</name><parameter_list>(<param><decl><type><name>updater</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>rv</name> = <call><name><name>updater</name>-&gt;<name>Open</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsFastLoadFileReader</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aReaderAsStream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>stream</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
</unit>
