<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="004a999908d35a0b1973d0dbe696849a96cfa169.h"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>jscntxt_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jscntxt_h___</name></cpp:macro></cpp:define>
<comment type="block">/*
 * JS execution context.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Gross special case for Gecko, which defines malloc/calloc/free. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>mozilla_mozalloc_macro_wrappers_h</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_UNDEFD_MOZALLOC_WRAPPERS</name></cpp:macro></cpp:define>
<comment type="block">/* The "anti-header" */</comment>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/mozalloc_undef_macro_wrappers.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprvtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslong.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdtoa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgcchunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jshashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsmath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertycache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertytree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsvector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prmjtime.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(push)</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(disable:4100)</cpp:pragma> <comment type="block">/* Silence unreferenced formal parameter warnings */</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(push)</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(disable:4355)</cpp:pragma> <comment type="block">/* Silence warning about "this" used in base member initializer list */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
 * given pc in a script. We use the script-&gt;code pointer to tag the cache,
 * instead of the script address itself, so that source notes are always found
 * by offset from the bytecode with which they were generated.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSGSNCache</name> <block>{
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>    <name>table</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GSNMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>hits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>misses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>fills</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>purges</name></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_METER</name><parameter_list>(<param><type><name>cache</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(++(cache)-&gt;cnt)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_METER</name><parameter_list>(<param><type><name>cache</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>JSGSNCache</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_FinishGSNCache</name><parameter_list>(<param><type><name>cache</name></type></param>)</parameter_list></cpp:macro> <cpp:value>js_PurgeGSNCache(cache)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_PurgeGSNCache</name><parameter_list>(<param><decl><type><name>JSGSNCache</name> *</type><name>cache</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* These helper macros take a cx as parameter and operate on its GSN cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PURGE_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>js_PurgeGSNCache(&amp;JS_GSN_CACHE(cx))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_METER_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>GSN_CACHE_METER(&amp;JS_GSN_CACHE(cx), cnt)</cpp:value></cpp:define>

<comment type="block">/* Forward declarations of nanojit types. */</comment>
<decl_stmt><decl><type><name>namespace</name></type> <name>nanojit</name> <block>{

<decl_stmt><decl><type><name>class</name></type> <name>Assembler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeAlloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Fragment</name></decl>;</decl_stmt>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>K</name>&gt; struct <name>DefaultHash</name></expr>;</expr_stmt>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>K</name></expr>, <expr><name>typename</name> <name>V</name></expr>, <expr><name>typename</name> <name>H</name>&gt; <name>class</name> <name>HashMap</name></expr>;</expr_stmt>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>T</name>&gt; <name>class</name> <name>Seq</name></expr>;</expr_stmt>

}</block></decl></decl_stmt>  <comment type="block">/* namespace nanojit */</comment>

<decl_stmt><decl><type><name>namespace</name></type> <name>JSC</name> <block>{
    <decl_stmt><decl><type><name>class</name></type> <name>ExecutableAllocator</name></decl>;</decl_stmt>
}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<comment type="block">/* Tracer constants. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MONITOR_N_GLOBAL_STATES</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>FRAGMENT_TABLE_SIZE</name> <init>= <expr>512</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_NATIVE_STACK_SLOTS</name> <init>= <expr>4096</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_CALL_STACK_ENTRIES</name> <init>= <expr>500</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_GLOBAL_SLOTS</name> <init>= <expr>4096</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>GLOBAL_SLOTS_BUFFER_SIZE</name> <init>= <expr><name>MAX_GLOBAL_SLOTS</name> + 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_SLOW_NATIVE_EXTRA_SLOTS</name> <init>= <expr>16</expr></init></decl>;</decl_stmt>

<comment type="block">/* Forward declarations of tracer types. */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>VMAllocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FrameInfoCache</name></decl>;</decl_stmt>
<struct_decl>struct <name>REHashFn</name>;</struct_decl>
<struct_decl>struct <name>REHashKey</name>;</struct_decl>
<struct_decl>struct <name>FrameInfo</name>;</struct_decl>
<struct_decl>struct <name>VMSideExit</name>;</struct_decl>
<struct_decl>struct <name>TreeFragment</name>;</struct_decl>
<struct_decl>struct <name>TracerState</name>;</struct_decl>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>T</name>&gt; <name>class</name> <name>Queue</name></expr>;</expr_stmt>
<typedef>typedef <expr_stmt><expr><name>Queue</name>&lt;<name>uint16</name>&gt; <name>SlotList</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>class</name></type> <name>TypeMap</name></decl>;</decl_stmt>
<struct_decl>struct <name>REFragment</name>;</struct_decl>
<typedef>typedef <expr_stmt><expr><name>nanojit</name>::<name>HashMap</name>&lt;<name>REHashKey</name></expr>, <expr><name>REFragment</name>*</expr>, <expr><name>REHashFn</name>&gt; <name>REHashMap</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>class</name></type> <name>LoopProfile</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JS_JIT_SPEW</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct_decl>struct <name>FragPI</name>;</struct_decl>
<typedef>typedef <expr_stmt><expr><name>nanojit</name>::<name>HashMap</name>&lt;<name>uint32</name></expr>, <expr><name>FragPI</name></expr>, <expr><name>nanojit</name>::<name>DefaultHash</name>&lt;<name>uint32</name>&gt; &gt; <name>FragStatsMap</name></expr>;</expr_stmt></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>namespace</name></type> <name>mjit</name> <block>{
<decl_stmt><decl><type><name>class</name></type> <name>JaegerCompartment</name></decl>;</decl_stmt>
}</block></decl></decl_stmt>

<comment type="block">/*
 * Allocation policy that calls JSContext memory functions and reports errors
 * to the context. Since the JSContext given on construction is stored for
 * the lifetime of the container, this policy may only be used for containers
 * whose lifetime is a shorter than the given JSContext.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>ContextAllocPolicy</name>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>

  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>ContextAllocPolicy</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call> : <macro><name>cx</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{}</block>
    <name>JSContext</name> *<macro><name>context</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>cx</name></expr>;</return> }</block></expr></expr_stmt>

    <comment type="block">/* Inline definitions below. */</comment>
    <function_decl><type><name>void</name> *</type><name>malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name> *</type><name>realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>void</name> <macro><name>reportAllocOverflow</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/* Holds the execution state during trace execution. */</comment>
<struct>struct <name>TracerState</name>
<block>{
    <decl_stmt><decl><type><name>JSContext</name>*</type>     <name>cx</name></decl>;</decl_stmt>                  <comment type="line">// current VM context handle</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>stackBase</name></decl>;</decl_stmt>           <comment type="line">// native stack base</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>sp</name></decl>;</decl_stmt>                  <comment type="line">// native stack pointer, stack[0] is spbase[0]</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>eos</name></decl>;</decl_stmt>                 <comment type="line">// first unusable word after the native stack / begin of globals</comment>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type>    <name>callstackBase</name></decl>;</decl_stmt>       <comment type="line">// call stack base</comment>
    <decl_stmt><decl><type><name>void</name>*</type>          <name>sor</name></decl>;</decl_stmt>                 <comment type="line">// start of rp stack</comment>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type>    <name>rp</name></decl>;</decl_stmt>                  <comment type="line">// call stack pointer</comment>
    <decl_stmt><decl><type><name>void</name>*</type>          <name>eor</name></decl>;</decl_stmt>                 <comment type="line">// first unusable word after the call stack</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>lastTreeExitGuard</name></decl>;</decl_stmt>   <comment type="line">// guard we exited on during a tree call</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>lastTreeCallGuard</name></decl>;</decl_stmt>   <comment type="line">// guard we want to grow from if the tree</comment>
                                        <comment type="line">// call exit guard mismatched</comment>
    <decl_stmt><decl><type><name>void</name>*</type>          <name>rpAtLastTreeCall</name></decl>;</decl_stmt>    <comment type="line">// value of rp at innermost tree call guard</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>outermostTreeExitGuard</name></decl>;</decl_stmt> <comment type="line">// the last side exit returned by js_CallTree</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type>  <name>outermostTree</name></decl>;</decl_stmt>       <comment type="line">// the outermost tree we initially invoked</comment>
    <decl_stmt><decl><type><name>uintN</name>*</type>         <name>inlineCallCountp</name></decl>;</decl_stmt>    <comment type="line">// inline call count counter</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>**</type>   <name>innermostNestedGuardp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>innermost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>         <name>startTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TracerState</name>*</type>   <name>prev</name></decl>;</decl_stmt>

    <comment type="line">// Used by _FAIL builtins; see jsbuiltins.h. The builtin sets the</comment>
    <comment type="line">// JSBUILTIN_BAILED bit if it bails off trace and the JSBUILTIN_ERROR bit</comment>
    <comment type="line">// if an error or exception occurred.</comment>
    <decl_stmt><decl><type><name>uint32</name></type>         <name>builtinStatus</name></decl>;</decl_stmt>

    <comment type="line">// Used to communicate the location of the return value in case of a deep bail.</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>deepBailSp</name></decl>;</decl_stmt>

    <comment type="line">// Used when calling natives from trace to root the vp vector.</comment>
    <decl_stmt><decl><type><name>uintN</name></type>          <name>nativeVpLen</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>js</name>::<name>Value</name>*     <name>nativeVp</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>TracerState</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>TraceMonitor</name> *<name>tm</name></expr></argument>, <argument><expr><name>TreeFragment</name> *<name>ti</name></expr></argument>,
                <argument><expr><name>uintN</name> &amp;<name>inlineCallCountp</name></expr></argument>, <argument><expr><name>VMSideExit</name>** <name>innermostNestedGuardp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>~<call><name>TracerState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>

<comment type="block">/*
 * Storage for the execution state and store during trace execution. Generated
 * code depends on the fact that the globals begin |MAX_NATIVE_STACK_SLOTS|
 * doubles after the stack begins. Thus, on trace, |TracerState::eos| holds a
 * pointer to the first global.
 */</comment>
<struct>struct <name>TraceNativeStorage</name>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name><name>stack_global_buf</name><index>[<expr><name>MAX_NATIVE_STACK_SLOTS</name> + <name>GLOBAL_SLOTS_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FrameInfo</name> *</type><name><name>callstack_buf</name><index>[<expr><name>MAX_CALL_STACK_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>

    <function><type><name>double</name> *</type><name>stack</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>stack_global_buf</name></expr>;</return> }</block></function>
    <function><type><name>double</name> *</type><name>global</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>stack_global_buf</name> + <name>MAX_NATIVE_STACK_SLOTS</name></expr>;</return> }</block></function>
    <function><type><name>FrameInfo</name> **</type><name>callstack</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>callstack_buf</name></expr>;</return> }</block></function>
}</block>;</struct>

<comment type="block">/* Holds data to track a single globa. */</comment>
<struct>struct <name>GlobalState</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type>               <name>globalObj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>                  <name>globalShape</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SlotList</name>*</type>               <name>globalSlots</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * A StackSegment (referred to as just a 'segment') contains a prev-linked set
 * of stack frames and the slots associated with each frame. A segment and its
 * contained frames/slots also have a precise memory layout that is described
 * in the js::StackSpace comment. A key layout invariant for segments is that
 * prev-linked frames are adjacent in memory, separated only by the values that
 * constitute the locals and expression stack of the prev-frame.
 *
 * The set of stack frames in a non-empty segment start at the segment's
 * "current frame", which is the most recently pushed frame, and ends at the
 * segment's "initial frame". Note that, while all stack frames in a segment
 * are prev-linked, not all prev-linked frames are in the same segment. Hence,
 * for a segment |ss|, |ss-&gt;getInitialFrame()-&gt;prev| may be non-null and in a
 * different segment. This occurs when the VM reenters itself (via Invoke or
 * Execute). In full generality, a single context may contain a forest of trees
 * of stack frames. With respect to this forest, a segment contains a linear
 * path along a single tree, not necessarily to the root.
 *
 * The frames of a non-empty segment must all be in the same context and thus
 * each non-empty segment is referred to as being "in" a context. Segments in a
 * context have an additional state of being either "active" or "suspended". A
 * suspended segment |ss| has a "suspended frame" which is snapshot of |cx-&gt;regs|
 * when the segment was suspended and serves as the current frame of |ss|.
 * There is at most one active segment in a given context. Segments in a
 * context execute LIFO and are maintained in a stack.  The top of this stack
 * is the context's "current segment". If a context |cx| has an active segment
 * |ss|, then:
 *   1. |ss| is |cx|'s current segment,
 *   2. |cx-&gt;regs != NULL|, and
 *   3. |ss|'s current frame is |cx-&gt;regs-&gt;fp|.
 * Moreover, |cx-&gt;regs != NULL| iff |cx| has an active segment.
 *
 * An empty segment is not associated with any context. Empty segments are
 * created when there is not an active segment for a context at the top of the
 * stack and claim space for the arguments of an Invoke before the Invoke's
 * stack frame is pushed. During the intervals when the arguments have been
 * pushed, but not the stack frame, the segment cannot be pushed onto the
 * context, since that would require some hack to deal with cx-&gt;fp not being
 * the current frame of cx-&gt;currentSegment.
 *
 * Finally, (to support JS_SaveFrameChain/JS_RestoreFrameChain) a suspended
 * segment may or may not be "saved". Normally, when the active segment is
 * popped, the previous segment (which is necessarily suspended) becomes
 * active. If the previous segment was saved, however, then it stays suspended
 * until it is made active by a call to JS_RestoreFrameChain. This is why a
 * context may have a current segment, but not an active segment.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>StackSegment</name>
<block>{
    <comment type="block">/* The context to which this segment belongs. */</comment>
    <decl_stmt><decl><type><name>JSContext</name>           *</type><name>cx</name></decl>;</decl_stmt>

    <comment type="block">/* Link for JSContext segment stack mentioned in big comment above. */</comment>
    <decl_stmt><decl><type><name>StackSegment</name>        *</type><name>previousInContext</name></decl>;</decl_stmt>

    <comment type="block">/* Link for StackSpace segment stack mentioned in StackSpace comment. */</comment>
    <decl_stmt><decl><type><name>StackSegment</name>        *</type><name>previousInMemory</name></decl>;</decl_stmt>

    <comment type="block">/* The first frame executed in this segment. null iff cx is null */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>        *</type><name>initialFrame</name></decl>;</decl_stmt>

    <comment type="block">/* If this segment is suspended, |cx-&gt;regs| when it was suspended. */</comment>
    <decl_stmt><decl><type><name>JSFrameRegs</name>         *</type><name>suspendedRegs</name></decl>;</decl_stmt>

    <comment type="block">/* The varobj on entry to initialFrame. */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>initialVarObj</name></decl>;</decl_stmt>

    <comment type="block">/* Whether this segment was suspended by JS_SaveFrameChain. */</comment>
    <decl_stmt><decl><type><name>bool</name></type>                <name>saved</name></decl>;</decl_stmt>

    <comment type="block">/* Align at 8 bytes on all platforms. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_BITS_PER_WORD</name> == 32</expr></cpp:if>
    <decl_stmt><decl><type><name>void</name>                *</type><name>padding</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * To make isActive a single null-ness check, this non-null constant is
     * assigned to suspendedRegs when !inContext.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NON_NULL_SUSPENDED_REGS</name></cpp:macro> <cpp:value>((JSFrameRegs *)0x1)</cpp:value></cpp:define>

  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>StackSegment</name><argument_list>()</argument_list></call>
      : <call><name>cx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>previousInContext</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>previousInMemory</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>initialFrame</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>suspendedRegs</name><argument_list>(<argument><expr><name>NON_NULL_SUSPENDED_REGS</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>initialVarObj</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <macro><name>saved</name><argument_list>(<argument>false</argument>)</argument_list></macro>
    <expr><block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="block">/* Safe casts guaranteed by the contiguous-stack layout. */</comment>

    <name>Value</name> *<macro><name>valueRangeBegin</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><call>(<name>Value</name> *)<argument_list>(<argument><expr><name>this</name> + 1</expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block">/*
     * As described in the comment at the beginning of the class, a segment
     * is in one of three states:
     *
     *  !inContext:  the segment has been created to root arguments for a
     *               future call to Invoke.
     *  isActive:    the segment describes a set of stack frames in a context,
     *               where the top frame currently executing.
     *  isSuspended: like isActive, but the top frame has been suspended.
     */</comment>

    <expr_stmt><expr><name>bool</name> <macro><name>inContext</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!!<name>cx</name> == !!<name>initialFrame</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>cx</name></expr></argument>, <argument><expr><name>suspendedRegs</name> == <name>NON_NULL_SUSPENDED_REGS</name> &amp;&amp; !<name>saved</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>cx</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>isActive</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>suspendedRegs</name></expr></argument>, <argument><expr><name>cx</name> &amp;&amp; !<name>saved</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>cx</name></expr></argument>, <argument><expr><name>suspendedRegs</name> == <name>NON_NULL_SUSPENDED_REGS</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr>!<name>suspendedRegs</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>isSuspended</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>cx</name> || !<name>suspendedRegs</name></expr></argument>, <argument><expr>!<name>saved</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>cx</name></expr></argument>, <argument><expr><name>suspendedRegs</name> == <name>NON_NULL_SUSPENDED_REGS</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>cx</name> &amp;&amp; <name>suspendedRegs</name></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block">/* Substate of suspended, queryable in any state. */</comment>

    <expr_stmt><expr><name>bool</name> <macro><name>isSaved</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>saved</name></expr></argument>, <argument><expr><call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>saved</name></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block">/* Transitioning between inContext &lt;--&gt; isActive */</comment>

    <function><type><name>void</name></type> <name>joinContext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>-&gt;<name>cx</name></name> = <name>cx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>initialFrame</name> = <name>f</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>suspendedRegs</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>leaveContext</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>-&gt;<name>cx</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>initialFrame</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>suspendedRegs</name> = <name>NON_NULL_SUSPENDED_REGS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <expr_stmt><expr><name>JSContext</name> *<macro><name>maybeContext</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><name>cx</name></expr>;</return>
    }</block></expr></expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NON_NULL_SUSPENDED_REGS</name></cpp:undef>

    <comment type="block">/* Transitioning between isActive &lt;--&gt; isSuspended */</comment>

    <function><type><name>void</name></type> <name>suspend</name><parameter_list>(<param><decl><type><name>JSFrameRegs</name> *</type><name>regs</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>regs</name> &amp;&amp; <name><name>regs</name>-&gt;<name>fp</name></name> &amp;&amp; <call><name>contains</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>suspendedRegs</name> = <name>regs</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>resume</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>suspendedRegs</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/* When isSuspended, transitioning isSaved &lt;--&gt; !isSaved */</comment>

    <function><type><name>void</name></type> <name>save</name><parameter_list>(<param><decl><type><name>JSFrameRegs</name> *</type><name>regs</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>suspend</name><argument_list>(<argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>saved</name> = <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isSaved</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>restore</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isSaved</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>saved</name> = <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resume</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/* Data available when inContext */</comment>

    <expr_stmt><expr><name>JSStackFrame</name> *<macro><name>getInitialFrame</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>initialFrame</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr>inline <name>JSFrameRegs</name> *<macro><name>getCurrentRegs</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
    <expr_stmt><expr>inline <name>JSStackFrame</name> *<macro><name>getCurrentFrame</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

    <comment type="block">/* Data available when isSuspended. */</comment>

    <expr_stmt><expr><name>JSFrameRegs</name> *<macro><name>getSuspendedRegs</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>suspendedRegs</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSStackFrame</name> *<macro><name>getSuspendedFrame</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><name><name>suspendedRegs</name>-&gt;<name>fp</name></name></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block">/* JSContext / js::StackSpace bookkeeping. */</comment>

    <function><type><name>void</name></type> <name>setPreviousInContext</name><parameter_list>(<param><decl><type><name>StackSegment</name> *</type><name>seg</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>previousInContext</name> = <name>seg</name></expr>;</expr_stmt>
    }</block></function>

    <expr_stmt><expr><name>StackSegment</name> *<macro><name>getPreviousInContext</name><argument_list>()</argument_list></macro> const  <block>{
        <return>return <expr><name>previousInContext</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>setPreviousInMemory</name><parameter_list>(<param><decl><type><name>StackSegment</name> *</type><name>seg</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>previousInMemory</name> = <name>seg</name></expr>;</expr_stmt>
    }</block></function>

    <expr_stmt><expr><name>StackSegment</name> *<macro><name>getPreviousInMemory</name><argument_list>()</argument_list></macro> const  <block>{
        <return>return <expr><name>previousInMemory</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>setInitialVarObj</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initialVarObj</name> = <name>obj</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>bool</name></type> <name>hasInitialVarObj</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>initialVarObj</name> != <name>NULL</name></expr>;</return>
    }</block></function>

    <expr_stmt><expr><name>JSObject</name> &amp;<macro><name>getInitialVarObj</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>inContext</name><argument_list>()</argument_list></call> &amp;&amp; <name>initialVarObj</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr>*<name>initialVarObj</name></expr>;</return>
    }</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type> <name>contains</name><argument_list>(<argument><expr>const <name>JSStackFrame</name> *<name>fp</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>VALUES_PER_STACK_SEGMENT</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>StackSegment</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StackSegment</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* See StackSpace::pushInvokeArgs. */</comment>
<expr_stmt><expr><name>class</name> <name>InvokeArgsGuard</name> : <name>public</name> <name>CallArgs</name>
<block>{
    <expr><name>friend</name> <name>class</name> <name>StackSpace</name></expr>;
    <expr><name>JSContext</name>        *<name>cx</name></expr>;  <comment type="block">/* null implies nothing pushed */</comment>
    <expr><name>StackSegment</name>     *<name>seg</name></expr>;
    <expr><name>Value</name>            *<name>prevInvokeArgEnd</name></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr><name>StackSegment</name>     *<name>prevInvokeSegment</name></expr>;
    <expr><name>JSStackFrame</name>     *<name>prevInvokeFrame</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><name>public</name>:
    <call><name>InvokeArgsGuard</name><argument_list>()</argument_list></call> : <call><name>cx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <macro><name>seg</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <expr><block>{}</block>
    ~<call><name>InvokeArgsGuard</name><argument_list>()</argument_list></call></expr>;
    <expr><name>bool</name> <macro><name>pushed</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>cx</name> != <name>NULL</name></expr>;</return> }</block>
}</expr>;

<comment type="block">/*
 * This type can be used to call Invoke when the arguments have already been
 * pushed onto the stack as part of normal execution.
 */</comment>
struct <expr><name>InvokeArgsAlreadyOnTheStack</name> : <name>CallArgs</name>
<block>{
    <macro><name>InvokeArgsAlreadyOnTheStack</name><argument_list>(<argument>Value *vp</argument>, <argument>uintN argc</argument>)</argument_list></macro> : <macro><name>CallArgs</name><argument_list>(<argument>vp + 2</argument>, <argument>argc</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;

<comment type="block">/* See StackSpace::pushInvokeFrame. */</comment>
<expr><name>class</name> <name>InvokeFrameGuard</name>
<block>{
    <expr><name>friend</name> <name>class</name> <name>StackSpace</name></expr>;
    <expr><name>JSContext</name>        *<name>cx_</name></expr>;  <comment type="block">/* null implies nothing pushed */</comment>
    <expr><name>JSFrameRegs</name>      <name>regs_</name></expr>;
    <expr><name>JSFrameRegs</name>      *<name>prevRegs_</name></expr>;
  <expr><name>public</name>:
    <call><name>InvokeFrameGuard</name><argument_list>()</argument_list></call> : <macro><name>cx_</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <block>{}</block>
    ~<macro><name>InvokeFrameGuard</name><argument_list>()</argument_list></macro> <block>{ <if>if <condition>(<expr><call><name>pushed</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>pop</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> }</block>
    <name>bool</name> <macro><name>pushed</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>cx_</name> != <name>NULL</name></expr>;</return> }</block>
    <name>void</name> <call><name>pop</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSStackFrame</name> *<macro><name>fp</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name><name>regs_</name>.<name>fp</name></name></expr>;</return> }</block>
}</expr>;

<comment type="block">/* Reusable base; not for direct use. */</comment>
<expr><name>class</name> <name>FrameGuard</name>
<block>{
    <expr><name>friend</name> <name>class</name> <name>StackSpace</name></expr>;
    <expr><name>JSContext</name>        *<name>cx_</name></expr>;  <comment type="block">/* null implies nothing pushed */</comment>
    <expr><name>StackSegment</name>     *<name>seg_</name></expr>;
    <expr><name>Value</name>            *<name>vp_</name></expr>;
    <expr><name>JSStackFrame</name>     *<name>fp_</name></expr>;
  <expr><name>public</name>:
    <call><name>FrameGuard</name><argument_list>()</argument_list></call> : <call><name>cx_</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>vp_</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <macro><name>fp_</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <expr><block>{}</block>
    <name>JS_REQUIRES_STACK</name> ~<call><name>FrameGuard</name><argument_list>()</argument_list></call></expr>;
    <expr><name>bool</name> <macro><name>pushed</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>cx_</name> != <name>NULL</name></expr>;</return> }</block>
    <name>StackSegment</name> *<macro><name>segment</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>seg_</name></expr>;</return> }</block>
    <name>Value</name> *<macro><name>vp</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>vp_</name></expr>;</return> }</block>
    <name>JSStackFrame</name> *<macro><name>fp</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>fp_</name></expr>;</return> }</block>
}</expr>;

<comment type="block">/* See StackSpace::pushExecuteFrame. */</comment>
<expr><name>class</name> <name>ExecuteFrameGuard</name> : <name>public</name> <name>FrameGuard</name>
<block>{
    <expr><name>friend</name> <name>class</name> <name>StackSpace</name></expr>;
    <expr><name>JSFrameRegs</name>      <name>regs_</name></expr>;
}</block></expr>;

<comment type="block">/* See StackSpace::pushDummyFrame. */</comment>
<expr><name>class</name> <name>DummyFrameGuard</name> : <name>public</name> <name>FrameGuard</name>
<block>{
    <expr><name>friend</name> <name>class</name> <name>StackSpace</name></expr>;
    <expr><name>JSFrameRegs</name>      <name>regs_</name></expr>;
}</block></expr>;

<comment type="block">/* See StackSpace::pushGeneratorFrame. */</comment>
<expr><name>class</name> <name>GeneratorFrameGuard</name> : <name>public</name> <name>FrameGuard</name>
<block>{}</block></expr>;

<comment type="block">/*
 * Stack layout
 *
 * Each JSThreadData has one associated StackSpace object which allocates all
 * segments for the thread. StackSpace performs all such allocations in a
 * single, fixed-size buffer using a specific layout scheme that allows some
 * associations between segments, frames, and slots to be implicit, rather
 * than explicitly stored as pointers. To maintain useful invariants, stack
 * space is not given out arbitrarily, but rather allocated/deallocated for
 * specific purposes. The use cases currently supported are: calling a function
 * with arguments (e.g. Invoke), executing a script (e.g. Execute), inline
 * interpreter calls, and pushing "dummy" frames for bookkeeping purposes. See
 * associated member functions below.
 *
 * First, we consider the layout of individual segments. (See the
 * js::StackSegment comment for terminology.) A non-empty segment (i.e., a
 * segment in a context) has the following layout:
 *
 *           initial frame                 current frame ------.  if regs,
 *          .------------.                           |         |  regs-&gt;sp
 *          |            V                           V         V
 *   |segment| slots |frame| slots |frame| slots |frame| slots |
 *                       |  ^          |  ^          |
 *          ? &lt;----------'  `----------'  `----------'
 *                prev          prev          prev
 *
 * Moreover, the bytes in the following ranges form a contiguous array of
 * Values that are marked during GC:
 *   1. between a segment and its first frame
 *   2. between two adjacent frames in a segment
 *   3. between a segment's current frame and (if fp-&gt;regs) fp-&gt;regs-&gt;sp
 * Thus, the VM must ensure that all such Values are safe to be marked.
 *
 * An empty segment is followed by arguments that are rooted by the
 * StackSpace::invokeArgEnd pointer:
 *
 *              invokeArgEnd
 *                   |
 *                   V
 *   |segment| slots |
 *
 * Above the level of segments, a StackSpace is simply a contiguous sequence
 * of segments kept in a linked list:
 *
 *   base                       currentSegment  firstUnused            end
 *    |                               |             |                   |
 *    V                               V             V                   V
 *    |segment| --- |segment| --- |segment| ------- |                   |
 *         | ^           | ^           |
 *   0 &lt;---' `-----------' `-----------'
 *   previous    previous       previous
 *
 * Both js::StackSpace and JSContext maintain a stack of segments, the top of
 * which is the "current segment" for that thread or context, respectively.
 * Since different contexts can arbitrarily interleave execution in a single
 * thread, these stacks are different enough that a segment needs both
 * "previousInMemory" and "previousInContext".
 *
 * For example, in a single thread, a function in segment S1 in a context CX1
 * may call out into C++ code that reenters the VM in a context CX2, which
 * creates a new segment S2 in CX2, and CX1 may or may not equal CX2.
 *
 * Note that there is some structure to this interleaving of segments:
 *   1. the inclusion from segments in a context to segments in a thread
 *      preserves order (in terms of previousInContext and previousInMemory,
 *      respectively).
 *   2. the mapping from stack frames to their containing segment preserves
 *      order (in terms of prev and previousInContext, respectively).
 */</comment>
<expr><name>class</name> <name>StackSpace</name>
<block>{
    <expr><name>Value</name> *<name>base</name></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
    <expr><name>mutable</name> <name>Value</name> *<name>commitEnd</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>Value</name> *<name>end</name></expr>;
    <expr><name>StackSegment</name> *<name>currentSegment</name></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/*
     * Keep track of which segment/frame bumped invokeArgEnd so that
     * firstUnused() can assert that, when invokeArgEnd is used as the top of
     * the stack, it is being used appropriately.
     */</comment>
    <expr><name>StackSegment</name> *<name>invokeSegment</name></expr>;
    <expr><name>JSStackFrame</name> *<name>invokeFrame</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>Value</name>        *<name>invokeArgEnd</name></expr>;

    <expr><name>friend</name> <name>class</name> <name>InvokeArgsGuard</name></expr>;
    <expr><name>friend</name> <name>class</name> <name>InvokeFrameGuard</name></expr>;
    <expr><name>friend</name> <name>class</name> <name>FrameGuard</name></expr>;

    <expr><name>bool</name> <macro><name>pushSegmentForInvoke</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN argc</argument>, <argument>InvokeArgsGuard *ag</argument>)</argument_list></macro></expr>;
    <expr><name>void</name> <call><name>popSegmentForInvoke</name><argument_list>(<argument><expr>const <name>InvokeArgsGuard</name> &amp;<name>ag</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>bool</name> <call><name>pushInvokeFrameSlow</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr>const <name>InvokeArgsGuard</name> &amp;<name>ag</name></expr></argument>,
                             <argument><expr><name>InvokeFrameGuard</name> *<name>fg</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>void</name> <call><name>popInvokeFrameSlow</name><argument_list>(<argument><expr>const <name>CallArgs</name> &amp;<name>args</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>bool</name> <macro><name>getSegmentAndFrame</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN vplen</argument>, <argument>uintN nfixed</argument>,
                            <argument>FrameGuard *fg</argument>)</argument_list></macro> const</expr>;
    <expr><name>void</name> <call><name>pushSegmentAndFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSObject</name> *<name>initialVarObj</name></expr></argument>,
                             <argument><expr><name>JSFrameRegs</name> *<name>regs</name></expr></argument>, <argument><expr><name>FrameGuard</name> *<name>fg</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>void</name> <call><name>popSegmentAndFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

    struct <expr><name>EnsureSpaceCheck</name> <block>{
        <expr>inline <name>bool</name> <call><call><name>operator</name><argument_list>()</argument_list></call><argument_list>(<argument><expr>const <name>StackSpace</name> &amp;</expr></argument>, <argument><expr><name>JSContext</name> *</expr></argument>, <argument><expr><name>Value</name> *</expr></argument>, <argument><expr><name>uintN</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr>;

    struct <expr><name>LimitCheck</name> <block>{
        <expr><name>JSStackFrame</name> *<name>base</name></expr>;
        <expr><name>Value</name> **<name>limit</name></expr>;
        <expr><call><name>LimitCheck</name><argument_list>(<argument><expr><name>JSStackFrame</name> *<name>base</name></expr></argument>, <argument><expr><name>Value</name> **<name>limit</name></expr></argument>)</argument_list></call> : <call><name>base</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>, <macro><name>limit</name><argument_list>(<argument>limit</argument>)</argument_list></macro> <expr><block>{}</block>
        inline <name>bool</name> <call><call><name>operator</name><argument_list>()</argument_list></call><argument_list>(<argument><expr>const <name>StackSpace</name> &amp;</expr></argument>, <argument><expr><name>JSContext</name> *</expr></argument>, <argument><expr><name>Value</name> *</expr></argument>, <argument><expr><name>uintN</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr>;

    <expr><name>template</name> &lt;<name>class</name> <name>Check</name>&gt;
    inline <name>JSStackFrame</name> *<macro><name>getCallFrame</name><argument_list>(<argument>JSContext *cx</argument>, <argument>Value *sp</argument>, <argument>uintN nactual</argument>,
                                      <argument>JSFunction *fun</argument>, <argument>JSScript *script</argument>,
                                      <argument>uint32 *pflags</argument>, <argument>Check check</argument>)</argument_list></macro> const</expr>;

    <expr>inline <name>void</name> <call><name>popInvokeArgs</name><argument_list>(<argument><expr>const <name>InvokeArgsGuard</name> &amp;<name>args</name></expr></argument>)</argument_list></call></expr>;
    <expr>inline <name>void</name> <call><name>popInvokeFrame</name><argument_list>(<argument><expr>const <name>InvokeFrameGuard</name> &amp;<name>ag</name></expr></argument>)</argument_list></call></expr>;

    <expr>inline <name>Value</name> *<macro><name>firstUnused</name><argument_list>()</argument_list></macro> const</expr>;

    <expr>inline <name>bool</name> <macro><name>isCurrentAndActive</name><argument_list>(<argument>JSContext *cx</argument>)</argument_list></macro> const</expr>;
    <expr><name>friend</name> <name>class</name> <name>AllFramesIter</name></expr>;
    <expr><name>StackSegment</name> *<macro><name>getCurrentSegment</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>currentSegment</name></expr>;</return> }</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
    <comment type="block">/* Commit more memory from the reserved stack space. */</comment>
    <macro><name>JS_FRIEND_API</name><argument_list>(<argument>bool</argument>)</argument_list></macro> <macro><name>bumpCommit</name><argument_list>(<argument>Value *from</argument>, <argument>ptrdiff_t nvals</argument>)</argument_list></macro> const</expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr><name>public</name>:
    static const <name>size_t</name> <name>CAPACITY_VALS</name>   = 512 * 1024</expr>;
    <expr>static const <name>size_t</name> <name>CAPACITY_BYTES</name>  = <name>CAPACITY_VALS</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></sizeof></expr>;
    <expr>static const <name>size_t</name> <name>COMMIT_VALS</name>     = 16 * 1024</expr>;
    <expr>static const <name>size_t</name> <name>COMMIT_BYTES</name>    = <name>COMMIT_VALS</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></sizeof></expr>;

    <comment type="block">/*
     * SunSpider and v8bench have roughly an average of 9 slots per script.
     * Our heuristic for a quick over-recursion check uses a generous slot
     * count based on this estimate. We take this frame size and multiply it
     * by the old recursion limit from the interpreter.
     *
     * Worst case, if an average size script (&lt;=9 slots) over recurses, it'll
     * effectively be the same as having increased the old inline call count
     * to &lt;= 5,000.
     */</comment>
    <expr>static const <name>size_t</name> <name>STACK_QUOTA</name>    = (<name>VALUES_PER_STACK_FRAME</name> + 18) *
                                         <name>JS_MAX_INLINE_CALL_COUNT</name></expr>;

    <comment type="block">/* Kept as a member of JSThreadData; cannot use constructor/destructor. */</comment>
    <expr><name>bool</name> <call><name>init</name><argument_list>()</argument_list></call></expr>;
    <expr><name>void</name> <call><name>finish</name><argument_list>()</argument_list></call></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr><name>template</name> &lt;<name>class</name> <name>T</name>&gt;
    <name>bool</name> <macro><name>contains</name><argument_list>(<argument>T *t</argument>)</argument_list></macro> const <block>{
        <expr><name>char</name> *<name>v</name> = (<name>char</name> *)<name>t</name></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>size_t</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call> - <call><name>uintptr_t</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>v</name> &gt;= (<name>char</name> *)<name>base</name> &amp;&amp; <name>v</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> &lt;= (<name>char</name> *)<name>end</name></expr>;</return>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * When we LeaveTree, we need to rebuild the stack, which requires stack
     * allocation. There is no good way to handle an OOM for these allocations,
     * so this function checks that they cannot occur using the size of the
     * TraceNativeStorage as a conservative upper bound.
     */</comment>
    inline <name>bool</name> <call><name>ensureEnoughSpaceToEnterTrace</name><argument_list>()</argument_list></call></expr>;

    <comment type="block">/* +1 for slow native's stack frame. */</comment>
    <expr>static const <name>ptrdiff_t</name> <name>MAX_TRACE_SPACE_VALS</name> =
      <name>MAX_NATIVE_STACK_SLOTS</name> + <name>MAX_CALL_STACK_ENTRIES</name> * <name>VALUES_PER_STACK_FRAME</name> +
      (<name>VALUES_PER_STACK_SEGMENT</name> + <name>VALUES_PER_STACK_FRAME</name> <comment type="block">/* synthesized slow native */</comment>)</expr>;

    <comment type="block">/* Mark all segments, frames, and slots on the stack. */</comment>
    <expr><name>JS_REQUIRES_STACK</name> <name>void</name> <call><name>mark</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/*
     * For all five use cases below:
     *  - The boolean-valued functions call js_ReportOutOfScriptQuota on OOM.
     *  - The "get*Frame" functions do not change any global state, they just
     *    check OOM and return pointers to an uninitialized frame with the
     *    requested missing arguments/slots. Only once the "push*Frame"
     *    function has been called is global state updated. Thus, between
     *    "get*Frame" and "push*Frame", the frame and slots are unrooted.
     *  - The "push*Frame" functions will set fp-&gt;prev; the caller needn't.
     *  - Functions taking "*Guard" arguments will use the guard's destructor
     *    to pop the allocation. The caller must ensure the guard has the
     *    appropriate lifetime.
     *  - The get*Frame functions put the 'nmissing' slots contiguously after
     *    the arguments.
     */</comment>

    <comment type="block">/*
     * pushInvokeArgs allocates |argc + 2| rooted values that will be passed as
     * the arguments to Invoke. A single allocation can be used for multiple
     * Invoke calls. The InvokeArgumentsGuard passed to Invoke must come from
     * an immediately-enclosing (stack-wise) call to pushInvokeArgs.
     */</comment>
    <expr><name>bool</name> <macro><name>pushInvokeArgs</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN argc</argument>, <argument>InvokeArgsGuard *ag</argument>)</argument_list></macro></expr>;

    <comment type="block">/* These functions are called inside Invoke, not Invoke clients. */</comment>
    <expr><name>bool</name> <macro><name>getInvokeFrame</name><argument_list>(<argument>JSContext *cx</argument>, <argument>const CallArgs &amp;args</argument>, <argument>JSFunction *fun</argument>,
                        <argument>JSScript *script</argument>, <argument>uint32 *flags</argument>, <argument>InvokeFrameGuard *fg</argument>)</argument_list></macro> const</expr>;

    <expr><name>void</name> <call><name>pushInvokeFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr>const <name>CallArgs</name> &amp;<name>args</name></expr></argument>, <argument><expr><name>InvokeFrameGuard</name> *<name>fg</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/* These functions are called inside Execute, not Execute clients. */</comment>
    <expr><name>bool</name> <macro><name>getExecuteFrame</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script</argument>, <argument>ExecuteFrameGuard *fg</argument>)</argument_list></macro> const</expr>;
    <expr><name>void</name> <call><name>pushExecuteFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSObject</name> *<name>initialVarObj</name></expr></argument>, <argument><expr><name>ExecuteFrameGuard</name> *<name>fg</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/*
     * Since RAII cannot be used for inline frames, callers must manually
     * call pushInlineFrame/popInlineFrame.
     */</comment>
    <expr>inline <name>JSStackFrame</name> *<macro><name>getInlineFrame</name><argument_list>(<argument>JSContext *cx</argument>, <argument>Value *sp</argument>, <argument>uintN nactual</argument>,
                                        <argument>JSFunction *fun</argument>, <argument>JSScript *script</argument>,
                                        <argument>uint32 *flags</argument>)</argument_list></macro> const</expr>;
    <expr>inline <name>void</name> <call><name>pushInlineFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSScript</name> *<name>script</name></expr></argument>, <argument><expr><name>JSStackFrame</name> *<name>fp</name></expr></argument>,
                                <argument><expr><name>JSFrameRegs</name> *<name>regs</name></expr></argument>)</argument_list></call></expr>;
    <expr>inline <name>void</name> <call><name>popInlineFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSStackFrame</name> *<name>prev</name></expr></argument>, <argument><expr><name>js</name>::<name>Value</name> *<name>newsp</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/* These functions are called inside SendToGenerator. */</comment>
    <expr><name>bool</name> <macro><name>getGeneratorFrame</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN vplen</argument>, <argument>uintN nfixed</argument>,
                           <argument>GeneratorFrameGuard *fg</argument>)</argument_list></macro></expr>;
    <expr><name>void</name> <call><name>pushGeneratorFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSFrameRegs</name> *<name>regs</name></expr></argument>, <argument><expr><name>GeneratorFrameGuard</name> *<name>fg</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/* Pushes a JSStackFrame::isDummyFrame. */</comment>
    <expr><name>bool</name> <call><name>pushDummyFrame</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSObject</name> &amp;<name>scopeChain</name></expr></argument>, <argument><expr><name>DummyFrameGuard</name> *<name>fg</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/* Check and bump the given stack limit. */</comment>
    <expr>inline <name>JSStackFrame</name> *<macro><name>getInlineFrameWithinLimit</name><argument_list>(<argument>JSContext *cx</argument>, <argument>Value *sp</argument>, <argument>uintN nactual</argument>,
                                                   <argument>JSFunction *fun</argument>, <argument>JSScript *script</argument>, <argument>uint32 *flags</argument>,
                                                   <argument>JSStackFrame *base</argument>, <argument>Value **limit</argument>)</argument_list></macro> const</expr>;

    <comment type="block">/*
     * Compute a stack limit for entering method jit code which allows the
     * method jit to check for end-of-stack and over-recursion with a single
     * comparison. See STACK_QUOTA above.
     */</comment>
    <expr>inline <name>Value</name> *<call><name>getStackLimit</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/*
     * Try to bump the given 'limit' by bumping the commit limit. Return false
     * if fully committed or if 'limit' exceeds 'base' + STACK_QUOTA.
     */</comment>
    <expr><name>bool</name> <macro><name>bumpCommitAndLimit</name><argument_list>(<argument>JSStackFrame *base</argument>, <argument>Value *from</argument>, <argument>uintN nvals</argument>, <argument>Value **limit</argument>)</argument_list></macro> const</expr>;

    <comment type="block">/*
     * Allocate nvals on the top of the stack, report error on failure.
     * N.B. the caller must ensure |from &gt;= firstUnused()|.
     */</comment>
    <expr>inline <name>bool</name> <macro><name>ensureSpace</name><argument_list>(<argument>JSContext *maybecx</argument>, <argument>Value *from</argument>, <argument>ptrdiff_t nvals</argument>)</argument_list></macro> const</expr>;
}</block></expr>;

<expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>StackSpace</name>::<name>CAPACITY_VALS</name> % <name>StackSpace</name>::<name>COMMIT_VALS</name> == 0</expr></argument>)</argument_list></call></expr>;

<comment type="block">/*
 * While |cx-&gt;fp|'s pc/sp are available in |cx-&gt;regs|, to compute the saved
 * value of pc/sp for any other frame, it is necessary to know about that
 * frame's next-frame. This iterator maintains this information when walking
 * a chain of stack frames starting at |cx-&gt;fp|.
 *
 * Usage:
 *   for (FrameRegsIter i(cx); !i.done(); ++i)
 *     ... i.fp() ... i.sp() ... i.pc()
 */</comment>
<expr><name>class</name> <name>FrameRegsIter</name>
<block>{
    <expr><name>JSContext</name>         *<name>cx</name></expr>;
    <expr><name>StackSegment</name>      *<name>curseg</name></expr>;
    <expr><name>JSStackFrame</name>      *<name>curfp</name></expr>;
    <expr><name>Value</name>             *<name>cursp</name></expr>;
    <expr><name>jsbytecode</name>        *<name>curpc</name></expr>;

    <expr><name>void</name> <call><name>initSlow</name><argument_list>()</argument_list></call></expr>;
    <expr><name>void</name> <call><name>incSlow</name><argument_list>(<argument><expr><name>JSStackFrame</name> *<name>fp</name></expr></argument>, <argument><expr><name>JSStackFrame</name> *<name>prev</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>public</name>:
    <name>JS_REQUIRES_STACK</name> inline <call><name>FrameRegsIter</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>bool</name> <macro><name>done</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>curfp</name> == <name>NULL</name></expr>;</return> }</block>
    inline <name>FrameRegsIter</name> &amp;<name>operator</name>++()</expr>;

    <expr><name>JSStackFrame</name> *<macro><name>fp</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>curfp</name></expr>;</return> }</block>
    <name>Value</name> *<macro><name>sp</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>cursp</name></expr>;</return> }</block>
    <name>jsbytecode</name> *<macro><name>pc</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>curpc</name></expr>;</return> }</block>
}</expr>;

<comment type="block">/*
 * Utility class for iteration over all active stack frames.
 */</comment>
<expr><name>class</name> <name>AllFramesIter</name>
<block>{
<expr><name>public</name>:
    <call><name>AllFramesIter</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>bool</name> <macro><name>done</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>curfp</name> == <name>NULL</name></expr>;</return> }</block>
    <name>AllFramesIter</name>&amp; <name>operator</name>++()</expr>;

    <expr><name>JSStackFrame</name> *<macro><name>fp</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>curfp</name></expr>;</return> }</block>

<name>private</name>:
    <name>StackSegment</name> *<name>curcs</name></expr>;
    <expr><name>JSStackFrame</name> *<name>curfp</name></expr>;
}</block></expr>;

}</block> <comment type="block">/* namespace js */</comment>

<comment type="block">/*
 * N.B. JS_ON_TRACE(cx) is true if JIT code is on the stack in the current
 * thread, regardless of whether cx is the context in which that trace is
 * executing.  cx must be a context on the current thread.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ON_TRACE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>(JS_TRACE_MONITOR(cx).ontrace())</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ON_TRACE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>false</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_KIND_METER_LIST</name><parameter_list>(<param><type><name>_</name></type></param>)</parameter_list></cpp:macro>                                          \
                        <cpp:value>_(allfun), _(heavy), _(nofreeupvar), _(onlyfreevar),  \
                        _(display), _(flat), _(setupvar), _(badfunarg),       \
                        _(joinedsetmethod), _(joinedinitmethod),              \
                        _(joinedreplace), _(joinedsort), _(joinedmodulepat),  \
                        _(mreadbarrier), _(mwritebarrier), _(mwslotbarrier),  \
                        _(unjoined)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>identity</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>x</cpp:value></cpp:define>

struct <name>JSFunctionMeter</name> <block>{
    <expr><name>int32</name> <call><name>FUNCTION_KIND_METER_LIST</name><argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<cpp:undef># <cpp:directive>undef</cpp:directive> <name>identity</name></cpp:undef>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_FUNCTION_METER</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_RUNTIME_METER((cx)-&gt;runtime, functionMeter.x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_FUNCTION_METER</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ITER_CACHE_LOG2</name></cpp:macro>  <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ITER_CACHE_MASK</name></cpp:macro>  <cpp:value>JS_BITMASK(NATIVE_ITER_CACHE_LOG2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ITER_CACHE_SIZE</name></cpp:macro>  <cpp:value>JS_BIT(NATIVE_ITER_CACHE_LOG2)</cpp:value></cpp:define>

struct <expr><name>JSPendingProxyOperation</name> <block>{
    <expr><name>JSPendingProxyOperation</name> *<name>next</name></expr>;
    <expr><name>JSObject</name> *<name>object</name></expr>;
}</block></expr>;

struct <expr><name>JSThreadData</name> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/* The request depth for this thread. */</comment>
    <expr><name>unsigned</name>            <name>requestDepth</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If non-zero, we were been asked to call the operation callback as soon
     * as possible.  If the thread has an active request, this contributes
     * towards rt-&gt;interruptCounter.
     */</comment>
    <expr>volatile <name>int32</name>      <name>interruptFlags</name></expr>;

    <comment type="block">/* Keeper of the contiguous stack used by all contexts in this thread. */</comment>
    <expr><name>js</name>::<name>StackSpace</name>      <name>stackSpace</name></expr>;

    <comment type="block">/*
     * Flag indicating that we are waiving any soft limits on the GC heap
     * because we want allocations to be infallible (except when we hit OOM).
     */</comment>
    <expr><name>bool</name>                <name>waiveGCQuota</name></expr>;

    <comment type="block">/*
     * The GSN cache is per thread since even multi-cx-per-thread embeddings
     * do not interleave js_GetSrcNote calls.
     */</comment>
    <expr><name>JSGSNCache</name>          <name>gsnCache</name></expr>;

    <comment type="block">/* Property cache for faster call/get/set invocation. */</comment>
    <expr><name>js</name>::<name>PropertyCache</name>   <name>propertyCache</name></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/* Counts the number of iterations run by a trace. */</comment>
    <expr><name>unsigned</name>            <name>iterationCounter</name></expr>;

    <comment type="block">/* Maximum size of the tracer's code cache before we start flushing. */</comment>
    <expr><name>uint32</name>              <name>maxCodeCacheBytes</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* State used by dtoa.c. */</comment>
    <expr><name>DtoaState</name>           *<name>dtoaState</name></expr>;

    <comment type="block">/*
     * A single-entry cache for some base-10 double-to-string conversions.
     * This helps date-format-xparb.js.  It also avoids skewing the results
     * for v8-splay.js when measured by the SunSpider harness, where the splay
     * tree initialization (which includes many repeated double-to-string
     * conversions) is erroneously included in the measurement; see bug
     * 562553.
     */</comment>
    struct <expr><block>{
        <expr><name>jsdouble</name> <name>d</name></expr>;
        <expr><name>jsint</name>    <name>base</name></expr>;
        <expr><name>JSString</name> *<name>s</name></expr>;        <comment type="line">// if s==NULL, d and base are not valid</comment>
    }</block> <name>dtoaCache</name></expr>;

    <comment type="block">/* Cached native iterators. */</comment>
    <expr><name>JSObject</name>            *<name><name>cachedNativeIterators</name><index>[<expr><name>NATIVE_ITER_CACHE_SIZE</name></expr>]</index></name></expr>;

    <comment type="block">/* Native iterator most recently started. */</comment>
    <expr><name>JSObject</name>            *<name>lastNativeIterator</name></expr>;

    <comment type="block">/* Base address of the native stack for the current thread. */</comment>
    <expr><name>jsuword</name>             *<name>nativeStackBase</name></expr>;

    <comment type="block">/* List of currently pending operations on proxies. */</comment>
    <expr><name>JSPendingProxyOperation</name> *<name>pendingProxyOperation</name></expr>;

    <expr><name>js</name>::<name>ConservativeGCThreadData</name> <name>conservativeGC</name></expr>;

  <expr><name>private</name>:
    <name>js</name>::<name>MathCache</name>       *<name>mathCache</name></expr>;

    <expr><name>js</name>::<name>MathCache</name> *<call><name>allocMathCache</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>public</name>:

    <name>js</name>::<name>MathCache</name> *<macro><name>getMathCache</name><argument_list>(<argument>JSContext *cx</argument>)</argument_list></macro> <block>{
        <return>return <expr><name>mathCache</name> ? <name>mathCache</name> : <call><name>allocMathCache</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block>

    <name>bool</name> <call><name>init</name><argument_list>()</argument_list></call></expr>;
    <expr><name>void</name> <call><name>finish</name><argument_list>()</argument_list></call></expr>;
    <expr><name>void</name> <call><name>mark</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>void</name> <call><name>purge</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/* This must be called with the GC lock held. */</comment>
    <expr>inline <name>void</name> <call><name>triggerOperationCallback</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>

<comment type="block">/*
 * Structure uniquely representing a thread.  It holds thread-private data
 * that can be accessed without a global lock.
 */</comment>
struct <expr><name>JSThread</name> <block>{
    <typedef>typedef <expr_stmt><expr><name>js</name>::<name>HashMap</name>&lt;<name>void</name> *</expr>,
                        <expr><name>JSThread</name> *</expr>,
                        <expr><name>js</name>::<name>DefaultHasher</name>&lt;<name>void</name> *&gt;</expr>,
                        <expr><name>js</name>::<name>SystemAllocPolicy</name>&gt; <name>Map</name></expr>;</expr_stmt></typedef>

    <comment type="block">/* Linked list of all contexts in use on this thread. */</comment>
    <name>JSCList</name>             <name>contextList</name></block></expr>;

    <comment type="block">/* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */</comment>
    <expr><name>void</name>                *<name>id</name></expr>;

    <comment type="block">/* Number of JS_SuspendRequest calls withot JS_ResumeRequest. */</comment>
    <expr><name>unsigned</name>            <name>suspendCount</name></expr>;

<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr><name>unsigned</name>            <name>checkRequestDepth</name></expr>;
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Factored out of JSThread for !JS_THREADSAFE embedding in JSRuntime. */</comment>
    <expr><name>JSThreadData</name>        <name>data</name></expr>;
}</block></expr>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_DATA</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>(&amp;(cx)-&gt;thread-&gt;data)</cpp:value></cpp:define>

<expr>extern <name>JSThread</name> *
<call><name>js_CurrentThread</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call></expr>;

<comment type="block">/*
 * The function takes the GC lock and does not release in successful return.
 * On error (out of memory) the function releases the lock but delegates
 * the error reporting to the caller.
 */</comment>
<expr>extern <name>JSBool</name>
<call><name>js_InitContextThread</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

<comment type="block">/*
 * On entrance the GC lock must be held and it will be held on exit.
 */</comment>
<expr>extern <name>void</name>
<call><name>js_ClearContextThread</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>

<typedef>typedef <type><enum>enum <name>JSDestroyContextMode</name> <block>{
    <decl><name>JSDCM_NO_GC</name></decl>,
    <decl><name>JSDCM_MAYBE_GC</name></decl>,
    <decl><name>JSDCM_FORCE_GC</name></decl>,
    <decl><name>JSDCM_NEW_FAILED</name>
} <name>JSDestroyContextMode</name></decl><empty_stmt>;</empty_stmt>

<typedef>typedef <type><enum>enum <name>JSRuntimeState</name> <block>{
    <decl><name>JSRTS_DOWN</name></decl>,
    <decl><name>JSRTS_LAUNCHING</name></decl>,
    <decl><name>JSRTS_UP</name></decl>,
    <decl><name>JSRTS_LANDING</name>
} <name>JSRuntimeState</name></decl><empty_stmt>;</empty_stmt>

<typedef>typedef <type><struct>struct <name>JSPropertyTreeEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>js</name>::<name>Shape</name>           *<name>child</name></expr>;</expr_stmt>
<expr_stmt/>}</block> <expr_stmt><expr><name>JSPropertyTreeEntry</name></expr>;</expr_stmt></struct></type></typedef>

<typedef>typedef <function_decl><type><name>void</name></type>
(* <name>JSActivityCallback</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>active</name></decl></param>)</parameter_list>;</function_decl></typedef>

<type><name>namespace</name></type> <name>js</name> <block>{

<typedef>typedef <expr_stmt><expr><name>js</name>::<name>Vector</name>&lt;<name>JSCompartment</name> *</expr>, <expr>0</expr>, <expr><name>js</name>::<name>SystemAllocPolicy</name>&gt; <name>WrapperVector</name></expr>;</expr_stmt></typedef>

<expr_stmt/>}</block>

struct <name>JSRuntime</name> <block>{
    <comment type="block">/* Default compartment. */</comment>
    <type><name>JSCompartment</name>       *</type><name>defaultCompartment</name>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <type><name>bool</name></type>                <name>defaultCompartmentIsLocked</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* List of compartments (protected by the GC lock). */</comment>
    <expr_stmt><expr><name>js</name>::<name>WrapperVector</name> <name>compartments</name></expr>;</expr_stmt>

    <comment type="block">/* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */</comment>
    <type><name>JSRuntimeState</name></type>      <name>state</name>;

    <comment type="block">/* Context create/destroy callback. */</comment>
    <type><name>JSContextCallback</name></type>   <name>cxCallback</name>;

    <comment type="block">/* Compartment create/destroy callback. */</comment>
    <type><name>JSCompartmentCallback</name></type> <name>compartmentCallback</name>;

    <comment type="block">/*
     * Sets a callback that is run whenever the runtime goes idle - the
     * last active request ceases - and begins activity - when it was
     * idle and a request begins. Note: The callback is called under the
     * GC lock.
     */</comment>
    <function><type><name>void</name></type> <name>setActivityCallback</name><parameter_list>(<param><decl><type><name>JSActivityCallback</name></type> <name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>activityCallback</name> = <name>cb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>activityCallbackArg</name> = <name>arg</name></expr>;</expr_stmt>
    <expr_stmt/>}</block>

    <type><name>JSActivityCallback</name></type>    <name>activityCallback</name>;
    <type><name>void</name>                 *</type><name>activityCallbackArg</name>;

    <comment type="block">/*
     * Shape regenerated whenever a prototype implicated by an "add property"
     * property cache fill and induced trace guard has a readonly property or a
     * setter defined on it. This number proxies for the shapes of all objects
     * along the prototype chain of all objects in the runtime on which such an
     * add-property result has been cached/traced.
     *
     * See bug 492355 for more details.
     *
     * This comes early in JSRuntime to minimize the immediate format used by
     * trace-JITted code that reads it.
     */</comment>
    <type><name>uint32</name></type>              <name>protoHazardShape</name>;

    <comment type="block">/* Garbage collector state, used by jsgc.c. */</comment>
    js::<type><name>GCChunkSet</name></type>      <name>gcChunkSet</name>;

    js::<type><name>RootedValueMap</name></type>  <name>gcRootsHash</name>;
    js::<type><name>GCLocks</name></type>         <name>gcLocksHash</name>;
    <type><name>jsrefcount</name></type>          <name>gcKeepAtoms</name>;
    <type><name>size_t</name></type>              <name>gcBytes</name>;
    <type><name>size_t</name></type>              <name>gcTriggerBytes</name>;
    <type><name>size_t</name></type>              <name>gcLastBytes</name>;
    <type><name>size_t</name></type>              <name>gcMaxBytes</name>;
    <type><name>size_t</name></type>              <name>gcMaxMallocBytes</name>;
    <type><name>uint32</name></type>              <name>gcEmptyArenaPoolLifespan</name>;
    <type><name>uint32</name></type>              <name>gcNumber</name>;
    js::<type><name>GCMarker</name>        *</type><name>gcMarkingTracer</name>;
    <type><name>uint32</name></type>              <name>gcTriggerFactor</name>;
    <type><specifier>volatile</specifier> <name>JSBool</name></type>     <name>gcIsNeeded</name>;

    <comment type="block">/*
     * We can pack these flags as only the GC thread writes to them. Atomic
     * updates to packed bytes are not guaranteed, so stores issued by one
     * thread may be lost due to unsynchronized read-modify-write cycles on
     * other threads.
     */</comment>
    <type><name>bool</name></type>                <name>gcPoke</name>;
    <type><name>bool</name></type>                <name>gcMarkAndSweep</name>;
    <type><name>bool</name></type>                <name>gcRunning</name>;
    <type><name>bool</name></type>                <name>gcRegenShapes</name>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GC_ZEAL</name></cpp:ifdef>
    <type><name>jsrefcount</name></type>          <name>gcZeal</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <type><name>JSGCCallback</name></type>        <name>gcCallback</name>;

  private:
    <comment type="block">/*
     * Malloc counter to measure memory pressure for GC scheduling. It runs
     * from gcMaxMallocBytes down to zero.
     */</comment>
    <type><specifier>volatile</specifier> <name>ptrdiff_t</name></type>  <name>gcMallocBytes</name>;

  public:
    js::<type><name>GCChunkAllocator</name>    *</type><name>gcChunkAllocator</name>;

    <type><name>void</name></type> <name>setCustomGCChunkAllocator</name>(js::GCChunkAllocator *allocator</function>)</block> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>state</name> == <name>JSRTS_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gcChunkAllocator</name> = <name>allocator</name></expr>;</expr_stmt>
    <expr_stmt/>}</block>

    <comment type="block">/*
     * The trace operation and its data argument to trace embedding-specific
     * GC roots.
     */</comment>
    <name>JSTraceDataOp</name>       <name>gcExtraRootsTraceOp</name>;
    <type><name>void</name>                *</type><name>gcExtraRootsData</name>;

    <comment type="block">/* Well-known numbers held for use by this runtime's contexts. */</comment>
    <decl><name>js</name>::<name>Value</name>           <name>NaNValue</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>Value</name>           <name>negativeInfinityValue</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>Value</name>           <name>positiveInfinityValue</name></decl><empty_stmt>;</empty_stmt>

    <type><name>JSString</name>            *</type><name>emptyString</name>;

    <comment type="block">/* List of active contexts sharing this runtime; protected by gcLock. */</comment>
    <type><name>JSCList</name></type>             <name>contextList</name>;

    <comment type="block">/* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */</comment>
    <type><name>JSDebugHooks</name></type>        <name>globalDebugHooks</name>;

    <comment type="block">/*
     * Right now, we only support runtime-wide debugging.
     */</comment>
    <type><name>JSBool</name></type>              <name>debugMode</name>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/* True if any debug hooks not supported by the JIT are enabled. */</comment>
    <decl><name>bool</name> <name>debuggerInhibitsJIT</name><argument_list>()</argument_list> const <block>{
        <return>return <expr>(<name><name>globalDebugHooks</name>.<name>interruptHook</name></name> ||
                <name><name>globalDebugHooks</name>.<name>callHook</name></name>)</expr>;</return>
    <expr_stmt/>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* More debugging state, see jsdbgapi.c. */</comment>
    <name>JSCList</name>             <name>trapList</name></decl><empty_stmt>;</empty_stmt>
    <type><name>JSCList</name></type>             <name>watchPointList</name>;

    <comment type="block">/* Client opaque pointers */</comment>
    <type><name>void</name>                *</type><name>data</name>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/* These combine to interlock the GC and new requests. */</comment>
    <type><name>PRLock</name>              *</type><name>gcLock</name>;
    <type><name>PRCondVar</name>           *</type><name>gcDone</name>;
    <type><name>PRCondVar</name>           *</type><name>requestDone</name>;
    <type><name>uint32</name></type>              <name>requestCount</name>;
    <type><name>JSThread</name>            *</type><name>gcThread</name>;

    <decl><name>js</name>::<name>GCHelperThread</name>  <name>gcHelperThread</name></decl><empty_stmt>;</empty_stmt>

    <comment type="block">/* Lock and owning thread pointer for JS_LOCK_RUNTIME. */</comment>
    <type><name>PRLock</name>              *</type><name>rtLock</name>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <type><name>void</name> *</type>              <name>rtLockOwner</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Used to synchronize down/up state change; protected by gcLock. */</comment>
    <type><name>PRCondVar</name>           *</type><name>stateChange</name>;

    <comment type="block">/*
     * Lock serializing trapList and watchPointList accesses, and count of all
     * mutations to trapList and watchPointList made by debugger threads.  To
     * keep the code simple, we define debuggerMutations for the thread-unsafe
     * case too.
     */</comment>
    <type><name>PRLock</name>              *</type><name>debuggerLock</name>;

    <decl><name>JSThread</name>::<name>Map</name>       <name>threads</name></decl><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>
    <type><name>uint32</name></type>              <name>debuggerMutations</name>;

    <comment type="block">/*
     * Security callbacks set on the runtime are used by each context unless
     * an override is set on the context.
     */</comment>
    <type><name>JSSecurityCallbacks</name> *</type><name>securityCallbacks</name>;

    <comment type="block">/* Structured data callbacks are runtime-wide. */</comment>
    <type><specifier>const</specifier> <name>JSStructuredCloneCallbacks</name> *</type><name>structuredCloneCallbacks</name>;

    <comment type="block">/*
     * Shared scope property tree, and arena-pool for allocating its nodes.
     * This really should be free of all locking overhead and allocated in
     * thread-local storage, hence the JS_PROPERTY_TREE(cx) macro.
     */</comment>
    <decl><name>js</name>::<name>PropertyTree</name>    <name>propertyTree</name></decl><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PROPERTY_TREE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((cx)-&gt;runtime-&gt;propertyTree)</cpp:value></cpp:define>

    <comment type="block">/*
     * The propertyRemovals counter is incremented for every JSObject::clear,
     * and for each JSObject::remove method call that frees a slot in the given
     * object. See js_NativeGet and js_NativeSet in jsobj.cpp.
     */</comment>
    <type><name>int32</name></type>               <name>propertyRemovals</name>;

    <comment type="block">/* Script filename table. */</comment>
    <type>struct <name>JSHashTable</name>  *</type><name>scriptFilenameTable</name>;
    <type><name>JSCList</name></type>             <name>scriptFilenamePrefixes</name>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <type><name>PRLock</name>              *</type><name>scriptFilenameTableLock</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Number localization, used by jsnum.c */</comment>
    <type><specifier>const</specifier> <name>char</name>          *</type><name>thousandsSeparator</name>;
    <type><specifier>const</specifier> <name>char</name>          *</type><name>decimalSeparator</name>;
    <type><specifier>const</specifier> <name>char</name>          *</type><name>numGrouping</name>;

    <comment type="block">/*
     * Weak references to lazily-created, well-known XML singletons.
     *
     * NB: Singleton objects must be carefully disconnected from the rest of
     * the object graph usually associated with a JSContext's global object,
     * including the set of standard class objects.  See jsxml.c for details.
     */</comment>
    <type><name>JSObject</name>            *</type><name>anynameObject</name>;
    <type><name>JSObject</name>            *</type><name>functionNamespaceObject</name>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/* Number of threads with active requests and unhandled interrupts. */</comment>
    <type><specifier>volatile</specifier> <name>int32</name></type>      <name>interruptCounter</name>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <type><name>JSThreadData</name></type>        <name>threadData</name>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_DATA</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>(&amp;(cx)-&gt;runtime-&gt;threadData)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Object shape (property cache structural type) identifier generator.
     *
     * Type 0 stands for the empty scope, and must not be regenerated due to
     * uint32 wrap-around. Since js_GenerateShape (in jsinterp.cpp) uses
     * atomic pre-increment, the initial value for the first typed non-empty
     * scope will be 1.
     *
     * If this counter overflows into SHAPE_OVERFLOW_BIT (in jsinterp.h), the
     * cache is disabled, to avoid aliasing two different types. It stays
     * disabled until a triggered GC at some later moment compresses live
     * types, minimizing rt-&gt;shapeGen in the process.
     */</comment>
    <type><specifier>volatile</specifier> <name>uint32</name></type>     <name>shapeGen</name>;

    <comment type="block">/* Literal table maintained by jsatom.c functions. */</comment>
    <type><name>JSAtomState</name></type>         <name>atomState</name>;

    <comment type="block">/*
     * Runtime-shared empty scopes for well-known built-in objects that lack
     * class prototypes (the usual locus of an emptyShape). Mnemonic: ABCDEW
     */</comment>
    <decl><name>js</name>::<name>EmptyShape</name>      *<name>emptyArgumentsShape</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>EmptyShape</name>      *<name>emptyBlockShape</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>EmptyShape</name>      *<name>emptyCallShape</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>EmptyShape</name>      *<name>emptyDeclEnvShape</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>EmptyShape</name>      *<name>emptyEnumeratorShape</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>EmptyShape</name>      *<name>emptyWithShape</name></decl><empty_stmt>;</empty_stmt>

    <comment type="block">/*
     * Various metering fields are defined at the end of JSRuntime. In this
     * way there is no need to recompile all the code that refers to other
     * fields of JSRuntime after enabling the corresponding metering macro.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_DUMP_ENUM_CACHE_STATS</name></cpp:ifdef>
    <type><name>int32</name></type>               <name>nativeEnumProbes</name>;
    <type><name>int32</name></type>               <name>nativeEnumMisses</name>;
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_CACHE_METER</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>JS_ATOMIC_INCREMENT(&amp;cx-&gt;runtime-&gt;name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_CACHE_METER</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_DUMP_LOOP_STATS</name></cpp:ifdef>
    <comment type="block">/* Loop statistics, to trigger trace recording and compiling. */</comment>
    <type><name>JSBasicStats</name></type>        <name>loopStats</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* Function invocation metering. */</comment>
    <type><name>jsrefcount</name></type>          <name>inlineCalls</name>;
    <type><name>jsrefcount</name></type>          <name>nativeCalls</name>;
    <type><name>jsrefcount</name></type>          <name>nonInlineCalls</name>;
    <type><name>jsrefcount</name></type>          <name>constructs</name>;

    <comment type="block">/* Property metering. */</comment>
    <type><name>jsrefcount</name></type>          <name>liveObjectProps</name>;
    <type><name>jsrefcount</name></type>          <name>liveObjectPropsPreSweep</name>;
    <type><name>jsrefcount</name></type>          <name>totalObjectProps</name>;
    <type><name>jsrefcount</name></type>          <name>livePropTreeNodes</name>;
    <type><name>jsrefcount</name></type>          <name>duplicatePropTreeNodes</name>;
    <type><name>jsrefcount</name></type>          <name>totalPropTreeNodes</name>;
    <type><name>jsrefcount</name></type>          <name>propTreeKidsChunks</name>;
    <type><name>jsrefcount</name></type>          <name>liveDictModeNodes</name>;

    <comment type="block">/*
     * NB: emptyShapes is init'ed iff at least one of these envars is set:
     *
     *  JS_PROPTREE_STATFILE  statistics on the property tree forest
     *  JS_PROPTREE_DUMPFILE  all paths in the property tree forest
     */</comment>
    <type><specifier>const</specifier> <name>char</name>          *</type><name>propTreeStatFilename</name>;
    <type><specifier>const</specifier> <name>char</name>          *</type><name>propTreeDumpFilename</name>;

    <decl><name>bool</name> <name>meterEmptyShapes</name><argument_list>()</argument_list> const <block>{ <return>return <expr><name>propTreeStatFilename</name> || <name>propTreeDumpFilename</name></expr>;</return> <expr_stmt/>}</block>

    typedef <name>js</name>::<name>HashSet</name><name/>&lt;<name>js</name>::<name>EmptyShape</name> *</decl>,
                        <decl><name>js</name>::<name>DefaultHasher</name><name/>&lt;<name>js</name>::<name>EmptyShape</name> *&gt;</decl>,
                        <decl><name>js</name>::<name>SystemAllocPolicy</name>&gt; <name>EmptyShapeSet</name></decl><empty_stmt>;</empty_stmt>

    <type><name>EmptyShapeSet</name></type>       <name>emptyShapes</name>;

    <comment type="block">/* String instrumentation. */</comment>
    <type><name>jsrefcount</name></type>          <name>liveStrings</name>;
    <type><name>jsrefcount</name></type>          <name>totalStrings</name>;
    <type><name>jsrefcount</name></type>          <name>liveDependentStrings</name>;
    <type><name>jsrefcount</name></type>          <name>totalDependentStrings</name>;
    <type><name>jsrefcount</name></type>          <name>badUndependStrings</name>;
    <type><name>double</name></type>              <name>lengthSum</name>;
    <type><name>double</name></type>              <name>lengthSquaredSum</name>;
    <type><name>double</name></type>              <name>strdepLengthSum</name>;
    <type><name>double</name></type>              <name>strdepLengthSquaredSum</name>;

    <comment type="block">/* Script instrumentation. */</comment>
    <type><name>jsrefcount</name></type>          <name>liveScripts</name>;
    <type><name>jsrefcount</name></type>          <name>totalScripts</name>;
    <type><name>jsrefcount</name></type>          <name>liveEmptyScripts</name>;
    <type><name>jsrefcount</name></type>          <name>totalEmptyScripts</name>;
    <type><name>jsrefcount</name></type>          <name>highWaterLiveScripts</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_SCOPE_DEPTH_METER</name></cpp:ifdef>
    <comment type="block">/*
     * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
     * counts of objects traversed on a chain until the wanted id is found.
     */</comment>
    <type><name>JSBasicStats</name></type>        <name>protoLookupDepthStats</name>;
    <type><name>JSBasicStats</name></type>        <name>scopeSearchDepthStats</name>;

    <comment type="block">/*
     * Stats on compile-time host environment and lexical scope chain lengths
     * (maximum depths).
     */</comment>
    <type><name>JSBasicStats</name></type>        <name>hostenvScopeDepthStats</name>;
    <type><name>JSBasicStats</name></type>        <name>lexicalScopeDepthStats</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <decl><name>js</name>::<name>gc</name>::<name>JSGCStats</name>           <name>gcStats</name></decl><empty_stmt>;</empty_stmt>
    <decl><name>js</name>::<name>gc</name>::<name>JSGCArenaStats</name>      <name><name>globalArenaStats</name><index>[<expr><name>js</name>::<name>gc</name>::<name>FINALIZE_LIMIT</name></expr>]</index></name></decl><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/*
     * If functionMeterFilename, set from an envariable in JSRuntime's ctor, is
     * null, the remaining members in this ifdef'ed group are not initialized.
     */</comment>
    <type><specifier>const</specifier> <name>char</name>          *</type><name>functionMeterFilename</name>;
    <type><name>JSFunctionMeter</name></type>     <name>functionMeter</name>;
    <type><name>char</name></type>                <name><name>lastScriptFilename</name><index>[<expr>1024</expr>]</index></name>;

    <typedef>typedef <expr_stmt><expr><name>js</name>::<name>HashMap</name>&lt;<name>JSFunction</name> *</expr>,
                        <expr><name>int32</name></expr>,
                        <expr><name>js</name>::<name>DefaultHasher</name>&lt;<name>JSFunction</name> *&gt;</expr>,
                        <expr><name>js</name>::<name>SystemAllocPolicy</name>&gt; <name>FunctionCountMap</name></expr>;</expr_stmt></typedef>

    <type><name>FunctionCountMap</name></type>    <name>methodReadBarrierCountMap</name>;
    <type><name>FunctionCountMap</name></type>    <name>unjoinedFunctionCountMap</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <type><name>JSWrapObjectCallback</name></type> <name>wrapObjectCallback</name>;
    <type><name>JSPreWrapCallback</name></type>    <name>preWrapObjectCallback</name>;

    <decl><name>JSC</name>::<name>ExecutableAllocator</name> *<name>regExpAllocator</name></decl><empty_stmt>;</empty_stmt>

    <decl><name>JSRuntime</name><argument_list>()</argument_list></decl><empty_stmt>;</empty_stmt>
    <expr_stmt><expr>~<call><name>JSRuntime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>bool</name></type> <name>init</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>maxbytes</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>setGCTriggerFactor</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>factor</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>setGCLastBytes</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>lastBytes</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
     * Call the system malloc while checking for GC memory pressure and
     * reporting OOM error when cx is not null.
     */</comment>
    <function><type><name>void</name>*</type> <name>malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name>NULL</name></expr></init></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <type><name>void</name> *</type><name>p</name> <init>= <expr>::<call><name>js_malloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init>;
        <return>return <expr><call><name>JS_LIKELY</name><argument_list>(<argument><expr>!!<name>p</name></expr></argument>)</argument_list></call> ? <name>p</name> : <call><name>onOutOfMemory</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    <comment type="block">/*
     * Call the system calloc while checking for GC memory pressure and
     * reporting OOM error when cx is not null.
     */</comment>
    void* calloc<parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name>NULL</name></expr></init></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <type><name>void</name> *</type><name>p</name> <init>= <expr>::<call><name>js_calloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init>;
        <return>return <expr><call><name>JS_LIKELY</name><argument_list>(<argument><expr>!!<name>p</name></expr></argument>)</argument_list></call> ? <name>p</name> : <call><name>onOutOfMemory</name><argument_list>(<argument><expr><name>reinterpret_cast</name>&lt;<name>void</name> *&gt;(1)</expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    void* realloc<parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>oldBytes</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>newBytes</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name>NULL</name></expr></init></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>oldBytes</name> &lt; <name>newBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>newBytes</name> - <name>oldBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <type><name>void</name> *</type><name>p2</name> <init>= <expr>::<call><name>js_realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newBytes</name></expr></argument>)</argument_list></call></expr></init>;
        <return>return <expr><call><name>JS_LIKELY</name><argument_list>(<argument><expr>!!<name>p2</name></expr></argument>)</argument_list></call> ? <name>p2</name> : <call><name>onOutOfMemory</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newBytes</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    void* realloc<parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr><name>NULL</name></expr></init></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * For compatibility we do not account for realloc that increases
         * previously allocated memory.
         */</comment>
        <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <type><name>void</name> *</type><name>p2</name> <init>= <expr>::<call><name>js_realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init>;
        <return>return <expr><call><name>JS_LIKELY</name><argument_list>(<argument><expr>!!<name>p2</name></expr></argument>)</argument_list></call> ? <name>p2</name> : <call><name>onOutOfMemory</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    void free<parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr>::<call><name>js_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt/>}</block>

    bool isGCMallocLimitReached<parameter_list>()</parameter_list> const <block>{ <return>return <expr><name>gcMallocBytes</name> &lt;= 0</expr>;</return> <expr_stmt/>}</block>

    void resetGCMallocBytes<parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>gcMallocBytes</name> = <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>gcMaxMallocBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt/>}</block>

    void setGCMaxMallocBytes<parameter_list>(<param><decl><type><name>size_t</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * For compatibility treat any value that exceeds PTRDIFF_T_MAX to
         * mean that value.
         */</comment>
        <expr_stmt><expr><name>gcMaxMallocBytes</name> = (<call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &gt;= 0) ? <name>value</name> : <call><name>size_t</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call> &gt;&gt; 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resetGCMallocBytes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>

    <comment type="block">/*
     * Call this after allocating memory held by GC things, to update memory
     * pressure counters or report the OOM error if necessary. If oomError and
     * cx is not null the function also reports OOM error.
     *
     * The function must be called outside the GC lock and in case of OOM error
     * the caller must ensure that no deadlock possible during OOM reporting.
     */</comment>
    void updateMallocCounter<parameter_list>(<param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/* We tolerate any thread races when updating gcMallocBytes. */</comment>
        <type><name>ptrdiff_t</name></type> <name>newCount</name> <init>= <expr><name>gcMallocBytes</name> - <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></init>;
        <expr_stmt><expr><name>gcMallocBytes</name> = <name>newCount</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JS_UNLIKELY</name><argument_list>(<argument><expr><name>newCount</name> &lt;= 0</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>onTooMuchMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt/>}</block>

  private:
    <comment type="block">/*
     * The function must be called outside the GC lock.
     */</comment>
    JS_FRIEND_API<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> onTooMuchMalloc<parameter_list>()</parameter_list>;</function>

    <comment type="block">/*
     * This should be called after system malloc/realloc returns NULL to try
     * to recove some memory or to report an error. Failures in malloc and
     * calloc are signaled by p == null and p == reinterpret_cast&lt;void *&gt;(1).
     * Other values of p mean a realloc failure.
     *
     * The function must be called outside the GC lock.
     */</comment>
    <macro><name>JS_FRIEND_API</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>onOutOfMemory</name><argument_list>(<argument>void *p</argument>, <argument>size_t nbytes</argument>, <argument>JSContext *cx</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt/>}</block>;</enum></type></typedef>

<comment type="block">/* Common macros to access thread-local caches in JSThread or JSRuntime. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(JS_THREAD_DATA(cx)-&gt;gsnCache)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PROPERTY_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>(JS_THREAD_DATA(cx)-&gt;propertyCache)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_METER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>JS_ATOMIC_INCREMENT(&amp;(rt)-&gt;which)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_UNMETER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>JS_ATOMIC_DECREMENT(&amp;(rt)-&gt;which)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_METER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro></cpp:define>    <comment type="block">/* nothing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_UNMETER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_KEEP_ATOMS</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>JS_ATOMIC_INCREMENT(&amp;(rt)-&gt;gcKeepAtoms);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_UNKEEP_ATOMS</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_ATOMIC_DECREMENT(&amp;(rt)-&gt;gcKeepAtoms);</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_ARGUMENT_FORMATTER_DEFINED</name></cpp:ifdef>
<comment type="block">/*
 * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
 * formatter functions.  Elements are sorted in non-increasing format string
 * length order.
 */</comment>
<struct>struct <name>JSArgumentFormatMap</name> <block>{
    <type><specifier>const</specifier> <name>char</name>          *</type><name>format</name>;
    <type><name>size_t</name></type>              <name>length</name>;
    <type><name>JSArgumentFormatter</name></type> <name>formatter</name>;
    <type><name>JSArgumentFormatMap</name> *</type><name>next</name>;
<expr_stmt/>}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
 * here because all consumers need to see these declarations (and not just the
 * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
 * declaration), along with cx-&gt;resolvingTable.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSResolvingKey</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type>                <name>id</name></decl>;</decl_stmt>
<expr_stmt/>}</block> <expr_stmt><expr><name>JSResolvingKey</name></expr>;</expr_stmt></struct></type></typedef>

<typedef>typedef <type><struct>struct <name>JSResolvingEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSResolvingKey</name></type>      <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>flags</name></decl>;</decl_stmt>
<expr_stmt/>}</block> <expr_stmt><expr><name>JSResolvingEntry</name></expr>;</expr_stmt></struct></type></typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESFLAG_LOOKUP</name></cpp:macro>        <cpp:value>0x1</cpp:value></cpp:define>     <comment type="block">/* resolving id from lookup */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESFLAG_WATCH</name></cpp:macro>         <cpp:value>0x2</cpp:value></cpp:define>     <comment type="block">/* resolving id from watch */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESOLVE_INFER</name></cpp:macro>         <cpp:value>0xffff</cpp:value></cpp:define>  <comment type="block">/* infer bits from current bytecode */</comment>

<type><specifier>extern</specifier> <specifier>const</specifier> <name>JSDebugHooks</name></type> <name>js_NullDebugHooks</name>;  <comment type="block">/* defined in jsdbgapi.cpp */</comment>

<type><name>namespace</name></type> <name>js</name> <block>{

<type><name>class</name></type> <name>AutoGCRooter</name>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>option</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(((cx)-&gt;options &amp; (option)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_STRICT_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_STRICT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_WERROR_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_WERROR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_COMPILE_N_GO_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_ATLINE_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_ATLINE)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>OptionsHasXML</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>options</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>!!(<name>options</name> &amp; <name>JSOPTION_XML</name>)</expr>;</return>
<expr_stmt/>}</block>

static inline bool
OptionsHasAnonFunFix<parameter_list>(<param><decl><type><name>uint32</name></type> <name>options</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>!!(<name>options</name> &amp; <name>JSOPTION_ANONFUNFIX</name>)</expr>;</return>
<expr_stmt/>}</block>

static inline bool
OptionsSameVersionFlags<parameter_list>(<param><decl><type><name>uint32</name></type> <name>self</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>other</name></decl></param>)</parameter_list>
<block>{
    <type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>mask</name> <init>= <expr><name>JSOPTION_XML</name> | <name>JSOPTION_ANONFUNFIX</name></expr></init>;
    <return>return <expr>!((<name>self</name> &amp; <name>mask</name>) ^ (<name>other</name> &amp; <name>mask</name>))</expr>;</return>
<expr_stmt/>}</block>

<comment type="block">/*
 * Flags accompany script version data so that a) dynamically created scripts
 * can inherit their caller's compile-time properties and b) scripts can be
 * appropriately compared in the eval cache across global option changes. An
 * example of the latter is enabling the top-level-anonymous-function-is-error
 * option: subsequent evals of the same, previously-valid script text may have
 * become invalid.
 */</comment>
<type><name>namespace</name></type> <name>VersionFlags</name> {
static const uint32 MASK        = 0x0FFF;</function> <comment type="block">/* see JSVersion in jspubtd.h */</comment>
<type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>HAS_XML</name>     <init>= <expr>0x1000</expr></init>; <comment type="block">/* flag induced by XML option */</comment>
<type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>ANONFUNFIX</name>  <init>= <expr>0x2000</expr></init>; <comment type="block">/* see jsapi.h comment on JSOPTION_ANONFUNFIX */</comment>
<expr_stmt/>}</block>

static inline <name>JSVersion</name>
<name>VersionNumber</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr><call><name>JSVersion</name><argument_list>(<argument><expr><call><name>uint32</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> &amp; <name>VersionFlags</name>::<name>MASK</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block>

static inline <name>bool</name>
<name>VersionHasXML</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr>!!(<name>version</name> &amp; <name>VersionFlags</name>::<name>HAS_XML</name>)</expr>;</return>
<expr_stmt/>}</block>

<comment type="block">/* @warning This is a distinct condition from having the XML flag set. */</comment>
static inline <name>bool</name>
<name>VersionShouldParseXML</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr><call><name>VersionHasXML</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> || <call><name>VersionNumber</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> &gt;= <name>JSVERSION_1_6</name></expr>;</return>
<expr_stmt/>}</block>

static inline <name>bool</name>
<name>VersionHasAnonFunFix</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr>!!(<name>version</name> &amp; <name>VersionFlags</name>::<name>ANONFUNFIX</name>)</expr>;</return>
<expr_stmt/>}</block>

static inline <name>void</name>
<name>VersionSetXML</name><argument_list>(<argument><expr><name>JSVersion</name> *<name>version</name></expr></argument>, <argument><expr><name>bool</name> <name>enable</name></expr></argument>)</argument_list>
<block>{
    <if>if <condition>(<expr><name>enable</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>version</name> = <call><name>JSVersion</name><argument_list>(<argument><expr><call><name>uint32</name><argument_list>(<argument><expr>*<name>version</name></expr></argument>)</argument_list></call> | <name>VersionFlags</name>::<name>HAS_XML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr>*<name>version</name> = <call><name>JSVersion</name><argument_list>(<argument><expr><call><name>uint32</name><argument_list>(<argument><expr>*<name>version</name></expr></argument>)</argument_list></call> &amp; ~<name>VersionFlags</name>::<name>HAS_XML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt/>}</block>

static inline <name>void</name>
<name>VersionSetAnonFunFix</name><argument_list>(<argument><expr><name>JSVersion</name> *<name>version</name></expr></argument>, <argument><expr><name>bool</name> <name>enable</name></expr></argument>)</argument_list>
<block>{
    <if>if <condition>(<expr><name>enable</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>version</name> = <call><name>JSVersion</name><argument_list>(<argument><expr><call><name>uint32</name><argument_list>(<argument><expr>*<name>version</name></expr></argument>)</argument_list></call> | <name>VersionFlags</name>::<name>ANONFUNFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr>*<name>version</name> = <call><name>JSVersion</name><argument_list>(<argument><expr><call><name>uint32</name><argument_list>(<argument><expr>*<name>version</name></expr></argument>)</argument_list></call> &amp; ~<name>VersionFlags</name>::<name>ANONFUNFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt/>}</block>

static inline <name>JSVersion</name>
<name>VersionExtractFlags</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr><call><name>JSVersion</name><argument_list>(<argument><expr><call><name>uint32</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> &amp; ~<name>VersionFlags</name>::<name>MASK</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block>

static inline <name>bool</name>
<name>VersionHasFlags</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr>!!<call><name>VersionExtractFlags</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block>

static inline <name>bool</name>
<name>VersionIsKnown</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr><call><name>VersionNumber</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> != <name>JSVERSION_UNKNOWN</name></expr>;</return>
<expr_stmt/>}</block>

} <comment type="block">/* namespace js */</comment>

struct <name>JSContext</name>
<block>{
    <function_decl><type><name>explicit</name></type> <name>JSContext</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* JSRuntime contextList linkage. */</comment>
    <type><name>JSCList</name></type>             <name>link</name>;

  <label><name>private</name>:</label>
    <comment type="block">/* See JSContext::findVersion. */</comment>
    <type><name>JSVersion</name></type>           <name>defaultVersion</name>;      <comment type="block">/* script compilation version */</comment>
    <type><name>JSVersion</name></type>           <name>versionOverride</name>;     <comment type="block">/* supercedes defaultVersion when valid */</comment>
    <type><name>bool</name></type>                <name>hasVersionOverride</name>;

  <label><name>public</name>:</label>
    <comment type="block">/* Per-context options. */</comment>
    <type><name>uint32</name></type>              <name>options</name>;            <comment type="block">/* see jsapi.h for JSOPTION_* */</comment>

    <comment type="block">/* Locale specific callbacks for string conversion. */</comment>
    <type><name>JSLocaleCallbacks</name>   *</type><name>localeCallbacks</name>;

    <comment type="block">/*
     * cx-&gt;resolvingTable is non-null and non-empty if we are initializing
     * standard classes lazily, or if we are otherwise recursing indirectly
     * from js_LookupProperty through a Class.resolve hook.  It is used to
     * limit runaway recursion (see jsapi.c and jsobj.c).
     */</comment>
    <type><name>JSDHashTable</name>        *</type><name>resolvingTable</name>;

    <comment type="block">/*
     * True if generating an error, to prevent runaway recursion.
     * NB: generatingError packs with throwing below.
     */</comment>
    <type><name>JSPackedBool</name></type>        <name>generatingError</name>;

    <comment type="block">/* Exception state -- the exception member is a GC root by definition. */</comment>
    <type><name>JSBool</name></type>              <name>throwing</name>;           <comment type="block">/* is there a pending exception? */</comment>
    <expr_stmt><expr><name>js</name>::<name>Value</name>           <name>exception</name></expr>;</expr_stmt>          <comment type="block">/* most-recently-thrown exception */</comment>

    <comment type="block">/* Limit pointer for checking native stack consumption during recursion. */</comment>
    <type><name>jsuword</name></type>             <name>stackLimit</name>;

    <comment type="block">/* Quota on the size of arenas used to compile and execute scripts. */</comment>
    <type><name>size_t</name></type>              <name>scriptStackQuota</name>;

    <comment type="block">/* Data shared by threads in an address space. */</comment>
    <type><name>JSRuntime</name> *<specifier>const</specifier></type>    <name>runtime</name>;

    <comment type="block">/* GC heap compartment. */</comment>
    <type><name>JSCompartment</name>       *</type><name>compartment</name>;

    <comment type="block">/* Currently executing frame and regs, set by stack operations. */</comment>
    <type><name>JS_REQUIRES_STACK</name>
    <name>JSFrameRegs</name>         *</type><name>regs</name>;

    <comment type="block">/* Current frame accessors. */</comment>

    <function><type><name>JSStackFrame</name>*</type> <name>fp</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>regs</name> &amp;&amp; <name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>regs</name>-&gt;<name>fp</name></name></expr>;</return>
    <expr_stmt/>}</block>

    JSStackFrame* maybefp<parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>regs</name> ? <name><name>regs</name>-&gt;<name>fp</name></name> : <name>NULL</name></expr>;</return>
    <expr_stmt/>}</block>

    bool hasfp<parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!!<name>regs</name></expr>;</return>
    <expr_stmt/>}</block>

  public:
    friend class js::StackSpace;</function>
    <expr_stmt><expr><name>friend</name> <name>bool</name> <name>js</name>::<call><name>Interpret</name><argument_list>(<argument><expr><name>JSContext</name> *</expr></argument>, <argument><expr><name>JSStackFrame</name> *</expr></argument>, <argument><expr><name>uintN</name></expr></argument>, <argument><expr><name>JSInterpMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>void</name></type> <name>resetCompartment</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block">/* 'regs' must only be changed by calling this function. */</comment>
    <function><type><name>void</name></type> <name>setCurrentRegs</name><parameter_list>(<param><decl><type><name>JSFrameRegs</name> *</type><name>regs</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>-&gt;<name>regs</name></name> = <name>regs</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>regs</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>resetCompartment</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt/>}</block>

    <comment type="block">/* Temporary arena pool used while compiling and decompiling. */</comment>
    <type><name>JSArenaPool</name></type>         <name>tempPool</name>;

    <comment type="block">/* Temporary arena pool used while evaluate regular expressions. */</comment>
    <type><name>JSArenaPool</name></type>         <name>regExpPool</name>;

    <comment type="block">/* Top-level object and pointer to top stack frame's scope chain. */</comment>
    <type><name>JSObject</name>            *</type><name>globalObject</name>;

    <comment type="block">/* State for object and array toSource conversion. */</comment>
    <type><name>JSSharpObjectMap</name></type>    <name>sharpObjectMap</name>;
    js::HashSet&lt;JSObject *&gt; busyArrays;</function>

    <comment type="block">/* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */</comment>
    <type><name>JSArgumentFormatMap</name> *</type><name>argumentFormatMap</name>;

    <comment type="block">/* Last message string and log file for debugging. */</comment>
    <type><name>char</name>                *</type><name>lastMessage</name>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <type><name>void</name>                *</type><name>logfp</name>;
    <type><name>jsbytecode</name>          *</type><name>logPrevPc</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Per-context optional error reporter. */</comment>
    <type><name>JSErrorReporter</name></type>     <name>errorReporter</name>;

    <comment type="block">/* Branch callback. */</comment>
    <type><name>JSOperationCallback</name></type> <name>operationCallback</name>;

    <comment type="block">/* Interpreter activation count. */</comment>
    <type><name>uintN</name></type>               <name>interpLevel</name>;

    <comment type="block">/* Client opaque pointers. */</comment>
    <type><name>void</name>                *</type><name>data</name>;
    <type><name>void</name>                *</type><name>data2</name>;

  <label><name>private</name>:</label>
    <comment type="block">/* Linked list of segments. See StackSegment. */</comment>
    <expr_stmt><expr><name>js</name>::<name>StackSegment</name> *<name>currentSegment</name></expr>;</expr_stmt>

  <label><name>public</name>:</label>
    <expr_stmt><expr><name>void</name> <macro><name>assertSegmentsInSync</name><argument_list>()</argument_list></macro> const <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <if>if <condition>(<expr><name>regs</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>currentSegment</name>-&gt;<name>isActive</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>js</name>::<name>StackSegment</name> *<name>prev</name> = <call><name><name>currentSegment</name>-&gt;<name>getPreviousInContext</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>prev</name>-&gt;<name>isActive</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt/>}</block> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>currentSegment</name></expr></argument>, <argument><expr>!<call><name><name>currentSegment</name>-&gt;<name>isActive</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt/></else></then></if>}</block>

    <comment type="block">/* Return whether this context has an active segment. */</comment>
    <name>bool</name> <macro><name>hasActiveSegment</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>assertSegmentsInSync</name><argument_list>()</argument_list></call></expr>;
        <return>return <expr>!!<name>regs</name></expr>;</return>
    }</block>

    <comment type="block">/* Assuming there is an active segment, return it. */</comment>
    <name>js</name>::<name>StackSegment</name> *<macro><name>activeSegment</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>hasActiveSegment</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>currentSegment</name></expr>;</return>
    }</block>

    <comment type="block">/* Return the current segment, which may or may not be active. */</comment>
    <name>js</name>::<name>StackSegment</name> *<macro><name>getCurrentSegment</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>assertSegmentsInSync</name><argument_list>()</argument_list></call></expr>;
        <return>return <expr><name>currentSegment</name></expr>;</return>
    }</block>

    inline <name>js</name>::<name>RegExpStatics</name> *<call><name>regExpStatics</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the given segment to the list as the new active segment. */</comment>
    <type><name>void</name></type> <name>pushSegmentAndFrame</name><argument_list>(<argument><expr><name>js</name>::<name>StackSegment</name> *<name>newseg</name></expr></argument>, <argument><expr><name>JSFrameRegs</name> &amp;<name>regs</name></expr></argument>)</argument_list>;

    <comment type="block">/* Remove the active segment and make the next segment active. */</comment>
    <function_decl><type><name>void</name></type> <name>popSegmentAndFrame</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block">/* Mark the top segment as suspended, without pushing a new one. */</comment>
    <function_decl><type><name>void</name></type> <name>saveActiveSegment</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block">/* Undoes calls to suspendActiveSegment. */</comment>
    <function_decl><type><name>void</name></type> <name>restoreSegment</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block">/* Get the frame whose prev() is fp, which may be in any segment. */</comment>
    <function_decl><type><specifier>inline</specifier> <name>JSStackFrame</name> *</type><name>computeNextFrame</name><parameter_list>(<param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
     * Perform a linear search of all frames in all segments in the given context
     * for the given frame, returning the segment, if found, and null otherwise.
     */</comment>
    <expr_stmt><expr><name>js</name>::<name>StackSegment</name> *<call><name>containingSegment</name><argument_list>(<argument><expr>const <name>JSStackFrame</name> *<name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Search the call stack for the nearest frame with static level targetLevel. */</comment>
    <type><name>JSStackFrame</name> *</type><name>findFrameAtLevel</name><argument_list>(<argument><expr><name>uintN</name> <name>targetLevel</name></expr></argument>)</argument_list> const <block>{
        <type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></init>;
        <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>fp</name> &amp;&amp; <call><name><name>fp</name>-&gt;<name>isScriptFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call>-&gt;<name>staticLevel</name> == <name>targetLevel</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>fp</name> = <call><name><name>fp</name>-&gt;<name>prev</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/>}</block>
        <return>return <expr><name>fp</name></expr>;</return></while>
    <expr_stmt/>}</block>

  <name>private</name>:
    <comment type="block">/*
     * The default script compilation version can be set iff there is no code running.
     * This typically occurs via the JSAPI right after a context is constructed.
     */</comment>
    <name>bool</name> <name>canSetDefaultVersion</name><argument_list>()</argument_list> const <block>{
        <return>return <expr>!<name>regs</name> &amp;&amp; !<name>hasVersionOverride</name></expr>;</return>
    <expr_stmt/>}</block>

    <comment type="block">/* Force a version for future script compilation. */</comment>
    <name>void</name> <name>overrideVersion</name><argument_list>(<argument><expr><name>JSVersion</name> <name>newVersion</name></expr></argument>)</argument_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>canSetDefaultVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>versionOverride</name> = <name>newVersion</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hasVersionOverride</name> = <name>true</name></expr>;</expr_stmt>
    <expr_stmt/>}</block>

  <name>public</name>:
    <name>void</name> <name>clearVersionOverride</name><argument_list>()</argument_list> <block>{
        <expr_stmt><expr><name>hasVersionOverride</name> = <name>false</name></expr>;</expr_stmt>
    <expr_stmt/>}</block>
    
    <name>bool</name> <name>isVersionOverridden</name><argument_list>()</argument_list> const <block>{
        <return>return <expr><name>hasVersionOverride</name></expr>;</return>
    <expr_stmt/>}</block>

    <comment type="block">/* Set the default script compilation version. */</comment>
    <name>void</name> <name>setDefaultVersion</name><argument_list>(<argument><expr><name>JSVersion</name> <name>version</name></expr></argument>)</argument_list> <block>{
        <expr_stmt><expr><name>defaultVersion</name> = <name>version</name></expr>;</expr_stmt>
    <expr_stmt/>}</block>

    <comment type="block">/*
     * Set the default version if possible; otherwise, force the version.
     * Return whether an override occurred.
     */</comment>
    <name>bool</name> <name>maybeOverrideVersion</name><argument_list>(<argument><expr><name>JSVersion</name> <name>newVersion</name></expr></argument>)</argument_list> <block>{
        <if>if <condition>(<expr><call><name>canSetDefaultVersion</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setDefaultVersion</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        <expr_stmt/>}</block>
        <expr_stmt><expr><call><name>overrideVersion</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>true</name></expr>;</return>
    <expr_stmt/>}</block>

    <comment type="block">/*
     * Return:
     * - The override version, if there is an override version.
     * - The newest scripted frame's version, if there is such a frame. 
     * - The default verion.
     *
     * @note    If this ever shows up in a profile, just add caching!
     */</comment>
    <name>JSVersion</name> <name>findVersion</name><argument_list>()</argument_list> const <block>{
        <if>if <condition>(<expr><name>hasVersionOverride</name></expr>)</condition><then>
            <return>return <expr><name>versionOverride</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>regs</name></expr>)</condition><then> <block>{
            <comment type="block">/* There may be a scripted function somewhere on the stack! */</comment>
            <type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></init>;
            <while>while <condition>(<expr><name>fp</name> &amp;&amp; !<call><name><name>fp</name>-&gt;<name>isScriptFrame</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <expr_stmt><expr><name>fp</name> = <call><name><name>fp</name>-&gt;<name>prev</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></while>
            <if>if <condition>(<expr><name>fp</name></expr>)</condition><then>
                <return>return <expr><call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call>-&gt;<call><name>getVersion</name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <expr_stmt/>}</block>

        <return>return <expr><name>defaultVersion</name></expr>;</return></then></if>
    <expr_stmt/>}</block>

    <name>void</name> <name>optionFlagsToVersion</name><argument_list>(<argument><expr><name>JSVersion</name> *<name>version</name></expr></argument>)</argument_list> const <block>{
        <expr_stmt><expr><name>js</name>::<call><name>VersionSetXML</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>js</name>::<call><name>OptionsHasXML</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>js</name>::<call><name>VersionSetAnonFunFix</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><name>js</name>::<call><name>OptionsHasAnonFunFix</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>

    <name>void</name> <name>checkOptionVersionSync</name><argument_list>()</argument_list> const <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <type><name>JSVersion</name></type> <name>version</name> <init>= <expr><call><name>findVersion</name><argument_list>()</argument_list></call></expr></init>;
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>js</name>::<call><name>VersionHasXML</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> == <name>js</name>::<call><name>OptionsHasXML</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>js</name>::<call><name>VersionHasAnonFunFix</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> == <name>js</name>::<call><name>OptionsHasAnonFunFix</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt/>}</block>

    <comment type="block">/* Note: may override the version. */</comment>
    <name>void</name> <name>syncOptionsToVersion</name><argument_list>()</argument_list> <block>{
        <type><name>JSVersion</name></type> <name>version</name> <init>= <expr><call><name>findVersion</name><argument_list>()</argument_list></call></expr></init>;
        <if>if <condition>(<expr><name>js</name>::<call><name>OptionsHasXML</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> == <name>js</name>::<call><name>VersionHasXML</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> &amp;&amp;
            <name>js</name>::<call><name>OptionsHasAnonFunFix</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> == <name>js</name>::<call><name>VersionHasAnonFunFix</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><name>js</name>::<call><name>VersionSetXML</name><argument_list>(<argument><expr>&amp;<name>version</name></expr></argument>, <argument><expr><name>js</name>::<call><name>OptionsHasXML</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>js</name>::<call><name>VersionSetAnonFunFix</name><argument_list>(<argument><expr>&amp;<name>version</name></expr></argument>, <argument><expr><name>js</name>::<call><name>OptionsHasAnonFunFix</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>maybeOverrideVersion</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <name>JSThread</name>            *<name>thread</name>;
    <type><name>unsigned</name></type>            <name>outstandingRequests</name>;<comment type="block">/* number of JS_BeginRequest calls
                                               without the corresponding
                                               JS_EndRequest. */</comment>
    <type><name>JSCList</name></type>             <name>threadLinks</name>;        <comment type="block">/* JSThread contextList linkage */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CX_FROM_THREAD_LINKS</name><parameter_list>(<param><type><name>tl</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Stack of thread-stack-allocated GC roots. */</comment>
    <expr_stmt><expr><name>js</name>::<name>AutoGCRooter</name>   *<name>autoGCRooters</name></expr>;</expr_stmt>

    <comment type="block">/* Debug hooks associated with the current context. */</comment>
    <type><specifier>const</specifier> <name>JSDebugHooks</name>  *</type><name>debugHooks</name>;

    <comment type="block">/* Security callbacks that override any defined on the runtime. */</comment>
    <type><name>JSSecurityCallbacks</name> *</type><name>securityCallbacks</name>;

    <comment type="block">/* Stored here to avoid passing it around as a parameter. */</comment>
    <type><name>uintN</name></type>               <name>resolveFlags</name>;

    <comment type="block">/* Random number generator state, used by jsmath.cpp. */</comment>
    <type><name>int64</name></type>               <name>rngSeed</name>;

    <comment type="block">/* Location to stash the iteration value between JSOP_MOREITER and JSOP_FOR*. */</comment>
    <expr_stmt><expr><name>js</name>::<name>Value</name>           <name>iterValue</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/*
     * State for the current tree execution.  bailExit is valid if the tree has
     * called back into native code via a _FAIL builtin and has not yet bailed,
     * else garbage (NULL in debug builds).
     */</comment>
    <expr_stmt><expr><name>js</name>::<name>TracerState</name>     *<name>tracerState</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>js</name>::<name>VMSideExit</name>      *<name>bailExit</name></expr>;</expr_stmt>

    <comment type="block">/*
     * True if traces may be executed. Invariant: The value of traceJitenabled
     * is always equal to the expression in updateJITEnabled below.
     *
     * This flag and the fields accessed by updateJITEnabled are written only
     * in runtime-&gt;gcLock, to avoid race conditions that would leave the wrong
     * value in traceJitEnabled. (But the interpreter reads this without
     * locking. That can race against another thread setting debug hooks, but
     * we always read cx-&gt;debugHooks without locking anyway.)
     */</comment>
    <type><name>bool</name></type>                 <name>traceJitEnabled</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_METHODJIT</name></cpp:ifdef>
    <type><name>bool</name></type>                 <name>methodJitEnabled</name>;
    <type><name>bool</name></type>                 <name>profilingEnabled</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Caller must be holding runtime-&gt;gcLock. */</comment>
    <function_decl><type><name>void</name></type> <name>updateJITEnabled</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACE_JSCALLS</name></cpp:ifdef>
    <comment type="block">/* Function entry/exit debugging callback. */</comment>
    <type><name>JSFunctionCallback</name></type>    <name>functionCallback</name>;

    <type><name>void</name></type> <name>doFunctionCallback</name><argument_list>(<argument><expr>const <name>JSFunction</name> *<name>fun</name></expr></argument>,
                            <argument><expr>const <name>JSScript</name> *<name>scr</name></expr></argument>,
                            <argument><expr><name>int</name> <name>entering</name></expr></argument>)</argument_list> const
    <block>{
        <if>if <condition>(<expr><name>functionCallback</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>functionCallback</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>scr</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>entering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt/>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <name>DSTOffsetCache</name> <name>dstOffsetCache</name>;

    <comment type="block">/* List of currently active non-escaping enumerators (for-in). */</comment>
    <type><name>JSObject</name> *</type><name>enumerators</name>;

  <label><name>private</name>:</label>
    <comment type="block">/*
     * To go from a live generator frame (on the stack) to its generator object
     * (see comment js_FloatingFrameIfGenerator), we maintain a stack of active
     * generators, pushing and popping when entering and leaving generator
     * frames, respectively.
     */</comment>
    <expr_stmt><expr><name>js</name>::<name>Vector</name>&lt;<name>JSGenerator</name> *</expr>, <expr>2</expr>, <expr><name>js</name>::<name>SystemAllocPolicy</name>&gt; <name>genStack</name></expr>;</expr_stmt>

  <label><name>public</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_METHODJIT</name></cpp:ifdef>
    <expr_stmt><expr>inline <name>js</name>::<name>mjit</name>::<name>JaegerCompartment</name> *<call><name>jaegerCompartment</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Return the generator object for the given generator frame. */</comment>
    <type><name>JSGenerator</name> *</type><name>generatorFor</name><argument_list>(<argument><expr><name>JSStackFrame</name> *<name>fp</name></expr></argument>)</argument_list> const;

    <comment type="block">/* Early OOM-check. */</comment>
    <function_decl><type><specifier>inline</specifier> <name>bool</name></type> <name>ensureGeneratorStackSpace</name><parameter_list>()</parameter_list>;</function_decl>

    <function><type><name>bool</name></type> <name>enterGenerator</name><parameter_list>(<param><decl><type><name>JSGenerator</name> *</type><name>gen</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>genStack</name>.<name>append</name></name><argument_list>(<argument><expr><name>gen</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    void leaveGenerator<parameter_list>(<param><decl><type><name>JSGenerator</name> *</type><name>gen</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>genStack</name>.<name>back</name></name><argument_list>()</argument_list></call> == <name>gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>genStack</name>.<name>popBack</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/*
     * When non-null JSContext::free delegates the job to the background
     * thread.
     */</comment>
    js::<type><name>GCHelperThread</name> *</type><name>gcBackgroundFree</name>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    inline void* malloc<parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>runtime</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    inline void* mallocNoReport<parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>bytes</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>runtime</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    inline void* calloc<parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>bytes</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>runtime</name>-&gt;<name>calloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    inline void* realloc<parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>runtime</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    inline void* realloc<parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>oldBytes</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>newBytes</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>runtime</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>oldBytes</name></expr></argument>, <argument><expr><name>newBytes</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt/>}</block>

    inline void free<parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>)</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>gcBackgroundFree</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>gcBackgroundFree</name>-&gt;<name>freeLater</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        <expr_stmt/>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name><name>runtime</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt/>}</block>

    <comment type="block">/*
     * In the common case that we'd like to allocate the memory for an object
     * with cx-&gt;malloc/free, we cannot use overloaded C++ operators (no
     * placement delete).  Factor the common workaround into one place.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_BODY</name><parameter_list>(<param><type><name>parms</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>void *memory = this-&gt;malloc(sizeof(T));                                   \
    if (!memory)                                                              \
        return NULL;                                                          \
    return new(memory) T parms;</cpp:value></cpp:define>

    template &lt;class T&gt;
    JS_ALWAYS_INLINE T *create<parameter_list>()</parameter_list> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>()</argument>)</argument_list></macro>
    <expr_stmt/>}</block>

    template &lt;<type><name>class</name></type> <name>T</name></function>, <name>class</name> <name>P1</name><empty_stmt/>&gt;
    <function><type><name>JS_ALWAYS_INLINE</name> <name>T</name> *</type><name>create</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>P1</name> &amp;</type><name>p1</name></decl></param>)</parameter_list> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>(p1)</argument>)</argument_list></macro>
    <expr_stmt/>}</block>

    template &lt;<type><name>class</name></type> <name>T</name></function>, <name>class</name> <name>P1</name>, <name>class</name> <name>P2</name><empty_stmt/>&gt;
    <function><type><name>JS_ALWAYS_INLINE</name> <name>T</name> *</type><name>create</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>P1</name> &amp;</type><name>p1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>P2</name> &amp;</type><name>p2</name></decl></param>)</parameter_list> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>(p1, p2)</argument>)</argument_list></macro>
    <expr_stmt/>}</block>

    template &lt;<type><name>class</name></type> <name>T</name></function>, <name>class</name> <name>P1</name>, <name>class</name> <name>P2</name>, <name>class</name> <name>P3</name><empty_stmt/>&gt;
    <function><type><name>JS_ALWAYS_INLINE</name> <name>T</name> *</type><name>create</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>P1</name> &amp;</type><name>p1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>P2</name> &amp;</type><name>p2</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>P3</name> &amp;</type><name>p3</name></decl></param>)</parameter_list> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>(p1, p2, p3)</argument>)</argument_list></macro>
    <expr_stmt/>}</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CREATE_BODY</name></cpp:undef>

    template &lt;class T&gt;
    JS_ALWAYS_INLINE void destroy<parameter_list>(<param><decl><type><name>T</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>p</name>-&gt;<name/></name>~<call><name>T</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>

    void purge<parameter_list>()</parameter_list>;</function>

    <expr_stmt><expr><name>js</name>::<name>StackSpace</name> &amp;<macro><name>stack</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>-&gt;<name>stackSpace</name></expr>;</return>
    }</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <name>void</name> <macro><name>assertValidStackDepth</name><argument_list>(<argument>uintN depth</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0 &lt;= <name><name>regs</name>-&gt;<name>sp</name></name> - <call><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>base</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>depth</name> &lt;= <call><name>uintptr_t</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>sp</name></name> - <call><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>base</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <name>void</name> <macro><name>assertValidStackDepth</name><argument_list>(<argument>uintN</argument> <comment type="block">/*depth*/</comment>)</argument_list></macro> <block>{}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>private</name>:

    <comment type="block">/*
     * The allocation code calls the function to indicate either OOM failure
     * when p is null or that a memory pressure counter has reached some
     * threshold when p is not null. The function takes the pointer and not
     * a boolean flag to minimize the amount of code in its inlined callers.
     */</comment>
    <macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro> <call><name>checkMallocGCPressure</name><argument_list>(<argument><expr><name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* To silence MSVC warning about using 'this' in a member initializer. */</comment>
    <function><type><name>JSContext</name> *</type><name>thisInInitializer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> <expr_stmt/>}</block>
};</function> <comment type="block">/* struct JSContext */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_ID</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>((cx)-&gt;thread ? (cx)-&gt;thread-&gt;id : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_THREADSAFE</name> &amp;&amp; <name>defined</name> <name>DEBUG</name></expr></cpp:if>

<type><name>namespace</name></type> <name>js</name> <block>{

<type><name>class</name></type> <name>AutoCheckRequestDepth</name> <block>{
    <type><name>JSContext</name> *</type><name>cx</name>;
  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>AutoCheckRequestDepth</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call> : <macro><name>cx</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{ <expr><name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>checkRequestDepth</name></name>++</expr>; }</block>

    ~<macro><name>AutoCheckRequestDepth</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>checkRequestDepth</name></name> != 0</expr></argument>)</argument_list></call></expr>;
        <expr><name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>checkRequestDepth</name></name>--</expr>;
    }</block></expr></expr_stmt>
}</block>;

<expr_stmt/>}</block>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_REQUEST</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>JS_ASSERT((cx)-&gt;thread);                                                  \
    JS_ASSERT((cx)-&gt;thread-&gt;data.requestDepth || (cx)-&gt;thread == (cx)-&gt;runtime-&gt;gcThread); \
    AutoCheckRequestDepth _autoCheckRequestDepth(cx);</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_REQUEST</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>          <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_REQUEST_THREAD</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static inline <name>uintN</name>
<name>FramePCOffset</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSStackFrame</name>* <name>fp</name></expr></argument>)</argument_list>
<block>{
    <type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call> ? <call><name><name>fp</name>-&gt;<name>imacropc</name></name><argument_list>()</argument_list></call> : <call><name><name>fp</name>-&gt;<name>pc</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init>;
    <return>return <expr><call><name>uintN</name><argument_list>(<argument><expr><name>pc</name> - <call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call>-&gt;<name>code</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block>

static inline <name>JSAtom</name> **
<name>FrameAtomBase</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSStackFrame</name> *<name>fp</name></expr></argument>)</argument_list>
<block>{
    <return>return <expr><call><name><name>fp</name>-&gt;<name>hasImacropc</name></name><argument_list>()</argument_list></call>
           ? <call><name>COMMON_ATOMS_START</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name></name></expr></argument>)</argument_list></call>
           : <call><name><name>fp</name>-&gt;<name>script</name></name><argument_list>()</argument_list></call>-&gt;<name><name>atomMap</name>.<name>vector</name></name></expr>;</return>
<expr_stmt/>}</block>

<name>namespace</name> <name>js</name> <block>{

<type><name>class</name></type> <name>AutoGCRooter</name> <block>{
  <label><name>public</name>:</label>
    <macro><name>AutoGCRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>ptrdiff_t tag</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>down</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>autoGCRooters</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>, <macro><name>context</name><argument_list>(<argument>cx</argument>)</argument_list></macro>
    <expr><block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>this</name> != <name><name>cx</name>-&gt;<name>autoGCRooters</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>CHECK_REQUEST</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;
        <expr><name><name>cx</name>-&gt;<name>autoGCRooters</name></name> = <name>this</name></expr>;
    }</block>

    ~<macro><name>AutoGCRooter</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>this</name> == <name><name>context</name>-&gt;<name>autoGCRooters</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>CHECK_REQUEST</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;
        <expr><name><name>context</name>-&gt;<name>autoGCRooters</name></name> = <name>down</name></expr>;
    }</block>

    <comment type="block">/* Implemented in jsgc.cpp. */</comment>
    inline <name>void</name> <call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility push(default)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <function_decl><type><name>friend</name> <name>void</name></type> <name>MarkContext</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>acx</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>friend</name> <name>void</name></type> <name>MarkRuntime</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility pop</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <label><name>protected</name>:</label>
    <type><name>AutoGCRooter</name> * <specifier>const</specifier></type> <name>down</name>;

    <comment type="block">/*
     * Discriminates actual subclass of this being used.  If non-negative, the
     * subclass roots an array of values of the length stored in this field.
     * If negative, meaning is indicated by the corresponding value in the enum
     * below.  Any other negative value indicates some deeper problem such as
     * memory corruption.
     */</comment>
    <type><name>ptrdiff_t</name></type> <name>tag</name>;

    <type><name>JSContext</name> * <specifier>const</specifier></type> <name>context</name>;

    <enum>enum <block>{
        <decl><name>JSVAL</name> <init>=        <expr>-1</expr></init></decl>, <comment type="block">/* js::AutoValueRooter */</comment>
        <decl><name>SHAPE</name> <init>=        <expr>-2</expr></init></decl>, <comment type="block">/* js::AutoShapeRooter */</comment>
        <decl><name>PARSER</name> <init>=       <expr>-3</expr></init></decl>, <comment type="block">/* js::Parser */</comment>
        <decl><name>SCRIPT</name> <init>=       <expr>-4</expr></init></decl>, <comment type="block">/* js::AutoScriptRooter */</comment>
        <decl><name>ENUMERATOR</name> <init>=   <expr>-5</expr></init></decl>, <comment type="block">/* js::AutoEnumStateRooter */</comment>
        <decl><name>IDARRAY</name> <init>=      <expr>-6</expr></init></decl>, <comment type="block">/* js::AutoIdArray */</comment>
        <decl><name>DESCRIPTORS</name> <init>=  <expr>-7</expr></init></decl>, <comment type="block">/* js::AutoPropDescArrayRooter */</comment>
        <decl><name>NAMESPACES</name> <init>=   <expr>-8</expr></init></decl>, <comment type="block">/* js::AutoNamespaceArray */</comment>
        <decl><name>XML</name> <init>=          <expr>-9</expr></init></decl>, <comment type="block">/* js::AutoXMLRooter */</comment>
        <decl><name>OBJECT</name> <init>=      <expr>-10</expr></init></decl>, <comment type="block">/* js::AutoObjectRooter */</comment>
        <decl><name>ID</name> <init>=          <expr>-11</expr></init></decl>, <comment type="block">/* js::AutoIdRooter */</comment>
        <decl><name>VALVECTOR</name> <init>=   <expr>-12</expr></init></decl>, <comment type="block">/* js::AutoValueVector */</comment>
        <decl><name>DESCRIPTOR</name> <init>=  <expr>-13</expr></init></decl>, <comment type="block">/* js::AutoPropertyDescriptorRooter */</comment>
        <decl><name>STRING</name> <init>=      <expr>-14</expr></init></decl>, <comment type="block">/* js::AutoStringRooter */</comment>
        <decl><name>IDVECTOR</name> <init>=    <expr>-15</expr>  <comment type="block">/* js::AutoIdVector */</comment>
    }</init></decl><empty_stmt>;</empty_stmt>

    <label><name>private</name>:</label>
    <comment type="block">/* No copy or assignment semantics. */</comment>
    <decl><name>AutoGCRooter</name><argument_list>(<argument><expr><name>AutoGCRooter</name> &amp;<name>ida</name></expr></argument>)</argument_list></decl><empty_stmt>;</empty_stmt>
    <type><name>void</name></type> <name>operator</name><init>=<expr>(<name>AutoGCRooter</name> &amp;<name>ida</name>)</expr></init>;
<expr_stmt/>}</block>;</enum>

<comment type="block">/* FIXME(bug 332648): Move this into a public header. */</comment>
<expr_stmt><expr><name>class</name> <name>AutoValueRooter</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoValueRooter</name><argument_list>(<argument>JSContext *cx
                             JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSVAL</name></expr></argument>)</argument_list></call></expr>, <macro><name>val</name><argument_list>(<argument>js::NullValue()</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <macro><name>AutoValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>const Value &amp;v
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSVAL</name></expr></argument>)</argument_list></call></expr>, <macro><name>val</name><argument_list>(<argument>v</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <macro><name>AutoValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>jsval v
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSVAL</name></expr></argument>)</argument_list></call></expr>, <macro><name>val</name><argument_list>(<argument>js::Valueify(v)</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <comment type="block">/*
     * If you are looking for Object* overloads, use AutoObjectRooter instead;
     * rooting Object*s as a js::Value requires discerning whether or not it is
     * a function object. Also, AutoObjectRooter is smaller.
     */</comment>

    <name>void</name> <macro><name>set</name><argument_list>(<argument>Value v</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>val</name> = <name>v</name></expr>;
    }</block>

    <name>void</name> <macro><name>set</name><argument_list>(<argument>jsval v</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>val</name> = <name>js</name>::<call><name>Valueify</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    const <name>Value</name> &amp;<macro><name>value</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>val</name></expr>;</return>
    }</block>

    <name>Value</name> *<macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr>&amp;<name>val</name></expr>;</return>
    }</block>

    const <name>jsval</name> &amp;<macro><name>jsval_value</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><call><name>Jsvalify</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block>

    <name>jsval</name> *<macro><name>jsval_addr</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><call><name>Jsvalify</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>friend</name> <name>void</name> <call><name>MarkRuntime</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>Value</name> <name>val</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoObjectRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoObjectRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj = NULL
                     JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>OBJECT</name></expr></argument>)</argument_list></call></expr>, <macro><name>obj</name><argument_list>(<argument>obj</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>void</name> <macro><name>setObject</name><argument_list>(<argument>JSObject *obj</argument>)</argument_list></macro> <block>{
        <expr><name><name>this</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;
    }</block>

    <name>JSObject</name> * <macro><name>object</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><name>obj</name></expr>;</return>
    }</block>

    <name>JSObject</name> ** <macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr>&amp;<name>obj</name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>friend</name> <name>void</name> <call><name>MarkRuntime</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSObject</name> *<name>obj</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoStringRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoStringRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSString *str = NULL
                     JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>, <macro><name>str</name><argument_list>(<argument>str</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>void</name> <macro><name>setString</name><argument_list>(<argument>JSString *str</argument>)</argument_list></macro> <block>{
        <expr><name><name>this</name>-&gt;<name>str</name></name> = <name>str</name></expr>;
    }</block>

    <name>JSString</name> * <macro><name>string</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><name>str</name></expr>;</return>
    }</block>

    <name>JSString</name> ** <macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr>&amp;<name>str</name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSString</name> *<name>str</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoArrayRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoArrayRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>size_t len</argument>, <argument>Value *vec
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>, <macro><name>array</name><argument_list>(<argument>vec</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;
    }</block>

    <macro><name>AutoArrayRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>size_t len</argument>, <argument>jsval *vec
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>, <macro><name>array</name><argument_list>(<argument>Valueify(vec)</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>changeLength</name><argument_list>(<argument>size_t newLength</argument>)</argument_list></macro> <block>{
        <expr><name>tag</name> = <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>changeArray</name><argument_list>(<argument>Value *newArray</argument>, <argument>size_t newLength</argument>)</argument_list></macro> <block>{
        <expr><call><name>changeLength</name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>array</name> = <name>newArray</name></expr>;
    }</block>

    <name>Value</name> *<name>array</name></expr>;

    <expr><name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoShapeRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoShapeRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>const js::Shape *shape
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>SHAPE</name></expr></argument>)</argument_list></call></expr>, <macro><name>shape</name><argument_list>(<argument>shape</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>friend</name> <name>void</name> <call><name>MarkRuntime</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    const <name>js</name>::<name>Shape</name> * const <name>shape</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoScriptRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoScriptRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script
                     JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>SCRIPT</name></expr></argument>)</argument_list></call></expr>, <macro><name>script</name><argument_list>(<argument>script</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>void</name> <macro><name>setScript</name><argument_list>(<argument>JSScript *script</argument>)</argument_list></macro> <block>{
        <expr><name><name>this</name>-&gt;<name>script</name></name> = <name>script</name></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSScript</name> *<name>script</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoIdRooter</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoIdRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>jsid id = INT_TO_JSID(0)
                          JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>, <macro><name>id_</name><argument_list>(<argument>id</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>jsid</name> <macro><name>id</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr><name>id_</name></expr>;</return>
    }</block>

    <name>jsid</name> * <macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr>&amp;<name>id_</name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>friend</name> <name>void</name> <call><name>MarkRuntime</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>jsid</name> <name>id_</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoIdArray</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoIdArray</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSIdArray *ida JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>IDARRAY</name></expr></argument>)</argument_list></call></expr>, <macro><name>idArray</name><argument_list>(<argument>ida</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>
    ~<macro><name>AutoIdArray</name><argument_list>()</argument_list></macro> <block>{
        <if>if <condition>(<expr><name>idArray</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_DestroyIdArray</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>idArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block>
    <name>bool</name> <name>operator</name>!() <block>{
        <return>return <expr><name>idArray</name> == <name>NULL</name></expr>;</return>
    }</block>
    <name>jsid</name> <name><name>operator</name><index>[]</index></name>(<name>size_t</name> <name>i</name>) const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>idArray</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>i</name> &lt; <call><name>size_t</name><argument_list>(<argument><expr><name><name>idArray</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name><name>idArray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
    }</block>
    <name>size_t</name> <macro><name>length</name><argument_list>()</argument_list></macro> const <block>{
         <return>return <expr><name><name>idArray</name>-&gt;<name>length</name></name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>JSIdArray</name> *<macro><name>steal</name><argument_list>()</argument_list></macro> <block>{
        <expr><name>JSIdArray</name> *<name>copy</name> = <name>idArray</name></expr>;
        <expr><name>idArray</name> = <name>NULL</name></expr>;
        <return>return <expr><name>copy</name></expr>;</return>
    }</block>

  <name>protected</name>:
    inline <name>void</name> <call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSIdArray</name> * <name>idArray</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name>

    <comment type="block">/* No copy or assignment semantics. */</comment>
    <call><name>AutoIdArray</name><argument_list>(<argument><expr><name>AutoIdArray</name> &amp;<name>ida</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>void</name> <name>operator</name>=(<name>AutoIdArray</name> &amp;<name>ida</name>)</expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/* The auto-root for enumeration object and its state. */</comment>
<expr_stmt><expr><name>class</name> <name>AutoEnumStateRooter</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <macro><name>AutoEnumStateRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj
                        JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ENUMERATOR</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>obj</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>, <macro><name>stateValue</name><argument_list>()</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    ~<macro><name>AutoEnumStateRooter</name><argument_list>()</argument_list></macro> <block>{
        <if>if <condition>(<expr>!<call><name><name>stateValue</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <type><name>JSBool</name></type> <name>ok</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr><call><name><name>obj</name>-&gt;<name>enumerate</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>JSENUMERATE_DESTROY</name></expr></argument>, <argument><expr>&amp;<name>stateValue</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init>;
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

    <expr>const <name>Value</name> &amp;<macro><name>state</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>stateValue</name></expr>;</return> }</block>
    <name>Value</name> *<macro><name>addr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr>&amp;<name>stateValue</name></expr>;</return> }</block>

  <name>protected</name>:
    <name>void</name> <call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>JSObject</name> * const <name>obj</name></expr>;

  <expr><name>private</name>:
    <name>Value</name> <name>stateValue</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_HAS_XML_SUPPORT</name></cpp:ifdef>
<expr_stmt><expr><name>class</name> <name>AutoXMLRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <call><name>AutoXMLRooter</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSXML</name> *<name>xml</name></expr></argument>)</argument_list></call>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>XML</name></expr></argument>)</argument_list></call></expr>, <macro><name>xml</name><argument_list>(<argument>xml</argument>)</argument_list></macro>
    <expr><block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>xml</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>friend</name> <name>void</name> <call><name>MarkRuntime</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSXML</name> * const <name>xml</name></expr>;
}</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

<type><name>class</name></type> <name>AutoLockGC</name> <block>{
<label><name>private</name>:</label>
    <type><name>JSRuntime</name> *</type><name>rt</name>;
<label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoLockGC</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <macro><name>rt</name><argument_list>(<argument>rt</argument>)</argument_list></macro> <block>{ <expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoLockGC</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block>;

<type><name>class</name></type> <name>AutoUnlockGC</name> <block>{
<label><name>private</name>:</label>
    <type><name>JSRuntime</name> *</type><name>rt</name>;
<label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoUnlockGC</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <macro><name>rt</name><argument_list>(<argument>rt</argument>)</argument_list></macro> <block>{ <expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoUnlockGC</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block>;

<type><name>class</name></type> <name>AutoLockDefaultCompartment</name> <block>{
  <label><name>private</name>:</label>
      <type><name>JSContext</name> *</type><name>cx</name>;
  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>AutoLockDefaultCompartment</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call> : <macro><name>cx</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_LOCK</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lock</name></name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>defaultCompartmentIsLocked</name></name> = <name>true</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    ~<macro><name>AutoLockDefaultCompartment</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_UNLOCK</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lock</name></name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>defaultCompartmentIsLocked</name></name> = <name>false</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr></expr_stmt>
}</block>;

<type><name>class</name></type> <name>AutoUnlockDefaultCompartment</name> <block>{
  <label><name>private</name>:</label>
      <type><name>JSContext</name> *</type><name>cx</name>;
  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>AutoUnlockDefaultCompartment</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call> : <macro><name>cx</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_UNLOCK</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lock</name></name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>defaultCompartmentIsLocked</name></name> = <name>false</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    ~<macro><name>AutoUnlockDefaultCompartment</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_LOCK</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lock</name></name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>defaultCompartmentIsLocked</name></name> = <name>true</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></expr></expr_stmt>
}</block>;

<type><name>class</name></type> <name>AutoKeepAtoms</name> <block>{
    <type><name>JSRuntime</name> *</type><name>rt</name>;
  <label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoKeepAtoms</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <macro><name>rt</name><argument_list>(<argument>rt</argument>)</argument_list></macro> <block>{ <expr><call><name>JS_KEEP_ATOMS</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoKeepAtoms</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_UNKEEP_ATOMS</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block>;

<type><name>class</name></type> <name>AutoArenaAllocator</name> <block>{
    <type><name>JSArenaPool</name> *</type><name>pool</name>;
    <type><name>void</name>        *</type><name>mark</name>;
  <label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoArenaAllocator</name><argument_list>(<argument><expr><name>JSArenaPool</name> *<name>pool</name></expr></argument>)</argument_list></call> : <macro><name>pool</name><argument_list>(<argument>pool</argument>)</argument_list></macro> <block>{ <expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoArenaAllocator</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>; }</block>

    <name>template</name> &lt;<name>typename</name> <name>T</name>&gt;
    <name>T</name> *<macro><name>alloc</name><argument_list>(<argument>size_t elems</argument>)</argument_list></macro> <block>{
        <expr><name>void</name> *<name>ptr</name></expr>;
        <expr><call><name>JS_ARENA_ALLOCATE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>elems</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>static_cast</name>&lt;<name>T</name> *&gt;(<name>ptr</name>)</expr>;</return>
    }</block>
}</expr>;</expr_stmt>

<type><name>class</name></type> <name>AutoReleasePtr</name> <block>{
    <type><name>JSContext</name>   *</type><name>cx</name>;
    <type><name>void</name>        *</type><name>ptr</name>;
    <type><name>AutoReleasePtr</name></type> <name>operator</name><init>=<expr>(const <name>AutoReleasePtr</name> &amp;<name>other</name>)</expr></init>;
  <label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoReleasePtr</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>void</name> *<name>ptr</name></expr></argument>)</argument_list></call> : <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>, <macro><name>ptr</name><argument_list>(<argument>ptr</argument>)</argument_list></macro> <expr><block>{}</block>
    ~<macro><name>AutoReleasePtr</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block>;

<comment type="block">/*
 * FIXME: bug 602774: cleaner API for AutoReleaseNullablePtr
 */</comment>
<type><name>class</name></type> <name>AutoReleaseNullablePtr</name> <block>{
    <type><name>JSContext</name>   *</type><name>cx</name>;
    <type><name>void</name>        *</type><name>ptr</name>;
    <type><name>AutoReleaseNullablePtr</name></type> <name>operator</name><init>=<expr>(const <name>AutoReleaseNullablePtr</name> &amp;<name>other</name>)</expr></init>;
  <label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoReleaseNullablePtr</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>void</name> *<name>ptr</name></expr></argument>)</argument_list></call> : <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>, <macro><name>ptr</name><argument_list>(<argument>ptr</argument>)</argument_list></macro> <expr><block>{}</block>
    <name>void</name> <macro><name>reset</name><argument_list>(<argument>void *ptr2</argument>)</argument_list></macro> <block>{
        <if>if <condition>(<expr><name>ptr</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <name>ptr</name> = <name>ptr2</name></block></expr>;</expr_stmt>
    <expr_stmt/>}</block>
    <name/>~<name>AutoReleaseNullablePtr</name><argument_list>()</argument_list> <block>{ <if>if <condition>(<expr><name>ptr</name></expr>)</condition><then> <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <expr_stmt/>}</block>
};

<type><name>class</name></type> <name>AutoLocalNameArray</name> <block>{
  <label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <macro><name>AutoLocalNameArray</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSFunction *fun
                                JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>context</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>mark</name><argument_list>(<argument><expr><call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>names</name><argument_list>(<argument><expr><call><name><name>fun</name>-&gt;<name>getLocalNameArray</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
        <macro><name>count</name><argument_list>(<argument>fun-&gt;countLocalNames()</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    ~<macro><name>AutoLocalNameArray</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>context</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr>!!<name>names</name></expr>;</return> }</block>

    <name>uint32</name> <macro><name>length</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>count</name></expr>;</return> }</block>

    const <name>jsuword</name> &amp;<name><name>operator</name> <index>[]</index></name>(<name>unsigned</name> <name>i</name>) const <block>{ <return>return <expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block>

  <name>private</name>:
    <name>JSContext</name>   *<name>context</name></expr>;</expr_stmt>
    <type><name>void</name>        *</type><name>mark</name>;
    <type><name>jsuword</name>     *</type><name>names</name>;
    <type><name>uint32</name></type>      <name>count</name>;

    <expr_stmt><expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block>;

<expr_stmt/>}</block> <comment type="block">/* namespace js */</comment>

<name>class</name> <name>JSAutoResolveFlags</name>
<block>{
  <label><name>public</name>:</label>
    <macro><name>JSAutoResolveFlags</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN flags
                       JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>mContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>, <macro><name>mSaved</name><argument_list>(<argument>cx-&gt;resolveFlags</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><name><name>cx</name>-&gt;<name>resolveFlags</name></name> = <name>flags</name></expr>;
    }</block>

    ~<macro><name>JSAutoResolveFlags</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>mContext</name>-&gt;<name>resolveFlags</name></name> = <name>mSaved</name></expr>; }</block>

  <name>private</name>:
    <name>JSContext</name> *<name>mContext</name></expr>;</expr_stmt>
    <type><name>uintN</name></type> <name>mSaved</name>;
    <expr_stmt><expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block>;

<function_decl><type><specifier>extern</specifier> <name>JSThreadData</name> *</type>
<name>js_CurrentThreadData</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InitThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_FinishThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_PurgeThreads</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<type><name>namespace</name></type> <name>js</name> <block>{

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>

<comment type="block">/* Iterator over JSThreadData from all JSThread instances. */</comment>
<expr_stmt><expr><name>class</name> <name>ThreadDataIter</name> : <name>public</name> <name>JSThread</name>::<name>Map</name>::<name>Range</name>
<block>{
  <expr><name>public</name>:
    <call><name>ThreadDataIter</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <name>JSThread</name>::<name>Map</name>::<macro><name>Range</name><argument_list>(<argument>rt-&gt;threads.all()</argument>)</argument_list></macro> <block>{}</block>

    <name>JSThreadData</name> *<macro><name>threadData</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr>&amp;<call><name>front</name><argument_list>()</argument_list></call>.<name><name>value</name>-&gt;<name>data</name></name></expr>;</return>
    }</block>
}</expr>;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !JS_THREADSAFE */</comment>

<expr><name>class</name> <name>ThreadDataIter</name>
<block>{
    <expr><name>JSRuntime</name> *<name>runtime</name></expr>;
    <expr><name>bool</name> <name>done</name></expr>;
  <expr><name>public</name>:
    <call><name>ThreadDataIter</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <call><name>runtime</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>, <macro><name>done</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

    <name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><name>done</name></expr>;</return>
    }</block>

    <name>void</name> <macro><name>popFront</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>done</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>done</name> = <name>true</name></expr>;
    }</block>

    <name>JSThreadData</name> *<macro><name>threadData</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>done</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr>&amp;<name><name>runtime</name>-&gt;<name>threadData</name></name></expr>;</return>
    }</block>
}</expr>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !JS_THREADSAFE */</comment>

}</block> <comment type="block">/* namespace js */</comment>

<comment type="block">/*
 * Create and destroy functions for JSContext, which is manually allocated
 * and exclusively owned.
 */</comment>
extern <name>JSContext</name> *
<macro><name>js_NewContext</name><argument_list>(<argument>JSRuntime *rt</argument>, <argument>size_t stackChunkSize</argument>)</argument_list></macro></expr>;

<expr>extern <name>void</name>
<macro><name>js_DestroyContext</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSDestroyContextMode mode</argument>)</argument_list></macro></expr>;

<expr>static <name>JS_INLINE</name> <name>JSContext</name> *
<macro><name>js_ContextFromLinkField</name><argument_list>(<argument>JSCList *link</argument>)</argument_list></macro>
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><call>(<name>JSContext</name> *) <argument_list>(<argument><expr>(<name>uint8</name> *) <name>link</name> - <call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/*
 * If unlocked, acquire and release rt-&gt;gcLock around *iterp update; otherwise
 * the caller must be holding rt-&gt;gcLock.
 */</comment>
extern <name>JSContext</name> *
<macro><name>js_ContextIterator</name><argument_list>(<argument>JSRuntime *rt</argument>, <argument>JSBool unlocked</argument>, <argument>JSContext **iterp</argument>)</argument_list></macro></expr>;

<comment type="block">/*
 * Iterate through contexts with active requests. The caller must be holding
 * rt-&gt;gcLock in case of a thread-safe build, or otherwise guarantee that the
 * context list is not alternated asynchroniously.
 */</comment>
<expr>extern <macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSContext *</argument>)</argument_list></macro>
<call><name>js_NextActiveContext</name><argument_list>(<argument><expr><name>JSRuntime</name> *</expr></argument>, <argument><expr><name>JSContext</name> *</expr></argument>)</argument_list></call></expr>;

<comment type="block">/*
 * Class.resolve and watchpoint recursion damping machinery.
 */</comment>
<expr>extern <name>JSBool</name>
<macro><name>js_StartResolving</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSResolvingKey *key</argument>, <argument>uint32 flag</argument>,
                  <argument>JSResolvingEntry **entryp</argument>)</argument_list></macro></expr>;

<expr>extern <name>void</name>
<macro><name>js_StopResolving</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSResolvingKey *key</argument>, <argument>uint32 flag</argument>,
                 <argument>JSResolvingEntry *entry</argument>, <argument>uint32 generation</argument>)</argument_list></macro></expr>;

<comment type="block">/*
 * Report an exception, which is currently realized as a printf-style format
 * string and its arguments.
 */</comment>
<typedef>typedef <type><enum>enum <name>JSErrNum</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_DEF</name><parameter_list>(<param><type><name>name</name></type></param>, <param><type><name>number</name></type></param>, <param><type><name>count</name></type></param>, <param><type><name>exception</name></type></param>, <param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>name = number,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"js.msg"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MSG_DEF</name></cpp:undef>
    <decl><name>JSErr_Limit</name>
} <name>JSErrNum</name></decl><empty_stmt>;</empty_stmt>

<extern>extern JS_FRIEND_API(const JSErrorFormatString *</extern>)</block>
<macro><name>js_GetErrorMessage</name><argument_list>(<argument>void *userRef</argument>, <argument>const char *locale</argument>, <argument>const uintN errorNumber</argument>)</argument_list></macro>;</enum></type></typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>va_start</name></cpp:ifdef>
extern <name>JSBool</name>
<macro><name>js_ReportErrorVA</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN flags</argument>, <argument>const char *format</argument>, <argument>va_list ap</argument>)</argument_list></macro></block></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportErrorNumberVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                       <param><decl><type><name>JSBool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ExpandErrorArguments</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                        <param><decl><type><name>char</name> **</type><name>message</name></decl></param>, <param><decl><type><name>JSErrorReport</name> *</type><name>reportp</name></decl></param>,
                        <param><decl><type><name>bool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOutOfMemory</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report that cx-&gt;scriptStackQuota is exhausted.
 */</comment>
<function_decl><type><name>void</name></type>
<name>js_ReportOutOfScriptQuota</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<extern>extern JS_FRIEND_API(void</extern>)</block>
<name>js_ReportOverRecursed</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list>;

<extern>extern JS_FRIEND_API(void</extern>)</block>
<name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_RECURSION</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>onerror</name></type></param>)</parameter_list></cpp:macro>                                       \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        int stackDummy_;                                                      \
                                                                              \
        if (!JS_CHECK_STACK_SIZE(cx-&gt;stackLimit, &amp;stackDummy_)) {             \
            js_ReportOverRecursed(cx);                                        \
            onerror;                                                          \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/*
 * Report an exception using a previously composed JSErrorReport.
 * XXXbe remove from "friend" API
 */</comment>
<extern>extern JS_FRIEND_API(void</extern>)</block>
<name>js_ReportErrorAgain</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr>const <name>char</name> *<name>message</name></expr></argument>, <argument><expr><name>JSErrorReport</name> *<name>report</name></expr></argument>)</argument_list>;

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportIsNotDefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report an attempt to access the property of a null or undefined value (v).
 */</comment>
<type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportIsNullOrUndefined</name>(<name>JSContext</name> *<name>cx</name>, <name>intN</name> <name>spindex</name>, <expr_stmt><expr>const <name>js</name>::<name>Value</name> &amp;<name>v</name></expr>,
                           <expr><name>JSString</name> *<name>fallback</name></expr></expr_stmt>)</block>;

<type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportMissingArg</name>(<name>JSContext</name> *<name>cx</name>, <type><specifier>const</specifier></type> <name>js</name>::<name>Value</name> &amp;<name>v</name>, <decl><name>uintN</name> <name>arg</name></decl>)<empty_stmt>;</empty_stmt>

<comment type="block">/*
 * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
 * the first argument for the error message. If the error message has less
 * then 3 arguments, use null for arg1 or arg2.
 */</comment>
<type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportValueErrorFlags</name>(<name>JSContext</name> *<name>cx</name>, <name>uintN</name> <name>flags</name>, <type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name>,
                         <type><name>intN</name></type> <name>spindex</name>, <expr_stmt><expr>const <name>js</name>::<name>Value</name> &amp;<name>v</name></expr>, <expr><name>JSString</name> *<name>fallback</name></expr>,
                         <expr>const <name>char</name> *<name>arg1</name></expr>, <expr>const <name>char</name> *<name>arg2</name></expr></expr_stmt>)</block>;</enum></type></typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>)</parameter_list></cpp:macro>                \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, NULL, NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError2</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>,<param><type><name>arg1</name></type></param>)</parameter_list></cpp:macro>          \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, arg1, NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError3</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>,<param><type><name>arg1</name></type></param>,<param><type><name>arg2</name></type></param>)</parameter_list></cpp:macro>     \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, arg1, arg2))</cpp:value></cpp:define>

extern <name>JSErrorFormatString</name> <name><name>js_ErrorFormatString</name><index>[<expr><name>JSErr_Limit</name></expr>]</index></name></block></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ASSERT_REQUEST_DEPTH</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(JS_ASSERT((cx)-&gt;thread),               \
                                       JS_ASSERT((cx)-&gt;thread-&gt;data.requestDepth &gt;= 1))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ASSERT_REQUEST_DEPTH</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * If the operation callback flag was set, call the operation callback.
 * This macro can run the full GC. Return true if it is OK to continue and
 * false otherwise.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_OPERATION_LIMIT</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>(JS_ASSERT_REQUEST_DEPTH(cx),                                             \
     (!JS_THREAD_DATA(cx)-&gt;interruptFlags || js_InvokeOperationCallback(cx)))</cpp:value></cpp:define>

<expr><name>JS_ALWAYS_INLINE</name> <name>void</name>
<name>JSThreadData</name>::<macro><name>triggerOperationCallback</name><argument_list>(<argument>JSRuntime *rt</argument>)</argument_list></macro>
<block>{
    <comment type="block">/*
     * Use JS_ATOMIC_SET and JS_ATOMIC_INCREMENT in the hope that it ensures
     * the write will become immediately visible to other processors polling
     * the flag.  Note that we only care about visibility here, not read/write
     * ordering: this field can only be written with the GC lock held.
     */</comment>
    <if>if <condition>(<expr><name>interruptFlags</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <call><name>JS_ATOMIC_SET</name><argument_list>(<argument><expr>&amp;<name>interruptFlags</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></block></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/* rt-&gt;interruptCounter does not reflect suspended threads. */</comment>
    <if>if <condition>(<expr><name>requestDepth</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_ATOMIC_INCREMENT</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>interruptCounter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></expr_stmt>

<comment type="block">/*
 * Invoke the operation callback and return false if the current execution
 * is to be terminated.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InvokeOperationCallback</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_HandleExecutionInterrupt</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<comment type="block">/* These must be called with GC lock taken. */</comment>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>TriggerOperationCallback</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>void</name></type>
<name>TriggerAllOperationCallbacks</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

}</block></decl></decl_stmt> <comment type="block">/* namespace js */</comment>

<function_decl><type><specifier>extern</specifier> <name>JSStackFrame</name> *</type>
<name>js_GetScriptedCaller</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>jsbytecode</name>*</type>
<name>js_GetCurrentBytecodePC</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>bool</name></type>
<name>js_CurrentPCIsInImacro</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>SetPendingException</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>RegExpStatics</name></decl>;</decl_stmt>

<function_decl><type><specifier>extern</specifier> <name>JS_FORCES_STACK</name></type> <name>JS_FRIEND_API</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
LeaveTrace<parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

}</block></decl></decl_stmt> <comment type="block">/* namespace js */</comment>

<comment type="block">/*
 * Get the current frame, first lazily instantiating stack frames if needed.
 * (Do not access cx-&gt;fp() directly except in JS_REQUIRES_STACK code.)
 *
 * Defined in jstracer.cpp if JS_TRACER is defined.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_FORCES_STACK</name> <name>JS_INLINE</name> <name>JSStackFrame</name> *</type>
<name>js_GetTopStackFrame</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>js</name>::<call><name>LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>cx</name>-&gt;<name>maybefp</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>JSBool</name></type>
<name>js_IsPropertyCacheDisabled</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>shapeGen</name></name> &gt;= <name>js</name>::<name>SHAPE_OVERFLOW_BIT</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>uint32</name></type>
<name>js_RegenerateShapeForGC</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRegenShapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Under the GC, compared with js_GenerateShape, we don't need to use
     * atomic increments but we still must make sure that after an overflow
     * the shape stays such.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>shape</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>shapeGen</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>shape</name> = (<name>shape</name> + 1) | (<name>shape</name> &amp; <name>js</name>::<name>SHAPE_OVERFLOW_BIT</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>shapeGen</name></name> = <name>shape</name></expr>;</expr_stmt>
    <return>return <expr><name>shape</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<expr_stmt><expr>inline <name>void</name> *
<name>ContextAllocPolicy</name>::<macro><name>malloc</name><argument_list>(<argument>size_t bytes</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr>inline <name>void</name>
<name>ContextAllocPolicy</name>::<macro><name>free</name><argument_list>(<argument>void *p</argument>)</argument_list></macro>
<block>{
    <expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
}</block>

inline <name>void</name> *
<name>ContextAllocPolicy</name>::<macro><name>realloc</name><argument_list>(<argument>void *p</argument>, <argument>size_t bytes</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name><name>cx</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr>inline <name>void</name>
<name>ContextAllocPolicy</name>::<macro><name>reportAllocOverflow</name><argument_list>()</argument_list></macro> const
<block>{
    <expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>class</name> <name>AutoValueVector</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoValueVector</name><argument_list>(<argument>JSContext *cx
                             JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>VALVECTOR</name></expr></argument>)</argument_list></call></expr>, <macro><name>vector</name><argument_list>(<argument>cx</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>size_t</name> <macro><name>length</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

    <name>bool</name> <macro><name>append</name><argument_list>(<argument>const Value &amp;v</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>vector</name>.<name>append</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

    <name>void</name> <macro><name>popBack</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>vector</name>.<name>popBack</name></name><argument_list>()</argument_list></call></expr>; }</block>

    <name>bool</name> <macro><name>growBy</name><argument_list>(<argument>size_t inc</argument>)</argument_list></macro> <block>{
        <comment type="block">/* N.B. Value's default ctor leaves the Value undefined */</comment>
        <expr><name>size_t</name> <name>oldLength</name> = <call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;
        <if>if <condition>(<expr>!<call><name><name>vector</name>.<name>growByUninitialized</name></name><argument_list>(<argument><expr><name>inc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>false</name></expr>;</return></then></if>
        <call><name>MakeValueRangeGCSafe</name><argument_list>(<argument><expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call> + <name>oldLength</name></expr></argument>, <argument><expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
        <return>return <expr><name>true</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>bool</name></type> <name>resize</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>newLength</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>oldLength</name> <init>= <expr><call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newLength</name> &lt;= <name>oldLength</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>vector</name>.<name>shrinkBy</name></name><argument_list>(<argument><expr><name>oldLength</name> - <name>newLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* N.B. Value's default ctor leaves the Value undefined */</comment>
        <if>if <condition>(<expr>!<call><name><name>vector</name>.<name>growByUninitialized</name></name><argument_list>(<argument><expr><name>newLength</name> - <name>oldLength</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>false</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MakeValueRangeGCSafe</name><argument_list>(<argument><expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call> + <name>oldLength</name></expr></argument>, <argument><expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    }</block></function>

    <function><type><name>bool</name></type> <name>reserve</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>newLength</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>vector</name>.<name>reserve</name></name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>Value</name> &amp;</type><name>operator</name>[]<parameter_list>(<param><decl><type><name>size_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block></function>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>size_t</name> <name>i</name></expr></argument>)</argument_list> const <block>{ <return>return <expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block></decl></decl_stmt>

    <expr_stmt><expr>const <name>Value</name> *<macro><name>begin</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>Value</name> *</type><name>begin</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr>const <name>Value</name> *<macro><name>end</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>Value</name> *</type><name>end</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr>const <name>jsval</name> *<macro><name>jsval_begin</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name>Jsvalify</name><argument_list>(<argument><expr><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>jsval</name> *</type><name>jsval_begin</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>Jsvalify</name><argument_list>(<argument><expr><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr>const <name>jsval</name> *<macro><name>jsval_end</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name>Jsvalify</name><argument_list>(<argument><expr><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>jsval</name> *</type><name>jsval_end</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>Jsvalify</name><argument_list>(<argument><expr><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr>const <name>Value</name> &amp;<macro><name>back</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>back</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>private</name>:</label>
    <expr_stmt><expr><name>Vector</name>&lt;<name>Value</name></expr>, <expr>8&gt; <name>vector</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>class</name> <name>AutoIdVector</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoIdVector</name><argument_list>(<argument>JSContext *cx
                          JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>IDVECTOR</name></expr></argument>)</argument_list></call></expr>, <macro><name>vector</name><argument_list>(<argument>cx</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>size_t</name> <macro><name>length</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

    <name>bool</name> <macro><name>append</name><argument_list>(<argument>jsid id</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>vector</name>.<name>append</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

    <name>void</name> <macro><name>popBack</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>vector</name>.<name>popBack</name></name><argument_list>()</argument_list></call></expr>; }</block>

    <name>bool</name> <macro><name>growBy</name><argument_list>(<argument>size_t inc</argument>)</argument_list></macro> <block>{
        <comment type="block">/* N.B. jsid's default ctor leaves the jsid undefined */</comment>
        <expr><name>size_t</name> <name>oldLength</name> = <call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;
        <if>if <condition>(<expr>!<call><name><name>vector</name>.<name>growByUninitialized</name></name><argument_list>(<argument><expr><name>inc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>false</name></expr>;</return></then></if>
        <call><name>MakeIdRangeGCSafe</name><argument_list>(<argument><expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call> + <name>oldLength</name></expr></argument>, <argument><expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
        <return>return <expr><name>true</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>bool</name></type> <name>resize</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>newLength</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>oldLength</name> <init>= <expr><call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newLength</name> &lt;= <name>oldLength</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>vector</name>.<name>shrinkBy</name></name><argument_list>(<argument><expr><name>oldLength</name> - <name>newLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* N.B. jsid's default ctor leaves the jsid undefined */</comment>
        <if>if <condition>(<expr>!<call><name><name>vector</name>.<name>growByUninitialized</name></name><argument_list>(<argument><expr><name>newLength</name> - <name>oldLength</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>false</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>MakeIdRangeGCSafe</name><argument_list>(<argument><expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call> + <name>oldLength</name></expr></argument>, <argument><expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    }</block></function>

    <function><type><name>bool</name></type> <name>reserve</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>newLength</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>vector</name>.<name>reserve</name></name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>jsid</name> &amp;</type><name>operator</name>[]<parameter_list>(<param><decl><type><name>size_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block></function>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jsid</name> &amp;</type><name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>size_t</name> <name>i</name></expr></argument>)</argument_list> const <block>{ <return>return <expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block></decl></decl_stmt>

    <expr_stmt><expr>const <name>jsid</name> *<macro><name>begin</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>jsid</name> *</type><name>begin</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr>const <name>jsid</name> *<macro><name>end</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>jsid</name> *</type><name>end</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>vector</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr>const <name>jsid</name> &amp;<macro><name>back</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>back</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

    <expr_stmt><expr><name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>private</name>:</label>
    <expr_stmt><expr><name>Vector</name>&lt;<name>jsid</name></expr>, <expr>8&gt; <name>vector</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>JSIdArray</name> *</type>
<name>NewIdArray</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsint</name></type> <name>length</name></decl></param>)</parameter_list>;</function_decl>

} <comment type="block">/* namespace js */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(pop)</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(pop)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_UNDEFD_MOZALLOC_WRAPPERS</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/mozalloc_macro_wrappers.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* jscntxt_h___ */</comment>
</unit>
