<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0064aad76e71399a8ab7763228085f4d2e0619f1.c"><comment type="block">/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set sw=4 ts=8 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS bytecode descriptors, disassemblers, and decompilers.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstddef.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MEMORY_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdtoa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsconfig.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdbgapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsemit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>js_incop_strs</name><index>[]</index><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>"++"</expr>, <expr>"--"</expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name></type> <name><name>js_CodeSpec</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPDEF</name><parameter_list>(<param><type><name>op</name></type></param>,<param><type><name>val</name></type></param>,<param><type><name>name</name></type></param>,<param><type><name>token</name></type></param>,<param><type><name>length</name></type></param>,<param><type><name>nuses</name></type></param>,<param><type><name>ndefs</name></type></param>,<param><type><name>prec</name></type></param>,<param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{length,nuses,ndefs,prec,format},</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPDEF</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uintN</name></type> <name>js_NumCodeSpecs</name> <init>= <expr><call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>js_CodeSpec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Each element of the array is either a source literal associated with JS
 * bytecode or null.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>CodeToken</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPDEF</name><parameter_list>(<param><type><name>op</name></type></param>,<param><type><name>val</name></type></param>,<param><type><name>name</name></type></param>,<param><type><name>token</name></type></param>,<param><type><name>length</name></type></param>,<param><type><name>nuses</name></type></param>,<param><type><name>ndefs</name></type></param>,<param><type><name>prec</name></type></param>,<param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>token,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPDEF</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<comment type="block">/*
 * Array of JS bytecode names used by DEBUG-only js_Disassemble.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>CodeName</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPDEF</name><parameter_list>(<param><type><name>op</name></type></param>,<param><type><name>val</name></type></param>,<param><type><name>name</name></type></param>,<param><type><name>token</name></type></param>,<param><type><name>length</name></type></param>,<param><type><name>nuses</name></type></param>,<param><type><name>ndefs</name></type></param>,<param><type><name>prec</name></type></param>,<param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>name,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPDEF</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>GetJumpOffset</name><parameter_list>(<param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>type</name> = <call><name>JOF_OPTYPE</name><argument_list>(<argument><expr>*<name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>uintN</name></type>
<name>js_GetIndexFromBytecode</name><parameter_list>(<param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>pcoff</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>span</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>op</name> = (<name>JSOp</name>)*<name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>length</name> &gt;= 1 + <name>pcoff</name> + <name>UINT16_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to detect index base prefix. It presents when resetbase
     * follows the bytecode.
     */</comment>
    <expr_stmt><expr><name>span</name> = <name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pc</name> - <name><name>script</name>-&gt;<name>code</name></name> + <name>span</name> &lt; <name><name>script</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>span</name></expr>]</index></name> == <name>JSOP_RESETBASE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>base</name> = <call><name>GET_INDEXBASE</name><argument_list>(<argument><expr><name>pc</name> - <name>JSOP_INDEXBASE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>span</name></expr>]</index></name> == <name>JSOP_RESETBASE0</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>JSOP_INDEXBASE1</name> &lt;= <name><name>pc</name><index>[<expr>-1</expr>]</index></name> || <name><name>pc</name><index>[<expr>-1</expr>]</index></name> &lt;= <name>JSOP_INDEXBASE3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>base</name> = (<name><name>pc</name><index>[<expr>-1</expr>]</index></name> - <name>JSOP_INDEXBASE1</name> + 1) &lt;&lt; 16</expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if>
    <return>return <expr><name>base</name> + <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name> + <name>pcoff</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSBool</argument>)</argument_list></macro>
<macro><name>js_Disassemble</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script</argument>, <argument>JSBool lines</argument>, <argument>FILE *fp</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pc</name> = <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>pc</name> + <name><name>script</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pc</name> &lt; <name>end</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name>pc</name> == <name><name>script</name>-&gt;<name/></name>main</expr>)</condition><then>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"main:\n"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>len</name> = <call><name>js_Disassemble1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>,
                              <argument><expr><call><name>PTRDIFF</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>lines</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>len</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>ToDisassemblySource</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>obj</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_BlockClass</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>source</name> = <call><name>JS_sprintf_append</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>"depth %d {"</expr></argument>,
                                       <argument><expr><call><name>OBJ_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>sprop</name> = <call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>lastProp</name></expr>;</init> <condition><expr><name>sprop</name></expr>;</condition>
                 <incr><expr><name>sprop</name> = <name><name>sprop</name>-&gt;<name>parent</name></name></expr></incr>) <block>{
                <expr_stmt><expr><name>bytes</name> = <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSID_TO_ATOM</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>source</name> = <call><name>JS_sprintf_append</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr>"%s: %d%s"</expr></argument>,
                                           <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>,
                                           <argument><expr><name><name>sprop</name>-&gt;<name>parent</name></name> ? ", " : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name>source</name> = <call><name>JS_sprintf_append</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr>"}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>source</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>str</name> = <call><name>JS_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <return>return <expr><call><name>js_GetStringBytes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><call><name>js_ValueToPrintableSource</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>uintN</argument>)</argument_list></macro>
<macro><name>js_Disassemble1</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script</argument>, <argument>jsbytecode *pc</argument>,
                <argument>uintN loc</argument>, <argument>JSBool lines</argument>, <argument>FILE *fp</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>jmplen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>op</name> = (<name>JSOp</name>)*<name>pc</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>op</name> &gt;= <name>JSOP_LIMIT</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>numBuf1</name><index>[<expr>12</expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>numBuf2</name><index>[<expr>12</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>numBuf1</name></expr></argument>, <argument><expr>sizeof <name>numBuf1</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>numBuf2</name></expr></argument>, <argument><expr>sizeof <name>numBuf2</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>JSOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_BYTECODE_TOO_BIG</name></expr></argument>, <argument><expr><name>numBuf1</name></expr></argument>, <argument><expr><name>numBuf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = (<name>ptrdiff_t</name>) <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%05u:"</expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>lines</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%4u"</expr></argument>, <argument><expr><call><name>JS_PCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"  %s"</expr></argument>, <argument><expr><name><name>CodeName</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> = <call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
      <case>case <expr><name>JOF_BYTE</name></expr>:
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_TRAP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>op</name> = <call><name>JS_GetTrapOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>op</name> == <name>JSOP_LIMIT</name></expr>)</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
            <expr_stmt><expr><name>len</name> = (<name>ptrdiff_t</name>) <name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>JOF_JUMP</name></expr>:
      </case><case>case <expr><name>JOF_JUMPX</name></expr>:
        <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %u (%d)"</expr></argument>, <argument><expr><name>loc</name> + <name>off</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JOF_ATOM</name></expr>:
      </case><case>case <expr><name>JOF_OBJECT</name></expr>:
      </case><case>case <expr><name>JOF_REGEXP</name></expr>:
        <expr_stmt><expr><name>index</name> = <call><name>js_GetIndexFromBytecode</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> == <name>JOF_ATOM</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_GET_SCRIPT_ATOM</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>type</name> == <name>JOF_OBJECT</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>JS_GET_SCRIPT_OBJECT</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name>JS_GET_SCRIPT_REGEXP</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            <expr_stmt><expr><name>v</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>bytes</name> = <call><name>ToDisassemblySource</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %s"</expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JOF_UINT16</name></expr>:
      </case><case>case <expr><name>JOF_LOCAL</name></expr>:
        <expr_stmt><expr><name>i</name> = (<name>jsint</name>)<call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>print_int</name>;</goto>

      </case><case>case <expr><name>JOF_2BYTE</name></expr>:
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %u"</expr></argument>, <argument><expr>(<name>uintN</name>)<name><name>pc</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JOF_TABLESWITCH</name></expr>:
      </case><case>case <expr><name>JOF_TABLESWITCHX</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>jmplen</name> = (<name>type</name> == <name>JOF_TABLESWITCH</name>) ? <name>JUMP_OFFSET_LEN</name>
                                           : <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>low</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>high</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" defaultOffset %d low %d high %d"</expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = <name>low</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>high</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\n\t%d: %d"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>len</name> = 1 + <name>pc2</name> - <name>pc</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>JOF_LOOKUPSWITCH</name></expr>:
      </case><case>case <expr><name>JOF_LOOKUPSWITCHX</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsatomid</name></type> <name>npairs</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>jmplen</name> = (<name>type</name> == <name>JOF_LOOKUPSWITCH</name>) ? <name>JUMP_OFFSET_LEN</name>
                                            : <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>npairs</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>UINT16_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" offset %d npairs %u"</expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr>(<name>uintN</name>) <name>npairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>npairs</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>JS_GET_SCRIPT_ATOM</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>bytes</name> = <call><name>ToDisassemblySource</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\n\t%s: %d"</expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>npairs</name>--</expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>len</name> = 1 + <name>pc2</name> - <name>pc</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>JOF_QARG</name></expr>:
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %u"</expr></argument>, <argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JOF_QVAR</name></expr>:
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %u"</expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JOF_SLOTATOM</name></expr>:
      </case><case>case <expr><name>JOF_SLOTOBJECT</name></expr>:
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %u"</expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>index</name> = <call><name>js_GetIndexFromBytecode</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>VARNO_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> == <name>JOF_SLOTATOM</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_GET_SCRIPT_ATOM</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_GET_SCRIPT_OBJECT</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>v</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>bytes</name> = <call><name>ToDisassemblySource</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %s"</expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JOF_UINT24</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_UINT24</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = (<name>jsint</name>)<call><name>GET_UINT24</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>print_int</name>;</goto>

      </case><case>case <expr><name>JOF_INT8</name></expr>:
        <expr_stmt><expr><name>i</name> = <call><name>GET_INT8</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>print_int</name>;</goto>

      </case><case>case <expr><name>JOF_INT32</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = <call><name>GET_INT32</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <label><name>print_int</name>:</label>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>" %d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><default>default: <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>numBuf</name><index>[<expr>12</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>numBuf</name></expr></argument>, <argument><expr>sizeof <name>numBuf</name></expr></argument>, <argument><expr>"%lx"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>) <name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_UNKNOWN_FORMAT</name></expr></argument>, <argument><expr><name>numBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
      }</block>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len</name></expr>;</return>
}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>

<comment type="block">/************************************************************************/</comment>

<comment type="block">/*
 * Sprintf, but with unlimited and automatically allocated buffering.
 */</comment>
<typedef>typedef <type><struct>struct <name>Sprinter</name> <block>{
    <decl_stmt><decl><type><name>JSContext</name>       *</type><name>context</name></decl>;</decl_stmt>       <comment type="block">/* context executing the decompiler */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name>     *</type><name>pool</name></decl>;</decl_stmt>          <comment type="block">/* string allocation pool */</comment>
    <decl_stmt><decl><type><name>char</name>            *</type><name>base</name></decl>;</decl_stmt>          <comment type="block">/* base address of buffer in pool */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>size</name></decl>;</decl_stmt>           <comment type="block">/* size of buffer allocated at base */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>       <name>offset</name></decl>;</decl_stmt>         <comment type="block">/* offset of next free char in buffer */</comment>
}</block></struct></type> <name>Sprinter</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_SPRINTER</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>sp</name></type></param>, <param><type><name>ap</name></type></param>, <param><type><name>off</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((sp)-&gt;context = cx, (sp)-&gt;pool = ap, (sp)-&gt;base = NULL, (sp)-&gt;size = 0,  \
     (sp)-&gt;offset = off)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF2STR</name><parameter_list>(<param><type><name>sp</name></type></param>,<param><type><name>off</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sp)-&gt;base + (off))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR2OFF</name><parameter_list>(<param><type><name>sp</name></type></param>,<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((str) - (sp)-&gt;base)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETRACT</name><parameter_list>(<param><type><name>sp</name></type></param>,<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sp)-&gt;offset = STR2OFF(sp, str))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>SprintEnsureBuffer</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>base</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nb</name> = (<name><name>sp</name>-&gt;<name>offset</name></name> + <name>len</name> + 1) - <name><name>sp</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nb</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>base</name> = <name><name>sp</name>-&gt;<name>base</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>base</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>, <argument><expr><name><name>sp</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>, <argument><expr><name><name>sp</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>sp</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr>!<name>base</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>sp</name>-&gt;<name>base</name></name> = <name>base</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name>-&gt;<name>size</name></name> += <name>nb</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>SprintPut</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bp</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate space for s, including the '\0' at the end. */</comment>
    <if>if <condition>(<expr>!<call><name>SprintEnsureBuffer</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <comment type="block">/* Advance offset and copy s into sp's buffer. */</comment>
    <expr_stmt><expr><name>offset</name> = <name><name>sp</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name>-&gt;<name>offset</name></name> += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bp</name> = <name><name>sp</name>-&gt;<name>base</name></name> + <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bp</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>SprintCString</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>SprintPut</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>SprintString</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JSSTRING_CHARS_AND_LENGTH</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>length</name> == 0</expr>)</condition><then>
        <return>return <expr><name><name>sp</name>-&gt;<name>offset</name></name></expr>;</return></then></if>

    <expr_stmt><expr><name>size</name> = <call><name>js_GetDeflatedStringLength</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>size</name> == (<name>size_t</name>)-1 || !<call><name>SprintEnsureBuffer</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <expr_stmt><expr><name>offset</name> = <name><name>sp</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name>-&gt;<name>offset</name></name> += <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_DeflateStringToBuffer</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>sp</name>-&gt;<name>base</name></name> + <name>offset</name></expr></argument>,
                             <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sp</name>-&gt;<name>base</name><index>[<expr><name><name>sp</name>-&gt;<name>offset</name></name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>Sprint</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bp</name> = <call><name>JS_vsmprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* XXX vsaprintf */</comment>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>bp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>offset</name> = <call><name>SprintCString</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_EscapeMap</name><index>[]</index></name> <init>= <expr><block>{
    <expr>'\b'</expr>, <expr>'b'</expr>,
    <expr>'\f'</expr>, <expr>'f'</expr>,
    <expr>'\n'</expr>, <expr>'n'</expr>,
    <expr>'\r'</expr>, <expr>'r'</expr>,
    <expr>'\t'</expr>, <expr>'t'</expr>,
    <expr>'\v'</expr>, <expr>'v'</expr>,
    <expr>'"'</expr>,  <expr>'"'</expr>,
    <expr>'\''</expr>, <expr>'\''</expr>,
    <expr>'\\'</expr>, <expr>'\\'</expr>,
    <expr>'\0'</expr>, <expr>'0'</expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DONT_ESCAPE</name></cpp:macro>     <cpp:value>0x10000</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>QuoteString</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>quote</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>dontEscape</name></decl>, <decl><type ref="prev"/><name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>qc</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>t</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bp</name></decl>;</decl_stmt>

    <comment type="block">/* Sample off first for later return value pointer computation. */</comment>
    <expr_stmt><expr><name>dontEscape</name> = (<name>quote</name> &amp; <name>DONT_ESCAPE</name>) != 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>qc</name> = (<name>jschar</name>) <name>quote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>off</name> = <name><name>sp</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>qc</name> &amp;&amp; <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr>(<name>char</name>)<name>qc</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Loop control variables: z points at end of string sentinel. */</comment>
    <expr_stmt><expr><call><name>JSSTRING_CHARS_AND_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>t</name> = <name>s</name></expr>;</init> <condition><expr><name>t</name> &lt; <name>z</name></expr>;</condition> <incr><expr><name>s</name> = ++<name>t</name></expr></incr>) <block>{
        <comment type="block">/* Move t forward from s past un-quote-worthy characters. */</comment>
        <expr_stmt><expr><name>c</name> = *<name>t</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>JS_ISPRINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> &amp;&amp; <name>c</name> != <name>qc</name> &amp;&amp; <name>c</name> != '\\' &amp;&amp; <name>c</name> != '\t' &amp;&amp;
               !(<name>c</name> &gt;&gt; 8)</expr>)</condition> <block>{
            <expr_stmt><expr><name>c</name> = *++<name>t</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>t</name> == <name>z</name></expr>)</condition><then>
                <break>break;</break></then></if>
        }</block></while>
        <expr_stmt><expr><name>len</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>jschar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Allocate space for s, including the '\0' at the end. */</comment>
        <if>if <condition>(<expr>!<call><name>SprintEnsureBuffer</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/* Advance sp-&gt;offset and copy s into sp's buffer. */</comment>
        <expr_stmt><expr><name>bp</name> = <name><name>sp</name>-&gt;<name>base</name></name> + <name><name>sp</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sp</name>-&gt;<name>offset</name></name> += <name>len</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>--<name>len</name> &gt;= 0</expr>)</condition>
            <expr_stmt><expr>*<name>bp</name>++ = (<name>char</name>) *<name>s</name>++</expr>;</expr_stmt></while>
        <expr_stmt><expr>*<name>bp</name> = '\0'</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>t</name> == <name>z</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <comment type="block">/* Use js_EscapeMap, \u, or \x only if necessary. */</comment>
        <if>if <condition>(<expr>!(<name>c</name> &gt;&gt; 8) &amp;&amp; (<name>e</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>js_EscapeMap</name></expr></argument>, <argument><expr>(<name>int</name>)<name>c</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <name>dontEscape</name>
                 ? <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr>(<name>char</name>)<name>c</name></expr></argument>)</argument_list></call> &gt;= 0
                 : <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>"\\%c"</expr></argument>, <argument><expr><name><name>e</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>(<name>c</name> &gt;&gt; 8) ? "\\u%04X" : "\\x%02X"</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></for>

    <comment type="block">/* Sprint the closing quote and return the quoted string. */</comment>
    <if>if <condition>(<expr><name>qc</name> &amp;&amp; <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr>(<name>char</name>)<name>qc</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/*
     * If we haven't Sprint'd anything yet, Sprint an empty string so that
     * the OFF2STR below gives a valid result.
     */</comment>
    <if>if <condition>(<expr><name>off</name> == <name><name>sp</name>-&gt;<name>offset</name></name> &amp;&amp; <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name>OFF2STR</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSString</name> *</type>
<name>js_QuoteString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>jschar</name></type> <name>quote</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Sprinter</name></type> <name>sprinter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>escstr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT_SPRINTER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>sprinter</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bytes</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name>sprinter</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>escstr</name> = <name>bytes</name> ? <call><name>JS_NewStringCopyZ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>escstr</name></expr>;</return>
}</block></function>

<comment type="block">/************************************************************************/</comment>

<struct>struct <name>JSPrinter</name> <block>{
    <decl_stmt><decl><type><name>Sprinter</name></type>        <name>sprinter</name></decl>;</decl_stmt>       <comment type="block">/* base class state */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name></type>     <name>pool</name></decl>;</decl_stmt>           <comment type="block">/* string allocation pool */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>           <name>indent</name></decl>;</decl_stmt>         <comment type="block">/* indentation in spaces */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>    <name>pretty</name></decl>;</decl_stmt>         <comment type="block">/* pretty-print: indent, use newlines */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>    <name>grouped</name></decl>;</decl_stmt>        <comment type="block">/* in parenthesized expression context */</comment>
    <decl_stmt><decl><type><name>JSScript</name>        *</type><name>script</name></decl>;</decl_stmt>        <comment type="block">/* script being printed */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>dvgfence</name></decl>;</decl_stmt>      <comment type="block">/* js_DecompileValueGenerator fencepost */</comment>
    <decl_stmt><decl><type><name>JSFunction</name>      *</type><name>fun</name></decl>;</decl_stmt>           <comment type="block">/* interpreted function */</comment>
    <decl_stmt><decl><type><name>jsuword</name>         *</type><name>localNames</name></decl>;</decl_stmt>    <comment type="block">/* argument and variable names */</comment>
}</block>;</struct>

<comment type="block">/*
 * Hack another flag, a la JS_DONT_PRETTY_PRINT, into uintN indent parameters
 * to functions such as js_DecompileFunction and js_NewPrinter.  This time, as
 * opposed to JS_DONT_PRETTY_PRINT back in the dark ages, we can assume that a
 * uintN is at least 32 bits.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_IN_GROUP_CONTEXT</name></cpp:macro> <cpp:value>0x10000</cpp:value></cpp:define>

<function><type><name>JSPrinter</name> *</type>
<name>JS_NEW_PRINTER</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,  <param><decl><type><name>JSFunction</name> *</type><name>fun</name></decl></param>,
               <param><decl><type><name>uintN</name></type> <name>indent</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>pretty</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>jp</name> = (<name>JSPrinter</name> *) <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSPrinter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>jp</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>INIT_SPRINTER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>&amp;<name><name>jp</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_INIT_ARENA_POOL</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>256</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> = <name>indent</name> &amp; ~<name>JS_IN_GROUP_CONTEXT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>pretty</name></name> = <name>pretty</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>grouped</name></name> = (<name>indent</name> &amp; <name>JS_IN_GROUP_CONTEXT</name>) != 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>dvgfence</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>localNames</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>fun</name> &amp;&amp; <call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JS_GET_LOCAL_NAME_COUNT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>localNames</name></name> = <call><name>js_GetLocalNameArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr>&amp;<name><name>jp</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>jp</name>-&gt;<name>localNames</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_DestroyPrinter</name><argument_list>(<argument><expr><name>jp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>jp</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_DestroyPrinter</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>, <argument><expr><name>jp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSString</name> *</type>
<name>js_GetPrinterOutput</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cx</name> = <name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>jp</name>-&gt;<name>sprinter</name>.<name>base</name></name></expr>)</condition><then>
        <return>return <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr>;</return></then></if>
    <expr_stmt><expr><name>str</name> = <call><name>JS_NewStringCopyZ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>jp</name>-&gt;<name>sprinter</name>.<name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_FreeArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>INIT_SPRINTER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>&amp;<name><name>jp</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * NB: Indexed by SRC_DECL_* defines from jsemit.h.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>var_prefix</name><index>[]</index></name> <init>= <expr><block>{<expr>"var "</expr>, <expr>"const "</expr>, <expr>"let "</expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>VarPrefix</name><parameter_list>(<param><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>sn</name> &amp;&amp; (<call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_DECL</name> || <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_GROUPASSIGN</name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>type</name> <init>= <expr><call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>uintN</name>)<name>type</name> &lt;= <name>SRC_DECL_LET</name></expr>)</condition><then>
            <return>return <expr><name><name>var_prefix</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr>""</expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>js_printf</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bp</name></decl>, *<decl><type ref="prev"/><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cc</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>format</name> == '\0'</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If pretty-printing, expand magic tab into a run of jp-&gt;indent spaces. */</comment>
    <if>if <condition>(<expr>*<name>format</name> == '\t'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>format</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>jp</name>-&gt;<name>pretty</name></name> &amp;&amp; <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%*s"</expr></argument>, <argument><expr><name><name>jp</name>-&gt;<name>indent</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/* Suppress newlines (must be once per format, at the end) if not pretty. */</comment>
    <expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>jp</name>-&gt;<name>pretty</name></name> &amp;&amp; <name><name>format</name><index>[<expr><name>cc</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> - 1</expr>]</index></name> == '\n'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>fp</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
        <expr_stmt><expr><name><name>fp</name><index>[<expr><name>cc</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>format</name> = <name>fp</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Allocate temp space, convert format, and put. */</comment>
    <expr_stmt><expr><name>bp</name> = <call><name>JS_vsmprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* XXX vsaprintf */</comment>
    <if>if <condition>(<expr><name>fp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>format</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>bp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>cc</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>cc</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>cc</name> = -1</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cc</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_puts</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<comment type="block">/************************************************************************/</comment>

<typedef>typedef <type><struct>struct <name>SprintStack</name> <block>{
    <decl_stmt><decl><type><name>Sprinter</name></type>    <name>sprinter</name></decl>;</decl_stmt>       <comment type="block">/* sprinter for postfix to infix buffering */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name>   *</type><name>offsets</name></decl>;</decl_stmt>       <comment type="block">/* stack of postfix string offsets */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name>  *</type><name>opcodes</name></decl>;</decl_stmt>       <comment type="block">/* parallel stack of JS opcodes */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>       <name>top</name></decl>;</decl_stmt>            <comment type="block">/* top of stack index */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>       <name>inArrayInit</name></decl>;</decl_stmt>    <comment type="block">/* array initialiser/comprehension level */</comment>
    <decl_stmt><decl><type><name>JSBool</name></type>      <name>inGenExp</name></decl>;</decl_stmt>       <comment type="block">/* in generator expression */</comment>
    <decl_stmt><decl><type><name>JSPrinter</name>   *</type><name>printer</name></decl>;</decl_stmt>       <comment type="block">/* permanent output goes here */</comment>
}</block></struct></type> <name>SprintStack</name>;</typedef>

<comment type="block">/*
 * Get a stacked offset from ss-&gt;sprinter.base, or if the stacked value |off|
 * is negative, lazily fetch the generating pc at |spindex = 1 + off| and try
 * to decompile the code that generated the missing value.  This is used when
 * reporting errors, where the model stack will lack |pcdepth| non-negative
 * offsets (see js_DecompileValueGenerator and js_DecompileCode).
 *
 * If the stacked offset is -1, return 0 to index the NUL padding at the start
 * of ss-&gt;sprinter.base.  If this happens, it means there is a decompiler bug
 * to fix, but it won't violate memory safety.
 */</comment>
<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>GetOff</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>off</name> = <name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_brendan</name> || <name>defined</name> <name>DEBUG_mrbkap</name> || <name>defined</name> <name>DEBUG_crowder</name></expr></cpp:if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>off</name> &lt; -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr>++<name>off</name> == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>ss</name>-&gt;<name>sprinter</name>.<name>base</name></name> &amp;&amp; <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>base</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>bytes</name> = <call><name>js_DecompileValueGenerator</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>,
                                           <argument><expr><name>JSVAL_NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>off</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><name>off</name> = 0</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> = <name>off</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>off</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>GetStr</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Must call GetOff before using ss-&gt;sprinter.base, since it may be null
     * until bootstrapped by GetOff.
     */</comment>
    <expr_stmt><expr><name>off</name> = <call><name>GetOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Gap between stacked strings to allow for insertion of parens and commas. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAREN_SLOP</name></cpp:macro>      <cpp:value>(2 + 1)</cpp:value></cpp:define>

<comment type="block">/*
 * These pseudo-ops help js_DecompileValueGenerator decompile JSOP_SETNAME,
 * JSOP_SETPROP, and JSOP_SETELEM, respectively.  They are never stored in
 * bytecode, so they don't preempt valid opcodes.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOP_GETPROP2</name></cpp:macro>   <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOP_GETELEM2</name></cpp:macro>   <cpp:value>257</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddParenSlop</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PAREN_SLOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> += <name>PAREN_SLOP</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>PushOff</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>top</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>SprintEnsureBuffer</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>PAREN_SLOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/* ss-&gt;top points to the next free slot; be paranoid about overflow. */</comment>
    <expr_stmt><expr><name>top</name> = <name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>top</name> &lt; <name><name>ss</name>-&gt;<name>printer</name>-&gt;<name>script</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>top</name> &gt;= <name><name>ss</name>-&gt;<name>printer</name>-&gt;<name>script</name>-&gt;<name>depth</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* The opcodes stack must contain real bytecodes that index js_CodeSpec. */</comment>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>top</name></expr>]</index></name> = <name>off</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name>top</name></expr>]</index></name> = (<name>op</name> == <name>JSOP_GETPROP2</name>) ? <name>JSOP_GETPROP</name>
                     : (<name>op</name> == <name>JSOP_GETELEM2</name>) ? <name>JSOP_GETELEM</name>
                     : (<name>jsbytecode</name>) <name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = ++<name>top</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddParenSlop</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>PopOff</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>top</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>, *<decl><type ref="prev"/><name>topcs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>

    <comment type="block">/* ss-&gt;top points to the next free slot; be paranoid about underflow. */</comment>
    <expr_stmt><expr><name>top</name> = <name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>top</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>top</name> == 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = --<name>top</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>off</name> = <call><name>GetOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>topcs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name>top</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>topcs</name>-&gt;<name>prec</name></name> != 0 &amp;&amp; <name><name>topcs</name>-&gt;<name>prec</name></name> &lt; <name><name>cs</name>-&gt;<name>prec</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>top</name></expr>]</index></name> = <name>off</name> - 2</expr>;</expr_stmt>
        <expr_stmt><expr><name>off</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"(%s)"</expr></argument>, <argument><expr><call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name>off</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>off</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>PopStr</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>off</name> = <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>TableEntry</name> <block>{
    <decl_stmt><decl><type><name>jsval</name></type>       <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>   <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name>      *</type><name>label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type>       <name>order</name></decl>;</decl_stmt>          <comment type="block">/* source order for stable tableswitch sort */</comment>
}</block></struct></type> <name>TableEntry</name>;</typedef>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CompareOffsets</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v2</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset_diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TableEntry</name> *</type><name>te1</name> <init>= <expr>(const <name>TableEntry</name> *) <name>v1</name></expr></init>,
                     *<name>te2</name> <init>= <expr>(const <name>TableEntry</name> *) <name>v2</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>offset_diff</name> = <name><name>te1</name>-&gt;<name>offset</name></name> - <name><name>te2</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>result</name> = (<name>offset_diff</name> == 0 ? <name><name>te1</name>-&gt;<name>order</name></name> - <name><name>te2</name>-&gt;<name>order</name></name>
               : <name>offset_diff</name> &lt; 0 ? -1
               : 1)</expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>SprintDoubleValue</name><parameter_list>(<param><decl><type><name>Sprinter</name> *</type><name>sp</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>JSOp</name> *</type><name>opp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>todo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>DTOSTR_STANDARD_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = *<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>"-0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>opp</name> = <name>JSOP_NEG</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>JSDOUBLE_IS_FINITE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Don't use Infinity and NaN, they're mutable. */</comment>
        <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr><name>sp</name></expr></argument>,
                             <argument><expr><call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call>
                             ? "0 / 0"
                             : (<name>d</name> &lt; 0)
                             ? "1 / -0"
                             : "1 / 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>opp</name> = <name>JSOP_DIV</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>s</name> = <call><name>JS_dtostr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>, <argument><expr><name>DTOSTR_STANDARD</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>js_Infinity_str</name></expr></argument>)</argument_list></call> &amp;&amp;
                  (*<name>s</name> != '-' ||
                   <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name> + 1</expr></argument>, <argument><expr><name>js_Infinity_str</name></expr></argument>)</argument_list></call>) &amp;&amp;
                  <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>js_NaN_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <return>return <expr><name>todo</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>Decompile</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>intN</name></type> <name>nb</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>nextop</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>DecompileSwitch</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>TableEntry</name> *</type><name>table</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>tableLength</name></decl></param>,
                <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>switchLength</name></decl></param>,
                <param><decl><type><name>ptrdiff_t</name></type> <name>defaultOffset</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>isCondSwitch</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>off2</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>, <decl><type ref="prev"/><name>caseExprOff</name></decl>, <decl><type ref="prev"/><name>todo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>lval</name></decl>, *<decl><type ref="prev"/><name>rval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cx</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>jp</name> = <name><name>ss</name>-&gt;<name>printer</name></name></expr>;</expr_stmt>

    <comment type="block">/* JSOP_CONDSWITCH doesn't pop, unlike JSOP_{LOOKUP,TABLE}SWITCH. */</comment>
    <expr_stmt><expr><name>off</name> = <name>isCondSwitch</name> ? <call><name>GetOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr></argument>)</argument_list></call> : <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tswitch (%s) {\n"</expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>tableLength</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>diff</name> = <name><name>table</name><index>[<expr>0</expr>]</index></name>.<name>offset</name> - <name>defaultOffset</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>diff</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s:\n"</expr></argument>, <argument><expr><name>js_default_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name> + <name>defaultOffset</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>caseExprOff</name> = <name>isCondSwitch</name> ? <name>JSOP_CONDSWITCH_LENGTH</name> : 0</expr>;</expr_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>tableLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>off</name> = <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>offset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>off2</name> = (<name>i</name> + 1 &lt; <name>tableLength</name>) ? <name><name>table</name><index>[<expr><name>i</name> + 1</expr>]</index></name>.<name>offset</name> : <name>switchLength</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>key</name> = <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>isCondSwitch</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nextCaseExprOff</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * key encodes the JSOP_CASE bytecode's offset from switchtop.
                 * The next case expression follows immediately, unless we are
                 * at the last case.
                 */</comment>
                <expr_stmt><expr><name>nextCaseExprOff</name> = (<name>ptrdiff_t</name>)<call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nextCaseExprOff</name> += <name><name>js_CodeSpec</name><index>[<expr><name><name>pc</name><index>[<expr><name>nextCaseExprOff</name></expr>]</index></name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name> + <name>caseExprOff</name></expr></argument>,
                               <argument><expr><name>nextCaseExprOff</name> - <name>caseExprOff</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>caseExprOff</name> = <name>nextCaseExprOff</name></expr>;</expr_stmt>

                <comment type="block">/* Balance the stack as if this JSOP_CASE matched. */</comment>
                <expr_stmt><expr>--<name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="block">/*
                 * key comes from an atom, not the decompiler, so we need to
                 * quote it if it's a string literal.  But if table[i].label
                 * is non-null, key was constant-propagated and label is the
                 * name of the const we should show as the case label.  We set
                 * key to undefined so this identifier is escaped, if required
                 * by non-ASCII characters, but not quoted, by QuoteString.
                 */</comment>
                <expr_stmt><expr><name>todo</name> = -1</expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>label</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>key</name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSOp</name></type> <name>junk</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>todo</name> = <call><name>SprintDoubleValue</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>str</name> = <name>NULL</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></else></if></else></if>
                <if>if <condition>(<expr><name>todo</name> &gt;= 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call>(<name>jschar</name>)
                                       <argument_list>(<argument><expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> ? '"' : 0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></else></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tcase %s:\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>off</name> &lt;= <name>defaultOffset</name> &amp;&amp; <name>defaultOffset</name> &lt; <name>off2</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>diff</name> = <name>defaultOffset</name> - <name>off</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>diff</name> != 0</expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name> + <name>off</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>off</name> = <name>defaultOffset</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 2</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s:\n"</expr></argument>, <argument><expr><name>js_default_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name> + <name>off</name></expr></argument>, <argument><expr><name>off2</name> - <name>off</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>

            <comment type="block">/* Re-balance as if last JSOP_CASE or JSOP_DEFAULT mismatched. */</comment>
            <if>if <condition>(<expr><name>isCondSwitch</name></expr>)</condition><then>
                <expr_stmt><expr>++<name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></then></if>

    <if>if <condition>(<expr><name>defaultOffset</name> == <name>switchLength</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 2</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s:;\n"</expr></argument>, <argument><expr><name>js_default_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 2</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* By the end of a JSOP_CONDSWITCH, the discriminant has been popped. */</comment>
    <if>if <condition>(<expr><name>isCondSwitch</name></expr>)</condition><then>
        <expr_stmt><expr>--<name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ASSERT_RV</name><parameter_list>(<param><type><name>expr</name></type></param>, <param><type><name>rv</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JS_ASSERT(expr);                                                      \
        if (!(expr)) return (rv);                                             \
    JS_END_MACRO</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSAtom</name> *</type>
<name>GetSlotAtom</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>argument</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>name</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fun</name> = <name><name>jp</name>-&gt;<name>fun</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCAL_ASSERT_RV</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCAL_ASSERT_RV</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>localNames</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argument</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOCAL_ASSERT_RV</name><argument_list>(<argument><expr><name>slot</name> &lt; <name><name>fun</name>-&gt;<name>nargs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>LOCAL_ASSERT_RV</name><argument_list>(<argument><expr><name>slot</name> &lt; <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nvars</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> += <name><name>fun</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>name</name> = <call><name>JS_LOCAL_NAME_TO_ATOM</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>localNames</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
    <expr_stmt><expr><call><name>LOCAL_ASSERT_RV</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>name</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>GetLocal</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsint</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsatomid</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rval</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ASSERT</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>LOCAL_ASSERT_RV(expr, "")</cpp:value></cpp:define>

    <expr_stmt><expr><name>off</name> = <name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>off</name> &gt;= 0</expr>)</condition><then>
        <return>return <expr><call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/*
     * We must be called from js_DecompileValueGenerator (via Decompile) when
     * dereferencing a local that's undefined or null. Search script-&gt;objects
     * for the block containing this local by its stack index, i.
     */</comment>
    <expr_stmt><expr><name>cx</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>script</name> = <name><name>ss</name>-&gt;<name>printer</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>script</name>-&gt;<name>objectsOffset</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>, <expr><name>n</name> = <call><name>JS_SCRIPT_OBJECTS</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call>-&gt;<name>length</name></expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>JS_GET_SCRIPT_OBJECT</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_BlockClass</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>depth</name> = <call><name>OBJ_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call>(<name>jsuint</name>)<argument_list>(<argument><expr><name>i</name> - <name>depth</name></expr></argument>)</argument_list></call> &lt; (<name>jsuint</name>)<name>count</name></expr>)</condition><then>
                <break>break;</break></then></if>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>j</name> &lt; <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> -= <name>depth</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>sprop</name> = <call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>lastProp</name></expr>;</init> <condition><expr><name>sprop</name></expr>;</condition> <incr><expr><name>sprop</name> = <name><name>sprop</name>-&gt;<name>parent</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>sprop</name>-&gt;<name>shortid</name></name> == <name>i</name></expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>sprop</name> &amp;&amp; <call><name>JSID_IS_ATOM</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>atom</name> = <call><name>JSID_TO_ATOM</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rval</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOCAL_ASSERT</name></cpp:undef>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ASSERT</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>LOCAL_ASSERT_RV(expr, NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_OP_DATA</name><parameter_list>(<param><type><name>pc</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>(oplen = (cs = &amp;js_CodeSpec[op=(JSOp)*pc])-&gt;length)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>DecompileDestructuring</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>endpc</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>DecompileDestructuringLHS</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>endpc</name></decl></param>,
                          <param><decl><type><name>JSBool</name> *</type><name>hole</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oplen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lval</name></decl>, *<decl><type ref="prev"/><name>xval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>todo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>hole</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cx</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>jp</name> = <name><name>ss</name>-&gt;<name>printer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>JSOP_POP</name></expr>:
        <expr_stmt><expr>*<name>hole</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_DUP</name></expr>:
        <expr_stmt><expr><name>pc</name> = <call><name>DecompileDestructuring</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lval</name> = <call><name>PopStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_POPN</name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>JSOP_SETARG</name></expr>:
      </case><case>case <expr><name>JSOP_SETVAR</name></expr>:
      </case><case>case <expr><name>JSOP_SETGVAR</name></expr>:
      </case><case>case <expr><name>JSOP_SETLOCAL</name></expr>:
        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><name>oplen</name></expr>]</index></name> == <name>JSOP_POP</name> || <name><name>pc</name><index>[<expr><name>oplen</name></expr>]</index></name> == <name>JSOP_POPN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALL THROUGH */</comment>

      </case><case>case <expr><name>JSOP_SETLOCALPOP</name></expr>:
        <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lval</name> = <name>NULL</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETARG</name> || <name>op</name> == <name>JSOP_SETVAR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>op</name> == <name>JSOP_SETARG</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETGVAR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>GET_ATOM_FROM_BYTECODE</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>lval</name> = <call><name>GetLocal</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <if>if <condition>(<expr><name>atom</name></expr>)</condition><then>
            <expr_stmt><expr><name>lval</name> = <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> != <name>JSOP_SETLOCALPOP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
                <return>return <expr><name>pc</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>op</name> == <name>JSOP_POPN</name></expr>)</condition><then>
                <return>return <expr><name>pc</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

      </case><default>default:
        <comment type="block">/*
         * We may need to auto-parenthesize the left-most value decompiled
         * here, so add back PAREN_SLOP temporarily.  Then decompile until the
         * opcode that would reduce the stack depth to (ss-&gt;top-1), which we
         * pass to Decompile encoded as -(ss-&gt;top-1) - 1 or just -ss-&gt;top for
         * the nb parameter.
         */</comment>
        <expr_stmt><expr><name>todo</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name>todo</name> + <name>PAREN_SLOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> = <call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>-((<name>intN</name>)<name><name>ss</name>-&gt;<name>top</name></name>)</expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_ENUMELEM</name> || <name>op</name> == <name>JSOP_ENUMCONSTELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>xval</name> = <call><name>PopStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lval</name> = <call><name>PopStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_GETPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name>todo</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>lval</name> == '\0'</expr>)</condition><then> <block>{
            <comment type="block">/* lval is from JSOP_BINDNAME, so just print xval. */</comment>
            <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr>*<name>xval</name> == '\0'</expr>)</condition><then> <block>{
            <comment type="block">/* xval is from JSOP_SETCALL or JSOP_BINDXMLNAME, print lval. */</comment>
            <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                          <argument><expr>(<call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>+1</expr>]</index></name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                          ? "%s.%s"
                          : "%s[%s]"</expr></argument>,
                          <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <break>break;</break>
    </default>}</block></switch>

    <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>pc</name> &lt; <name>endpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
    <return>return <expr><name>pc</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Starting with a SRC_DESTRUCT-annotated JSOP_DUP, decompile a destructuring
 * left-hand side object or array initialiser, including nested destructuring
 * initialisers.  On successful return, the decompilation will be pushed on ss
 * and the return value will point to the POP or GROUP bytecode following the
 * destructuring expression.
 *
 * At any point, if pc is equal to endpc and would otherwise advance, we stop
 * immediately and return endpc.
 */</comment>
<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>DecompileDestructuring</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>endpc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>saveop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oplen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>lasti</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>hole</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_DUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> += <name>JSOP_DUP_LENGTH</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Set head so we can rewrite '[' to '{' as needed.  Back up PAREN_SLOP
     * chars so the destructuring decompilation accumulates contiguously in
     * ss-&gt;sprinter starting with "[".
     */</comment>
    <expr_stmt><expr><name>head</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"["</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>head</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> -= <name>PAREN_SLOP</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>head</name> == <name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call> == '['</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cx</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>jp</name> = <name><name>ss</name>-&gt;<name>printer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lasti</name> = -1</expr>;</expr_stmt>

    <while>while <condition>(<expr><name>pc</name> &lt; <name>endpc</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nameoff</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>saveop</name> = <name>op</name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
          <case>case <expr><name>JSOP_POP</name></expr>:
            <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>

          <comment type="block">/* Handle the optimized number-pushing opcodes. */</comment>
          </case><case>case <expr><name>JSOP_ZERO</name></expr>:   <expr_stmt><expr><name>d</name> = <name>i</name> = 0</expr>;</expr_stmt> <goto>goto <name>do_getelem</name>;</goto>
          </case><case>case <expr><name>JSOP_ONE</name></expr>:    <expr_stmt><expr><name>d</name> = <name>i</name> = 1</expr>;</expr_stmt> <goto>goto <name>do_getelem</name>;</goto>
          </case><case>case <expr><name>JSOP_UINT16</name></expr>: <expr_stmt><expr><name>d</name> = <name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <goto>goto <name>do_getelem</name>;</goto>
          </case><case>case <expr><name>JSOP_UINT24</name></expr>: <expr_stmt><expr><name>d</name> = <name>i</name> = <call><name>GET_UINT24</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <goto>goto <name>do_getelem</name>;</goto>
          </case><case>case <expr><name>JSOP_INT8</name></expr>:   <expr_stmt><expr><name>d</name> = <name>i</name> = <call><name>GET_INT8</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <goto>goto <name>do_getelem</name>;</goto>
          </case><case>case <expr><name>JSOP_INT32</name></expr>:  <expr_stmt><expr><name>d</name> = <name>i</name> = <call><name>GET_INT32</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <goto>goto <name>do_getelem</name>;</goto>

          </case><case>case <expr><name>JSOP_DOUBLE</name></expr>:
            <expr_stmt><expr><call><name>GET_ATOM_FROM_BYTECODE</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>d</name> = *<call><name>ATOM_TO_DOUBLE</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>JSDOUBLE_IS_FINITE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> = (<name>jsint</name>)<name>d</name></expr>;</expr_stmt>

          <label><name>do_getelem</name>:</label>
            <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
                <return>return <expr><name>pc</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_GETELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Distinguish object from array by opcode or source note. */</comment>
            <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_INITPROP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call> = '{'</expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%g: "</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <comment type="block">/* Sanity check for the gnarly control flow above. */</comment>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>i</name> == <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Fill in any holes (holes at the end don't matter). */</comment>
                <while>while <condition>(<expr>++<name>lasti</name> &lt; <name>i</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></while>
            }</block></else></if>
            <break>break;</break>

          </case><case>case <expr><name>JSOP_LENGTH</name></expr>:
            <expr_stmt><expr><name>atom</name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr>;</expr_stmt>
            <goto>goto <name>do_destructure_atom</name>;</goto>

          </case><case>case <expr><name>JSOP_CALLPROP</name></expr>:
          </case><case>case <expr><name>JSOP_GETPROP</name></expr>:
            <expr_stmt><expr><call><name>GET_ATOM_FROM_BYTECODE</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <label><name>do_destructure_atom</name>:</label>
            <expr_stmt><expr>*<call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call> = '{'</expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
            <expr_stmt><expr><name>nameoff</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr>!<call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
                             <argument><expr><call><name>js_IsIdentifier</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> ? 0 : (<name>jschar</name>)'\''</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>": "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>

          </case><default>default:
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>

        <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>

        <comment type="block">/*
         * Decompile the left-hand side expression whose bytecode starts at pc
         * and continues for a bounded number of bytecodes or stack operations
         * (and which in any event stops before endpc).
         */</comment>
        <expr_stmt><expr><name>pc</name> = <call><name>DecompileDestructuringLHS</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>, <argument><expr>&amp;<name>hole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
        <if>if <condition>(<expr><name>nameoff</name> &gt;= 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>initlen</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>offset</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> == '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>initlen</name> = <name>offset</name> - <name>nameoff</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>initlen</name> &gt;= 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Early check to rule out odd "name: lval" length. */</comment>
            <if>if <condition>(<expr>((<name>size_t</name>)<name>initlen</name> &amp; 1) == 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>size_t</name></type> <name>namelen</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Even "name: lval" string length: check for "x: x" and the
                 * like, and apply the shorthand if we can.
                 */</comment>
                <expr_stmt><expr><name>namelen</name> = <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>initlen</name> - 2</expr></argument>)</argument_list></call> &gt;&gt; 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>name</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>nameoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>name</name> + <name>namelen</name></expr></argument>, <argument><expr>": "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &amp;&amp;
                    !<call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name> + <name>namelen</name> + 2</expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>offset</name> -= <name>namelen</name> + 2</expr>;</expr_stmt>
                    <expr_stmt><expr>*<call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> = '\0'</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name>offset</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><name>pc</name> == <name>endpc</name> || *<name>pc</name> != <name>JSOP_DUP</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <comment type="block">/*
         * Check for SRC_DESTRUCT on this JSOP_DUP, which would mean another
         * destructuring initialiser abuts this one, and we should stop.  This
         * happens with source of the form '[a] = [b] = c'.
         */</comment>
        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_DESTRUCT</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <if>if <condition>(<expr>!<name>hole</name> &amp;&amp; <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <expr_stmt><expr><name>pc</name> += <name>JSOP_DUP_LENGTH</name></expr>;</expr_stmt>
    }</block></while>

<label><name>out</name>:</label>
    <expr_stmt><expr><name>lval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>(*<name>lval</name> == '[') ? "]" : "}"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><name>pc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>DecompileGroupAssignment</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>endpc</name></decl></param>,
                         <param><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl></param>, <param><decl><type><name>ptrdiff_t</name> *</type><name>todop</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oplen</name></decl>, <decl><type ref="prev"/><name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>todo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>hole</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rval</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_PUSH</name> || <name>op</name> == <name>JSOP_GETLOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s["</expr></argument>, <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> -= <name>PAREN_SLOP</name></expr>;</expr_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pc</name> = <call><name>DecompileDestructuringLHS</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>, <argument><expr>&amp;<name>hole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>pc</name> == <name>endpc</name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>LOAD_OP_DATA</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> != <name>JSOP_PUSH</name> &amp;&amp; <name>op</name> != <name>JSOP_GETLOCAL</name></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr>!<name>hole</name> &amp;&amp; <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_POPN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"] = ["</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>end</name> = <name><name>ss</name>-&gt;<name>top</name></name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> = <name>end</name> - <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name>start</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rval</name> = <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                   <argument><expr>(<name>i</name> == <name>start</name>) ? "%s" : ", %s"</expr></argument>,
                   <argument><expr>(<name>i</name> == <name>end</name> - 1 &amp;&amp; *<name>rval</name> == '\0') ? ", " : <name>rval</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"]"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>todop</name> = <name>todo</name></expr>;</expr_stmt>
    <return>return <expr><name>pc</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOCAL_ASSERT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOAD_OP_DATA</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DESTRUCTURING */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>InitSprintStack</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>depth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>offsetsz</name></decl>, <decl><type ref="prev"/><name>opcodesz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>space</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>INIT_SPRINTER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>PAREN_SLOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate the parallel (to avoid padding) offset and opcode stacks. */</comment>
    <expr_stmt><expr><name>offsetsz</name> = <name>depth</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>ptrdiff_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>opcodesz</name> = <name>depth</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE</name><argument_list>(<argument><expr><name>space</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>offsetsz</name> + <name>opcodesz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>space</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>offsets</name></name> = (<name>ptrdiff_t</name> *) <name>space</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>opcodes</name></name> = <call>(<name>jsbytecode</name> *) <argument_list>(<argument><expr>(<name>char</name> *)<name>space</name> + <name>offsetsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = <name><name>ss</name>-&gt;<name>inArrayInit</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>inGenExp</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name>-&gt;<name>printer</name></name> = <name>jp</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * If nb is non-negative, decompile nb bytecodes starting at pc.  Otherwise
 * the decompiler starts at pc and continues until it reaches an opcode for
 * which decompiling would result in the stack depth equaling -(nb + 1).
 *
 * The nextop parameter is either JSOP_NOP or the "next" opcode in order of
 * abstract interpretation (not necessarily physically next in a bytecode
 * vector). So nextop is JSOP_POP for the last operand in a comma expression,
 * or JSOP_AND for the right operand of &amp;&amp;.
 */</comment>
<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>Decompile</name><parameter_list>(<param><decl><type><name>SprintStack</name> *</type><name>ss</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>intN</name></type> <name>nb</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>nextop</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl>, *<decl><type ref="prev"/><name>jp2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>startpc</name></decl>, *<decl><type ref="prev"/><name>endpc</name></decl>, *<decl><type ref="prev"/><name>pc2</name></decl>, *<decl><type ref="prev"/><name>done</name></decl>, *<decl><type ref="prev"/><name>forelem_tail</name></decl>, *<decl><type ref="prev"/><name>forelem_done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>tail</name></decl>, <decl><type ref="prev"/><name>todo</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>oplen</name></decl>, <decl><type ref="prev"/><name>cond</name></decl>, <decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>lastop</name></decl>, <decl><type ref="prev"/><name>saveop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>, *<decl><type ref="prev"/><name>sn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lval</name></decl>, *<decl><type ref="prev"/><name>rval</name></decl>, *<decl><type ref="prev"/><name>xval</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>, *<decl><type ref="prev"/><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>foreach</name></decl>, <decl><type ref="prev"/><name>inXML</name></decl>, <decl><type ref="prev"/><name>quoteAttr</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inXML</name></cpp:macro> <cpp:value>JS_FALSE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>jsval</name></type> <name>val</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>exception_cookie</name><index>[]</index></name> <init>= <expr>"/*EXCEPTION*/"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>retsub_pc_cookie</name><index>[]</index></name> <init>= <expr>"/*RETSUB_PC*/"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>forelem_cookie</name><index>[]</index></name>   <init>= <expr>"/*FORELEM*/"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>with_cookie</name><index>[]</index></name>      <init>= <expr>"/*WITH*/"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dot_format</name><index>[]</index></name>       <init>= <expr>"%s.%s"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>index_format</name><index>[]</index></name>     <init>= <expr>"%s[%s]"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>predot_format</name><index>[]</index></name>    <init>= <expr>"%s%s.%s"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>postdot_format</name><index>[]</index></name>   <init>= <expr>"%s.%s%s"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>preindex_format</name><index>[]</index></name>  <init>= <expr>"%s%s[%s]"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>postindex_format</name><index>[]</index></name> <init>= <expr>"%s[%s]%s"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ss_format</name><index>[]</index></name>        <init>= <expr>"%s%s"</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Argument and variables decompilation uses the following to share code. */</comment>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ARGNO_LEN</name> == <name>VARNO_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Local macros
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECOMPILE_CODE</name><parameter_list>(<param><type><name>pc</name></type></param>,<param><type><name>nb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (!Decompile(ss, pc, nb, JSOP_NOP)) return NULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_OP</name><parameter_list>(<param><type><name>pc</name></type></param>)</parameter_list></cpp:macro>           <cpp:value>(((pc) + (len) == endpc) ? nextop : pc[len])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POP_STR</name><parameter_list>()</parameter_list></cpp:macro>             <cpp:value>PopStr(ss, op)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ASSERT</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>LOCAL_ASSERT_RV(expr, NULL)</cpp:value></cpp:define>

<comment type="block">/*
 * Callers know that ATOM_IS_STRING(atom), and we leave it to the optimizer to
 * common ATOM_TO_STRING(atom) here and near the call sites.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATOM_IS_IDENTIFIER</name><parameter_list>(<param><type><name>atom</name></type></param>)</parameter_list></cpp:macro> <cpp:value>js_IsIdentifier(ATOM_TO_STRING(atom))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATOM_IS_KEYWORD</name><parameter_list>(<param><type><name>atom</name></type></param>)</parameter_list></cpp:macro>                                                 \
    <cpp:value>(js_CheckKeyword(JSSTRING_CHARS(ATOM_TO_STRING(atom)),                    \
                     JSSTRING_LENGTH(ATOM_TO_STRING(atom))) != TOK_EOF)</cpp:value></cpp:define>

<comment type="block">/*
 * Given an atom already fetched from jp-&gt;script's atom map, quote/escape its
 * string appropriately into rval, and select fmt from the quoted and unquoted
 * alternatives.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_QUOTE_AND_FMT</name><parameter_list>(<param><type><name>qfmt</name></type></param>, <param><type><name>ufmt</name></type></param>, <param><type><name>rval</name></type></param>)</parameter_list></cpp:macro>                                   \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        jschar quote_;                                                        \
        if (!ATOM_IS_IDENTIFIER(atom)) {                                      \
            quote_ = '\'';                                                    \
            fmt = qfmt;                                                       \
        } else {                                                              \
            quote_ = 0;                                                       \
            fmt = ufmt;                                                       \
        }                                                                     \
        rval = QuoteString(&amp;ss-&gt;sprinter, ATOM_TO_STRING(atom), quote_);      \
        if (!rval)                                                            \
            return NULL;                                                      \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_ATOM</name><parameter_list>(<param><type><name>PCOFF</name></type></param>)</parameter_list></cpp:macro>                                                      \
    <cpp:value>GET_ATOM_FROM_BYTECODE(jp-&gt;script, pc, PCOFF, atom)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_OBJECT</name><parameter_list>(<param><type><name>PCOFF</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>GET_OBJECT_FROM_BYTECODE(jp-&gt;script, pc, PCOFF, obj)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_FUNCTION</name><parameter_list>(<param><type><name>PCOFF</name></type></param>)</parameter_list></cpp:macro>                                                  \
    <cpp:value>GET_FUNCTION_FROM_BYTECODE(jp-&gt;script, pc, PCOFF, obj)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_REGEXP</name><parameter_list>(<param><type><name>PCOFF</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>GET_REGEXP_FROM_BYTECODE(jp-&gt;script, pc, PCOFF, obj)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SOURCE_NOTE_ATOM</name><parameter_list>(<param><type><name>sn</name></type></param>, <param><type><name>atom</name></type></param>)</parameter_list></cpp:macro>                                        \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        jsatomid atomIndex_ = (jsatomid) js_GetSrcNoteOffset((sn), 0);        \
                                                                              \
        LOCAL_ASSERT(atomIndex_ &lt; jp-&gt;script-&gt;atomMap.length);                \
        (atom) = jp-&gt;script-&gt;atomMap.vector[atomIndex_];                      \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/*
 * Get atom from jp-&gt;script's atom map, quote/escape its string appropriately
 * into rval, and select fmt from the quoted and unquoted alternatives.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ATOM_QUOTE_AND_FMT</name><parameter_list>(<param><type><name>qfmt</name></type></param>, <param><type><name>ufmt</name></type></param>, <param><type><name>rval</name></type></param>)</parameter_list></cpp:macro>                              \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        LOAD_ATOM(0);                                                         \
        GET_QUOTE_AND_FMT(qfmt, ufmt, rval);                                  \
    JS_END_MACRO</cpp:value></cpp:define>

    <expr_stmt><expr><name>cx</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return NULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>jp</name> = <name><name>ss</name>-&gt;<name>printer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>startpc</name> = <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endpc</name> = (<name>nb</name> &lt; 0) ? <name><name>jp</name>-&gt;<name>script</name>-&gt;<name>code</name></name> + <name><name>jp</name>-&gt;<name>script</name>-&gt;<name>length</name></name> : <name>pc</name> + <name>nb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>forelem_tail</name> = <name>forelem_done</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>                  <comment type="block">/* NB: different from Sprint() error return. */</comment>
    <expr_stmt><expr><name>saveop</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sn</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rval</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <expr_stmt><expr><name>foreach</name> = <name>inXML</name> = <name>quoteAttr</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while <condition>(<expr><name>nb</name> &lt; 0 || <name>pc</name> &lt; <name>endpc</name></expr>)</condition> <block>{
        <comment type="block">/*
         * Move saveop to lastop so prefixed bytecodes can take special action
         * while sharing maximal code.  Set op and saveop to the new bytecode,
         * use op in POP_STR to trigger automatic parenthesization, but push
         * saveop at the bottom of the loop if this op pushes.  Thus op may be
         * set to nop or otherwise mutated to suppress auto-parens.
         */</comment>
        <expr_stmt><expr><name>lastop</name> = <name>saveop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INDEXBASE</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * The decompiler uses js_GetIndexFromBytecode to get atoms and
             * objects and ignores these suffix/prefix bytecodes, thus
             * simplifying code that must process JSOP_GETTER/JSOP_SETTER
             * prefixes.
             */</comment>
            <expr_stmt><expr><name>pc</name> += <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pc</name> &gt;= <name>endpc</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>saveop</name> = <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = <name>oplen</name> = <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>nb</name> &lt; 0 &amp;&amp; -(<name>nb</name> + 1) == (<name>intN</name>)<name><name>ss</name>-&gt;<name>top</name></name> - <name><name>cs</name>-&gt;<name>nuses</name></name> + <name><name>cs</name>-&gt;<name>ndefs</name></name></expr>)</condition><then>
            <return>return <expr><name>pc</name></expr>;</return></then></if>

        <comment type="block">/*
         * Save source literal associated with JS now before the following
         * rewrite changes op. See bug 380197.
         */</comment>
        <expr_stmt><expr><name>token</name> = <name><name>CodeToken</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>pc</name> + <name>oplen</name> == <name><name>jp</name>-&gt;<name>dvgfence</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32</name></type> <name>format</name></decl>, <decl><type ref="prev"/><name>mode</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Rewrite non-get ops to their "get" format if the error is in
             * the bytecode at pc, so we don't decompile more than the error
             * expression.
             */</comment>
            <for>for (<init><expr><name>fp</name> = <name><name>cx</name>-&gt;<name>fp</name></name></expr>;</init> <condition><expr><name>fp</name> &amp;&amp; !<name><name>fp</name>-&gt;<name>script</name></name></expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>)
                <continue>continue;</continue></for>
            <expr_stmt><expr><name>format</name> = <name><name>cs</name>-&gt;<name>format</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>((<name>fp</name> &amp;&amp; <name>pc</name> == <name><name>fp</name>-&gt;<name>pc</name></name>) ||
                 (<name>pc</name> == <name>startpc</name> &amp;&amp; <name><name>cs</name>-&gt;<name>nuses</name></name> != 0)) &amp;&amp;
                <name>format</name> &amp; (<name>JOF_SET</name>|<name>JOF_DEL</name>|<name>JOF_INCDEC</name>|<name>JOF_IMPORT</name>|<name>JOF_FOR</name>|
                          <name>JOF_VARPROP</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>mode</name> = <call><name>JOF_MODE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>mode</name> == <name>JOF_NAME</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * JOF_NAME does not imply JOF_ATOM, so we must check for
                     * the QARG and QVAR format types, and translate those to
                     * JSOP_GETARG or JSOP_GETVAR appropriately, instead of to
                     * JSOP_NAME.
                     */</comment>
                    <expr_stmt><expr><name>type</name> = <call><name>JOF_TYPE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = (<name>type</name> == <name>JOF_QARG</name>)
                         ? <name>JSOP_GETARG</name>
                         : (<name>type</name> == <name>JOF_QVAR</name>)
                         ? <name>JSOP_GETVAR</name>
                         : (<name>type</name> == <name>JOF_LOCAL</name>)
                         ? <name>JSOP_GETLOCAL</name>
                         : <name>JSOP_NAME</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>i</name> = <name><name>cs</name>-&gt;<name>nuses</name></name> - <name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>nuses</name></expr>;</expr_stmt>
                    <while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition>
                        <expr_stmt><expr><call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
                }</block></then> <else>else <block>{
                    <comment type="block">/*
                     * We must replace the faulting pc's bytecode with a
                     * corresponding JSOP_GET* code.  For JSOP_SET{PROP,ELEM},
                     * we must use the "2nd" form of JSOP_GET{PROP,ELEM}, to
                     * throw away the assignment op's right-hand operand and
                     * decompile it as if it were a GET of its left-hand
                     * operand.
                     */</comment>
                    <if>if <condition>(<expr><name>mode</name> == <name>JOF_PROP</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>op</name> = <call>(<name>JSOp</name>) <argument_list>(<argument><expr>(<name>format</name> &amp; <name>JOF_SET</name>)
                                     ? <name>JSOP_GETPROP2</name>
                                     : <name>JSOP_GETPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <if>if <condition>(<expr><name>mode</name> == <name>JOF_ELEM</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>op</name> = <call>(<name>JSOp</name>) <argument_list>(<argument><expr>(<name>format</name> &amp; <name>JOF_SET</name>)
                                     ? <name>JSOP_GETELEM2</name>
                                     : <name>JSOP_GETELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <comment type="block">/*
                         * Zero mode means precisely that op is uncategorized
                         * for our purposes, so we must write per-op special
                         * case code here.
                         */</comment>
                        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
                          <case>case <expr><name>JSOP_ENUMELEM</name></expr>:
                          </case><case>case <expr><name>JSOP_ENUMCONSTELEM</name></expr>:
                            <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                            <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
                          </case><case>case <expr><name>JSOP_SETCALL</name></expr>:
                            <expr_stmt><expr><name>op</name> = <name>JSOP_CALL</name></expr>;</expr_stmt>
                            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                          </case><case>case <expr><name>JSOP_GETARGPROP</name></expr>:
                            <expr_stmt><expr><name>op</name> = <name>JSOP_GETARG</name></expr>;</expr_stmt>
                            <break>break;</break>
                          </case><case>case <expr><name>JSOP_GETVARPROP</name></expr>:
                            <expr_stmt><expr><name>op</name> = <name>JSOP_GETVAR</name></expr>;</expr_stmt>
                            <break>break;</break>
                          </case><case>case <expr><name>JSOP_GETLOCALPROP</name></expr>:
                            <expr_stmt><expr><name>op</name> = <name>JSOP_GETLOCAL</name></expr>;</expr_stmt>
                            <break>break;</break>
                          </case><default>default:
                            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </default>}</block></switch>
                    }</block></else></if></else></if>
                }</block></else></if>
            }</block></then></if>

            <expr_stmt><expr><name>saveop</name> = <name>op</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>op</name> &gt;= <name>JSOP_LIMIT</name></expr>)</condition><then> <block>{
                <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
                  <case>case <expr><name>JSOP_GETPROP2</name></expr>:
                    <expr_stmt><expr><name>saveop</name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                    <break>break;</break>
                  </case><case>case <expr><name>JSOP_GETELEM2</name></expr>:
                    <expr_stmt><expr><name>saveop</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                    <break>break;</break>
                  </case><default>default:<empty_stmt>;</empty_stmt>
                </default>}</block></switch>
            }</block></then></if>
            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>js_CodeSpec</name><index>[<expr><name>saveop</name></expr>]</index></name>.<name>length</name> == <name>oplen</name> ||
                         <call><name>JOF_TYPE</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> == <name>JOF_SLOTATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>jp</name>-&gt;<name>dvgfence</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>token</name></expr>)</condition><then> <block>{
            <switch>switch <condition>(<expr><name><name>cs</name>-&gt;<name>nuses</name></name></expr>)</condition> <block>{
              <case>case <expr>2</expr>:
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_ASSIGNOP</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Avoid over-parenthesizing y in x op= y based on its
                     * expansion: x = x op y (replace y by z = w to see the
                     * problem).
                     */</comment>
                    <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) <name><name>pc</name><index>[<expr><name>oplen</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> != <name>saveop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> != <name>saveop</name></expr>)</condition><then> <block>{
                    <comment type="block">/* Print only the right operand of the assignment-op. */</comment>
                    <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = <name>saveop</name></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr>!<name>inXML</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s %s"</expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="block">/* In XML, just concatenate the two operands. */</comment>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if></else></if>
                <break>break;</break>

              </case><case>case <expr>1</expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr>0</expr>:
                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><default>default:
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
            </default>}</block></switch>
        }</block></then> <else>else <block>{
            <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
              <case>case <expr><name>JSOP_NOP</name></expr>:
                <comment type="block">/*
                 * Check for a do-while loop, a for-loop with an empty
                 * initializer part, a labeled statement, a function
                 * definition, or try/finally.
                 */</comment>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>sn</name> ? <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> : <name>SRC_NULL</name></expr>)</condition> <block>{
                  <case>case <expr><name>SRC_WHILE</name></expr>:
                    <expr_stmt><expr>++<name>pc</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tail</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><name>tail</name></expr>]</index></name> == <name>JSOP_IFNE</name> ||
                                 <name><name>pc</name><index>[<expr><name>tail</name></expr>]</index></name> == <name>JSOP_IFNEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tdo {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t} while (%s);\n"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <name>tail</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_FOR</name></expr>:
                    <expr_stmt><expr><name>rval</name> = ""</expr>;</expr_stmt>

                  <label><name>do_forloop</name>:</label>
                    <comment type="block">/* Skip the JSOP_NOP or JSOP_POP bytecode. */</comment>
                    <expr_stmt><expr><name>pc</name>++</expr>;</expr_stmt>

                    <comment type="block">/* Get the cond, next, and loop-closing tail offsets. */</comment>
                    <expr_stmt><expr><name>cond</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>next</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tail</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>tail</name> + <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name>+<name>tail</name></expr></argument>, <argument><expr><name>pc</name>+<name>tail</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Print the keyword and the possibly empty init-part. */</comment>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tfor (%s;"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>cond</name></expr>]</index></name> == <name>JSOP_IFEQ</name> || <name><name>pc</name><index>[<expr><name>cond</name></expr>]</index></name> == <name>JSOP_IFEQX</name></expr>)</condition><then> <block>{
                        <comment type="block">/* Decompile the loop condition. */</comment>
                        <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>" %s"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="block">/* Need a semicolon whether or not there was a cond. */</comment>
                    <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>";"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>next</name></expr>]</index></name> != <name>JSOP_GOTO</name> &amp;&amp; <name><name>pc</name><index>[<expr><name>next</name></expr>]</index></name> != <name>JSOP_GOTOX</name></expr>)</condition><then> <block>{
                        <comment type="block">/* Decompile the loop updater. */</comment>
                        <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>next</name></expr></argument>, <argument><expr><name>tail</name> - <name>next</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>" %s"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="block">/* Do the loop body. */</comment>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>") {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><name>oplen</name> = (<name>cond</name>) ? <name><name>js_CodeSpec</name><index>[<expr><name><name>pc</name><index>[<expr><name>cond</name></expr>]</index></name></expr>]</index></name>.<name>length</name> : 0</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>cond</name> + <name>oplen</name></expr></argument>, <argument><expr><name>next</name> - <name>cond</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Set len so pc skips over the entire loop. */</comment>
                    <expr_stmt><expr><name>len</name> = <name>tail</name> + <name><name>js_CodeSpec</name><index>[<expr><name><name>pc</name><index>[<expr><name>tail</name></expr>]</index></name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_LABEL</name></expr>:
                    <expr_stmt><expr><call><name>GET_SOURCE_NOTE_ATOM</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s:\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_LABELBRACE</name></expr>:
                    <expr_stmt><expr><call><name>GET_SOURCE_NOTE_ATOM</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s: {\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_ENDBRACE</name></expr>:
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_FUNCDEF</name></expr>:
                    <expr_stmt><expr><call><name>JS_GET_SCRIPT_OBJECT</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <label><name>do_function</name>:</label>
                    <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fun</name> = <call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>jp2</name> = <call><name>JS_NEW_PRINTER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"nested_function"</expr></argument>, <argument><expr><name>fun</name></expr></argument>,
                                         <argument><expr><name><name>jp</name>-&gt;<name>indent</name></name></expr></argument>, <argument><expr><name><name>jp</name>-&gt;<name>pretty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>jp2</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>ok</name> = <call><name>js_DecompileFunction</name><argument_list>(<argument><expr><name>jp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name><name>jp2</name>-&gt;<name>sprinter</name>.<name>base</name></name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name><name>jp2</name>-&gt;<name>sprinter</name>.<name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name>js_DestroyPrinter</name><argument_list>(<argument><expr><name>jp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_BRACE</name></expr>:
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t{\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>len</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><default>default:<empty_stmt>;</empty_stmt>
                </default>}</block></switch>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GROUP</name></expr>:
                <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>lastop</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<name><name>cs</name>-&gt;<name>prec</name></name> != 0 &amp;&amp;
                     <name><name>cs</name>-&gt;<name>prec</name></name> &lt;= <name><name>js_CodeSpec</name><index>[<expr><call><name>NEXT_OP</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>prec</name>) ||
                    <name><name>pc</name><index>[<expr><name>JSOP_GROUP_LENGTH</name></expr>]</index></name> == <name>JSOP_NULL</name> ||
                    <name><name>pc</name><index>[<expr><name>JSOP_GROUP_LENGTH</name></expr>]</index></name> == <name>JSOP_DUP</name> ||
                    <name><name>pc</name><index>[<expr><name>JSOP_GROUP_LENGTH</name></expr>]</index></name> == <name>JSOP_IFEQ</name> ||
                    <name><name>pc</name><index>[<expr><name>JSOP_GROUP_LENGTH</name></expr>]</index></name> == <name>JSOP_IFNE</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Force parens if this JSOP_GROUP forced re-association
                     * against precedence, or if this is a call or constructor
                     * expression, or if it is destructured (JSOP_DUP), or if
                     * it is an if or loop condition test.
                     *
                     * This is necessary to handle the operator new grammar,
                     * by which new x(y).z means (new x(y))).z.  For example
                     * new (x(y).z) must decompile with the constructor
                     * parenthesized, but normal precedence has JSOP_GETPROP
                     * (for the final .z) higher than JSOP_NEW.  In general,
                     * if the call or constructor expression is parenthesized,
                     * we preserve parens.
                     */</comment>
                    <expr_stmt><expr><name>op</name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="block">/*
                     * Don't explicitly parenthesize -- just fix the top
                     * opcode so that the auto-parens magic in PopOff can do
                     * its thing.
                     */</comment>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>top</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name> = <name>saveop</name> = <name>lastop</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_PUSH</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_GROUPASSIGN</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pc</name> = <call><name>DecompileGroupAssignment</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr>&amp;<name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_POPN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <name>oplen</name> = <name>JSOP_POPN_LENGTH</name></expr>;</expr_stmt>
                    <goto>goto <name>end_groupassignment</name>;</goto>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_BINDNAME</name></expr>:
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_TRY</name></expr>:
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\ttry {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_FINALLY</name></expr>:
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t} finally {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>

                <comment type="block">/*
                 * We push push the pair of exception/restsub cookies to
                 * simulate the effects [gosub] or control transfer during
                 * exception capturing on the stack.
                 */</comment>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>retsub_pc_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_RETSUB</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>retsub_pc_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_SWAP</name></expr>:
                <comment type="block">/*
                 * We don't generate this opcode currently, and previously we
                 * did not need to decompile it.  If old, serialized bytecode
                 * uses it still, we should fall through and set todo = -2.
                 */</comment>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_GOSUB</name></expr>:
              </case><case>case <expr><name>JSOP_GOSUBX</name></expr>:
                <comment type="block">/*
                 * JSOP_GOSUB and GOSUBX have no effect on the decompiler's
                 * string stack because the next op in bytecode order finds
                 * the stack balanced by a JSOP_RETSUB executed elsewhere.
                 */</comment>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_POPN</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>uintN</name></type> <name>newtop</name></decl>, <decl><type ref="prev"/><name>oldtop</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * The compiler models operand stack depth and fixes the stack
                 * pointer on entry to a catch clause based on its depth model.
                 * The decompiler must match the code generator's model, which
                 * is why JSOP_FINALLY pushes a cookie that JSOP_RETSUB pops.
                 */</comment>
                <expr_stmt><expr><name>oldtop</name> = <name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>newtop</name> = <name>oldtop</name> - <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>newtop</name> &lt;= <name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>

                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr>)</condition><then>
                    <break>break;</break></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_GROUPASSIGN</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s[] = ["</expr></argument>,
                                  <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <for>for (<init><expr><name>i</name> = <name>newtop</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>oldtop</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><name>rval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                                   <argument><expr>(<name>i</name> == <name>newtop</name>) ? "" : ", "</expr></argument>,
                                   <argument><expr>(<name>i</name> == <name>oldtop</name> - 1 &amp;&amp; *<name>rval</name> == '\0')
                                   ? ", " : <name>rval</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                            <return>return <expr><name>NULL</name></expr>;</return>
                        }</block></then></if>
                    }</block></for>
                    <if>if <condition>(<expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"]"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>

                    <comment type="block">/*
                     * Kill newtop before the end_groupassignment: label by
                     * retracting/popping early.  Control will either jump to
                     * do_forloop: or do_letheadbody: or else break from our
                     * case JSOP_POPN: after the switch (*pc2) below.
                     */</comment>
                    <if>if <condition>(<expr><name>newtop</name> &lt; <name>oldtop</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <call><name>GetOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>newtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = <name>newtop</name></expr>;</expr_stmt>
                    }</block></then></if>

                  <label><name>end_groupassignment</name>:</label>
                    <comment type="block">/*
                     * Thread directly to the next opcode if we can, to handle
                     * the special cases of a group assignment in the first or
                     * last part of a for(;;) loop head, or in a let block or
                     * expression head.
                     *
                     * NB: todo at this point indexes space in ss-&gt;sprinter
                     * that is liable to be overwritten.  The code below knows
                     * exactly how long rval lives, or else copies it down via
                     * SprintCString.
                     */</comment>
                    <expr_stmt><expr><name>rval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc2</name> = <name>pc</name> + <name>oplen</name></expr>;</expr_stmt>
                    <switch>switch <condition>(<expr>*<name>pc2</name></expr>)</condition> <block>{
                      <case>case <expr><name>JSOP_NOP</name></expr>:
                        <comment type="block">/* First part of for(;;) or let block/expr head. */</comment>
                        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>sn</name></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_FOR</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>pc</name> = <name>pc2</name></expr>;</expr_stmt>
                                <goto>goto <name>do_forloop</name>;</goto>
                            }</block></then></if>
                            <if>if <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_DECL</name></expr>)</condition><then> <block>{
                                <if>if <condition>(<expr><name><name>ss</name>-&gt;<name>top</name></name> == <name><name>jp</name>-&gt;<name>script</name>-&gt;<name>depth</name></name></expr>)</condition><then> <block>{
                                    <comment type="block">/*
                                     * This must be an empty destructuring
                                     * in the head of a let whose body block
                                     * is also empty.
                                     */</comment>
                                    <expr_stmt><expr><name>pc</name> = <name>pc2</name> + 1</expr>;</expr_stmt>
                                    <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><name>len</name></expr>]</index></name> == <name>JSOP_LEAVEBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tlet (%s) {\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <goto>goto <name>end_popn</name>;</goto>
                                }</block></then></if>
                                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                                <expr_stmt><expr><name>op</name> = <name>JSOP_POP</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>pc</name> = <name>pc2</name> + 1</expr>;</expr_stmt>
                                <goto>goto <name>do_letheadbody</name>;</goto>
                            }</block></then></if>
                        }</block></then></if>
                        <break>break;</break>

                      </case><case>case <expr><name>JSOP_GOTO</name></expr>:
                      </case><case>case <expr><name>JSOP_GOTOX</name></expr>:
                        <comment type="block">/* Third part of for(;;) loop head. */</comment>
                        <expr_stmt><expr><name>cond</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc2</name> + <name>cond</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_FOR</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>saveop</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
                        }</block></then></if>
                        <break>break;</break>
                    </case>}</block></switch>

                    <comment type="block">/*
                     * If control flow reaches this point with todo still -2,
                     * just print rval as an expression statement.
                     */</comment>
                    <if>if <condition>(<expr><name>todo</name> == -2</expr>)</condition><then>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s;\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                  <label><name>end_popn</name>:</label>
                    <break>break;</break>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if>if <condition>(<expr><name>newtop</name> &lt; <name>oldtop</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <call><name>GetOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>newtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = <name>newtop</name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_EXCEPTION</name></expr>:
                <comment type="block">/* The catch decompiler handles this op itself. */</comment>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_POP</name></expr>:
                <comment type="block">/*
                 * By default, do not automatically parenthesize when popping
                 * a stacked expression decompilation.  We auto-parenthesize
                 * only when JSOP_POP is annotated with SRC_PCDELTA, meaning
                 * comma operator.
                 */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_POPV</name></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_POPV</name></expr>:
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>sn</name> ? <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> : <name>SRC_NULL</name></expr>)</condition> <block>{
                  <case>case <expr><name>SRC_FOR</name></expr>:
                    <comment type="block">/* Force parens around 'in' expression at 'for' front. */</comment>
                    <if>if <condition>(<expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name> == <name>JSOP_IN</name></expr>)</condition><then>
                        <expr_stmt><expr><name>op</name> = <name>JSOP_LSH</name></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <goto>goto <name>do_forloop</name>;</goto>

                  </case><case>case <expr><name>SRC_PCDELTA</name></expr>:
                    <comment type="block">/* Comma operator: use JSOP_POP for correct precedence. */</comment>
                    <expr_stmt><expr><name>op</name> = <name>JSOP_POP</name></expr>;</expr_stmt>

                    <comment type="block">/* Pop and save to avoid blowing stack depth budget. */</comment>
                    <expr_stmt><expr><name>lval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>

                    <comment type="block">/*
                     * The offset tells distance to the end of the right-hand
                     * operand of the comma operator.
                     */</comment>
                    <expr_stmt><expr><name>done</name> = <name>pc</name> + <name>len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>

                    <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>done</name></expr></argument>, <argument><expr><name>pc</name> - <name>done</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>NULL</name></expr>;</return>
                    }</block></then></if>

                    <comment type="block">/* Pop Decompile result and print comma expression. */</comment>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s, %s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_HIDDEN</name></expr>:
                    <comment type="block">/* Hide this pop, it's from a goto in a with or for/in. */</comment>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_DECL</name></expr>:
                    <comment type="block">/* This pop is at the end of the let block/expr head. */</comment>
                    <expr_stmt><expr><name>pc</name> += <name>JSOP_POP_LENGTH</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                  <label><name>do_letheadbody</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>len</name></expr>]</index></name> == <name>JSOP_LEAVEBLOCK</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tlet (%s) {\n"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><name>len</name></expr>]</index></name> == <name>JSOP_LEAVEBLOCKEXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>lval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                            <return>return <expr><name>NULL</name></expr>;</return></then></if>

                        <comment type="block">/* Set saveop to reflect what we will push. */</comment>
                        <expr_stmt><expr><name>saveop</name> = <name>JSOP_LEAVEBLOCKEXPR</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>saveop</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>NULL</name></expr>;</return>
                        }</block></then></if>
                        <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                                      <argument><expr>(*<name>rval</name> == '{')
                                      ? "let (%s) (%s)"
                                      : "let (%s) %s"</expr></argument>,
                                      <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>

                  </case><default>default:
                    <comment type="block">/* Turn off parens around a yield statement. */</comment>
                    <if>if <condition>(<expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name> == <name>JSOP_YIELD</name></expr>)</condition><then>
                        <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt></then></if>

                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Don't emit decompiler-pushed strings that are not
                     * handled by other opcodes. They are pushed onto the
                     * stack to help model the interpreter stack and should
                     * not appear in the decompiler's output.
                     */</comment>
                    <if>if <condition>(<expr>*<name>rval</name> != '\0' &amp;&amp; (<name><name>rval</name><index>[<expr>0</expr>]</index></name> != '/' || <name><name>rval</name><index>[<expr>1</expr>]</index></name> != '*')</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>,
                                  <argument><expr>(*<name>rval</name> == '{' ||
                                   (<call><name>strncmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>js_function_str</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0 &amp;&amp;
                                    <name><name>rval</name><index>[<expr>8</expr>]</index></name> == ' '))
                                  ? "\t(%s);\n"
                                  : "\t%s;\n"</expr></argument>,
                                  <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>rval</name> == '\0' ||
                                     <call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <break>break;</break>
                </default>}</block></switch>
                <expr_stmt><expr><name>sn</name> = <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ENDITER</name></expr>:
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr>(<name>void</name>) <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ENTERWITH</name></expr>:
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>!<call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\twith (%s) {\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>with_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_LEAVEWITH</name></expr>:
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>with_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ENTERBLOCK</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>JSAtom</name> **</type><name>atomv</name></decl>, *<decl><type ref="prev"/><name><name>smallv</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>LOAD_OBJECT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>argc</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<name>size_t</name>)<name>argc</name> &lt;= <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>smallv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>atomv</name> = <name>smallv</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>atomv</name> = (<name>JSAtom</name> **) <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>JSAtom</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>atomv</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></else></if>

                <comment type="block">/* From here on, control must flow through enterblock_out. */</comment>
                <for>for (<init><expr><name>sprop</name> = <call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>lastProp</name></expr>;</init> <condition><expr><name>sprop</name></expr>;</condition>
                     <incr><expr><name>sprop</name> = <name><name>sprop</name>-&gt;<name>parent</name></name></expr></incr>) <block>{
                    <if>if <condition>(<expr>!(<name><name>sprop</name>-&gt;<name>flags</name></name> &amp; <name>SPROP_HAS_SHORTID</name>)</expr>)</condition><then>
                        <continue>continue;</continue></then></if>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name> &lt; <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>atomv</name><index>[<expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr>]</index></name> = <call><name>JSID_TO_ATOM</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>atom</name> = <name><name>atomv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name> ||
                        !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><call><name>STR2OFF</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                        <goto>goto <name>enterblock_out</name>;</goto>
                    }</block></then></if>
                }</block></for>

                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>sn</name> ? <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> : <name>SRC_NULL</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                  <case>case <expr><name>SRC_BRACE</name></expr>:
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t{\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ok</name> = <call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>len</name> - <name>oplen</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call>
                         != <name>NULL</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                        <goto>goto <name>enterblock_out</name>;</goto></then></if>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                  </case><case>case <expr><name>SRC_CATCH</name></expr>:
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t} catch ("</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_EXCEPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <name>JSOP_EXCEPTION_LENGTH</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>JSOP_EXCEPTION</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                        <goto>goto <name>enterblock_out</name>;</goto>
                    }</block></then></if>

                    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_DUP</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>sn2</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>sn2</name> || <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn2</name></expr></argument>)</argument_list></call> != <name>SRC_DESTRUCT</name></expr>)</condition><then> <block>{
                            <comment type="block">/*
                             * This is a dup to save the exception for later.
                             * It is emitted only when the catch head contains
                             * an exception guard.
                             */</comment>
                            <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>pc</name> += <name>JSOP_DUP_LENGTH</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><name>todo</name> &lt; 0 ||
                                !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>JSOP_EXCEPTION</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                                <goto>goto <name>enterblock_out</name>;</goto>
                            }</block></then></if>
                        }</block></then></if>
                    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_DUP</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>pc</name> = <call><name>DecompileDestructuring</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                            <goto>goto <name>enterblock_out</name>;</goto>
                        }</block></then></if>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pc</name> += <name>JSOP_POP_LENGTH</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lval</name> = <call><name>PopStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_SETLOCALPOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pc</name> += <name>JSOP_SETLOCALPOP_LENGTH</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>atom</name> = <name><name>atomv</name><index>[<expr><name>i</name> - <call><name>OBJ_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>str</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                            <goto>goto <name>enterblock_out</name>;</goto>
                        }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="block">/*
                     * Pop the exception_cookie (or its dup in the case of a
                     * guarded catch head) off the stack now.
                     */</comment>
                    <expr_stmt><expr><name>rval</name> = <call><name>PopStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>len</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>len</name> -= <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>len</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>" if "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ok</name> = <call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                            <goto>goto <name>enterblock_out</name>;</goto></then></if>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_IFEQ</name> || *<name>pc</name> == <name>JSOP_IFEQX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pc</name> += <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>") {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
                    <break>break;</break>
                  </case><default>default:
                    <break>break;</break>
                </default>}</block></switch>

                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>

              <label><name>enterblock_out</name>:</label>
                <if>if <condition>(<expr><name>atomv</name> != <name>smallv</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atomv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
              }</block>
              <break>break;</break>

              </case><case>case <expr><name>JSOP_LEAVEBLOCK</name></expr>:
              </case><case>case <expr><name>JSOP_LEAVEBLOCKEXPR</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>uintN</name></type> <name>top</name></decl>, <decl><type ref="prev"/><name>depth</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_LEAVEBLOCKEXPR</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_PCBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>sn</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_LEAVEBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr>)</condition><then>
                        <break>break;</break></then></if>

                    <comment type="block">/*
                     * This JSOP_LEAVEBLOCK must be for a catch block. If sn's
                     * offset does not equal the model stack depth, there must
                     * be a copy of the exception value on the stack due to a
                     * catch guard (see above, the JSOP_ENTERBLOCK + SRC_CATCH
                     * case code).
                     */</comment>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_CATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>(<name>uintN</name>)<call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != <name><name>ss</name>-&gt;<name>top</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>)<call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
                                     == <name><name>ss</name>-&gt;<name>top</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>exception_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if></else></if>
                <expr_stmt><expr><name>top</name> = <name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>depth</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>top</name> &gt;= <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>top</name> -= <name>depth</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ss</name>-&gt;<name>top</name></name> = <name>top</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <call><name>GetOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_LEAVEBLOCKEXPR</name></expr>)</condition><then>
                    <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_CALLLOCAL</name></expr>:
              </case><case>case <expr><name>JSOP_GETLOCAL</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>)<name>i</name> &lt; <name><name>ss</name>-&gt;<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_GROUPASSIGN</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pc</name> = <call><name>DecompileGroupAssignment</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr>&amp;<name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_POPN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <name>oplen</name> = <name>JSOP_POPN_LENGTH</name></expr>;</expr_stmt>
                    <goto>goto <name>end_groupassignment</name>;</goto>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><name>rval</name> = <call><name>GetLocal</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>, <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_SETLOCAL</name></expr>:
              </case><case>case <expr><name>JSOP_SETLOCALPOP</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_setlval</name>;</goto>

              </case><case>case <expr><name>JSOP_INCLOCAL</name></expr>:
              </case><case>case <expr><name>JSOP_DECLOCAL</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>GetLocal</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_inclval</name>;</goto>

              </case><case>case <expr><name>JSOP_LOCALINC</name></expr>:
              </case><case>case <expr><name>JSOP_LOCALDEC</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>GetLocal</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_lvalinc</name>;</goto>

              </case><case>case <expr><name>JSOP_FORLOCAL</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>
                <goto>goto <name>do_forlvalinloop</name>;</goto>

              </case><case>case <expr><name>JSOP_RETRVAL</name></expr>:
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_RETURN</name></expr>:
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fun</name> = <name><name>jp</name>-&gt;<name>fun</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_EXPR_CLOSURE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>(*<name>rval</name> == '{') ? "(%s)%s" : <name>ss_format</name></expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>,
                              <argument><expr>((<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_LAMBDA</name>) || !<name><name>fun</name>-&gt;<name>atom</name></name>)
                              ? ""
                              : ";"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_SETRVAL</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>rval</name> != '\0'</expr>)</condition><then>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s %s;\n"</expr></argument>, <argument><expr><name>js_return_str</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s;\n"</expr></argument>, <argument><expr><name>js_return_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_YIELD</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
                <if>if <condition>(<expr>!<name><name>ss</name>-&gt;<name>inGenExp</name></name> || !(<name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <block>{
                    <comment type="block">/* Turn off most parens. */</comment>
                    <expr_stmt><expr><name>op</name> = <name>JSOP_SETNAME</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = (*<name>rval</name> != '\0')
                           ? <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                                    <argument><expr>(<call><name>strncmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>js_yield_str</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> == 0 &amp;&amp;
                                     (<name><name>rval</name><index>[<expr>5</expr>]</index></name> == ' ' || <name><name>rval</name><index>[<expr>5</expr>]</index></name> == '\0'))
                                    ? "%s (%s)"
                                    : "%s %s"</expr></argument>,
                                    <argument><expr><name>js_yield_str</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call>
                           : <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>js_yield_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

              </case><case>case <expr><name>JSOP_ARRAYPUSH</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>uintN</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>forpos</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>start</name></decl>;</decl_stmt>

                <comment type="block">/* Turn off most parens. */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_SETNAME</name></expr>;</expr_stmt>

                <comment type="block">/* Pop the expression being pushed or yielded. */</comment>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Skip down over iterables left stacked by JSOP_FOR* until
                 * we hit a block-local or the new Array initialiser (empty
                 * destructuring patterns yield zero-count blocks).
                 */</comment>
                <expr_stmt><expr><name>pos</name> = <name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
                <while>while <condition>(<expr>(<name>op</name> = (<name>JSOp</name>) <name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr>--<name>pos</name></expr>]</index></name>) != <name>JSOP_ENTERBLOCK</name> &amp;&amp;
                       <name>op</name> != <name>JSOP_NEWINIT</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr><name>pos</name> == 0</expr>)</condition><then>
                        <break>break;</break></then></if>
                }</block></while>

                <comment type="block">/*
                 * Make forpos index the space before the left-most |for| in
                 * the single string of accumulated |for| heads and optional
                 * final |if (condition)|.
                 */</comment>
                <expr_stmt><expr><name>forpos</name> = <name>pos</name> + (<name>op</name> == <name>JSOP_ENTERBLOCK</name> || <name>op</name> == <name>JSOP_NEWINIT</name>)</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>forpos</name> &lt; <name><name>ss</name>-&gt;<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Now skip down over the block's local slots, if any. There
                 * may be no locals for an empty destructuring pattern.
                 */</comment>
                <while>while <condition>(<expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name>pos</name></expr>]</index></name> == <name>JSOP_ENTERBLOCK</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr><name>pos</name> == 0</expr>)</condition><then>
                        <break>break;</break></then></if>
                    <expr_stmt><expr>--<name>pos</name></expr>;</expr_stmt>
                }</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
                <if>if <condition>(<expr><name>saveop</name> == <name>JSOP_YIELD</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Generator expression: decompile just rval followed by
                     * the string starting at forpos. Leave the result string
                     * in ss-&gt;offsets[0] so it can be recovered by our caller
                     * (the JSOP_ANONFUNOBJ with SRC_GENEXP case). Bump the
                     * top of stack to balance yield, which is an expression
                     * (so has neutral stack balance).
                     */</comment>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>pos</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>xval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>forpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> = <name>PAREN_SLOP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr>0</expr>]</index></name> = <name>todo</name></expr>;</expr_stmt>
                    <expr_stmt><expr>++<name><name>ss</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
                    <return>return <expr><name>pc</name></expr>;</return>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATOR_EXPRS */</comment>

                <comment type="block">/*
                 * Array comprehension: retract the sprinter to the beginning
                 * of the array initialiser and decompile "[&lt;rval&gt; for ...]".
                 */</comment>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name>pos</name></expr>]</index></name> == <name>JSOP_NEWINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> = <name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>base</name><index>[<expr><name>start</name></expr>]</index></name> == '[' ||
                             <name><name>ss</name>-&gt;<name>sprinter</name>.<name>base</name><index>[<expr><name>start</name></expr>]</index></name> == '#'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>forpos</name> &lt; <name><name>ss</name>-&gt;<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>xval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>forpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%.*s"</expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>, <argument><expr><name>rval</name> - <name>xval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name>pos</name></expr>]</index></name> = <name>todo</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
              }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

              </case><case>case <expr><name>JSOP_THROWING</name></expr>:
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_THROW</name></expr>:
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s %s;\n"</expr></argument>, <argument><expr><name>js_throw_str</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GOTO</name></expr>:
              </case><case>case <expr><name>JSOP_GOTOX</name></expr>:
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>sn</name> ? <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> : <name>SRC_NULL</name></expr>)</condition> <block>{
                  <case>case <expr><name>SRC_WHILE</name></expr>:
                    <expr_stmt><expr><name>cond</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tail</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>cond</name></expr></argument>, <argument><expr><name>tail</name> - <name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\twhile (%s) {\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>cond</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <name>tail</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_IFNE</name> || *<name>pc</name> == <name>JSOP_IFNEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_CONT2LABEL</name></expr>:
                    <expr_stmt><expr><call><name>GET_SOURCE_NOTE_ATOM</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tcontinue %s;\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_CONTINUE</name></expr>:
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tcontinue;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_BREAK2LABEL</name></expr>:
                    <expr_stmt><expr><call><name>GET_SOURCE_NOTE_ATOM</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tbreak %s;\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_HIDDEN</name></expr>:
                    <break>break;</break>

                  </case><default>default:
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tbreak;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </default>}</block></switch>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_IFEQ</name></expr>:
              </case><case>case <expr><name>JSOP_IFEQX</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>JSBool</name></type> <name>elseif</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>

              <label><name>if_again</name>:</label>
                <expr_stmt><expr><name>len</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <switch>switch <condition>(<expr><name>sn</name> ? <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> : <name>SRC_NULL</name></expr>)</condition> <block>{
                  <case>case <expr><name>SRC_IF</name></expr>:
                  </case><case>case <expr><name>SRC_IF_ELSE</name></expr>:
                    <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>              <comment type="block">/* turn off parens */</comment>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>ss</name>-&gt;<name>inArrayInit</name></name> || <name><name>ss</name>-&gt;<name>inGenExp</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> -= <name>PAREN_SLOP</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>" if (%s)"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                            <return>return <expr><name>NULL</name></expr>;</return></then></if>
                        <expr_stmt><expr><call><name>AddParenSlop</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>,
                                  <argument><expr><name>elseif</name> ? " if (%s) {\n" : "\tif (%s) {\n"</expr></argument>,
                                  <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    }</block></else></if>

                    <if>if <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_IF</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>len</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>!<name><name>ss</name>-&gt;<name>inArrayInit</name></name> &amp;&amp; !<name><name>ss</name>-&gt;<name>inGenExp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>tail</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>tail</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                        <expr_stmt><expr><name>pc</name> += <name>tail</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_GOTO</name> || *<name>pc</name> == <name>JSOP_GOTOX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>oplen</name> = <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t} else"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
                         * If the second offset for sn is non-zero, it tells
                         * the distance from the goto around the else, to the
                         * ifeq for the if inside the else that forms an "if
                         * else if" chain.  Thus cond spans the condition of
                         * the second if, so we simply decompile it and start
                         * over at label if_again.
                         */</comment>
                        <expr_stmt><expr><name>cond</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>cond</name> != 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>cond</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>pc</name> += <name>cond</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>elseif</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                            <goto>goto <name>if_again</name>;</goto>
                        }</block></then></if>

                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>" {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>len</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>

                    <if>if <condition>(<expr>!<name><name>ss</name>-&gt;<name>inArrayInit</name></name> &amp;&amp; !<name><name>ss</name>-&gt;<name>inGenExp</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                    <break>break;</break>

                  </case><case>case <expr><name>SRC_COND</name></expr>:
                    <expr_stmt><expr><name>xval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>xval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>len</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>NULL</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_GOTO</name> || *<name>pc</name> == <name>JSOP_GOTOX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>oplen</name> = <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>len</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s ? %s : %s"</expr></argument>,
                                  <argument><expr><name>xval</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                  </case><default>default:
                    <break>break;</break>
                </default>}</block></switch>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_IFNE</name></expr>:
              </case><case>case <expr><name>JSOP_IFNEX</name></expr>:
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_OR</name></expr>:
              </case><case>case <expr><name>JSOP_ORX</name></expr>:
                <expr_stmt><expr><name>xval</name> = "||"</expr>;</expr_stmt>

              <label><name>do_logical_connective</name>:</label>
                <comment type="block">/* Top of stack is the first clause in a disjunction (||). */</comment>
                <expr_stmt><expr><name>lval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>done</name> = <name>pc</name> + <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>done</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>jp</name>-&gt;<name>pretty</name></name> &amp;&amp;
                    <name><name>jp</name>-&gt;<name>indent</name></name> + 4 + <call><name>strlen</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call> + 4 + <call><name>strlen</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call> &gt; 75</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>tail</name> = -1</expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s\n"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>tail</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%*s%s"</expr></argument>,
                                      <argument><expr><name><name>jp</name>-&gt;<name>indent</name></name> + 4</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <if>if <condition>(<expr><name>tail</name> &lt; 0</expr>)</condition><then>
                        <expr_stmt><expr><name>todo</name> = -1</expr>;</expr_stmt></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s %s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_AND</name></expr>:
              </case><case>case <expr><name>JSOP_ANDX</name></expr>:
                <expr_stmt><expr><name>xval</name> = "&amp;&amp;"</expr>;</expr_stmt>
                <goto>goto <name>do_logical_connective</name>;</goto>

              </case><case>case <expr><name>JSOP_FORARG</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_fornameinloop</name>;</goto>

              </case><case>case <expr><name>JSOP_FORVAR</name></expr>:
              </case><case>case <expr><name>JSOP_FORCONST</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_fornameinloop</name>;</goto>

              </case><case>case <expr><name>JSOP_FORNAME</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <label><name>do_fornameinloop</name>:</label>
                <expr_stmt><expr><name>lval</name> = ""</expr>;</expr_stmt>
              <label><name>do_forlvalinloop</name>:</label>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>xval</name> = <name>NULL</name></expr>;</expr_stmt>
                <goto>goto <name>do_forinloop</name>;</goto>

              </case><case>case <expr><name>JSOP_FORPROP</name></expr>:
                <expr_stmt><expr><name>xval</name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>ATOM_IS_IDENTIFIER</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>xval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr>(<name>jschar</name>)'\''</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>xval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <name>NULL</name></expr>;</expr_stmt>

              <label><name>do_forinloop</name>:</label>
                <expr_stmt><expr><name>pc</name> += <name>oplen</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_IFEQ</name> || *<name>pc</name> == <name>JSOP_IFEQX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oplen</name> = <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn2</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tail</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <label><name>do_forinhead</name>:</label>
                <if>if <condition>(<expr>!<name>atom</name> &amp;&amp; <name>xval</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * If xval is not a dummy empty string, we have to strdup
                     * it to save it from being clobbered by the first Sprint
                     * below.  Standard dumb decompiler operating procedure!
                     */</comment>
                    <if>if <condition>(<expr>*<name>xval</name> == '\0'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>xval</name> = <name>NULL</name></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>xval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>xval</name></expr>)</condition><then>
                            <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    }</block></else></if>
                }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
                <if>if <condition>(<expr><name>foreach</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>foreach</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"for %s (%s%s"</expr></argument>,
                                  <argument><expr><name>js_each_str</name></expr></argument>, <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"for (%s%s"</expr></argument>,
                                  <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name>atom</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>*<name>lval</name> &amp;&amp; <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"."</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>xval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>xval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></then> <else>else <if>if <condition>(<expr><name>xval</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>xval</name> != '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ok</name> = (<call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                                 <argument><expr>(<call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>lastop</name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                                 ? ".%s"
                                 : "[%s]"</expr></argument>,
                                 <argument><expr><name>xval</name></expr></argument>)</argument_list></call>
                          &gt;= 0)</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></then></if></else></if>
                <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>

                <expr_stmt><expr><name>lval</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>ss</name>-&gt;<name>inArrayInit</name></name> || <name><name>ss</name>-&gt;<name>inGenExp</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>ss</name>-&gt;<name>top</name></name> &gt; 1 &amp;&amp;
                        (<name><name>js_CodeSpec</name><index>[<expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-2</expr>]</index></name></expr>]</index></name>.<name>format</name> &amp;
                         <name>JOF_FOR</name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name> -= <name>PAREN_SLOP</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>" %s in %s)"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>offsets</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name> = <name>todo</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name> = <name>op</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>AddParenSlop</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>tail</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s in %s) {\n"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name> + <name>oplen</name></expr></argument>, <argument><expr><name>tail</name> - <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_FORELEM</name></expr>:
                <expr_stmt><expr><name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_IFEQ</name> || *<name>pc</name> == <name>JSOP_IFEQX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Arrange for the JSOP_ENUMELEM case to set tail for use by
                 * do_forinhead: code that uses on it to find the loop-closing
                 * jump (whatever its format, normal or extended), in order to
                 * bound the recursively decompiled loop body.
                 */</comment>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>!<name>forelem_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>forelem_tail</name> = <name>pc</name> + <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * This gets a little wacky.  Only the length of the for loop
                 * body PLUS the element-indexing expression is known here, so
                 * we pass the after-loop pc to the JSOP_ENUMELEM case, which
                 * is immediately below, to decompile that helper bytecode via
                 * the 'forelem_done' local.
                 *
                 * Since a for..in loop can't nest in the head of another for
                 * loop, we can use forelem_{tail,done} singletons to remember
                 * state from JSOP_FORELEM to JSOP_ENUMELEM, thence (via goto)
                 * to label do_forinhead.
                 */</comment>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>!<name>forelem_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>forelem_done</name> = <name>pc</name> + <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Our net stack balance after forelem;ifeq is +1. */</comment>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>forelem_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ENUMELEM</name></expr>:
              </case><case>case <expr><name>JSOP_ENUMCONSTELEM</name></expr>:
                <comment type="block">/*
                 * The stack has the object under the (top) index expression.
                 * The "rval" property id is underneath those two on the stack.
                 * The for loop body net and gross lengths can now be adjusted
                 * to account for the length of the indexing expression that
                 * came after JSOP_FORELEM and before JSOP_ENUMELEM.
                 */</comment>
                <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>          <comment type="block">/* turn off parens around xval */</comment>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>      <comment type="block">/* lval must have high precedence */</comment>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>saveop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>forelem_cookie</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>forelem_tail</name> &gt; <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tail</name> = <name>forelem_tail</name> - <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>forelem_tail</name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>forelem_done</name> &gt; <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <name>forelem_done</name> - <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>forelem_done</name> = <name>NULL</name></expr>;</expr_stmt>
                <goto>goto <name>do_forinhead</name>;</goto>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_GETTER</name></expr>:
              </case><case>case <expr><name>JSOP_SETTER</name></expr>:
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

              </case><case>case <expr><name>JSOP_DUP2</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>top</name></name>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>,
                                         <argument><expr>(<name>JSOp</name>) <name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_DUP</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_DESTRUCT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> = <call><name>DecompileDestructuring</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
                    <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = <name>saveop</name> = <name>JSOP_ENUMELEM</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>forelem_cookie</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>forelem_tail</name> &gt; <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>tail</name> = <name>forelem_tail</name> - <name>pc</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>forelem_tail</name> = <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>forelem_done</name> &gt; <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> = <name>forelem_done</name> - <name>pc</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>forelem_done</name> = <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>xval</name> = <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Null sn if this is a 'for (var [k, v] = i in o)'
                         * loop, because 'var [k, v = i;' has already been
                         * hoisted.
                         */</comment>
                        <if>if <condition>(<expr><call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>SRC_DECL_VAR</name></expr>)</condition><then>
                            <expr_stmt><expr><name>sn</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
                        <goto>goto <name>do_forinhead</name>;</goto>
                    }</block></then></if>

                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s = %s"</expr></argument>,
                                  <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><name>rval</name> = <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>saveop</name> = (<name>JSOp</name>) <name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_SETARG</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_setname</name>;</goto>

              </case><case>case <expr><name>JSOP_SETVAR</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_setname</name>;</goto>

              </case><case>case <expr><name>JSOP_SETCONST</name></expr>:
              </case><case>case <expr><name>JSOP_SETNAME</name></expr>:
              </case><case>case <expr><name>JSOP_SETGVAR</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <label><name>do_setname</name>:</label>
                <expr_stmt><expr><name>lval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETNAME</name></expr>)</condition><then>
                    <expr_stmt><expr>(<name>void</name>) <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

              <label><name>do_setlval</name>:</label>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_ASSIGNOP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s= %s"</expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>,
                                  <argument><expr>(<name>lastop</name> == <name>JSOP_GETTER</name>)
                                  ? <name>js_getter_str</name>
                                  : (<name>lastop</name> == <name>JSOP_SETTER</name>)
                                  ? <name>js_setter_str</name>
                                  : <name><name>CodeToken</name><index>[<expr><name>lastop</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s = %s"</expr></argument>,
                                  <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETLOCALPOP</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>saveop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>rval</name> != '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s;\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_NEW</name></expr>:
              </case><case>case <expr><name>JSOP_CALL</name></expr>:
              </case><case>case <expr><name>JSOP_EVAL</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_SETCALL</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Turn off most parens (all if there's only one argument). */</comment>
                <expr_stmt><expr><name>argc</name> = <call><name>GET_ARGC</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>argc</name> == 1) ? <name>JSOP_NOP</name> : <name>JSOP_SETNAME</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>argv</name> = (<name>char</name> **)
                    <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>argc</name> + 1</expr></argument>)</argument_list></call> * sizeof *<name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>argv</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>

                <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = <name>argc</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
                    <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt></then></if>
                }</block></for>

                <comment type="block">/* Skip the JSOP_PUSHOBJ-created empty string. */</comment>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>top</name></name> &gt;= 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>) <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Special case: new (x(y)(z)) must be parenthesized like so.
                 * Same for new (x(y).z) -- contrast with new x(y).z.
                 */</comment>
                <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) <name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>-1</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>PopStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>,
                              <argument><expr>(<name>saveop</name> == <name>JSOP_NEW</name> &amp;&amp;
                               (<name>op</name> == <name>JSOP_CALL</name> || <name>op</name> == <name>JSOP_EVAL</name> ||
                                (<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_CALLOP</name>)))
                              ? <name>JSOP_NAME</name>
                              : <name>saveop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>saveop</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><name>lval</name> = "("</expr>, <expr><name>rval</name> = ")"</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_NEW</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then>
                        <expr_stmt><expr><name>lval</name> = <name>rval</name> = ""</expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s%s"</expr></argument>,
                                  <argument><expr><name>js_new_str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                                  <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then>
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt></then></if>

                <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <if>if <condition>(<expr>!<name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> ||
                        <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                               <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>(<name>i</name> &lt; <name>argc</name>) ? ", " : ""</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
                <if>if <condition>(<expr><call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt></then></if>

                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETCALL</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_DELNAME</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_delete_lval</name>:</label>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s"</expr></argument>, <argument><expr><name>js_delete_str</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_DELPROP</name></expr>:
                <expr_stmt><expr><call><name>GET_ATOM_QUOTE_AND_FMT</name><argument_list>(<argument><expr>"%s %s[%s]"</expr></argument>, <argument><expr>"%s %s.%s"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>js_delete_str</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_DELELEM</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>          <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>saveop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>xval</name> == '\0'</expr>)</condition><then>
                    <goto>goto <name>do_delete_lval</name>;</goto></then></if>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                              <argument><expr>(<call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>lastop</name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                              ? "%s %s.%s"
                              : "%s %s[%s]"</expr></argument>,
                              <argument><expr><name>js_delete_str</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_DELDESC</name></expr>:
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s..%s"</expr></argument>,
                              <argument><expr><name>js_delete_str</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

              </case><case>case <expr><name>JSOP_TYPEOFEXPR</name></expr>:
              </case><case>case <expr><name>JSOP_TYPEOF</name></expr>:
              </case><case>case <expr><name>JSOP_VOID</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s"</expr></argument>,
                              <argument><expr>(<name>op</name> == <name>JSOP_VOID</name>) ? <name>js_void_str</name> : <name>js_typeof_str</name></expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_INCARG</name></expr>:
              </case><case>case <expr><name>JSOP_DECARG</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_incatom</name>;</goto>

              </case><case>case <expr><name>JSOP_INCVAR</name></expr>:
              </case><case>case <expr><name>JSOP_DECVAR</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_incatom</name>;</goto>

              </case><case>case <expr><name>JSOP_INCNAME</name></expr>:
              </case><case>case <expr><name>JSOP_DECNAME</name></expr>:
              </case><case>case <expr><name>JSOP_INCGVAR</name></expr>:
              </case><case>case <expr><name>JSOP_DECGVAR</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_incatom</name>:</label>
                <expr_stmt><expr><name>lval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_inclval</name>:</label>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                              <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_INCPROP</name></expr>:
              </case><case>case <expr><name>JSOP_DECPROP</name></expr>:
                <expr_stmt><expr><call><name>GET_ATOM_QUOTE_AND_FMT</name><argument_list>(<argument><expr><name>preindex_format</name></expr></argument>, <argument><expr><name>predot_format</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Force precedence below the numeric literal opcodes, so that
                 * 42..foo or 10000..toString(16), e.g., decompile with parens
                 * around the left-hand side of dot.
                 */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>,
                              <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_INCELEM</name></expr>:
              </case><case>case <expr><name>JSOP_DECELEM</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>          <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>xval</name> != '\0'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                                  <argument><expr>(<call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>lastop</name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                                  ? <name>predot_format</name>
                                  : <name>preindex_format</name></expr></argument>,
                                  <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                                  <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ARGINC</name></expr>:
              </case><case>case <expr><name>JSOP_ARGDEC</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_atominc</name>;</goto>

              </case><case>case <expr><name>JSOP_VARINC</name></expr>:
              </case><case>case <expr><name>JSOP_VARDEC</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_atominc</name>;</goto>

              </case><case>case <expr><name>JSOP_NAMEINC</name></expr>:
              </case><case>case <expr><name>JSOP_NAMEDEC</name></expr>:
              </case><case>case <expr><name>JSOP_GVARINC</name></expr>:
              </case><case>case <expr><name>JSOP_GVARDEC</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_atominc</name>:</label>
                <expr_stmt><expr><name>lval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_lvalinc</name>:</label>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>, <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_PROPINC</name></expr>:
              </case><case>case <expr><name>JSOP_PROPDEC</name></expr>:
                <expr_stmt><expr><call><name>GET_ATOM_QUOTE_AND_FMT</name><argument_list>(<argument><expr><name>postindex_format</name></expr></argument>, <argument><expr><name>postdot_format</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Force precedence below the numeric literal opcodes, so that
                 * 42..foo or 10000..toString(16), e.g., decompile with parens
                 * around the left-hand side of dot.
                 */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>,
                              <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ELEMINC</name></expr>:
              </case><case>case <expr><name>JSOP_ELEMDEC</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>          <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>xval</name> != '\0'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                                  <argument><expr>(<call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>lastop</name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                                  ? <name>postdot_format</name>
                                  : <name>postindex_format</name></expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>,
                                  <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>ss_format</name></expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>, <argument><expr><name><name>js_incop_strs</name><index>[<expr>!(<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_INC</name>)</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_LENGTH</name></expr>:
                <expr_stmt><expr><name>fmt</name> = <name>dot_format</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <name>js_length_str</name></expr>;</expr_stmt>
                <goto>goto <name>do_getprop_lval</name>;</goto>

              </case><case>case <expr><name>JSOP_GETPROP2</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>) <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>lastop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_CALLPROP</name></expr>:
              </case><case>case <expr><name>JSOP_GETPROP</name></expr>:
              </case><case>case <expr><name>JSOP_GETXPROP</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <label><name>do_getprop</name>:</label>
                <expr_stmt><expr><call><name>GET_QUOTE_AND_FMT</name><argument_list>(<argument><expr><name>index_format</name></expr></argument>, <argument><expr><name>dot_format</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_getprop_lval</name>:</label>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GETTHISPROP</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>GET_QUOTE_AND_FMT</name><argument_list>(<argument><expr><name>index_format</name></expr></argument>, <argument><expr><name>dot_format</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>js_this_str</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GETARGPROP</name></expr>:
              </case><case>case <expr><name>JSOP_GETVARPROP</name></expr>:
                <comment type="block">/* Get the name of the argument or variable. */</comment>
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name><name>ss</name>-&gt;<name>printer</name></name></expr></argument>, <argument><expr><name>op</name> == <name>JSOP_GETARGPROP</name></expr></argument>,
                                   <argument><expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>ATOM_IS_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name> || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><call><name>STR2OFF</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>

                <comment type="block">/* Get the name of the property. */</comment>
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr><name>ARGNO_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_getprop</name>;</goto>

              </case><case>case <expr><name>JSOP_GETLOCALPROP</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>)<name>i</name> &lt; <name><name>ss</name>-&gt;<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>GetLocal</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <goto>goto <name>do_getprop</name>;</goto>

              </case><case>case <expr><name>JSOP_SETPROP</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>GET_QUOTE_AND_FMT</name><argument_list>(<argument><expr>"%s[%s] %s= %s"</expr></argument>, <argument><expr>"%s.%s %s= %s"</expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Force precedence below the numeric literal opcodes, so that
                 * 42..foo or 10000..toString(16), e.g., decompile with parens
                 * around the left-hand side of dot.
                 */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETPROP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>,
                              <argument><expr>(<name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_ASSIGNOP</name>)
                              ? (<name>lastop</name> == <name>JSOP_GETTER</name>)
                                ? <name>js_getter_str</name>
                                : (<name>lastop</name> == <name>JSOP_SETTER</name>)
                                ? <name>js_setter_str</name>
                                : <name><name>CodeToken</name><index>[<expr><name>lastop</name></expr>]</index></name>
                              : ""</expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GETELEM2</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>) <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>lastop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_CALLELEM</name></expr>:
              </case><case>case <expr><name>JSOP_GETELEM</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>          <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>saveop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>xval</name> == '\0'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                                  <argument><expr>(<call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>lastop</name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                                  ? <name>dot_format</name>
                                  : <name>index_format</name></expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_SETELEM</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>          <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>      <comment type="block">/* lval must have high precedence */</comment>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>saveop</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>xval</name> == '\0'</expr>)</condition><then>
                    <goto>goto <name>do_setlval</name>;</goto></then></if>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>,
                              <argument><expr>(<call><name>JOF_MODE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name>)
                              ? "%s.%s %s= %s"
                              : "%s[%s] %s= %s"</expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>,
                              <argument><expr>(<name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_ASSIGNOP</name>)
                              ? (<name>lastop</name> == <name>JSOP_GETTER</name>)
                                ? <name>js_getter_str</name>
                                : (<name>lastop</name> == <name>JSOP_SETTER</name>)
                                ? <name>js_setter_str</name>
                                : <name><name>CodeToken</name><index>[<expr><name>lastop</name></expr>]</index></name>
                              : ""</expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ARGSUB</name></expr>:
                <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s[%d]"</expr></argument>,
                              <argument><expr><name>js_arguments_str</name></expr></argument>, <argument><expr>(<name>int</name>) <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ARGCNT</name></expr>:
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>dot_format</name></expr></argument>,
                              <argument><expr><name>js_arguments_str</name></expr></argument>, <argument><expr><name>js_length_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_CALLARG</name></expr>:
              </case><case>case <expr><name>JSOP_GETARG</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_ARGNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s[%d]"</expr></argument>, <argument><expr><name>js_arguments_str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <goto>goto <name>do_name</name>;</goto>

              </case><case>case <expr><name>JSOP_CALLVAR</name></expr>:
              </case><case>case <expr><name>JSOP_GETVAR</name></expr>:
                <expr_stmt><expr><name>atom</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><call><name>GET_VARNO</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_name</name>;</goto>

              </case><case>case <expr><name>JSOP_CALLNAME</name></expr>:
              </case><case>case <expr><name>JSOP_NAME</name></expr>:
              </case><case>case <expr><name>JSOP_GETGVAR</name></expr>:
              </case><case>case <expr><name>JSOP_CALLGVAR</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_name</name>:</label>
                <expr_stmt><expr><name>lval</name> = ""</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
              <label><name>do_qname</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>inXML</name> ? <name>DONT_ESCAPE</name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%s"</expr></argument>,
                              <argument><expr><call><name>VarPrefix</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_UINT16</name></expr>:
                <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_sprint_int</name>;</goto>

              </case><case>case <expr><name>JSOP_UINT24</name></expr>:
                <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <call><name>GET_UINT24</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_sprint_int</name>;</goto>

              </case><case>case <expr><name>JSOP_INT8</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_INT8</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_sprint_int</name>;</goto>

              </case><case>case <expr><name>JSOP_INT32</name></expr>:
                <expr_stmt><expr><name>i</name> = <call><name>GET_INT32</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_sprint_int</name>:</label>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_DOUBLE</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintDoubleValue</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>&amp;<name>saveop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_STRING</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>inXML</name> ? <name>DONT_ESCAPE</name> : '"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = <call><name>STR2OFF</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ANONFUNOBJ</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATOR_EXPRS</name></expr></cpp:if>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_GENEXP</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSScript</name> *</type><name>inner</name></decl>, *<decl><type ref="prev"/><name>outer</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>SprintStack</name></type> <name>ss2</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>LOAD_FUNCTION</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fun</name> = <call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inner</name> = <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * All allocation when decompiling is LIFO, using malloc
                     * or, more commonly, arena-alloocating from cx-&gt;tempPool.
                     * After InitSprintStack succeeds, we must release to mark
                     * before returning.
                     */</comment>
                    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>InitSprintStack</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>ss2</name></expr></argument>, <argument><expr><name>jp</name></expr></argument>, <argument><expr><name><name>inner</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name><name>ss2</name>.<name>inGenExp</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Recursively decompile this generator function as an
                     * un-parenthesized generator expression. The ss-&gt;inGenExp
                     * special case of JSOP_YIELD shares array comprehension
                     * decompilation code that leaves the result as the single
                     * string pushed on ss2.
                     */</comment>
                    <expr_stmt><expr><name>outer</name> = <name><name>jp</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>JS_UPTRDIFF</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>outer</name>-&gt;<name>code</name></name></expr></argument>)</argument_list></call> &lt;= <name><name>outer</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name>inner</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>Decompile</name><argument_list>(<argument><expr>&amp;<name>ss2</name></expr></argument>, <argument><expr><name><name>inner</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><name><name>inner</name>-&gt;<name>length</name></name></expr></argument>,
                                   <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>NULL</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name>outer</name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Advance over this op and its global |this| push, and
                     * arrange to advance over the call to this lambda.
                     */</comment>
                    <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> += <name>JSOP_NULL_LENGTH</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>GET_ARGC</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <name>JSOP_CALL_LENGTH</name></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Arrange to parenthesize this genexp unless:
                     *
                     *  1. It is the complete expression consumed by a control
                     *     flow bytecode such as JSOP_TABLESWITCH whose syntax
                     *     always parenthesizes the controlling expression.
                     *  2. It is the sole argument to a function call.
                     *  3. It is the condition of an if statement and not of a
                     *     ?: expression.
                     *
                     * But (first, before anything else) always parenthesize
                     * if this genexp runs up against endpc and the next op is
                     * not a while or do-while loop JSOP_IFNE* opcode. In such
                     * cases, this Decompile activation has been recursively
                     * called by a comma operator, &amp;&amp;, or || bytecode.
                     */</comment>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>pc</name> + <name>len</name> &lt; <name>endpc</name> ||
                                 <name>endpc</name> &lt; <name><name>outer</name>-&gt;<name>code</name></name> + <name><name>outer</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>ss2</name>.<name>top</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss2</name>.<name>opcodes</name><index>[<expr>0</expr>]</index></name> = <name>JSOP_POP</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>pc</name> + <name>len</name> == <name>endpc</name> &amp;&amp;
                        ((<name>JSOp</name>) *<name>endpc</name> != <name>JSOP_IFNE</name> &amp;&amp;
                         (<name>JSOp</name>) *<name>endpc</name> != <name>JSOP_IFNEX</name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>op</name> = <name>JSOP_SETNAME</name></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) <name><name>pc</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>op</name> = ((<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_PARENHEAD</name>) ||
                              ((<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_INVOKE</name>) &amp;&amp;
                               <call><name>GET_ARGC</name><argument_list>(<argument><expr><name>pc</name> + <name>len</name></expr></argument>)</argument_list></call> == 1) ||
                              (((<name>op</name> == <name>JSOP_IFEQ</name> || <name>op</name> == <name>JSOP_IFEQX</name>) &amp;&amp;
                               (<name>sn2</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name>outer</name></expr></argument>, <argument><expr><name>pc</name> + <name>len</name></expr></argument>)</argument_list></call>) &amp;&amp;
                               <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn2</name></expr></argument>)</argument_list></call> != <name>SRC_COND</name>)))
                             ? <name>JSOP_POP</name>
                             : <name>JSOP_SETNAME</name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * Stack this result as if it's a name and not an
                         * anonymous function, so it doesn't get decompiled as
                         * a generator function in a getter or setter context.
                         * The precedence level is the same for JSOP_NAME and
                         * JSOP_ANONFUNOBJ.
                         */</comment>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>js_CodeSpec</name><index>[<expr><name>JSOP_NAME</name></expr>]</index></name>.<name>prec</name> ==
                                     <name><name>js_CodeSpec</name><index>[<expr><name>saveop</name></expr>]</index></name>.<name>prec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>saveop</name> = <name>JSOP_NAME</name></expr>;</expr_stmt>
                    }</block></else></if>

                    <comment type="block">/*
                     * Alas, we have to malloc a copy of the result left on
                     * the top of ss2 because both ss and ss2 arena-allocate
                     * from cx's tempPool.
                     */</comment>
                    <expr_stmt><expr><name>rval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>PopStr</name><argument_list>(<argument><expr>&amp;<name>ss2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATOR_EXPRS */</comment>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr><name>JSOP_NAMEDFUNOBJ</name></expr>:
                <expr_stmt><expr><call><name>LOAD_FUNCTION</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <block>{
                    <decl_stmt><decl><type><name>uintN</name></type> <name>indent</name> <init>= <expr><name>JS_DONT_PRETTY_PRINT</name></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Always parenthesize expression closures. We can't force
                     * saveop to a low-precedence op to arrange for auto-magic
                     * parenthesization without confusing getter/setter code
                     * that checks for JSOP_ANONFUNOBJ and JSOP_NAMEDFUNOBJ.
                     */</comment>
                    <expr_stmt><expr><name>fun</name> = <call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!(<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_EXPR_CLOSURE</name>)</expr>)</condition><then>
                        <expr_stmt><expr><name>indent</name> |= <name>JS_IN_GROUP_CONTEXT</name></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><name>str</name> = <call><name>JS_DecompileFunction</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block>
              <label><name>sprint_string</name>:</label>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_OBJECT</name></expr>:
                <expr_stmt><expr><call><name>LOAD_OBJECT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_RegExpClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_regexp</name>;</goto>

              </case><case>case <expr><name>JSOP_REGEXP</name></expr>:
                <expr_stmt><expr><call><name>GET_REGEXP_FROM_BYTECODE</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>do_regexp</name>:</label>
                <if>if <condition>(<expr>!<call><name>js_regexp_toString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>str</name> = <call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>sprint_string</name>;</goto>

              </case><case>case <expr><name>JSOP_TABLESWITCH</name></expr>:
              </case><case>case <expr><name>JSOP_TABLESWITCHX</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>jmplen</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>off2</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsint</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TableEntry</name> *</type><name>table</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>jmplen</name> = (<name>op</name> == <name>JSOP_TABLESWITCH</name>) ? <name>JUMP_OFFSET_LEN</name>
                                                  : <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>low</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>high</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>n</name> = <name>high</name> - <name>low</name> + 1</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>table</name> = <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
                    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>table</name> = (<name>TableEntry</name> *)
                            <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>n</name> * sizeof *<name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                    <for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>label</name> = <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>off2</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>off2</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><name>sn</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_LABEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>GET_SOURCE_NOTE_ATOM</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                            <expr_stmt><expr><name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>low</name> + <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>offset</name> = <name>off2</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>table</name><index>[<expr><name>j</name></expr>]</index></name>.<name>order</name> = <name>j</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
                    }</block></for>
                    <expr_stmt><expr><name>tmp</name> = (<name>TableEntry</name> *)
                          <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>j</name> * sizeof *<name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>tmp</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ok</name> = <call><name>js_MergeSort</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>j</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                          <argument><expr><name>CompareOffsets</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>

                <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <call><name>DecompileSwitch</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>j</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>off</name></expr></argument>,
                                         <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_LOOKUPSWITCH</name></expr>:
              </case><case>case <expr><name>JSOP_LOOKUPSWITCHX</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>jmplen</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>off2</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsatomid</name></type> <name>npairs</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TableEntry</name> *</type><name>table</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>jmplen</name> = (<name>op</name> == <name>JSOP_LOOKUPSWITCH</name>) ? <name>JUMP_OFFSET_LEN</name>
                                                   : <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>off</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>npairs</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> += <name>UINT16_LEN</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>table</name> = (<name>TableEntry</name> *)
                    <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>npairs</name> * sizeof *<name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name>npairs</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>sn</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_LABEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>GET_SOURCE_NOTE_ATOM</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>label</name> = <name>NULL</name></expr>;</expr_stmt>
                    }</block></else></if>
                    <expr_stmt><expr><call><name>JS_GET_SCRIPT_ATOM</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc2</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>off2</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>key</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>k</name></expr>]</index></name>.<name>offset</name> = <name>off2</name></expr>;</expr_stmt>
                }</block></for>

                <expr_stmt><expr><name>ok</name> = <call><name>DecompileSwitch</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>npairs</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>off</name></expr></argument>,
                                     <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_CONDSWITCH</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>off2</name></decl>, <decl><type ref="prev"/><name>caseOff</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsint</name></type> <name>ncases</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TableEntry</name> *</type><name>table</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_SWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>off</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Count the cases using offsets from switch to first case,
                 * and case to case, stored in srcnote immediates.
                 */</comment>
                <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>off2</name> = <name>off</name></expr>;</expr_stmt>
                <for>for (<init><expr><name>ncases</name> = 0</expr>;</init> <condition><expr><name>off2</name> != 0</expr>;</condition> <incr><expr><name>ncases</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>pc2</name> += <name>off2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc2</name> == <name>JSOP_CASE</name> || *<name>pc2</name> == <name>JSOP_DEFAULT</name> ||
                                 *<name>pc2</name> == <name>JSOP_CASEX</name> || *<name>pc2</name> == <name>JSOP_DEFAULTX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>*<name>pc2</name> == <name>JSOP_DEFAULT</name> || *<name>pc2</name> == <name>JSOP_DEFAULTX</name></expr>)</condition><then> <block>{
                        <comment type="block">/* End of cases, but count default as a case. */</comment>
                        <expr_stmt><expr><name>off2</name> = 0</expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_PCDELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>off2</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></for>

                <comment type="block">/*
                 * Allocate table and rescan the cases using their srcnotes,
                 * stashing each case's delta from switch top in table[i].key,
                 * and the distance to its statements in table[i].offset.
                 */</comment>
                <expr_stmt><expr><name>table</name> = (<name>TableEntry</name> *)
                    <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>ncases</name> * sizeof *<name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>off2</name> = <name>off</name></expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ncases</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>pc2</name> += <name>off2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc2</name> == <name>JSOP_CASE</name> || *<name>pc2</name> == <name>JSOP_DEFAULT</name> ||
                                 *<name>pc2</name> == <name>JSOP_CASEX</name> || *<name>pc2</name> == <name>JSOP_DEFAULTX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>caseOff</name> = <name>pc2</name> - <name>pc</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr>(<name>jsint</name>) <name>caseOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>offset</name> = <name>caseOff</name> + <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>*<name>pc2</name> == <name>JSOP_CASE</name> || *<name>pc2</name> == <name>JSOP_CASEX</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_PCDELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>off2</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>

                <comment type="block">/*
                 * Find offset of default code by fetching the default offset
                 * from the end of table.  JSOP_CONDSWITCH always has a default
                 * case at the end.
                 */</comment>
                <expr_stmt><expr><name>off</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>ncases</name>-1</expr>]</index></name>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> = <name>pc</name> + <name>off</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>off</name> += <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>ok</name> = <call><name>DecompileSwitch</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>ncases</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>off</name></expr></argument>,
                                     <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_CASE</name></expr>:
              </case><case>case <expr><name>JSOP_CASEX</name></expr>:
              <block>{
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>lval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tcase %s:\n"</expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_STRICTEQ</name></expr>:
              </case><case>case <expr><name>JSOP_STRICTNE</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %c== %s"</expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>, <argument><expr>(<name>op</name> == <name>JSOP_STRICTEQ</name>) ? '=' : '!'</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_CLOSURE</name></expr>:
                <expr_stmt><expr><call><name>LOAD_FUNCTION</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <goto>goto <name>do_function</name>;</goto>
                <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_EXPORT_IMPORT</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_EXPORTALL</name></expr>:
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\texport *;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_EXPORTNAME</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\texport %s;\n"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_IMPORTALL</name></expr>:
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\timport %s.*;\n"</expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_IMPORTPROP</name></expr>:
              <label><name>do_importprop</name>:</label>
                <expr_stmt><expr><call><name>GET_ATOM_QUOTE_AND_FMT</name><argument_list>(<argument><expr>"\timport %s[%s];\n"</expr></argument>,
                                       <argument><expr>"\timport %s.%s;\n"</expr></argument>,
                                       <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_IMPORTELEM</name></expr>:
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETELEM</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>lastop</name></expr></argument>)</argument_list></call> == <name>JOF_XMLNAME</name></expr>)</condition><then>
                    <goto>goto <name>do_importprop</name>;</goto></then></if>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\timport %s[%s];\n"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_EXPORT_IMPORT */</comment>

              </case><case>case <expr><name>JSOP_TRAP</name></expr>:
                <expr_stmt><expr><name>op</name> = <call><name>JS_GetTrapOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_LIMIT</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>saveop</name> = <name>op</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>pc</name> = <name>op</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DECOMPILE_CODE</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>pc</name> = <name>JSOP_TRAP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_NEWINIT</name></expr>:
              <block>{
                <expr_stmt><expr><name>i</name> = <call><name>GET_INT8</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>i</name> == <name>JSProto_Array</name> || <name>i</name> == <name>JSProto_Object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>todo</name> = <name><name>ss</name>-&gt;<name>sprinter</name>.<name>offset</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
                <expr_stmt><expr><name>op</name> = (<name>JSOp</name>)<name><name>pc</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_DEFSHARP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> = <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"#%u="</expr></argument>,
                               <argument><expr>(<name>unsigned</name>) (<name>jsint</name>) <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SHARP_VARS */</comment>
                <if>if <condition>(<expr><name>i</name> == <name>JSProto_Array</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>++<name><name>ss</name>-&gt;<name>inArrayInit</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"["</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"{"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>NULL</name></expr>;</return></then></if>
                }</block></else></if>
                <break>break;</break>
              }</block>

              </case><case>case <expr><name>JSOP_ENDINIT</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>JSBool</name></type> <name>inArray</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>           <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Skip any #n= prefix to find the opening bracket. */</comment>
                <for>for (<init><expr><name>xval</name> = <name>rval</name></expr>;</init> <condition><expr>*<name>xval</name> != '[' &amp;&amp; *<name>xval</name> != '{'</expr>;</condition> <incr><expr><name>xval</name>++</expr></incr>)
                    <continue>continue;</continue></for>
                <expr_stmt><expr><name>inArray</name> = (*<name>xval</name> == '[')</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>inArray</name></expr>)</condition><then>
                    <expr_stmt><expr>--<name><name>ss</name>-&gt;<name>inArrayInit</name></name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%c"</expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>,
                              <argument><expr>(<name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_CONTINUE</name>) ? ", " : ""</expr></argument>,
                              <argument><expr><name>inArray</name> ? ']' : '}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              }</block>

              <block>{
                <decl_stmt><decl><type><name>JSBool</name></type> <name>isFirst</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>maybeComma</name></decl>;</decl_stmt>

              <case>case <expr><name>JSOP_INITELEM</name></expr>:
                <comment type="block">/* Turn off most parens (all if there's only one initialiser). */</comment>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name>pc</name> + <name>len</name> &lt; <name>endpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>isFirst</name> = (<name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name> - 3</expr>]</index></name> == <name>JSOP_NEWINIT</name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>isFirst</name> &amp;&amp;
                      <call><name>GetStr</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>top</name></name> - 2</expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index> == '0' &amp;&amp;
                      (<name>JSOp</name>) <name><name>pc</name><index>[<expr><name>len</name></expr>]</index></name> == <name>JSOP_ENDINIT</name>)
                     ? <name>JSOP_NOP</name>
                     : <name>JSOP_SETNAME</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Turn off all parens for xval and lval, which we control. */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>xval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_INITPROP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>atom</name> = <name>NULL</name></expr>;</expr_stmt>
                    <goto>goto <name>do_initprop</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name>maybeComma</name> = <name>isFirst</name> ? "" : ", "</expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%s"</expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>,
                              <argument><expr><name>maybeComma</name></expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_INITPROP</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>xval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call>(<name>jschar</name>)
                                   <argument_list>(<argument><expr><call><name>ATOM_IS_IDENTIFIER</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call> ? 0 : '\''</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>xval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>isFirst</name> = (<name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name> - 2</expr>]</index></name> == <name>JSOP_NEWINIT</name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* fall through */</comment>

              <label><name>do_initprop</name>:</label>
                <expr_stmt><expr><name>maybeComma</name> = <name>isFirst</name> ? "" : ", "</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OLD_GETTER_SETTER</name></cpp:ifdef>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%s%s%s%s%s:%s"</expr></argument>,
                              <argument><expr><name>lval</name></expr></argument>,
                              <argument><expr><name>maybeComma</name></expr></argument>,
                              <argument><expr><name>xval</name></expr></argument>,
                              <argument><expr>(<name>lastop</name> == <name>JSOP_GETTER</name> || <name>lastop</name> == <name>JSOP_SETTER</name>)
                              ? " " : ""</expr></argument>,
                              <argument><expr>(<name>lastop</name> == <name>JSOP_GETTER</name>) ? <name>js_getter_str</name> :
                              (<name>lastop</name> == <name>JSOP_SETTER</name>) ? <name>js_setter_str</name> :
                              ""</expr></argument>,
                              <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <if>if <condition>(<expr><name>lastop</name> == <name>JSOP_GETTER</name> || <name>lastop</name> == <name>JSOP_SETTER</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<name>atom</name> ||
                        !<call><name>ATOM_IS_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call> ||
                        !<call><name>ATOM_IS_IDENTIFIER</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call> ||
                        <call><name>ATOM_IS_KEYWORD</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call> ||
                        (<name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>+1</expr>]</index></name> != <name>JSOP_ANONFUNOBJ</name> &amp;&amp;
                         <name><name>ss</name>-&gt;<name>opcodes</name><index>[<expr><name><name>ss</name>-&gt;<name>top</name></name>+1</expr>]</index></name> != <name>JSOP_NAMEDFUNOBJ</name>)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%s %s: %s"</expr></argument>,
                                      <argument><expr><name>lval</name></expr></argument>,
                                      <argument><expr><name>maybeComma</name></expr></argument>,
                                      <argument><expr><name>xval</name></expr></argument>,
                                      <argument><expr>(<name>lastop</name> == <name>JSOP_GETTER</name>) ? <name>js_getter_str</name> :
                                      (<name>lastop</name> == <name>JSOP_SETTER</name>) ? <name>js_setter_str</name> :
                                      ""</expr></argument>,
                                      <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>rval</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if>if <condition>(<expr>*<name>rval</name> == '('</expr>)</condition><then>
                            <expr_stmt><expr>++<name>rval</name></expr>, <expr>--<name>end</name></expr>;</expr_stmt></then></if>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>js_function_str</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr><name><name>rval</name><index>[<expr>8</expr>]</index></name> == ' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rval</name> += 8 + 1</expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>end</name> ? *<name>end</name> == ')' : <name><name>end</name><index>[<expr>-1</expr>]</index></name> == '}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%s %s%s%.*s"</expr></argument>,
                                      <argument><expr><name>lval</name></expr></argument>,
                                      <argument><expr><name>maybeComma</name></expr></argument>,
                                      <argument><expr>(<name>lastop</name> == <name>JSOP_GETTER</name>)
                                      ? <name>js_get_str</name> : <name>js_set_str</name></expr></argument>,
                                      <argument><expr><name>xval</name></expr></argument>,
                                      <argument><expr>(<name><name>rval</name><index>[<expr>0</expr>]</index></name> != '(') ? " " : ""</expr></argument>,
                                      <argument><expr><name>end</name> - <name>rval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s%s%s: %s"</expr></argument>,
                                  <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>maybeComma</name></expr></argument>, <argument><expr><name>xval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <break>break;</break>
              </case>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_DEFSHARP</name></expr>:
                <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"#%u=%s"</expr></argument>, <argument><expr>(<name>unsigned</name>) <name>i</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_USESHARP</name></expr>:
                <expr_stmt><expr><name>i</name> = (<name>jsint</name>) <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"#%u#"</expr></argument>, <argument><expr>(<name>unsigned</name>) <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SHARP_VARS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DEBUGGER_KEYWORD</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_DEBUGGER</name></expr>:
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\tdebugger;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DEBUGGER_KEYWORD */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
              </case><case>case <expr><name>JSOP_STARTXML</name></expr>:
              </case><case>case <expr><name>JSOP_STARTXMLEXPR</name></expr>:
                <expr_stmt><expr><name>inXML</name> = <name>op</name> == <name>JSOP_STARTXML</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_DEFXMLNS</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t%s %s %s = %s;\n"</expr></argument>,
                          <argument><expr><name>js_default_str</name></expr></argument>, <argument><expr><name>js_xml_str</name></expr></argument>, <argument><expr><name>js_namespace_str</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ANYNAME</name></expr>:
                <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>JSOP_ANYNAME_LENGTH</name></expr>]</index></name> == <name>JSOP_TOATTRNAME</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>len</name> += <name>JSOP_TOATTRNAME_LENGTH</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"@*"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"*"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_QNAMEPART</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>JSOP_QNAMEPART_LENGTH</name></expr>]</index></name> == <name>JSOP_TOATTRNAME</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>saveop</name> = <name>JSOP_TOATTRNAME</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name> += <name>JSOP_TOATTRNAME_LENGTH</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lval</name> = "@"</expr>;</expr_stmt>
                    <goto>goto <name>do_qname</name>;</goto>
                }</block></then></if>
                <goto>goto <name>do_name</name>;</goto>

              </case><case>case <expr><name>JSOP_QNAMECONST</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>RETRACT</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s::%s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_QNAME</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s::[%s]"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_TOATTRNAME</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>           <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"@[%s]"</expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_TOATTRVAL</name></expr>:
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ADDATTRNAME</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s %s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* This gets reset by all XML tag expressions. */</comment>
                <expr_stmt><expr><name>quoteAttr</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ADDATTRVAL</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>quoteAttr</name></expr>)</condition><then>
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s=\"%s\""</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_BINDXMLNAME</name></expr>:
                <comment type="block">/* Leave the name stacked and push a dummy string. */</comment>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_SETXMLNAME</name></expr>:
                <comment type="block">/* Pop the r.h.s., the dummy string, and the name. */</comment>
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>) <call><name>PopOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>do_setlval</name>;</goto>

              </case><case>case <expr><name>JSOP_XMLELTEXPR</name></expr>:
              </case><case>case <expr><name>JSOP_XMLTAGEXPR</name></expr>:
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"{%s}"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>inXML</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <comment type="block">/* If we're an attribute value, we shouldn't quote this. */</comment>
                <expr_stmt><expr><name>quoteAttr</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_TOXMLLIST</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>           <comment type="block">/* turn off parens */</comment>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"&lt;&gt;%s&lt;/&gt;"</expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>inXML</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_FOREACH</name></expr>:
                <expr_stmt><expr><name>foreach</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_TOXML</name></expr>:
              </case><case>case <expr><name>JSOP_CALLXMLNAME</name></expr>:
              </case><case>case <expr><name>JSOP_XMLNAME</name></expr>:
              </case><case>case <expr><name>JSOP_FILTER</name></expr>:
                <comment type="block">/* These ops indicate the end of XML expressions. */</comment>
                <expr_stmt><expr><name>inXML</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_ENDFILTER</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s.(%s)"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_DESCENDANTS</name></expr>:
                <expr_stmt><expr><name>rval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>POP_STR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"%s..%s"</expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_XMLOBJECT</name></expr>:
                <expr_stmt><expr><call><name>LOAD_OBJECT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"&lt;xml address='%p'&gt;"</expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_XMLCDATA</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"&lt;![CDATA["</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>DONT_ESCAPE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"]]&gt;"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_XMLCOMMENT</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"&lt;!--"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>DONT_ESCAPE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"--&gt;"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_XMLPI</name></expr>:
                <expr_stmt><expr><call><name>LOAD_ATOM</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rval</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>POP_STR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>rval</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"&lt;?"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = <call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &amp;&amp;
                     (*<name>rval</name> == '\0' ||
                      (<call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &gt;= 0 &amp;&amp;
                       <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>"?&gt;"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GETFUNNS</name></expr>:
                <expr_stmt><expr><name>todo</name> = <call><name>SprintPut</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>js_function_str</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

              </case><default>default:
                <expr_stmt><expr><name>todo</name> = -2</expr>;</expr_stmt>
                <break>break;</break>
            </default>}</block></switch>
        }</block></else></if>

        <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then> <block>{
            <comment type="block">/* -2 means "don't push", -1 means reported error. */</comment>
            <if>if <condition>(<expr><name>todo</name> == -1</expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>saveop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_CALLOP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>todo</name> = <call><name>Sprint</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>todo</name> &lt; 0 || !<call><name>PushOff</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name>todo</name></expr></argument>, <argument><expr><name>saveop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if>

        <expr_stmt><expr><name>pc</name> += <name>len</name></expr>;</expr_stmt>
    }</block></while>

<comment type="block">/*
 * Undefine local macros.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>inXML</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DECOMPILE_CODE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NEXT_OP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>POP_STR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOCAL_ASSERT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ATOM_IS_IDENTIFIER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_QUOTE_AND_FMT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_ATOM_QUOTE_AND_FMT</name></cpp:undef>

    <return>return <expr><name>pc</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_DecompileCode</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>len</name></decl></param>,
                 <param><decl><type><name>uintN</name></type> <name>pcdepth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SprintStack</name></type> <name>ss</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>oldscript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>last</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>depth</name> = <name><name>script</name>-&gt;<name>depth</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pcdepth</name> &lt;= <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize a sprinter for use with the offset stack. */</comment>
    <expr_stmt><expr><name>cx</name> = <name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>InitSprintStack</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr><name>jp</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <comment type="block">/*
     * If we are called from js_DecompileValueGenerator with a portion of
     * script's bytecode that starts with a non-zero model stack depth given
     * by pcdepth, attempt to initialize the missing string offsets in ss to
     * |spindex| negative indexes from fp-&gt;sp for the activation fp in which
     * the error arose.
     *
     * See js_DecompileValueGenerator for how its |spindex| parameter is used,
     * and see also GetOff, which makes use of the ss.offsets[i] &lt; -1 that are
     * potentially stored below.
     */</comment>
    <expr_stmt><expr><name><name>ss</name>.<name>top</name></name> = <name>pcdepth</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pcdepth</name> != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>;</decl_stmt>

        <for>for (<init><expr><name>fp</name> = <name><name>cx</name>-&gt;<name>fp</name></name></expr>;</init> <condition><expr><name>fp</name> &amp;&amp; !<name><name>fp</name>-&gt;<name>script</name></name></expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>)
            <continue>continue;</continue></for>
        <expr_stmt><expr><name>top</name> = <name>fp</name> ? <name><name>fp</name>-&gt;<name>sp</name></name> - <name><name>fp</name>-&gt;<name>spbase</name></name> : 0</expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>pcdepth</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>ss</name>.<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ss</name>.<name>opcodes</name><index>[<expr><name>i</name></expr>]</index></name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name>fp</name> &amp;&amp; <name><name>fp</name>-&gt;<name>pc</name></name> == <name>pc</name> &amp;&amp; (<name>uintN</name>)<name>top</name> == <name>pcdepth</name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>pcdepth</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>genpc</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>off</name> = (<name>intN</name>)<name>i</name> - (<name>intN</name>)<name>depth</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>genpc</name> = (<name>jsbytecode</name> *) <name><name>fp</name>-&gt;<name>spbase</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>JS_UPTRDIFF</name><argument_list>(<argument><expr><name>genpc</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>)</argument_list></call> &lt; <name><name>script</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ss</name>.<name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> += (<name>ptrdiff_t</name>)<name>i</name> - <name>top</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ss</name>.<name>opcodes</name><index>[<expr><name>i</name></expr>]</index></name> = *<name>genpc</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Call recursive subroutine to do the hard work. */</comment>
    <expr_stmt><expr><name>oldscript</name> = <name><name>jp</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name>script</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>Decompile</name><argument_list>(<argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name>oldscript</name></expr>;</expr_stmt>

    <comment type="block">/* If the given code didn't empty the stack, do it now. */</comment>
    <if>if <condition>(<expr><name><name>ss</name>.<name>top</name></name></expr>)</condition><then> <block>{
        <do>do <block>{
            <expr_stmt><expr><name>last</name> = <call><name>OFF2STR</name><argument_list>(<argument><expr>&amp;<name><name>ss</name>.<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>PopOff</name><argument_list>(<argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr><name><name>ss</name>.<name>top</name></name> &gt; <name>pcdepth</name></expr>)</condition>;</do>
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<label><name>out</name>:</label>
    <comment type="block">/* Free all temporary stuff allocated under this call. */</comment>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_DecompileScript</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_DecompileCode</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr>(<name>uintN</name>)<name><name>script</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>native_code_str</name><index>[]</index></name> <init>= <expr>"\t[native code]\n"</expr></init></decl>;</decl_stmt>

<function><type><name>JSBool</name></type>
<name>js_DecompileFunctionBody</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>jp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>native_code_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>script</name> = <name><name>jp</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr>;</expr_stmt>
    <return>return <expr><call><name>js_DecompileCode</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr>(<name>uintN</name>)<name><name>script</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_DecompileFunction</name><parameter_list>(<param><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>endpc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fun</name> = <name><name>jp</name>-&gt;<name>fun</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>jp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If pretty, conform to ECMA-262 Edition 3, 15.3.4.2, by decompiling a
     * FunctionDeclaration.  Otherwise, check the JSFUN_LAMBDA flag and force
     * an expression by parenthesizing.
     */</comment>
    <if>if <condition>(<expr><name><name>jp</name>-&gt;<name>pretty</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<name><name>jp</name>-&gt;<name>grouped</name></name> &amp;&amp; (<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_LAMBDA</name>)</expr>)</condition><then>
            <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"("</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
    <if>if <condition>(<expr><call><name>JSFUN_GETTER_TEST</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"%s "</expr></argument>, <argument><expr><name>js_getter_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name>JSFUN_SETTER_TEST</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"%s "</expr></argument>, <argument><expr><name>js_setter_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

    <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"%s "</expr></argument>, <argument><expr><name>js_function_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>atom</name></name> &amp;&amp; !<call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"("</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>") {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>native_code_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_HAS_DESTRUCTURING</name></cpp:ifdef>
        <decl_stmt><decl><type><name>SprintStack</name></type> <name>ss</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Print the parameters. */</comment>
        <expr_stmt><expr><name>pc</name> = <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name/></name>main</expr>;</expr_stmt>
        <expr_stmt><expr><name>endpc</name> = <name>pc</name> + <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_HAS_DESTRUCTURING</name></cpp:ifdef>
        <comment type="block">/* Skip JSOP_GENERATOR in case of destructuring parameters. */</comment>
        <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_GENERATOR</name></expr>)</condition><then>
            <expr_stmt><expr><name>pc</name> += <name>JSOP_GENERATOR_LENGTH</name></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name><name>ss</name>.<name>printer</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fun</name>-&gt;<name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><name>param</name> = <call><name>GetSlotAtom</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_ASSERT</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>LOCAL_ASSERT_RV(expr, JS_FALSE)</cpp:value></cpp:define>

            <if>if <condition>(<expr>!<name>param</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>todo</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lval</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_GETARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>JSOP_GETARG_LENGTH</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_DUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>ss</name>.<name>printer</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <call><name>InitSprintStack</name><argument_list>(<argument><expr><name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name></name></expr></argument>, <argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr><name>jp</name></expr></argument>,
                                         <argument><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                        <break>break;</break></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>pc</name> = <call><name>DecompileDestructuring</name><argument_list>(<argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>endpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>LOCAL_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>JSOP_POP_LENGTH</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lval</name> = <call><name>PopStr</name><argument_list>(<argument><expr>&amp;<name>ss</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>todo</name> = <call><name>SprintCString</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>todo</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <continue>continue;</continue>
            }</block></then></if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOCAL_ASSERT</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if>if <condition>(<expr>!<call><name>QuoteString</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name></name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_HAS_DESTRUCTURING</name></cpp:ifdef>
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>script</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>jp</name>-&gt;<name>sprinter</name>.<name>context</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_EXPR_CLOSURE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>") "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>") {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> += 4</expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>len</name> = <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>code</name></name> + <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>length</name></name> - <name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>js_DecompileCode</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>len</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!(<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_EXPR_CLOSURE</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>jp</name>-&gt;<name>indent</name></name> -= 4</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_printf</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>"\t}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr>!<name><name>jp</name>-&gt;<name>pretty</name></name> &amp;&amp; !<name><name>jp</name>-&gt;<name>grouped</name></name> &amp;&amp; (<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_LAMBDA</name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>js_puts</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LOCAL_ASSERT_RV</name></cpp:undef>

<function><type><name>char</name> *</type>
<name>js_DecompileValueGenerator</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>,
                           <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl>, *<decl><type ref="prev"/><name>down</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>begin</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name> *</type><name>sp</name></decl>, *<decl><type ref="prev"/><name>spbase</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>pcdepth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>oplen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrinter</name> *</type><name>jp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>spindex</name> &lt; 0 ||
              <name>spindex</name> == <name>JSDVG_IGNORE_STACK</name> ||
              <name>spindex</name> == <name>JSDVG_SEARCH_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>fp</name> = <name><name>cx</name>-&gt;<name>fp</name></name></expr>;</init> <condition><expr><name>fp</name> &amp;&amp; !<name><name>fp</name>-&gt;<name>script</name></name></expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>)
        <continue>continue;</continue></for>
    <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
        <goto>goto <name>do_fallback</name>;</goto></then></if>

    <comment type="block">/* Try to find sp's generating pc depth slots under it on the stack. */</comment>
    <expr_stmt><expr><name>pc</name> = <name><name>fp</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> = <name><name>fp</name>-&gt;<name>sp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spbase</name> = <name><name>fp</name>-&gt;<name>spbase</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call>(<name>uintN</name>)<argument_list>(<argument><expr><name>sp</name> - <name>spbase</name></expr></argument>)</argument_list></call> &gt; <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>depth</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Preparing to make an internal invocation, using an argv stack
         * segment pushed just above fp's operand stack space.  Such an argv
         * stack has no generating pc "basement", so we must fall back.
         */</comment>
        <goto>goto <name>do_fallback</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>spindex</name> == <name>JSDVG_SEARCH_STACK</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Current frame is native: look under it for a scripted call
             * in which a decompilable bytecode string that generated the
             * value as an actual argument might exist.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>script</name></name> &amp;&amp; !(<name><name>fp</name>-&gt;<name>fun</name></name> &amp;&amp; <call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>down</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>down</name></expr>)</condition><then>
                <goto>goto <name>do_fallback</name>;</goto></then></if>
            <expr_stmt><expr><name>script</name> = <name><name>down</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>spbase</name> = <name><name>down</name>-&gt;<name>spbase</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>base</name> = <name><name>fp</name>-&gt;<name>argv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>limit</name> = <name>base</name> + <name><name>fp</name>-&gt;<name>argc</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * This should be a script activation, either a top-level
             * script or a scripted function.  But be paranoid about calls
             * to js_DecompileValueGenerator from code that hasn't fully
             * initialized a (default-all-zeroes) frame.
             */</comment>
            <expr_stmt><expr><name>script</name> = <name><name>fp</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>spbase</name> = <name>base</name> = <name><name>fp</name>-&gt;<name>spbase</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>limit</name> = <name><name>fp</name>-&gt;<name>sp</name></name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/*
         * Pure paranoia about default-zeroed frames being active while
         * js_DecompileValueGenerator is called.  It can't hurt much now;
         * error reporting performance is not an issue.
         */</comment>
        <if>if <condition>(<expr>!<name>script</name> || !<name>base</name> || !<name>limit</name></expr>)</condition><then>
            <goto>goto <name>do_fallback</name>;</goto></then></if>

        <comment type="block">/*
         * Try to find operand-generating pc depth slots below sp.
         *
         * In the native case, we know the arguments have generating pc's
         * under them, on account of fp-&gt;down-&gt;script being non-null: all
         * compiled scripts get depth slots for generating pc's allocated
         * upon activation, at the top of js_Interpret.
         *
         * In the script or scripted function case, the same reasoning
         * applies to fp rather than to fp-&gt;down.
         *
         * We search from limit to base to find the most recently calculated
         * value matching v under assumption that it is it that caused
         * exception, see bug 328664.
         */</comment>
        <for>for (<init><expr><name>sp</name> = <name>limit</name></expr>;</init><condition>;</condition><incr/>) <block>{
            <if>if <condition>(<expr><name>sp</name> &lt;= <name>base</name></expr>)</condition><then>
                <goto>goto <name>do_fallback</name>;</goto></then></if>
            <expr_stmt><expr>--<name>sp</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>sp</name> == <name>v</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>depth</name> = (<name>intN</name>)<name><name>script</name>-&gt;<name>depth</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sp</name> -= <name>depth</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = (<name>jsbytecode</name> *) *<name>sp</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * At this point, pc may or may not be null, i.e., we could be in
         * a script activation, or we could be in a native frame that was
         * called by another native function.  Check pc and script.
         */</comment>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <goto>goto <name>do_fallback</name>;</goto></then></if>
        <expr_stmt><expr><name>script</name> = <name><name>fp</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then>
            <goto>goto <name>do_fallback</name>;</goto></then></if>

        <if>if <condition>(<expr><name>spindex</name> != <name>JSDVG_IGNORE_STACK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>spindex</name> &lt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>depth</name> = (<name>intN</name>)<name><name>script</name>-&gt;<name>depth</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>JS_HAS_NO_SUCH_METHOD</name></expr></cpp:if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>-<name>depth</name> &lt;= <name>spindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>sp</name> = <name><name>fp</name>-&gt;<name>sp</name></name> + <name>spindex</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call>(<name>jsuword</name>) <argument_list>(<argument><expr><name>sp</name> - <name><name>fp</name>-&gt;<name>spbase</name></name></expr></argument>)</argument_list></call> &lt; (<name>jsuword</name>) <name>depth</name></expr>)</condition><then>
                <expr_stmt><expr><name>pc</name> = (<name>jsbytecode</name> *) *(<name>sp</name> - <name>depth</name>)</expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></else></if>

    <comment type="block">/*
     * Again, be paranoid, this time about possibly loading an invalid pc
     * from fp-&gt;sp[spindex - script-&gt;depth)].
     */</comment>
    <if>if <condition>(<expr><call><name>JS_UPTRDIFF</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>)</argument_list></call> &gt;= (<name>jsuword</name>)<name><name>script</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pc</name> = <name><name>fp</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <goto>goto <name>do_fallback</name>;</goto></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>op</name> == <name>JSOP_TRAP</name></expr>)</condition><then>
        <expr_stmt><expr><name>op</name> = <call><name>JS_GetTrapOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* None of these stack-writing ops generates novel values. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> != <name>JSOP_CASE</name> &amp;&amp; <name>op</name> != <name>JSOP_CASEX</name> &amp;&amp;
              <name>op</name> != <name>JSOP_DUP</name> &amp;&amp; <name>op</name> != <name>JSOP_DUP2</name> &amp;&amp;
              <name>op</name> != <name>JSOP_SWAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * |this| could convert to a very long object initialiser, so cite it by
     * its keyword name instead.
     */</comment>
    <if>if <condition>(<expr><name>op</name> == <name>JSOP_THIS</name></expr>)</condition><then>
        <return>return <expr><call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_this_str</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/*
     * JSOP_BINDNAME is special: it generates a value, the base object of a
     * reference.  But if it is the generating op for a diagnostic produced by
     * js_DecompileValueGenerator, the name being bound is irrelevant.  Just
     * fall back to the base object.
     */</comment>
    <if>if <condition>(<expr><name>op</name> == <name>JSOP_BINDNAME</name></expr>)</condition><then>
        <goto>goto <name>do_fallback</name>;</goto></then></if>

    <comment type="block">/* NAME ops are self-contained, others require left or right context. */</comment>
    <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>begin</name> = <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>pc</name> + <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>JOF_MODE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name>JOF_PROP</name></expr>:
      </case><case>case <expr><name>JOF_ELEM</name></expr>:
      </case><case>case <expr><name>JOF_XMLNAME</name></expr>:
      </case><case>case <expr>0</expr>:
        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>sn</name></expr>)</condition><then>
            <goto>goto <name>do_fallback</name>;</goto></then></if>
        <switch>switch <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>SRC_PCBASE</name></expr>:
            <expr_stmt><expr><name>begin</name> -= <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>SRC_PCDELTA</name></expr>:
            <expr_stmt><expr><name>end</name> = <name>begin</name> + <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>begin</name> += <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:
            <goto>goto <name>do_fallback</name>;</goto>
        </default>}</block></switch>
        <break>break;</break>
      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>
    <expr_stmt><expr><name>len</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> &lt;= 0</expr>)</condition><then>
        <goto>goto <name>do_fallback</name>;</goto></then></if>

    <comment type="block">/*
     * Walk forward from script-&gt;main and compute starting stack depth.
     * FIXME: Code to compute oplen copied from js_Disassemble1 and reduced.
     * FIXME: Optimize to use last empty-stack sequence point.
     */</comment>
    <expr_stmt><expr><name>pcdepth</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>pc</name> = <name><name>script</name>-&gt;<name/></name>main</expr>;</init> <condition><expr><name>pc</name> &lt; <name>begin</name></expr>;</condition> <incr><expr><name>pc</name> += <name>oplen</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>uint32</name></type> <name>type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>intN</name></type> <name>nuses</name></decl>, <decl><type ref="prev"/><name>ndefs</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_TRAP</name></expr>)</condition><then>
            <expr_stmt><expr><name>op</name> = <call><name>JS_GetTrapOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>oplen</name> = <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>op</name> == <name>JSOP_POPN</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pcdepth</name> -= <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/*
         * A (C ? T : E) expression requires skipping either T (if begin is in
         * E) or both T and E (if begin is after the whole expression) before
         * adjusting pcdepth based on the JSOP_IFEQ or JSOP_IFEQX at pc that
         * tests condition C.  We know that the stack depth can't change from
         * what it was with C on top of stack.
         */</comment>
        <expr_stmt><expr><name>sn</name> = <call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_COND</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>jmpoff</name></decl>, <decl><type ref="prev"/><name>jmplen</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>jmpoff</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pc</name> + <name>jmpoff</name> &lt; <name>begin</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pc</name> += <name>jmpoff</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_GOTO</name> || <name>op</name> == <name>JSOP_GOTOX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>oplen</name> = <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>jmplen</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>pc</name> + <name>jmplen</name> &lt; <name>begin</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>oplen</name> = (<name>uintN</name>) <name>jmplen</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="block">/*
                 * Ok, begin lies in E.  Manually pop C off the model stack,
                 * since we have moved beyond the IFEQ now.
                 */</comment>
                <expr_stmt><expr>--<name>pcdepth</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><name>type</name> = <call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
          <case>case <expr><name>JOF_TABLESWITCH</name></expr>:
          </case><case>case <expr><name>JOF_TABLESWITCHX</name></expr>:
          <block>{
            <decl_stmt><decl><type><name>jsint</name></type> <name>jmplen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>jmplen</name> = (<name>type</name> == <name>JOF_TABLESWITCH</name>) ? <name>JUMP_OFFSET_LEN</name>
                                               : <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>low</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>high</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = <name>low</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>high</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt></for>
            <expr_stmt><expr><name>oplen</name> = 1 + <name>pc2</name> - <name>pc</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block>

          </case><case>case <expr><name>JOF_LOOKUPSWITCH</name></expr>:
          </case><case>case <expr><name>JOF_LOOKUPSWITCHX</name></expr>:
          <block>{
            <decl_stmt><decl><type><name>jsint</name></type> <name>jmplen</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsatomid</name></type> <name>npairs</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>jmplen</name> = (<name>type</name> == <name>JOF_LOOKUPSWITCH</name>) ? <name>JUMP_OFFSET_LEN</name>
                                                : <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>npairs</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc2</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>npairs</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>pc2</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc2</name> += <name>jmplen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>npairs</name>--</expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>oplen</name> = 1 + <name>pc2</name> - <name>pc</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block>

          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>

        <if>if <condition>(<expr><name>sn</name> &amp;&amp; <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_HIDDEN</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <expr_stmt><expr><name>nuses</name> = <name><name>cs</name>-&gt;<name>nuses</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nuses</name> &lt; 0</expr>)</condition><then> <block>{
            <comment type="block">/* Call opcode pushes [callee, this, argv...]. */</comment>
            <expr_stmt><expr><name>nuses</name> = 2 + <call><name>GET_ARGC</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>JSOP_RETSUB</name></expr>)</condition><then> <block>{
            <comment type="block">/* Pop [exception or hole, retsub pc-index]. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nuses</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nuses</name> = 2</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>JSOP_LEAVEBLOCK</name> || <name>op</name> == <name>JSOP_LEAVEBLOCKEXPR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nuses</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nuses</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
        <expr_stmt><expr><name>pcdepth</name> -= <name>nuses</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pcdepth</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ndefs</name> = <name><name>cs</name>-&gt;<name>ndefs</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_FINALLY</name></expr>)</condition><then> <block>{
            <comment type="block">/* Push [exception or hole, retsub pc-index]. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ndefs</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ndefs</name> = 2</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>JSOP_ENTERBLOCK</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ndefs</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GET_OBJECT_FROM_BYTECODE</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == <name>pcdepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ndefs</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>pcdepth</name> += <name>ndefs</name></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name>name</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>jp</name> = <call><name>JS_NEW_PRINTER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"js_DecompileValueGenerator"</expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>jp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>jp</name>-&gt;<name>dvgfence</name></name> = <name>end</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_DecompileCode</name><argument_list>(<argument><expr><name>jp</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>len</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>pcdepth</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>name</name> = (<name><name>jp</name>-&gt;<name>sprinter</name>.<name>base</name></name>) ? <name><name>jp</name>-&gt;<name>sprinter</name>.<name>base</name></name> : (<name>char</name> *) ""</expr>;</expr_stmt>
            <expr_stmt><expr><name>name</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>js_DestroyPrinter</name><argument_list>(<argument><expr><name>jp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>name</name></expr>;</return>

  <label><name>do_fallback</name>:</label>
    <if>if <condition>(<expr>!<name>fallback</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>fallback</name> = <call><name>js_ValueToSource</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>fallback</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr><call><name>js_DeflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSSTRING_CHARS</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>JSSTRING_LENGTH</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
