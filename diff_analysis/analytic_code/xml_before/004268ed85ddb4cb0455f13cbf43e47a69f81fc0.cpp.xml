<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="004268ed85ddb4cb0455f13cbf43e47a69f81fc0.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * Generate CPU-specific bit-size and similar #defines.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CROSS_COMPILE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;prtypes.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_NEVER_INLINE</name></cpp:macro> <cpp:value>__attribute__((noinline))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_NEVER_INLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_C</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>StackGrowthDirection</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>dummy1addr</name></decl></param>)</parameter_list>;</function_decl>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> no_inline(StackGrowthDirection)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name> <name>NS_NEVER_INLINE</name></type> <name>StackGrowthDirection</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>dummy1addr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>dummy2</name></decl>;</decl_stmt>

    <return>return <expr>(&amp;<name>dummy2</name> &lt; <name>dummy1addr</name>) ? -1 : 1</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>dummy1</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#ifndef js_cpucfg___\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define js_cpucfg___\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"/* AUTOMATICALLY GENERATED - DO NOT EDIT */\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CROSS_COMPILE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/*
     * Darwin NSPR uses the same MDCPUCFG (_darwin.cfg) for multiple
     * processors, and determines which processor to configure for based
     * on compiler predefined macros.  We do the same thing here.
     */</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#ifdef __LITTLE_ENDIAN__\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define IS_LITTLE_ENDIAN 1\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#undef  IS_BIG_ENDIAN\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#else\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#undef  IS_LITTLE_ENDIAN\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define IS_BIG_ENDIAN 1\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#endif\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define IS_LITTLE_ENDIAN 1\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#undef  IS_BIG_ENDIAN\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IS_BIG_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#undef  IS_LITTLE_ENDIAN\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define IS_BIG_ENDIAN 1\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Endianess not defined."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <comment type="block">/*
     * We don't handle PDP-endian or similar orders: if a short is big-endian,
     * so must int and long be big-endian for us to generate the IS_BIG_ENDIAN
     * #define and the IS_LITTLE_ENDIAN #undef.
     */</comment>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>big_endian</name> <init>= <expr>0</expr></init>, <name>little_endian</name> <init>= <expr>0</expr></init>, <name>ntests</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof> == 2</expr>)</condition><then> <block>{
            <comment type="block">/* force |volatile| here to get rid of any compiler optimisations
             * (var in register etc.) which may be appiled to |auto| vars -
             * even those in |union|s...
             * (|static| is used to get the same functionality for compilers
             * which do not honor |volatile|...).
             */</comment>
            <union><specifier>volatile</specifier> <specifier>static</specifier> union <block>{<public type="default">
                <decl_stmt><decl><type><name>short</name></type> <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
            </public>}</block> <decl><name>u</name></decl>;</union>

            <expr_stmt><expr><name><name>u</name>.<name>i</name></name> = 0x0102</expr>;</expr_stmt>
            <expr_stmt><expr><name>big_endian</name> += (<name><name>u</name>.<name>c</name><index>[<expr>0</expr>]</index></name> == 0x01 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>1</expr>]</index></name> == 0x02)</expr>;</expr_stmt>
            <expr_stmt><expr><name>little_endian</name> += (<name><name>u</name>.<name>c</name><index>[<expr>0</expr>]</index></name> == 0x02 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>1</expr>]</index></name> == 0x01)</expr>;</expr_stmt>
            <expr_stmt><expr><name>ntests</name>++</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> == 4</expr>)</condition><then> <block>{
            <comment type="block">/* force |volatile| here ... */</comment>
            <union><specifier>volatile</specifier> <specifier>static</specifier> union <block>{<public type="default">
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
            </public>}</block> <decl><name>u</name></decl>;</union>

            <expr_stmt><expr><name><name>u</name>.<name>i</name></name> = 0x01020304</expr>;</expr_stmt>
            <expr_stmt><expr><name>big_endian</name> += (<name><name>u</name>.<name>c</name><index>[<expr>0</expr>]</index></name> == 0x01 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>1</expr>]</index></name> == 0x02 &amp;&amp;
                           <name><name>u</name>.<name>c</name><index>[<expr>2</expr>]</index></name> == 0x03 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>3</expr>]</index></name> == 0x04)</expr>;</expr_stmt>
            <expr_stmt><expr><name>little_endian</name> += (<name><name>u</name>.<name>c</name><index>[<expr>0</expr>]</index></name> == 0x04 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>1</expr>]</index></name> == 0x03 &amp;&amp;
                              <name><name>u</name>.<name>c</name><index>[<expr>2</expr>]</index></name> == 0x02 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>3</expr>]</index></name> == 0x01)</expr>;</expr_stmt>
            <expr_stmt><expr><name>ntests</name>++</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> == 8</expr>)</condition><then> <block>{
            <comment type="block">/* force |volatile| here ... */</comment>
            <union><specifier>volatile</specifier> <specifier>static</specifier> union <block>{<public type="default">
                <decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
            </public>}</block> <decl><name>u</name></decl>;</union>

            <comment type="block">/*
             * Write this as portably as possible: avoid 0x0102030405060708L
             * and &lt;&lt;= 32.
             */</comment>
            <expr_stmt><expr><name><name>u</name>.<name>i</name></name> = 0x01020304</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>u</name>.<name>i</name></name> &lt;&lt;= 16</expr>, <expr><name><name>u</name>.<name>i</name></name> &lt;&lt;= 16</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>u</name>.<name>i</name></name> |= 0x05060708</expr>;</expr_stmt>
            <expr_stmt><expr><name>big_endian</name> += (<name><name>u</name>.<name>c</name><index>[<expr>0</expr>]</index></name> == 0x01 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>1</expr>]</index></name> == 0x02 &amp;&amp;
                           <name><name>u</name>.<name>c</name><index>[<expr>2</expr>]</index></name> == 0x03 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>3</expr>]</index></name> == 0x04 &amp;&amp;
                           <name><name>u</name>.<name>c</name><index>[<expr>4</expr>]</index></name> == 0x05 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>5</expr>]</index></name> == 0x06 &amp;&amp;
                           <name><name>u</name>.<name>c</name><index>[<expr>6</expr>]</index></name> == 0x07 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>7</expr>]</index></name> == 0x08)</expr>;</expr_stmt>
            <expr_stmt><expr><name>little_endian</name> += (<name><name>u</name>.<name>c</name><index>[<expr>0</expr>]</index></name> == 0x08 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>1</expr>]</index></name> == 0x07 &amp;&amp;
                              <name><name>u</name>.<name>c</name><index>[<expr>2</expr>]</index></name> == 0x06 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>3</expr>]</index></name> == 0x05 &amp;&amp;
                              <name><name>u</name>.<name>c</name><index>[<expr>4</expr>]</index></name> == 0x04 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>5</expr>]</index></name> == 0x03 &amp;&amp;
                              <name><name>u</name>.<name>c</name><index>[<expr>6</expr>]</index></name> == 0x02 &amp;&amp; <name><name>u</name>.<name>c</name><index>[<expr>7</expr>]</index></name> == 0x01)</expr>;</expr_stmt>
            <expr_stmt><expr><name>ntests</name>++</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>big_endian</name> &amp;&amp; <name>big_endian</name> == <name>ntests</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#undef  IS_LITTLE_ENDIAN\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define IS_BIG_ENDIAN 1\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>little_endian</name> &amp;&amp; <name>little_endian</name> == <name>ntests</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define IS_LITTLE_ENDIAN 1\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#undef  IS_BIG_ENDIAN\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: unknown byte order"
                    "(big_endian=%d, little_endian=%d, ntests=%d)!\n"</expr></argument>,
                    <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><name>little_endian</name></expr></argument>, <argument><expr><name>ntests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></else></if></else></if>
    }</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* CROSS_COMPILE */</comment>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#define JS_STACK_GROWTH_DIRECTION (%d)\n"</expr></argument>, <argument><expr><call><name>StackGrowthDirection</name><argument_list>(<argument><expr>&amp;<name>dummy1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"#endif /* js_cpucfg___ */\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
}</block></function>

</unit>
