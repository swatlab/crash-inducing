<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="008006bde57369f4bb8bee543a4f6a44ba3d96fb.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=2 sw=2 et tw=78:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Novell code.
 *
 * The Initial Developer of the Original Code is Novell Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *     robert@ocallahan.org
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK *****
 */</comment>

<comment type="block">/*
 * structures that represent things to be painted (ordered in z-order),
 * used during painting and hit testing
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NSDISPLAYLIST_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSDISPLAYLIST_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCaret.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Layers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FrameLayerBuilder.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>class</name></type> <name>nsIPresShell</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIContent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIRenderingContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIDeviceContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayTableItem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayItem</name></decl>;</decl_stmt>

<comment type="block">/*
 * An nsIFrame can have many different visual parts. For example an image frame
 * can have a background, border, and outline, the image itself, and a
 * translucent selection overlay. In general these parts can be drawn at
 * discontiguous z-levels; see CSS2.1 appendix E:
 * http://www.w3.org/TR/CSS21/zindex.html
 * 
 * We construct a display list for a frame tree that contains one item
 * for each visual part. The display list is itself a tree since some items
 * are containers for other items; however, its structure does not match
 * the structure of its source frame tree. The display list items are sorted
 * by z-order. A display list can be used to paint the frames, to determine
 * which frame is the target of a mouse event, and to determine what areas
 * need to be repainted when scrolling. The display lists built for each task
 * may be different for efficiency; in particular some frames need special
 * display list items only for event handling, and do not create these items
 * when the display list will be used for painting (the common case). For
 * example, when painting we avoid creating nsDisplayBackground items for
 * frames that don't display a visible background, but for event handling
 * we need those backgrounds because they are not transparent to events.
 * 
 * We could avoid constructing an explicit display list by traversing the
 * frame tree multiple times in clever ways. However, reifying the display list
 * reduces code complexity and reduces the number of times each frame must be
 * traversed to one, which seems to be good for performance. It also means
 * we can share code for painting, event handling and scroll analysis.
 * 
 * Display lists are short-lived; content and frame trees cannot change
 * between a display list being created and destroyed. Display lists should
 * not be created during reflow because the frame tree may be in an
 * inconsistent state (e.g., a frame's stored overflow-area may not include
 * the bounds of all its children). However, it should be fine to create
 * a display list while a reflow is pending, before it starts.
 * 
 * A display list covers the "extended" frame tree; the display list for a frame
 * tree containing FRAME/IFRAME elements can include frames from the subdocuments.
 */</comment>

<comment type="line">// All types are defined in nsDisplayItemTypes.h</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_DISPLAY_DECL_NAME</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>e</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>virtual const char* Name() { return n; } \
  virtual Type GetType() { return e; }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_DISPLAY_DECL_NAME</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>e</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>virtual Type GetType() { return e; }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**
 * This manages a display list and is passed as a parameter to
 * nsIFrame::BuildDisplayList.
 * It contains the parameters that don't change from frame to frame and manages
 * the display list memory using a PLArena. It also establishes the reference
 * coordinate system for all display list items. Some of the parameters are
 * available from the prescontext/presshell, but we copy them into the builder
 * for faster/more convenient access.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayListBuilder</name> <block>{
<label><name>public</name>:</label>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>FramePropertyDescriptor</name> <name>FramePropertyDescriptor</name></expr>;</expr_stmt></typedef>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>FrameLayerBuilder</name> <name>FrameLayerBuilder</name></expr>;</expr_stmt></typedef>

  <comment type="block">/**
   * @param aReferenceFrame the frame at the root of the subtree; its origin
   * is the origin of the reference coordinate system for this display list
   * @param aIsForEvents PR_TRUE if we're creating this list in order to
   * determine which frame is under the mouse position
   * @param aBuildCaret whether or not we should include the caret in any
   * display lists that we make.
   */</comment>
  <macro><name>nsDisplayListBuilder</name><argument_list>(<argument>nsIFrame* aReferenceFrame</argument>, <argument>PRBool aIsForEvents</argument>,
                       <argument>PRBool aBuildCaret</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr>~<call><name>nsDisplayListBuilder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * @return PR_TRUE if the display is being built in order to determine which
   * frame is under the mouse position.
   */</comment>
  <function><type><name>PRBool</name></type> <name>IsForEventDelivery</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mEventDelivery</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * @return PR_TRUE if "painting is suppressed" during page load and we
   * should paint only the background of the document.
   */</comment>
  <function><type><name>PRBool</name></type> <name>IsBackgroundOnly</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIsBackgroundOnly</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Set to PR_TRUE if painting should be suppressed during page load.
   * Set to PR_FALSE if painting should not be suppressed.
   */</comment>
  <function><type><name>void</name></type> <name>SetBackgroundOnly</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIsBackgroundOnly</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mIsBackgroundOnly</name> = <name>aIsBackgroundOnly</name></expr>;</expr_stmt> }</block></function>
  <comment type="block">/**
   * @return PR_TRUE if the currently active BuildDisplayList call is being
   * applied to a frame at the root of a pseudo stacking context. A pseudo
   * stacking context is either a real stacking context or basically what
   * CSS2.1 appendix E refers to with "treat the element as if it created
   * a new stacking context
   */</comment>
  <function><type><name>PRBool</name></type> <name>IsAtRootOfPseudoStackingContext</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIsAtRootOfPseudoStackingContext</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * Indicate that we'll use this display list to analyze the effects
   * of aMovingFrame moving by aMoveDelta. The move has already been
   * applied to the frame tree. Moving frames are not allowed to clip or
   * cover (during ComputeVisibility) non-moving frames. E.g. when we're
   * constructing a display list to see what should be repainted during a
   * scroll operation, we specify the scrolled frame as the moving frame.
   * @param aSaveVisibleRegionOfMovingContent if non-null,
   *   this receives a bounding region for the visible moving content
   * (considering the moving content both before and after the move)
   */</comment>
  <function><type><name>void</name></type> <name>SetMovingFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aMovingFrame</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><name>mMovingFrame</name> = <name>aMovingFrame</name></expr>;</expr_stmt>
  }</block></function>

  <comment type="block">/**
   * @return PR_TRUE if we are doing analysis of moving frames
   */</comment>
  <function><type><name>PRBool</name></type> <name>HasMovingFrames</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mMovingFrame</name> != <name>nsnull</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * @return the frame that was moved
   */</comment>
  <function><type><name>nsIFrame</name>*</type> <name>GetRootMovingFrame</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mMovingFrame</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * @return PR_TRUE if aFrame is, or is a descendant of, the hypothetical
   * moving frame
   */</comment>
  <function_decl><type><name>PRBool</name></type> <name>IsMovingFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * @return the selection that painting should be restricted to (or nsnull
   * in the normal unrestricted case)
   */</comment>
  <function><type><name>nsISelection</name>*</type> <name>GetBoundingSelection</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mBoundingSelection</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * @return the root of the display list's frame (sub)tree, whose origin
   * establishes the coordinate system for the display list
   */</comment>
  <function><type><name>nsIFrame</name>*</type> <name>ReferenceFrame</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mReferenceFrame</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * @return a point pt such that adding pt to a coordinate relative to aFrame
   * makes it relative to ReferenceFrame(), i.e., returns 
   * aFrame-&gt;GetOffsetTo(ReferenceFrame()). It may be optimized to be faster
   * than aFrame-&gt;GetOffsetTo(ReferenceFrame()) (but currently isn't).
   */</comment>
  <function><type><name>nsPoint</name></type> <name>ToReferenceFrame</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><call><name><name>aFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><call><name>ReferenceFrame</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
  <comment type="block">/**
   * When building the display list, the scrollframe aFrame will be "ignored"
   * for the purposes of clipping, and its scrollbars will be hidden. We use
   * this to allow RenderOffscreen to render a whole document without beign
   * clipped by the viewport or drawing the viewport scrollbars.
   */</comment>
  <function><type><name>void</name></type> <name>SetIgnoreScrollFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mIgnoreScrollFrame</name> = <name>aFrame</name></expr>;</expr_stmt> }</block></function>
  <comment type="block">/**
   * Get the scrollframe to ignore, if any.
   */</comment>
  <function><type><name>nsIFrame</name>*</type> <name>GetIgnoreScrollFrame</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIgnoreScrollFrame</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Calling this setter makes us:
   * 1. include all positioned descendant frames in the display list,
   *    wherever they may be positioned (even outside the dirty rects).
   * 2. exclude all leaf frames that does not have the NS_FRAME_SELECTED_CONTENT
   *    bit.
   */</comment>
  <function><type><name>void</name></type> <name>SetSelectedFramesOnly</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mSelectedFramesOnly</name> = <name>PR_TRUE</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>PRBool</name></type> <name>GetSelectedFramesOnly</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mSelectedFramesOnly</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Calling this setter makes us compute accurate visible regions at the cost
   * of performance if regions get very complex.
   */</comment>
  <function><type><name>void</name></type> <name>SetAccurateVisibleRegions</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mAccurateVisibleRegions</name> = <name>PR_TRUE</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>PRBool</name></type> <name>GetAccurateVisibleRegions</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mAccurateVisibleRegions</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Allows callers to selectively override the regular paint suppression checks,
   * so that methods like GetFrameForPoint work when painting is suppressed.
   */</comment>
  <function><type><name>void</name></type> <name>IgnorePaintSuppression</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mIsBackgroundOnly</name> = <name>PR_FALSE</name></expr>;</expr_stmt> }</block></function>
  <comment type="block">/**
   * Call this if we're doing normal painting to the window.
   */</comment>
  <function><type><name>void</name></type> <name>SetPaintingToWindow</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aToWindow</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mIsPaintingToWindow</name> = <name>aToWindow</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>PRBool</name></type> <name>IsPaintingToWindow</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIsPaintingToWindow</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Display the caret if needed.
   */</comment>
  <function><type><name>nsresult</name></type> <name>DisplayCaret</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>,
      <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>GetCaretFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aFrame</name> != <name>frame</name></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name><name>frame</name>-&gt;<name>DisplayCaret</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>, <argument><expr><name>aList</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
  <comment type="block">/**
   * Get the frame that the caret is supposed to draw in.
   * If the caret is currently invisible, this will be null.
   */</comment>
  <function><type><name>nsIFrame</name>*</type> <name>GetCaretFrame</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><call><name>CurrentPresShellState</name><argument_list>()</argument_list></call>-&gt;<name>mCaretFrame</name></expr>;</return>
  }</block></function>
  <comment type="block">/**
   * Get the caret associated with the current presshell.
   */</comment>
  <function_decl><type><name>nsCaret</name>*</type> <name>GetCaret</name><parameter_list>()</parameter_list>;</function_decl>
  <comment type="block">/**
   * Notify the display list builder that we're entering a presshell.
   * aReferenceFrame should be a frame in the new presshell and aDirtyRect
   * should be the current dirty rect in aReferenceFrame's coordinate space.
   */</comment>
  <function_decl><type><name>void</name></type> <name>EnterPresShell</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aReferenceFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * Notify the display list builder that we're leaving a presshell.
   */</comment>
  <function_decl><type><name>void</name></type> <name>LeavePresShell</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aReferenceFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns true if we're currently building a display list that's
   * directly or indirectly under an nsDisplayTransform or SVG
   * foreignObject.
   */</comment>
  <function><type><name>PRBool</name></type> <name>IsInTransform</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mInTransform</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Indicate whether or not we're directly or indirectly under and
   * nsDisplayTransform or SVG foreignObject.
   */</comment>
  <function><type><name>void</name></type> <name>SetInTransform</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInTransform</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mInTransform</name> = <name>aInTransform</name></expr>;</expr_stmt> }</block></function>

  <comment type="block">/**
   * @return PR_TRUE if images have been set to decode synchronously.
   */</comment>
  <function><type><name>PRBool</name></type> <name>ShouldSyncDecodeImages</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mSyncDecodeImages</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * Indicates whether we should synchronously decode images. If true, we decode
   * and draw whatever image data has been loaded. If false, we just draw
   * whatever has already been decoded.
   */</comment>
  <function><type><name>void</name></type> <name>SetSyncDecodeImages</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSyncDecodeImages</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><name>mSyncDecodeImages</name> = <name>aSyncDecodeImages</name></expr>;</expr_stmt>
  }</block></function>

  <comment type="block">/**
   * Helper method to generate background painting flags based on the
   * information available in the display list builder. Currently only
   * accounts for mSyncDecodeImages.
   */</comment>
  <function_decl><type><name>PRUint32</name></type> <name>GetBackgroundPaintFlags</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="block">/**
   * Subtracts aRegion from *aVisibleRegion. We avoid letting
   * aVisibleRegion become overcomplex by simplifying it if necessary ---
   * unless mAccurateVisibleRegions is set, in which case we let it
   * get arbitrarily complex.
   */</comment>
  <function_decl><type><name>void</name></type> <name>SubtractFromVisibleRegion</name><parameter_list>(<param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Mark the frames in aFrames to be displayed if they intersect aDirtyRect
   * (which is relative to aDirtyFrame). If the frames have placeholders
   * that might not be displayed, we mark the placeholders and their ancestors
   * to ensure that display list construction descends into them
   * anyway. nsDisplayListBuilder will take care of unmarking them when it is
   * destroyed.
   */</comment>
  <function_decl><type><name>void</name></type> <name>MarkFramesForDisplayList</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aDirtyFrame</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsFrameList</name>&amp;</type> <name>aFrames</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Return the FrameLayerBuilder.
   */</comment>
  <function><type><name>FrameLayerBuilder</name>*</type> <name>LayerBuilder</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>&amp;<name>mLayerBuilder</name></expr>;</return> }</block></function>
  
  <comment type="block">/**
   * Allocate memory in our arena. It will only be freed when this display list
   * builder is destroyed. This memory holds nsDisplayItems. nsDisplayItem
   * destructors are called as soon as the item is no longer used.
   */</comment>
  <function_decl><type><name>void</name>*</type> <name>Allocate</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>;</function_decl>
  
  <comment type="block">/**
   * A helper class to temporarily set the value of
   * mIsAtRootOfPseudoStackingContext.
   */</comment>
  <decl_stmt><decl><type><name>class</name></type> <name>AutoIsRootSetter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>AutoIsRootSetter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>class</name></type> <name>AutoIsRootSetter</name> <block>{
  <label><name>public</name>:</label>
    <macro><name>AutoIsRootSetter</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>PRBool aIsRoot</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>mBuilder</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>, <macro><name>mOldValue</name><argument_list>(<argument>aBuilder-&gt;mIsAtRootOfPseudoStackingContext</argument>)</argument_list></macro> <expr><block>{ 
      <expr><name><name>aBuilder</name>-&gt;<name>mIsAtRootOfPseudoStackingContext</name></name> = <name>aIsRoot</name></expr>;
    }</block>
    ~<macro><name>AutoIsRootSetter</name><argument_list>()</argument_list></macro> <block>{
      <expr><name><name>mBuilder</name>-&gt;<name>mIsAtRootOfPseudoStackingContext</name></name> = <name>mOldValue</name></expr>;
    }</block>
  <name>private</name>:
    <name>nsDisplayListBuilder</name>* <name>mBuilder</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type>          <name>mOldValue</name></decl>;</decl_stmt>
  }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * A helper class to temporarily set the value of mInTransform.
   */</comment>
  <decl_stmt><decl><type><name>class</name></type> <name>AutoInTransformSetter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>AutoInTransformSetter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>class</name></type> <name>AutoInTransformSetter</name> <block>{
  <label><name>public</name>:</label>
    <macro><name>AutoInTransformSetter</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>PRBool aInTransform</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>mBuilder</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>, <macro><name>mOldValue</name><argument_list>(<argument>aBuilder-&gt;mInTransform</argument>)</argument_list></macro> <expr><block>{ 
      <expr><name><name>aBuilder</name>-&gt;<name>mInTransform</name></name> = <name>aInTransform</name></expr>;
    }</block>
    ~<macro><name>AutoInTransformSetter</name><argument_list>()</argument_list></macro> <block>{
      <expr><name><name>mBuilder</name>-&gt;<name>mInTransform</name></name> = <name>mOldValue</name></expr>;
    }</block>
  <name>private</name>:
    <name>nsDisplayListBuilder</name>* <name>mBuilder</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRPackedBool</name></type>          <name>mOldValue</name></decl>;</decl_stmt>
  }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>  
  
  <comment type="line">// Helpers for tables</comment>
  <function><type><name>nsDisplayTableItem</name>*</type> <name>GetCurrentTableItem</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mCurrentTableItem</name></expr>;</return> }</block></function>
  <function><type><name>void</name></type> <name>SetCurrentTableItem</name><parameter_list>(<param><decl><type><name>nsDisplayTableItem</name>*</type> <name>aTableItem</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mCurrentTableItem</name> = <name>aTableItem</name></expr>;</expr_stmt> }</block></function>

  <macro><name>NS_DECLARE_FRAME_PROPERTY</name><argument_list>(<argument>OutOfFlowDirtyRectProperty</argument>, <argument>nsIFrame::DestroyRect</argument>)</argument_list></macro>

<label><name>private</name>:</label>
  <struct>struct <name>PresShellState</name> <block>{
    <decl_stmt><decl><type><name>nsIPresShell</name>*</type> <name>mPresShell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type>     <name>mCaretFrame</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type>      <name>mFirstFrameMarkedForDisplay</name></decl>;</decl_stmt>
  }</block>;</struct>
  <function><type><name>PresShellState</name>*</type> <name>CurrentPresShellState</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mPresShellStates</name>.<name>Length</name></name><argument_list>()</argument_list></call> &gt; 0</expr></argument>,
                 <argument><expr>"Someone forgot to enter a presshell"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>&amp;<name><name>mPresShellStates</name><index>[<expr><call><name><name>mPresShellStates</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr>]</index></name></expr>;</return>
  }</block></function>

  <decl_stmt><decl><type><name>FrameLayerBuilder</name></type>              <name>mLayerBuilder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type>                      <name>mReferenceFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type>                      <name>mMovingFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type>                      <name>mIgnoreScrollFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLArenaPool</name></type>                    <name>mPool</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsISelection</name>&gt;         <name>mBoundingSelection</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsAutoTArray</name>&lt;<name>PresShellState</name></expr>,<expr>8&gt; <name>mPresShellStates</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsAutoTArray</name>&lt;<name>nsIFrame</name>*</expr>,<expr>100&gt;    <name>mFramesMarkedForDisplay</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsDisplayTableItem</name>*</type>            <name>mCurrentTableItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mBuildCaret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mEventDelivery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mIsBackgroundOnly</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mIsAtRootOfPseudoStackingContext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mSelectedFramesOnly</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mAccurateVisibleRegions</name></decl>;</decl_stmt>
  <comment type="line">// True when we're building a display list that's directly or indirectly</comment>
  <comment type="line">// under an nsDisplayTransform</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mInTransform</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mSyncDecodeImages</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>                   <name>mIsPaintingToWindow</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayItem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayList</name></decl>;</decl_stmt>
<comment type="block">/**
 * nsDisplayItems are put in singly-linked lists rooted in an nsDisplayList.
 * nsDisplayItemLink holds the link. The lists are linked from lowest to
 * highest in z-order.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayItemLink</name> <block>{
  <comment type="line">// This is never instantiated directly, so no need to count constructors and</comment>
  <comment type="line">// destructors.</comment>
<label><name>protected</name>:</label>
  <expr_stmt><expr><call><name>nsDisplayItemLink</name><argument_list>()</argument_list></call> : <macro><name>mAbove</name><argument_list>(<argument>nsnull</argument>)</argument_list></macro> <block>{}</block>
  <name>nsDisplayItem</name>* <name>mAbove</name></expr>;</expr_stmt>  
  
  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>nsDisplayList</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * This is the unit of rendering and event testing. Each instance of this
 * class represents an entity that can be drawn on the screen, e.g., a
 * frame's CSS background, or a frame's text string.
 * 
 * nsDisplayListItems can be containers --- i.e., they can perform hit testing
 * and painting by recursively traversing a list of child items.
 * 
 * These are arena-allocated during display list construction. A typical
 * subclass would just have a frame pointer, so its object would be just three
 * pointers (vtable, next-item, frame).
 * 
 * Display items belong to a list at all times (except temporarily as they
 * move from one list to another).
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayItem</name> : <name>public</name> <name>nsDisplayItemLink</name> <block>{
<expr><name>public</name>:</expr>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>layers</name>::<name>Layer</name> <name>Layer</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>layers</name>::<name>LayerManager</name> <name>LayerManager</name></expr>;</expr_stmt></typedef>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>LayerState</name> <name>LayerState</name></expr>;</expr_stmt></typedef>

  <comment type="line">// This is never instantiated directly (it has pure virtual methods), so no</comment>
  <comment type="line">// need to count constructors and destructors.</comment>
  <expr_stmt><expr><call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>mFrame</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{}</block>
  <name>virtual</name> ~<macro><name>nsDisplayItem</name><argument_list>()</argument_list></macro> <block>{}</block>
  
  <name>void</name>* <name>operator</name> <macro><name>new</name><argument_list>(<argument>size_t aSize</argument>,
                     <argument>nsDisplayListBuilder* aBuilder</argument>)</argument_list></macro> <name>CPP_THROW_NEW</name> <block>{
    <return>return <expr><call><name><name>aBuilder</name>-&gt;<name>Allocate</name></name><argument_list>(<argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></expr></expr_stmt>

<comment type="line">// Contains all the type integers for each display list item type</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDisplayItemTypes.h"</cpp:file></cpp:include>

  <struct>struct <name>HitTestState</name> <block>{
    <expr_stmt><expr>~<macro><name>HitTestState</name><argument_list>()</argument_list></macro> <block>{
      <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mItemBuffer</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr></argument>,
                   <argument><expr>"mItemBuffer should have been cleared"</expr></argument>)</argument_list></call></expr>;
    }</block>
    <name>nsAutoTArray</name>&lt;<name>nsDisplayItem</name>*</expr>, <expr>100&gt; <name>mItemBuffer</name></expr>;</expr_stmt>
  }</block>;</struct>

  <comment type="block">/**
   * Some consecutive items should be rendered together as a unit, e.g.,
   * outlines for the same element. For this, we need a way for items to
   * identify their type. We use the type for other purposes too.
   */</comment>
  <expr_stmt><expr><name>virtual</name> <name>Type</name> <call><name>GetType</name><argument_list>()</argument_list></call> = 0</expr>;</expr_stmt>
  <comment type="block">/**
   * If this returns a non-zero value, then pairing this with the
   * GetUnderlyingFrame() pointer gives a key that uniquely identifies
   * this display item in the display item tree.
   * This will only return a zero value for items which wrap display lists
   * and do not create a CSS stacking context, therefore requiring
   * display items to be individually wrapped --- currently nsDisplayClip
   * only.
   */</comment>
  <function><type><name>virtual</name> <name>PRUint32</name></type> <name>GetPerFrameKey</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>PRUint32</name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
  <comment type="block">/**
   * This is called after we've constructed a display list for event handling.
   * When this is called, we've already ensured that aRect intersects the
   * item's bounds.
   * 
   * @param aState must point to a HitTestState. If you don't have one,
   * just create one with the default constructor and pass it in.
   * @param aOutFrames each item appends the frame(s) in this display item that
   * the rect is considered over (if any) to aOutFrames.
   */</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>HitTest</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>,
                       <argument><expr><name>HitTestState</name>* <name>aState</name></expr></argument>, <argument><expr><name>nsTArray</name>&lt;<name>nsIFrame</name>*&gt; *<name>aOutFrames</name></expr></argument>)</argument_list> <block>{}</block></decl></decl_stmt>
  <comment type="block">/**
   * @return the frame that this display item is based on. This is used to sort
   * items by z-index and content order and for some other uses. For some items
   * that wrap item lists, this could return nsnull because there is no single
   * underlying frame; for leaf items it will never return nsnull.
   */</comment>
  <function><type><specifier>inline</specifier> <name>nsIFrame</name>*</type> <name>GetUnderlyingFrame</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mFrame</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * The default bounds is the frame border rect.
   * @return a rectangle relative to aBuilder-&gt;ReferenceFrame() that
   * contains the area drawn by this display item
   */</comment>
  <function><type><name>virtual</name> <name>nsRect</name></type> <name>GetBounds</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name>GetUnderlyingFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
  <comment type="block">/**
   * @return PR_TRUE if the item is definitely opaque --- i.e., paints
   * every pixel within its bounds opaquely
   */</comment>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>IsOpaque</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name>PR_FALSE</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * If this returns true, then aColor is set to the uniform color
   * @return PR_TRUE if the item is guaranteed to paint every pixel in its
   * bounds with the same (possibly translucent) color
   */</comment>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>IsUniform</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name>PR_FALSE</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * @return PR_FALSE if the painting performed by the item is invariant
   * when frame aFrame is moved relative to aBuilder-&gt;GetRootMovingFrame().
   * This can only be called when aBuilder-&gt;IsMovingFrame(mFrame) is true.
   * It return PR_TRUE for all wrapped lists.
   */</comment>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>IsVaryingRelativeToMovingFrame</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><name>PR_FALSE</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * @return PR_TRUE if the contents of this item are rendered fixed relative
   * to the nearest viewport *and* they cover the viewport. Only return true
   * if the contents actually vary when scrolling in the viewport.
   */</comment>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>IsFixedAndCoveringViewport</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><name>PR_FALSE</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * @return LAYER_NONE if BuildLayer will return null. In this case
   * there is no layer for the item, and Paint should be called instead
   * to paint the content using Thebes.
   * Return LAYER_INACTIVE if there is a layer --- BuildLayer will
   * not return null (unless there's an error) --- but the layer contents
   * are not changing frequently. In this case it makes sense to composite
   * the layer into a ThebesLayer with other content, so we don't have to
   * recomposite it every time we paint.
   * Note: GetLayerState is only allowed to return LAYER_INACTIVE if all
   * descendant display items returned LAYER_INACTIVE or LAYER_NONE. Also,
   * all descendant display item frames must have an active scrolled root
   * that's either the same as this item's frame's active scrolled root, or
   * a descendant of this item's frame. This ensures that the entire
   * set of display items can be collapsed onto a single ThebesLayer.
   * Return LAYER_ACTIVE if the layer is active, that is, its contents are
   * changing frequently. In this case it makes sense to keep the layer
   * as a separate buffer in VRAM and composite it into the destination
   * every time we paint.
   */</comment>
  <function><type><name>virtual</name> <name>LayerState</name></type> <name>GetLayerState</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                   <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><name>mozilla</name>::<name>LAYER_NONE</name></expr>;</return> }</block></function>
  <comment type="block">/**
   * Actually paint this item to some rendering context.
   * Content outside mVisibleRect need not be painted.
   * aCtx must be set up as for nsDisplayList::Paint.
   */</comment>
  <function><type><name>virtual</name> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{}</block></function>
  <comment type="block">/**
   * Get the layer drawn by this display item. Call this only if
   * GetLayerState() returns something other than LAYER_NONE.
   * If GetLayerState returned LAYER_NONE then Paint will be called
   * instead.
   * This is called while aManager is in the construction phase.
   * 
   * The caller (nsDisplayList) is responsible for setting the visible
   * region of the layer.
   */</comment>
  <expr_stmt><expr><name>virtual</name> <name>already_AddRefed</name>&lt;<name>Layer</name>&gt; <macro><name>BuildLayer</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>,
                                             <argument>LayerManager* aManager</argument>)</argument_list></macro>
  <block>{ <return>return <expr><name>nsnull</name></expr>;</return> }</block></expr></expr_stmt>

  <comment type="block">/**
   * On entry, aVisibleRegion contains the region (relative to ReferenceFrame())
   * which may be visible. If the display item opaquely covers an area, it
   * can remove that area from aVisibleRegion before returning.
   * If we're doing scroll analysis with moving frames, then
   * aVisibleRegionBeforeMove will be non-null and contains the region that
   * would have been visible before the move. aVisibleRegion contains the
   * region that is visible after the move.
   * nsDisplayList::ComputeVisibility automatically subtracts the bounds
   * of items that return true from IsOpaque(), and automatically
   * removes items whose bounds do not intersect the visible area,
   * so implementations of nsDisplayItem::ComputeVisibility do not
   * need to do these things.
   * nsDisplayList::ComputeVisibility will already have set mVisibleRect on
   * this item to the intersection of *aVisibleRegion (unioned with
   * *aVisibleRegionBeforeMove, if that's non-null) and this item's bounds.
   * 
   * @return PR_TRUE if the item is visible, PR_FALSE if no part of the item
   * is visible
   */</comment>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>ComputeVisibility</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr>!<call><name><name>mVisibleRect</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

  <comment type="block">/**
   * Try to merge with the other item (which is below us in the display
   * list). This gets used by nsDisplayClip to coalesce clipping operations
   * (optimization), by nsDisplayOpacity to merge rendering for the same
   * content element into a single opacity group (correctness), and will be
   * used by nsDisplayOutline to merge multiple outlines for the same element
   * (also for correctness).
   * @return PR_TRUE if the merge was successful and the other item should be deleted
   */</comment>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>TryMerge</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></function>
  
  <comment type="block">/**
   * If this is a leaf item we return null, otherwise we return the wrapped
   * list.
   */</comment>
  <function><type><name>virtual</name> <name>nsDisplayList</name>*</type> <name>GetList</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>nsnull</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * Returns the visible rect. Should only be called after ComputeVisibility
   * has happened.
   */</comment>
  <function><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>GetVisibleRect</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mVisibleRect</name></expr>;</return> }</block></function>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <comment type="block">/**
   * For debugging and stuff
   */</comment>
  <expr_stmt><expr><name>virtual</name> const <name>char</name>* <call><name>Name</name><argument_list>()</argument_list></call> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function><type><name>nsDisplayItem</name>*</type> <name>GetAbove</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mAbove</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * Like ComputeVisibility, but does the work that nsDisplayList
   * does per-item:
   * -- Intersects GetBounds with aVisibleRegion and puts the result
   * in mVisibleRect
   * -- Subtracts bounds from aVisibleRegion if the item is opaque
   */</comment>
  <function_decl><type><name>PRBool</name></type> <name>RecomputeVisibility</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                             <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>nsDisplayList</name></decl>;</decl_stmt>
  
  <macro><name>nsDisplayItem</name><argument_list>()</argument_list></macro> <block>{
    <expr_stmt><expr><name>mAbove</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block>
  
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>mFrame</name></decl>;</decl_stmt>
  <comment type="line">// This is the rectangle that needs to be painted.</comment>
  <comment type="line">// nsDisplayList::ComputeVisibility sets this to the visible region</comment>
  <comment type="line">// of the item by intersecting the current visible region with the bounds</comment>
  <comment type="line">// of the item. Paint implementations can use this to limit their drawing.</comment>
  <comment type="line">// Guaranteed to be contained in GetBounds().</comment>
  <decl_stmt><decl><type><name>nsRect</name></type>    <name>mVisibleRect</name></decl>;</decl_stmt>
};

<comment type="block">/**
 * Manages a singly-linked list of display list items.
 * 
 * mSentinel is the sentinel list value, the first value in the null-terminated
 * linked list of items. mTop is the last item in the list (whose 'above'
 * pointer is null). This class has no virtual methods. So list objects are just
 * two pointers.
 * 
 * Stepping upward through this list is very fast. Stepping downward is very
 * slow so we don't support it. The methods that need to step downward
 * (HitTest(), ComputeVisibility()) internally build a temporary array of all
 * the items while they do the downward traversal, so overall they're still
 * linear time. We have optimized for efficient AppendToTop() of both
 * items and lists, with minimal codesize. AppendToBottom() is efficient too.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayList</name> <block>{
<label><name>public</name>:</label>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>layers</name>::<name>Layer</name> <name>Layer</name></expr>;</expr_stmt></typedef>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>layers</name>::<name>LayerManager</name> <name>LayerManager</name></expr>;</expr_stmt></typedef>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>layers</name>::<name>ThebesLayer</name> <name>ThebesLayer</name></expr>;</expr_stmt></typedef>

  <comment type="block">/**
   * Create an empty list.
   */</comment>
  <expr_stmt><expr><call><name>nsDisplayList</name><argument_list>()</argument_list></call> :
    <macro><name>mIsOpaque</name><argument_list>(<argument>PR_FALSE</argument>)</argument_list></macro>
  <block>{
    <expr><name>mTop</name> = &amp;<name>mSentinel</name></expr>;
    <expr><name><name>mSentinel</name>.<name>mAbove</name></name> = <name>nsnull</name></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr><name>mDidComputeVisibility</name> = <name>PR_FALSE</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block>
  ~<macro><name>nsDisplayList</name><argument_list>()</argument_list></macro> <block>{
    <if>if <condition>(<expr><name><name>mSentinel</name>.<name>mAbove</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Nonempty list left over?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>
    <expr_stmt><expr><call><name>DeleteAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></expr></expr_stmt>

  <comment type="block">/**
   * Append an item to the top of the list. The item must not currently
   * be in a list and cannot be null.
   */</comment>
  <function><type><name>void</name></type> <name>AppendToTop</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>, <argument><expr>"No item to append!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name><name>aItem</name>-&gt;<name>mAbove</name></name></expr></argument>, <argument><expr>"Already in a list!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mTop</name>-&gt;<name>mAbove</name></name> = <name>aItem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mTop</name> = <name>aItem</name></expr>;</expr_stmt>
  }</block></function>
  
  <comment type="block">/**
   * Append a new item to the top of the list. If the item is null we return
   * NS_ERROR_OUT_OF_MEMORY. The intended usage is AppendNewToTop(new ...);
   */</comment>
  <function><type><name>nsresult</name></type> <name>AppendNewToTop</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr>!<name>aItem</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>AppendToTop</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></function>
  
  <comment type="block">/**
   * Append a new item to the bottom of the list. If the item is null we return
   * NS_ERROR_OUT_OF_MEMORY. The intended usage is AppendNewToBottom(new ...);
   */</comment>
  <function><type><name>nsresult</name></type> <name>AppendNewToBottom</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr>!<name>aItem</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>AppendToBottom</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></function>
  
  <comment type="block">/**
   * Append a new item to the bottom of the list. The item must be non-null
   * and not already in a list.
   */</comment>
  <function><type><name>void</name></type> <name>AppendToBottom</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>, <argument><expr>"No item to append!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name><name>aItem</name>-&gt;<name>mAbove</name></name></expr></argument>, <argument><expr>"Already in a list!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aItem</name>-&gt;<name>mAbove</name></name> = <name><name>mSentinel</name>.<name>mAbove</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mSentinel</name>.<name>mAbove</name></name> = <name>aItem</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mTop</name> == &amp;<name>mSentinel</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mTop</name> = <name>aItem</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></function>
  
  <comment type="block">/**
   * Removes all items from aList and appends them to the top of this list
   */</comment>
  <function><type><name>void</name></type> <name>AppendToTop</name><parameter_list>(<param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name><name>aList</name>-&gt;<name>mSentinel</name>.<name>mAbove</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>mTop</name>-&gt;<name>mAbove</name></name> = <name><name>aList</name>-&gt;<name>mSentinel</name>.<name>mAbove</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mTop</name> = <name><name>aList</name>-&gt;<name>mTop</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aList</name>-&gt;<name>mTop</name></name> = &amp;<name><name>aList</name>-&gt;<name>mSentinel</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aList</name>-&gt;<name>mSentinel</name>.<name>mAbove</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></function>
  
  <comment type="block">/**
   * Removes all items from aList and prepends them to the bottom of this list
   */</comment>
  <function><type><name>void</name></type> <name>AppendToBottom</name><parameter_list>(<param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name><name>aList</name>-&gt;<name>mSentinel</name>.<name>mAbove</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>aList</name>-&gt;<name>mTop</name>-&gt;<name>mAbove</name></name> = <name><name>mSentinel</name>.<name>mAbove</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mTop</name> = <name><name>aList</name>-&gt;<name>mTop</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mSentinel</name>.<name>mAbove</name></name> = <name><name>aList</name>-&gt;<name>mSentinel</name>.<name>mAbove</name></name></expr>;</expr_stmt>
           
      <expr_stmt><expr><name><name>aList</name>-&gt;<name>mTop</name></name> = &amp;<name><name>aList</name>-&gt;<name>mSentinel</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aList</name>-&gt;<name>mSentinel</name>.<name>mAbove</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></function>
  
  <comment type="block">/**
   * Remove an item from the bottom of the list and return it.
   */</comment>
  <function_decl><type><name>nsDisplayItem</name>*</type> <name>RemoveBottom</name><parameter_list>()</parameter_list>;</function_decl>
  
  <comment type="block">/**
   * Remove all items from the list and call their destructors.
   */</comment>
  <function_decl><type><name>void</name></type> <name>DeleteAll</name><parameter_list>()</parameter_list>;</function_decl>
  
  <comment type="block">/**
   * @return the item at the top of the list, or null if the list is empty
   */</comment>
  <expr_stmt><expr><name>nsDisplayItem</name>* <macro><name>GetTop</name><argument_list>()</argument_list></macro> const <block>{
    <return>return <expr><name>mTop</name> != &amp;<name>mSentinel</name> ? <name>static_cast</name>&lt;<name>nsDisplayItem</name>*&gt;(<name>mTop</name>) : <name>nsnull</name></expr>;</return>
  }</block></expr></expr_stmt>
  <comment type="block">/**
   * @return the item at the bottom of the list, or null if the list is empty
   */</comment>
  <expr_stmt><expr><name>nsDisplayItem</name>* <macro><name>GetBottom</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name><name>mSentinel</name>.<name>mAbove</name></name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsEmpty</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mTop</name> == &amp;<name>mSentinel</name></expr>;</return> }</block></expr></expr_stmt>
  
  <comment type="block">/**
   * This is *linear time*!
   * @return the number of items in the list
   */</comment>
  <expr_stmt><expr><name>PRUint32</name> <macro><name>Count</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
  <comment type="block">/**
   * Stable sort the list by the z-order of GetUnderlyingFrame() on
   * each item. 'auto' is counted as zero. Content order is used as the
   * secondary order.
   * @param aCommonAncestor a common ancestor of all the content elements
   * associated with the display items, for speeding up tree order
   * checks, or nsnull if not known; it's only a hint, if it is not an
   * ancestor of some elements, then we lose performance but not correctness
   */</comment>
  <function_decl><type><name>void</name></type> <name>SortByZOrder</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aCommonAncestor</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * Stable sort the list by the tree order of the content of
   * GetUnderlyingFrame() on each item. z-index is ignored.
   * @param aCommonAncestor a common ancestor of all the content elements
   * associated with the display items, for speeding up tree order
   * checks, or nsnull if not known; it's only a hint, if it is not an
   * ancestor of some elements, then we lose performance but not correctness
   */</comment>
  <function_decl><type><name>void</name></type> <name>SortByContentOrder</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aCommonAncestor</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Generic stable sort. Take care, because some of the items might be nsDisplayLists
   * themselves.
   * aCmp(item1, item2) should return true if item1 &lt;= item2. We sort the items
   * into increasing order.
   */</comment>
  <typedef>typedef <function_decl><type><name>PRBool</name></type> (* <name>SortLEQ</name>)<parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem1</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem2</name></decl></param>,
                             <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list>;</function_decl></typedef>
  <function_decl><type><name>void</name></type> <name>Sort</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>SortLEQ</name></type> <name>aCmp</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Compute visiblity for the items in the list.
   * We put this logic here so it can be shared by top-level
   * painting and also display items that maintain child lists.
   * This is also a good place to put ComputeVisibility-related logic
   * that must be applied to every display item. In particular, this
   * sets mVisibleRect on each display item.
   * This also sets mIsOpaque to whether aVisibleRegion is empty on return.
   * This does not remove any items from the list, so we can recompute
   * visiblity with different regions later (see
   * FrameLayerBuilder::DrawThebesLayer).
   * 
   * @param aVisibleRegion the area that is visible, relative to the
   * reference frame; on return, this contains the area visible under the list
   * @return true if any item in the list is visible
   */</comment>
  <function_decl><type><name>PRBool</name></type> <name>ComputeVisibility</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * Returns true if the visible region output from ComputeVisiblity was
   * empty, i.e. everything visible in this list is opaque.
   */</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsOpaque</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mDidComputeVisibility</name></expr></argument>, <argument><expr>"Need to have called ComputeVisibility"</expr></argument>)</argument_list></call></expr>;
    <return>return <expr><name>mIsOpaque</name></expr>;</return>
  }</block></expr></expr_stmt>
  <comment type="block">/**
   * Paint the list to the rendering context. We assume that (0,0) in aCtx
   * corresponds to the origin of the reference frame. For best results,
   * aCtx's current transform should make (0,0) pixel-aligned. The
   * rectangle in aDirtyRect is painted, which *must* be contained in the
   * dirty rect used to construct the display list.
   * 
   * If aFlags contains PAINT_USE_WIDGET_LAYERS and
   * ShouldUseWidgetLayerManager() is set, then we will paint using
   * the reference frame's widget's layer manager (and ctx may be null),
   * otherwise we will use a temporary BasicLayerManager and ctx must
   * not be null.
   * 
   * If PAINT_FLUSH_LAYERS is set, we'll force a completely new layer
   * tree to be created for this paint *and* the next paint.
   * 
   * ComputeVisibility must be called before Paint.
   * 
   * This must only be called on the root display list of the display list
   * tree.
   */</comment>
  <enum>enum <block>{
    <decl><name>PAINT_DEFAULT</name> <init>= <expr>0</expr></init></decl>,
    <decl><name>PAINT_USE_WIDGET_LAYERS</name> <init>= <expr>0x01</expr></init></decl>,
    <decl><name>PAINT_FLUSH_LAYERS</name> <init>= <expr>0x02</expr></init></decl>
  }</block>;</enum>
  <decl_stmt><decl><type><name>void</name></type> <name>PaintRoot</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>,
                 <argument><expr><name>PRUint32</name> <name>aFlags</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <comment type="block">/**
   * Like PaintRoot, but used for internal display sublists.
   * aForFrame is the frame that the list is associated with.
   */</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>PaintForFrame</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>,
                     <argument><expr><name>nsIFrame</name>* <name>aForFrame</name></expr></argument>, <argument><expr><name>PRUint32</name> <name>aFlags</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <comment type="block">/**
   * Get the bounds. Takes the union of the bounds of all children.
   */</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>GetBounds</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
  <comment type="block">/**
   * Find the topmost display item that returns a non-null frame, and return
   * the frame.
   */</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>HitTest</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>,
               <argument><expr><name>nsDisplayItem</name>::<name>HitTestState</name>* <name>aState</name></expr></argument>,
               <argument><expr><name>nsTArray</name>&lt;<name>nsIFrame</name>*&gt; *<name>aOutFrames</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>PRBool</name> <macro><name>DidComputeVisibility</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mDidComputeVisibility</name></expr>;</return> }</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>private</name>:</label>
  <comment type="line">// This class is only used on stack, so we don't have to worry about leaking</comment>
  <comment type="line">// it.  Don't let us be heap-allocated!</comment>
  <decl_stmt><decl><type><name>void</name>* <name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>size_t</name> <name>sz</name></expr></argument>)</argument_list> <name>CPP_THROW_NEW</name></decl>;</decl_stmt>
  
  <comment type="line">// Utility function used to massage the list during ComputeVisibility.</comment>
  <decl_stmt><decl><type><name>void</name></type> <name>FlattenTo</name><argument_list>(<argument><expr><name>nsTArray</name>&lt;<name>nsDisplayItem</name>*&gt;* <name>aElements</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <comment type="line">// Utility function used to massage the list during sorting, to rewrite</comment>
  <comment type="line">// any wrapper items with null GetUnderlyingFrame</comment>
  <function_decl><type><name>void</name></type> <name>ExplodeAnonymousChildLists</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>;</function_decl>
  
  <decl_stmt><decl><type><name>nsDisplayItemLink</name></type>  <name>mSentinel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayItemLink</name>*</type> <name>mTop</name></decl>;</decl_stmt>

  <comment type="line">// This is set by ComputeVisibility</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>mVisibleRect</name></decl>;</decl_stmt>
  <comment type="line">// This is set to true by ComputeVisibility if the final visible region</comment>
  <comment type="line">// is empty (i.e. everything that was visible is covered by some</comment>
  <comment type="line">// opaque content in this list).</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mIsOpaque</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mDidComputeVisibility</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * This is passed as a parameter to nsIFrame::BuildDisplayList. That method
 * will put any generated items onto the appropriate list given here. It's
 * basically just a collection with one list for each separate stacking layer.
 * The lists themselves are external to this object and thus can be shared
 * with others. Some of the list pointers may even refer to the same list.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayListSet</name> <block>{
<label><name>public</name>:</label>
  <comment type="block">/**
   * @return a list where one should place the border and/or background for
   * this frame (everything from steps 1 and 2 of CSS 2.1 appendix E)
   */</comment>
  <expr_stmt><expr><name>nsDisplayList</name>* <macro><name>BorderBackground</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mBorderBackground</name></expr>;</return> }</block></expr></expr_stmt>
  <comment type="block">/**
   * @return a list where one should place the borders and/or backgrounds for
   * block-level in-flow descendants (step 4 of CSS 2.1 appendix E)
   */</comment>
  <expr_stmt><expr><name>nsDisplayList</name>* <macro><name>BlockBorderBackgrounds</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mBlockBorderBackgrounds</name></expr>;</return> }</block></expr></expr_stmt>
  <comment type="block">/**
   * @return a list where one should place descendant floats (step 5 of
   * CSS 2.1 appendix E)
   */</comment>
  <expr_stmt><expr><name>nsDisplayList</name>* <macro><name>Floats</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFloats</name></expr>;</return> }</block></expr></expr_stmt>
  <comment type="block">/**
   * @return a list where one should place the (pseudo) stacking contexts 
   * for descendants of this frame (everything from steps 3, 7 and 8
   * of CSS 2.1 appendix E)
   */</comment>
  <expr_stmt><expr><name>nsDisplayList</name>* <macro><name>PositionedDescendants</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mPositioned</name></expr>;</return> }</block></expr></expr_stmt>
  <comment type="block">/**
   * @return a list where one should place the outlines
   * for this frame and its descendants (step 9 of CSS 2.1 appendix E)
   */</comment>
  <expr_stmt><expr><name>nsDisplayList</name>* <macro><name>Outlines</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mOutlines</name></expr>;</return> }</block></expr></expr_stmt>
  <comment type="block">/**
   * @return a list where one should place all other content
   */</comment>
  <expr_stmt><expr><name>nsDisplayList</name>* <macro><name>Content</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mContent</name></expr>;</return> }</block></expr></expr_stmt>
  
  <expr_stmt><expr><call><name>nsDisplayListSet</name><argument_list>(<argument><expr><name>nsDisplayList</name>* <name>aBorderBackground</name></expr></argument>,
                   <argument><expr><name>nsDisplayList</name>* <name>aBlockBorderBackgrounds</name></expr></argument>,
                   <argument><expr><name>nsDisplayList</name>* <name>aFloats</name></expr></argument>,
                   <argument><expr><name>nsDisplayList</name>* <name>aContent</name></expr></argument>,
                   <argument><expr><name>nsDisplayList</name>* <name>aPositionedDescendants</name></expr></argument>,
                   <argument><expr><name>nsDisplayList</name>* <name>aOutlines</name></expr></argument>)</argument_list></call> :
     <call><name>mBorderBackground</name><argument_list>(<argument><expr><name>aBorderBackground</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mBlockBorderBackgrounds</name><argument_list>(<argument><expr><name>aBlockBorderBackgrounds</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mFloats</name><argument_list>(<argument><expr><name>aFloats</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mContent</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mPositioned</name><argument_list>(<argument><expr><name>aPositionedDescendants</name></expr></argument>)</argument_list></call></expr>,
     <macro><name>mOutlines</name><argument_list>(<argument>aOutlines</argument>)</argument_list></macro> <expr><block>{
  }</block>

  <comment type="block">/**
   * A copy constructor that lets the caller override the BorderBackground
   * list.
   */</comment>  
  <call><name>nsDisplayListSet</name><argument_list>(<argument><expr>const <name>nsDisplayListSet</name>&amp; <name>aLists</name></expr></argument>,
                   <argument><expr><name>nsDisplayList</name>* <name>aBorderBackground</name></expr></argument>)</argument_list></call> :
     <call><name>mBorderBackground</name><argument_list>(<argument><expr><name>aBorderBackground</name></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mBlockBorderBackgrounds</name><argument_list>(<argument><expr><call><name><name>aLists</name>.<name>BlockBorderBackgrounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mFloats</name><argument_list>(<argument><expr><call><name><name>aLists</name>.<name>Floats</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mContent</name><argument_list>(<argument><expr><call><name><name>aLists</name>.<name>Content</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
     <expr><call><name>mPositioned</name><argument_list>(<argument><expr><call><name><name>aLists</name>.<name>PositionedDescendants</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
     <macro><name>mOutlines</name><argument_list>(<argument>aLists.Outlines()</argument>)</argument_list></macro> <expr><block>{
  }</block>
  
  <comment type="block">/**
   * Move all display items in our lists to top of the corresponding lists in the
   * destination.
   */</comment>
  <name>void</name> <macro><name>MoveTo</name><argument_list>(<argument>const nsDisplayListSet&amp; aDestination</argument>)</argument_list></macro> const</expr>;</expr_stmt>

<label><name>private</name>:</label>
  <comment type="line">// This class is only used on stack, so we don't have to worry about leaking</comment>
  <comment type="line">// it.  Don't let us be heap-allocated!</comment>
  <decl_stmt><decl><type><name>void</name>* <name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>size_t</name> <name>sz</name></expr></argument>)</argument_list> <name>CPP_THROW_NEW</name></decl>;</decl_stmt>

<label><name>protected</name>:</label>
  <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>mBorderBackground</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>mBlockBorderBackgrounds</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>mFloats</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>mContent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>mPositioned</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>mOutlines</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * A specialization of nsDisplayListSet where the lists are actually internal
 * to the object, and all distinct.
 */</comment>
struct <label><name>nsDisplayListCollection</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>nsDisplayListSet</name> <block>{
  <expr_stmt><expr><call><name>nsDisplayListCollection</name><argument_list>()</argument_list></call> :
    <macro><name>nsDisplayListSet</name><argument_list>(<argument>&amp;mLists[0]</argument>, <argument>&amp;mLists[1]</argument>, <argument>&amp;mLists[2]</argument>, <argument>&amp;mLists[3]</argument>, <argument>&amp;mLists[4]</argument>,
                     <argument>&amp;mLists[5]</argument>)</argument_list></macro> <block>{}</block>
  <call><name>nsDisplayListCollection</name><argument_list>(<argument><expr><name>nsDisplayList</name>* <name>aBorderBackground</name></expr></argument>)</argument_list></call> :
    <macro><name>nsDisplayListSet</name><argument_list>(<argument>aBorderBackground</argument>, <argument>&amp;mLists[1]</argument>, <argument>&amp;mLists[2]</argument>, <argument>&amp;mLists[3]</argument>, <argument>&amp;mLists[4]</argument>,
                     <argument>&amp;mLists[5]</argument>)</argument_list></macro> <block>{}</block>

  <comment type="block">/**
   * Sort all lists by content order.
   */</comment>                     
  <name>void</name> <macro><name>SortAllByContentOrder</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>nsIContent* aCommonAncestor</argument>)</argument_list></macro> <block>{
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 6</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <expr_stmt><expr><name><name>mLists</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>SortByContentOrder</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aCommonAncestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/>}</block>
  <expr_stmt/></for>}</block>

<name>private</name>:
  <comment type="line">// This class is only used on stack, so we don't have to worry about leaking</comment>
  <comment type="line">// it.  Don't let us be heap-allocated!</comment>
  <name>void</name>* <name>operator</name> <macro><name>new</name><argument_list>(<argument>size_t sz</argument>)</argument_list></macro> <name>CPP_THROW_NEW</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name><name>mLists</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Use this class to implement not-very-frequently-used display items
 * that are not opaque, do not receive events, and are bounded by a frame's
 * border-rect.
 * 
 * This should not be used for display items which are created frequently,
 * because each item is one or two pointers bigger than an item from a
 * custom display item class could be, and fractionally slower. However it does
 * save code size. We use this for infrequently-used item types.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayGeneric</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:</expr>
  <typedef>typedef <function_decl><type><name>void</name></type> (* <name>PaintCallback</name>)<parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>, <param><decl><type><name>nsPoint</name></type> <name>aFramePt</name></decl></param>)</parameter_list>;</function_decl></typedef>

  <macro><name>nsDisplayGeneric</name><argument_list>(<argument>nsIFrame* aFrame</argument>, <argument>PaintCallback aPaint</argument>, <argument>const char* aName</argument>, <argument>Type aType</argument>)</argument_list></macro>
    : <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call>, <call><name>mPaint</name><argument_list>(<argument><expr><name>aPaint</name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      , <call><name>mName</name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      , <macro><name>mType</name><argument_list>(<argument>aType</argument>)</argument_list></macro>
  <block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayGeneric</name></expr></argument>)</argument_list></call></expr>;
  }</block></block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayGeneric</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayGeneric</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <name>virtual</name> <name>void</name> <macro><name>Paint</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>nsIRenderingContext* aCtx</argument>)</argument_list></macro> <block>{
    <expr><call><name>mPaint</name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name>aCtx</name></expr></argument>, <argument><expr><name>mVisibleRect</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
  }</block>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>mName</argument>, <argument>mType</argument>)</argument_list></macro>
<name>protected</name>:
  <name>PaintCallback</name> <name>mPaint</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type>   <name>mName</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>Type</name></type> <name>mType</name></decl>;</decl_stmt>
};

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOZ_REFLOW_PERF_DSP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>MOZ_REFLOW_PERF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/**
 * This class implements painting of reflow counts.  Ideally, we would simply
 * make all the frame names be those returned by nsFrame::GetFrameName
 * (except that tosses in the content tag name!)  and support only one color
 * and eliminate this class altogether in favor of nsDisplayGeneric, but for
 * the time being we can't pass args to a PaintCallback, so just have a
 * separate class to do the right thing.  Sadly, this alsmo means we need to
 * hack all leaf frame classes to handle this.
 *
 * XXXbz the color thing is a bit of a mess, but 0 basically means "not set"
 * here...  I could switch it all to nscolor, but why bother?
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayReflowCount</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <macro><name>nsDisplayReflowCount</name><argument_list>(<argument>nsIFrame* aFrame</argument>, <argument>const char* aFrameName</argument>,
                       <argument>PRUint32 aColor = 0</argument>)</argument_list></macro>
    : <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>,
      <expr><call><name>mFrameName</name><argument_list>(<argument><expr><name>aFrameName</name></expr></argument>)</argument_list></call></expr>,
      <macro><name>mColor</name><argument_list>(<argument>aColor</argument>)</argument_list></macro>
  <expr><block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayReflowCount</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayReflowCount</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayReflowCount</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <name>virtual</name> <name>void</name> <macro><name>Paint</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>nsIRenderingContext* aCtx</argument>)</argument_list></macro> <block>{
    <expr><name>nsPoint</name> <name>pt</name> = <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>nsIRenderingContext</name>::<name>AutoPushTranslation</name> <call><name>translate</name><argument_list>(<argument><expr><name>aCtx</name></expr></argument>, <argument><expr><name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>PaintCount</name><argument_list>(<argument><expr><name>mFrameName</name></expr></argument>, <argument><expr><name>aCtx</name></expr></argument>,
                                                      <argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                      <argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name>mColor</name></expr></argument>)</argument_list></call></expr>;
  }</block>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"nsDisplayReflowCount"</argument>, <argument>TYPE_REFLOW_COUNT</argument>)</argument_list></macro>
<name>protected</name>:
  const <name>char</name>* <name>mFrameName</name></expr>;
  <expr><name>nscolor</name> <name>mColor</name></expr>;
}</block></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GLOBAL_REFLOW_COUNT_DSP</name><parameter_list>(<param><type><name>_name</name></type></param>)</parameter_list></cpp:macro>                                     \
  <cpp:value>PR_BEGIN_MACRO                                                              \
    if (!aBuilder-&gt;IsBackgroundOnly() &amp;&amp; !aBuilder-&gt;IsForEventDelivery() &amp;&amp;   \
        PresContext()-&gt;PresShell()-&gt;IsPaintingFrameCounts()) {                \
      nsresult _rv =                                                          \
        aLists.Outlines()-&gt;AppendNewToTop(new (aBuilder)                      \
                                          nsDisplayReflowCount(this, _name)); \
      NS_ENSURE_SUCCESS(_rv, _rv);                                            \
    }                                                                         \
  PR_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GLOBAL_REFLOW_COUNT_DSP_COLOR</name><parameter_list>(<param><type><name>_name</name></type></param>, <param><type><name>_color</name></type></param>)</parameter_list></cpp:macro>                       \
  <cpp:value>PR_BEGIN_MACRO                                                              \
    if (!aBuilder-&gt;IsBackgroundOnly() &amp;&amp; !aBuilder-&gt;IsForEventDelivery() &amp;&amp;   \
        PresContext()-&gt;PresShell()-&gt;IsPaintingFrameCounts()) {                \
      nsresult _rv =                                                          \
        aLists.Outlines()-&gt;AppendNewToTop(new (aBuilder)                      \
                                          nsDisplayReflowCount(this, _name,   \
                                                               _color));      \
      NS_ENSURE_SUCCESS(_rv, _rv);                                            \
    }                                                                         \
  PR_END_MACRO</cpp:value></cpp:define>

<comment type="block">/*
  Macro to be used for classes that don't actually implement BuildDisplayList
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_DO_GLOBAL_REFLOW_COUNT_DSP</name><parameter_list>(<param><type><name>_class</name></type></param>, <param><type><name>_super</name></type></param>)</parameter_list></cpp:macro>                   \
  <cpp:value>NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,           \
                              const nsRect&amp;           aDirtyRect,         \
                              const nsDisplayListSet&amp; aLists) {           \
    DO_GLOBAL_REFLOW_COUNT_DSP(#_class);                                  \
    return _super::BuildDisplayList(aBuilder, aDirtyRect, aLists);        \
  }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// MOZ_REFLOW_PERF_DSP &amp;&amp; MOZ_REFLOW_PERF</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GLOBAL_REFLOW_COUNT_DSP</name><parameter_list>(<param><type><name>_name</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GLOBAL_REFLOW_COUNT_DSP_COLOR</name><parameter_list>(<param><type><name>_name</name></type></param>, <param><type><name>_color</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_DO_GLOBAL_REFLOW_COUNT_DSP</name><parameter_list>(<param><type><name>_class</name></type></param>, <param><type><name>_super</name></type></param>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_REFLOW_PERF_DSP &amp;&amp; MOZ_REFLOW_PERF</comment>

<expr_stmt><expr><name>class</name> <name>nsDisplayCaret</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayCaret</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aCaretFrame</name></expr></argument>, <argument><expr><name>nsCaret</name> *<name>aCaret</name></expr></argument>)</argument_list></call>
    : <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aCaretFrame</name></expr></argument>)</argument_list></call></expr>, <macro><name>mCaret</name><argument_list>(<argument>aCaret</argument>)</argument_list></macro> <expr><block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayCaret</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayCaret</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayCaret</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>nsRect</name> <macro><name>GetBounds</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>)</argument_list></macro> <block>{
    <comment type="line">// The caret returns a rect in the coordinates of mFrame.</comment>
    <return>return <expr><call><name><name>mCaret</name>-&gt;<name>GetCaretRect</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
  }</block>
  <name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"Caret"</argument>, <argument>TYPE_CARET</argument>)</argument_list></macro>
<label><name>protected</name>:</label>
  <expr_stmt><expr><name>nsRefPtr</name>&lt;<name>nsCaret</name>&gt; <name>mCaret</name></expr>;</expr_stmt>
};

<comment type="block">/**
 * The standard display item to paint the CSS borders of a frame.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayBorder</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayBorder</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>nsDisplayItem</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayBorder</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayBorder</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayBorder</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"Border"</argument>, <argument>TYPE_BORDER</argument>)</argument_list></macro>
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * A simple display item that just renders a solid color across the
 * specified bounds. For canvas frames (in the CSS sense) we split off the
 * drawing of the background color into this class (from nsDisplayBackground
 * via nsDisplayCanvasBackground). This is done so that we can always draw a
 * background color to avoid ugly flashes of white when we can't draw a full
 * frame tree (ie when a page is loading). The bounds can differ from the
 * frame's bounds -- this is needed when a frame/iframe is loading and there
 * is not yet a frame tree to go in the frame/iframe so we use the subdoc
 * frame of the parent document as a standin.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplaySolidColor</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <macro><name>nsDisplaySolidColor</name><argument_list>(<argument>nsIFrame* aFrame</argument>, <argument>const nsRect&amp; aBounds</argument>, <argument>nscolor aColor</argument>)</argument_list></macro>
    : <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mBounds</name><argument_list>(<argument><expr><name>aBounds</name></expr></argument>)</argument_list></call></expr>, <macro><name>mColor</name><argument_list>(<argument>aColor</argument>)</argument_list></macro> <expr><block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplaySolidColor</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplaySolidColor</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplaySolidColor</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>nsRect</name> <macro><name>GetBounds</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>)</argument_list></macro> <block>{ <return>return <expr><name>mBounds</name></expr>;</return></block></expr> }</block>

  <name>virtual</name> <name>PRBool</name> <macro><name>IsOpaque</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>)</argument_list></macro> <block>{
    <return>return <expr>(<call><name>NS_GET_A</name><argument_list>(<argument><expr><name>mColor</name></expr></argument>)</argument_list></call> == 255)</expr>;</return>
  }</block></expr></expr_stmt>

  <function><type><name>virtual</name> <name>PRBool</name></type> <name>IsUniform</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr>*<name>aColor</name> = <name>mColor</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></function>

  <function_decl><type><name>virtual</name> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list>;</function_decl>

  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"SolidColor"</argument>, <argument>TYPE_SOLID_COLOR</argument>)</argument_list></macro>

<label><name>private</name>:</label>
  <decl_stmt><decl><type><name>nsRect</name></type>  <name>mBounds</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type> <name>mColor</name></decl>;</decl_stmt>
};

<comment type="block">/**
 * The standard display item to paint the CSS background of a frame.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayBackground</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayBackground</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>nsDisplayItem</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{
    <expr><name>mIsThemed</name> = <call><name><name>mFrame</name>-&gt;<name>IsThemed</name></name><argument_list>(<argument><expr>&amp;<name>mThemeTransparency</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayBackground</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayBackground</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayBackground</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>void</name> <macro><name>HitTest</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>const nsRect&amp; aRect</argument>,
                       <argument>HitTestState* aState</argument>, <argument>nsTArray&lt;nsIFrame*&gt; *aOutFrames</argument>)</argument_list></macro>
  <block>{
    <expr><call><name><name>aOutFrames</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;
  }</block>
  <name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsOpaque</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsVaryingRelativeToMovingFrame</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsUniform</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nscolor</name>* <name>aColor</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>nsRect</name> <call><name>GetBounds</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"Background"</argument>, <argument>TYPE_BACKGROUND</argument>)</argument_list></macro>
<expr><name>protected</name>:
  <comment type="block">/* Used to cache mFrame-&gt;IsThemed() since it isn't a cheap call */</comment>
  <name>PRPackedBool</name> <name>mIsThemed</name></expr>;
  <expr><name>nsITheme</name>::<name>Transparency</name> <name>mThemeTransparency</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * The standard display item to paint the outer CSS box-shadows of a frame.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayBoxShadowOuter</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayBoxShadowOuter</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>nsDisplayItem</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayBoxShadowOuter</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayBoxShadowOuter</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayBoxShadowOuter</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>nsRect</name> <call><name>GetBounds</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"BoxShadowOuter"</argument>, <argument>TYPE_BOX_SHADOW_OUTER</argument>)</argument_list></macro>

<expr><name>private</name>:
  <name>nsRegion</name> <name>mVisibleRegion</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * The standard display item to paint the inner CSS box-shadows of a frame.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayBoxShadowInner</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayBoxShadowInner</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>nsDisplayItem</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayBoxShadowInner</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayBoxShadowInner</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayBoxShadowInner</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"BoxShadowInner"</argument>, <argument>TYPE_BOX_SHADOW_INNER</argument>)</argument_list></macro>

<expr><name>private</name>:
  <name>nsRegion</name> <name>mVisibleRegion</name></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * The standard display item to paint the CSS outline of a frame.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayOutline</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayOutline</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>nsDisplayItem</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayOutline</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayOutline</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayOutline</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>nsRect</name> <call><name>GetBounds</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"Outline"</argument>, <argument>TYPE_OUTLINE</argument>)</argument_list></macro>
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * A class that lets you receive events within the frame bounds but never paints.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayEventReceiver</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayEventReceiver</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>)</argument_list></call> : <macro><name>nsDisplayItem</name><argument_list>(<argument>aFrame</argument>)</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayEventReceiver</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayEventReceiver</name><argument_list>()</argument_list></macro> <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayEventReceiver</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>void</name> <macro><name>HitTest</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>const nsRect&amp; aRect</argument>,
                       <argument>HitTestState* aState</argument>, <argument>nsTArray&lt;nsIFrame*&gt; *aOutFrames</argument>)</argument_list></macro>
  <block>{
    <expr><call><name><name>aOutFrames</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;
  }</block>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"EventReceiver"</argument>, <argument>TYPE_EVENT_RECEIVER</argument>)</argument_list></macro></expr>
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * A class that lets you wrap a display list as a display item.
 * 
 * GetUnderlyingFrame() is troublesome for wrapped lists because if the wrapped
 * list has many items, it's not clear which one has the 'underlying frame'.
 * Thus we force the creator to specify what the underlying frame is. The
 * underlying frame should be the root of a stacking context, because sorting
 * a list containing this item will not get at the children.
 * 
 * In some cases (e.g., clipping) we want to wrap a list but we don't have a
 * particular underlying frame that is a stacking context root. In that case
 * we allow the frame to be nsnull. Callers to GetUnderlyingFrame must
 * detect and handle this case.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayWrapList</name> : <name>public</name> <name>nsDisplayItem</name> <block>{
  <comment type="line">// This is never instantiated directly, so no need to count constructors and</comment>
  <comment type="line">// destructors.</comment>

<expr><name>public</name>:
  <comment type="block">/**
   * Takes all the items from aList and puts them in our list.
   */</comment>
  <call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayList</name>* <name>aList</name></expr></argument>)</argument_list></call></expr>;
  <expr><call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayItem</name>* <name>aItem</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> ~<call><name>nsDisplayWrapList</name><argument_list>()</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>HitTest</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>,
                       <argument><expr><name>HitTestState</name>* <name>aState</name></expr></argument>, <argument><expr><name>nsTArray</name>&lt;<name>nsIFrame</name>*&gt; *<name>aOutFrames</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>nsRect</name> <call><name>GetBounds</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsOpaque</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsUniform</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nscolor</name>* <name>aColor</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsVaryingRelativeToMovingFrame</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <macro><name>TryMerge</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>nsDisplayItem* aItem</argument>)</argument_list></macro> <block>{
    <expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"This list should already have been flattened!!!"</expr></argument>)</argument_list></call></expr>;
    <return>return <expr><name>PR_FALSE</name></expr>;</return></block></expr>
  }</block>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"WrapList"</argument>, <argument>TYPE_WRAP_LIST</argument>)</argument_list></macro>
                                    
  <name>virtual</name> <name>nsDisplayList</name>* <macro><name>GetList</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr>&amp;<name>mList</name></expr>;</return> }</block></expr></expr_stmt>
  
  <comment type="block">/**
   * This creates a copy of this item, but wrapping aItem instead of
   * our existing list. Only gets called if this item returned nsnull
   * for GetUnderlyingFrame(). aItem is guaranteed to return non-null from
   * GetUnderlyingFrame().
   */</comment>
  <function><type><name>virtual</name> <name>nsDisplayWrapList</name>*</type> <name>WrapWithClone</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                           <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"We never returned nsnull for GetUnderlyingFrame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></function>

  <comment type="block">/**
   * Returns true if all descendant display items can be placed in the same
   * ThebesLayer --- GetLayerState returns LAYER_INACTIVE or LAYER_NONE,
   * and they all have the given aActiveScrolledRoot.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>ChildrenCanBeInactive</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                      <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nsDisplayList</name>&amp;</type> <name>aList</name></decl></param>,
                                      <param><decl><type><name>nsIFrame</name>*</type> <name>aActiveScrolledRoot</name></decl></param>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
  <macro><name>nsDisplayWrapList</name><argument_list>()</argument_list></macro> <block>{}</block>
  
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>mList</name></decl>;</decl_stmt>
};

<comment type="block">/**
 * We call WrapDisplayList on the in-flow lists: BorderBackground(),
 * BlockBorderBackgrounds() and Content().
 * We call WrapDisplayItem on each item of Outlines(), PositionedDescendants(),
 * and Floats(). This is done to support special wrapping processing for frames
 * that may not be in-flow descendants of the current frame.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>nsDisplayWrapper</name> <block>{
<label><name>public</name>:</label>
  <comment type="line">// This is never instantiated directly (it has pure virtual methods), so no</comment>
  <comment type="line">// need to count constructors and destructors.</comment>

  <function><type><name>virtual</name> <name>PRBool</name></type> <name>WrapBorderBackground</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>PR_TRUE</name></expr>;</return> }</block></function>
  <decl_stmt><decl><type><name>virtual</name> <name>nsDisplayItem</name>*</type> <name>WrapList</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                  <argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayList</name>* <name>aList</name></expr></argument>)</argument_list> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>virtual</name> <name>nsDisplayItem</name>*</type> <name>WrapItem</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                  <argument><expr><name>nsDisplayItem</name>* <name>aItem</name></expr></argument>)</argument_list> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <function_decl><type><name>nsresult</name></type> <name>WrapLists</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aIn</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aOut</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>WrapListsInPlace</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>;</function_decl>
<label><name>protected</name>:</label>
  <macro><name>nsDisplayWrapper</name><argument_list>()</argument_list></macro> <block>{}</block>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
                              
<comment type="block">/**
 * The standard display item to paint a stacking context with translucency
 * set by the stacking context root frame's 'opacity' style.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayOpacity</name> : <name>public</name> <name>nsDisplayWrapList</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayOpacity</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayList</name>* <name>aList</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <expr><name>virtual</name> ~<call><name>nsDisplayOpacity</name><argument_list>()</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsOpaque</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>already_AddRefed</name>&lt;<name>Layer</name>&gt; <call><name>BuildLayer</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                             <argument><expr><name>LayerManager</name>* <name>aManager</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>LayerState</name> <call><name>GetLayerState</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>LayerManager</name>* <name>aManager</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;  
  <expr><name>virtual</name> <name>PRBool</name> <call><name>TryMerge</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsDisplayItem</name>* <name>aItem</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"Opacity"</argument>, <argument>TYPE_OPACITY</argument>)</argument_list></macro>
}</block></expr>;</expr_stmt>

<comment type="block">/**
 * A display item that has no purpose but to ensure its contents get
 * their own layer.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayOwnLayer</name> : <name>public</name> <name>nsDisplayWrapList</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplayOwnLayer</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayList</name>* <name>aList</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <expr><name>virtual</name> ~<call><name>nsDisplayOwnLayer</name><argument_list>()</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr><name>virtual</name> <name>already_AddRefed</name>&lt;<name>Layer</name>&gt; <call><name>BuildLayer</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                             <argument><expr><name>LayerManager</name>* <name>aManager</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>LayerState</name> <macro><name>GetLayerState</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>,
                                   <argument>LayerManager* aManager</argument>)</argument_list></macro>
  <block>{
    <return>return <expr><name>mozilla</name>::<name>LAYER_ACTIVE</name></expr>;</return></block></expr>
  }</block>
  <name>virtual</name> <name>PRBool</name> <macro><name>TryMerge</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>, <argument>nsDisplayItem* aItem</argument>)</argument_list></macro>
  <block>{
    <comment type="line">// Don't allow merging, each sublist must have its own layer</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></expr></expr_stmt>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"OwnLayer"</argument>, <argument>TYPE_OWN_LAYER</argument>)</argument_list></macro>
};

<comment type="block">/**
 * nsDisplayClip can clip a list of items, but we take a single item
 * initially and then later merge other items into it when we merge
 * adjacent matching nsDisplayClips
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplayClip</name> : <name>public</name> <name>nsDisplayWrapList</name> <block>{
<expr><name>public</name>:
  <comment type="block">/**
   * @param aFrame the frame that should be considered the underlying
   * frame for this content, e.g. the frame whose z-index we have.
   * @param aClippingFrame the frame that is inducing the clipping.
   */</comment>
  <call><name>nsDisplayClip</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsIFrame</name>* <name>aClippingFrame</name></expr></argument>, 
                <argument><expr><name>nsDisplayItem</name>* <name>aItem</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>)</argument_list></call></expr>;
  <expr><call><name>nsDisplayClip</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsIFrame</name>* <name>aClippingFrame</name></expr></argument>,
                <argument><expr><name>nsDisplayList</name>* <name>aList</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <expr><name>virtual</name> ~<call><name>nsDisplayClip</name><argument_list>()</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr><name>virtual</name> <name>nsRect</name> <call><name>GetBounds</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegion</name></expr></argument>,
                                   <argument><expr><name>nsRegion</name>* <name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>PRBool</name> <call><name>TryMerge</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsDisplayItem</name>* <name>aItem</name></expr></argument>)</argument_list></call></expr>;
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"Clip"</argument>, <argument>TYPE_CLIP</argument>)</argument_list></macro>
  <expr><name>virtual</name> <name>PRUint32</name> <macro><name>GetPerFrameKey</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr>0</expr>;</return></block></expr> }</block>
  
  const <name>nsRect</name>&amp; <macro><name>GetClipRect</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>mClip</name></expr>;</return> }</block></expr></expr_stmt>
  <function><type><name>void</name></type> <name>SetClipRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mClip</name> = <name>aRect</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>nsIFrame</name>*</type> <name>GetClippingFrame</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mClippingFrame</name></expr>;</return> }</block></function>

  <function_decl><type><name>virtual</name> <name>nsDisplayWrapList</name>*</type> <name>WrapWithClone</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                           <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
  <comment type="line">// The frame that is responsible for the clipping. This may be different</comment>
  <comment type="line">// from mFrame because mFrame represents the content that is being</comment>
  <comment type="line">// clipped, and for example may be used to obtain the z-index of the</comment>
  <comment type="line">// content.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>mClippingFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type>    <name>mClip</name></decl>;</decl_stmt>
};

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
<comment type="block">/**
 * A display item to paint a stacking context with effects
 * set by the stacking context root frame's style.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsDisplaySVGEffects</name> : <name>public</name> <name>nsDisplayWrapList</name> <block>{
<expr><name>public</name>:
  <call><name>nsDisplaySVGEffects</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayList</name>* <name>aList</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <expr><name>virtual</name> ~<call><name>nsDisplaySVGEffects</name><argument_list>()</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr><name>virtual</name> <name>PRBool</name> <call><name>IsOpaque</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>void</name> <call><name>HitTest</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>,
                       <argument><expr><name>HitTestState</name>* <name>aState</name></expr></argument>, <argument><expr><name>nsTArray</name>&lt;<name>nsIFrame</name>*&gt; *<name>aOutFrames</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>virtual</name> <name>nsRect</name> <macro><name>GetBounds</name><argument_list>(<argument>nsDisplayListBuilder* aBuilder</argument>)</argument_list></macro> <block>{
    <return>return <expr><name>mBounds</name> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mEffectsFrame</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
  }</block>
  <name>virtual</name> <name>void</name> <call><name>Paint</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name>* <name>aBuilder</name></expr></argument>, <argument><expr><name>nsIRenderingContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>ComputeVisibility</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list>;</function_decl>  
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>TryMerge</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>;</function_decl>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"SVGEffects"</argument>, <argument>TYPE_SVG_EFFECTS</argument>)</argument_list></macro>

  <function><type><name>nsIFrame</name>*</type> <name>GetEffectsFrame</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mEffectsFrame</name></expr>;</return> }</block></function>

<label><name>private</name>:</label>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>mEffectsFrame</name></decl>;</decl_stmt>
  <comment type="line">// relative to mEffectsFrame</comment>
  <decl_stmt><decl><type><name>nsRect</name></type>    <name>mBounds</name></decl>;</decl_stmt>
};
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A display item that applies a transformation to all of its descendent
 * elements.  This wrapper should only be used if there is a transform applied
 * to the root element.
 * INVARIANT: The wrapped frame is transformed.
 * INVARIANT: The wrapped frame is non-null.
 */</comment> 
<expr_stmt><expr><name>class</name> <name>nsDisplayTransform</name>: <name>public</name> <name>nsDisplayItem</name>
<block>{
<expr><name>public</name>:
  <comment type="block">/* Constructor accepts a display list, empties it, and wraps it up.  It also
   * ferries the underlying frame to the nsDisplayItem constructor.
   */</comment>
  <call><name>nsDisplayTransform</name><argument_list>(<argument><expr><name>nsIFrame</name> *<name>aFrame</name></expr></argument>, <argument><expr><name>nsDisplayList</name> *<name>aList</name></expr></argument>)</argument_list></call> :
    <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>, <macro><name>mStoredList</name><argument_list>(<argument>aFrame</argument>, <argument>aList</argument>)</argument_list></macro>
  <expr><block>{
    <expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayTransform</name></expr></argument>)</argument_list></call></expr>;
  }</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <name>virtual</name> ~<macro><name>nsDisplayTransform</name><argument_list>()</argument_list></macro>
  <block>{
    <expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayTransform</name></expr></argument>)</argument_list></call></expr>;
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <call><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument><expr>"nsDisplayTransform"</expr></argument>, <argument><expr><name>TYPE_TRANSFORM</name></expr></argument>)</argument_list></call></expr>;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
  <expr><name>nsDisplayWrapList</name>* <macro><name>GetStoredList</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr>&amp;<name>mStoredList</name></expr>;</return></block></expr> }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <name>virtual</name> <name>void</name> <call><name>HitTest</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name> *<name>aBuilder</name></expr></argument>, <argument><expr>const <name>nsRect</name>&amp; <name>aRect</name></expr></argument>,
                       <argument><expr><name>HitTestState</name> *<name>aState</name></expr></argument>, <argument><expr><name>nsTArray</name>&lt;<name>nsIFrame</name>*&gt; *<name>aOutFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>virtual</name> <name>nsRect</name></type> <name>GetBounds</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>IsOpaque</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>IsUniform</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>, <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type>   <name>Paint</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                       <param><decl><type><name>nsIRenderingContext</name> *</type><name>aCtx</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>ComputeVisibility</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name> *</type><name>aVisibleRegion</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name> *</type><name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>PRBool</name></type> <name>TryMerge</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>, <param><decl><type><name>nsDisplayItem</name> *</type><name>aItem</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * TransformRect takes in as parameters a rectangle (in aFrame's coordinate
   * space) and returns the smallest rectangle (in aFrame's coordinate space)
   * containing the transformed image of that rectangle.  That is, it takes
   * the four corners of the rectangle, transforms them according to the
   * matrix associated with the specified frame, then returns the smallest
   * rectangle containing the four transformed points.
   *
   * @param untransformedBounds The rectangle (in app units) to transform.
   * @param aFrame The frame whose transformation should be applied.  This
   *        function raises an assertion if aFrame is null or doesn't have a
   *        transform applied to it.
   * @param aOrigin The origin of the transform relative to aFrame's local
   *        coordinate space.
   * @param aBoundsOverride (optional) Rather than using the frame's computed
   *        bounding rect as frame bounds, use this rectangle instead.  Pass
   *        nsnull (or nothing at all) to use the default.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type> <name>TransformRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name> &amp;</type><name>aUntransformedBounds</name></decl></param>, 
                              <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aOrigin</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>aBoundsOverride</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* UntransformRect is like TransformRect, except that it inverts the
   * transform.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type> <name>UntransformRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name> &amp;</type><name>aUntransformedBounds</name></decl></param>, 
                                <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aOrigin</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Returns the bounds of a frame as defined for transforms.  If
   * UNIFIED_CONTINUATIONS is not defined, this is simply the frame's bounding
   * rectangle, translated to the origin.  Otherwise, returns the smallest
   * rectangle containing a frame and all of its continuations.  For example,
   * if there is a &lt;span&gt; element with several continuations split over
   * several lines, this function will return the rectangle containing all of
   * those continuations.  This rectangle is relative to the origin of the
   * frame's local coordinate space.
   *
   * @param aFrame The frame to get the bounding rect for.
   * @return The frame's bounding rect, as described above.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>nsRect</name></type> <name>GetFrameBoundsForTransform</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * Given a frame with the -moz-transform property, returns the
   * transformation matrix for that frame.
   *
   * @param aFrame The frame to get the matrix from.
   * @param aOrigin Relative to which point this transform should be applied.
   * @param aScaleFactor The number of app units per graphics unit.
   * @param aBoundsOverride [optional] If this is nsnull (the default), the
   *        computation will use the value of GetFrameBoundsForTransform(aFrame)
   *        for the frame's bounding rectangle. Otherwise, it will use the
   *        value of aBoundsOverride.  This is mostly for internal use and in
   *        most cases you will not need to specify a value.
   */</comment>
  <function_decl><type><specifier>static</specifier> <name>gfxMatrix</name></type> <name>GetResultingTransformMatrix</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsPoint</name>&amp;</type> <name>aOrigin</name></decl></param>,
                                               <param><decl><type><name>float</name></type> <name>aFactor</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>aBoundsOverride</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
  <decl_stmt><decl><type><name>nsDisplayWrapList</name></type> <name>mStoredList</name></decl>;</decl_stmt>
};

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*NSDISPLAYLIST_H_*/</comment>
</unit>
