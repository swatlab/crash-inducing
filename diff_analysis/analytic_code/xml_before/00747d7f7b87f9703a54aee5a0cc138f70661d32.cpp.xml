<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00747d7f7b87f9703a54aee5a0cc138f70661d32.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * Base class for DOM Core's nsIDOMComment, nsIDOMDocumentType, nsIDOMText,
 * nsIDOMCDATASection, and nsIDOMProcessingInstruction nodes.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGenericDOMDataNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGenericElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIEventListenerManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMutationEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsINameSpaceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOM3Node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIURI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrivateDOMEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMText.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDOMString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMUserDataHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsChangeHint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsEventDispatcher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNodeUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBindingManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCCUncollectableMarker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozAutoDocUpdate.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pldhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>

<constructor><name><name>nsGenericDOMDataNode</name>::<name>nsGenericDOMDataNode</name></name><parameter_list>(<param><decl><type><name>nsINodeInfo</name> *</type><name>aNodeInfo</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsIContent</name><argument_list>(<argument><expr><name>aNodeInfo</name></expr></argument>)</argument_list></call>
</member_list><block>{
}</block></constructor>

<destructor><name><name>nsGenericDOMDataNode</name>::~<name>nsGenericDOMDataNode</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name>IsInDoc</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Please remove this from the document properly"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<macro><name>NS_IMPL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>nsGenericDOMDataNode</argument>)</argument_list></macro>

<macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN</name><argument_list>(<argument>nsGenericDOMDataNode</argument>)</argument_list></macro>
  <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>currentDoc</name> <init>= <expr><call><name><name>tmp</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>currentDoc</name> &amp;&amp; <call><name><name>nsCCUncollectableMarker</name>::<name>InGeneration</name></name><argument_list>(
                      <argument><expr><call><name><name>currentDoc</name>-&gt;<name>GetMarkedCCGeneration</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mNodeInfo</argument>)</argument_list></macro>

  <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>ownerDoc</name> <init>= <expr><call><name><name>tmp</name>-&gt;<name>GetOwnerDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>ownerDoc</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>ownerDoc</name>-&gt;<name>BindingManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Traverse</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER</name>
  <name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA</name>
  <name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_PRESERVED_WRAPPER</name>
<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</name></type>

<name>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN</name><argument_list>(<argument><expr><name>nsGenericDOMDataNode</name></expr></argument>)</argument_list>
  <name>NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER</name>
  <name>NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA</name>
  <name>NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER</name>
<name>NS_IMPL_CYCLE_COLLECTION_UNLINK_END</name>

<name>NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION</name><argument_list>(<argument><expr><name>nsGenericDOMDataNode</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsIContent</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsINode</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsPIDOMEventTarget</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY_TEAROFF</name><argument_list>(<argument><expr><name>nsIDOMEventTarget</name></expr></argument>,
                                 <argument><expr><call><name><name>nsDOMEventRTTearoff</name>::<name>Create</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY_TEAROFF</name><argument_list>(<argument><expr><name>nsIDOM3EventTarget</name></expr></argument>,
                                 <argument><expr><call><name><name>nsDOMEventRTTearoff</name>::<name>Create</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY_TEAROFF</name><argument_list>(<argument><expr><name>nsIDOMNSEventTarget</name></expr></argument>,
                                 <argument><expr><call><name><name>nsDOMEventRTTearoff</name>::<name>Create</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY_TEAROFF</name><argument_list>(<argument><expr><name>nsISupportsWeakReference</name></expr></argument>,
                                 <argument><expr>new <call><name>nsNodeSupportsWeakRefTearoff</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY_TEAROFF</name><argument_list>(<argument><expr><name>nsIDOM3Node</name></expr></argument>, <argument><expr>new <call><name>nsNode3Tearoff</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
  <comment type="line">// nsNodeSH::PreCreate() depends on the identity pointer being the</comment>
  <comment type="line">// same as nsINode (which nsIContent inherits), so if you change the</comment>
  <comment type="line">// below line, make sure nsNodeSH::PreCreate() still does the right</comment>
  <comment type="line">// thing!</comment>
  <name>NS_INTERFACE_MAP_ENTRY_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsISupports</name></expr></argument>, <argument><expr><name>nsIContent</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_END</name>

<name>NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsGenericDOMDataNode</name></expr></argument>, <argument><expr><name>nsIContent</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTING_RELEASE_FULL</name><argument_list>(<argument><expr><name>nsGenericDOMDataNode</name></expr></argument>, <argument><expr><name>nsIContent</name></expr></argument>,
                                      <argument><expr><call><name><name>nsNodeUtils</name>::<name>LastRelease</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>


<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetNodeValue</name></name><argument_list>(<argument><expr><name>nsAString</name>&amp; <name>aNodeValue</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><call><name>GetData</name><argument_list>(<argument><expr><name>aNodeValue</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>SetNodeValue</name></name><argument_list>(<argument><expr>const <name>nsAString</name>&amp; <name>aNodeValue</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><call><name>SetTextInternal</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aNodeValue</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>aNodeValue</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetParentNode</name></name><argument_list>(<argument><expr><name>nsIDOMNode</name>** <name>aParentNode</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr>*<name>aParentNode</name> = <name>nsnull</name></expr></argument>;
  <argument><expr><name>nsINode</name> *<name>parent</name> = <call><name>GetNodeParent</name><argument_list>()</argument_list></call></expr></argument>;

  return <argument><expr><name>parent</name> ? <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call> : <name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetPreviousSibling</name></name><argument_list>(<argument><expr><name>nsIDOMNode</name>** <name>aPrevSibling</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr>*<name>aPrevSibling</name> = <name>nsnull</name></expr></argument>;

  <argument><expr><name>nsINode</name> *<name>parent</name> = <call><name>GetNodeParent</name><argument_list>()</argument_list></call></expr></argument>;
  if <argument><expr>(!<name>parent</name>) <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block>

  <name>PRInt32</name> <name>pos</name> = <call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>;
  <argument><expr><name>nsIContent</name> *<name>sibling</name> = <call><name><name>parent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>pos</name> - 1</expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><name>sibling</name> ? <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>sibling</name></expr></argument>, <argument><expr><name>aPrevSibling</name></expr></argument>)</argument_list></call> : <name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetNextSibling</name></name><argument_list>(<argument><expr><name>nsIDOMNode</name>** <name>aNextSibling</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr>*<name>aNextSibling</name> = <name>nsnull</name></expr></argument>;

  <argument><expr><name>nsINode</name> *<name>parent</name> = <call><name>GetNodeParent</name><argument_list>()</argument_list></call></expr></argument>;
  if <argument><expr>(!<name>parent</name>) <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block>

  <name>PRInt32</name> <name>pos</name> = <call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>;
  <argument><expr><name>nsIContent</name> *<name>sibling</name> = <call><name><name>parent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>pos</name> + 1</expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><name>sibling</name> ? <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>sibling</name></expr></argument>, <argument><expr><name>aNextSibling</name></expr></argument>)</argument_list></call> : <name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetChildNodes</name></name><argument_list>(<argument><expr><name>nsIDOMNodeList</name>** <name>aChildNodes</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr>*<name>aChildNodes</name> = <name>nsnull</name></expr></argument>;
  <argument><expr><name>nsDataSlots</name> *<name>slots</name> = <call><name>GetDataSlots</name><argument_list>()</argument_list></call></expr></argument>;
  <argument><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr></argument>;

  if <argument><expr>(!<name><name>slots</name>-&gt;<name>mChildNodes</name></name>) <block>{
    <expr><name><name>slots</name>-&gt;<name>mChildNodes</name></name> = new <call><name>nsChildContentList</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name><name>slots</name>-&gt;<name>mChildNodes</name></name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name><name>slots</name>-&gt;<name>mChildNodes</name></name></expr></argument>)</argument_list></call></expr>;
  }</block>

  <call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aChildNodes</name> = <name><name>slots</name>-&gt;<name>mChildNodes</name></name></expr></argument>)</argument_list></call></expr></argument>;
  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetOwnerDocument</name></name><argument_list>(<argument><expr><name>nsIDOMDocument</name>** <name>aOwnerDocument</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><name>nsIDocument</name> *<name>document</name> = <call><name>GetOwnerDoc</name><argument_list>()</argument_list></call></expr></argument>;
  if <argument><expr>(<name>document</name>) <block>{
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>document</name></expr></argument>, <argument><expr><name>aOwnerDocument</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>

  *<name>aOwnerDocument</name> = <name>nsnull</name></expr></argument>;

  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetNamespaceURI</name></name><argument_list>(<argument><expr><name>nsAString</name>&amp; <name>aNamespaceURI</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><call><name>SetDOMStringToNull</name><argument_list>(<argument><expr><name>aNamespaceURI</name></expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetPrefix</name></name><argument_list>(<argument><expr><name>nsAString</name>&amp; <name>aPrefix</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><call><name>SetDOMStringToNull</name><argument_list>(<argument><expr><name>aPrefix</name></expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>SetPrefix</name></name><argument_list>(<argument><expr>const <name>nsAString</name>&amp; <name>aPrefix</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><name>NS_ERROR_DOM_NAMESPACE_ERR</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetLocalName</name></name><argument_list>(<argument><expr><name>nsAString</name>&amp; <name>aLocalName</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><call><name>SetDOMStringToNull</name><argument_list>(<argument><expr><name>aLocalName</name></expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>Normalize</name></name><argument_list>()</argument_list>
<argument_list>{
  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>IsSupported</name></name><argument_list>(<argument><expr>const <name>nsAString</name>&amp; <name>aFeature</name></expr></argument>,
                                  <argument><expr>const <name>nsAString</name>&amp; <name>aVersion</name></expr></argument>,
                                  <argument><expr><name>PRBool</name>* <name>aReturn</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><call><name><name>nsGenericElement</name>::<name>InternalIsSupported</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIContent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><name>aFeature</name></expr></argument>, <argument><expr><name>aVersion</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>GetBaseURI</name></name><argument_list>(<argument><expr><name>nsAString</name>&amp; <name>aURI</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name> <name>baseURI</name> = <call><name>GetBaseURI</name><argument_list>()</argument_list></call></expr></argument>;
  <argument><expr><name>nsCAutoString</name> <name>spec</name></expr></argument>;

  if <argument><expr>(<name>baseURI</name>) <block>{
    <expr><call><name><name>baseURI</name>-&gt;<name>GetSpec</name></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;
  }</block>

  <call><name>CopyUTF8toUTF16</name><argument_list>(<argument><expr><name>spec</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name>
<name><name>nsGenericDOMDataNode</name>::<name>LookupPrefix</name></name><argument_list>(<argument><expr>const <name>nsAString</name>&amp; <name>aNamespaceURI</name></expr></argument>,
                                   <argument><expr><name>nsAString</name>&amp; <name>aPrefix</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><call><name><name>aPrefix</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr></argument>;

  <argument><expr><name>nsIContent</name> *<name>parent_weak</name> = <call><name>GetParent</name><argument_list>()</argument_list></call></expr></argument>;

  <comment type="line">// DOM Data Node passes the query on to its parent</comment>
  <argument><expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOM3Node</name></expr></argument>&gt;</argument_list></name> <call><name>node</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>parent_weak</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;
  if <argument><expr>(<name>node</name>) <block>{
    <return>return <expr><call><name><name>node</name>-&gt;<name>LookupPrefix</name></name><argument_list>(<argument><expr><name>aNamespaceURI</name></expr></argument>, <argument><expr><name>aPrefix</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></expr></argument>

  <return>return <expr><name>NS_OK</name></expr>;</return></argument_list></decl></decl_stmt>
}

nsresult
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>LookupNamespaceURI</name></name>(const <name>nsAString</name>&amp; <name>aNamespacePrefix</name>,
                                         <name>nsAString</name>&amp; <name>aNamespaceURI</name>)
<block>{
  <expr><call><name><name>aNamespaceURI</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;

  <expr><name>nsIContent</name> *<name>parent_weak</name> = <call><name>GetParent</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// DOM Data Node passes the query on to its parent</comment>
  <expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOM3Node</name></expr></argument>&gt;</argument_list></name> <call><name>node</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>parent_weak</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

  <if>if <condition>(<expr><name>node</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>node</name>-&gt;<name>LookupNamespaceURI</name></name><argument_list>(<argument><expr><name>aNamespacePrefix</name></expr></argument>, <argument><expr><name>aNamespaceURI</name></expr></argument>)</argument_list></call></expr>;</return>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

<comment type="line">//----------------------------------------------------------------------</comment>

<comment type="line">// Implementation of nsIDOMCharacterData</comment>

nsresult
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>GetData</name></name>(<name>nsAString</name>&amp; <name>aData</name>) const
<block>{
  <if>if <condition>(<expr><call><name><name>mText</name>.<name>Is2b</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aData</name>.<name>Assign</name></name><argument_list>(<argument><expr><call><name><name>mText</name>.<name>Get2b</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt> <else>else <block>{
    <comment type="line">// Must use Substring() since nsDependentCString() requires null</comment>
    <comment type="line">// terminated strings.</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name> <init>= <expr><call><name><name>mText</name>.<name>Get1b</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>data</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>CopyASCIItoUTF16</name><argument_list>(<argument><expr><call><name>Substring</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> + <call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>aData</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

nsresult
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>SetData</name></name>(const <name>nsAString</name>&amp; <name>aData</name>)
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aData</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>aData</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetLength</name></name><parameter_list>(<param><decl><type><name>PRUint32</name>*</type> <name>aLength</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aLength</name> = <call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SubstringData</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aStart</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>,
                                    <param><decl><type><name>nsAString</name>&amp;</type> <name>aReturn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aReturn</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXX add &lt;0 checks if types change</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>textLength</name> <init>= <expr><call><name>PRUint32</name><argument_list>( <argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aStart</name> &gt; <name>textLength</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_DOM_INDEX_SIZE_ERR</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>amount</name> <init>= <expr><name>aCount</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>amount</name> &gt; <name>textLength</name> - <name>aStart</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>amount</name> = <name>textLength</name> - <name>aStart</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><call><name><name>mText</name>.<name>Is2b</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aReturn</name>.<name>Assign</name></name><argument_list>(<argument><expr><call><name><name>mText</name>.<name>Get2b</name></name><argument_list>()</argument_list></call> + <name>aStart</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Must use Substring() since nsDependentCString() requires null</comment>
    <comment type="line">// terminated strings.</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name> <init>= <expr><call><name><name>mText</name>.<name>Get1b</name></name><argument_list>()</argument_list></call> + <name>aStart</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CopyASCIItoUTF16</name><argument_list>(<argument><expr><call><name>Substring</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> + <name>amount</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>AppendData</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name><name>aData</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>aData</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>InsertData</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name><name>aData</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>aData</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>DeleteData</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>ReplaceData</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>, <argument><expr><call><name><name>aData</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>aData</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SetTextInternal</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aBuffer</name></decl></param>,
                                      <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aBuffer</name> || !<name>aLength</name></expr></argument>,
                  <argument><expr>"Null buffer passed to SetTextInternal!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// sanitize arguments</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>textLength</name> <init>= <expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aOffset</name> &gt; <name>textLength</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_DOM_INDEX_SIZE_ERR</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>document</name> <init>= <expr><call><name>GetCurrentDoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>mozAutoDocUpdate</name></type> <name>updateBatch</name><parameter_list>(<param><decl><type><name>document</name></type></decl></param>, <param><decl><type><name>UPDATE_CONTENT_MODEL</name></type></decl></param>, <param><decl><type><name>aNotify</name></type></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveMutationListeners</name> <init>= <expr><name>aNotify</name> &amp;&amp;
    <call><name><name>nsContentUtils</name>::<name>HasMutationListeners</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
      <argument><expr><name>NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED</name></expr></argument>,
      <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>oldValue</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>haveMutationListeners</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>oldValue</name> = <call><name>GetCurrentValueAtom</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
    
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>endOffset</name> <init>= <expr><name>aOffset</name> + <name>aCount</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>endOffset</name> &gt; <name>textLength</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aCount</name> = <name>textLength</name> - <name>aOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endOffset</name> = <name>textLength</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aNotify</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>CharacterDataChangeInfo</name></type> <name>info</name> <init>= <expr><block>{
      <expr><name>aOffset</name> == <name>textLength</name></expr>,
      <expr><name>aOffset</name></expr>,
      <expr><name>endOffset</name></expr>,
      <expr><name>aLength</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>nsNodeUtils</name>::<name>CharacterDataWillChange</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aOffset</name> == 0 &amp;&amp; <name>endOffset</name> == <name>textLength</name></expr>)</condition><then> <block>{
    <comment type="line">// Replacing whole text or old text was empty</comment>
    <expr_stmt><expr><call><name><name>mText</name>.<name>SetTo</name></name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aOffset</name> == <name>textLength</name></expr>)</condition><then> <block>{
    <comment type="line">// Appending to existing</comment>
    <expr_stmt><expr><call><name><name>mText</name>.<name>Append</name></name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <comment type="line">// Merging old and new</comment>

    <comment type="line">// Allocate new buffer</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>newLength</name> <init>= <expr><name>textLength</name> - <name>aCount</name> + <name>aLength</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUnichar</name>*</type> <name>to</name> <init>= <expr>new <name><name>PRUnichar</name><index>[<expr><name>newLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Copy over appropriate data</comment>
    <if>if <condition>(<expr>0 != <name>aOffset</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mText</name>.<name>CopyTo</name></name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>0 != <name>aLength</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>to</name> + <name>aOffset</name></expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aLength</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PRUnichar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>endOffset</name> != <name>textLength</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mText</name>.<name>CopyTo</name></name><argument_list>(<argument><expr><name>to</name> + <name>aOffset</name> + <name>aLength</name></expr></argument>, <argument><expr><name>endOffset</name></expr></argument>, <argument><expr><name>textLength</name> - <name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// XXX Add OOM checking to this</comment>
    <expr_stmt><expr><call><name><name>mText</name>.<name>SetTo</name></name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>delete <index>[]</index> <name>to</name></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <expr_stmt><expr><call><name>SetBidiStatus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Notify observers</comment>
  <if>if <condition>(<expr><name>aNotify</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>CharacterDataChangeInfo</name></type> <name>info</name> <init>= <expr><block>{
      <expr><name>aOffset</name> == <name>textLength</name></expr>,
      <expr><name>aOffset</name></expr>,
      <expr><name>endOffset</name></expr>,
      <expr><name>aLength</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>nsNodeUtils</name>::<name>CharacterDataChanged</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>haveMutationListeners</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>mozAutoRemovableBlockerRemover</name></type> <name>blockerRemover</name></decl>;</decl_stmt>

      <function_decl><type><name>nsMutationEvent</name></type> <name>mutation</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MUTATION_CHARACTERDATAMODIFIED</name></type></decl></param>)</parameter_list>;</function_decl>

      <expr_stmt><expr><name><name>mutation</name>.<name>mPrevAttrValue</name></name> = <name>oldValue</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>aLength</name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>val</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mText</name>.<name>AppendTo</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mutation</name>.<name>mNewAttrValue</name></name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <decl_stmt><decl><type><name>mozAutoSubtreeModified</name></type> <name>subtree</name><argument_list>(<argument><expr><call><name>GetOwnerDoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>nsEventDispatcher</name>::<name>Dispatch</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>&amp;<name>mutation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<comment type="line">// Implementation of nsIContent</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>ToCString</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aBuf</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aLen</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><call><name><name>mText</name>.<name>Is2b</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>cp</name> <init>= <expr><call><name><name>mText</name>.<name>Get2b</name></name><argument_list>()</argument_list></call> + <name>aOffset</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>end</name> <init>= <expr><name>cp</name> + <name>aLen</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>cp</name> &lt; <name>end</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>ch</name> <init>= <expr>*<name>cp</name>++</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>ch</name> == '&amp;'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"&amp;amp;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '&lt;'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"&amp;lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '&gt;'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"&amp;gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>(<name>ch</name> &lt; ' ') || (<name>ch</name> &gt;= 127)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"\\u%04x"</expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendASCIItoUTF16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>Append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if></else></if></else></if></else></if>
    }</block></while>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name>*</type> <name>cp</name> <init>= <expr>(<name>unsigned</name> <name>char</name>*)<call><name><name>mText</name>.<name>Get1b</name></name><argument_list>()</argument_list></call> + <name>aOffset</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>end</name> <init>= <expr><name>cp</name> + <name>aLen</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>cp</name> &lt; <name>end</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>ch</name> <init>= <expr>*<name>cp</name>++</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>ch</name> == '&amp;'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"&amp;amp;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '&lt;'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"&amp;lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '&gt;'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"&amp;gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>(<name>ch</name> &lt; ' ') || (<name>ch</name> &gt;= 127)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"\\u%04x"</expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendASCIItoUTF16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>aBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name><name>aBuf</name>.<name>Append</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if></else></if></else></if></else></if>
    }</block></while>
  }</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>BindToTree</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aParent</name></decl></param>,
                                 <param><decl><type><name>nsIContent</name>*</type> <name>aBindingParent</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>aCompileEventHandlers</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aParent</name> || <name>aDocument</name></expr></argument>, <argument><expr>"Must have document if no parent!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name>HasSameOwnerDoc</name><argument_list>(<argument><expr><call><name>NODE_FROM</name><argument_list>(<argument><expr><name>aParent</name></expr></argument>, <argument><expr><name>aDocument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr>"Must have the same owner document"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>aParent</name> || <name>aDocument</name> == <call><name><name>aParent</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"aDocument must be current doc of aParent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name>GetCurrentDoc</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>IsInDoc</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Already have a document.  Unbind first!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Note that as we recurse into the kids, they'll have a non-null parent.  So</comment>
  <comment type="line">// only assert if our parent is _changing_ while we have a parent.</comment>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name>GetParent</name><argument_list>()</argument_list></call> || <name>aParent</name> == <call><name>GetParent</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Already have a parent.  Unbind first!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name>GetBindingParent</name><argument_list>()</argument_list></call> ||
                  <name>aBindingParent</name> == <call><name>GetBindingParent</name><argument_list>()</argument_list></call> ||
                  (!<name>aBindingParent</name> &amp;&amp; <name>aParent</name> &amp;&amp;
                   <call><name><name>aParent</name>-&gt;<name>GetBindingParent</name></name><argument_list>()</argument_list></call> == <call><name>GetBindingParent</name><argument_list>()</argument_list></call>)</expr></argument>,
                  <argument><expr>"Already have a binding parent.  Unbind first!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aBindingParent</name> != <name>this</name> || <call><name>IsNativeAnonymous</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Only native anonymous content should have itself as its "
                  "own binding parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>aBindingParent</name> &amp;&amp; <name>aParent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aBindingParent</name> = <call><name><name>aParent</name>-&gt;<name>GetBindingParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// First set the binding parent</comment>
  <if>if <condition>(<expr><name>aBindingParent</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsDataSlots</name> *</type><name>slots</name> <init>= <expr><call><name>GetDataSlots</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IsNativeAnonymous</name><argument_list>()</argument_list></call> || !<call><name>HasFlag</name><argument_list>(<argument><expr><name>NODE_IS_IN_ANONYMOUS_SUBTREE</name></expr></argument>)</argument_list></call> ||
                 <call><name><name>aBindingParent</name>-&gt;<name>IsInNativeAnonymousSubtree</name></name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Trying to re-bind content from native anonymous subtree to"
                 "non-native anonymous parent!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>slots</name>-&gt;<name>mBindingParent</name></name> = <name>aBindingParent</name></expr>;</expr_stmt> <comment type="line">// Weak, so no addref happens.</comment>
    <if>if <condition>(<expr><call><name>IsNativeAnonymous</name><argument_list>()</argument_list></call> ||
        <call><name><name>aBindingParent</name>-&gt;<name>IsInNativeAnonymousSubtree</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetFlags</name><argument_list>(<argument><expr><name>NODE_IS_IN_ANONYMOUS_SUBTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Set parent</comment>
  <if>if <condition>(<expr><name>aParent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mParentPtrBits</name> =
      <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>PtrBits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aParent</name></expr></argument>)</argument_list></call> | <name>PARENT_BIT_PARENT_IS_CONTENT</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>mParentPtrBits</name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>PtrBits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aDocument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="line">// XXXbz sXBL/XBL2 issue!</comment>

  <comment type="line">// Set document</comment>
  <if>if <condition>(<expr><name>aDocument</name></expr>)</condition><then> <block>{
    <comment type="line">// XXX See the comment in nsGenericElement::BindToTree</comment>
    <expr_stmt><expr><name>mParentPtrBits</name> |= <name>PARENT_BIT_INDOCUMENT</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>mText</name>.<name>IsBidi</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aDocument</name>-&gt;<name>SetBidiEnabled</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsNodeUtils</name>::<name>ParentChainChanged</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>UpdateEditableState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_POSTCONDITION</name><argument_list>(<argument><expr><name>aDocument</name> == <call><name>GetCurrentDoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Bound to wrong document"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_POSTCONDITION</name><argument_list>(<argument><expr><name>aParent</name> == <call><name>GetParent</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Bound to wrong parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_POSTCONDITION</name><argument_list>(<argument><expr><name>aBindingParent</name> == <call><name>GetBindingParent</name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr>"Bound to wrong binding parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>UnbindFromTree</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aDeep</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aNullParent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>document</name> <init>= <expr><call><name>GetCurrentDoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>document</name></expr>)</condition><then> <block>{
    <comment type="line">// Notify XBL- &amp; nsIAnonymousContentCreator-generated</comment>
    <comment type="line">// anonymous content that the document is changing.</comment>
    <comment type="line">// This is needed to update the insertion point.</comment>
    <expr_stmt><expr><call><name><name>document</name>-&gt;<name>BindingManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ChangeDocumentFor</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>document</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>mParentPtrBits</name> = <name>aNullParent</name> ? 0 : <name>mParentPtrBits</name> &amp; ~<name>PARENT_BIT_INDOCUMENT</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsDataSlots</name> *</type><name>slots</name> <init>= <expr><call><name>GetExistingDataSlots</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>slots</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>slots</name>-&gt;<name>mBindingParent</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsNodeUtils</name>::<name>ParentChainChanged</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsIAtom</name> *</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetIDAttributeName</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsINodeInfo</name></expr></argument>&gt;</argument_list></name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetExistingAttrNameFromQName</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aStr</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SetAttr</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNameSpaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aAttr</name></decl></param>,
                              <param><decl><type><name>nsIAtom</name>*</type> <name>aPrefix</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aValue</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>UnsetAttr</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNameSpaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aAttr</name></decl></param>,
                                <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetAttr</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNameSpaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name> *</type><name>aAttr</name></decl></param>,
                              <param><decl><type><name>nsAString</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name><name>aResult</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>HasAttr</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNameSpaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name> *</type><name>aAttribute</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>nsAttrName</name>*</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetAttrNameAt</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>PRUint32</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetAttrCount</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>PreHandleEvent</name></name><parameter_list>(<param><decl><type><name>nsEventChainPreVisitor</name>&amp;</type> <name>aVisitor</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>nsGenericElement</name>::<name>doPreHandleEvent</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aVisitor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>PostHandleEvent</name></name><parameter_list>(<param><decl><type><name>nsEventChainPostVisitor</name>&amp;</type></decl></param> <comment type="block">/*aVisitor*/</comment>)</parameter_list>
<block>{
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>DispatchDOMEvent</name></name><parameter_list>(<param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>,
                                       <param><decl><type><name>nsIDOMEvent</name>*</type> <name>aDOMEvent</name></decl></param>,
                                       <param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                                       <param><decl><type><name>nsEventStatus</name>*</type> <name>aEventStatus</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>nsEventDispatcher</name>::<name>DispatchDOMEvent</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsINode</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>aEvent</name></expr></argument>, <argument><expr><name>aDOMEvent</name></expr></argument>,
                                             <argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aEventStatus</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetListenerManager</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCreateIfNotFound</name></decl></param>,
                                         <param><decl><type><name>nsIEventListenerManager</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>nsContentUtils</name>::<name>GetListenerManager</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aCreateIfNotFound</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>AddEventListenerByIID</name></name><parameter_list>(<param><decl><type><name>nsIDOMEventListener</name> *</type><name>aListener</name></decl></param>,
                                            <param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>aIID</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEventListenerManager</name></expr></argument>&gt;</argument_list></name></type> <name>elm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetListenerManager</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>elm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>elm</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>elm</name>-&gt;<name>AddEventListenerByIID</name></name><argument_list>(<argument><expr><name>aListener</name></expr></argument>, <argument><expr><name>aIID</name></expr></argument>, <argument><expr><name>NS_EVENT_FLAG_BUBBLE</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>RemoveEventListenerByIID</name></name><parameter_list>(<param><decl><type><name>nsIDOMEventListener</name> *</type><name>aListener</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>aIID</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEventListenerManager</name></expr></argument>&gt;</argument_list></name></type> <name>elm</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetListenerManager</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>elm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>elm</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>elm</name>-&gt;<name>RemoveEventListenerByIID</name></name><argument_list>(<argument><expr><name>aListener</name></expr></argument>, <argument><expr><name>aIID</name></expr></argument>, <argument><expr><name>NS_EVENT_FLAG_BUBBLE</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetSystemEventGroup</name></name><parameter_list>(<param><decl><type><name>nsIDOMEventGroup</name>**</type> <name>aGroup</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEventListenerManager</name></expr></argument>&gt;</argument_list></name></type> <name>elm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetListenerManager</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>elm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>elm</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>elm</name>-&gt;<name>GetSystemEventGroupLM</name></name><argument_list>(<argument><expr><name>aGroup</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>PRUint32</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetChildCount</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>nsIContent</name> *</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetChildAt</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>IndexOf</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aPossibleChild</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>InsertChildAt</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aKid</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aIndex</name></decl></param>,
                                    <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>RemoveChildAt</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aIndex</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// virtual</comment>
<function><type><name>PRBool</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>MayHaveFrame</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>parent</name> <init>= <expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>parent</name> &amp;&amp; <call><name><name>parent</name>-&gt;<name>MayHaveFrame</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIContent</name> *</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetBindingParent</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsDataSlots</name> *</type><name>slots</name> <init>= <expr><call><name>GetExistingDataSlots</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>slots</name> ? <name><name>slots</name>-&gt;<name>mBindingParent</name></name> : <name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>IsNodeOfType</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr>!(<name>aFlags</name> &amp; ~(<name>eCONTENT</name> | <name>eDATA_NODE</name>))</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SaveSubtreeState</name></name><parameter_list>()</parameter_list>
<block>{
}</block></function>

<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>DestroyContent</name></name><parameter_list>()</parameter_list>
<block>{
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>List</name></name><parameter_list>(<param><decl><type><name>FILE</name>*</type> <name>out</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndent</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
}</block></function>

<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>DumpContent</name></name><parameter_list>(<param><decl><type><name>FILE</name>*</type> <name>out</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndent</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type> <name>aDumpAll</name></decl></param>)</parameter_list> <specifier>const</specifier> 
<block>{
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetBaseURI</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <comment type="line">// DOM Data Node inherits the base from its parent element/document</comment>
  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>parent</name> <init>= <expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>parent</name>-&gt;<name>GetBaseURI</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIURI</name> *</type><name>uri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>doc</name> <init>= <expr><call><name>GetOwnerDoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>doc</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>uri</name> = <call><name><name>doc</name>-&gt;<name>GetBaseURI</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>uri</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>uri</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>IsLink</name></name><parameter_list>(<param><decl><type><name>nsIURI</name>**</type> <name>aURI</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr>*<name>aURI</name> = <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name><name>nsINode</name>::<name>nsSlots</name></name>*</type>
<name><name>nsGenericDOMDataNode</name>::<name>CreateSlots</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>new <call><name>nsDataSlots</name><argument_list>(<argument><expr><name>mFlagsOrSlots</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<comment type="line">// Implementation of the nsIDOMText interface</comment>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SplitText</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>, <param><decl><type><name>nsIDOMText</name>**</type> <name>aReturn</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>cutText</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name>TextLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aOffset</name> &gt; <name>length</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_DOM_INDEX_SIZE_ERR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rv</name> = <call><name>SubstringData</name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>, <argument><expr><name>length</name> - <name>aOffset</name></expr></argument>, <argument><expr><name>cutText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>rv</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rv</name> = <call><name>DeleteData</name><argument_list>(<argument><expr><name>aOffset</name></expr></argument>, <argument><expr><name>length</name> - <name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>rv</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/*
   * Use Clone for creating the new node so that the new node is of same class
   * as this node!
   */</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>newContent</name> <init>= <expr><call><name>CloneDataNode</name><argument_list>(<argument><expr><name>mNodeInfo</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>newContent</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>newContent</name>-&gt;<name>SetText</name></name><argument_list>(<argument><expr><name>cutText</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>parent</name> <init>= <expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr><call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newContent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>parent</name>-&gt;<name>InsertChildAt</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>index</name>+1</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// No need to handle the case of document being the parent since text</comment>
  <comment type="line">// isn't allowed as direct child of documents</comment>

  <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>newContent</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<comment type="line">// Implementation of the nsGenericDOMDataNode nsIDOM3Text tearoff</comment>

<macro><name>NS_IMPL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>nsText3Tearoff</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION</name><argument_list>(<argument>nsText3Tearoff</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIDOM3Text</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_MAP_END_AGGREGATED</name><argument_list>(<argument>mNode</argument>)</argument_list></macro>

<macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN</name><argument_list>(<argument>nsText3Tearoff</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mNode</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_END</name></type>

<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN</name><argument_list>(<argument><expr><name>nsText3Tearoff</name></expr></argument>)</argument_list>
  <name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS</name><argument_list>(<argument><expr><name>mNode</name></expr></argument>, <argument><expr><name>nsIContent</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</name>

<name>NS_IMPL_CYCLE_COLLECTING_ADDREF</name><argument_list>(<argument><expr><name>nsText3Tearoff</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTING_RELEASE</name><argument_list>(<argument><expr><name>nsText3Tearoff</name></expr></argument>)</argument_list>

<name>NS_IMETHODIMP</name>
<name><name>nsText3Tearoff</name>::<name>GetIsElementContentWhitespace</name></name><argument_list>(<argument><expr><name>PRBool</name> *<name>aReturn</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr></argument>;
}</argument_list>

<name>NS_IMETHODIMP</name>
<name><name>nsText3Tearoff</name>::<name>GetWholeText</name></name><argument_list>(<argument><expr><name>nsAString</name>&amp; <name>aWholeText</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><call><name><name>mNode</name>-&gt;<name>GetWholeText</name></name><argument_list>(<argument><expr><name>aWholeText</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<name>NS_IMETHODIMP</name>
<name><name>nsText3Tearoff</name>::<name>ReplaceWholeText</name></name><argument_list>(<argument><expr>const <name>nsAString</name>&amp; <name>aContent</name></expr></argument>,
                                 <argument><expr><name>nsIDOMText</name> **<name>aReturn</name></expr></argument>)</argument_list>
<argument_list>{
  return <argument><expr><call><name><name>mNode</name>-&gt;<name>ReplaceWholeText</name></name><argument_list>(<argument><expr><call><name>PromiseFlatString</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<comment type="line">// Implementation of the nsIDOM3Text interface</comment>

<comment type="block">/* static */</comment> <name>PRUint32</name>
<name><name>nsGenericDOMDataNode</name>::<name>FirstLogicallyAdjacentTextNode</name></name><argument_list>(<argument><expr><name>nsIContent</name>* <name>aParent</name></expr></argument>,
                                                     <argument><expr><name>PRUint32</name> <name>aIndex</name></expr></argument>)</argument_list>
<argument_list>{
  while <argument><expr>(<name>aIndex</name>-- &gt; 0) <block>{
    <expr><name>nsIContent</name>* <name>sibling</name> = <call><name><name>aParent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;
    <if>if <condition>(<expr>!<call><name><name>sibling</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eTEXT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>aIndex</name> + 1</expr>;</return></then></if>
  }</block></expr></argument>
  <return>return <expr>0</expr>;</return></argument_list></decl></decl_stmt>
}

<comment type="block">/* static */</comment> PRUint32
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>LastLogicallyAdjacentTextNode</name></name>(<name>nsIContent</name>* <name>aParent</name>,
                                                    <name>PRUint32</name> <name>aIndex</name>,
                                                    <name>PRUint32</name> <name>aCount</name>)
<block>{
  <while>while <condition>(<expr>++<name>aIndex</name> &lt; <name>aCount</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>sibling</name> <init>= <expr><call><name><name>aParent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>sibling</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eTEXT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>aIndex</name> - 1</expr>;</return></then></if>
  <expr_stmt/></block></while>}</block></expr></expr_stmt>
  <return>return <expr><name>aCount</name> - 1</expr>;</return>
}

nsresult
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>GetWholeText</name></name>(<name>nsAString</name>&amp; <name>aWholeText</name>)
<block>{
  <expr><name>nsIContent</name>* <name>parent</name> = <call><name>GetParent</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// Handle parent-less nodes</comment>
  <if>if <condition>(<expr>!<name>parent</name></expr>)</condition><then>
    <return>return <expr><call><name>GetData</name><argument_list>(<argument><expr><name>aWholeText</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <name>PRUint32</name> <name>index</name> = <call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>first</name> <init>=
    <expr><call><name>FirstLogicallyAdjacentTextNode</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>last</name> <init>=
    <expr><call><name>LastLogicallyAdjacentTextNode</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>parent</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>aWholeText</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMText</name></expr></argument>&gt;</argument_list></name></type> <name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>tmp</name></decl>;</decl_stmt>
  <do>do <block>{
    <expr_stmt><expr><name>node</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>parent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>node</name>-&gt;<name>GetData</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aWholeText</name>.<name>Append</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block> while <condition>(<expr><name>first</name>++ &lt; <name>last</name></expr>)</condition>;</do>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

nsresult
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>ReplaceWholeText</name></name>(const <name>nsAFlatString</name>&amp; <name>aContent</name>,
                                       <name>nsIDOMText</name> **<name>aReturn</name>)
<block>{
  <comment type="line">// Batch possible DOMSubtreeModified events.</comment>
  <expr><name>mozAutoSubtreeModified</name> <call><name>subtree</name><argument_list>(<argument><expr><call><name>GetOwnerDoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>mozAutoDocUpdate</name> <call><name>updateBatch</name><argument_list>(<argument><expr><call><name>GetCurrentDoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>UPDATE_CONTENT_MODEL</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;

  <expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name> <name>parent</name> = <call><name>GetParent</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// Handle parent-less nodes</comment>
  <if>if <condition>(<expr>!<name>parent</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>aContent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aReturn</name> = <name>nsnull</name></expr>;</expr_stmt>
      <return>return <expr><name>NS_OK</name></expr>;</return>
    <expr_stmt/></block></then></if></block></then></if>}</block>

    <call><name>SetText</name><argument_list>(<argument><expr><call><name><name>aContent</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aContent</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return>
  }

  <comment type="line">// We don't support entity references or read-only nodes, so remove the</comment>
  <comment type="line">// logically adjacent text nodes (which therefore must all be siblings of</comment>
  <comment type="line">// this) and set this one to the provided text, if that text isn't empty.</comment>

  PRUint32 <expr_stmt><expr><name>index</name> = <call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>first</name> <init>=
    <expr><call><name>FirstLogicallyAdjacentTextNode</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>last</name> <init>=
    <expr><call><name>LastLogicallyAdjacentTextNode</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>parent</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <do>do <block>{
    <if>if <condition>(<expr><name>last</name> == <name>index</name> &amp;&amp; !<call><name><name>aContent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
      <continue>continue;</continue></then></if>

    <expr_stmt><expr><call><name><name>parent</name>-&gt;<name>RemoveChildAt</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block> while <condition>(<expr><name>last</name>-- &gt; <name>first</name></expr>)</condition>;</do>

  <comment type="line">// Empty string means we removed this node too.</comment>
  <if>if <condition>(<expr><call><name><name>aContent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aReturn</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>SetText</name><argument_list>(<argument><expr><call><name><name>aContent</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aContent</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return>
}

<comment type="line">//----------------------------------------------------------------------</comment>

<comment type="line">// Implementation of the nsIContent interface text functions</comment>

const <function><type><name>nsTextFragment</name> *</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetText</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>&amp;<name>mText</name></expr>;</return>
}</block></function>

<function><type><name>PRUint32</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>TextLength</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SetText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aBuffer</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aLength</name></expr></argument>, <argument><expr><name>aNotify</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>AppendText</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aBuffer</name></decl></param>,
                                 <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>SetTextInternal</name><argument_list>(<argument><expr><call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aLength</name></expr></argument>, <argument><expr><name>aNotify</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>TextIsOnlyWhitespace</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>mText</name>.<name>Is2b</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// The fragment contains non-8bit characters and such characters</comment>
    <comment type="line">// are never considered whitespace.</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>cp</name> <init>= <expr><call><name><name>mText</name>.<name>Get1b</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>end</name> <init>= <expr><name>cp</name> + <call><name><name>mText</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>cp</name> &lt; <name>end</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr>*<name>cp</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>XP_IS_SPACE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>AppendTextTo</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mText</name>.<name>AppendTo</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsGenericDOMDataNode</name>::<name>SetBidiStatus</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>document</name> <init>= <expr><call><name>GetCurrentDoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>document</name> &amp;&amp; <call><name><name>document</name>-&gt;<name>GetBidiEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// OK, we already know it's Bidi, so we won't test again</comment>
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mText</name>.<name>SetBidiFlag</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>document</name> &amp;&amp; <call><name><name>mText</name>.<name>IsBidi</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>document</name>-&gt;<name>SetBidiEnabled</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetCurrentValueAtom</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>val</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetData</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>NS_NewAtom</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetID</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>nsAttrValue</name>*</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetClasses</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>WalkContentStyleRules</name></name><parameter_list>(<param><decl><type><name>nsRuleWalker</name>*</type> <name>aRuleWalker</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsICSSStyleRule</name>*</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetInlineStyleRule</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>SetInlineStyleRule</name></name><parameter_list>(<param><decl><type><name>nsICSSStyleRule</name>*</type> <name>aStyleRule</name></decl></param>,
                                         <param><decl><type><name>PRBool</name></type> <name>aNotify</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"How come we're setting inline style on a non-element?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
}</block></function>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro>
<macro><name>nsGenericDOMDataNode</name></macro><expr_stmt><expr><name>::<name>IsAttributeMapped</name></name>(const <name>nsIAtom</name>* <name>aAttribute</name>) const
<block>{
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>nsChangeHint</name></type>
<name><name>nsGenericDOMDataNode</name>::<name>GetAttributeChangeHint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIAtom</name>*</type> <name>aAttribute</name></decl></param>,
                                             <param><decl><type><name>PRInt32</name></type> <name>aModType</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Shouldn't be calling this!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>nsChangeHint</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsGenericDOMDataNode</name>::<name>GetClassAttributeName</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>
</unit>
