<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="006bc569e4c97710e9b3e714155d65c8ce4f51ce.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim:set ts=2 sts=2 sw=2 et cin: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Dean Tessman &lt;dean_tessman@hotmail.com&gt;
 *   Ere Maijala &lt;emaijala@kolumbus.fi&gt;
 *   Mark Hammond &lt;markh@activestate.com&gt;
 *   Michael Lowe &lt;michael.lowe@bigfoot.com&gt;
 *   Peter Bajusz &lt;hyp-x@inf.bme.hu&gt;
 *   Pierre Phaneuf &lt;pp@ludusdesign.com&gt;
 *   Robert O'Callahan &lt;roc+moz@cs.cmu.edu&gt;
 *   Roy Yokoyama &lt;yokoyama@netscape.com&gt;
 *   Makoto Kato  &lt;m_kato@ga2.so-net.ne.jp&gt;
 *   Masayuki Nakano &lt;masayuki@d-toybox.com&gt;
 *   Dainis Jonitis &lt;Dainis_Jonitis@swh-t.lv&gt;
 *   Christian Biesinger &lt;cbiesinger@web.de&gt;
 *   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
 *   Ningjie Chen &lt;chenn@email.uc.edu&gt;
 *   Jim Mathies &lt;jmathies@mozilla.com&gt;
 *   Kyle Huey &lt;me@kylehuey.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * nsWindow - Native window management and event handling.
 * 
 * nsWindow is organized into a set of major blocks and
 * block subsections. The layout is as follows:
 *
 *  Includes
 *  Variables
 *  nsIWidget impl.
 *     nsIWidget methods and utilities
 *  nsSwitchToUIThread impl.
 *     nsSwitchToUIThread methods and utilities
 *  Moz events
 *     Event initialization
 *     Event dispatching
 *  Native events
 *     Wndproc(s)
 *     Event processing
 *     OnEvent event handlers
 *  IME management and accessibility
 *  Transparency
 *  Popup hook handling
 *  Misc. utilities
 *  Child window impl.
 *
 * Search for "BLOCK:" to find major blocks.
 * Search for "SECTION:" to find specific sections.
 *
 * Blocks should be split out into separate files if they
 * become unmanageable.
 *
 * Related source:
 *
 *  nsWindowDefs.h     - Definitions, macros, structs, enums
 *                       and general setup.
 *  nsWindowDbg.h/.cpp - Debug related code and directives.
 *  nsWindowGfx.h/.cpp - Graphics and painting.
 *  nsWindowCE.h/.cpp  - WINCE specific code that can be
 *                       split out from nsWindow.
 *
 */</comment>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Includes
 **
 ** Include headers.
 **
 **************************************************************
 **************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/ipc/RPCChannel.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWindow.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commctrl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unknwn.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prmem.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAppShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupportsPrimitives.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNSUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITheme.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrefBranch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrefService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObserverService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScreenManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"imgIContainer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRollupListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMenuRollup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClipboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMM32Handler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILocalFile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFontMetrics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFontEnumerator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIdleService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFont.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNativeCharsetUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWidgetAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsUnicharUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCRT.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAppDirectoryServiceDefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPIDLString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWidgetsCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTHashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHashKeys.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWindowCE.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_WINDOWS_MOBILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KILL_PRIORITY_ID</name></cpp:macro> <cpp:value>2444</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWindowGfx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxWindowsPlatform.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsUXThemeConstants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsKeyboardLayout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNativeDragTarget.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mmsystem.h&gt;</cpp:file></cpp:include> <comment type="line">// needed for WIN32_LEAN_AND_MEAN</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zmouse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pbt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;richedit.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ACCESSIBILITY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oleidl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winuser.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINABLEAPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winable.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINABLEAPI)</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibleDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessNode.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// defined(ACCESSIBILITY)</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_WIN7</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIWinTaskbar.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NS_ENABLE_TSF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTextStore.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// defined(NS_ENABLE_TSF)</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOZ_SPLASHSCREEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSplashScreen.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// defined(MOZ_SPLASHSCREEN)</comment>

<comment type="line">// Windowless plugin support</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"npapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWindowDefs.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGfxCIID.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Variables
 **
 ** nsWindow Class static initializations and global variables. 
 **
 **************************************************************
 **************************************************************/</comment>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsWindow statics
 *
 **************************************************************/</comment>

<decl_stmt><decl><type><name>PRUint32</name></type>        <name><name>nsWindow</name>::<name>sInstanceCount</name></name>          <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type>          <name><name>nsWindow</name>::<name>sSwitchKeyboardLayout</name></name>   <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type>            <name><name>nsWindow</name>::<name>sIsRegistered</name></name>           <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type>            <name><name>nsWindow</name>::<name>sIsPopupClassRegistered</name></name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type>            <name><name>nsWindow</name>::<name>sIsOleInitialized</name></name>       <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HCURSOR</name></type>         <name><name>nsWindow</name>::<name>sHCursor</name></name>                <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>imgIContainer</name>*</type>  <name><name>nsWindow</name>::<name>sCursorImgContainer</name></name>     <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsWindow</name>*</type>       <name><name>nsWindow</name>::<name>sCurrentWindow</name></name>          <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type>          <name><name>nsWindow</name>::<name>sJustGotDeactivate</name></name>      <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type>          <name><name>nsWindow</name>::<name>sJustGotActivate</name></name>        <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<comment type="line">// imported in nsWidgetFactory.cpp</comment>
<decl_stmt><decl><type><name>TriStateBool</name></type>    <name><name>nsWindow</name>::<name>sCanQuit</name></name>                <init>= <expr><name>TRI_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<comment type="line">// Hook Data Memebers for Dropdowns. sProcessHook Tells the</comment>
<comment type="line">// hook methods whether they should be processing the hook</comment>
<comment type="line">// messages.</comment>
<decl_stmt><decl><type><name>HHOOK</name></type>           <name><name>nsWindow</name>::<name>sMsgFilterHook</name></name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HHOOK</name></type>           <name><name>nsWindow</name>::<name>sCallProcHook</name></name>           <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HHOOK</name></type>           <name><name>nsWindow</name>::<name>sCallMouseHook</name></name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRPackedBool</name></type>    <name><name>nsWindow</name>::<name>sProcessHook</name></name>            <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT</name></type>            <name><name>nsWindow</name>::<name>sRollupMsgId</name></name>            <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HWND</name></type>            <name><name>nsWindow</name>::<name>sRollupMsgWnd</name></name>           <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT</name></type>            <name><name>nsWindow</name>::<name>sHookTimerId</name></name>            <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="line">// Rollup Listener</comment>
<decl_stmt><decl><type><name>nsIRollupListener</name>*</type> <name><name>nsWindow</name>::<name>sRollupListener</name></name>      <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsIMenuRollup</name>*</type>  <name><name>nsWindow</name>::<name>sMenuRollup</name></name>             <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsIWidget</name>*</type>      <name><name>nsWindow</name>::<name>sRollupWidget</name></name>           <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type>          <name><name>nsWindow</name>::<name>sRollupConsumeEvent</name></name>     <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<comment type="line">// Mouse Clicks - static variable definitions for figuring</comment>
<comment type="line">// out 1 - 3 Clicks.</comment>
<decl_stmt><decl><type><name>POINT</name></type>           <name><name>nsWindow</name>::<name>sLastMousePoint</name></name>         <init>= <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>POINT</name></type>           <name><name>nsWindow</name>::<name>sLastMouseMovePoint</name></name>     <init>= <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LONG</name></type>            <name><name>nsWindow</name>::<name>sLastMouseDownTime</name></name>      <init>= <expr>0L</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LONG</name></type>            <name><name>nsWindow</name>::<name>sLastClickCount</name></name>         <init>= <expr>0L</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type>            <name><name>nsWindow</name>::<name>sLastMouseButton</name></name>        <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="line">// Trim heap on minimize. (initialized, but still true.)</comment>
<decl_stmt><decl><type><name>int</name></type>             <name><name>nsWindow</name>::<name>sTrimOnMinimize</name></name>         <init>= <expr>2</expr></init></decl>;</decl_stmt>

<comment type="line">// Default Trackpoint Hack to off</comment>
<decl_stmt><decl><type><name>PRBool</name></type>          <name><name>nsWindow</name>::<name>sTrackPointHack</name></name>         <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type>            <name><name>nsWindow</name>::<name>sIsAccessibilityOn</name></name>      <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<comment type="line">// Accessibility wm_getobject handler</comment>
<decl_stmt><decl><type><name>HINSTANCE</name></type>       <name><name>nsWindow</name>::<name>sAccLib</name></name>                 <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LPFNLRESULTFROMOBJECT</name></type> 
                <name><name>nsWindow</name>::<name>sLresultFromObject</name></name>      <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ACCESSIBILITY</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
<comment type="line">// Used in OOPP plugin focus processing.</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>kOOPPPluginFocusEventId</name>   <init>= <expr>L"OOPP Plugin Focus Widget Event"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRUint32</name></type>        <name><name>nsWindow</name>::<name>sOOPPPluginFocusEvent</name></name>   <init>=
                  <expr><call><name>RegisterWindowMessageW</name><argument_list>(<argument><expr><name>kOOPPPluginFocusEventId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: globals variables
 *
 **************************************************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>sScreenManagerContractID</name>       <init>= <expr>"@mozilla.org/gfx/screenmanager;1"</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
<decl_stmt><decl><type><name>PRLogModuleInfo</name>*</type> <name>gWindowsLog</name>                      <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
<comment type="line">// Kbd layout. Used throughout character processing.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>KeyboardLayout</name></type> <name>gKbdLayout</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
<comment type="line">// HTC Navigation Wheel Event</comment>
<comment type="line">// This is the defined value for Gesture Mode</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>WM_HTCNAV</name> <init>= <expr>0x0400 + 200</expr></init></decl>;</decl_stmt>

<typedef>typedef <function_decl><type><name>int</name></type> (<name>__stdcall</name> * <name>HTCApiNavOpen</name>)<parameter_list>(<param><decl><type><name>HANDLE</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int</name></type> (<name>__stdcall</name> * <name>HTCApiNavSetMode</name>)<parameter_list>(<param><decl><type><name>HANDLE</name></type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>int</name></decl></param>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><name>HTCApiNavOpen</name></type>    <name>gHTCApiNavOpen</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HTCApiNavSetMode</name></type> <name>gHTCApiNavSetMode</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type>    <name>gCheckForHTCApi</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// The last user input event time in microseconds. If</comment>
<comment type="line">// there are any pending native toolkit input events</comment>
<comment type="line">// it returns the current time. The value is compatible</comment>
<comment type="line">// with PR_IntervalToMicroseconds(PR_IntervalNow()).</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRUint32</name></type> <name>gLastInputEventTime</name>               <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>PRUint32</name></type>        <name>gLastInputEventTime</name>               <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>UpdateLastInputEventTime</name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><name>gLastInputEventTime</name> = <call><name>PR_IntervalToMicroseconds</name><argument_list>(<argument><expr><call><name>PR_IntervalNow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIIdleService</name></expr></argument>&gt;</argument_list></name></type> <name>idleService</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/widget/idleservice;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIdleService</name>*</type> <name>is</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIdleService</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>idleService</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>is</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>is</name>-&gt;<name>IdleTimeWasModified</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="line">// Global user preference for disabling native theme. Used</comment>
<comment type="line">// in NativeWindowTheme.</comment>
<decl_stmt><decl><type><name>PRBool</name></type>          <name>gDisableNativeTheme</name>               <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<comment type="line">// Global used in Show window enumerations.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type>   <name>gWindowsVisible</name>                   <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kCClipboardCID</name></expr></argument>, <argument><expr><name>NS_CLIPBOARD_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kRegionCID</name></expr></argument>, <argument><expr><name>NS_REGION_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: nsIWidget impl.
 **
 ** nsIWidget interface implementation, broken down into
 ** sections.
 **
 **************************************************************
 **************************************************************/</comment>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsWindow construction and destruction
 *
 **************************************************************/</comment>

<constructor><name><name>nsWindow</name>::<name>nsWindow</name></name><parameter_list>()</parameter_list> <member_list>: <call><name>nsBaseWidget</name><argument_list>()</argument_list></call>
</member_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
  <if>if <condition>(<expr>!<name>gWindowsLog</name></expr>)</condition><then>
    <expr_stmt><expr><name>gWindowsLog</name> = <call><name>PR_NewLogModule</name><argument_list>(<argument><expr>"nsWindowsWidgets"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>mWnd</name>                  = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mPaintDC</name>              = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mPrevWndProc</name>          = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mOldIMC</name>               = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mNativeDragTarget</name>     = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mInDtor</name>               = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsVisible</name>            = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mHas3DBorder</name>          = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsInMouseCapture</name>     = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsTopWidgetWindow</name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mUnicodeWidget</name>        = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mWindowType</name>           = <name>eWindowType_child</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mBorderStyle</name>          = <name>eBorderStyle_default</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mPopupType</name>            = <name>ePopupTypeAny</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mDisplayPanFeedback</name>   = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mLastPoint</name>.<name>x</name></name>          = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mLastPoint</name>.<name>y</name></name>          = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mLastSize</name>.<name>width</name></name>       = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mLastSize</name>.<name>height</name></name>      = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mOldStyle</name>             = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mOldExStyle</name>           = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mPainting</name>             = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mLastKeyboardLayout</name>   = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mBlurSuppressLevel</name>    = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mIMEEnabled</name>           = <name><name>nsIWidget</name>::<name>IME_STATUS_ENABLED</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mLeadByte</name>             = '\0'</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <expr_stmt><expr><name>mTransparentSurface</name>   = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mMemoryDC</name>             = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mTransparencyMode</name>     = <name>eTransparencyOpaque</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_LONGHORN</name></expr></cpp:if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>mGlassMargins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof <name>mGlassMargins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #if MOZ_WINSDK_TARGETVER &gt;= MOZ_NTDDI_LONGHORN</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mBackground</name>           = <call><name>::<name>GetSysColor</name></name><argument_list>(<argument><expr><name>COLOR_BTNFACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mBrush</name>                = <call><name>::<name>CreateSolidBrush</name></name><argument_list>(<argument><expr><call><name>NSRGB_2_COLOREF</name><argument_list>(<argument><expr><name>mBackground</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mForeground</name>           = <call><name>::<name>GetSysColor</name></name><argument_list>(<argument><expr><name>COLOR_WINDOWTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_WIN7</name></expr></cpp:if>
  <expr_stmt><expr><name>mTaskbarPreview</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mHasTaskbarIconBeenCreated</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Global initialization</comment>
  <if>if <condition>(<expr>!<name>sInstanceCount</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name><name>gKbdLayout</name>.<name>LoadLayout</name></name><argument_list>(<argument><expr><call><name>::<name>GetKeyboardLayout</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Init IME handler</comment>
  <expr_stmt><expr><call><name><name>nsIMM32Handler</name>::<name>Initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>Initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if <condition>(<expr><call><name>SUCCEEDED</name><argument_list>(<argument><expr><call><name>::<name>OleInitialize</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>sIsOleInitialized</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>sIsOleInitialized</name></expr></argument>, <argument><expr>"***** OLE is not initialized!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEAP_DUMP_EVENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>InitHeapDump</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>InitTrackPointHack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if> <comment type="line">// !sInstanceCount</comment>

  <comment type="line">// Set gLastInputEventTime to some valid number</comment>
  <expr_stmt><expr><name>gLastInputEventTime</name> = <call><name>PR_IntervalToMicroseconds</name><argument_list>(<argument><expr><call><name>PR_IntervalNow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>sInstanceCount</name>++</expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsWindow</name>::~<name>nsWindow</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mInDtor</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <comment type="line">// If the widget was released without calling Destroy() then the native window still</comment>
  <comment type="line">// exists, and we need to destroy it. This will also result in a call to OnDestroy.</comment>
  <comment type="line">//</comment>
  <comment type="line">// XXX How could this happen???</comment>
  <if>if <condition>(<expr><name>NULL</name> != <name>mWnd</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>Destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>sInstanceCount</name>--</expr>;</expr_stmt>

  <comment type="line">// Global shutdown</comment>
  <if>if <condition>(<expr><name>sInstanceCount</name> == 0</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>Terminate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sCursorImgContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sIsOleInitialized</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>OleFlushClipboard</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>::<name>OleUninitialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sIsOleInitialized</name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// delete any of the IME structures that we allocated</comment>
    <expr_stmt><expr><call><name><name>nsIMM32Handler</name>::<name>Terminate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>
  }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mNativeDragTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>
}</block></destructor>

<macro><name>NS_IMPL_ISUPPORTS_INHERITED0</name><argument_list>(<argument>nsWindow</argument>, <argument>nsBaseWidget</argument>)</argument_list></macro>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Create, nsIWidget::Destroy
 *
 * Creating and destroying windows for this widget.
 *
 **************************************************************/</comment>

<comment type="line">// Allow Derived classes to modify the height that is passed</comment>
<comment type="line">// when the window is created or resized. Also add extra height</comment>
<comment type="line">// if needed (on Windows CE)</comment>
<function><type><name>PRInt32</name></type> <name><name>nsWindow</name>::<name>GetHeight</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aProposedHeight</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>extra</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WINCE_WINDOWS_MOBILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>style</name> <init>= <expr><call><name>WindowStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>style</name> &amp; <name>WS_SYSMENU</name>) &amp;&amp; (<name>style</name> &amp; <name>WS_POPUP</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>extra</name> = <call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CYCAPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>aProposedHeight</name> + <name>extra</name></expr>;</return>
}</block></function>

<comment type="line">// Create the proper widget</comment>
<function><type><name>nsresult</name></type>
<name><name>nsWindow</name>::<name>Create</name></name><parameter_list>(<param><decl><type><name>nsIWidget</name> *</type><name>aParent</name></decl></param>,
                 <param><decl><type><name>nsNativeWidget</name></type> <name>aNativeParent</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type><name>aRect</name></decl></param>,
                 <param><decl><type><name>EVENT_CALLBACK</name></type> <name>aHandleEventFunction</name></decl></param>,
                 <param><decl><type><name>nsIDeviceContext</name> *</type><name>aContext</name></decl></param>,
                 <param><decl><type><name>nsIAppShell</name> *</type><name>aAppShell</name></decl></param>,
                 <param><decl><type><name>nsIToolkit</name> *</type><name>aToolkit</name></decl></param>,
                 <param><decl><type><name>nsWidgetInitData</name> *</type><name>aInitData</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aInitData</name></expr>)</condition><then>
    <expr_stmt><expr><name>mUnicodeWidget</name> = <name><name>aInitData</name>-&gt;<name>mUnicode</name></name></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>nsIWidget</name> *</type><name>baseParent</name> <init>= <expr><name>aInitData</name> &amp;&amp;
                         (<name><name>aInitData</name>-&gt;<name>mWindowType</name></name> == <name>eWindowType_dialog</name> ||
                          <name><name>aInitData</name>-&gt;<name>mWindowType</name></name> == <name>eWindowType_toplevel</name> ||
                          <name><name>aInitData</name>-&gt;<name>mWindowType</name></name> == <name>eWindowType_invisible</name>) ?
                         <name>nsnull</name> : <name>aParent</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>mIsTopWidgetWindow</name> = (<name>nsnull</name> == <name>baseParent</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>width</name></name> = <name><name>aRect</name>.<name>width</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>height</name></name> = <name><name>aRect</name>.<name>height</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>BaseCreate</name><argument_list>(<argument><expr><name>baseParent</name></expr></argument>, <argument><expr><name>aRect</name></expr></argument>, <argument><expr><name>aHandleEventFunction</name></expr></argument>, <argument><expr><name>aContext</name></expr></argument>,
             <argument><expr><name>aAppShell</name></expr></argument>, <argument><expr><name>aToolkit</name></expr></argument>, <argument><expr><name>aInitData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>HWND</name></type> <name>parent</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>nsnull</name> != <name>aParent</name></expr>)</condition><then> <block>{ <comment type="line">// has a nsIWidget parent</comment>
    <expr_stmt><expr><name>parent</name> = ((<name>aParent</name>) ? (<name>HWND</name>)<call><name><name>aParent</name>-&gt;<name>GetNativeData</name></name><argument_list>(<argument><expr><name>NS_NATIVE_WINDOW</name></expr></argument>)</argument_list></call> : <name>nsnull</name>)</expr>;</expr_stmt>
  }</block></then> <else>else <block>{ <comment type="line">// has a nsNative parent</comment>
    <expr_stmt><expr><name>parent</name> = (<name>HWND</name>)<name>aNativeParent</name></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr><name>nsnull</name> != <name>aInitData</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mPopupType</name> = <name><name>aInitData</name>-&gt;<name>mPopupHint</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>mContentType</name> = <name>aInitData</name> ? <name><name>aInitData</name>-&gt;<name>mContentType</name></name> : <name>eContentTypeInherit</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>DWORD</name></type> <name>style</name> <init>= <expr><call><name>WindowStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>extendedStyle</name> <init>= <expr><call><name>WindowExStyle</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>aInitData</name>-&gt;<name>mRTL</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>extendedStyle</name> |= <name>WS_EX_LAYOUTRTL</name> | <name>WS_EX_NOINHERITLAYOUT</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_popup</name></expr>)</condition><then> <block>{
    <comment type="line">// if a parent was specified, don't use WS_EX_TOPMOST so that the popup</comment>
    <comment type="line">// only appears above the parent, instead of all windows</comment>
    <if>if <condition>(<expr><name>aParent</name></expr>)</condition><then>
      <expr_stmt><expr><name>extendedStyle</name> = <name>WS_EX_TOOLWINDOW</name></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>parent</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
  }</block></then> <else>else <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
    <comment type="line">// Make sure CreateWindowEx succeeds at creating a toplevel window</comment>
    <expr_stmt><expr><name>style</name> &amp;= ~0x40000000</expr>;</expr_stmt> <comment type="line">// WS_CHILDWINDOW</comment>
  }</block></then> <else>else <if>if <condition>(<expr><name>nsnull</name> != <name>aInitData</name></expr>)</condition><then> <block>{
    <comment type="line">// See if the caller wants to explictly set clip children and clip siblings</comment>
    <if>if <condition>(<expr><name><name>aInitData</name>-&gt;<name>clipChildren</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>style</name> |= <name>WS_CLIPCHILDREN</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_CLIPCHILDREN</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name><name>aInitData</name>-&gt;<name>clipSiblings</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>style</name> |= <name>WS_CLIPSIBLINGS</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if></else></if></else></if>

  <expr_stmt><expr><name>mHas3DBorder</name> = (<name>extendedStyle</name> &amp; <name>WS_EX_CLIENTEDGE</name>) &gt; 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>mWnd</name> = <call><name>::<name>CreateWindowExW</name></name><argument_list>(<argument><expr><name>extendedStyle</name></expr></argument>,
                           <argument><expr><name>aInitData</name> &amp;&amp; <name><name>aInitData</name>-&gt;<name>mDropShadow</name></name> ?
                           <call><name>WindowPopupClass</name><argument_list>()</argument_list></call> : <call><name>WindowClass</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr>L""</expr></argument>,
                           <argument><expr><name>style</name></expr></argument>,
                           <argument><expr><name><name>aRect</name>.<name>x</name></name></expr></argument>,
                           <argument><expr><name><name>aRect</name>.<name>y</name></name></expr></argument>,
                           <argument><expr><name><name>aRect</name>.<name>width</name></name></expr></argument>,
                           <argument><expr><call><name>GetHeight</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>parent</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mWnd</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>nsWindow</name>::<name>sTrackPointHack</name></name> &amp;&amp;
      <name>mWindowType</name> != <name>eWindowType_plugin</name> &amp;&amp;
      <name>mWindowType</name> != <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
    <comment type="line">// Ugly Thinkpad Driver Hack (Bug 507222)</comment>
    <comment type="line">// We create an invisible scrollbar to trick the </comment>
    <comment type="line">// Trackpoint driver into sending us scrolling messages</comment>
    <expr_stmt><expr><call><name>::<name>CreateWindowW</name></name><argument_list>(<argument><expr>L"SCROLLBAR"</expr></argument>, <argument><expr>L"FAKETRACKPOINTSCROLLBAR"</expr></argument>, 
                    <argument><expr><name>WS_CHILD</name> | <name>WS_VISIBLE</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>, <argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// call the event callback to notify about creation</comment>

  <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SubclassWindow</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>sTrimOnMinimize</name> == 2 &amp;&amp; <name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
    <comment type="block">/* The internal variable set by the config.trim_on_minimize pref
       has not yet been initialized, and this is the hidden window
       (conveniently created before any visible windows, and after
       the profile has been initialized).
       
       Default config.trim_on_minimize to false, to fix bug 76831
       for good.  If anyone complains about this new default, saying
       that a Mozilla app hogs too much memory while minimized, they
       will have that entire bug tattooed on their backside. */</comment>

    <expr_stmt><expr><name>sTrimOnMinimize</name> = 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefService</name></expr></argument>&gt;</argument_list></name></type> <name>prefs</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>prefs</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>prefBranch</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>prefs</name>-&gt;<name>GetBranch</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>prefBranch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>prefBranch</name></expr>)</condition><then> <block>{

        <decl_stmt><decl><type><name>PRBool</name></type> <name>temp</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>prefBranch</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"config.trim_on_minimize"</expr></argument>,
                                                 <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
            &amp;&amp; <name>temp</name></expr>)</condition><then>
          <expr_stmt><expr><name>sTrimOnMinimize</name> = 1</expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>prefBranch</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"intl.keyboard.per_window_layout"</expr></argument>,
                                                 <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>sSwitchKeyboardLayout</name> = <name>temp</name></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>prefBranch</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"mozilla.widget.disable-native-theme"</expr></argument>,
                                                 <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>gDisableNativeTheme</name> = <name>temp</name></expr>;</expr_stmt></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_HAVE_SOFTKB</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_dialog</name> || <name>mWindowType</name> == <name>eWindowType_toplevel</name></expr> )</condition><then>
     <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>CreateSoftKeyMenuBar</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Close this nsWindow</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Destroy</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// WM_DESTROY has already fired, we're done.</comment>
  <if>if <condition>(<expr><name>nsnull</name> == <name>mWnd</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// During the destruction of all of our children, make sure we don't get deleted.</comment>
  <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWidget</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// The DestroyWindow function destroys the specified window. The function sends WM_DESTROY</comment>
  <comment type="line">// and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus</comment>
  <comment type="line">// from it. The function also destroys the window's menu, flushes the thread message queue,</comment>
  <comment type="line">// destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if</comment>
  <comment type="line">// the window is at the top of the viewer chain).</comment>
  <comment type="line">//</comment>
  <comment type="line">// If the specified window is a parent or owner window, DestroyWindow automatically destroys</comment>
  <comment type="line">// the associated child or owned windows when it destroys the parent or owner window. The</comment>
  <comment type="line">// function first destroys child or owned windows, and then it destroys the parent or owner</comment>
  <comment type="line">// window.</comment>
  <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>DestroyWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Our windows can be subclassed which may prevent us receiving WM_DESTROY. If OnDestroy()</comment>
  <comment type="line">// didn't get called, call it now.</comment>
  <if>if <condition>(<expr><name>PR_FALSE</name> == <name>mOnDestroyCalled</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>OnDestroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Window class utilities
 *
 * Utilities for calculating the proper window class name for
 * Create window.
 *
 **************************************************************/</comment>

<comment type="line">// Return the proper window class for everything except popups.</comment>
<function><type><name>LPCWSTR</name></type> <name><name>nsWindow</name>::<name>WindowClass</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name><name>nsWindow</name>::<name>sIsRegistered</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>WNDCLASSW</name></type> <name>wc</name></decl>;</decl_stmt>

<comment type="line">//    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;</comment>
    <expr_stmt><expr><name><name>wc</name>.<name>style</name></name>         = <name>CS_DBLCLKS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>lpfnWndProc</name></name>   = <name>::<name>DefWindowProcW</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>cbClsExtra</name></name>    = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>cbWndExtra</name></name>    = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hInstance</name></name>     = <name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hIcon</name></name>         = <call><name>::<name>LoadIconW</name></name><argument_list>(<argument><expr><call><name>::<name>GetModuleHandleW</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>LPWSTR</name>)<name>IDI_APPLICATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hCursor</name></name>       = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hbrBackground</name></name> = <name>mBrush</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>lpszMenuName</name></name>  = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameHidden</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>BOOL</name></type> <name>succeeded</name> <init>= <expr><call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call> != 0 &amp;&amp; 
      <name>ERROR_CLASS_ALREADY_EXISTS</name> != <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsRegistered</name></name> = <name>succeeded</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameContentFrame</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call> &amp;&amp; 
      <name>ERROR_CLASS_ALREADY_EXISTS</name> != <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsRegistered</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameContent</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call> &amp;&amp; 
      <name>ERROR_CLASS_ALREADY_EXISTS</name> != <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsRegistered</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameUI</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call> &amp;&amp; 
      <name>ERROR_CLASS_ALREADY_EXISTS</name> != <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsRegistered</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameGeneral</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>ATOM</name></type> <name>generalClassAtom</name> <init>= <expr><call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>generalClassAtom</name> &amp;&amp; 
      <name>ERROR_CLASS_ALREADY_EXISTS</name> != <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsRegistered</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameDialog</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hIcon</name></name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call> &amp;&amp; 
      <name>ERROR_CLASS_ALREADY_EXISTS</name> != <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsRegistered</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
    <return>return <expr><name>kClassNameHidden</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_dialog</name></expr>)</condition><then> <block>{
    <return>return <expr><name>kClassNameDialog</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>mContentType</name> == <name>eContentTypeContent</name></expr>)</condition><then> <block>{
    <return>return <expr><name>kClassNameContent</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>mContentType</name> == <name>eContentTypeContentFrame</name></expr>)</condition><then> <block>{
    <return>return <expr><name>kClassNameContentFrame</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>mContentType</name> == <name>eContentTypeUI</name></expr>)</condition><then> <block>{
    <return>return <expr><name>kClassNameUI</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>kClassNameGeneral</name></expr>;</return>
}</block></function>

<comment type="line">// Return the proper popup window class</comment>
<function><type><name>LPCWSTR</name></type> <name><name>nsWindow</name>::<name>WindowPopupClass</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name><name>nsWindow</name>::<name>sIsPopupClassRegistered</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>WNDCLASSW</name></type> <name>wc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>wc</name>.<name>style</name></name> = <name>CS_DBLCLKS</name> | <name>CS_XP_DROPSHADOW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>lpfnWndProc</name></name>   = <name>::<name>DefWindowProcW</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>cbClsExtra</name></name>    = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>cbWndExtra</name></name>    = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hInstance</name></name>     = <name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hIcon</name></name>         = <call><name>::<name>LoadIconW</name></name><argument_list>(<argument><expr><call><name>::<name>GetModuleHandleW</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>LPWSTR</name>)<name>IDI_APPLICATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hCursor</name></name>       = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>hbrBackground</name></name> = <name>mBrush</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>lpszMenuName</name></name>  = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wc</name>.<name>lpszClassName</name></name> = <name>kClassNameDropShadow</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsPopupClassRegistered</name></name> = <call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>nsWindow</name>::<name>sIsPopupClassRegistered</name></name></expr>)</condition><then> <block>{
      <comment type="line">// For older versions of Win32 (i.e., not XP), the registration will</comment>
      <comment type="line">// fail, so we have to re-register without the CS_XP_DROPSHADOW flag.</comment>
      <expr_stmt><expr><name><name>wc</name>.<name>style</name></name> = <name>CS_DBLCLKS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsPopupClassRegistered</name></name> = <call><name>::<name>RegisterClassW</name></name><argument_list>(<argument><expr>&amp;<name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>kClassNameDropShadow</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Window styles utilities
 *
 * Return the proper windows styles and extended styles.
 *
 **************************************************************/</comment>

<comment type="line">// Return nsWindow styles</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="line">// implemented in nsWindowCE.cpp</comment>
<function><type><name>DWORD</name></type> <name><name>nsWindow</name>::<name>WindowStyle</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>DWORD</name></type> <name>style</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>mWindowType</name></expr>)</condition> <block>{
    <case>case <expr><name>eWindowType_plugin</name></expr>:
    </case><case>case <expr><name>eWindowType_child</name></expr>:
      <expr_stmt><expr><name>style</name> = <name>WS_OVERLAPPED</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eWindowType_dialog</name></expr>:
      <expr_stmt><expr><name>style</name> = <name>WS_OVERLAPPED</name> | <name>WS_BORDER</name> | <name>WS_DLGFRAME</name> | <name>WS_SYSMENU</name> | <name>DS_3DLOOK</name> | <name>DS_MODALFRAME</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mBorderStyle</name> != <name>eBorderStyle_default</name></expr>)</condition><then>
        <expr_stmt><expr><name>style</name> |= <name>WS_THICKFRAME</name> | <name>WS_MINIMIZEBOX</name> | <name>WS_MAXIMIZEBOX</name></expr>;</expr_stmt></then></if>
      <break>break;</break>

    </case><case>case <expr><name>eWindowType_popup</name></expr>:
      <expr_stmt><expr><name>style</name> = <name>WS_POPUP</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mTransparencyMode</name> != <name>eTransparencyGlass</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>style</name> |= <name>WS_OVERLAPPED</name></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"unknown border style"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// fall through</comment>

    </default><case>case <expr><name>eWindowType_toplevel</name></expr>:
    </case><case>case <expr><name>eWindowType_invisible</name></expr>:
      <expr_stmt><expr><name>style</name> = <name>WS_OVERLAPPED</name> | <name>WS_BORDER</name> | <name>WS_DLGFRAME</name> | <name>WS_SYSMENU</name> |
              <name>WS_THICKFRAME</name> | <name>WS_MINIMIZEBOX</name> | <name>WS_MAXIMIZEBOX</name></expr>;</expr_stmt>
      <break>break;</break>
  </case>}</block></switch>

  <if>if <condition>(<expr><name>mBorderStyle</name> != <name>eBorderStyle_default</name> &amp;&amp; <name>mBorderStyle</name> != <name>eBorderStyle_all</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> || !(<name>mBorderStyle</name> &amp; <name>eBorderStyle_border</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_BORDER</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> || !(<name>mBorderStyle</name> &amp; <name>eBorderStyle_title</name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_DLGFRAME</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>style</name> |= <name>WS_POPUP</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_CHILD</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> || !(<name>mBorderStyle</name> &amp; <name>eBorderStyle_close</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>style</name> &amp;= ~0</expr>;</expr_stmt></then></if>
    <comment type="line">// XXX The close box can only be removed by changing the window class,</comment>
    <comment type="line">// as far as I know   --- roc+moz@cs.cmu.edu</comment>

    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> ||
      !(<name>mBorderStyle</name> &amp; (<name>eBorderStyle_menu</name> | <name>eBorderStyle_close</name>))</expr>)</condition><then>
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_SYSMENU</name></expr>;</expr_stmt></then></if>
    <comment type="line">// Looks like getting rid of the system menu also does away with the</comment>
    <comment type="line">// close box. So, we only get rid of the system menu if you want neither it</comment>
    <comment type="line">// nor the close box. How does the Windows "Dialog" window class get just</comment>
    <comment type="line">// closebox and no sysmenu? Who knows.</comment>

    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> || !(<name>mBorderStyle</name> &amp; <name>eBorderStyle_resizeh</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_THICKFRAME</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> || !(<name>mBorderStyle</name> &amp; <name>eBorderStyle_minimize</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_MINIMIZEBOX</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mBorderStyle</name> == <name>eBorderStyle_none</name> || !(<name>mBorderStyle</name> &amp; <name>eBorderStyle_maximize</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>style</name> &amp;= ~<name>WS_MAXIMIZEBOX</name></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>VERIFY_WINDOW_STYLE</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>style</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

<comment type="line">// Return nsWindow extended styles</comment>
<function><type><name>DWORD</name></type> <name><name>nsWindow</name>::<name>WindowExStyle</name></name><parameter_list>()</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>mWindowType</name></expr>)</condition>
  <block>{
    <case>case <expr><name>eWindowType_plugin</name></expr>:
    </case><case>case <expr><name>eWindowType_child</name></expr>:
      <return>return <expr>0</expr>;</return>

    </case><case>case <expr><name>eWindowType_dialog</name></expr>:
      <return>return <expr><name>WS_EX_WINDOWEDGE</name> | <name>WS_EX_DLGMODALFRAME</name></expr>;</return>

    </case><case>case <expr><name>eWindowType_popup</name></expr>:
      <return>return
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WINCE_WINDOWS_MOBILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr><name>WS_EX_NOACTIVATE</name> |
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <name>WS_EX_TOPMOST</name> | <name>WS_EX_TOOLWINDOW</name></expr>;</return>

    </case><default>default:
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"unknown border style"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// fall through</comment>

    </default><case>case <expr><name>eWindowType_toplevel</name></expr>:
    </case><case>case <expr><name>eWindowType_invisible</name></expr>:
      <return>return <expr><name>WS_EX_WINDOWEDGE</name></expr>;</return>
  </case>}</block></switch>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Window subclassing utilities
 *
 * Set or clear window subclasses on native windows. Used in
 * Create and Destroy.
 *
 **************************************************************/</comment>

<comment type="line">// Subclass (or remove the subclass from) this component's nsWindow</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>SubclassWindow</name></name><parameter_list>(<param><decl><type><name>BOOL</name></type> <name>bState</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>NULL</name> != <name>mWnd</name></expr>)</condition><then> <block>{
    <comment type="line">//NS_PRECONDITION(::IsWindow(mWnd), "Invalid window handle");</comment>
    <if>if <condition>(<expr>!<call><name>::<name>IsWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Invalid window handle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>bState</name></expr>)</condition><then> <block>{
      <comment type="line">// change the nsWindow proc</comment>
      <if>if <condition>(<expr><name>mUnicodeWidget</name></expr>)</condition><then>
        <expr_stmt><expr><name>mPrevWndProc</name> = (<name>WNDPROC</name>)<call><name>::<name>SetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>,
                                                <argument><expr>(<name>LONG_PTR</name>)<name><name>nsWindow</name>::<name>WindowProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>mPrevWndProc</name> = (<name>WNDPROC</name>)<call><name>::<name>SetWindowLongPtrA</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>,
                                                <argument><expr>(<name>LONG_PTR</name>)<name><name>nsWindow</name>::<name>WindowProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mPrevWndProc</name></expr></argument>, <argument><expr>"Null standard window procedure"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// connect the this pointer to the nsWindow handle</comment>
      <expr_stmt><expr><call><name>SetNSWindowPtr</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <if>if <condition>(<expr><name>mUnicodeWidget</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>::<name>SetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>, <argument><expr>(<name>LONG_PTR</name>)<name>mPrevWndProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>::<name>SetWindowLongPtrA</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>, <argument><expr>(<name>LONG_PTR</name>)<name>mPrevWndProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><call><name>SetNSWindowPtr</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mPrevWndProc</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Window properties
 *
 * Set and clear native window properties.
 *
 **************************************************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PRUnichar</name></type> <name><name>sPropName</name><index>[<expr>40</expr>]</index></name> <init>= <expr>L""</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PRUnichar</name>*</type> <name>GetNSWindowPropName</name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!*<name>sPropName</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>_snwprintf</name><argument_list>(<argument><expr><name>sPropName</name></expr></argument>, <argument><expr>39</expr></argument>, <argument><expr>L"MozillansIWidgetPtr%p"</expr></argument>, <argument><expr><call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sPropName</name><index>[<expr>39</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>sPropName</name></expr>;</return>
}</block></function>

<function><type><name>nsWindow</name> *</type> <name><name>nsWindow</name>::<name>GetNSWindowPtr</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name>nsWindow</name> *) <call><name>::<name>GetPropW</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><call><name>GetNSWindowPropName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>BOOL</name></type> <name><name>nsWindow</name>::<name>SetNSWindowPtr</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>, <param><decl><type><name>nsWindow</name> *</type> <name>ptr</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>ptr</name> == <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>RemovePropW</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><call><name>GetNSWindowPropName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
  }</block></then> <else>else <block>{
    <return>return <expr><call><name>::<name>SetPropW</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><call><name>GetNSWindowPropName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>HANDLE</name>)<name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::SetParent, nsIWidget::GetParent
 *
 * Set or clear the parent widgets using window properties, and
 * handles calculating native parent handles.
 *
 **************************************************************/</comment>

<comment type="line">// Get and set parent widgets</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>SetParent</name></name><parameter_list>(<param><decl><type><name>nsIWidget</name> *</type><name>aNewParent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aNewParent</name></expr>)</condition><then> <block>{
    <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWidget</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>parent</name> <init>= <expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>parent</name>-&gt;<name>RemoveChild</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>HWND</name></type> <name>newParent</name> <init>= <expr>(<name>HWND</name>)<call><name><name>aNewParent</name>-&gt;<name>GetNativeData</name></name><argument_list>(<argument><expr><name>NS_NATIVE_WINDOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>newParent</name></expr></argument>, <argument><expr>"Parent widget has a null native window handle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>newParent</name> &amp;&amp; <name>mWnd</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>SetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>newParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>aNewParent</name>-&gt;<name>AddChild</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWidget</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>parent</name> <init>= <expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>parent</name>-&gt;<name>RemoveChild</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <comment type="line">// If we have no parent, SetParent should return the desktop.</comment>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>SetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsIWidget</name>*</type> <name><name>nsWindow</name>::<name>GetParent</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>GetParentWindow</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsWindow</name>*</type> <name><name>nsWindow</name>::<name>GetParentWindow</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIncludeOwner</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mIsTopWidgetWindow</name></expr>)</condition><then> <block>{
    <comment type="line">// Must use a flag instead of mWindowType to tell if the window is the</comment>
    <comment type="line">// owned by the topmost widget, because a child window can be embedded inside</comment>
    <comment type="line">// a HWND which is not associated with a nsIWidget.</comment>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// If this widget has already been destroyed, pretend we have no parent.</comment>
  <comment type="line">// This corresponds to code in Destroy which removes the destroyed</comment>
  <comment type="line">// widget from its parent's child list.</comment>
  <if>if <condition>(<expr><name>mInDtor</name> || <name>mOnDestroyCalled</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>


  <comment type="line">// aIncludeOwner set to true implies walking the parent chain to retrieve the</comment>
  <comment type="line">// root owner. aIncludeOwner set to false implies the search will stop at the</comment>
  <comment type="line">// true parent (default).</comment>
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>widget</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>HWND</name></type> <name>parent</name> <init>= <expr><call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>HWND</name></type> <name>parent</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aIncludeOwner</name></expr>)</condition><then>
      <expr_stmt><expr><name>parent</name> = <call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>parent</name> = <call><name>::<name>GetAncestor</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GA_PARENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>widget</name> = <call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>widget</name></expr>)</condition><then> <block>{
        <comment type="line">// If the widget is in the process of being destroyed then</comment>
        <comment type="line">// do NOT return it</comment>
        <if>if <condition>(<expr><name><name>widget</name>-&gt;<name>mInDtor</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>widget</name> = <name>nsnull</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>widget</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Show
 *
 * Hide or show this component.
 *
 **************************************************************/</comment>

<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Show</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>bState</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOZ_SPLASHSCREEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// we're about to show the first toplevel window,</comment>
  <comment type="line">// so kill off any splash screen if we had one</comment>
  <decl_stmt><decl><type><name>nsSplashScreen</name> *</type><name>splash</name> <init>= <expr><call><name><name>nsSplashScreen</name>::<name>Get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>splash</name> &amp;&amp; <call><name><name>splash</name>-&gt;<name>IsOpen</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>mWnd</name> &amp;&amp; <name>bState</name> &amp;&amp;
      (<name>mWindowType</name> == <name>eWindowType_toplevel</name> ||
       <name>mWindowType</name> == <name>eWindowType_dialog</name> ||
       <name>mWindowType</name> == <name>eWindowType_popup</name>)</expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>splash</name>-&gt;<name>Close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>wasVisible</name> <init>= <expr><name>mIsVisible</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// Set the status now so that anyone asking during ShowWindow or</comment>
  <comment type="line">// SetWindowPos would get the correct answer.</comment>
  <expr_stmt><expr><name>mIsVisible</name> = <name>bState</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>bState</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<name>wasVisible</name> &amp;&amp; <name>mWindowType</name> == <name>eWindowType_toplevel</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>mSizeMode</name></expr>)</condition> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
          <case>case <expr><name>nsSizeMode_Fullscreen</name></expr>:
            <expr_stmt><expr><call><name>::<name>SetForegroundWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWMAXIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MakeFullScreen</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>nsSizeMode_Maximized</name></expr> :
            <expr_stmt><expr><call><name>::<name>SetForegroundWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWMAXIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <comment type="line">// use default for nsSizeMode_Minimized on Windows CE</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          </case><case>case <expr><name>nsSizeMode_Fullscreen</name></expr>:
            <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWMAXIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>nsSizeMode_Maximized</name></expr> :
            <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWMAXIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>nsSizeMode_Minimized</name></expr> :
            <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWMINIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </case><default>default:
            <if>if <condition>(<expr><call><name>CanTakeFocus</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
              <expr_stmt><expr><call><name>::<name>SetForegroundWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWNORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
              <comment type="line">// Place the window behind the foreground window</comment>
              <comment type="line">// (as long as it is not topmost)</comment>
              <decl_stmt><decl><type><name>HWND</name></type> <name>wndAfter</name> <init>= <expr><call><name>::<name>GetForegroundWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <if>if <condition>(<expr>!<name>wndAfter</name></expr>)</condition><then>
                <expr_stmt><expr><name>wndAfter</name> = <name>HWND_BOTTOM</name></expr>;</expr_stmt></then>
              <else>else <if>if <condition>(<expr><call><name>GetWindowLongPtrW</name><argument_list>(<argument><expr><name>wndAfter</name></expr></argument>, <argument><expr><name>GWL_EXSTYLE</name></expr></argument>)</argument_list></call> &amp; <name>WS_EX_TOPMOST</name></expr>)</condition><then>
                <expr_stmt><expr><name>wndAfter</name> = <name>HWND_TOP</name></expr>;</expr_stmt></then></if></else></if>
              <expr_stmt><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>wndAfter</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SWP_SHOWWINDOW</name> | <name>SWP_NOSIZE</name> | 
                             <name>SWP_NOMOVE</name> | <name>SWP_NOACTIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>GetAttention</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
        </default>}</block></switch>
      }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>DWORD</name></type> <name>flags</name> <init>= <expr><name>SWP_NOSIZE</name> | <name>SWP_NOMOVE</name> | <name>SWP_SHOWWINDOW</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>wasVisible</name></expr>)</condition><then>
          <expr_stmt><expr><name>flags</name> |= <name>SWP_NOZORDER</name></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_popup</name></expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
          <comment type="line">// ensure popups are the topmost of the TOPMOST</comment>
          <comment type="line">// layer. Remember not to set the SWP_NOZORDER</comment>
          <comment type="line">// flag as that might allow the taskbar to overlap</comment>
          <comment type="line">// the popup.  However on windows ce, we need to</comment>
          <comment type="line">// activate the popup or clicks will not be sent.</comment>
          <expr_stmt><expr><name>flags</name> |= <name>SWP_NOACTIVATE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <decl_stmt><decl><type><name>HWND</name></type> <name>owner</name> <init>= <expr><call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GW_OWNER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>owner</name> ? 0 : <name>HWND_TOPMOST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
          <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_dialog</name> &amp;&amp; !<call><name>CanTakeFocus</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>flags</name> |= <name>SWP_NOACTIVATE</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>HWND_TOP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></else></if>
    }</block></then> <else>else <block>{
      <if>if <condition>(<expr><name>mWindowType</name> != <name>eWindowType_dialog</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_HIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SWP_HIDEWINDOW</name> | <name>SWP_NOSIZE</name> | <name>SWP_NOMOVE</name> |
                       <name>SWP_NOZORDER</name> | <name>SWP_NOACTIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
  }</block></then></if>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <if>if <condition>(<expr>!<name>wasVisible</name> &amp;&amp; <name>bState</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::IsVisible
 *
 * Returns the visibility state.
 *
 **************************************************************/</comment>

<comment type="line">// Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>IsVisible</name></name><parameter_list>(<param><decl><type><name>PRBool</name> &amp;</type> <name>bState</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>bState</name> = <name>mIsVisible</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Window clipping utilities
 *
 * Used in Size and Move operations for setting the proper
 * window clipping regions for window transparency.
 *
 **************************************************************/</comment>

<comment type="line">// XP and Vista visual styles sometimes require window clipping regions to be applied for proper</comment>
<comment type="line">// transparency. These routines are called on size and move operations.</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>ClearThemeRegion</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <if>if <condition>(<expr><name><name>nsUXThemeData</name>::<name>sIsVistaOrLater</name></name> &amp;&amp; <name>mTransparencyMode</name> != <name>eTransparencyGlass</name> &amp;&amp;
      <name>mWindowType</name> == <name>eWindowType_popup</name> &amp;&amp; (<name>mPopupType</name> == <name>ePopupTypeTooltip</name> || <name>mPopupType</name> == <name>ePopupTypePanel</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetWindowRgn</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>SetThemeRegion</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <comment type="line">// Popup types that have a visual styles region applied (bug 376408). This can be expanded</comment>
  <comment type="line">// for other window types as needed. The regions are applied generically to the base window</comment>
  <comment type="line">// so default constants are used for part and state. At some point we might need part and</comment>
  <comment type="line">// state values from nsNativeThemeWin's GetThemePartAndState, but currently windows that</comment>
  <comment type="line">// change shape based on state haven't come up.</comment>
  <if>if <condition>(<expr><name><name>nsUXThemeData</name>::<name>sIsVistaOrLater</name></name> &amp;&amp; <name>mTransparencyMode</name> != <name>eTransparencyGlass</name> &amp;&amp;
      <name>mWindowType</name> == <name>eWindowType_popup</name> &amp;&amp; (<name>mPopupType</name> == <name>ePopupTypeTooltip</name> || <name>mPopupType</name> == <name>ePopupTypePanel</name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>HRGN</name></type> <name>hRgn</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RECT</name></type> <name>rect</name> <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr><name><name>mBounds</name>.<name>width</name></name></expr>,<expr><name><name>mBounds</name>.<name>height</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>HDC</name></type> <name>dc</name> <init>= <expr><call><name>::<name>GetDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>nsUXThemeData</name>::<name>getThemeBackgroundRegion</name></name><argument_list>(<argument><expr><call><name><name>nsUXThemeData</name>::<name>GetTheme</name></name><argument_list>(<argument><expr><name>eUXTooltip</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>TTP_STANDARD</name></expr></argument>, <argument><expr><name>TS_NORMAL</name></expr></argument>, <argument><expr>&amp;<name>rect</name></expr></argument>, <argument><expr>&amp;<name>hRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hRgn</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>SetWindowRgn</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>hRgn</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">// do not delete or alter hRgn if accepted.</comment>
        <expr_stmt><expr><call><name>DeleteObject</name><argument_list>(<argument><expr><name>hRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>::<name>ReleaseDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Move, nsIWidget::Resize,
 * nsIWidget::Size, nsIWidget::BeginResizeDrag
 *
 * Repositioning and sizing a window.
 *
 **************************************************************/</comment>

<comment type="line">// Move this component</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Move</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aX</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aY</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_toplevel</name> ||
      <name>mWindowType</name> == <name>eWindowType_dialog</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetSizeMode</name><argument_list>(<argument><expr><name>nsSizeMode_Normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// Check to see if window needs to be moved first</comment>
  <comment type="line">// to avoid a costly call to SetWindowPos. This check</comment>
  <comment type="line">// can not be moved to the calling code in nsView, because</comment>
  <comment type="line">// some platforms do not position child windows correctly</comment>

  <comment type="line">// Only perform this check for non-popup windows, since the positioning can</comment>
  <comment type="line">// in fact change even when the x/y do not.  We always need to perform the</comment>
  <comment type="line">// check. See bug #97805 for details.</comment>
  <if>if <condition>(<expr><name>mWindowType</name> != <name>eWindowType_popup</name> &amp;&amp; (<name><name>mBounds</name>.<name>x</name></name> == <name>aX</name>) &amp;&amp; (<name><name>mBounds</name>.<name>y</name></name> == <name>aY</name>)</expr>)</condition><then>
  <block>{
    <comment type="line">// Nothing to do, since it is already positioned correctly.</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name><name>mBounds</name>.<name>x</name></name> = <name>aX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>y</name></name> = <name>aY</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// complain if a window is moved offscreen (legal, but potentially worrisome)</comment>
    <if>if <condition>(<expr><name>mIsTopWidgetWindow</name></expr>)</condition><then> <block>{ <comment type="line">// only a problem for top-level windows</comment>
      <comment type="line">// Make sure this window is actually on the screen before we move it</comment>
      <comment type="line">// XXX: Needs multiple monitor support</comment>
      <decl_stmt><decl><type><name>HDC</name></type> <name>dc</name> <init>= <expr><call><name>::<name>GetDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>dc</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>::<name>GetDeviceCaps</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>TECHNOLOGY</name></expr></argument>)</argument_list></call> == <name>DT_RASDISPLAY</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>RECT</name></type> <name>workArea</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>::<name>SystemParametersInfo</name></name><argument_list>(<argument><expr><name>SPI_GETWORKAREA</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>workArea</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// no annoying assertions. just mention the issue.</comment>
          <if>if <condition>(<expr><name><name>aX</name> <argument_list>&lt; <argument><expr>0 || <name>aX</name></expr></argument> &gt;</argument_list></name>= <name><name>workArea</name>.<name>right</name></name> || <name><name>aY</name> <argument_list>&lt; <argument><expr>0 || <name>aY</name></expr></argument> &gt;</argument_list></name>= <name><name>workArea</name>.<name>bottom</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"window moved to offscreen position\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
      <expr_stmt><expr><call><name>::<name>ReleaseDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>ClearThemeRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                          <argument><expr><name>SWP_NOZORDER</name> | <name>SWP_NOACTIVATE</name> | <name>SWP_NOSIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetThemeRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Resize this component</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Resize</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aHeight</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aRepaint</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aWidth</name> &gt;=0 )</expr></argument> , <argument><expr>"Negative width passed to nsWindow::Resize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aHeight</name> &gt;=0 )</expr></argument>, <argument><expr>"Negative height passed to nsWindow::Resize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <if>if <condition>(<expr><name>eTransparencyTransparent</name> == <name>mTransparencyMode</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>ResizeTranslucentWindow</name><argument_list>(<argument><expr><name>aWidth</name></expr></argument>, <argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Set cached value for lightweight and printing</comment>
  <expr_stmt><expr><name><name>mBounds</name>.<name>width</name></name>  = <name>aWidth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>height</name></name> = <name>aHeight</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>UINT</name></type>  <name>flags</name> <init>= <expr><name>SWP_NOZORDER</name> | <name>SWP_NOACTIVATE</name> | <name>SWP_NOMOVE</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <if>if <condition>(<expr>!<name>aRepaint</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SWP_NOREDRAW</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ClearThemeRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aWidth</name></expr></argument>, <argument><expr><call><name>GetHeight</name><argument_list>(<argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetThemeRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aRepaint</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Resize this component</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Resize</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aX</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aY</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aWidth</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aHeight</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aRepaint</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aWidth</name> &gt;=0 )</expr></argument>,  <argument><expr>"Negative width passed to nsWindow::Resize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aHeight</name> &gt;=0 )</expr></argument>, <argument><expr>"Negative height passed to nsWindow::Resize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <if>if <condition>(<expr><name>eTransparencyTransparent</name> == <name>mTransparencyMode</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>ResizeTranslucentWindow</name><argument_list>(<argument><expr><name>aWidth</name></expr></argument>, <argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Set cached value for lightweight and printing</comment>
  <expr_stmt><expr><name><name>mBounds</name>.<name>x</name></name>      = <name>aX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>y</name></name>      = <name>aY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>width</name></name>  = <name>aWidth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>height</name></name> = <name>aHeight</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>UINT</name></type>  <name>flags</name> <init>= <expr><name>SWP_NOZORDER</name> | <name>SWP_NOACTIVATE</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <if>if <condition>(<expr>!<name>aRepaint</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SWP_NOREDRAW</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ClearThemeRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr><name>aWidth</name></expr></argument>, <argument><expr><call><name>GetHeight</name><argument_list>(<argument><expr><name>aHeight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetThemeRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aRepaint</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>BeginResizeDrag</name></name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>*</type> <name>aEvent</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aHorizontal</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aVertical</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>aEvent</name>-&gt;<name>eventStructType</name></name> != <name>NS_MOUSE_EVENT</name></expr>)</condition><then> <block>{
    <comment type="line">// you can only begin a resize drag with a mouse event</comment>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsMouseEvent</name>*</type> <name>mouseEvent</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsMouseEvent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aEvent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>mouseEvent</name>-&gt;<name>button</name></name> != <name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr>)</condition><then> <block>{
    <comment type="line">// you can only begin a resize drag with the left mouse button</comment>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// work out what sizemode we're talking about</comment>
  <decl_stmt><decl><type><name>WPARAM</name></type> <name>syscommand</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aVertical</name> &lt; 0</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aHorizontal</name> &lt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_TOPLEFT</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>aHorizontal</name> == 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_TOP</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_TOPRIGHT</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then> <else>else <if>if <condition>(<expr><name>aVertical</name> == 0</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aHorizontal</name> &lt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_LEFT</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>aHorizontal</name> == 0</expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_RIGHT</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then> <else>else <block>{
    <if>if <condition>(<expr><name>aHorizontal</name> &lt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_BOTTOMLEFT</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>aHorizontal</name> == 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_BOTTOM</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>syscommand</name> = <name>SC_SIZE</name> | <name>WMSZ_BOTTOMRIGHT</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></else></if></else></if>

  <comment type="line">// resizing doesn't work if the mouse is already captured</comment>
  <expr_stmt><expr><call><name>CaptureMouse</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// find the top-level window</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>toplevelWnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// tell Windows to start the resize</comment>
  <expr_stmt><expr><call><name>::<name>PostMessage</name></name><argument_list>(<argument><expr><name>toplevelWnd</name></expr></argument>, <argument><expr><name>WM_SYSCOMMAND</name></expr></argument>, <argument><expr><name>syscommand</name></expr></argument>,
                <argument><expr><call><name>POINTTOPOINTS</name><argument_list>(<argument><expr><name><name>aEvent</name>-&gt;<name>refPoint</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Window Z-order and state.
 *
 * nsIWidget::PlaceBehind, nsIWidget::SetSizeMode,
 * nsIWidget::ConstrainPosition
 *
 * Z-order, positioning, restore, minimize, and maximize.
 *
 **************************************************************/</comment>

<comment type="line">// Position the window behind the given window</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>PlaceBehind</name></name><parameter_list>(<param><decl><type><name>nsTopLevelWidgetZPlacement</name></type> <name>aPlacement</name></decl></param>,
                                <param><decl><type><name>nsIWidget</name> *</type><name>aWidget</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aActivate</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HWND</name></type> <name>behind</name> <init>= <expr><name>HWND_TOP</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aPlacement</name> == <name>eZPlacementBottom</name></expr>)</condition><then>
    <expr_stmt><expr><name>behind</name> = <name>HWND_BOTTOM</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>aPlacement</name> == <name>eZPlacementBelow</name> &amp;&amp; <name>aWidget</name></expr>)</condition><then>
    <expr_stmt><expr><name>behind</name> = (<name>HWND</name>)<call><name><name>aWidget</name>-&gt;<name>GetNativeData</name></name><argument_list>(<argument><expr><name>NS_NATIVE_WINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
  <decl_stmt><decl><type><name>UINT</name></type> <name>flags</name> <init>= <expr><name>SWP_NOMOVE</name> | <name>SWP_NOREPOSITION</name> | <name>SWP_NOSIZE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aActivate</name></expr>)</condition><then>
    <expr_stmt><expr><name>flags</name> |= <name>SWP_NOACTIVATE</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>!<call><name>CanTakeFocus</name><argument_list>()</argument_list></call> &amp;&amp; <name>behind</name> == <name>HWND_TOP</name></expr>)</condition><then>
  <block>{
    <comment type="line">// Can't place the window to top so place it behind the foreground window</comment>
    <comment type="line">// (as long as it is not topmost)</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>wndAfter</name> <init>= <expr><call><name>::<name>GetForegroundWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>wndAfter</name></expr>)</condition><then>
      <expr_stmt><expr><name>behind</name> = <name>HWND_BOTTOM</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>!(<call><name>GetWindowLongPtrW</name><argument_list>(<argument><expr><name>wndAfter</name></expr></argument>, <argument><expr><name>GWL_EXSTYLE</name></expr></argument>)</argument_list></call> &amp; <name>WS_EX_TOPMOST</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>behind</name> = <name>wndAfter</name></expr>;</expr_stmt></then></if></else></if>
    <expr_stmt><expr><name>flags</name> |= <name>SWP_NOACTIVATE</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>behind</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Maximize, minimize or restore the window.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="line">// implemented in nsWindowCE.cpp</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>SetSizeMode</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aMode</name></decl></param>)</parameter_list> <block>{

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

  <comment type="line">// Let's not try and do anything if we're already in that state.</comment>
  <comment type="line">// (This is needed to prevent problems when calling window.minimize(), which</comment>
  <comment type="line">// calls us directly, and then the OS triggers another call to us.)</comment>
  <if>if <condition>(<expr><name>aMode</name> == <name>mSizeMode</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// save the requested state</comment>
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsBaseWidget</name>::<name>SetSizeMode</name></name><argument_list>(<argument><expr><name>aMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>mIsVisible</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>aMode</name></expr>)</condition> <block>{
      <case>case <expr><name>nsSizeMode_Fullscreen</name></expr> :
        <expr_stmt><expr><name>mode</name> = <name>SW_MAXIMIZE</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>nsSizeMode_Maximized</name></expr> :
        <expr_stmt><expr><name>mode</name> = <name>SW_MAXIMIZE</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>nsSizeMode_Minimized</name></expr> :
        <comment type="line">// Using SW_SHOWMINIMIZED prevents the working set from being trimmed but</comment>
        <comment type="line">// keeps the window active in the tray. So after the window is minimized,</comment>
        <comment type="line">// windows will fire WM_WINDOWPOSCHANGED (OnWindowPosChanged) at which point</comment>
        <comment type="line">// we will do some additional processing to get the active window set right.</comment>
        <comment type="line">// If sTrimOnMinimize is set, we let windows handle minimization normally</comment>
        <comment type="line">// using SW_MINIMIZE.</comment>
        <expr_stmt><expr><name>mode</name> = <name>sTrimOnMinimize</name> ? <name>SW_MINIMIZE</name> : <name>SW_SHOWMINIMIZED</name></expr>;</expr_stmt>
        <break>break;</break>

      </case><default>default :
        <expr_stmt><expr><name>mode</name> = <name>SW_RESTORE</name></expr>;</expr_stmt>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// we dispatch an activate event here to ensure that the right child window</comment>
    <comment type="line">// is focused</comment>
    <if>if <condition>(<expr><name>mode</name> == <name>SW_RESTORE</name> || <name>mode</name> == <name>SW_MAXIMIZE</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>DispatchFocusToTopLevelWindow</name><argument_list>(<argument><expr><name>NS_ACTIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

<comment type="line">// Constrain a potential move to fit onscreen</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>ConstrainPosition</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aAllowSlop</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name> *</type><name>aX</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aY</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mIsTopWidgetWindow</name></expr>)</condition><then> <comment type="line">// only a problem for top-level windows</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>doConstrain</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt> <comment type="line">// whether we have enough info to do anything</comment>

  <comment type="block">/* get our playing field. use the current screen, or failing that
    for any reason, use device caps for the default screen. */</comment>
  <decl_stmt><decl><type><name>RECT</name></type> <name>screenRect</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIScreenManager</name></expr></argument>&gt;</argument_list></name></type> <name>screenmgr</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>sScreenManagerContractID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>screenmgr</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIScreen</name></expr></argument>&gt;</argument_list></name></type> <name>screen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>top</name></decl>, <decl><type ref="prev"/><name>width</name></decl>, <decl><type ref="prev"/><name>height</name></decl>;</decl_stmt>

    <comment type="line">// zero size rects confuse the screen manager</comment>
    <expr_stmt><expr><name>width</name> = <name><name>mBounds</name>.<name>width</name></name> &gt; 0 ? <name><name>mBounds</name>.<name>width</name></name> : 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>height</name> = <name><name>mBounds</name>.<name>height</name></name> &gt; 0 ? <name><name>mBounds</name>.<name>height</name></name> : 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>screenmgr</name>-&gt;<name>ScreenForRect</name></name><argument_list>(<argument><expr>*<name>aX</name></expr></argument>, <argument><expr>*<name>aY</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>,
                             <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>screen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>screen</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>screen</name>-&gt;<name>GetAvailRect</name></name><argument_list>(<argument><expr>&amp;<name>left</name></expr></argument>, <argument><expr>&amp;<name>top</name></expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr>&amp;<name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>screenRect</name>.<name>left</name></name> = <name>left</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>screenRect</name>.<name>right</name></name> = <name>left</name>+<name>width</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>screenRect</name>.<name>top</name></name> = <name>top</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>screenRect</name>.<name>bottom</name></name> = <name>top</name>+<name>height</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>doConstrain</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>HDC</name></type> <name>dc</name> <init>= <expr><call><name>::<name>GetDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>dc</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>::<name>GetDeviceCaps</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>TECHNOLOGY</name></expr></argument>)</argument_list></call> == <name>DT_RASDISPLAY</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>::<name>SystemParametersInfo</name></name><argument_list>(<argument><expr><name>SPI_GETWORKAREA</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>screenRect</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>doConstrain</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>::<name>ReleaseDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>

  <if>if <condition>(<expr><name>aAllowSlop</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>*<name>aX</name> &lt; <name><name>screenRect</name>.<name>left</name></name> - <name><name>mBounds</name>.<name>width</name></name> + <name>kWindowPositionSlop</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aX</name> = <name><name>screenRect</name>.<name>left</name></name> - <name><name>mBounds</name>.<name>width</name></name> + <name>kWindowPositionSlop</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>*<name>aX</name> &gt;= <name><name>screenRect</name>.<name>right</name></name> - <name>kWindowPositionSlop</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aX</name> = <name><name>screenRect</name>.<name>right</name></name> - <name>kWindowPositionSlop</name></expr>;</expr_stmt></then></if></else></if>

    <if>if <condition>(<expr>*<name>aY</name> &lt; <name><name>screenRect</name>.<name>top</name></name> - <name><name>mBounds</name>.<name>height</name></name> + <name>kWindowPositionSlop</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aY</name> = <name><name>screenRect</name>.<name>top</name></name> - <name><name>mBounds</name>.<name>height</name></name> + <name>kWindowPositionSlop</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>*<name>aY</name> &gt;= <name><name>screenRect</name>.<name>bottom</name></name> - <name>kWindowPositionSlop</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aY</name> = <name><name>screenRect</name>.<name>bottom</name></name> - <name>kWindowPositionSlop</name></expr>;</expr_stmt></then></if></else></if>

  }</block></then> <else>else <block>{

    <if>if <condition>(<expr>*<name>aX</name> &lt; <name><name>screenRect</name>.<name>left</name></name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aX</name> = <name><name>screenRect</name>.<name>left</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>*<name>aX</name> &gt;= <name><name>screenRect</name>.<name>right</name></name> - <name><name>mBounds</name>.<name>width</name></name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aX</name> = <name><name>screenRect</name>.<name>right</name></name> - <name><name>mBounds</name>.<name>width</name></name></expr>;</expr_stmt></then></if></else></if>

    <if>if <condition>(<expr>*<name>aY</name> &lt; <name><name>screenRect</name>.<name>top</name></name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aY</name> = <name><name>screenRect</name>.<name>top</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>*<name>aY</name> &gt;= <name><name>screenRect</name>.<name>bottom</name></name> - <name><name>mBounds</name>.<name>height</name></name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aY</name> = <name><name>screenRect</name>.<name>bottom</name></name> - <name><name>mBounds</name>.<name>height</name></name></expr>;</expr_stmt></then></if></else></if>
  }</block></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Enable, nsIWidget::IsEnabled
 *
 * Enabling and disabling the widget.
 *
 **************************************************************/</comment>

<comment type="line">// Enable/disable this component</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Enable</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>bState</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>EnableWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>bState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Return the current enable state</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>IsEnabled</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aState</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <expr_stmt><expr>*<name>aState</name> = !<name>mWnd</name> || (<call><name>::<name>IsWindowEnabled</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>::<name>IsWindowEnabled</name></name><argument_list>(<argument><expr><call><name>::<name>GetAncestor</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GA_ROOT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr>*<name>aState</name> = !<name>mWnd</name> || (<call><name>::<name>IsWindowEnabled</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>::<name>IsWindowEnabled</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::SetFocus
 *
 * Give the focus to this widget.
 *
 **************************************************************/</comment>

<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>SetFocus</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aRaise</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINSTATE_DEBUG_OUTPUT</name></cpp:ifdef>
    <if>if <condition>(<expr><name>mWnd</name> == <call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** SetFocus: [  top] raise=%d\n"</expr></argument>, <argument><expr><name>aRaise</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** SetFocus: [child] raise=%d\n"</expr></argument>, <argument><expr><name>aRaise</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// Uniconify, if necessary</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>toplevelWnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aRaise</name> &amp;&amp; <call><name>::<name>IsIconic</name></name><argument_list>(<argument><expr><name>toplevelWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>toplevelWnd</name></expr></argument>, <argument><expr><name>SW_RESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>::<name>SetFocus</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Bounds
 *
 * nsIWidget::GetBounds, nsIWidget::GetScreenBounds,
 * nsIWidget::GetClientBounds
 *
 * Bound calculations.
 *
 **************************************************************/</comment>

<comment type="line">// Get this component dimension</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsIntRect</name> &amp;</type><name>aRect</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// assign size</comment>
    <expr_stmt><expr><name><name>aRect</name>.<name>width</name></name>  = <name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>height</name></name> = <name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>

    <comment type="line">// convert coordinates if parent exists</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>parent</name> <init>= <expr><call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>RECT</name></type> <name>pr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr>&amp;<name>pr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>r</name>.<name>left</name></name> -= <name><name>pr</name>.<name>left</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>r</name>.<name>top</name></name>  -= <name><name>pr</name>.<name>top</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>aRect</name>.<name>x</name></name> = <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>y</name></name> = <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>aRect</name> = <name>mBounds</name></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Get this component dimension</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>GetClientBounds</name></name><parameter_list>(<param><decl><type><name>nsIntRect</name> &amp;</type><name>aRect</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>GetClientRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// assign size</comment>
    <expr_stmt><expr><name><name>aRect</name>.<name>x</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>y</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>width</name></name>  = <name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>height</name></name> = <name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>

  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aRect</name>.<name>SetRect</name></name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Get the bounds, but don't take into account the client size</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>GetNonClientBounds</name></name><parameter_list>(<param><decl><type><name>nsIntRect</name> &amp;</type><name>aRect</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// assign size</comment>
    <expr_stmt><expr><name><name>aRect</name>.<name>width</name></name> = <name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>height</name></name> = <name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>

    <comment type="line">// convert coordinates if parent exists</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>parent</name> <init>= <expr><call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>RECT</name></type> <name>pr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr>&amp;<name>pr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>r</name>.<name>left</name></name> -= <name><name>pr</name>.<name>left</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>r</name>.<name>top</name></name> -= <name><name>pr</name>.<name>top</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>aRect</name>.<name>x</name></name> = <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>y</name></name> = <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aRect</name>.<name>SetRect</name></name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="line">// Like GetBounds, but don't offset by the parent</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>GetScreenBounds</name></name><parameter_list>(<param><decl><type><name>nsIntRect</name> &amp;</type><name>aRect</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aRect</name>.<name>width</name></name>  = <name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>height</name></name> = <name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>x</name></name> = <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>y</name></name> = <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>
  }</block></then> <else>else
    <expr_stmt><expr><name>aRect</name> = <name>mBounds</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::SetBackgroundColor
 *
 * Sets the window background paint color.
 *
 **************************************************************/</comment>

<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>SetBackgroundColor</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nscolor</name> &amp;</type><name>aColor</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>nsBaseWidget</name>::<name>SetBackgroundColor</name></name><argument_list>(<argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mBrush</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>mBrush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>mBrush</name> = <call><name>::<name>CreateSolidBrush</name></name><argument_list>(<argument><expr><call><name>NSRGB_2_COLOREF</name><argument_list>(<argument><expr><name>mBackground</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <if>if <condition>(<expr><name>mWnd</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>SetClassLongPtrW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GCLP_HBRBACKGROUND</name></expr></argument>, <argument><expr>(<name>LONG_PTR</name>)<name>mBrush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::SetCursor
 *
 * SetCursor and related utilities for manging cursor state.
 *
 **************************************************************/</comment>

<comment type="line">// Set this component cursor</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>SetCursor</name></name><parameter_list>(<param><decl><type><name>nsCursor</name></type> <name>aCursor</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Only change cursor if it's changing</comment>

  <comment type="line">//XXX mCursor isn't always right.  Scrollbars and others change it, too.</comment>
  <comment type="line">//XXX If we want this optimization we need a better way to do it.</comment>
  <comment type="line">//if (aCursor != mCursor) {</comment>
  <decl_stmt><decl><type><name>HCURSOR</name></type> <name>newCursor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>aCursor</name></expr>)</condition> <block>{
    <case>case <expr><name>eCursor_select</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_IBEAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_wait</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_hyperlink</name></expr>:
    <block>{
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_HAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    </case><case>case <expr><name>eCursor_standard</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_ARROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_n_resize</name></expr>:
    </case><case>case <expr><name>eCursor_s_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZENS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_w_resize</name></expr>:
    </case><case>case <expr><name>eCursor_e_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZEWE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_nw_resize</name></expr>:
    </case><case>case <expr><name>eCursor_se_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZENWSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_ne_resize</name></expr>:
    </case><case>case <expr><name>eCursor_sw_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZENESW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_crosshair</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_CROSS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_move</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZEALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_help</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_HELP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_copy</name></expr>: <comment type="line">// CSS3</comment>
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_COPY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_alias</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_ALIAS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_cell</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_CELL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_grab</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_GRAB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_grabbing</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_GRABBING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_spinning</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_APPSTARTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_context_menu</name></expr>:
      <comment type="line">// XXX this CSS3 cursor needs to be implemented</comment>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_zoom_in</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_ZOOMIN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_zoom_out</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_ZOOMOUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_not_allowed</name></expr>:
    </case><case>case <expr><name>eCursor_no_drop</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_NO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_col_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_COLRESIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_row_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_ROWRESIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_vertical_text</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_VERTICALTEXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_all_scroll</name></expr>:
      <comment type="line">// XXX not 100% appropriate perhaps</comment>
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZEALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_nesw_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZENESW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_nwse_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZENWSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_ns_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZENS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_ew_resize</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>IDC_SIZEWE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>eCursor_none</name></expr>:
      <expr_stmt><expr><name>newCursor</name> = <call><name>::<name>LoadCursor</name></name><argument_list>(<argument><expr><name><name>nsToolkit</name>::<name>mDllInstance</name></name></expr></argument>, <argument><expr><call><name>MAKEINTRESOURCE</name><argument_list>(<argument><expr><name>IDC_NONE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Invalid cursor type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </default>}</block></switch>

  <if>if <condition>(<expr><name>NULL</name> != <name>newCursor</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCursor</name> = <name>aCursor</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>HCURSOR</name></type> <name>oldCursor</name> <init>= <expr><call><name>::<name>SetCursor</name></name><argument_list>(<argument><expr><name>newCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>sHCursor</name> == <name>oldCursor</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sCursorImgContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>sHCursor</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>::<name>DestroyIcon</name></name><argument_list>(<argument><expr><name>sHCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>sHCursor</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Setting the actual cursor</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>SetCursor</name></name><parameter_list>(<param><decl><type><name>imgIContainer</name>*</type> <name>aCursor</name></decl></param>,
                                  <param><decl><type><name>PRUint32</name></type> <name>aHotspotX</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aHotspotY</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>sCursorImgContainer</name> == <name>aCursor</name> &amp;&amp; <name>sHCursor</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>SetCursor</name></name><argument_list>(<argument><expr><name>sHCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>width</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>height</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>aCursor</name>-&gt;<name>GetWidth</name></name><argument_list>(<argument><expr>&amp;<name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>aCursor</name>-&gt;<name>GetHeight</name></name><argument_list>(<argument><expr>&amp;<name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Reject cursors greater than 128 pixels in either direction, to prevent</comment>
  <comment type="line">// spoofing.</comment>
  <comment type="line">// XXX ideally we should rescale. Also, we could modify the API to</comment>
  <comment type="line">// allow trusted content to set larger cursors.</comment>
  <if>if <condition>(<expr><name>width</name> &gt; 128 || <name>height</name> &gt; 128</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>HCURSOR</name></type> <name>cursor</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsWindowGfx</name>::<name>CreateIcon</name></name><argument_list>(<argument><expr><name>aCursor</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>aHotspotX</name></expr></argument>, <argument><expr><name>aHotspotY</name></expr></argument>, <argument><expr>&amp;<name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mCursor</name> = <call><name>nsCursor</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetCursor</name></name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sCursorImgContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sCursorImgContainer</name> = <name>aCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>sCursorImgContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>sHCursor</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>DestroyIcon</name></name><argument_list>(<argument><expr><name>sHCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>sHCursor</name> = <name>cursor</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Get/SetTransparencyMode
 *
 * Manage the transparency mode of the top-level window
 * containing this widget.
 *
 **************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
<function><type><name>nsTransparencyMode</name></type> <name><name>nsWindow</name>::<name>GetTransparencyMode</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name>GetTopLevelWindow</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>-&gt;<call><name>GetWindowTranslucencyInner</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>SetTransparencyMode</name></name><parameter_list>(<param><decl><type><name>nsTransparencyMode</name></type> <name>aMode</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>GetTopLevelWindow</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>-&gt;<call><name>SetWindowTranslucencyInner</name><argument_list>(<argument><expr><name>aMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>UpdatePossiblyTransparentRegion</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name> &amp;</type><name>aDirtyRegion</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name> &amp;</type><name>aPossiblyTransparentRegion</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_LONGHORN</name></expr></cpp:if>
  <if>if <condition>(<expr><name>mTransparencyMode</name> != <name>eTransparencyGlass</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>HWND</name></type> <name>hWnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>topWindow</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>mPossiblyTransparentRegion</name>.<name>Sub</name></name><argument_list>(<argument><expr><name>mPossiblyTransparentRegion</name></expr></argument>, <argument><expr><name>aDirtyRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mPossiblyTransparentRegion</name>.<name>Or</name></name><argument_list>(<argument><expr><name>mPossiblyTransparentRegion</name></expr></argument>, <argument><expr><name>aPossiblyTransparentRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>clientBounds</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>topWindow</name>-&gt;<name>GetClientBounds</name></name><argument_list>(<argument><expr><name>clientBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIntRegion</name></type> <name>opaqueRegion</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>opaqueRegion</name>.<name>Sub</name></name><argument_list>(<argument><expr><name>clientBounds</name></expr></argument>, <argument><expr><name>mPossiblyTransparentRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MARGINS</name></type> <name>margins</name> <init>= <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>dwStyle</name> <init>= <expr><call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// If there is no opaque region or hidechrome=true then full glass</comment>
  <if>if <condition>(<expr><call><name><name>opaqueRegion</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> || !(<name>dwStyle</name> &amp; <name>WS_CAPTION</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>margins</name>.<name>cxLeftWidth</name></name> = -1</expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Find the largest rectangle and use that to calculate the inset</comment>
    <function_decl><type><name>nsIntRegionRectIterator</name></type> <name>rgnIter</name><parameter_list>(<param><decl><type><name>opaqueRegion</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsIntRect</name> *</type><name>currentRect</name> <init>= <expr><call><name><name>rgnIter</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIntRect</name></type> <name>largest</name> <init>= <expr>*<name>currentRect</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>largestArea</name> <init>= <expr><name><name>largest</name>.<name>width</name></name> * <name><name>largest</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>currentRect</name> = <call><name><name>rgnIter</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nscoord</name></type> <name>area</name> <init>= <expr><name><name>currentRect</name>-&gt;<name>width</name></name> * <name><name>currentRect</name>-&gt;<name>height</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>area</name> &gt; <name>largestArea</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>largest</name> = *<name>currentRect</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>largestArea</name> = <name>area</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></while>
    <expr_stmt><expr><name><name>margins</name>.<name>cxLeftWidth</name></name> = <name><name>largest</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>margins</name>.<name>cxRightWidth</name></name> = <name><name>clientBounds</name>.<name>width</name></name> - <call><name><name>largest</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>margins</name>.<name>cyTopHeight</name></name> = <name><name>largest</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>margins</name>.<name>cyBottomHeight</name></name> = <name><name>clientBounds</name>.<name>height</name></name> - <call><name><name>largest</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>mGlassMargins</name></expr></argument>, <argument><expr>&amp;<name>margins</name></expr></argument>, <argument><expr>sizeof <name>mGlassMargins</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mGlassMargins</name> = <name>margins</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateGlass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #if MOZ_WINSDK_TARGETVER &gt;= MOZ_NTDDI_LONGHORN</comment>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>UpdateGlass</name></name><parameter_list>()</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_LONGHORN</name></expr></cpp:if>
  <decl_stmt><decl><type><name>HWND</name></type> <name>hWnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWMNCRENDERINGPOLICY</name></type> <name>policy</name> <init>= <expr><name>DWMNCRP_USEWINDOWSTYLE</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>eTransparencyGlass</name> == <name>mTransparencyMode</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>policy</name> = <name>DWMNCRP_ENABLED</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>(<expr><call><name><name>nsUXThemeData</name>::<name>CheckForCompositor</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsUXThemeData</name>::<name>dwmExtendFrameIntoClientAreaPtr</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>&amp;<name>mGlassMargins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsUXThemeData</name>::<name>dwmSetWindowAttributePtr</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>DWMWA_NCRENDERING_POLICY</name></expr></argument>, <argument><expr>&amp;<name>policy</name></expr></argument>, <argument><expr>sizeof <name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #if MOZ_WINSDK_TARGETVER &gt;= MOZ_NTDDI_LONGHORN</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::HideWindowChrome
 *
 * Show or hide window chrome.
 *
 **************************************************************/</comment>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>HideWindowChrome</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aShouldHide</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HWND</name></type> <name>hwnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Trying to hide window decorations in an embedded context"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>style</name></decl>, <decl><type ref="prev"/><name>exStyle</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aShouldHide</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>tempStyle</name> <init>= <expr><call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>tempExStyle</name> <init>= <expr><call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr><name>GWL_EXSTYLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>style</name> = <name>tempStyle</name> &amp; ~(<name>WS_CAPTION</name> | <name>WS_THICKFRAME</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>exStyle</name> = <name>tempExStyle</name> &amp; ~(<name>WS_EX_DLGMODALFRAME</name> | <name>WS_EX_WINDOWEDGE</name> |
                              <name>WS_EX_CLIENTEDGE</name> | <name>WS_EX_STATICEDGE</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>mOldStyle</name> = <name>tempStyle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mOldExStyle</name> = <name>tempExStyle</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <if>if <condition>(<expr>!<name>mOldStyle</name> || !<name>mOldExStyle</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mOldStyle</name> = <call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mOldExStyle</name> = <call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr><name>GWL_EXSTYLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>style</name> = <name>mOldStyle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>exStyle</name> = <name>mOldExStyle</name></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name>VERIFY_WINDOW_STYLE</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr><name>GWL_EXSTYLE</name></expr></argument>, <argument><expr><name>exStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Invalidate
 *
 * Invalidate an area of the client for painting.
 *
 **************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>AddRECTToRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>RECT</name>&amp;</type> <name>aRect</name></decl></param>, <param><decl><type><name>nsIRegion</name>*</type> <name>aRegion</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aRegion</name>-&gt;<name>Union</name></name><argument_list>(<argument><expr><name><name>aRect</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>aRect</name>.<name>top</name></name></expr></argument>, <argument><expr><name><name>aRect</name>.<name>right</name></name> - <name><name>aRect</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>aRect</name>.<name>bottom</name></name> - <name><name>aRect</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Invalidate this component visible area</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Invalidate</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then>
  <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDGET_DEBUG_OUTPUT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_DumpInvalidate</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,
                         <argument><expr><name>this</name></expr></argument>,
                         <argument><expr><name>nsnull</name></expr></argument>,
                         <argument><expr><name>aIsSynchronous</name></expr></argument>,
                         <argument><expr><call><name>nsCAutoString</name><argument_list>(<argument><expr>"noname"</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr>(<name>PRInt32</name>) <name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WIDGET_DEBUG_OUTPUT</comment>

    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>InvalidateRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aIsSynchronous</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>UpdateWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Invalidate this component visible area</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>Invalidate</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type> <name>aRect</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then>
  <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDGET_DEBUG_OUTPUT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_DumpInvalidate</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,
                         <argument><expr><name>this</name></expr></argument>,
                         <argument><expr>&amp;<name>aRect</name></expr></argument>,
                         <argument><expr><name>aIsSynchronous</name></expr></argument>,
                         <argument><expr><call><name>nsCAutoString</name><argument_list>(<argument><expr>"noname"</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr>(<name>PRInt32</name>) <name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WIDGET_DEBUG_OUTPUT</comment>

    <decl_stmt><decl><type><name>RECT</name></type> <name>rect</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>rect</name>.<name>left</name></name>   = <name><name>aRect</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rect</name>.<name>top</name></name>    = <name><name>aRect</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rect</name>.<name>right</name></name>  = <name><name>aRect</name>.<name>x</name></name> + <name><name>aRect</name>.<name>width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rect</name>.<name>bottom</name></name> = <name><name>aRect</name>.<name>y</name></name> + <name><name>aRect</name>.<name>height</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>InvalidateRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>rect</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aIsSynchronous</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>UpdateWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>MakeFullScreen</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aFullScreen</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WINCE_WINDOWS_MOBILE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>RECT</name></type> <name>rc</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aFullScreen</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetForegroundWindow</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>nsWindowCE</name>::<name>sMenuBarShown</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>SIPINFO</name></type> <name>sipInfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sipInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIPINFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sipInfo</name>.<name>cbSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>SIPINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>SipGetInfo</name><argument_list>(<argument><expr>&amp;<name>sipInfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetRect</name><argument_list>(<argument><expr>&amp;<name>rc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CXSCREEN</name></expr></argument>)</argument_list></call></expr></argument>, 
                <argument><expr><name><name>sipInfo</name>.<name>rcVisibleDesktop</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SetRect</name><argument_list>(<argument><expr>&amp;<name>rc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CXSCREEN</name></expr></argument>)</argument_list></call></expr></argument>, 
                <argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CYSCREEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <decl_stmt><decl><type><name>RECT</name></type> <name>menuBarRect</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>GetWindowRect</name><argument_list>(<argument><expr><name><name>nsWindowCE</name>::<name>sSoftKeyMenuBarHandle</name></name></expr></argument>, <argument><expr>&amp;<name>menuBarRect</name></expr></argument>)</argument_list></call> &amp;&amp; 
          <name><name>menuBarRect</name>.<name>top</name></name> &lt; <name><name>rc</name>.<name>bottom</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>rc</name>.<name>bottom</name></name> = <name><name>menuBarRect</name>.<name>top</name></name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SHFullScreen</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SHFS_HIDETASKBAR</name> | <name>SHFS_HIDESTARTICON</name> | <name>SHFS_SHOWSIPBUTTON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      
      <expr_stmt><expr><call><name>SHFullScreen</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SHFS_HIDETASKBAR</name> | <name>SHFS_HIDESTARTICON</name> | <name>SHFS_HIDESIPBUTTON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SetRect</name><argument_list>(<argument><expr>&amp;<name>rc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CXSCREEN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CYSCREEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>SHFullScreen</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SHFS_SHOWTASKBAR</name> | <name>SHFS_SHOWSTARTICON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SystemParametersInfo</name><argument_list>(<argument><expr><name>SPI_GETWORKAREA</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr><name>aFullScreen</name></expr>)</condition><then>
    <expr_stmt><expr><name>mSizeMode</name> = <name>nsSizeMode_Fullscreen</name></expr>;</expr_stmt></then></if>

  <comment type="line">// nsBaseWidget hides the chrome and resizes the window, replicate that here</comment>
  <expr_stmt><expr><call><name>HideWindowChrome</name><argument_list>(<argument><expr><name>aFullScreen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Resize</name><argument_list>(<argument><expr><name><name>rc</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>rc</name>.<name>top</name></name></expr></argument>, <argument><expr><name><name>rc</name>.<name>right</name></name>-<name><name>rc</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>rc</name>.<name>bottom</name></name>-<name><name>rc</name>.<name>top</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <return>return <expr><call><name><name>nsBaseWidget</name>::<name>MakeFullScreen</name></name><argument_list>(<argument><expr><name>aFullScreen</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Update
 *
 * Force a synchronous repaint of the window.
 *
 **************************************************************/</comment>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>Update</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// updates can come through for windows no longer holding an mWnd during</comment>
  <comment type="line">// deletes triggered by JavaScript in buttons with mouse feedback</comment>
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>UpdateWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::Scroll
 *
 * Scroll this widget.
 *
 **************************************************************/</comment>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>ClipRegionContainedInRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIntRect</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aClipRects</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>aClipRects</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <if>if <condition>(<expr>!<call><name><name>aRect</name>.<name>Contains</name></name><argument_list>(<argument><expr><name><name>aClipRects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// This function determines whether the given window has a descendant that</comment>
<comment type="line">// does not intersect the given aScreenRect. If we encounter a window owned</comment>
<comment type="line">// by another thread (which includes another process, since thread IDs</comment>
<comment type="line">// are unique system-wide), then we give up and conservatively return true.</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>HasDescendantWindowOutsideRect</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>aThisThreadID</name></decl></param>, <param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>RECT</name>&amp;</type> <name>aScreenRect</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// If the window is owned by another thread, give up now, don't try to</comment>
  <comment type="line">// look at its children since they could change asynchronously.</comment>
  <comment type="line">// XXX should we try harder here for out-of-process plugins?</comment>
  <if>if <condition>(<expr><call><name>GetWindowThreadProcessId</name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>aThisThreadID</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <for>for (<init><decl><type><name>HWND</name></type> <name>child</name> <init>= <expr><call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>GW_CHILD</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>child</name></expr>;</condition>
       <incr><expr><name>child</name> = <call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>GW_HWNDNEXT</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>childScreenRect</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr>&amp;<name>childScreenRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RECT</name></type> <name>result</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>IntersectRect</name></name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr>&amp;<name>childScreenRect</name></expr></argument>, <argument><expr>&amp;<name>aScreenRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>HasDescendantWindowOutsideRect</name><argument_list>(<argument><expr><name>aThisThreadID</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>aScreenRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateRgnInWindowSubtree</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>, <param><decl><type><name>HRGN</name></type> <name>aRgn</name></decl></param>, <param><decl><type><name>HRGN</name></type> <name>aTmpRgn</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>RECT</name></type> <name>clientRect</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetClientRect</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr>&amp;<name>clientRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetRectRgn</name></name><argument_list>(<argument><expr><name>aTmpRgn</name></expr></argument>, <argument><expr><name><name>clientRect</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>clientRect</name>.<name>top</name></name></expr></argument>,
               <argument><expr><name><name>clientRect</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>clientRect</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>::<name>CombineRgn</name></name><argument_list>(<argument><expr><name>aTmpRgn</name></expr></argument>, <argument><expr><name>aTmpRgn</name></expr></argument>, <argument><expr><name>aRgn</name></expr></argument>, <argument><expr><name>RGN_AND</name></expr></argument>)</argument_list></call> == <name>NULLREGION</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>::<name>InvalidateRgn</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>aTmpRgn</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>HWND</name></type> <name>child</name> <init>= <expr><call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>GW_CHILD</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>child</name></expr>;</condition>
       <incr><expr><name>child</name> = <call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>GW_HWNDNEXT</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><name>POINT</name></type> <name>pt</name> <init>= <expr><block>{ <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>::<name>MapWindowPoints</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>aWnd</name></expr></argument>, <argument><expr>&amp;<name>pt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>OffsetRgn</name></name><argument_list>(<argument><expr><name>aRgn</name></expr></argument>, <argument><expr>-<name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr>-<name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InvalidateRgnInWindowSubtree</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>aRgn</name></expr></argument>, <argument><expr><name>aTmpRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>OffsetRgn</name></name><argument_list>(<argument><expr><name>aRgn</name></expr></argument>, <argument><expr><name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsWindow</name>::<name>Scroll</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntPoint</name>&amp;</type> <name>aDelta</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIntRect</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aDestRects</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>Configuration</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aConfigurations</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// We use SW_SCROLLCHILDREN if all the windows that intersect the</comment>
  <comment type="line">// affected area are moving by the scroll amount.</comment>
  <comment type="line">// First, build the set of widgets that are to be moved by the scroll</comment>
  <comment type="line">// amount.</comment>
  <comment type="line">// At the same time, set the clip region of all changed windows to the</comment>
  <comment type="line">// intersection of the current and new regions.</comment>
  <decl_stmt><decl><type><name><name>nsTHashtable</name><argument_list>&lt;<argument><expr><name><name>nsPtrHashKey</name><argument_list>&lt;<argument><expr><name>nsWindow</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>scrolledWidgets</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>scrolledWidgets</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>aConfigurations</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>Configuration</name>&amp;</type> <name>configuration</name> <init>= <expr><name><name>aConfigurations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>w</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mChild</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>w</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> == <name>this</name></expr></argument>,
                 <argument><expr>"Configured widget is not a child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>configuration</name>.<name>mBounds</name></name> == <name><name>w</name>-&gt;<name>mBounds</name></name> + <name>aDelta</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>scrolledWidgets</name>.<name>PutEntry</name></name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>w</name>-&gt;<name>SetWindowClipRegion</name></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mClipRegion</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// Create temporary regions</comment>
  <decl_stmt><decl><type><name>HRGN</name></type> <name>updateRgn</name> <init>= <expr><call><name>::<name>CreateRectRgn</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>updateRgn</name></expr>)</condition><then> <block>{
    <comment type="line">// OOM?</comment>
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>HRGN</name></type> <name>destRgn</name> <init>= <expr><call><name>::<name>CreateRectRgn</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>destRgn</name></expr>)</condition><then> <block>{
    <comment type="line">// OOM?</comment>
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr>(<name>HGDIOBJ</name>)<name>updateRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>DWORD</name></type> <name>ourThreadID</name> <init>= <expr><call><name>GetWindowThreadProcessId</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for (<init><expr><name>BlitRectIter</name> <call><name>iter</name><argument_list>(<argument><expr><name>aDelta</name></expr></argument>, <argument><expr><name>aDestRects</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>!<call><name><name>iter</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>iter</name></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>destRect</name> <init>= <expr><call><name><name>iter</name>.<name>Rect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIntRect</name></type> <name>affectedRect</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>affectedRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>destRect</name></expr></argument>, <argument><expr><name>destRect</name> - <name>aDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>UINT</name></type> <name>flags</name> <init>= <expr><name>SW_SCROLLCHILDREN</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Now check if any of our children would be affected by</comment>
    <comment type="line">// SW_SCROLLCHILDREN but not supposed to scroll.</comment>
    <for>for (<init><decl><type><name>nsWindow</name>*</type> <name>w</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetFirstChild</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>w</name></expr>;</condition>
         <incr><expr><name>w</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>w</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>) <block>{
      <if>if <condition>(<expr><call><name><name>w</name>-&gt;<name>mBounds</name>.<name>Intersects</name></name><argument_list>(<argument><expr><name>affectedRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// This child will be affected</comment>
        <decl_stmt><decl><type><name><name>nsPtrHashKey</name><argument_list>&lt;<argument><expr><name>nsWindow</name></expr></argument>&gt;</argument_list></name>*</type> <name>entry</name> <init>= <expr><call><name><name>scrolledWidgets</name>.<name>GetEntry</name></name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
          <comment type="line">// It's supposed to be scrolled, so we can still use</comment>
          <comment type="line">// SW_SCROLLCHILDREN. But don't allow SW_SCROLLCHILDREN to be</comment>
          <comment type="line">// used on it again by a later rectangle; we don't want it to</comment>
          <comment type="line">// move twice!</comment>
          <expr_stmt><expr><call><name><name>scrolledWidgets</name>.<name>RawRemoveEntry</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>screenOffset</name> <init>= <expr><call><name>WidgetToScreenOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>RECT</name></type> <name>screenAffectedRect</name> <init>= <expr><block>{
            <expr><name><name>screenOffset</name>.<name>x</name></name> + <name><name>affectedRect</name>.<name>x</name></name></expr>,
            <expr><name><name>screenOffset</name>.<name>y</name></name> + <name><name>affectedRect</name>.<name>y</name></name></expr>,
            <expr><name><name>screenOffset</name>.<name>x</name></name> + <call><name><name>affectedRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>,
            <expr><name><name>screenOffset</name>.<name>y</name></name> + <macro><name>affectedRect</name></macro>.<macro><name>YMost</name><argument_list>()</argument_list></macro></expr>
          }</block></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name>HasDescendantWindowOutsideRect</name><argument_list>(<argument><expr><name>ourThreadID</name></expr></argument>, <argument><expr><name><name>w</name>-&gt;<name>mWnd</name></name></expr></argument>,
                                             <argument><expr><name>screenAffectedRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// SW_SCROLLCHILDREN seems to not move descendant windows</comment>
            <comment type="line">// that don't intersect the scrolled rectangle, *even if* the</comment>
            <comment type="line">// immediate child window of the scrolled window *does* intersect</comment>
            <comment type="line">// the scrolled window. So if w has a descendant window</comment>
            <comment type="line">// that would not be moved, SW_SCROLLCHILDREN will hopelessly mess</comment>
            <comment type="line">// things up and we must not use it.</comment>
            <expr_stmt><expr><name>flags</name> &amp;= ~<name>SW_SCROLLCHILDREN</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>flags</name> &amp;= ~<name>SW_SCROLLCHILDREN</name></expr>;</expr_stmt>
          <comment type="line">// We may have removed some children from scrolledWidgets even</comment>
          <comment type="line">// though we decide here to not use SW_SCROLLCHILDREN. That's OK,</comment>
          <comment type="line">// it just means that we might not use SW_SCROLLCHILDREN</comment>
          <comment type="line">// for a later rectangle when we could have.</comment>
          <break>break;</break>
        }</block></else></if>
      }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>flags</name> &amp; <name>SW_SCROLLCHILDREN</name> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
        &amp;&amp; !<name>mD2DWindowSurface</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><then> <block>{
      <comment type="line">// ScrollWindowEx will send WM_MOVE to each moved window to tell it</comment>
      <comment type="line">// its new position. Unfortunately those messages don't reach our</comment>
      <comment type="line">// WM_MOVE handler for some plugins, so we have to update their</comment>
      <comment type="line">// mBounds here. For windows that do receive WM_MOVE, this is OK,</comment>
      <comment type="line">// they'll just overwrite mBounds again with the correct value.</comment>
      <for>for (<init><decl><type><name>nsWindow</name>*</type> <name>w</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetFirstChild</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>w</name></expr>;</condition>
           <incr><expr><name>w</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>w</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name><name>w</name>-&gt;<name>mBounds</name>.<name>Intersects</name></name><argument_list>(<argument><expr><name>affectedRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>w</name>-&gt;<name>mBounds</name></name> += <name>aDelta</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></then></if>

    <decl_stmt><decl><type><name>RECT</name></type> <name>clip</name> <init>= <expr><block>{ <expr><name><name>affectedRect</name>.<name>x</name></name></expr>, <expr><name><name>affectedRect</name>.<name>y</name></name></expr>, <expr><call><name><name>affectedRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>, <macro><name>affectedRect</name></macro><expr>.<macro><name>YMost</name><argument_list>()</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>mD2DWindowSurface</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mD2DWindowSurface</name>-&gt;<name>Scroll</name></name><argument_list>(<argument><expr><name>aDelta</name></expr></argument>, <argument><expr><name>affectedRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>aConfigurations</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>Configuration</name>&amp;</type> <name>configuration</name> <init>= <expr><name><name>aConfigurations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>w</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mChild</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>w</name>-&gt;<name>Invalidate</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>

      <expr_stmt><expr><call><name>::<name>GetUpdateRgn</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>::<name>OffsetRgn</name></name><argument_list>(<argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name><name>aDelta</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aDelta</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name><name>gfxPlatform</name>::<name>GetDPI</name></name><argument_list>()</argument_list></call> != 96 &amp;&amp;
          <name><name>aDelta</name>.<name>y</name></name> &lt; 0 &amp;&amp;
          <name><name>clip</name>.<name>bottom</name></name> == (<name><name>mBounds</name>.<name>y</name></name> + <name><name>mBounds</name>.<name>height</name></name>)</expr>)</condition><then> <block>{
        <comment type="line">// XXX - bug 548935 - we can at high DPI settings scroll an undrawn</comment>
        <comment type="line">// row of pixels into view. This row should be invalidated to make</comment>
        <comment type="line">// sure it contains the correct content.</comment>
        <decl_stmt><decl><type><name>HRGN</name></type> <name>scrollRgn</name> <init>= <expr><call><name>::<name>CreateRectRgn</name></name><argument_list>(<argument><expr><name><name>clip</name>.<name>left</name></name></expr></argument>,
                                         <argument><expr><name><name>clip</name>.<name>bottom</name></name> + <name><name>aDelta</name>.<name>y</name></name> - 1</expr></argument>,
                                         <argument><expr><name><name>clip</name>.<name>right</name></name></expr></argument>,
                                         <argument><expr><name><name>clip</name>.<name>bottom</name></name> + <name><name>aDelta</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>::<name>CombineRgn</name></name><argument_list>(<argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>scrollRgn</name></expr></argument>, <argument><expr><name>RGN_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr>(<name>HGDIOBJ</name>)<name>scrollRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>::<name>ScrollWindowEx</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name><name>aDelta</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aDelta</name>.<name>y</name></name></expr></argument>, <argument><expr>&amp;<name>clip</name></expr></argument>, <argument><expr>&amp;<name>clip</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>::<name>SetRectRgn</name></name><argument_list>(<argument><expr><name>destRgn</name></expr></argument>, <argument><expr><name><name>destRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>destRect</name>.<name>y</name></name></expr></argument>, <argument><expr><call><name><name>destRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>destRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>CombineRgn</name></name><argument_list>(<argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>destRgn</name></expr></argument>, <argument><expr><name>RGN_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>flags</name> &amp; <name>SW_SCROLLCHILDREN</name></expr>)</condition><then> <block>{
      <for>for (<init><decl><type><name>nsWindow</name>*</type> <name>w</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetFirstChild</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>w</name></expr>;</condition>
           <incr><expr><name>w</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>w</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr>(<name><name>w</name>-&gt;<name>mBounds</name></name> - <name>aDelta</name>).<call><name>Intersects</name><argument_list>(<argument><expr><name>affectedRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// Widgets that have been scrolled by SW_SCROLLCHILDREN but which</comment>
          <comment type="line">// were, or are, partly outside the scroll area must be invalidated</comment>
          <comment type="line">// because SW_SCROLLCHILDREN doesn't update parts of widgets outside</comment>
          <comment type="line">// the area it scrolled, even if it moved them.</comment>
          <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsIntRect</name></expr></argument>,<argument><expr>1</expr></argument>&gt;</argument_list></name></type> <name>clipRegion</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>w</name>-&gt;<name>GetWindowClipRegion</name></name><argument_list>(<argument><expr>&amp;<name>clipRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<call><name>ClipRegionContainedInRect</name><argument_list>(<argument><expr><name>clipRegion</name></expr></argument>,
                                         <argument><expr><name>destRect</name> - <call><name><name>w</name>-&gt;<name>mBounds</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> ||
              !<call><name>ClipRegionContainedInRect</name><argument_list>(<argument><expr><name>clipRegion</name></expr></argument>,
                                         <argument><expr><name>destRect</name> - (<call><name><name>w</name>-&gt;<name>mBounds</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> - <name>aDelta</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>::<name>SetRectRgn</name></name><argument_list>(<argument><expr><name>destRgn</name></expr></argument>, <argument><expr><name><name>w</name>-&gt;<name>mBounds</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>w</name>-&gt;<name>mBounds</name>.<name>y</name></name></expr></argument>, <argument><expr><call><name><name>w</name>-&gt;<name>mBounds</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>w</name>-&gt;<name>mBounds</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>::<name>CombineRgn</name></name><argument_list>(<argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>destRgn</name></expr></argument>, <argument><expr><name>RGN_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></for>

      <expr_stmt><expr><call><name>InvalidateRgnInWindowSubtree</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>destRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>::<name>InvalidateRgn</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>updateRgn</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>

  <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr>(<name>HGDIOBJ</name>)<name>updateRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr>(<name>HGDIOBJ</name>)<name>destRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Now make sure all children actually get positioned, sized and clipped</comment>
  <comment type="line">// correctly. If SW_SCROLLCHILDREN already moved widgets to their correct</comment>
  <comment type="line">// locations, then the SetWindowPos calls this triggers will just be</comment>
  <comment type="line">// no-ops.</comment>
  <expr_stmt><expr><call><name>ConfigureChildren</name><argument_list>(<argument><expr><name>aConfigurations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Native data storage
 *
 * nsIWidget::GetNativeData
 * nsIWidget::FreeNativeData
 *
 * Set or clear native data based on a constant.
 *
 **************************************************************/</comment>

<comment type="line">// Return some native data according to aDataType</comment>
<function><type><name>void</name>*</type> <name><name>nsWindow</name>::<name>GetNativeData</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aDataType</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aDataType</name></expr>)</condition> <block>{
    <case>case <expr><name>NS_NATIVE_PLUGIN_PORT</name></expr>:
    </case><case>case <expr><name>NS_NATIVE_WIDGET</name></expr>:
    </case><case>case <expr><name>NS_NATIVE_WINDOW</name></expr>:
      <return>return <expr>(<name>void</name>*)<name>mWnd</name></expr>;</return>
    </case><case>case <expr><name>NS_NATIVE_GRAPHIC</name></expr>:
      <comment type="line">// XXX:  This is sleezy!!  Remember to Release the DC after using it!</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
      <return>return <expr>(<name>void</name>*)(<name>eTransparencyTransparent</name> == <name>mTransparencyMode</name>) ?
        <name>mMemoryDC</name> : <call><name>::<name>GetDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <return>return <expr>(<name>void</name>*)<call><name>::<name>GetDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
    </case><case>case <expr><name>NS_NATIVE_TSF_THREAD_MGR</name></expr>:
      <return>return <expr><call><name><name>nsTextStore</name>::<name>GetThreadMgr</name></name><argument_list>()</argument_list></call></expr>;</return>
    </case><case>case <expr><name>NS_NATIVE_TSF_CATEGORY_MGR</name></expr>:
      <return>return <expr><call><name><name>nsTextStore</name>::<name>GetCategoryMgr</name></name><argument_list>()</argument_list></call></expr>;</return>
    </case><case>case <expr><name>NS_NATIVE_TSF_DISPLAY_ATTR_MGR</name></expr>:
      <return>return <expr><call><name><name>nsTextStore</name>::<name>GetDisplayAttrMgr</name></name><argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>

    </case><default>default:
      <break>break;</break>
  </default>}</block></switch>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="line">// Free some native data according to aDataType</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>FreeNativeData</name></name><parameter_list>(<param><decl><type><name>void</name> *</type> <name>data</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aDataType</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aDataType</name></expr>)</condition>
  <block>{
    <case>case <expr><name>NS_NATIVE_GRAPHIC</name></expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
      <if>if <condition>(<expr><name>eTransparencyTransparent</name> != <name>mTransparencyMode</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>::<name>ReleaseDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>(<name>HDC</name>)<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>::<name>ReleaseDC</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>(<name>HDC</name>)<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </case><case>case <expr><name>NS_NATIVE_WIDGET</name></expr>:
    </case><case>case <expr><name>NS_NATIVE_WINDOW</name></expr>:
    </case><case>case <expr><name>NS_NATIVE_PLUGIN_PORT</name></expr>:
      <break>break;</break>
    </case><default>default:
      <break>break;</break>
  </default>}</block></switch>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::SetTitle
 *
 * Set the main windows title text.
 *
 **************************************************************/</comment>

<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>SetTitle</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aTitle</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>strTitle</name> <init>= <expr><call><name>PromiseFlatString</name><argument_list>(<argument><expr><name>aTitle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_SETTEXT</name></expr></argument>, <argument><expr>(<name>WPARAM</name>)0</expr></argument>, <argument><expr>(<name>LPARAM</name>)(<name>LPCWSTR</name>)<call><name><name>strTitle</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::SetIcon
 *
 * Set the main windows icon.
 *
 **************************************************************/</comment>

<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>SetIcon</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aIconSpec</name></decl></param>)</parameter_list> 
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <comment type="line">// Assume the given string is a local identifier for an icon file.</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILocalFile</name></expr></argument>&gt;</argument_list></name></type> <name>iconFile</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ResolveIconName</name><argument_list>(<argument><expr><name>aIconSpec</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>".ico"</expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>iconFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>iconFile</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">// not an error if icon is not found</comment>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>iconPath</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>iconFile</name>-&gt;<name>GetPath</name></name><argument_list>(<argument><expr><name>iconPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXX this should use MZLU (see bug 239279)</comment>

  <expr_stmt><expr><call><name>::<name>SetLastError</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>HICON</name></type> <name>bigIcon</name> <init>= <expr>(<name>HICON</name>)<call><name>::<name>LoadImageW</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr>(<name>LPCWSTR</name>)<call><name><name>iconPath</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                      <argument><expr><name>IMAGE_ICON</name></expr></argument>,
                                      <argument><expr><call><name>::<name>GetSystemMetrics</name></name><argument_list>(<argument><expr><name>SM_CXICON</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>::<name>GetSystemMetrics</name></name><argument_list>(<argument><expr><name>SM_CYICON</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>LR_LOADFROMFILE</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HICON</name></type> <name>smallIcon</name> <init>= <expr>(<name>HICON</name>)<call><name>::<name>LoadImageW</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr>(<name>LPCWSTR</name>)<call><name><name>iconPath</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><name>IMAGE_ICON</name></expr></argument>,
                                        <argument><expr><call><name>::<name>GetSystemMetrics</name></name><argument_list>(<argument><expr><name>SM_CXSMICON</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>::<name>GetSystemMetrics</name></name><argument_list>(<argument><expr><name>SM_CYSMICON</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>LR_LOADFROMFILE</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>bigIcon</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>HICON</name></type> <name>icon</name> <init>= <expr>(<name>HICON</name>) <call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_SETICON</name></expr></argument>, <argument><expr>(<name>WPARAM</name>)<name>ICON_BIG</name></expr></argument>, <argument><expr>(<name>LPARAM</name>)<name>bigIcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>icon</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>::<name>DestroyIcon</name></name><argument_list>(<argument><expr><name>icon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SetIcon</name></cpp:ifdef>
  <else>else <block>{
    <function_decl><type><name>NS_LossyConvertUTF16toASCII</name></type> <name>cPath</name><parameter_list>(<param><decl><type><name>iconPath</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"\nIcon load error; icon=%s, rc=0x%08X\n\n"</expr></argument>, <argument><expr><call><name><name>cPath</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>::<name>GetLastError</name></name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><name>smallIcon</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>HICON</name></type> <name>icon</name> <init>= <expr>(<name>HICON</name>) <call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_SETICON</name></expr></argument>, <argument><expr>(<name>WPARAM</name>)<name>ICON_SMALL</name></expr></argument>, <argument><expr>(<name>LPARAM</name>)<name>smallIcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>icon</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>::<name>DestroyIcon</name></name><argument_list>(<argument><expr><name>icon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SetIcon</name></cpp:ifdef>
  <else>else <block>{
    <function_decl><type><name>NS_LossyConvertUTF16toASCII</name></type> <name>cPath</name><parameter_list>(<param><decl><type><name>iconPath</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>printf</name><argument_list>( <argument><expr>"\nSmall icon load error; icon=%s, rc=0x%08X\n\n"</expr></argument>, <argument><expr><call><name><name>cPath</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>::<name>GetLastError</name></name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WINCE</comment>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::WidgetToScreenOffset
 *
 * Return this widget's origin in screen coordinates.
 *
 **************************************************************/</comment>

<function><type><name>nsIntPoint</name></type> <name><name>nsWindow</name>::<name>WidgetToScreenOffset</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>POINT</name></type> <name>point</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>point</name>.<name>x</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>point</name>.<name>y</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>ClientToScreen</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>nsIntPoint</name><argument_list>(<argument><expr><name><name>point</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>point</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::EnableDragDrop
 *
 * Enables/Disables drag and drop of files on this widget.
 *
 **************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="line">// implemented in nsWindowCE.cpp</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>EnableDragDrop</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aEnable</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_ERROR_FAILURE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aEnable</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>nsnull</name> == <name>mNativeDragTarget</name></expr>)</condition><then> <block>{
       <expr_stmt><expr><name>mNativeDragTarget</name> = new <call><name>nsNativeDragTarget</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if>if <condition>(<expr><name>NULL</name> != <name>mNativeDragTarget</name></expr>)</condition><then> <block>{
         <expr_stmt><expr><call><name><name>mNativeDragTarget</name>-&gt;<name>AddRef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>S_OK</name> == <call><name>::<name>CoLockObjectExternal</name></name><argument_list>(<argument><expr>(<name>LPUNKNOWN</name>)<name>mNativeDragTarget</name></expr></argument>,<argument><expr><name>TRUE</name></expr></argument>,<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
           <if>if <condition>(<expr><name>S_OK</name> == <call><name>::<name>RegisterDragDrop</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>(<name>LPDROPTARGET</name>)<name>mNativeDragTarget</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
             <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
           }</block></then></if>
         }</block></then></if>
       }</block></then></if>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <if>if <condition>(<expr><name>nsnull</name> != <name>mWnd</name> &amp;&amp; <name>NULL</name> != <name>mNativeDragTarget</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>RevokeDragDrop</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>S_OK</name> == <call><name>::<name>CoLockObjectExternal</name></name><argument_list>(<argument><expr>(<name>LPUNKNOWN</name>)<name>mNativeDragTarget</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>mNativeDragTarget</name>-&gt;<name>mDragCancelled</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>mNativeDragTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::CaptureMouse
 *
 * Enables/Disables system mouse capture.
 *
 **************************************************************/</comment>

<function><type><name>NS_METHOD</name></type> <name><name>nsWindow</name>::<name>CaptureMouse</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCapture</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name><name>nsToolkit</name>::<name>gMouseTrailer</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"nsWindow::CaptureMouse called after nsToolkit destroyed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>aCapture</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsToolkit</name>::<name>gMouseTrailer</name>-&gt;<name>SetCaptureWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>SetCapture</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>nsToolkit</name>::<name>gMouseTrailer</name>-&gt;<name>SetCaptureWindow</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>ReleaseCapture</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>mIsInMouseCapture</name> = <name>aCapture</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::CaptureRollupEvents
 *
 * Dealing with event rollup on destroy for popups. Enables &amp;
 * Disables system capture of any and all events that would
 * cause a dropdown to be rolled up.
 *
 **************************************************************/</comment>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>CaptureRollupEvents</name></name><parameter_list>(<param><decl><type><name>nsIRollupListener</name> *</type> <name>aListener</name></decl></param>,
                                            <param><decl><type><name>nsIMenuRollup</name> *</type> <name>aMenuRollup</name></decl></param>,
                                            <param><decl><type><name>PRBool</name></type> <name>aDoCapture</name></decl></param>,
                                            <param><decl><type><name>PRBool</name></type> <name>aConsumeRollupEvent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aDoCapture</name></expr>)</condition><then> <block>{
    <comment type="block">/* we haven't bothered carrying a weak reference to sRollupWidget because
       we believe lifespan is properly scoped. this next assertion helps
       assure that remains true. */</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>sRollupWidget</name></expr></argument>, <argument><expr>"rollup widget reassigned before release"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sRollupConsumeEvent</name> = <name>aConsumeRollupEvent</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sRollupWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sMenuRollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sRollupListener</name> = <name>aListener</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sMenuRollup</name> = <name>aMenuRollup</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr><name>aMenuRollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sRollupWidget</name> = <name>this</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <if>if <condition>(<expr>!<name>sMsgFilterHook</name> &amp;&amp; !<name>sCallProcHook</name> &amp;&amp; !<name>sCallMouseHook</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>RegisterSpecialDropdownHooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sProcessHook</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>sRollupListener</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sMenuRollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>sRollupWidget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <expr_stmt><expr><name>sProcessHook</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UnregisterSpecialDropdownHooks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::GetAttention
 *
 * Bring this window to the user's attention.
 *
 **************************************************************/</comment>

<comment type="line">// Draw user's attention to this window until it comes to foreground.</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>GetAttention</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aCycleCount</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <comment type="line">// Got window?</comment>
  <if>if <condition>(<expr>!<name>mWnd</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if>

  <comment type="line">// Don't flash if the flash count is 0 or if the</comment>
  <comment type="line">// top level window is already active.</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>fgWnd</name> <init>= <expr><call><name>::<name>GetForegroundWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aCycleCount</name> == 0 || <name>fgWnd</name> == <call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>HWND</name></type> <name>flashWnd</name> <init>= <expr><name>mWnd</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<decl><type><name>HWND</name></type> <name>ownerWnd</name> <init>= <expr><call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>flashWnd</name></expr></argument>, <argument><expr><name>GW_OWNER</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{
    <expr_stmt><expr><name>flashWnd</name> = <name>ownerWnd</name></expr>;</expr_stmt>
  }</block></while>

  <comment type="line">// Don't flash if the owner window is active either.</comment>
  <if>if <condition>(<expr><name>fgWnd</name> == <name>flashWnd</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>DWORD</name></type> <name>defaultCycleCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>SystemParametersInfo</name></name><argument_list>(<argument><expr><name>SPI_GETFOREGROUNDFLASHCOUNT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>defaultCycleCount</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>FLASHWINFO</name></type> <name>flashInfo</name> <init>= <expr><block>{ <expr><sizeof>sizeof<argument_list>(<argument><expr><name>FLASHWINFO</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>flashWnd</name></expr>,
    <expr><name>FLASHW_ALL</name></expr>, <expr><name>aCycleCount</name> &gt; 0 ? <name>aCycleCount</name> : <name>defaultCycleCount</name></expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>FlashWindowEx</name></name><argument_list>(<argument><expr>&amp;<name>flashInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>StopFlashing</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>HWND</name></type> <name>flashWnd</name> <init>= <expr><name>mWnd</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<decl><type><name>HWND</name></type> <name>ownerWnd</name> <init>= <expr><call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>flashWnd</name></expr></argument>, <argument><expr><name>GW_OWNER</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{
    <expr_stmt><expr><name>flashWnd</name> = <name>ownerWnd</name></expr>;</expr_stmt>
  }</block></while>

  <decl_stmt><decl><type><name>FLASHWINFO</name></type> <name>flashInfo</name> <init>= <expr><block>{ <expr><sizeof>sizeof<argument_list>(<argument><expr><name>FLASHWINFO</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>flashWnd</name></expr>,
    <expr><name>FLASHW_STOP</name></expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>FlashWindowEx</name></name><argument_list>(<argument><expr>&amp;<name>flashInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::HasPendingInputEvent
 *
 * Ask whether there user input events pending.  All input events are
 * included, including those not targeted at this nsIwidget instance.
 *
 **************************************************************/</comment>

<function><type><name>PRBool</name></type>
<name><name>nsWindow</name>::<name>HasPendingInputEvent</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// If there is pending input or the user is currently</comment>
  <comment type="line">// moving the window then return true.</comment>
  <comment type="line">// Note: When the user is moving the window WIN32 spins</comment>
  <comment type="line">// a separate event loop and input events are not</comment>
  <comment type="line">// reported to the application.</comment>
  <if>if <condition>(<expr><call><name>HIWORD</name><argument_list>(<argument><expr><call><name>GetQueueStatus</name><argument_list>(<argument><expr><name>QS_INPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>GUITHREADINFO</name></type> <name>guiInfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>guiInfo</name>.<name>cbSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>GUITHREADINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>GetGUIThreadInfo</name><argument_list>(<argument><expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>guiInfo</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <return>return <expr><name>GUI_INMOVESIZE</name> == (<name><name>guiInfo</name>.<name>flags</name></name> &amp; <name>GUI_INMOVESIZE</name>)</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::GetThebesSurface
 *
 * Get the Thebes surface associated with this widget.
 *
 **************************************************************/</comment>

<function><type><name>gfxASurface</name> *</type><name><name>nsWindow</name>::<name>GetThebesSurface</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
  <if>if <condition>(<expr><name>mD2DWindowSurface</name></expr>)</condition><then> <block>{
    <return>return <expr><name>mD2DWindowSurface</name></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><name>mPaintDC</name></expr>)</condition><then>
    <return>return <expr>(new <call><name>gfxWindowsSurface</name><argument_list>(<argument><expr><name>mPaintDC</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
  <if>if <condition>(<expr><call><name><name>gfxWindowsPlatform</name>::<name>GetPlatform</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetRenderMode</name><argument_list>()</argument_list></call> ==
      <name><name>gfxWindowsPlatform</name>::<name>RENDER_DIRECT2D</name></name></expr>)</condition><then> <block>{
    <return>return <expr>(new <call><name>gfxD2DSurface</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call>)</expr>;</return>
  }</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>(new <call><name>gfxWindowsSurface</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call>)</expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: nsIWidget::OnDefaultButtonLoaded
 *
 * Called after the dialog is loaded and it has a default button.
 *
 **************************************************************/</comment>
 
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>OnDefaultButtonLoaded</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRect</name> &amp;</type><name>aButtonRect</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
  <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if>if <condition>(<expr><call><name><name>aButtonRect</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// Don't snap when we are not active.</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>activeWnd</name> <init>= <expr><call><name>::<name>GetActiveWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>activeWnd</name> != <call><name>::<name>GetForegroundWindow</name></name><argument_list>()</argument_list></call> ||
      <call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> != <call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>activeWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>isAlwaysSnapCursor</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefService</name></expr></argument>&gt;</argument_list></name></type> <name>prefs</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>prefs</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>prefBranch</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>prefs</name>-&gt;<name>GetBranch</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>prefBranch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>prefBranch</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>prefBranch</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"ui.cursor_snapping.always_enabled"</expr></argument>,
                              <argument><expr>&amp;<name>isAlwaysSnapCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>isAlwaysSnapCursor</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>BOOL</name></type> <name>snapDefaultButton</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>SystemParametersInfo</name></name><argument_list>(<argument><expr><name>SPI_GETSNAPTODEFBUTTON</name></expr></argument>, <argument><expr>0</expr></argument>,
                                <argument><expr>&amp;<name>snapDefaultButton</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> || !<name>snapDefaultButton</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>widgetRect</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetScreenBounds</name><argument_list>(<argument><expr><name>widgetRect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>buttonRect</name><argument_list>(<argument><expr><name>aButtonRect</name> + <call><name><name>widgetRect</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>centerOfButton</name><argument_list>(<argument><expr><name><name>buttonRect</name>.<name>x</name></name> + <name><name>buttonRect</name>.<name>width</name></name> / 2</expr></argument>,
                            <argument><expr><name><name>buttonRect</name>.<name>y</name></name> + <name><name>buttonRect</name>.<name>height</name></name> / 2</expr></argument>)</argument_list></decl>;</decl_stmt>
  <comment type="line">// The center of the button can be outside of the widget.</comment>
  <comment type="line">// E.g., it could be hidden by scrolling.</comment>
  <if>if <condition>(<expr>!<call><name><name>widgetRect</name>.<name>Contains</name></name><argument_list>(<argument><expr><name>centerOfButton</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>::<name>SetCursorPos</name></name><argument_list>(<argument><expr><name><name>centerOfButton</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>centerOfButton</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"SetCursorPos failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>OverrideSystemMouseScrollSpeed</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aOriginalDelta</name></decl></param>,
                                         <param><decl><type><name>PRBool</name></type> <name>aIsHorizontal</name></decl></param>,
                                         <param><decl><type><name>PRInt32</name> &amp;</type><name>aOverriddenDelta</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The default vertical and horizontal scrolling speed is 3, this is defined</comment>
  <comment type="line">// on the document of SystemParametersInfo in MSDN.</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>kSystemDefaultScrollingSpeed</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>absOriginDelta</name> <init>= <expr><call><name>PR_ABS</name><argument_list>(<argument><expr><name>aOriginalDelta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Compute the simple overridden speed.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>absComputedOverriddenDelta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=
    <expr><call><name><name>nsBaseWidget</name>::<name>OverrideSystemMouseScrollSpeed</name></name><argument_list>(<argument><expr><name>absOriginDelta</name></expr></argument>, <argument><expr><name>aIsHorizontal</name></expr></argument>,
                                                 <argument><expr><name>absComputedOverriddenDelta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aOverriddenDelta</name> = <name>aOriginalDelta</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>absComputedOverriddenDelta</name> == <name>absOriginDelta</name></expr>)</condition><then> <block>{
    <comment type="line">// We don't override now.</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Otherwise, we should check whether the user customized the system settings</comment>
  <comment type="line">// or not.  If the user did it, we should respect the will.</comment>
  <decl_stmt><decl><type><name>UINT</name></type> <name>systemSpeed</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>::<name>SystemParametersInfo</name></name><argument_list>(<argument><expr><name>SPI_GETWHEELSCROLLLINES</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>systemSpeed</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// The default vertical scrolling speed is 3, this is defined on the document</comment>
  <comment type="line">// of SystemParametersInfo in MSDN.</comment>
  <if>if <condition>(<expr><name>systemSpeed</name> != <name>kSystemDefaultScrollingSpeed</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Only Vista and later, Windows has the system setting of horizontal</comment>
  <comment type="line">// scrolling by the mouse wheel.</comment>
  <if>if <condition>(<expr><call><name>GetWindowsVersion</name><argument_list>()</argument_list></call> &gt;= <name>VISTA_VERSION</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>::<name>SystemParametersInfo</name></name><argument_list>(<argument><expr><name>SPI_GETWHEELSCROLLCHARS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>systemSpeed</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// The default horizontal scrolling speed is 3, this is defined on the</comment>
    <comment type="line">// document of SystemParametersInfo in MSDN.</comment>
    <if>if <condition>(<expr><name>systemSpeed</name> != <name>kSystemDefaultScrollingSpeed</name></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Limit the overridden delta value from the system settings.  The mouse</comment>
  <comment type="line">// driver might accelerate the scrolling speed already.  If so, we shouldn't</comment>
  <comment type="line">// override the scrolling speed for preventing the unexpected high speed</comment>
  <comment type="line">// scrolling.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>absDeltaLimit</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> =
    <call><name><name>nsBaseWidget</name>::<name>OverrideSystemMouseScrollSpeed</name></name><argument_list>(<argument><expr><name>kSystemDefaultScrollingSpeed</name></expr></argument>,
                                                 <argument><expr><name>aIsHorizontal</name></expr></argument>, <argument><expr><name>absDeltaLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If the given delta is larger than our computed limitation value, the delta</comment>
  <comment type="line">// was accelerated by the mouse driver.  So, we should do nothing here.</comment>
  <if>if <condition>(<expr><name>absDeltaLimit</name> &lt;= <name>absOriginDelta</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>absComputedOverriddenDelta</name> =
    <call><name>PR_MIN</name><argument_list>(<argument><expr><name>absComputedOverriddenDelta</name></expr></argument>, <argument><expr><name>absDeltaLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aOverriddenDelta</name> = (<name>aOriginalDelta</name> &gt; 0) ? <name>absComputedOverriddenDelta</name> :
                                            -<name>absComputedOverriddenDelta</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Moz Events
 **
 ** Moz GUI event management. 
 **
 **************************************************************
 **************************************************************/</comment>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Mozilla event initialization
 *
 * Helpers for initializing moz events.
 *
 **************************************************************/</comment>

<comment type="line">// Event intialization</comment>
<function><type><name>MSG</name></type> <name><name>nsWindow</name>::<name>InitMSG</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>aMessage</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>MSG</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>msg</name>.<name>message</name></name> = <name>aMessage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name>.<name>wParam</name></name>  = <name>wParam</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name>.<name>lParam</name></name>  = <name>lParam</name></expr>;</expr_stmt>
  <return>return <expr><name>msg</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>InitEvent</name></name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>&amp;</type> <name>event</name></decl></param>, <param><decl><type><name>nsIntPoint</name>*</type> <name>aPoint</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name> == <name>aPoint</name></expr>)</condition><then> <block>{     <comment type="line">// use the point from the event</comment>
    <comment type="line">// get the message position in client coordinates</comment>
    <if>if <condition>(<expr><name>mWnd</name> != <name>NULL</name></expr>)</condition><then> <block>{

      <decl_stmt><decl><type><name>DWORD</name></type> <name>pos</name> <init>= <expr><call><name>::<name>GetMessagePos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>POINT</name></type> <name>cpos</name></decl>;</decl_stmt>
      
      <expr_stmt><expr><name><name>cpos</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cpos</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>::<name>ScreenToClient</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>cpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>x</name></name> = <name><name>cpos</name>.<name>x</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>y</name></name> = <name><name>cpos</name>.<name>y</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>x</name></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>y</name></name> = 0</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <block>{  
    <comment type="line">// use the point override if provided</comment>
    <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>x</name></name> = <name><name>aPoint</name>-&gt;<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>y</name></name> = <name><name>aPoint</name>-&gt;<name>y</name></name></expr>;</expr_stmt>
  }</block></else></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <expr_stmt><expr><name><name>event</name>.<name>time</name></name> = <call><name>::<name>GetMessageTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>event</name>.<name>time</name></name> = <call><name>PR_Now</name><argument_list>()</argument_list></call> / 1000</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>mLastPoint</name> = <name><name>event</name>.<name>refPoint</name></name></expr>;</expr_stmt>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Moz event dispatch helpers
 *
 * Helpers for dispatching different types of moz events.
 *
 **************************************************************/</comment>

<comment type="line">// Main event dispatch. Invokes callback and ProcessEvent method on</comment>
<comment type="line">// Event Listener object. Part of nsIWidget.</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>DispatchEvent</name></name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>*</type> <name>event</name></decl></param>, <param><decl><type><name>nsEventStatus</name> &amp;</type> <name>aStatus</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDGET_DEBUG_OUTPUT</name></cpp:ifdef>
  <expr_stmt><expr><call><name>debug_DumpEvent</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,
                  <argument><expr><name><name>event</name>-&gt;<name>widget</name></name></expr></argument>,
                  <argument><expr><name>event</name></expr></argument>,
                  <argument><expr><call><name>nsCAutoString</name><argument_list>(<argument><expr>"something"</expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr>(<name>PRInt32</name>) <name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WIDGET_DEBUG_OUTPUT</comment>

  <expr_stmt><expr><name>aStatus</name> = <name>nsEventStatus_eIgnore</name></expr>;</expr_stmt>

  <comment type="line">// skip processing of suppressed blur events</comment>
  <if>if <condition>(<expr><name><name>event</name>-&gt;<name>message</name></name> == <name>NS_DEACTIVATE</name> &amp;&amp; <call><name>BlurEventsSuppressed</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>nsnull</name> != <name>mEventCallback</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aStatus</name> = <call>(*<name>mEventCallback</name>)<argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// the window can be destroyed during processing of seemingly innocuous events like, say,</comment>
  <comment type="line">// mousedowns due to the magic of scripting. mousedowns will return nsEventStatus_eIgnore,</comment>
  <comment type="line">// which causes problems with the deleted window. therefore:</comment>
  <if>if <condition>(<expr><name>mOnDestroyCalled</name></expr>)</condition><then>
    <expr_stmt><expr><name>aStatus</name> = <name>nsEventStatus_eConsumeNoDefault</name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchStandardEvent</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsGUIEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>aMsg</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchWindowEvent</name></name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>*</type> <name>event</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsEventStatus</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>DispatchEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ConvertStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchWindowEvent</name></name><parameter_list>(<param><decl><type><name>nsGUIEvent</name>*</type> <name>event</name></decl></param>, <param><decl><type><name>nsEventStatus</name> &amp;</type><name>aStatus</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>DispatchEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ConvertStatus</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchKeyEvent</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventType</name></decl></param>, <param><decl><type><name>WORD</name></type> <name>aCharCode</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsAlternativeCharCode</name></expr></argument>&gt;</argument_list></name>*</type> <name>aAlternativeCharCodes</name></decl></param>,
                   <param><decl><type><name>UINT</name></type> <name>aVirtualCharCode</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>MSG</name> *</type><name>aMsg</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>nsModifierKeyState</name> &amp;</type><name>aModKeyState</name></decl></param>,
                   <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsKeyEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>aEventType</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// this add ref's event.widget</comment>

  <expr_stmt><expr><name><name>event</name>.<name>flags</name></name> |= <name>aFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>charCode</name></name> = <name>aCharCode</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aAlternativeCharCodes</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>event</name>.<name>alternativeCharCodes</name>.<name>AppendElements</name></name><argument_list>(<argument><expr>*<name>aAlternativeCharCodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>event</name>.<name>keyCode</name></name>  = <name>aVirtualCharCode</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>KE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr>static <name>cnt</name>=0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d DispatchKE Type: %s charCode %d  keyCode %d "</expr></argument>, <argument><expr><name>cnt</name>++</expr></argument>,
        <argument><expr>(<name>NS_KEY_PRESS</name> == <name>aEventType</name>) ? "PRESS" : (<name>aEventType</name> == <name>NS_KEY_UP</name> ? "Up" : "Down")</expr></argument>,
         <argument><expr><name><name>event</name>.<name>charCode</name></name></expr></argument>, <argument><expr><name><name>event</name>.<name>keyCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Shift: %s Control %s Alt: %s \n"</expr></argument>, 
         <argument><expr>(<name>mIsShiftDown</name> ? "D" : "U")</expr></argument>, <argument><expr>(<name>mIsControlDown</name> ? "D" : "U")</expr></argument>, <argument><expr>(<name>mIsAltDown</name> ? "D" : "U")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"[%c][%c][%c] &lt;==   [%c][%c][%c][ space bar ][%c][%c][%c]\n"</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call> ? 'S' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call> ? 'C' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call> ? 'A' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>VK_LSHIFT</name></expr></argument>)</argument_list></call> ? 'S' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>VK_LCONTROL</name></expr></argument>)</argument_list></call> ? 'C' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>VK_LMENU</name></expr></argument>)</argument_list></call> ? 'A' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>VK_RMENU</name></expr></argument>)</argument_list></call> ? 'A' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>VK_RCONTROL</name></expr></argument>)</argument_list></call> ? 'C' : ' '</expr></argument>,
         <argument><expr><call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>VK_RSHIFT</name></expr></argument>)</argument_list></call> ? 'S' : ' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name>   = <name><name>aModKeyState</name>.<name>mIsShiftDown</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isControl</name></name> = <name><name>aModKeyState</name>.<name>mIsControlDown</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isAlt</name></name>     = <name><name>aModKeyState</name>.<name>mIsAltDown</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>NPEvent</name></type> <name>pluginEvent</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aMsg</name> &amp;&amp; <call><name>PluginHasFocus</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name><name>aMsg</name>-&gt;<name>message</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pluginEvent</name>.<name>wParam</name></name> = <name><name>aMsg</name>-&gt;<name>wParam</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pluginEvent</name>.<name>lParam</name></name> = <name><name>aMsg</name>-&gt;<name>lParam</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>pluginEvent</name></name> = (<name>void</name> *)&amp;<name>pluginEvent</name></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchCommandEvent</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventCommand</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>command</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>aEventCommand</name></expr>)</condition> <block>{
    <case>case <expr><name>APPCOMMAND_BROWSER_BACKWARD</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Back</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>APPCOMMAND_BROWSER_FORWARD</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Forward</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>APPCOMMAND_BROWSER_REFRESH</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Reload</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>APPCOMMAND_BROWSER_STOP</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Stop</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>APPCOMMAND_BROWSER_SEARCH</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Search</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>APPCOMMAND_BROWSER_FAVORITES</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Bookmarks</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>APPCOMMAND_BROWSER_HOME</name></expr>:
      <expr_stmt><expr><name>command</name> = <name><name>nsWidgetAtoms</name>::<name>Home</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>
  <function_decl><type><name>nsCommandEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name><name>nsWidgetAtoms</name>::<name>onAppCommand</name></name></type></decl></param>, <param><decl><type><name>command</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Recursively dispatch synchronous paints for nsIWidget</comment>
<comment type="line">// descendants with invalidated rectangles.</comment>
<function><type><name>BOOL</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>DispatchStarvedPaints</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>LONG_PTR</name></type> <name>proc</name> <init>= <expr><call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>proc</name> == (<name>LONG_PTR</name>)&amp;<name><name>nsWindow</name>::<name>WindowProc</name></name></expr>)</condition><then> <block>{
    <comment type="line">// its one of our windows so check to see if it has a</comment>
    <comment type="line">// invalidated rect. If it does. Dispatch a synchronous</comment>
    <comment type="line">// paint.</comment>
    <if>if <condition>(<expr><call><name>GetUpdateRect</name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>UpdateWindow</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Check for pending paints and dispatch any pending paint</comment>
<comment type="line">// messages for any nsIWidget which is a descendant of the</comment>
<comment type="line">// top-level window that *this* window is embedded within.</comment>
<comment type="line">//</comment>
<comment type="line">// Note: We do not dispatch pending paint messages for non</comment>
<comment type="line">// nsIWidget managed windows.</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>DispatchPendingEvents</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mPainting</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"We were asked to dispatch pending events during painting, "
               "denying since that's unsafe."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>UpdateLastInputEventTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// We need to ensure that reflow events do not get starved.</comment>
  <comment type="line">// At the same time, we don't want to recurse through here</comment>
  <comment type="line">// as that would prevent us from dispatching starved paints.</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recursionBlocker</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>recursionBlocker</name>++ == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ProcessPendingEvents</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name>PR_MillisecondsToInterval</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>--<name>recursionBlocker</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Quickly check to see if there are any</comment>
  <comment type="line">// paint events pending.</comment>
  <if>if <condition>(<expr><call><name>::<name>GetQueueStatus</name></name><argument_list>(<argument><expr><name>QS_PAINT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Find the top level window.</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>topWnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Dispatch pending paints for all topWnd's descendant windows.</comment>
    <comment type="line">// Note: EnumChildWindows enumerates all descendant windows not just</comment>
    <comment type="line">// it's children.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>::<name>EnumChildWindows</name></name><argument_list>(<argument><expr><name>topWnd</name></expr></argument>, <argument><expr><name><name>nsWindow</name>::<name>DispatchStarvedPaints</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>EnumChildWindows</name></name><argument_list>(<argument><expr><name>topWnd</name></expr></argument>, <argument><expr><name><name>nsWindow</name>::<name>DispatchStarvedPaints</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
}</block></function>

<comment type="line">// Deal with plugin events</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchPluginEvent</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MSG</name> &amp;</type><name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>PluginHasFocus</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <function_decl><type><name>nsGUIEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_PLUGIN_EVENT</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>NPEvent</name></type> <name>pluginEvent</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name><name>aMsg</name>.<name>message</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pluginEvent</name>.<name>wParam</name></name> = <name><name>aMsg</name>.<name>wParam</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pluginEvent</name>.<name>lParam</name></name> = <name><name>aMsg</name>.<name>lParam</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>pluginEvent</name></name> = (<name>void</name> *)&amp;<name>pluginEvent</name></expr>;</expr_stmt>
  <return>return <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>RemoveMessageAndDispatchPluginEvent</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>aFirstMsg</name></decl></param>,
                                                   <param><decl><type><name>UINT</name></type> <name>aLastMsg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>MSG</name></type> <name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetMessageW</name></name><argument_list>(<argument><expr>&amp;<name>msg</name></expr></argument>, <argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>aFirstMsg</name></expr></argument>, <argument><expr><name>aLastMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DispatchPluginEvent</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Deal with all sort of mouse event</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchMouseEvent</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventType</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                                    <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsContextMenuKey</name></decl></param>,
                                    <param><decl><type><name>PRInt16</name></type> <name>aButton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>mEventCallback</name></expr>)</condition><then> <block>{
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>eventPoint</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>eventPoint</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eventPoint</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsMouseEvent</name></type> <name>event</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>aEventType</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsMouseEvent</name>::<name>eReal</name></name></expr></argument>,
                     <argument><expr><name>aIsContextMenuKey</name>
                     ? <name><name>nsMouseEvent</name>::<name>eContextMenuKey</name></name>
                     : <name><name>nsMouseEvent</name>::<name>eNormal</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aEventType</name> == <name>NS_CONTEXTMENU</name> &amp;&amp; <name>aIsContextMenuKey</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>zero</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>eventPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isControl</name></name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isAlt</name></name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>button</name></name>    = <name>aButton</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>mpScreen</name> <init>= <expr><name>eventPoint</name> + <call><name>WidgetToScreenOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Suppress mouse moves caused by widget creation</comment>
  <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_MOVE</name></expr>)</condition><then> 
  <block>{
    <if>if <condition>(<expr>(<name><name>sLastMouseMovePoint</name>.<name>x</name></name> == <name><name>mpScreen</name>.<name>x</name></name>) &amp;&amp; (<name><name>sLastMouseMovePoint</name>.<name>y</name></name> == <name><name>mpScreen</name>.<name>y</name></name>)</expr>)</condition><then>
      <return>return <expr><name>result</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>sLastMouseMovePoint</name>.<name>x</name></name> = <name><name>mpScreen</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sLastMouseMovePoint</name>.<name>y</name></name> = <name><name>mpScreen</name>.<name>y</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>insideMovementThreshold</name> <init>= <expr>(<call><name>abs</name><argument_list>(<argument><expr><name><name>sLastMousePoint</name>.<name>x</name></name> - <name><name>eventPoint</name>.<name>x</name></name></expr></argument>)</argument_list></call> &lt; (<name>short</name>)<call><name>::<name>GetSystemMetrics</name></name><argument_list>(<argument><expr><name>SM_CXDOUBLECLK</name></expr></argument>)</argument_list></call>) &amp;&amp;
                                   (<call><name>abs</name><argument_list>(<argument><expr><name><name>sLastMousePoint</name>.<name>y</name></name> - <name><name>eventPoint</name>.<name>y</name></name></expr></argument>)</argument_list></call> &lt; (<name>short</name>)<call><name>::<name>GetSystemMetrics</name></name><argument_list>(<argument><expr><name>SM_CYDOUBLECLK</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>BYTE</name></type> <name>eventButton</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>aButton</name></expr>)</condition> <block>{
    <case>case <expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr>:
      <expr_stmt><expr><name>eventButton</name> = <name>VK_LBUTTON</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr>:
      <expr_stmt><expr><name>eventButton</name> = <name>VK_MBUTTON</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr>:
      <expr_stmt><expr><name>eventButton</name> = <name>VK_RBUTTON</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <expr_stmt><expr><name>eventButton</name> = 0</expr>;</expr_stmt>
      <break>break;</break>
  </default>}</block></switch>

  <comment type="line">// Doubleclicks are used to set the click count, then changed to mousedowns</comment>
  <comment type="line">// We're going to time double-clicks from mouse *up* to next mouse *down*</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>LONG</name></type> <name>curMsgTime</name> <init>= <expr><call><name>::<name>GetMessageTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>LONG</name></type> <name>curMsgTime</name> <init>= <expr><call><name>PR_Now</name><argument_list>()</argument_list></call> / 1000</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_DOUBLECLICK</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>event</name>.<name>message</name></name> = <name>NS_MOUSE_BUTTON_DOWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>button</name></name> = <name>aButton</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sLastClickCount</name> = 2</expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_BUTTON_UP</name></expr>)</condition><then> <block>{
    <comment type="line">// remember when this happened for the next mouse down</comment>
    <expr_stmt><expr><name><name>sLastMousePoint</name>.<name>x</name></name> = <name><name>eventPoint</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sLastMousePoint</name>.<name>y</name></name> = <name><name>eventPoint</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sLastMouseButton</name> = <name>eventButton</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_BUTTON_DOWN</name></expr>)</condition><then> <block>{
    <comment type="line">// now look to see if we want to convert this to a double- or triple-click</comment>
    <if>if <condition>(<expr>((<name>curMsgTime</name> - <name>sLastMouseDownTime</name>) &lt; (<name>LONG</name>)<call><name>::<name>GetDoubleClickTime</name></name><argument_list>()</argument_list></call>) &amp;&amp; <name>insideMovementThreshold</name> &amp;&amp;
        <name>eventButton</name> == <name>sLastMouseButton</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>sLastClickCount</name> ++</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// reset the click count, to count *this* click</comment>
      <expr_stmt><expr><name>sLastClickCount</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
    <comment type="line">// Set last Click time on MouseDown only</comment>
    <expr_stmt><expr><name>sLastMouseDownTime</name> = <name>curMsgTime</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_MOVE</name> &amp;&amp; !<name>insideMovementThreshold</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>sLastClickCount</name> = 0</expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_EXIT</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>event</name>.<name>exit</name></name> = <call><name>IsTopLevelMouseExit</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call> ? <name><name>nsMouseEvent</name>::<name>eTopLevel</name></name> : <name><name>nsMouseEvent</name>::<name>eChild</name></name></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if></else></if></else></if>
  <expr_stmt><expr><name><name>event</name>.<name>clickCount</name></name> = <name>sLastClickCount</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG_XX</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Msg Time: %d Click Count: %d\n"</expr></argument>, <argument><expr><name>curMsgTime</name></expr></argument>, <argument><expr><name><name>event</name>.<name>clickCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>NPEvent</name></type> <name>pluginEvent</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>aEventType</name></expr>)</condition>
  <block>{
    <case>case <expr><name>NS_MOUSE_BUTTON_DOWN</name></expr>:
      <switch>switch <condition>(<expr><name>aButton</name></expr>)</condition> <block>{
        <case>case <expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_LBUTTONDOWN</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_MBUTTONDOWN</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_RBUTTONDOWN</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><default>default:
          <break>break;</break>
      </default>}</block></switch>
      <break>break;</break>
    </case><case>case <expr><name>NS_MOUSE_BUTTON_UP</name></expr>:
      <switch>switch <condition>(<expr><name>aButton</name></expr>)</condition> <block>{
        <case>case <expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_LBUTTONUP</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_MBUTTONUP</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_RBUTTONUP</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><default>default:
          <break>break;</break>
      </default>}</block></switch>
      <break>break;</break>
    </case><case>case <expr><name>NS_MOUSE_DOUBLECLICK</name></expr>:
      <switch>switch <condition>(<expr><name>aButton</name></expr>)</condition> <block>{
        <case>case <expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_LBUTTONDBLCLK</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_MBUTTONDBLCLK</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr>:
          <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_RBUTTONDBLCLK</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><default>default:
          <break>break;</break>
      </default>}</block></switch>
      <break>break;</break>
    </case><case>case <expr><name>NS_MOUSE_MOVE</name></expr>:
      <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_MOUSEMOVE</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>NS_MOUSE_EXIT</name></expr>:
      <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_MOUSELEAVE</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_NULL</name></expr>;</expr_stmt>
      <break>break;</break>
  </default>}</block></switch>

  <expr_stmt><expr><name><name>pluginEvent</name>.<name>wParam</name></name> = <name>wParam</name></expr>;</expr_stmt>     <comment type="line">// plugins NEED raw OS event flags!</comment>
  <expr_stmt><expr><name><name>pluginEvent</name>.<name>lParam</name></name> = <name>lParam</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>event</name>.<name>pluginEvent</name></name> = (<name>void</name> *)&amp;<name>pluginEvent</name></expr>;</expr_stmt>

  <comment type="line">// call the event callback</comment>
  <if>if <condition>(<expr><name>nsnull</name> != <name>mEventCallback</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>nsToolkit</name>::<name>gMouseTrailer</name></name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>nsToolkit</name>::<name>gMouseTrailer</name>-&gt;<name>Disable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_MOVE</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name><name>nsToolkit</name>::<name>gMouseTrailer</name></name> &amp;&amp; !<name>mIsInMouseCapture</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>nsToolkit</name>::<name>gMouseTrailer</name>-&gt;<name>SetMouseTrailerWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsIntRect</name></type> <name>rect</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GetBounds</name><argument_list>(<argument><expr><name>rect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rect</name>.<name>x</name></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rect</name>.<name>y</name></name> = 0</expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name><name>rect</name>.<name>Contains</name></name><argument_list>(<argument><expr><name><name>event</name>.<name>refPoint</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>sCurrentWindow</name> == <name>NULL</name> || <name>sCurrentWindow</name> != <name>this</name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr>(<name>nsnull</name> != <name>sCurrentWindow</name>) &amp;&amp; (!<name><name>sCurrentWindow</name>-&gt;<name>mInDtor</name></name>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LPARAM</name></type> <name>pos</name> <init>= <expr><call><name><name>sCurrentWindow</name>-&gt;<name>lParamToClient</name></name><argument_list>(<argument><expr><call><name>lParamToScreen</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>sCurrentWindow</name>-&gt;<name>DispatchMouseEvent</name></name><argument_list>(<argument><expr><name>NS_MOUSE_EXIT</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>sCurrentWindow</name> = <name>this</name></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>mInDtor</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LPARAM</name></type> <name>pos</name> <init>= <expr><call><name><name>sCurrentWindow</name>-&gt;<name>lParamToClient</name></name><argument_list>(<argument><expr><call><name>lParamToScreen</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>sCurrentWindow</name>-&gt;<name>DispatchMouseEvent</name></name><argument_list>(<argument><expr><name>NS_MOUSE_ENTER</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>aEventType</name> == <name>NS_MOUSE_EXIT</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>sCurrentWindow</name> == <name>this</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sCurrentWindow</name> = <name>nsnull</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>

    <expr_stmt><expr><name>result</name> = <call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>nsToolkit</name>::<name>gMouseTrailer</name></name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>nsToolkit</name>::<name>gMouseTrailer</name>-&gt;<name>Enable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Release the widget with NS_IF_RELEASE() just in case</comment>
    <comment type="line">// the context menu key code in nsEventListenerManager::HandleEvent()</comment>
    <comment type="line">// released it already.</comment>
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">// Deal with accessibile event</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchAccessibleEvent</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventType</name></decl></param>, <param><decl><type><name>nsIAccessible</name>**</type> <name>aAcc</name></decl></param>, <param><decl><type><name>nsIntPoint</name>*</type> <name>aPoint</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>nsnull</name> == <name>mEventCallback</name></expr>)</condition><then> <block>{
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>aAcc</name> = <name>nsnull</name></expr>;</expr_stmt>

  <function_decl><type><name>nsAccessibleEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>aEventType</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>aPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isControl</name></name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isAlt</name></name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>accessible</name></name> = <name>nsnull</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>result</name> = <call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// if the event returned an accesssible get it.</comment>
  <if>if <condition>(<expr><name><name>event</name>.<name>accessible</name></name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aAcc</name> = <name><name>event</name>.<name>accessible</name></name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchFocusToTopLevelWindow</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventType</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aEventType</name> == <name>NS_ACTIVATE</name></expr>)</condition><then>
    <expr_stmt><expr><name>sJustGotActivate</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>sJustGotDeactivate</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <comment type="line">// retrive the toplevel window or dialog</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>curWnd</name> <init>= <expr><name>mWnd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HWND</name></type> <name>toplevelWnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>curWnd</name></expr>)</condition> <block>{
    <expr_stmt><expr><name>toplevelWnd</name> = <name>curWnd</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsWindow</name> *</type><name>win</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>curWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>win</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsWindowType</name></type> <name>wintype</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>win</name>-&gt;<name>GetWindowType</name></name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>wintype</name> == <name>eWindowType_toplevel</name> || <name>wintype</name> == <name>eWindowType_dialog</name></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>curWnd</name> = <call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>curWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Parent or owner (if has no parent)</comment>
  }</block></while>

  <if>if <condition>(<expr><name>toplevelWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsWindow</name> *</type><name>win</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>toplevelWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>win</name></expr>)</condition><then>
      <return>return <expr><call><name><name>win</name>-&gt;<name>DispatchFocus</name></name><argument_list>(<argument><expr><name>aEventType</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block></then></if>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Deal with focus messages</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>DispatchFocus</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventType</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// call the event callback</comment>
  <if>if <condition>(<expr><name>mEventCallback</name></expr>)</condition><then> <block>{
    <function_decl><type><name>nsGUIEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>aEventType</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//focus and blur event should go to their base widget loc, not current mouse pos</comment>
    <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>x</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>y</name></name> = 0</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>NPEvent</name></type> <name>pluginEvent</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>aEventType</name></expr>)</condition>
    <block>{
      <case>case <expr><name>NS_ACTIVATE</name></expr>:
        <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_SETFOCUS</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>NS_DEACTIVATE</name></expr>:
        <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_KILLFOCUS</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>NS_PLUGIN_ACTIVATE</name></expr>:
        <expr_stmt><expr><name><name>pluginEvent</name>.<name>event</name></name> = <name>WM_KILLFOCUS</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <break>break;</break>
    </default>}</block></switch>

    <expr_stmt><expr><name><name>event</name>.<name>pluginEvent</name></name> = (<name>void</name> *)&amp;<name>pluginEvent</name></expr>;</expr_stmt>

    <return>return <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>IsTopLevelMouseExit</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>DWORD</name></type> <name>pos</name> <init>= <expr><call><name>::<name>GetMessagePos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>POINT</name></type> <name>mp</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>mp</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mp</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>HWND</name></type> <name>mouseWnd</name> <init>= <expr><call><name>::<name>WindowFromPoint</name></name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// GetTopLevelHWND will return a HWND for the window frame (which includes</comment>
  <comment type="line">// the non-client area).  If the mouse has moved into the non-client area,</comment>
  <comment type="line">// we should treat it as a top-level exit.</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>mouseTopLevel</name> <init>= <expr><call><name><name>nsWindow</name>::<name>GetTopLevelHWND</name></name><argument_list>(<argument><expr><name>mouseWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mouseWnd</name> == <name>mouseTopLevel</name></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <return>return <expr><call><name><name>nsWindow</name>::<name>GetTopLevelHWND</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>)</argument_list></call> != <name>mouseTopLevel</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>BlurEventsSuppressed</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// are they suppressed in this window?</comment>
  <if>if <condition>(<expr><name>mBlurSuppressLevel</name> &gt; 0</expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <comment type="line">// are they suppressed by any container widget?</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>parentWnd</name> <init>= <expr><call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>parentWnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsWindow</name> *</type><name>parent</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>parentWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>parent</name></expr>)</condition><then>
      <return>return <expr><call><name><name>parent</name>-&gt;<name>BlurEventsSuppressed</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// In some circumstances (opening dependent windows) it makes more sense</comment>
<comment type="line">// (and fixes a crash bug) to not blur the parent window. Called from</comment>
<comment type="line">// nsFilePicker.</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>SuppressBlurEvents</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSuppress</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aSuppress</name></expr>)</condition><then>
    <expr_stmt><expr>++<name>mBlurSuppressLevel</name></expr>;</expr_stmt></then> <comment type="line">// for this widget</comment>
  <else>else <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mBlurSuppressLevel</name> &gt; 0</expr></argument>, <argument><expr>"unbalanced blur event suppression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mBlurSuppressLevel</name> &gt; 0</expr>)</condition><then>
      <expr_stmt><expr>--<name>mBlurSuppressLevel</name></expr>;</expr_stmt></then></if>
  }</block></else></if>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>ConvertStatus</name></name><parameter_list>(<param><decl><type><name>nsEventStatus</name></type> <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>aStatus</name> == <name>nsEventStatus_eConsumeNoDefault</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: IPC
 *
 * IPC related helpers.
 *
 **************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>

<comment type="line">// static</comment>
<function><type><name>bool</name></type>
<name><name>nsWindow</name>::<name>IsAsyncResponseEvent</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>aMsg</name></decl></param>, <param><decl><type><name>LRESULT</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <switch>switch<condition>(<expr><name>aMsg</name></expr>)</condition> <block>{
    <case>case <expr><name>WM_SETFOCUS</name></expr>:
    </case><case>case <expr><name>WM_KILLFOCUS</name></expr>:
    </case><case>case <expr><name>WM_ENABLE</name></expr>:
    </case><case>case <expr><name>WM_WINDOWPOSCHANGING</name></expr>:
    </case><case>case <expr><name>WM_WINDOWPOSCHANGED</name></expr>:
    </case><case>case <expr><name>WM_PARENTNOTIFY</name></expr>:
    </case><case>case <expr><name>WM_ACTIVATEAPP</name></expr>:
    </case><case>case <expr><name>WM_NCACTIVATE</name></expr>:
    </case><case>case <expr><name>WM_ACTIVATE</name></expr>:
    </case><case>case <expr><name>WM_CHILDACTIVATE</name></expr>:
    </case><case>case <expr><name>WM_IME_SETCONTEXT</name></expr>:
    </case><case>case <expr><name>WM_IME_NOTIFY</name></expr>:
    </case><case>case <expr><name>WM_SHOWWINDOW</name></expr>:
    </case><case>case <expr><name>WM_CANCELMODE</name></expr>:
    </case><case>case <expr><name>WM_MOUSEACTIVATE</name></expr>:
    </case><case>case <expr><name>WM_CONTEXTMENU</name></expr>:
      <expr_stmt><expr><name>aResult</name> = 0</expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>

    </case><case>case <expr><name>WM_SETTINGCHANGE</name></expr>:
    </case><case>case <expr><name>WM_SETCURSOR</name></expr>:
    <return>return <expr>false</expr>;</return>
  </case>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>char</name></type> <name><name>szBuf</name><index>[<expr>200</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>szBuf</name></expr></argument>,
    <argument><expr>"An unhandled ISMEX_SEND message was received during spin loop! (%X)"</expr></argument>, <argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr><name>szBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsWindow</name>::<name>IPCWindowProcHandler</name></name><parameter_list>(<param><decl><type><name>UINT</name>&amp;</type> <name>msg</name></decl></param>, <param><decl><type><name>WPARAM</name>&amp;</type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name>&amp;</type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>mozilla</name>::<name>ipc</name>::<name>SyncChannel</name>::<name>IsPumpingMessages</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Failed to prevent a nonqueued message from running!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Modal UI being displayed in windowless plugins.</comment>
  <if>if <condition>(<expr><call><name><name>mozilla</name>::<name>ipc</name>::<name>RPCChannel</name>::<name>IsSpinLoopActive</name></name><argument_list>()</argument_list></call> &amp;&amp;
      (<call><name>InSendMessageEx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>&amp;(<name>ISMEX_REPLIED</name>|<name>ISMEX_SEND</name>)) == <name>ISMEX_SEND</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>LRESULT</name></type> <name>res</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>IsAsyncResponseEvent</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>ReplyMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// Handle certain sync plugin events sent to the parent which</comment>
  <comment type="line">// trigger ipc calls that result in deadlocks.</comment>

  <comment type="line">// Windowed plugins receiving focus triggering WM_ACTIVATE app messages.</comment>
  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_plugin</name> &amp;&amp; <name>msg</name> == <name>WM_SETFOCUS</name> &amp;&amp;
    <call><name>GetPropW</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>L"PluginInstanceParentProperty"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ReplyMessage</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// Windowless flash sending WM_ACTIVATE events to the main window</comment>
  <comment type="line">// via calls to ShowWindow.</comment>
  <if>if <condition>(<expr><name>msg</name> == <name>WM_ACTIVATE</name> &amp;&amp; <name>lParam</name> != 0 &amp;&amp;
      <call><name>LOWORD</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call> == <name>WA_ACTIVE</name> &amp;&amp; <call><name>IsWindow</name><argument_list>(<argument><expr>(<name>HWND</name>)<name>lParam</name></expr></argument>)</argument_list></call> &amp;&amp;
      (<call><name>InSendMessageEx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>&amp;(<name>ISMEX_REPLIED</name>|<name>ISMEX_SEND</name>)) == <name>ISMEX_SEND</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ReplyMessage</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// Windowed plugins that pass sys key events to defwndproc generate</comment>
  <comment type="line">// WM_SYSCOMMAND events to the main window.</comment>
  <if>if <condition>(<expr><name>msg</name> == <name>WM_SYSCOMMAND</name> &amp;&amp;
      (<call><name>InSendMessageEx</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>&amp;(<name>ISMEX_REPLIED</name>|<name>ISMEX_SEND</name>)) == <name>ISMEX_SEND</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ReplyMessage</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_IPC</comment>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Native events
 **
 ** Main Windows message handlers and OnXXX handlers for
 ** Windows event handling.
 **
 **************************************************************
 **************************************************************/</comment>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Wind proc.
 *
 * The main Windows event procedures and associated
 * message processing methods.
 *
 **************************************************************/</comment>

<comment type="line">// The WndProc procedure for all nsWindows in this toolkit</comment>
<function><type><name>LRESULT</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>WindowProc</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>msg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Get the window which caused the event and ask it to process the message</comment>
  <decl_stmt><decl><type><name>nsWindow</name> *</type><name>someWindow</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
  <if>if <condition>(<expr><name>someWindow</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>someWindow</name>-&gt;<name>IPCWindowProcHandler</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// create this here so that we store the last rolled up popup until after</comment>
  <comment type="line">// the event has been processed.</comment>
  <decl_stmt><decl><type><name>nsAutoRollup</name></type> <name>autoRollup</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>LRESULT</name></type> <name>popupHandlingResult</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>DealWithPopups</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr>&amp;<name>popupHandlingResult</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>popupHandlingResult</name></expr>;</return></then></if>

  <comment type="line">// XXX This fixes 50208 and we are leaving 51174 open to further investigate</comment>
  <comment type="line">// why we are hitting this assert</comment>
  <if>if <condition>(<expr><name>nsnull</name> == <name>someWindow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>someWindow</name></expr></argument>, <argument><expr>"someWindow is null, cannot call any CallWindowProc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>::<name>DefWindowProcW</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <comment type="line">// hold on to the window for the life of this method, in case it gets</comment>
  <comment type="line">// deleted during processing. yes, it's a double hack, since someWindow</comment>
  <comment type="line">// is not really an interface.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>someWindow</name>-&gt;<name>mInDtor</name></name></expr>)</condition><then> <comment type="line">// not if we're in the destructor!</comment>
    <expr_stmt><expr><name>kungFuDeathGrip</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr>(<name>nsBaseWidget</name>*)<name>someWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Re-direct a tab change message destined for its parent window to the</comment>
  <comment type="line">// the actual window which generated the event.</comment>
  <if>if <condition>(<expr><name>msg</name> == <name>WM_NOTIFY</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>LPNMHDR</name></type> <name>pnmh</name> <init>= <expr>(<name>LPNMHDR</name>) <name>lParam</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>pnmh</name>-&gt;<name>code</name></name> == <name>TCN_SELCHANGE</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>someWindow</name> = <call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name><name>pnmh</name>-&gt;<name>hwndFrom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Call ProcessMessage</comment>
  <decl_stmt><decl><type><name>LRESULT</name></type> <name>retValue</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>PR_TRUE</name> == <call><name><name>someWindow</name>-&gt;<name>ProcessMessage</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr>&amp;<name>retValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>retValue</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>LRESULT</name></type> <name>res</name> <init>= <expr><call><name>::<name>CallWindowProcW</name></name><argument_list>(<argument><expr><call><name><name>someWindow</name>-&gt;<name>GetPrevWindowProc</name></name><argument_list>()</argument_list></call></expr></argument>,
                                  <argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="line">// The main windows message processing method for plugins.</comment>
<comment type="line">// The result means whether this method processed the native</comment>
<comment type="line">// event for plugin. If false, the native event should be</comment>
<comment type="line">// processed by the caller self.</comment>
<function><type><name>PRBool</name></type>
<name><name>nsWindow</name>::<name>ProcessMessageForPlugin</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MSG</name> &amp;</type><name>aMsg</name></decl></param>,
                                  <param><decl><type><name>LRESULT</name> *</type><name>aResult</name></decl></param>,
                                  <param><decl><type><name>PRBool</name> &amp;</type><name>aCallDefWndProc</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aResult</name></expr></argument>, <argument><expr>"aResult must be non-null."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aResult</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>aCallDefWndProc</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>fallBackToNonPluginProcess</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>eventDispatched</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>dispatchPendingEvents</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>aMsg</name>.<name>message</name></name></expr>)</condition> <block>{
    <case>case <expr><name>WM_INPUTLANGCHANGEREQUEST</name></expr>:
    </case><case>case <expr><name>WM_INPUTLANGCHANGE</name></expr>:
      <expr_stmt><expr><call><name>DispatchPluginEvent</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// go to non-plug-ins processing</comment>

    </case><case>case <expr><name>WM_CHAR</name></expr>:
    </case><case>case <expr><name>WM_SYSCHAR</name></expr>:
      <expr_stmt><expr>*<name>aResult</name> = <call><name>ProcessCharMessage</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr>&amp;<name>eventDispatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_KEYUP</name></expr>:
    </case><case>case <expr><name>WM_SYSKEYUP</name></expr>:
      <expr_stmt><expr>*<name>aResult</name> = <call><name>ProcessKeyUpMessage</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr>&amp;<name>eventDispatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_KEYDOWN</name></expr>:
    </case><case>case <expr><name>WM_SYSKEYDOWN</name></expr>:
      <expr_stmt><expr>*<name>aResult</name> = <call><name>ProcessKeyDownMessage</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr>&amp;<name>eventDispatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_DEADCHAR</name></expr>:
    </case><case>case <expr><name>WM_SYSDEADCHAR</name></expr>:
    </case><case>case <expr><name>WM_CONTEXTMENU</name></expr>:

    </case><case>case <expr><name>WM_CUT</name></expr>:
    </case><case>case <expr><name>WM_COPY</name></expr>:
    </case><case>case <expr><name>WM_PASTE</name></expr>:
    </case><case>case <expr><name>WM_CLEAR</name></expr>:
    </case><case>case <expr><name>WM_UNDO</name></expr>:

    </case><case>case <expr><name>WM_IME_STARTCOMPOSITION</name></expr>:
    </case><case>case <expr><name>WM_IME_COMPOSITION</name></expr>:
    </case><case>case <expr><name>WM_IME_ENDCOMPOSITION</name></expr>:
    </case><case>case <expr><name>WM_IME_CHAR</name></expr>:
    </case><case>case <expr><name>WM_IME_COMPOSITIONFULL</name></expr>:
    </case><case>case <expr><name>WM_IME_CONTROL</name></expr>:
    </case><case>case <expr><name>WM_IME_KEYDOWN</name></expr>:
    </case><case>case <expr><name>WM_IME_KEYUP</name></expr>:
    </case><case>case <expr><name>WM_IME_NOTIFY</name></expr>:
    </case><case>case <expr><name>WM_IME_REQUEST</name></expr>:
    </case><case>case <expr><name>WM_IME_SELECT</name></expr>:
      <break>break;</break>

    </case><case>case <expr><name>WM_IME_SETCONTEXT</name></expr>:
      <comment type="line">// Don't synchronously dispatch when we receive WM_IME_SETCONTEXT</comment>
      <comment type="line">// because we get it during plugin destruction. (bug 491848)</comment>
      <expr_stmt><expr><name>dispatchPendingEvents</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>

  <if>if <condition>(<expr>!<name>eventDispatched</name></expr>)</condition><then>
    <expr_stmt><expr><name>aCallDefWndProc</name> = !<call><name>DispatchPluginEvent</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>dispatchPendingEvents</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// The main windows message processing method.</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>ProcessMessage</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>msg</name></decl></param>, <param><decl><type><name>WPARAM</name> &amp;</type><name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name> &amp;</type><name>lParam</name></decl></param>,
                                <param><decl><type><name>LRESULT</name> *</type><name>aRetValue</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// (Large blocks of code should be broken out into OnEvent handlers.)</comment>
  <if>if <condition>(<expr><call><name><name>mWindowHook</name>.<name>Notify</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT_DEBUG_OUTPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// First param shows all events, second param indicates whether</comment>
  <comment type="line">// to show mouse move events. See nsWindowDbg for details.</comment>
  <expr_stmt><expr><call><name>PrintEvent</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>SHOW_REPEAT_EVENTS</name></expr></argument>, <argument><expr><name>SHOW_MOUSEMOVE_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>eatMessage</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>nsIMM32Handler</name>::<name>ProcessMessage</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>,
                                     <argument><expr><name>eatMessage</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>mWnd</name> ? <name>eatMessage</name> : <name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>PluginHasFocus</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>callDefaultWndProc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSG</name></type> <name>nativeMsg</name> <init>= <expr><call><name>InitMSG</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>ProcessMessageForPlugin</name><argument_list>(<argument><expr><name>nativeMsg</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>, <argument><expr><name>callDefaultWndProc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>mWnd</name> ? !<name>callDefaultWndProc</name> : <name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><specifier>static</specifier> <name>UINT</name></type> <name>vkKeyCached</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// caches VK code fon WM_KEYDOWN</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>    <comment type="line">// call the default nsWindow proc</comment>
  <expr_stmt><expr>*<name>aRetValue</name> = 0</expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>getWheelInfo</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>msg</name></expr>)</condition> <block>{
    <case>case <expr><name>WM_COMMAND</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>WORD</name></type> <name>wNotifyCode</name> <init>= <expr><call><name>HIWORD</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// notification code</comment>
      <if>if <condition>(<expr>(<name>CBN_SELENDOK</name> == <name>wNotifyCode</name>) || (<name>CBN_SELENDCANCEL</name> == <name>wNotifyCode</name>)</expr>)</condition><then> <block>{ <comment type="line">// Combo box change</comment>
        <function_decl><type><name>nsGUIEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTROL_CHANGE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// this add ref's event.widget</comment>
        <expr_stmt><expr><name>result</name> = <call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>wNotifyCode</name> == 0</expr>)</condition><then> <block>{ <comment type="line">// Menu selection</comment>
        <function_decl><type><name>nsMenuEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MENU_SELECTED</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><name><name>event</name>.<name>mCommand</name></name> = <call><name>LOWORD</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block>
    <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <comment type="line">// WM_QUERYENDSESSION must be handled by all windows.</comment>
    <comment type="line">// Otherwise Windows thinks the window can just be killed at will.</comment>
    </case><case>case <expr><name>WM_QUERYENDSESSION</name></expr>:
      <if>if <condition>(<expr><name>sCanQuit</name> == <name>TRI_UNKNOWN</name></expr>)</condition><then>
      <block>{
        <comment type="line">// Ask if it's ok to quit, and store the answer until we</comment>
        <comment type="line">// get WM_ENDSESSION signaling the round is complete.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObserverService</name></expr></argument>&gt;</argument_list></name></type> <name>obsServ</name> <init>=
          <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/observer-service;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupportsPRBool</name></expr></argument>&gt;</argument_list></name></type> <name>cancelQuit</name> <init>=
          <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>NS_SUPPORTS_PRBOOL_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cancelQuit</name>-&gt;<name>SetData</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>cancelQuit</name></expr></argument>, <argument><expr>"quit-application-requested"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>PRBool</name></type> <name>abortQuit</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cancelQuit</name>-&gt;<name>GetData</name></name><argument_list>(<argument><expr>&amp;<name>abortQuit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sCanQuit</name> = <name>abortQuit</name> ? <name>TRI_FALSE</name> : <name>TRI_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr>*<name>aRetValue</name> = <name>sCanQuit</name> ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_ENDSESSION</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr><name>MOZ_WM_APP_QUIT</name></expr>:
      <if>if <condition>(<expr><name>msg</name> == <name>MOZ_WM_APP_QUIT</name> || (<name>wParam</name> == <name>TRUE</name> &amp;&amp; <name>sCanQuit</name> == <name>TRI_TRUE</name>)</expr>)</condition><then>
      <block>{
        <comment type="line">// Let's fake a shutdown sequence without actually closing windows etc.</comment>
        <comment type="line">// to avoid Windows killing us in the middle. A proper shutdown would</comment>
        <comment type="line">// require having a chance to pump some messages. Unfortunately</comment>
        <comment type="line">// Windows won't let us do that. Bug 212316.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObserverService</name></expr></argument>&gt;</argument_list></name></type> <name>obsServ</name> <init>=
          <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/observer-service;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_NAMED_LITERAL_STRING</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>"shutdown-persist"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"quit-application-granted"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"quit-application-forced"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"quit-application"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"profile-change-net-teardown"</expr></argument>, <argument><expr><call><name><name>context</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"profile-change-teardown"</expr></argument>, <argument><expr><call><name><name>context</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obsServ</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>"profile-before-change"</expr></argument>, <argument><expr><call><name><name>context</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Then a controlled but very quick exit.</comment>
        <expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>sCanQuit</name> = <name>TRI_UNKNOWN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_DISPLAYCHANGE</name></expr>:
      <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_DISPLAYCHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>WM_SYSCOLORCHANGE</name></expr>:
      <comment type="line">// Note: This is sent for child windows as well as top-level windows.</comment>
      <comment type="line">// The Win32 toolkit normally only sends these events to top-level windows.</comment>
      <comment type="line">// But we cycle through all of the childwindows and send it to them as well</comment>
      <comment type="line">// so all presentations get notified properly.</comment>
      <comment type="line">// See nsWindow::GlobalMsgWindowProc.</comment>
      <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_SYSCOLORCHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_NOTIFY</name></expr>:
      <comment type="line">// TAB change</comment>
    <block>{
      <decl_stmt><decl><type><name>LPNMHDR</name></type> <name>pnmh</name> <init>= <expr>(<name>LPNMHDR</name>) <name>lParam</name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>pnmh</name>-&gt;<name>code</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TCN_SELCHANGE</name></expr>:
          <block>{
            <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_TABCHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          }</block>
          <break>break;</break>
        </case>}</block></switch>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_XP_THEMECHANGED</name></expr>:
    <block>{
      <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_THEMECHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Invalidate the window so that the repaint will</comment>
      <comment type="line">// pick up the new theme.</comment>
      <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_FONTCHANGE</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>didChange</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

      <comment type="line">// update the global font list</comment>
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFontEnumerator</name></expr></argument>&gt;</argument_list></name></type> <name>fontEnum</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/gfx/fontenumerator;1"</expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>fontEnum</name>-&gt;<name>UpdateFontList</name></name><argument_list>(<argument><expr>&amp;<name>didChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//didChange is TRUE only if new font langGroup is added to the list.</comment>
        <if>if <condition>(<expr><name>didChange</name></expr>)</condition><then>  <block>{
          <comment type="line">// update device context font cache</comment>
          <comment type="line">// Dirty but easiest way:</comment>
          <comment type="line">// Changing nsIPrefBranch entry which triggers callbacks</comment>
          <comment type="line">// and flows into calling mDeviceContext-&gt;FlushFontCache()</comment>
          <comment type="line">// to update the font cache in all the instance of Browsers</comment>
          <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefService</name></expr></argument>&gt;</argument_list></name></type> <name>prefs</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>prefs</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>fiPrefs</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>prefs</name>-&gt;<name>GetBranch</name></name><argument_list>(<argument><expr>"font.internaluseonly."</expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>fiPrefs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>fiPrefs</name></expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>PRBool</name></type> <name>fontInternalChange</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>fiPrefs</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"changed"</expr></argument>, <argument><expr>&amp;<name>fontInternalChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>fiPrefs</name>-&gt;<name>SetBoolPref</name></name><argument_list>(<argument><expr>"changed"</expr></argument>, <argument><expr>!<name>fontInternalChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if> <comment type="line">//if (NS_SUCCEEDED(rv))</comment>
    }</block>
    <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_POWERBROADCAST</name></expr>:
      <comment type="line">// only hidden window handle this</comment>
      <comment type="line">// to prevent duplicate notification</comment>
      <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>wParam</name></expr>)</condition>
        <block>{
          <case>case <expr><name>PBT_APMSUSPEND</name></expr>:
            <expr_stmt><expr><call><name>PostSleepWakeNotification</name><argument_list>(<argument><expr>"sleep_notification"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>PBT_APMRESUMEAUTOMATIC</name></expr>:
          </case><case>case <expr><name>PBT_APMRESUMECRITICAL</name></expr>:
          </case><case>case <expr><name>PBT_APMRESUMESUSPEND</name></expr>:
            <expr_stmt><expr><call><name>PostSleepWakeNotification</name><argument_list>(<argument><expr>"wake_notification"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>
      }</block></then></if>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>WM_MOVE</name></expr>: <comment type="line">// Window moved</comment>
    <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>x</name> <init>= <expr><call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// horizontal position in screen coordinates</comment>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>y</name> <init>= <expr><call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// vertical position in screen coordinates</comment>
      <expr_stmt><expr><name>result</name> = <call><name>OnMove</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_CLOSE</name></expr>: <comment type="line">// close request</comment>
      <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_XUL_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt> <comment type="line">// abort window closure</comment>
      <break>break;</break>

    </case><case>case <expr><name>WM_DESTROY</name></expr>:
      <comment type="line">// clean up.</comment>
      <expr_stmt><expr><call><name>OnDestroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_PAINT</name></expr>:
      <expr_stmt><expr>*<name>aRetValue</name> = (<name>int</name>) <call><name>OnPaint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_PRINTCLIENT</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>OnPaint</name><argument_list>(<argument><expr>(<name>HDC</name>) <name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>WM_HOTKEY</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>OnHotKey</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_SYSCHAR</name></expr>:
    </case><case>case <expr><name>WM_CHAR</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>MSG</name></type> <name>nativeMsg</name> <init>= <expr><call><name>InitMSG</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>result</name> = <call><name>ProcessCharMessage</name><argument_list>(<argument><expr><name>nativeMsg</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_SYSKEYUP</name></expr>:
    </case><case>case <expr><name>WM_KEYUP</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>MSG</name></type> <name>nativeMsg</name> <init>= <expr><call><name>InitMSG</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>result</name> = <call><name>ProcessKeyUpMessage</name><argument_list>(<argument><expr><name>nativeMsg</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_SYSKEYDOWN</name></expr>:
    </case><case>case <expr><name>WM_KEYDOWN</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>MSG</name></type> <name>nativeMsg</name> <init>= <expr><call><name>InitMSG</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>result</name> = <call><name>ProcessKeyDownMessage</name><argument_list>(<argument><expr><name>nativeMsg</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    <comment type="line">// say we've dealt with erase background if widget does</comment>
    <comment type="line">// not need auto-erasing</comment>
    </case><case>case <expr><name>WM_ERASEBKGND</name></expr>:
      <if>if <condition>(<expr>!<call><name>AutoErase</name><argument_list>(<argument><expr>(<name>HDC</name>)<name>wParam</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>aRetValue</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>

    </case><case>case <expr><name>WM_GETDLGCODE</name></expr>:
      <expr_stmt><expr>*<name>aRetValue</name> = <name>DLGC_WANTALLKEYS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_MOUSEMOVE</name></expr>:
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
      <comment type="line">// Reset the kill timer so that we can continue at this</comment>
      <comment type="line">// priority</comment>
      <expr_stmt><expr><call><name>SetTimer</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>KILL_PRIORITY_ID</name></expr></argument>, <argument><expr>2000</expr></argument> <comment type="block">/* 2seconds */</comment>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// Suppress dispatch of pending events</comment>
      <comment type="line">// when mouse moves are generated by widget</comment>
      <comment type="line">// creation instead of user input.</comment>
      <decl_stmt><decl><type><name>LPARAM</name></type> <name>lParamScreen</name> <init>= <expr><call><name>lParamToScreen</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>POINT</name></type> <name>mp</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>mp</name>.<name>x</name></name>      = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>lParamScreen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mp</name>.<name>y</name></name>      = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>lParamScreen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>userMovedMouse</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name><name>sLastMouseMovePoint</name>.<name>x</name></name> != <name><name>mp</name>.<name>x</name></name>) || (<name><name>sLastMouseMovePoint</name>.<name>y</name></name> != <name><name>mp</name>.<name>y</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>userMovedMouse</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_MOVE</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>userMovedMouse</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block>
    <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
    </case><case>case <expr><name>WM_TIMER</name></expr>:
      <expr_stmt><expr><call><name>SetThreadPriority</name><argument_list>(<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>THREAD_PRIORITY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>KillTimer</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>KILL_PRIORITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>WM_LBUTTONDOWN</name></expr>:
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
      <expr_stmt><expr><call><name>SetThreadPriority</name><argument_list>(<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>THREAD_PRIORITY_ABOVE_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SetTimer</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>KILL_PRIORITY_ID</name></expr></argument>, <argument><expr>2000</expr></argument> <comment type="block">/* 2 seconds */</comment>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_DOWN</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>,
                                  <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_LBUTTONUP</name></expr>:
    <block>{
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_UP</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>,
                                  <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
      <expr_stmt><expr><call><name>SetThreadPriority</name><argument_list>(<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>THREAD_PRIORITY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>KillTimer</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>KILL_PRIORITY_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_MOUSELEAVE</name></expr>:
    <block>{
      <comment type="line">// We need to check mouse button states and put them in for</comment>
      <comment type="line">// wParam.</comment>
      <decl_stmt><decl><type><name>WPARAM</name></type> <name>mouseState</name> <init>= <expr>(<call><name>GetKeyState</name><argument_list>(<argument><expr><name>VK_LBUTTON</name></expr></argument>)</argument_list></call> ? <name>MK_LBUTTON</name> : 0)
        | (<call><name>GetKeyState</name><argument_list>(<argument><expr><name>VK_MBUTTON</name></expr></argument>)</argument_list></call> ? <name>MK_MBUTTON</name> : 0)
        | (<call><name>GetKeyState</name><argument_list>(<argument><expr><name>VK_RBUTTON</name></expr></argument>)</argument_list></call> ? <name>MK_RBUTTON</name> : 0)</expr></init></decl>;</decl_stmt>
      <comment type="line">// Synthesize an event position because we don't get one from</comment>
      <comment type="line">// WM_MOUSELEAVE.</comment>
      <decl_stmt><decl><type><name>LPARAM</name></type> <name>pos</name> <init>= <expr><call><name>lParamToClient</name><argument_list>(<argument><expr><call><name>::<name>GetMessagePos</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_EXIT</name></expr></argument>, <argument><expr><name>mouseState</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>WM_CONTEXTMENU</name></expr>:
    <block>{
      <comment type="line">// if the context menu is brought up from the keyboard, |lParam|</comment>
      <comment type="line">// will be maxlong.</comment>
      <decl_stmt><decl><type><name>LPARAM</name></type> <name>pos</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>contextMenukey</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>lParam</name> == 0xFFFFFFFF</expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>contextMenukey</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> = <call><name>lParamToClient</name><argument_list>(<argument><expr><call><name>GetMessagePos</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><name>pos</name> = <call><name>lParamToClient</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_CONTEXTMENU</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>contextMenukey</name></expr></argument>,
                                  <argument><expr><name>contextMenukey</name> ?
                                    <name><name>nsMouseEvent</name>::<name>eLeftButton</name></name> :
                                    <name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_LBUTTONDBLCLK</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_DOUBLECLICK</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eLeftButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_MBUTTONDOWN</name></expr>:
    <block>{
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_DOWN</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_MBUTTONUP</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_UP</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_MBUTTONDBLCLK</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_DOWN</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eMiddleButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_RBUTTONDOWN</name></expr>:
    <block>{
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_DOWN</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_RBUTTONUP</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_BUTTON_UP</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DispatchPendingEvents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_RBUTTONDBLCLK</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>DispatchMouseEvent</name><argument_list>(<argument><expr><name>NS_MOUSE_DOUBLECLICK</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                  <argument><expr><name><name>nsMouseEvent</name>::<name>eRightButton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_APPCOMMAND</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>appCommand</name> <init>= <expr><call><name>GET_APPCOMMAND_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <switch>switch <condition>(<expr><name>appCommand</name></expr>)</condition>
      <block>{
        <case>case <expr><name>APPCOMMAND_BROWSER_BACKWARD</name></expr>:
        </case><case>case <expr><name>APPCOMMAND_BROWSER_FORWARD</name></expr>:
        </case><case>case <expr><name>APPCOMMAND_BROWSER_REFRESH</name></expr>:
        </case><case>case <expr><name>APPCOMMAND_BROWSER_STOP</name></expr>:
        </case><case>case <expr><name>APPCOMMAND_BROWSER_SEARCH</name></expr>:
        </case><case>case <expr><name>APPCOMMAND_BROWSER_FAVORITES</name></expr>:
        </case><case>case <expr><name>APPCOMMAND_BROWSER_HOME</name></expr>:
          <expr_stmt><expr><call><name>DispatchCommandEvent</name><argument_list>(<argument><expr><name>appCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// tell the driver that we handled the event</comment>
          <expr_stmt><expr>*<name>aRetValue</name> = 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
      </case>}</block></switch>
      <comment type="line">// default = PR_FALSE - tell the driver that the event was not handled</comment>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_HSCROLL</name></expr>:
    </case><case>case <expr><name>WM_VSCROLL</name></expr>:
      <expr_stmt><expr>*<name>aRetValue</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <call><name>OnScroll</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_CTLCOLORLISTBOX</name></expr>:
    </case><case>case <expr><name>WM_CTLCOLOREDIT</name></expr>:
    </case><case>case <expr><name>WM_CTLCOLORBTN</name></expr>:
    <comment type="line">//case WM_CTLCOLORSCROLLBAR: //XXX causes the scrollbar to be drawn incorrectly</comment>
    </case><case>case <expr><name>WM_CTLCOLORSTATIC</name></expr>:
      <if>if <condition>(<expr><name>lParam</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>control</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr>(<name>HWND</name>)<name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>control</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>control</name>-&gt;<name>SetUpForPaint</name></name><argument_list>(<argument><expr>(<name>HDC</name>)<name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>aRetValue</name> = (<name>LPARAM</name>)<call><name><name>control</name>-&gt;<name>OnControlColor</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
      }</block></then></if>

      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

    <comment type="line">// The WM_ACTIVATE event is fired when a window is raised or lowered,</comment>
    <comment type="line">// and the loword of wParam specifies which. But we don't want to tell</comment>
    <comment type="line">// the focus system about this until the WM_SETFOCUS or WM_KILLFOCUS</comment>
    <comment type="line">// events are fired. Instead, set either the sJustGotActivate or</comment>
    <comment type="line">// gJustGotDeativate flags and fire the NS_ACTIVATE or NS_DEACTIVATE</comment>
    <comment type="line">// events once the focus events arrive.</comment>
    </case><case>case <expr><name>WM_ACTIVATE</name></expr>:
      <if>if <condition>(<expr><name>mEventCallback</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>fActive</name> <init>= <expr><call><name>LOWORD</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_HAVE_SOFTKB</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if>if <condition>(<expr><name>mIsTopWidgetWindow</name> &amp;&amp; <name>sSoftKeyboardState</name></expr>)</condition><then>
          <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>ToggleSoftKB</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>fActive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>nsWindowCE</name>::<name>sShowSIPButton</name></name> == <name>TRI_FALSE</name> &amp;&amp; <name>WA_INACTIVE</name> != <name>fActive</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>HWND</name></type> <name>hWndSIPB</name> <init>= <expr><call><name>FindWindowW</name><argument_list>(<argument><expr>L"MS_SIPBUTTON"</expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt> 
          <if>if <condition>(<expr><name>hWndSIPB</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ShowWindow</name><argument_list>(<argument><expr><name>hWndSIPB</name></expr></argument>, <argument><expr><name>SW_HIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><name>WA_INACTIVE</name> == <name>fActive</name></expr>)</condition><then> <block>{
          <comment type="line">// when minimizing a window, the deactivation and focus events will</comment>
          <comment type="line">// be fired in the reverse order. Instead, just dispatch</comment>
          <comment type="line">// NS_DEACTIVATE right away.</comment>
          <if>if <condition>(<expr><call><name>HIWORD</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>result</name> = <call><name>DispatchFocusToTopLevelWindow</name><argument_list>(<argument><expr><name>NS_DEACTIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>sJustGotDeactivate</name> = <name>PR_TRUE</name></expr>;</expr_stmt></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
          <if>if <condition>(<expr><name>mIsTopWidgetWindow</name></expr>)</condition><then>
            <expr_stmt><expr><name>mLastKeyboardLayout</name> = <call><name><name>gKbdLayout</name>.<name>GetLayout</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        }</block></then> <else>else <block>{
          <expr_stmt><expr><call><name>StopFlashing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>sJustGotActivate</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          <function_decl><type><name>nsMouseEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MOUSE_ACTIVATE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>,
                             <param><decl><type><name><name>nsMouseEvent</name>::<name>eReal</name></name></type></decl></param>)</parameter_list>;</function_decl>
          <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>event</name>.<name>acceptActivation</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  
          <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
          <if>if <condition>(<expr><name><name>event</name>.<name>acceptActivation</name></name></expr>)</condition><then>
            <expr_stmt><expr>*<name>aRetValue</name> = <name>MA_ACTIVATE</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr>*<name>aRetValue</name> = <name>MA_NOACTIVATE</name></expr>;</expr_stmt></else></if>

          <if>if <condition>(<expr><name>sSwitchKeyboardLayout</name> &amp;&amp; <name>mLastKeyboardLayout</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ActivateKeyboardLayout</name><argument_list>(<argument><expr><name>mLastKeyboardLayout</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr>*<name>aRetValue</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if>if <condition>(<expr><name>mSizeMode</name> == <name>nsSizeMode_Fullscreen</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MakeFullScreen</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
      }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
      <if>if <condition>(<expr>!<name>gCheckForHTCApi</name> &amp;&amp; <name>gHTCApiNavOpen</name> == <name>nsnull</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>gCheckForHTCApi</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>HINSTANCE</name></type> <name>library</name> <init>= <expr><call><name>LoadLibrary</name><argument_list>(<argument><expr>L"HTCAPI.dll"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
        <expr_stmt><expr><name>gHTCApiNavOpen</name>    = (<name>HTCApiNavOpen</name>)    <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>library</name></expr></argument>, <argument><expr>"HTCNavOpen"</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><name>gHTCApiNavSetMode</name> = (<name>HTCApiNavSetMode</name>) <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>library</name></expr></argument> ,<argument><expr>"HTCNavSetMode"</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      }</block></then></if>
      
      <if>if <condition>(<expr><name>gHTCApiNavOpen</name> != <name>nsnull</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>gHTCApiNavOpen</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>1</expr></argument> <comment type="block">/* undocumented value */</comment>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>gHTCApiNavSetMode</name> != <name>nsnull</name></expr>)</condition><then>
          <expr_stmt><expr><call><name>gHTCApiNavSetMode</name> <argument_list>( <argument><expr><name>mWnd</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <comment type="line">// 4 is Gesture Mode. This will generate WM_HTCNAV events to the window</comment>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
      
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_MOUSEACTIVATE</name></expr>:
      <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_popup</name></expr>)</condition><then> <block>{
        <comment type="line">// a popup with a parent owner should not be activated when clicked</comment>
        <comment type="line">// but should still allow the mouse event to be fired, so the return</comment>
        <comment type="line">// value is set to MA_NOACTIVATE. But if the owner isn't the frontmost</comment>
        <comment type="line">// window, just use default processing so that the window is activated.</comment>
        <decl_stmt><decl><type><name>HWND</name></type> <name>owner</name> <init>= <expr><call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>GW_OWNER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>owner</name> &amp;&amp; <name>owner</name> == <call><name>::<name>GetForegroundWindow</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr>*<name>aRetValue</name> = <name>MA_NOACTIVATE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <break>break;</break>

    </case><case>case <expr><name>WM_WINDOWPOSCHANGING</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>LPWINDOWPOS</name></type> <name>info</name> <init>= <expr>(<name>LPWINDOWPOS</name>) <name>lParam</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>OnWindowPosChanging</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>WM_SETFOCUS</name></expr>:
      <if>if <condition>(<expr><name>sJustGotActivate</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = <call><name>DispatchFocusToTopLevelWindow</name><argument_list>(<argument><expr><name>NS_ACTIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
      <if>if <condition>(<expr><name><name>nsWindow</name>::<name>sIsAccessibilityOn</name></name></expr>)</condition><then> <block>{
        <comment type="line">// Create it for the first time so that it can start firing events</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAccessible</name></expr></argument>&gt;</argument_list></name></type> <name>rootAccessible</name> <init>= <expr><call><name>GetRootAccessible</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_HAVE_SOFTKB</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <block>{
        <comment type="line">// On Windows CE, we have a window that overlaps</comment>
        <comment type="line">// the ISP button.  In this case, we should always</comment>
        <comment type="line">// try to hide it when we are activated</comment>
      
        <function_decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><parameter_list>(<param><decl><type><name>mWnd</name></type></decl></param>)</parameter_list>;</function_decl>
        <comment type="line">// Open the IME </comment>
        <expr_stmt><expr><call><name>ImmSetOpenStatus</name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>

    </case><case>case <expr><name>WM_KILLFOCUS</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_HAVE_SOFTKB</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <block>{
        <function_decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><parameter_list>(<param><decl><type><name>mWnd</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name>ImmSetOpenStatus</name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr><name>sJustGotDeactivate</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = <call><name>DispatchFocusToTopLevelWindow</name><argument_list>(<argument><expr><name>NS_DEACTIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>

    </case><case>case <expr><name>WM_WINDOWPOSCHANGED</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>WINDOWPOS</name> *</type><name>wp</name> <init>= <expr>(<name>LPWINDOWPOS</name>)<name>lParam</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>OnWindowPosChanged</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_SETTINGCHANGE</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name> <argument_list>(<argument><expr><name>WINCE_WINDOWS_MOBILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><name>getWheelInfo</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <switch>switch <condition>(<expr><name>wParam</name></expr>)</condition> <block>{
        <case>case <expr><name>SPI_SETSIPINFO</name></expr>:
        </case><case>case <expr><name>SPI_SETCURRENTIM</name></expr>:
          <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>OnSoftKbSettingsChange</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>SETTINGCHANGE_RESET</name></expr>:
          <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
            <comment type="line">// The OS sees to get confused and think that the invisable window</comment>
            <comment type="line">// is in the foreground after an orientation change. By actually</comment>
            <comment type="line">// setting it to the foreground and hiding it, we set it strait.</comment>
            <comment type="line">// See bug 514007 for details.</comment>
            <expr_stmt><expr><call><name>SetForegroundWindow</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ShowWindow</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_HIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if> 
          <break>break;</break>
      </case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>OnSettingsChange</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_INPUTLANGCHANGEREQUEST</name></expr>:
      <expr_stmt><expr>*<name>aRetValue</name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>WM_INPUTLANGCHANGE</name></expr>:
      <expr_stmt><expr><name>result</name> = <call><name>OnInputLangChange</name><argument_list>(<argument><expr>(<name>HKL</name>)<name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WINCE</comment>

    </case><case>case <expr><name>WM_DESTROYCLIPBOARD</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>nsIClipboard</name>*</type> <name>clipboard</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CallGetService</name><argument_list>(<argument><expr><name>kCClipboardCID</name></expr></argument>, <argument><expr>&amp;<name>clipboard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>clipboard</name>-&gt;<name>EmptyClipboard</name></name><argument_list>(<argument><expr><name><name>nsIClipboard</name>::<name>kGlobalClipboard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>clipboard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
    </case><case>case <expr><name>WM_GETOBJECT</name></expr>:
    <block>{
      <expr_stmt><expr>*<name>aRetValue</name> = 0</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>lParam</name> == <name>OBJID_CLIENT</name></expr>)</condition><then> <block>{ <comment type="line">// oleacc.dll will be loaded dynamically</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAccessible</name></expr></argument>&gt;</argument_list></name></type> <name>rootAccessible</name> <init>= <expr><call><name>GetRootAccessible</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Held by a11y cache</comment>
        <if>if <condition>(<expr><name>rootAccessible</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>IAccessible</name> *</type><name>msaaAccessible</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>rootAccessible</name>-&gt;<name>GetNativeInterface</name></name><argument_list>(<argument><expr>(<name>void</name>**)&amp;<name>msaaAccessible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// does an addref</comment>
          <if>if <condition>(<expr><name>msaaAccessible</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>aRetValue</name> = <call><name>LresultFromObject</name><argument_list>(<argument><expr><name>IID_IAccessible</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>msaaAccessible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// does an addref</comment>
            <expr_stmt><expr><call><name><name>msaaAccessible</name>-&gt;<name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// release extra addref</comment>
            <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>  <comment type="line">// We handled the WM_GETOBJECT message</comment>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>WM_SYSCOMMAND</name></expr>:
      <comment type="line">// prevent Windows from trimming the working set. bug 76831</comment>
      <if>if <condition>(<expr>!<name>sTrimOnMinimize</name> &amp;&amp; <name>wParam</name> == <name>SC_MINIMIZE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>ShowWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>SW_SHOWMINIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
  </case><case>case <expr><name>WM_HIBERNATE</name></expr>:        
    <expr_stmt><expr><call><name><name>nsMemory</name>::<name>HeapMinimize</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  </case><case>case <expr><name>WM_MOUSEWHEEL</name></expr>:
  </case><case>case <expr><name>WM_MOUSEHWHEEL</name></expr>:
    <block>{
      <comment type="line">// If OnMouseWheel returns true, the event was forwarded directly to another</comment>
      <comment type="line">// mozilla window message handler (ProcessMessage). In this case the return</comment>
      <comment type="line">// value of the forwarded event is in 'result' which we should return immediately.</comment>
      <comment type="line">// If OnMouseWheel returns false, OnMouseWheel processed the event internally.</comment>
      <comment type="line">// 'result' and 'aRetValue' will be set based on what we did with the event, so</comment>
      <comment type="line">// we should fall through.</comment>
      <if>if <condition>(<expr><call><name>OnMouseWheel</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>getWheelInfo</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>result</name></expr>;</return></then></if>
    }</block>
    <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_LONGHORN</name></expr></cpp:if>
  </case><case>case <expr><name>WM_DWMCOMPOSITIONCHANGED</name></expr>:
    <expr_stmt><expr><call><name>BroadcastMsg</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_DWMCOMPOSITIONCHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_THEMECHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UpdateGlass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Gesture support events */</comment>
  </case><case>case <expr><name>WM_TABLET_QUERYSYSTEMGESTURESTATUS</name></expr>:
    <comment type="line">// According to MS samples, this must be handled to enable</comment>
    <comment type="line">// rotational support in multi-touch drivers.</comment>
    <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aRetValue</name> = <name>TABLET_ROTATE_GESTURE_ENABLE</name></expr>;</expr_stmt>
    <break>break;</break>
    
  </case><case>case <expr><name>WM_GESTURE</name></expr>:
    <expr_stmt><expr><name>result</name> = <call><name>OnGesture</name><argument_list>(<argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

  </case><case>case <expr><name>WM_GESTURENOTIFY</name></expr>:
    <block>{
      <if>if <condition>(<expr><name>mWindowType</name> != <name>eWindowType_invisible</name> &amp;&amp;
          <name>mWindowType</name> != <name>eWindowType_plugin</name> &amp;&amp;
          <name>mWindowType</name> != <name>eWindowType_toplevel</name></expr>)</condition><then> <block>{
        <comment type="line">// eWindowType_toplevel is the top level main frame window. Gesture support</comment>
        <comment type="line">// there prevents the user from interacting with the title bar or nc</comment>
        <comment type="line">// areas using a single finger. Java and plugin windows can make their</comment>
        <comment type="line">// own calls.</comment>
        <decl_stmt><decl><type><name>GESTURENOTIFYSTRUCT</name> *</type> <name>gestureinfo</name> <init>= <expr>(<name>GESTURENOTIFYSTRUCT</name>*)<name>lParam</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsPointWin</name></type> <name>touchPoint</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>touchPoint</name> = <name><name>gestureinfo</name>-&gt;<name>ptsLocation</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>touchPoint</name>.<name>ScreenToClient</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <function_decl><type><name>nsGestureNotifyEvent</name></type> <name>gestureNotifyEvent</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_GESTURENOTIFY_EVENT_START</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><name><name>gestureNotifyEvent</name>.<name>refPoint</name></name> = <name>touchPoint</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsEventStatus</name></type> <name>status</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>DispatchEvent</name><argument_list>(<argument><expr>&amp;<name>gestureNotifyEvent</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mDisplayPanFeedback</name> = <name><name>gestureNotifyEvent</name>.<name>displayPanFeedback</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mGesture</name>.<name>SetWinGestureSupport</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name><name>gestureNotifyEvent</name>.<name>panDirection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>result</name> = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">//should always bubble to DefWindowProc</comment>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

    </case><case>case <expr><name>WM_CLEAR</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_DELETE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_CUT</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_CUT</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_COPY</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_COPY</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>WM_PASTE</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_PASTE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    </case><case>case <expr><name>EM_UNDO</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_UNDO</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aRetValue</name> = <call>(<name>LRESULT</name>)<argument_list>(<argument><expr><name><name>command</name>.<name>mSucceeded</name></name> &amp;&amp; <name><name>command</name>.<name>mIsEnabled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>EM_REDO</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_REDO</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aRetValue</name> = <call>(<name>LRESULT</name>)<argument_list>(<argument><expr><name><name>command</name>.<name>mSucceeded</name></name> &amp;&amp; <name><name>command</name>.<name>mIsEnabled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>EM_CANPASTE</name></expr>:
    <block>{
      <comment type="line">// Support EM_CANPASTE message only when wParam isn't specified or</comment>
      <comment type="line">// is plain text format.</comment>
      <if>if <condition>(<expr><name>wParam</name> == 0 || <name>wParam</name> == <name>CF_TEXT</name> || <name>wParam</name> == <name>CF_UNICODETEXT</name></expr>)</condition><then> <block>{
        <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_PASTE</name></type></decl></param>,
                                      <param><decl><type><name>this</name></type></decl></param>, <param><decl><type><name>PR_TRUE</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>aRetValue</name> = <call>(<name>LRESULT</name>)<argument_list>(<argument><expr><name><name>command</name>.<name>mSucceeded</name></name> &amp;&amp; <name><name>command</name>.<name>mIsEnabled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>EM_CANUNDO</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_UNDO</name></type></decl></param>,
                                    <param><decl><type><name>this</name></type></decl></param>, <param><decl><type><name>PR_TRUE</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aRetValue</name> = <call>(<name>LRESULT</name>)<argument_list>(<argument><expr><name><name>command</name>.<name>mSucceeded</name></name> &amp;&amp; <name><name>command</name>.<name>mIsEnabled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>EM_CANREDO</name></expr>:
    <block>{
      <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_REDO</name></type></decl></param>,
                                    <param><decl><type><name>this</name></type></decl></param>, <param><decl><type><name>PR_TRUE</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aRetValue</name> = <call>(<name>LRESULT</name>)<argument_list>(<argument><expr><name><name>command</name>.<name>mSucceeded</name></name> &amp;&amp; <name><name>command</name>.<name>mIsEnabled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
   <comment type="line">//HTC NAVIGATION WHEEL EVENT</comment>
   </case><case>case <expr><name>WM_HTCNAV</name></expr>:
   <block>{
     <decl_stmt><decl><type><name>int</name></type> <name>distance</name> <init>= <expr><name>wParam</name> &amp; 0x000000FF</expr></init></decl>;</decl_stmt>
     <if>if <condition>( <expr>(<name>wParam</name> &amp; 0x000000100) != 0</expr>)</condition><then> <comment type="line">// Counter Clockwise</comment>
       <expr_stmt><expr><name>distance</name> *= -1</expr>;</expr_stmt></then></if>
     <if>if <condition>(<expr><call><name>OnMouseWheel</name><argument_list>(<argument><expr><name>WM_MOUSEWHEEL</name></expr></argument>, <argument><expr><call><name>MAKEWPARAM</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>distance</name></expr></argument>)</argument_list></call></expr></argument>, 
                      <argument><expr><call><name>MAKELPARAM</name><argument_list>(<argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CXSCREEN</name></expr></argument>)</argument_list></call> / 2</expr></argument>, 
                                 <argument><expr><call><name>GetSystemMetrics</name><argument_list>(<argument><expr><name>SM_CYSCREEN</name></expr></argument>)</argument_list></call> / 2</expr></argument>)</argument_list></call></expr></argument>, 
                      <argument><expr><name>getWheelInfo</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>result</name></expr>;</return></then></if>
   }</block>
   <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><default>default:
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
      <if>if <condition>(<expr><name>msg</name> == <name>WM_USER_TSF_TEXTCHANGE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>OnTextChangeMsg</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEAP_DUMP_EVENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <if>if <condition>(<expr><name>msg</name> == <call><name>GetHeapMsg</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>HeapDump</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MOZ_WINSDK_TARGETVER</name> &gt;= <name>MOZ_NTDDI_WIN7</name></expr></cpp:if>
      <if>if <condition>(<expr><name>msg</name> == <call><name><name>nsAppShell</name>::<name>GetTaskbarButtonCreatedMessage</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetHasTaskbarIconBeenCreated</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
      <if>if <condition>(<expr><name>msg</name> == <name>sOOPPPluginFocusEvent</name></expr>)</condition><then> <block>{
        <comment type="line">// With OOPP, the plugin window exists in another process and is a child of</comment>
        <comment type="line">// this window. This window is a placeholder plugin window for the dom. We</comment>
        <comment type="line">// receive this event when the child window receives focus. (sent from</comment>
        <comment type="line">// PluginInstanceParent.cpp)</comment>
        <expr_stmt><expr><call><name>::<name>SendMessage</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_MOUSEACTIVATE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// See nsPluginNativeWindowWin.cpp</comment>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
  </default>}</block></switch>

  <comment type="line">//*aRetValue = result;</comment>
  <if>if <condition>(<expr><name>mWnd</name></expr>)</condition><then> <block>{
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then>
  <else>else <block>{
    <comment type="line">//Events which caused mWnd destruction and aren't consumed</comment>
    <comment type="line">//will crash during the Windows default processing.</comment>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Broadcast messaging
 *
 * Broadcast messages to all windows.
 *
 **************************************************************/</comment>

<comment type="line">// Enumerate all child windows sending aMsg to each of them</comment>
<function><type><name>BOOL</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>BroadcastMsgToChildren</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>WNDPROC</name></type> <name>winProc</name> <init>= <expr>(<name>WNDPROC</name>)<call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>winProc</name> == &amp;<name><name>nsWindow</name>::<name>WindowProc</name></name></expr>)</condition><then> <block>{
    <comment type="line">// it's one of our windows so go ahead and send a message to it</comment>
    <expr_stmt><expr><call><name>::<name>CallWindowProcW</name></name><argument_list>(<argument><expr><name>winProc</name></expr></argument>, <argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>aMsg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Enumerate all top level windows specifying that the children of each</comment>
<comment type="line">// top level window should be enumerated. Do *not* send the message to</comment>
<comment type="line">// each top level window since it is assumed that the toolkit will send</comment>
<comment type="line">// aMsg to them directly.</comment>
<function><type><name>BOOL</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>BroadcastMsg</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aTopWindow</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Iterate each of aTopWindows child windows sending the aMsg</comment>
  <comment type="line">// to each of them.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>::<name>EnumChildWindows</name></name><argument_list>(<argument><expr><name>aTopWindow</name></expr></argument>, <argument><expr><name><name>nsWindow</name>::<name>BroadcastMsgToChildren</name></name></expr></argument>, <argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>EnumChildWindows</name></name><argument_list>(<argument><expr><name>aTopWindow</name></expr></argument>, <argument><expr><name><name>nsWindow</name>::<name>BroadcastMsgToChildren</name></name></expr></argument>, <argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// This method is called from nsToolkit::WindowProc to forward global</comment>
<comment type="line">// messages which need to be dispatched to all child windows.</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>GlobalMsgWindowProc</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>msg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>msg</name></expr>)</condition> <block>{
    <case>case <expr><name>WM_SYSCOLORCHANGE</name></expr>:
      <comment type="line">// Code to dispatch WM_SYSCOLORCHANGE message to all child windows.</comment>
      <comment type="line">// WM_SYSCOLORCHANGE is only sent to top-level windows, but the</comment>
      <comment type="line">// cross platform API requires that NS_SYSCOLORCHANGE message be sent to</comment>
      <comment type="line">// all child windows as well. When running in an embedded application</comment>
      <comment type="line">// we may not receive a WM_SYSCOLORCHANGE message because the top</comment>
      <comment type="line">// level window is owned by the embeddor.</comment>
      <comment type="line">// System color changes are posted to top-level windows only.</comment>
      <comment type="line">// The NS_SYSCOLORCHANGE must be dispatched to all child</comment>
      <comment type="line">// windows as well.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
     <expr_stmt><expr><call><name>::<name>EnumThreadWindows</name></name><argument_list>(<argument><expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>nsWindow</name>::<name>BroadcastMsg</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  </case>}</block></switch>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: Event processing helpers
 *
 * Special processing for certain event types and 
 * synthesized events.
 *
 **************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>PostSleepWakeNotification</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aNotification</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIObserverService</name></expr></argument>&gt;</argument_list></name></type> <name>observerService</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/observer-service;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>observerService</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>observerService</name>-&gt;<name>NotifyObservers</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aNotification</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>LRESULT</name></type> <name><name>nsWindow</name>::<name>ProcessCharMessage</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MSG</name> &amp;</type><name>aMsg</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aEventDispatched</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name><name>aMsg</name>.<name>message</name></name> == <name>WM_CHAR</name> || <name><name>aMsg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name></expr></argument>,
                  <argument><expr>"message is not keydown event"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gWindowsLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
         <argument><expr>("%s charCode=%d scanCode=%d\n",
         <name><name>aMsg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name> ? "WM_SYSCHAR" : "WM_CHAR",
         <name><name>aMsg</name>.<name>wParam</name></name>, <call><name>HIWORD</name><argument_list>(<argument><expr><name><name>aMsg</name>.<name>lParam</name></name></expr></argument>)</argument_list></call> &amp; 0xFF)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// These must be checked here too as a lone WM_CHAR could be received</comment>
  <comment type="line">// if a child window didn't handle it (for example Alt+Space in a content window)</comment>
  <decl_stmt><decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name></decl>;</decl_stmt>
  <return>return <expr><call><name>OnChar</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>, <argument><expr><name>aEventDispatched</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LRESULT</name></type> <name><name>nsWindow</name>::<name>ProcessKeyUpMessage</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MSG</name> &amp;</type><name>aMsg</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aEventDispatched</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name><name>aMsg</name>.<name>message</name></name> == <name>WM_KEYUP</name> || <name><name>aMsg</name>.<name>message</name></name> == <name>WM_SYSKEYUP</name></expr></argument>,
                  <argument><expr>"message is not keydown event"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gWindowsLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
         <argument><expr>("%s VK=%d\n", <name><name>aMsg</name>.<name>message</name></name> == <name>WM_SYSKEYDOWN</name> ?
                          "WM_SYSKEYUP" : "WM_KEYUP", <name><name>aMsg</name>.<name>wParam</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name></decl>;</decl_stmt>

  <comment type="line">// Note: the original code passed (HIWORD(lParam)) to OnKeyUp as</comment>
  <comment type="line">// scan code. However, this breaks Alt+Num pad input.</comment>
  <comment type="line">// MSDN states the following:</comment>
  <comment type="line">//  Typically, ToAscii performs the translation based on the</comment>
  <comment type="line">//  virtual-key code. In some cases, however, bit 15 of the</comment>
  <comment type="line">//  uScanCode parameter may be used to distinguish between a key</comment>
  <comment type="line">//  press and a key release. The scan code is used for</comment>
  <comment type="line">//  translating ALT+number key combinations.</comment>

  <comment type="line">// ignore [shift+]alt+space so the OS can handle it</comment>
  <if>if <condition>(<expr><name><name>modKeyState</name>.<name>mIsAltDown</name></name> &amp;&amp; !<name><name>modKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp;
      <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SPACE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> &amp;&amp;
      (<name><name>aMsg</name>.<name>message</name></name> != <name>WM_KEYUP</name> || <name><name>aMsg</name>.<name>message</name></name> != <name>VK_MENU</name>)</expr>)</condition><then> <block>{
    <comment type="line">// Ignore VK_MENU if it's not a system key release, so that the menu bar does not trigger</comment>
    <comment type="line">// This helps avoid triggering the menu bar for ALT key accelerators used in</comment>
    <comment type="line">// assistive technologies such as Window-Eyes and ZoomText, and when using Alt+Tab</comment>
    <comment type="line">// to switch back to Mozilla in Windows 95 and Windows 98</comment>
    <return>return <expr><call><name>OnKeyUp</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>, <argument><expr><name>aEventDispatched</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>LRESULT</name></type> <name><name>nsWindow</name>::<name>ProcessKeyDownMessage</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MSG</name> &amp;</type><name>aMsg</name></decl></param>,
                                        <param><decl><type><name>PRBool</name> *</type><name>aEventDispatched</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gWindowsLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
         <argument><expr>("%s VK=%d\n", <name><name>aMsg</name>.<name>message</name></name> == <name>WM_SYSKEYDOWN</name> ?
                          "WM_SYSKEYDOWN" : "WM_KEYDOWN", <name><name>aMsg</name>.<name>wParam</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name><name>aMsg</name>.<name>message</name></name> == <name>WM_KEYDOWN</name> || <name><name>aMsg</name>.<name>message</name></name> == <name>WM_SYSKEYDOWN</name></expr></argument>,
                  <argument><expr>"message is not keydown event"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name></decl>;</decl_stmt>

  <comment type="line">// Note: the original code passed (HIWORD(lParam)) to OnKeyDown as</comment>
  <comment type="line">// scan code. However, this breaks Alt+Num pad input.</comment>
  <comment type="line">// MSDN states the following:</comment>
  <comment type="line">//  Typically, ToAscii performs the translation based on the</comment>
  <comment type="line">//  virtual-key code. In some cases, however, bit 15 of the</comment>
  <comment type="line">//  uScanCode parameter may be used to distinguish between a key</comment>
  <comment type="line">//  press and a key release. The scan code is used for</comment>
  <comment type="line">//  translating ALT+number key combinations.</comment>

  <comment type="line">// ignore [shift+]alt+space so the OS can handle it</comment>
  <if>if <condition>(<expr><name><name>modKeyState</name>.<name>mIsAltDown</name></name> &amp;&amp; !<name><name>modKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp;
      <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SPACE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>LRESULT</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>modKeyState</name>.<name>mIsAltDown</name></name> &amp;&amp; <call><name><name>nsIMM32Handler</name>::<name>IsStatusChanged</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsIMM32Handler</name>::<name>NotifyEndStatusChange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr>!<call><name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name>OnKeyDown</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>, <argument><expr><name>aEventDispatched</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <if>if <condition>(<expr><name><name>aMsg</name>.<name>wParam</name></name> == <name>VK_MENU</name> ||
      (<name><name>aMsg</name>.<name>wParam</name></name> == <name>VK_F10</name> &amp;&amp; !<name><name>modKeyState</name>.<name>mIsShiftDown</name></name>)</expr>)</condition><then> <block>{
    <comment type="line">// We need to let Windows handle this keypress,</comment>
    <comment type="line">// by returning PR_FALSE, if there's a native menu</comment>
    <comment type="line">// bar somewhere in our containing window hierarchy.</comment>
    <comment type="line">// Otherwise we handle the keypress and don't pass</comment>
    <comment type="line">// it on to Windows, by returning PR_TRUE.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>hasNativeMenu</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HWND</name></type> <name>hWnd</name> <init>= <expr><name>mWnd</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>hWnd</name></expr>)</condition> <block>{
      <if>if <condition>(<expr><call><name>::<name>GetMenu</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>hasNativeMenu</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><name>hWnd</name> = <call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>result</name> = !<name>hasNativeMenu</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsWindow</name>::<name>SynthesizeNativeKeyEvent</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNativeKeyboardLayout</name></decl></param>,
                                   <param><decl><type><name>PRInt32</name></type> <name>aNativeKeyCode</name></decl></param>,
                                   <param><decl><type><name>PRUint32</name></type> <name>aModifierFlags</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aCharacters</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aUnmodifiedCharacters</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>  <comment type="line">//Win CE doesn't support many of the calls used in this method, perhaps theres another way</comment>
  <decl_stmt><decl><type><name>nsPrintfCString</name></type> <name>layoutName</name><argument_list>(<argument><expr>"%08x"</expr></argument>, <argument><expr><name>aNativeKeyboardLayout</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HKL</name></type> <name>loadedLayout</name> <init>= <expr><call><name>LoadKeyboardLayoutA</name><argument_list>(<argument><expr><call><name><name>layoutName</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>KLF_NOTELLSHELL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>loadedLayout</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

  <comment type="line">// Setup clean key state and load desired layout</comment>
  <decl_stmt><decl><type><name>BYTE</name></type> <name><name>originalKbdState</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetKeyboardState</name></name><argument_list>(<argument><expr><name>originalKbdState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>BYTE</name></type> <name><name>kbdState</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>kbdState</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>kbdState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// This changes the state of the keyboard for the current thread only,</comment>
  <comment type="line">// and we'll restore it soon, so this should be OK.</comment>
  <expr_stmt><expr><call><name>::<name>SetKeyboardState</name></name><argument_list>(<argument><expr><name>kbdState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>HKL</name></type> <name>oldLayout</name> <init>= <expr><call><name><name>gKbdLayout</name>.<name>GetLayout</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>gKbdLayout</name>.<name>LoadLayout</name></name><argument_list>(<argument><expr><name>loadedLayout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>KeyPair</name></expr></argument>,<argument><expr>10</expr></argument>&gt;</argument_list></name></type> <name>keySequence</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetupKeyModifiersSequence</name><argument_list>(<argument><expr>&amp;<name>keySequence</name></expr></argument>, <argument><expr><name>aModifierFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aNativeKeyCode</name> &gt;= 0 &amp;&amp; <name>aNativeKeyCode</name> &lt; 256</expr></argument>,
               <argument><expr>"Native VK key code out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>keySequence</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><call><name>KeyPair</name><argument_list>(<argument><expr><name>aNativeKeyCode</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Simulate the pressing of each modifier key and then the real key</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>keySequence</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>key</name> <init>= <expr><name><name>keySequence</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mGeneral</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>keySpecific</name> <init>= <expr><name><name>keySequence</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mSpecific</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>kbdState</name><index>[<expr><name>key</name></expr>]</index></name> = 0x81</expr>;</expr_stmt> <comment type="line">// key is down and toggled on if appropriate</comment>
    <if>if <condition>(<expr><name>keySpecific</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>kbdState</name><index>[<expr><name>keySpecific</name></expr>]</index></name> = 0x81</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>::<name>SetKeyboardState</name></name><argument_list>(<argument><expr><name>kbdState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSG</name></type> <name>msg</name> <init>= <expr><call><name>InitMSG</name><argument_list>(<argument><expr><name>WM_KEYDOWN</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>i</name> == <call><name><name>keySequence</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1 &amp;&amp; <call><name><name>aCharacters</name>.<name>Length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>UINT</name></type> <name>scanCode</name> <init>= <expr><call><name>::<name>MapVirtualKeyEx</name></name><argument_list>(<argument><expr><name>aNativeKeyCode</name></expr></argument>, <argument><expr><name>MAPVK_VK_TO_VSC</name></expr></argument>,
                                        <argument><expr><call><name><name>gKbdLayout</name>.<name>GetLayout</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsFakeCharMessage</name></type> <name>fakeMsg</name> <init>= <expr><block>{ <expr><call><name><name>aCharacters</name>.<name>CharAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><name>scanCode</name></expr> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>OnKeyDown</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>&amp;<name>fakeMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>OnKeyDown</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr><call><name><name>keySequence</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>key</name> <init>= <expr><name><name>keySequence</name><index>[<expr><name>i</name> - 1</expr>]</index></name>.<name>mGeneral</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>keySpecific</name> <init>= <expr><name><name>keySequence</name><index>[<expr><name>i</name> - 1</expr>]</index></name>.<name>mSpecific</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>kbdState</name><index>[<expr><name>key</name></expr>]</index></name> = 0</expr>;</expr_stmt> <comment type="line">// key is up and toggled off if appropriate</comment>
    <if>if <condition>(<expr><name>keySpecific</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>kbdState</name><index>[<expr><name>keySpecific</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>::<name>SetKeyboardState</name></name><argument_list>(<argument><expr><name>kbdState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSG</name></type> <name>msg</name> <init>= <expr><call><name>InitMSG</name><argument_list>(<argument><expr><name>WM_KEYUP</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OnKeyUp</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// Restore old key state and layout</comment>
  <expr_stmt><expr><call><name>::<name>SetKeyboardState</name></name><argument_list>(<argument><expr><name>originalKbdState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>gKbdLayout</name>.<name>LoadLayout</name></name><argument_list>(<argument><expr><name>oldLayout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>UnloadKeyboardLayout</name><argument_list>(<argument><expr><name>loadedLayout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="line">//XXX: is there another way to do this?</comment>
  <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsWindow</name>::<name>SynthesizeNativeMouseEvent</name></name><parameter_list>(<param><decl><type><name>nsIntPoint</name></type> <name>aPoint</name></decl></param>,
                                     <param><decl><type><name>PRUint32</name></type> <name>aNativeMessage</name></decl></param>,
                                     <param><decl><type><name>PRUint32</name></type> <name>aModifierFlags</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef> <comment type="line">// I don't think WINCE supports SendInput</comment>
  <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetCursorPos</name></name><argument_list>(<argument><expr><name><name>r</name>.<name>left</name></name> + <name><name>aPoint</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>top</name></name> + <name><name>aPoint</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>INPUT</name></type> <name>input</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>input</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>input</name>.<name>type</name></name> = <name>INPUT_MOUSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>input</name>.<name>mi</name>.<name>dwFlags</name></name> = <name>aNativeMessage</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SendInput</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>&amp;<name>input</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>INPUT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 *
 * SECTION: OnXXX message handlers
 *
 * For message handlers that need to be broken out or
 * implemented in specific platform code.
 *
 **************************************************************/</comment>

<function><type><name>BOOL</name></type> <name><name>nsWindow</name>::<name>OnInputLangChange</name></name><parameter_list>(<param><decl><type><name>HKL</name></type> <name>aHKL</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>KE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"OnInputLanguageChange\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <expr_stmt><expr><call><name><name>gKbdLayout</name>.<name>LoadLayout</name></name><argument_list>(<argument><expr><name>aHKL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>   <comment type="line">// always pass to child window</comment>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="line">// implemented in nsWindowCE.cpp</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>OnWindowPosChanged</name></name><parameter_list>(<param><decl><type><name>WINDOWPOS</name> *</type><name>wp</name></decl></param>, <param><decl><type><name>PRBool</name>&amp;</type> <name>result</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>wp</name> == <name>nsnull</name></expr>)</condition><then>
    <return>return;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINSTATE_DEBUG_OUTPUT</name></cpp:ifdef>
  <if>if <condition>(<expr><name>mWnd</name> == <call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** OnWindowPosChanged: [  top] "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** OnWindowPosChanged: [child] "</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"WINDOWPOS flags:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>wp</name>-&gt;<name>flags</name></name> &amp; <name>SWP_FRAMECHANGED</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SWP_FRAMECHANGED "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>wp</name>-&gt;<name>flags</name></name> &amp; <name>SWP_SHOWWINDOW</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SWP_SHOWWINDOW "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>wp</name>-&gt;<name>flags</name></name> &amp; <name>SWP_NOSIZE</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SWP_NOSIZE "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>wp</name>-&gt;<name>flags</name></name> &amp; <name>SWP_HIDEWINDOW</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SWP_HIDEWINDOW "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Handle window size mode changes</comment>
  <if>if <condition>(<expr><name><name>wp</name>-&gt;<name>flags</name></name> &amp; <name>SWP_FRAMECHANGED</name></expr>)</condition><then> <block>{
    <function_decl><type><name>nsSizeModeEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_SIZEMODE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>WINDOWPLACEMENT</name></type> <name>pl</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pl</name>.<name>length</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>GetWindowPlacement</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>pl</name>.<name>showCmd</name></name> == <name>SW_SHOWMAXIMIZED</name></expr>)</condition><then>
      <expr_stmt><expr><name><name>event</name>.<name>mSizeMode</name></name> = <name>nsSizeMode_Maximized</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name><name>pl</name>.<name>showCmd</name></name> == <name>SW_SHOWMINIMIZED</name></expr>)</condition><then>
      <expr_stmt><expr><name><name>event</name>.<name>mSizeMode</name></name> = <name>nsSizeMode_Minimized</name></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name><name>event</name>.<name>mSizeMode</name></name> = <name>nsSizeMode_Normal</name></expr>;</expr_stmt></else></if></else></if>

    <comment type="line">// Windows has just changed the size mode of this window. The following</comment>
    <comment type="line">// NS_SIZEMODE event will trigger a call into SetSizeMode where we will</comment>
    <comment type="line">// set the min/max window state again or for nsSizeMode_Normal, call</comment>
    <comment type="line">// SetWindow with a parameter of SW_RESTORE. There's no need however as</comment>
    <comment type="line">// this window's mode has already changed. Updating mSizeMode here</comment>
    <comment type="line">// insures the SetSizeMode call is a no-op. Addresses a bug on Win7 related</comment>
    <comment type="line">// to window docking. (bug 489258)</comment>
    <expr_stmt><expr><name>mSizeMode</name> = <name><name>event</name>.<name>mSizeMode</name></name></expr>;</expr_stmt>

    <comment type="line">// If !sTrimOnMinimize, we minimize windows using SW_SHOWMINIMIZED (See</comment>
    <comment type="line">// SetSizeMode for internal calls, and WM_SYSCOMMAND for external). This</comment>
    <comment type="line">// prevents the working set from being trimmed but keeps the window active.</comment>
    <comment type="line">// After the window is minimized, we need to do some touch up work on the</comment>
    <comment type="line">// active window. (bugs 76831 &amp; 499816)</comment>
    <if>if <condition>(<expr>!<name>sTrimOnMinimize</name> &amp;&amp; <name>nsSizeMode_Minimized</name> == <name><name>event</name>.<name>mSizeMode</name></name></expr>)</condition><then>
      <expr_stmt><expr><call><name>ActivateOtherWindowHelper</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINSTATE_DEBUG_OUTPUT</name></cpp:ifdef>
    <switch>switch <condition>(<expr><name>mSizeMode</name></expr>)</condition> <block>{
      <case>case <expr><name>nsSizeMode_Normal</name></expr>:
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** mSizeMode: nsSizeMode_Normal\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>nsSizeMode_Minimized</name></expr>:
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** mSizeMode: nsSizeMode_Minimized\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>nsSizeMode_Maximized</name></expr>:
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** mSizeMode: nsSizeMode_Maximized\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** mSizeMode: ??????\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> = <call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Skip window size change events below on minimization.</comment>
    <if>if <condition>(<expr><name>mSizeMode</name> == <name>nsSizeMode_Minimized</name></expr>)</condition><then>
      <return>return;</return></then></if>
  }</block></then></if>

  <comment type="line">// Handle window size changes</comment>
  <if>if <condition>(<expr>0 == (<name><name>wp</name>-&gt;<name>flags</name></name> &amp; <name>SWP_NOSIZE</name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>newWidth</name></decl>, <decl><type ref="prev"/><name>newHeight</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>newWidth</name>  = <name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newHeight</name> = <name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>
    <function_decl><type><name>nsIntRect</name></type> <name>rect</name><parameter_list>(<param><decl><type><name><name>wp</name>-&gt;<name>x</name></name></type></decl></param>, <param><decl><type><name><name>wp</name>-&gt;<name>y</name></name></type></decl></param>, <param><decl><type><name>newWidth</name></type></decl></param>, <param><decl><type><name>newHeight</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
    <if>if <condition>(<expr><name>eTransparencyTransparent</name> == <name>mTransparencyMode</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>ResizeTranslucentWindow</name><argument_list>(<argument><expr><name>newWidth</name></expr></argument>, <argument><expr><name>newHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>newWidth</name> &gt; <name><name>mLastSize</name>.<name>width</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>RECT</name></type> <name>drect</name></decl>;</decl_stmt>

      <comment type="line">// getting wider</comment>
      <expr_stmt><expr><name><name>drect</name>.<name>left</name></name>   = <name><name>wp</name>-&gt;<name>x</name></name> + <name><name>mLastSize</name>.<name>width</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>drect</name>.<name>top</name></name>    = <name><name>wp</name>-&gt;<name>y</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>drect</name>.<name>right</name></name>  = <name><name>drect</name>.<name>left</name></name> + (<name>newWidth</name> - <name><name>mLastSize</name>.<name>width</name></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>drect</name>.<name>bottom</name></name> = <name><name>drect</name>.<name>top</name></name> + <name>newHeight</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>::<name>RedrawWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>drect</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><name>RDW_INVALIDATE</name> |
                     <name>RDW_NOERASE</name> |
                     <name>RDW_NOINTERNALPAINT</name> |
                     <name>RDW_ERASENOW</name> |
                     <name>RDW_ALLCHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>newHeight</name> &gt; <name><name>mLastSize</name>.<name>height</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>RECT</name></type> <name>drect</name></decl>;</decl_stmt>

      <comment type="line">// getting taller</comment>
      <expr_stmt><expr><name><name>drect</name>.<name>left</name></name>   = <name><name>wp</name>-&gt;<name>x</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>drect</name>.<name>top</name></name>    = <name><name>wp</name>-&gt;<name>y</name></name> + <name><name>mLastSize</name>.<name>height</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>drect</name>.<name>right</name></name>  = <name><name>drect</name>.<name>left</name></name> + <name>newWidth</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>drect</name>.<name>bottom</name></name> = <name><name>drect</name>.<name>top</name></name> + (<name>newHeight</name> - <name><name>mLastSize</name>.<name>height</name></name>)</expr>;</expr_stmt>

      <expr_stmt><expr><call><name>::<name>RedrawWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>drect</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><name>RDW_INVALIDATE</name> |
                     <name>RDW_NOERASE</name> |
                     <name>RDW_NOINTERNALPAINT</name> |
                     <name>RDW_ERASENOW</name> |
                     <name>RDW_ALLCHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>mBounds</name>.<name>width</name></name>    = <name>newWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mBounds</name>.<name>height</name></name>   = <name>newHeight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mLastSize</name>.<name>width</name></name>  = <name>newWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mLastSize</name>.<name>height</name></name> = <name>newHeight</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINSTATE_DEBUG_OUTPUT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"*** Resize window: %d x %d x %d x %d\n"</expr></argument>, <argument><expr><name><name>wp</name>-&gt;<name>x</name></name></expr></argument>, <argument><expr><name><name>wp</name>-&gt;<name>y</name></name></expr></argument>, <argument><expr><name>newWidth</name></expr></argument>, <argument><expr><name>newHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Recalculate the width and height based on the client area for gecko events.</comment>
    <if>if <condition>(<expr><call><name>::<name>GetClientRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>rect</name>.<name>width</name></name>  = <name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rect</name>.<name>height</name></name> = <name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="line">// Send a gecko resize event</comment>
    <expr_stmt><expr><name>result</name> = <call><name>OnResize</name><argument_list>(<argument><expr><name>rect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// static</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>ActivateOtherWindowHelper</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Find the next window that is enabled, visible, and not minimized.</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>hwndBelow</name> <init>= <expr><call><name>::<name>GetNextWindow</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>GW_HWNDNEXT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>hwndBelow</name> &amp;&amp; (!<call><name>::<name>IsWindowEnabled</name></name><argument_list>(<argument><expr><name>hwndBelow</name></expr></argument>)</argument_list></call> || !<call><name>::<name>IsWindowVisible</name></name><argument_list>(<argument><expr><name>hwndBelow</name></expr></argument>)</argument_list></call> ||
                       <call><name>::<name>IsIconic</name></name><argument_list>(<argument><expr><name>hwndBelow</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
    <expr_stmt><expr><name>hwndBelow</name> = <call><name>::<name>GetNextWindow</name></name><argument_list>(<argument><expr><name>hwndBelow</name></expr></argument>, <argument><expr><name>GW_HWNDNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <comment type="line">// Push ourselves to the bottom of the stack, then activate the</comment>
  <comment type="line">// next window.</comment>
  <expr_stmt><expr><call><name>::<name>SetWindowPos</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>HWND_BOTTOM</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                 <argument><expr><name>SWP_NOACTIVATE</name> | <name>SWP_NOMOVE</name> | <name>SWP_NOSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>hwndBelow</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>SetForegroundWindow</name></name><argument_list>(<argument><expr><name>hwndBelow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Play the minimize sound while we're here, since that is also</comment>
  <comment type="line">// forgotten when we use SW_SHOWMINIMIZED.</comment>
  <expr_stmt><expr><call><name>::<name>PlaySoundW</name></name><argument_list>(<argument><expr>L"Minimize"</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>SND_ALIAS</name> | <name>SND_NODEFAULT</name> | <name>SND_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>OnWindowPosChanging</name></name><parameter_list>(<param><decl><type><name>LPWINDOWPOS</name>&amp;</type> <name>info</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// enforce local z-order rules</comment>
  <if>if <condition>(<expr>!(<name><name>info</name>-&gt;<name>flags</name></name> &amp; <name>SWP_NOZORDER</name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>HWND</name></type> <name>hwndAfter</name> <init>= <expr><name><name>info</name>-&gt;<name>hwndInsertAfter</name></name></expr></init></decl>;</decl_stmt>
    
    <function_decl><type><name>nsZLevelEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_SETZLEVEL</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>nsWindow</name> *</type><name>aboveWindow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>hwndAfter</name> == <name>HWND_BOTTOM</name></expr>)</condition><then>
      <expr_stmt><expr><name><name>event</name>.<name>mPlacement</name></name> = <name>nsWindowZBottom</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>hwndAfter</name> == <name>HWND_TOP</name> || <name>hwndAfter</name> == <name>HWND_TOPMOST</name> || <name>hwndAfter</name> == <name>HWND_NOTOPMOST</name></expr>)</condition><then>
      <expr_stmt><expr><name><name>event</name>.<name>mPlacement</name></name> = <name>nsWindowZTop</name></expr>;</expr_stmt></then>
    <else>else <block>{
      <expr_stmt><expr><name><name>event</name>.<name>mPlacement</name></name> = <name>nsWindowZRelative</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aboveWindow</name> = <call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>hwndAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><name><name>event</name>.<name>mReqBelow</name></name> = <name>aboveWindow</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>mActualBelow</name></name> = <name>nsnull</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>event</name>.<name>mImmediate</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>mAdjusted</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>event</name>.<name>mAdjusted</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name><name>event</name>.<name>mPlacement</name></name> == <name>nsWindowZBottom</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>info</name>-&gt;<name>hwndInsertAfter</name></name> = <name>HWND_BOTTOM</name></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name><name>event</name>.<name>mPlacement</name></name> == <name>nsWindowZTop</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>info</name>-&gt;<name>hwndInsertAfter</name></name> = <name>HWND_TOP</name></expr>;</expr_stmt></then>
      <else>else <block>{
        <expr_stmt><expr><name><name>info</name>-&gt;<name>hwndInsertAfter</name></name> = (<name>HWND</name>)<call><name><name>event</name>.<name>mActualBelow</name>-&gt;<name>GetNativeData</name></name><argument_list>(<argument><expr><name>NS_NATIVE_WINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name><name>event</name>.<name>mActualBelow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// prevent rude external programs from making hidden window visible</comment>
  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>info</name>-&gt;<name>flags</name></name> &amp;= ~<name>SWP_SHOWWINDOW</name></expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Gesture event processing. Handles WM_GESTURE events.</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>OnGesture</name></name><parameter_list>(<param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Treatment for pan events which translate into scroll events:</comment>
  <if>if <condition>(<expr><call><name><name>mGesture</name>.<name>IsPanEvent</name></name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <function_decl><type><name>nsMouseScrollEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MOUSE_PIXEL_SCROLL</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

    <if>if <condition>( <expr>!<call><name><name>mGesture</name>.<name>ProcessPanMessage</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr> )</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if> <comment type="line">// ignore</comment>

    <decl_stmt><decl><type><name>nsEventStatus</name></type> <name>status</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>isControl</name></name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>isAlt</name></name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>button</name></name>    = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>time</name></name>      = <call><name>::<name>GetMessageTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>endFeedback</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>scrollOverflowX</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>scrollOverflowY</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>mGesture</name>.<name>PanDeltaToPixelScrollX</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DispatchEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>scrollOverflowX</name> = <name><name>event</name>.<name>scrollOverflow</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>mGesture</name>.<name>PanDeltaToPixelScrollY</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DispatchEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>scrollOverflowY</name> = <name><name>event</name>.<name>scrollOverflow</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mDisplayPanFeedback</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mGesture</name>.<name>UpdatePanFeedbackX</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>scrollOverflowX</name></expr></argument>, <argument><expr><name>endFeedback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mGesture</name>.<name>UpdatePanFeedbackY</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>scrollOverflowY</name></expr></argument>, <argument><expr><name>endFeedback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mGesture</name>.<name>PanFeedbackFinalize</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>endFeedback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>mGesture</name>.<name>CloseGestureInfoHandle</name></name><argument_list>(<argument><expr>(<name>HGESTUREINFO</name>)<name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Other gestures translate into simple gesture events:</comment>
  <decl_stmt><decl><type><name>nsSimpleGestureEvent</name></type> <name>event</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0.0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>( <expr>!<call><name><name>mGesture</name>.<name>ProcessGestureMessage</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// fall through to DefWndProc</comment>
  }</block></then></if>
  
  <comment type="line">// Polish up and send off the new event</comment>
  <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isControl</name></name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isAlt</name></name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>button</name></name>    = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>time</name></name>      = <call><name>::<name>GetMessageTime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsEventStatus</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>DispatchEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name> == <name>nsEventStatus_eIgnore</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// Ignored, fall through</comment>
  }</block></then></if>

  <comment type="line">// Only close this if we process and return true.</comment>
  <expr_stmt><expr><call><name><name>mGesture</name>.<name>CloseGestureInfoHandle</name></name><argument_list>(<argument><expr>(<name>HGESTUREINFO</name>)<name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return> <comment type="line">// Handled</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

<comment type="block">/*
 * OnMouseWheel - mouse wheele event processing. This was originally embedded
 * within the message case block. If returning true result should be returned
 * immediately (no more processing).
 */</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>OnMouseWheel</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>msg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>, <param><decl><type><name>PRBool</name>&amp;</type> <name>getWheelInfo</name></decl></param>, <param><decl><type><name>PRBool</name>&amp;</type> <name>result</name></decl></param>, <param><decl><type><name>LRESULT</name> *</type><name>aRetValue</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Handle both flavors of mouse wheel events.</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>iDeltaPerLine</name></decl>, <decl><type ref="prev"/><name>iDeltaPerChar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>ULONG</name></type> <name>ulScrollLines</name></decl>, <decl><type ref="prev"/><name>ulScrollChars</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>currentVDelta</name></decl>, <decl><type ref="prev"/><name>currentHDelta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>HWND</name></type> <name>currentWindow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>isVertical</name> <init>= <expr><name>msg</name> == <name>WM_MOUSEWHEEL</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Get mouse wheel metrics (but only once).</comment>
  <if>if <condition>(<expr><name>getWheelInfo</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>getWheelInfo</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SystemParametersInfo</name> <argument_list>(<argument><expr><name>SPI_GETWHEELSCROLLLINES</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>ulScrollLines</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ulScrollLines usually equals 3 or 0 (for no scrolling)</comment>
    <comment type="line">// WHEEL_DELTA equals 120, so iDeltaPerLine will be 40.</comment>

    <comment type="line">// However, if ulScrollLines &gt; WHEEL_DELTA, we assume that</comment>
    <comment type="line">// the mouse driver wants a page scroll.  The docs state that</comment>
    <comment type="line">// ulScrollLines should explicitly equal WHEEL_PAGESCROLL, but</comment>
    <comment type="line">// since some mouse drivers use an arbitrary large number instead,</comment>
    <comment type="line">// we have to handle that as well.</comment>

    <expr_stmt><expr><name>iDeltaPerLine</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ulScrollLines</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>ulScrollLines</name> &lt;= <name>WHEEL_DELTA</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>iDeltaPerLine</name> = <name>WHEEL_DELTA</name> / <name>ulScrollLines</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ulScrollLines</name> = <name>WHEEL_PAGESCROLL</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>SystemParametersInfo</name><argument_list>(<argument><expr><name>SPI_GETWHEELSCROLLCHARS</name></expr></argument>, <argument><expr>0</expr></argument>,
                              <argument><expr>&amp;<name>ulScrollChars</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Note that we may always fail to get the value before Win Vista.</comment>
      <expr_stmt><expr><name>ulScrollChars</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>iDeltaPerChar</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ulScrollChars</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>ulScrollChars</name> &lt;= <name>WHEEL_DELTA</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>iDeltaPerChar</name> = <name>WHEEL_DELTA</name> / <name>ulScrollChars</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ulScrollChars</name> = <name>WHEEL_PAGESCROLL</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>(<name>isVertical</name>  &amp;&amp; <name>ulScrollLines</name> != <name>WHEEL_PAGESCROLL</name> &amp;&amp; !<name>iDeltaPerLine</name>) ||
      (!<name>isVertical</name> &amp;&amp; <name>ulScrollChars</name> != <name>WHEEL_PAGESCROLL</name> &amp;&amp; !<name>iDeltaPerChar</name>)</expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if> <comment type="line">// break</comment>

  <comment type="line">// The mousewheel event will be dispatched to the toplevel</comment>
  <comment type="line">// window.  We need to give it to the child window</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>quit</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>HandleScrollingPlugins</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>, <argument><expr><name>quit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>quit</name></expr>;</return></then></if> <comment type="line">// return immediately if its not our window</comment>

  <comment type="line">// We should cancel the surplus delta if the current window is not</comment>
  <comment type="line">// same as previous.</comment>
  <if>if <condition>(<expr><name>currentWindow</name> != <name>mWnd</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>currentVDelta</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>currentHDelta</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>currentWindow</name> = <name>mWnd</name></expr>;</expr_stmt>
  }</block></then></if>

  <function_decl><type><name>nsMouseScrollEvent</name></type> <name>scrollEvent</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MOUSE_SCROLL</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><name><name>scrollEvent</name>.<name>delta</name></name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>isVertical</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>scrollEvent</name>.<name>scrollFlags</name></name> = <name><name>nsMouseScrollEvent</name>::<name>kIsVertical</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ulScrollLines</name> == <name>WHEEL_PAGESCROLL</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>scrollEvent</name>.<name>scrollFlags</name></name> |= <name><name>nsMouseScrollEvent</name>::<name>kIsFullPage</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>scrollEvent</name>.<name>delta</name></name> = (((<name>short</name>) <call><name>HIWORD</name> <argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call>) &gt; 0) ? -1 : 1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>currentVDelta</name> -= (<name>short</name>) <call><name>HIWORD</name> <argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>PR_ABS</name><argument_list>(<argument><expr><name>currentVDelta</name></expr></argument>)</argument_list></call> &gt;= <name>iDeltaPerLine</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>scrollEvent</name>.<name>delta</name></name> = <name>currentVDelta</name> / <name>iDeltaPerLine</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentVDelta</name> %= <name>iDeltaPerLine</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name><name>scrollEvent</name>.<name>scrollFlags</name></name> = <name><name>nsMouseScrollEvent</name>::<name>kIsHorizontal</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ulScrollChars</name> == <name>WHEEL_PAGESCROLL</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>scrollEvent</name>.<name>scrollFlags</name></name> |= <name><name>nsMouseScrollEvent</name>::<name>kIsFullPage</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>scrollEvent</name>.<name>delta</name></name> = (((<name>short</name>) <call><name>HIWORD</name> <argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call>) &gt; 0) ? 1 : -1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>currentHDelta</name> += (<name>short</name>) <call><name>HIWORD</name> <argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>PR_ABS</name><argument_list>(<argument><expr><name>currentHDelta</name></expr></argument>)</argument_list></call> &gt;= <name>iDeltaPerChar</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>scrollEvent</name>.<name>delta</name></name> = <name>currentHDelta</name> / <name>iDeltaPerChar</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentHDelta</name> %= <name>iDeltaPerChar</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></else></if>

  <if>if <condition>(<expr>!<name><name>scrollEvent</name>.<name>delta</name></name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if> <comment type="line">// break</comment>

  <expr_stmt><expr><name><name>scrollEvent</name>.<name>isShift</name></name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scrollEvent</name>.<name>isControl</name></name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scrollEvent</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scrollEvent</name>.<name>isAlt</name></name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>scrollEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>nsnull</name> != <name>mEventCallback</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>scrollEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// Note that we should return zero if we process WM_MOUSEWHEEL.</comment>
  <comment type="line">// But if we process WM_MOUSEHWHEEL, we should return non-zero.</comment>

  <if>if <condition>(<expr><name>result</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aRetValue</name> = <name>isVertical</name> ? 0 : <name>TRUE</name></expr>;</expr_stmt></then></if>
  
  <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// break;</comment>
}</block></function> 

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>StringCaseInsensitiveEquals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aChars1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>aNumChars1</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aChars2</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>aNumChars2</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aNumChars1</name> != <name>aNumChars2</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsCaseInsensitiveStringComparator</name></type> <name>comp</name></decl>;</decl_stmt>
  <return>return <expr><call><name>comp</name><argument_list>(<argument><expr><name>aChars1</name></expr></argument>, <argument><expr><name>aChars2</name></expr></argument>, <argument><expr><name>aNumChars1</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>

<function><type><name>UINT</name></type> <name><name>nsWindow</name>::<name>MapFromNativeToDOM</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>aNativeKeyCode</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <switch>switch <condition>(<expr><name>aNativeKeyCode</name></expr>)</condition> <block>{
    <case>case <expr><name>VK_OEM_1</name></expr>:     <return>return <expr><name>NS_VK_SEMICOLON</name></expr>;</return>     <comment type="line">// 0xBA, For the US standard keyboard, the ';:' key</comment>
    </case><case>case <expr><name>VK_OEM_PLUS</name></expr>:  <return>return <expr><name>NS_VK_ADD</name></expr>;</return>           <comment type="line">// 0xBB, For any country/region, the '+' key</comment>
    </case><case>case <expr><name>VK_OEM_MINUS</name></expr>: <return>return <expr><name>NS_VK_SUBTRACT</name></expr>;</return>      <comment type="line">// 0xBD, For any country/region, the '-' key</comment>
  </case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>aNativeKeyCode</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * nsWindow::OnKeyDown peeks into the message queue and pulls out
 * WM_CHAR messages for processing. During testing we don't want to
 * mess with the real message queue. Instead we pass a
 * pseudo-WM_CHAR-message using this structure, and OnKeyDown will use
 * that as if it was in the message queue, and refrain from actually
 * looking at or touching the message queue.
 */</comment>
<function><type><name>LRESULT</name></type> <name><name>nsWindow</name>::<name>OnKeyDown</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MSG</name> &amp;</type><name>aMsg</name></decl></param>,
                            <param><decl><type><name>nsModifierKeyState</name> &amp;</type><name>aModKeyState</name></decl></param>,
                            <param><decl><type><name>PRBool</name> *</type><name>aEventDispatched</name></decl></param>,
                            <param><decl><type><name>nsFakeCharMessage</name>*</type> <name>aFakeCharMessage</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>UINT</name></type> <name>virtualKeyCode</name> <init>= <expr><name><name>aMsg</name>.<name>wParam</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <expr_stmt><expr><call><name><name>gKbdLayout</name>.<name>OnKeyDown</name></name> <argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Use only DOMKeyCode for XP processing.</comment>
  <comment type="line">// Use aVirtualKeyCode for gKbdLayout and native processing.</comment>
  <decl_stmt><decl><type><name>UINT</name></type> <name>DOMKeyCode</name> <init>= <expr><call><name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> ?
                      <name>virtualKeyCode</name> : <call><name>MapFromNativeToDOM</name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <comment type="line">//printf("In OnKeyDown virt: %d\n", DOMKeyCode);</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>noDefault</name> <init>=
    <expr><call><name>DispatchKeyEvent</name><argument_list>(<argument><expr><name>NS_KEY_DOWN</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>DOMKeyCode</name></expr></argument>, <argument><expr>&amp;<name>aMsg</name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aEventDispatched</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aEventDispatched</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>

  <comment type="line">// If we won't be getting a WM_CHAR, WM_SYSCHAR or WM_DEADCHAR, synthesize a keypress</comment>
  <comment type="line">// for almost all keys</comment>
  <switch>switch <condition>(<expr><name>DOMKeyCode</name></expr>)</condition> <block>{
    <case>case <expr><name>NS_VK_SHIFT</name></expr>:
    </case><case>case <expr><name>NS_VK_CONTROL</name></expr>:
    </case><case>case <expr><name>NS_VK_ALT</name></expr>:
    </case><case>case <expr><name>NS_VK_CAPS_LOCK</name></expr>:
    </case><case>case <expr><name>NS_VK_NUM_LOCK</name></expr>:
    </case><case>case <expr><name>NS_VK_SCROLL_LOCK</name></expr>: <return>return <expr><name>noDefault</name></expr>;</return>
  </case>}</block></switch>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>extraFlags</name> <init>= <expr>(<name>noDefault</name> ? <name>NS_EVENT_FLAG_NO_DEFAULT</name> : 0)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSG</name></type> <name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>gotMsg</name> <init>= <expr><name>aFakeCharMessage</name> ||
    <call><name>::<name>PeekMessageW</name></name><argument_list>(<argument><expr>&amp;<name>msg</name></expr></argument>, <argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_KEYFIRST</name></expr></argument>, <argument><expr><name>WM_KEYLAST</name></expr></argument>, <argument><expr><name>PM_NOREMOVE</name> | <name>PM_NOYIELD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Enter and backspace are always handled here to avoid for example the</comment>
  <comment type="line">// confusion between ctrl-enter and ctrl-J.</comment>
  <if>if <condition>(<expr><name>DOMKeyCode</name> == <name>NS_VK_RETURN</name> || <name>DOMKeyCode</name> == <name>NS_VK_BACK</name> ||
      ((<name><name>aModKeyState</name>.<name>mIsControlDown</name></name> || <name><name>aModKeyState</name>.<name>mIsAltDown</name></name>)
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
       )</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
       <expr_stmt><expr>&amp;&amp; !<call><name><name>gKbdLayout</name>.<name>IsDeadKey</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>KeyboardLayout</name>::<name>IsPrintableCharKey</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call></expr></expr_stmt></then></if>)</block></function>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{
    <comment type="line">// Remove a possible WM_CHAR or WM_SYSCHAR messages from the message queue.</comment>
    <comment type="line">// They can be more than one because of:</comment>
    <comment type="line">//  * Dead-keys not pairing with base character</comment>
    <comment type="line">//  * Some keyboard layouts may map up to 4 characters to the single key</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>anyCharMessagesRemoved</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>aFakeCharMessage</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>anyCharMessagesRemoved</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <while>while <condition>(<expr><name>gotMsg</name> &amp;&amp; (<name><name>msg</name>.<name>message</name></name> == <name>WM_CHAR</name> || <name><name>msg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name>)</expr>)</condition>
      <block>{
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gWindowsLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("%s charCode=%d scanCode=%d\n", <name><name>msg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name> ? "WM_SYSCHAR" : "WM_CHAR",
                <name><name>msg</name>.<name>wParam</name></name>, <call><name>HIWORD</name><argument_list>(<argument><expr><name><name>msg</name>.<name>lParam</name></name></expr></argument>)</argument_list></call> &amp; 0xFF)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RemoveMessageAndDispatchPluginEvent</name><argument_list>(<argument><expr><name>WM_KEYFIRST</name></expr></argument>, <argument><expr><name>WM_KEYLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anyCharMessagesRemoved</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>gotMsg</name> = <call><name>::<name>PeekMessageW</name></name> <argument_list>(<argument><expr>&amp;<name>msg</name></expr></argument>, <argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_KEYFIRST</name></expr></argument>, <argument><expr><name>WM_KEYLAST</name></expr></argument>, <argument><expr><name>PM_NOREMOVE</name> | <name>PM_NOYIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>anyCharMessagesRemoved</name> &amp;&amp; <name>DOMKeyCode</name> == <name>NS_VK_BACK</name> &amp;&amp;
        <call><name><name>nsIMM32Handler</name>::<name>IsDoingKakuteiUndo</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aFakeCharMessage</name></expr></argument>,
                   <argument><expr>"We shouldn't be touching the real msg queue"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RemoveMessageAndDispatchPluginEvent</name><argument_list>(<argument><expr><name>WM_CHAR</name></expr></argument>, <argument><expr><name>WM_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block>
  <else>else <if>if <condition>(<expr><name>gotMsg</name> &amp;&amp;
           (<name>aFakeCharMessage</name> ||
            <name><name>msg</name>.<name>message</name></name> == <name>WM_CHAR</name> || <name><name>msg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name> || <name><name>msg</name>.<name>message</name></name> == <name>WM_DEADCHAR</name>)</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aFakeCharMessage</name></expr>)</condition><then>
      <return>return <expr><call><name>OnCharRaw</name><argument_list>(<argument><expr><name><name>aFakeCharMessage</name>-&gt;<name>mCharCode</name></name></expr></argument>,
                       <argument><expr><name><name>aFakeCharMessage</name>-&gt;<name>mScanCode</name></name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>, <argument><expr><name>extraFlags</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="line">// If prevent default set for keydown, do same for keypress</comment>
    <expr_stmt><expr><call><name>::<name>GetMessageW</name></name><argument_list>(<argument><expr>&amp;<name>msg</name></expr></argument>, <argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name><name>msg</name>.<name>message</name></name></expr></argument>, <argument><expr><name><name>msg</name>.<name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>msg</name>.<name>message</name></name> == <name>WM_DEADCHAR</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>PluginHasFocus</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

      <comment type="line">// We need to send the removed message to focused plug-in.</comment>
      <expr_stmt><expr><call><name>DispatchPluginEvent</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>noDefault</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gWindowsLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
           <argument><expr>("%s charCode=%d scanCode=%d\n",
            <name><name>msg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name> ? "WM_SYSCHAR" : "WM_CHAR",
            <name><name>msg</name>.<name>wParam</name></name>, <call><name>HIWORD</name><argument_list>(<argument><expr><name><name>msg</name>.<name>lParam</name></name></expr></argument>)</argument_list></call> &amp; 0xFF)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>BOOL</name></type> <name>result</name> <init>= <expr><call><name>OnChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>extraFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// If a syschar keypress wasn't processed, Windows may want to</comment>
    <comment type="line">// handle it to activate a native menu.</comment>
    <if>if <condition>(<expr>!<name>result</name> &amp;&amp; <name><name>msg</name>.<name>message</name></name> == <name>WM_SYSCHAR</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>::<name>DefWindowProcW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name><name>msg</name>.<name>message</name></name></expr></argument>, <argument><expr><name><name>msg</name>.<name>wParam</name></name></expr></argument>, <argument><expr><name><name>msg</name>.<name>lParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <else>else <if>if <condition>(<expr>!<name><name>aModKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp; !<name><name>aModKeyState</name>.<name>mIsAltDown</name></name> &amp;&amp;
             (<call><name><name>KeyboardLayout</name>::<name>IsPrintableCharKey</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call> ||
              <call><name><name>KeyboardLayout</name>::<name>IsNumpadKey</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
  <block>{
    <comment type="line">// If this is simple KeyDown event but next message is not WM_CHAR,</comment>
    <comment type="line">// this event may not input text, so we should ignore this event.</comment>
    <comment type="line">// See bug 314130.</comment>
    <return>return <expr><call><name>PluginHasFocus</name><argument_list>()</argument_list></call> &amp;&amp; <name>noDefault</name></expr>;</return>
  }</block></then></if></else></if></else>

  <if>if <condition>(<expr><call><name><name>gKbdLayout</name>.<name>IsDeadKey</name></name> <argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>PluginHasFocus</name><argument_list>()</argument_list></call> &amp;&amp; <name>noDefault</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRUint8</name></type> <name><name>shiftStates</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUnichar</name></type> <name><name>uniChars</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUnichar</name></type> <name><name>shiftedChars</name><index>[<expr>5</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUnichar</name></type> <name><name>unshiftedChars</name><index>[<expr>5</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUnichar</name></type> <name>shiftedLatinChar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUnichar</name></type> <name>unshiftedLatinChar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numOfUniChars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numOfShiftedChars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numOfUnshiftedChars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numOfShiftStates</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>virtualKeyCode</name></expr>)</condition> <block>{
    <comment type="line">// keys to be sent as characters</comment>
    <case>case <expr><name>VK_ADD</name></expr>:       <expr_stmt><expr><name><name>uniChars</name> <index>[<expr>0</expr>]</index></name> = '+'</expr>;</expr_stmt>  <expr_stmt><expr><name>numOfUniChars</name> = 1</expr>;</expr_stmt>  <break>break;</break>
    </case><case>case <expr><name>VK_SUBTRACT</name></expr>:  <expr_stmt><expr><name><name>uniChars</name> <index>[<expr>0</expr>]</index></name> = '-'</expr>;</expr_stmt>  <expr_stmt><expr><name>numOfUniChars</name> = 1</expr>;</expr_stmt>  <break>break;</break>
    </case><case>case <expr><name>VK_DIVIDE</name></expr>:    <expr_stmt><expr><name><name>uniChars</name> <index>[<expr>0</expr>]</index></name> = '/'</expr>;</expr_stmt>  <expr_stmt><expr><name>numOfUniChars</name> = 1</expr>;</expr_stmt>  <break>break;</break>
    </case><case>case <expr><name>VK_MULTIPLY</name></expr>:  <expr_stmt><expr><name><name>uniChars</name> <index>[<expr>0</expr>]</index></name> = '*'</expr>;</expr_stmt>  <expr_stmt><expr><name>numOfUniChars</name> = 1</expr>;</expr_stmt>  <break>break;</break>
    </case><case>case <expr><name>VK_NUMPAD0</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD1</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD2</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD3</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD4</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD5</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD6</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD7</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD8</name></expr>:
    </case><case>case <expr><name>VK_NUMPAD9</name></expr>:
      <expr_stmt><expr><name><name>uniChars</name> <index>[<expr>0</expr>]</index></name> = <name>virtualKeyCode</name> - <name>VK_NUMPAD0</name> + '0'</expr>;</expr_stmt>
      <expr_stmt><expr><name>numOfUniChars</name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <if>if <condition>(<expr><call><name><name>KeyboardLayout</name>::<name>IsPrintableCharKey</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>numOfUniChars</name> = <name>numOfShiftStates</name> =
          <call><name><name>gKbdLayout</name>.<name>GetUniChars</name></name><argument_list>(<argument><expr><name>uniChars</name></expr></argument>, <argument><expr><name>shiftStates</name></expr></argument>,
                                 <argument><expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>uniChars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name> ^ <name><name>aModKeyState</name>.<name>mIsAltDown</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint8</name></type> <name>capsLockState</name> <init>= <expr>(<call><name>::<name>GetKeyState</name></name><argument_list>(<argument><expr><name>VK_CAPITAL</name></expr></argument>)</argument_list></call> &amp; 1) ? <name>eCapsLock</name> : 0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>numOfUnshiftedChars</name> =
          <call><name><name>gKbdLayout</name>.<name>GetUniCharsWithShiftState</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>, <argument><expr><name>capsLockState</name></expr></argument>,
                       <argument><expr><name>unshiftedChars</name></expr></argument>, <argument><expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>unshiftedChars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numOfShiftedChars</name> =
          <call><name><name>gKbdLayout</name>.<name>GetUniCharsWithShiftState</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>,
                       <argument><expr><name>capsLockState</name> | <name>eShift</name></expr></argument>,
                       <argument><expr><name>shiftedChars</name></expr></argument>, <argument><expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>shiftedChars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The current keyboard cannot input alphabets or numerics,</comment>
        <comment type="line">// we should append them for Shortcut/Access keys.</comment>
        <comment type="line">// E.g., for Cyrillic keyboard layout.</comment>
        <if>if <condition>(<expr><name>NS_VK_A</name> &lt;= <name>DOMKeyCode</name> &amp;&amp; <name>DOMKeyCode</name> &lt;= <name>NS_VK_Z</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>shiftedLatinChar</name> = <name>unshiftedLatinChar</name> = <name>DOMKeyCode</name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>capsLockState</name></expr>)</condition><then>
            <expr_stmt><expr><name>shiftedLatinChar</name> += 0x20</expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>unshiftedLatinChar</name> += 0x20</expr>;</expr_stmt></else></if>
          <if>if <condition>(<expr><name>unshiftedLatinChar</name> == <name><name>unshiftedChars</name><index>[<expr>0</expr>]</index></name> &amp;&amp;
              <name>shiftedLatinChar</name> == <name><name>shiftedChars</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>shiftedLatinChar</name> = <name>unshiftedLatinChar</name> = 0</expr>;</expr_stmt>
          }</block></then></if>
        }</block></then> <else>else <block>{
          <decl_stmt><decl><type><name>PRUint16</name></type> <name>ch</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>NS_VK_0</name> &lt;= <name>DOMKeyCode</name> &amp;&amp; <name>DOMKeyCode</name> &lt;= <name>NS_VK_9</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ch</name> = <name>DOMKeyCode</name></expr>;</expr_stmt>
          }</block></then> <else>else <block>{
            <switch>switch <condition>(<expr><name>virtualKeyCode</name></expr>)</condition> <block>{
              <case>case <expr><name>VK_OEM_PLUS</name></expr>:   <expr_stmt><expr><name>ch</name> = '+'</expr>;</expr_stmt> <break>break;</break>
              </case><case>case <expr><name>VK_OEM_MINUS</name></expr>:  <expr_stmt><expr><name>ch</name> = '-'</expr>;</expr_stmt> <break>break;</break>
            </case>}</block></switch>
          }</block></else></if>
          <if>if <condition>(<expr><name>ch</name> &amp;&amp; <name><name>unshiftedChars</name><index>[<expr>0</expr>]</index></name> != <name>ch</name> &amp;&amp; <name><name>shiftedChars</name><index>[<expr>0</expr>]</index></name> != <name>ch</name></expr>)</condition><then> <block>{
            <comment type="line">// Windows has assigned a virtual key code to the key even though</comment>
            <comment type="line">// the character can't be produced with this key.  That probably</comment>
            <comment type="line">// means the character can't be produced with any key in the</comment>
            <comment type="line">// current layout and so the assignment is based on a QWERTY</comment>
            <comment type="line">// layout.  Append this code so that users can access the shortcut.</comment>
            <expr_stmt><expr><name>unshiftedLatinChar</name> = <name>ch</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></else></if>

        <comment type="line">// If the charCode is not ASCII character, we should replace the</comment>
        <comment type="line">// charCode with ASCII character only when Ctrl is pressed.</comment>
        <comment type="line">// But don't replace the charCode when the charCode is not same as</comment>
        <comment type="line">// unmodified characters. In such case, Ctrl is sometimes used for a</comment>
        <comment type="line">// part of character inputting key combination like Shift.</comment>
        <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>currentState</name> <init>= <expr><name>eCtrl</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsShiftDown</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>currentState</name> |= <name>eShift</name></expr>;</expr_stmt></then></if>

          <decl_stmt><decl><type><name>PRUint32</name></type> <name>ch</name> <init>=
            <expr><name><name>aModKeyState</name>.<name>mIsShiftDown</name></name> ? <name>shiftedLatinChar</name> : <name>unshiftedLatinChar</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>ch</name> &amp;&amp;
              (<name>numOfUniChars</name> == 0 ||
               <call><name>StringCaseInsensitiveEquals</name><argument_list>(<argument><expr><name>uniChars</name></expr></argument>, <argument><expr><name>numOfUniChars</name></expr></argument>,
                 <argument><expr><name><name>aModKeyState</name>.<name>mIsShiftDown</name></name> ? <name>shiftedChars</name> : <name>unshiftedChars</name></expr></argument>,
                 <argument><expr><name><name>aModKeyState</name>.<name>mIsShiftDown</name></name> ? <name>numOfShiftedChars</name> :
                                             <name>numOfUnshiftedChars</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>numOfUniChars</name> = <name>numOfShiftStates</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uniChars</name><index>[<expr>0</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>shiftStates</name><index>[<expr>0</expr>]</index></name> = <name>currentState</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
  </default>}</block></switch>

  <if>if <condition>(<expr><name>numOfUniChars</name> &gt; 0 || <name>numOfShiftedChars</name> &gt; 0 || <name>numOfUnshiftedChars</name> &gt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>num</name> <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>numOfUniChars</name></expr></argument>,
                          <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>numOfShiftedChars</name></expr></argument>, <argument><expr><name>numOfUnshiftedChars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>skipUniChars</name> <init>= <expr><name>num</name> - <name>numOfUniChars</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>skipShiftedChars</name> <init>= <expr><name>num</name> - <name>numOfShiftedChars</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>skipUnshiftedChars</name> <init>= <expr><name>num</name> - <name>numOfUnshiftedChars</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UINT</name></type> <name>keyCode</name> <init>= <expr><name>numOfUniChars</name> == 0 ? <name>DOMKeyCode</name> : 0</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>cnt</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>cnt</name> &lt; <name>num</name></expr>;</condition> <incr><expr><name>cnt</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>PRUint16</name></type> <name>uniChar</name></decl>, <decl><type ref="prev"/><name>shiftedChar</name></decl>, <decl><type ref="prev"/><name>unshiftedChar</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>uniChar</name> = <name>shiftedChar</name> = <name>unshiftedChar</name> = 0</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>skipUniChars</name> &lt;= <name>cnt</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>cnt</name> - <name>skipUniChars</name>  &lt; <name>numOfShiftStates</name></expr>)</condition><then> <block>{
          <comment type="line">// If key in combination with Alt and/or Ctrl produces a different</comment>
          <comment type="line">// character than without them then do not report these flags</comment>
          <comment type="line">// because it is separate keyboard layout shift state. If dead-key</comment>
          <comment type="line">// and base character does not produce a valid composite character</comment>
          <comment type="line">// then both produced dead-key character and following base</comment>
          <comment type="line">// character may have different modifier flags, too.</comment>
          <expr_stmt><expr><name><name>aModKeyState</name>.<name>mIsShiftDown</name></name> =
            (<name><name>shiftStates</name><index>[<expr><name>cnt</name> - <name>skipUniChars</name></expr>]</index></name> &amp; <name>eShift</name>) != 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name> =
            (<name><name>shiftStates</name><index>[<expr><name>cnt</name> - <name>skipUniChars</name></expr>]</index></name> &amp; <name>eCtrl</name>) != 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aModKeyState</name>.<name>mIsAltDown</name></name> =
            (<name><name>shiftStates</name><index>[<expr><name>cnt</name> - <name>skipUniChars</name></expr>]</index></name> &amp; <name>eAlt</name>) != 0</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>uniChar</name> = <name><name>uniChars</name><index>[<expr><name>cnt</name> - <name>skipUniChars</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><name>skipShiftedChars</name> &lt;= <name>cnt</name></expr>)</condition><then>
        <expr_stmt><expr><name>shiftedChar</name> = <name><name>shiftedChars</name><index>[<expr><name>cnt</name> - <name>skipShiftedChars</name></expr>]</index></name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>skipUnshiftedChars</name> &lt;= <name>cnt</name></expr>)</condition><then>
        <expr_stmt><expr><name>unshiftedChar</name> = <name><name>unshiftedChars</name><index>[<expr><name>cnt</name> - <name>skipUnshiftedChars</name></expr>]</index></name></expr>;</expr_stmt></then></if>
      <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsAlternativeCharCode</name></expr></argument>, <argument><expr>5</expr></argument>&gt;</argument_list></name></type> <name>altArray</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>shiftedChar</name> || <name>unshiftedChar</name></expr>)</condition><then> <block>{
        <function_decl><type><name>nsAlternativeCharCode</name></type> <name>chars</name><parameter_list>(<param><decl><type><name>unshiftedChar</name></type></decl></param>, <param><decl><type><name>shiftedChar</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name><name>altArray</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><name>cnt</name> == <name>num</name> - 1 &amp;&amp; (<name>unshiftedLatinChar</name> || <name>shiftedLatinChar</name>)</expr>)</condition><then> <block>{
        <function_decl><type><name>nsAlternativeCharCode</name></type> <name>chars</name><parameter_list>(<param><decl><type><name>unshiftedLatinChar</name></type></decl></param>, <param><decl><type><name>shiftedLatinChar</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name><name>altArray</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><call><name>DispatchKeyEvent</name><argument_list>(<argument><expr><name>NS_KEY_PRESS</name></expr></argument>, <argument><expr><name>uniChar</name></expr></argument>, <argument><expr>&amp;<name>altArray</name></expr></argument>,
                       <argument><expr><name>keyCode</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>, <argument><expr><name>extraFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>DispatchKeyEvent</name><argument_list>(<argument><expr><name>NS_KEY_PRESS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>DOMKeyCode</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>,
                     <argument><expr><name>extraFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <block>{
    <decl_stmt><decl><type><name>UINT</name></type> <name>unichar</name> <init>= <expr><call><name>::<name>MapVirtualKey</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>, <argument><expr><name>MAPVK_VK_TO_CHAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Check for dead characters or no mapping</comment>
    <if>if <condition>(<expr><name>unichar</name> &amp; 0x80</expr>)</condition><then> <block>{
      <return>return <expr><name>noDefault</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>DispatchKeyEvent</name><argument_list>(<argument><expr><name>NS_KEY_PRESS</name></expr></argument>, <argument><expr><name>unichar</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>DOMKeyCode</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>,
                     <argument><expr><name>extraFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>noDefault</name></expr>;</return>
}

<comment type="line">// OnKeyUp</comment>
LRESULT <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>OnKeyUp</name></name>(const <name>MSG</name> &amp;<name>aMsg</name>,
                          <name>nsModifierKeyState</name> &amp;<name>aModKeyState</name>,
                          <name>PRBool</name> *<name>aEventDispatched</name>)
<block>{
  <expr><name>UINT</name> <name>virtualKeyCode</name> = <name><name>aMsg</name>.<name>wParam</name></name></expr>;

  <expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gWindowsLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
         <argument><expr>("nsWindow::OnKeyUp VK=%d\n", <name>virtualKeyCode</name>)</expr></argument>)</argument_list></call></expr>;

  <if>if <condition>(<expr>!<call><name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>virtualKeyCode</name> = <call><name>MapFromNativeToDOM</name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt>

  <if>if <condition>(<expr><name>aEventDispatched</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aEventDispatched</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
  <return>return <expr><call><name>DispatchKeyEvent</name><argument_list>(<argument><expr><name>NS_KEY_UP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>virtualKeyCode</name></expr></argument>, <argument><expr>&amp;<name>aMsg</name></expr></argument>,
                          <argument><expr><name>aModKeyState</name></expr></argument>)</argument_list></call></expr>;</return>
}

<comment type="line">// OnChar</comment>
LRESULT <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>OnChar</name></name>(const <name>MSG</name> &amp;<name>aMsg</name>, <name>nsModifierKeyState</name> &amp;<name>aModKeyState</name>,
                         <name>PRBool</name> *<name>aEventDispatched</name>, <name>PRUint32</name> <name>aFlags</name>)
<block>{
  <return>return <expr><call><name>OnCharRaw</name><argument_list>(<argument><expr><name><name>aMsg</name>.<name>wParam</name></name></expr></argument>, <argument><expr><call><name>HIWORD</name><argument_list>(<argument><expr><name><name>aMsg</name>.<name>lParam</name></name></expr></argument>)</argument_list></call> &amp; 0xFF</expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>,
                   <argument><expr><name>aFlags</name></expr></argument>, <argument><expr>&amp;<name>aMsg</name></expr></argument>, <argument><expr><name>aEventDispatched</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<comment type="line">// OnCharRaw</comment>
<function><type><name>LRESULT</name></type> <name><name>nsWindow</name>::<name>OnCharRaw</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>charCode</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>aScanCode</name></decl></param>,
                            <param><decl><type><name>nsModifierKeyState</name> &amp;</type><name>aModKeyState</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>MSG</name> *</type><name>aMsg</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aEventDispatched</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// ignore [shift+]alt+space so the OS can handle it</comment>
  <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsAltDown</name></name> &amp;&amp; !<name><name>aModKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp;
      <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SPACE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>FALSE</name></expr>;</return>
  }</block></then></if>
  
  <comment type="line">// Ignore Ctrl+Enter (bug 318235)</comment>
  <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp; <name>charCode</name> == 0xA</expr>)</condition><then> <block>{
    <return>return <expr><name>FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// WM_CHAR with Control and Alt (== AltGr) down really means a normal character</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>saveIsAltDown</name> <init>= <expr><name><name>aModKeyState</name>.<name>mIsAltDown</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>saveIsControlDown</name> <init>= <expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsAltDown</name></name> &amp;&amp; <name><name>aModKeyState</name>.<name>mIsControlDown</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>aModKeyState</name>.<name>mIsAltDown</name></name> = <name><name>aModKeyState</name>.<name>mIsControlDown</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>wchar_t</name></type> <name>uniChar</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ResetInputState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp; <name>charCode</name> &lt;= 0x1A</expr>)</condition><then> <block>{ <comment type="line">// Ctrl+A Ctrl+Z, see Programming Windows 3.1 page 110 for details</comment>
    <comment type="line">// need to account for shift here.  bug 16486</comment>
    <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsShiftDown</name></name></expr>)</condition><then>
      <expr_stmt><expr><name>uniChar</name> = <name>charCode</name> - 1 + 'A'</expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>uniChar</name> = <name>charCode</name> - 1 + 'a'</expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>charCode</name> = 0</expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name> &amp;&amp; <name>charCode</name> &lt;= 0x1F</expr>)</condition><then> <block>{
    <comment type="line">// Fix for 50255 - &lt;ctrl&gt;&lt;[&gt; and &lt;ctrl&gt;&lt;]&gt; are not being processed.</comment>
    <comment type="line">// also fixes ctrl+\ (x1c), ctrl+^ (x1e) and ctrl+_ (x1f)</comment>
    <comment type="line">// for some reason the keypress handler need to have the uniChar code set</comment>
    <comment type="line">// with the addition of a upper case A not the lower case.</comment>
    <expr_stmt><expr><name>uniChar</name> = <name>charCode</name> - 1 + 'A'</expr>;</expr_stmt>
    <expr_stmt><expr><name>charCode</name> = 0</expr>;</expr_stmt>
  }</block></then> <else>else <block>{ <comment type="line">// 0x20 - SPACE, 0x3D - EQUALS</comment>
    <if>if <condition>(<expr><name>charCode</name> &lt; 0x20 || (<name>charCode</name> == 0x3D &amp;&amp; <name><name>aModKeyState</name>.<name>mIsControlDown</name></name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>uniChar</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>uniChar</name> = <name>charCode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>charCode</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if></else></if>

  <comment type="line">// Keep the characters unshifted for shortcuts and accesskeys and make sure</comment>
  <comment type="line">// that numbers are always passed as such (among others: bugs 50255 and 351310)</comment>
  <if>if <condition>(<expr><name>uniChar</name> &amp;&amp; (<name><name>aModKeyState</name>.<name>mIsControlDown</name></name> || <name><name>aModKeyState</name>.<name>mIsAltDown</name></name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>UINT</name></type> <name>virtualKeyCode</name> <init>= <expr><call><name>::<name>MapVirtualKeyEx</name></name><argument_list>(<argument><expr><name>aScanCode</name></expr></argument>, <argument><expr><name>MAPVK_VSC_TO_VK</name></expr></argument>,
                                            <argument><expr><call><name><name>gKbdLayout</name>.<name>GetLayout</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UINT</name></type> <name>unshiftedCharCode</name> <init>=
      <expr><name>virtualKeyCode</name> &gt;= '0' &amp;&amp; <name>virtualKeyCode</name> &lt;= '9' ? <name>virtualKeyCode</name> :
        <name><name>aModKeyState</name>.<name>mIsShiftDown</name></name> ? <call><name>::<name>MapVirtualKeyEx</name></name><argument_list>(<argument><expr><name>virtualKeyCode</name></expr></argument>,
                                        <argument><expr><name>MAPVK_VK_TO_CHAR</name></expr></argument>,
                                        <argument><expr><call><name><name>gKbdLayout</name>.<name>GetLayout</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
    <comment type="line">// ignore diacritics (top bit set) and key mapping errors (char code 0)</comment>
    <if>if <condition>(<expr>(<name>INT</name>)<name>unshiftedCharCode</name> &gt; 0</expr>)</condition><then>
      <expr_stmt><expr><name>uniChar</name> = <name>unshiftedCharCode</name></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <comment type="line">// Fix for bug 285161 (and 295095) which was caused by the initial fix for bug 178110.</comment>
  <comment type="line">// When pressing (alt|ctrl)+char, the char must be lowercase unless shift is</comment>
  <comment type="line">// pressed too.</comment>
  <if>if <condition>(<expr>!<name><name>aModKeyState</name>.<name>mIsShiftDown</name></name> &amp;&amp; (<name>saveIsAltDown</name> || <name>saveIsControlDown</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>uniChar</name> = <call><name>towlower</name><argument_list>(<argument><expr><name>uniChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><call><name>DispatchKeyEvent</name><argument_list>(<argument><expr><name>NS_KEY_PRESS</name></expr></argument>, <argument><expr><name>uniChar</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                   <argument><expr><name>charCode</name></expr></argument>, <argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>aModKeyState</name></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aEventDispatched</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aEventDispatched</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>aModKeyState</name>.<name>mIsAltDown</name></name> = <name>saveIsAltDown</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aModKeyState</name>.<name>mIsControlDown</name></name> = <name>saveIsControlDown</name></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsWindow</name>::<name>SetupKeyModifiersSequence</name></name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>KeyPair</name></expr></argument>&gt;</argument_list></name>*</type> <name>aArray</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aModifiers</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>sModifierKeyMap</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name>*</type> <name>map</name> <init>= <expr><name><name>sModifierKeyMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aModifiers</name> &amp; <name><name>map</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aArray</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><call><name>KeyPair</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>map</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsWindow</name>::<name>ConfigureChildren</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>Configuration</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aConfigurations</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXXroc we could use BeginDeferWindowPos/DeferWindowPos/EndDeferWindowPos</comment>
  <comment type="line">// here, if that helps in some situations. So far I haven't seen a</comment>
  <comment type="line">// need.</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>aConfigurations</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>Configuration</name>&amp;</type> <name>configuration</name> <init>= <expr><name><name>aConfigurations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>w</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mChild</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>w</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> == <name>this</name></expr></argument>,
                 <argument><expr>"Configured widget is not a child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
    <comment type="line">// MSDN says we should do on WinCE this before moving or resizing the window</comment>
    <comment type="line">// See http://msdn.microsoft.com/en-us/library/aa930600.aspx</comment>
    <comment type="line">// We put the region back just below, anyway.</comment>
    <expr_stmt><expr><call><name>::<name>SetWindowRgn</name></name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>mWnd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>nsIntRect</name></type> <name>bounds</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>w</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>bounds</name>.<name>Size</name></name><argument_list>()</argument_list></call> != <call><name><name>configuration</name>.<name>mBounds</name>.<name>Size</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>w</name>-&gt;<name>Resize</name></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mBounds</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>configuration</name>.<name>mBounds</name>.<name>y</name></name></expr></argument>,
                <argument><expr><name><name>configuration</name>.<name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>configuration</name>.<name>mBounds</name>.<name>height</name></name></expr></argument>,
                <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>bounds</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> != <call><name><name>configuration</name>.<name>mBounds</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>w</name>-&gt;<name>Move</name></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mBounds</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>configuration</name>.<name>mBounds</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>w</name>-&gt;<name>SetWindowClipRegion</name></name><argument_list>(<argument><expr><name><name>configuration</name>.<name>mClipRegion</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>HRGN</name></type>
<name>CreateHRGNFromArray</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIntRect</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aRects</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>RGNDATAHEADER</name></expr></argument>)</argument_list></sizeof> + <sizeof>sizeof<argument_list>(<argument><expr><name>RECT</name></expr></argument>)</argument_list></sizeof>*<call><name><name>aRects</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>PRUint8</name></expr></argument>,<argument><expr>100</expr></argument>&gt;</argument_list></name></type> <name>buf</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>buf</name>.<name>SetLength</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>RGNDATA</name>*</type> <name>data</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>RGNDATA</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>buf</name>.<name>Elements</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RECT</name>*</type> <name>rects</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>RECT</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>data</name>-&gt;<name>Buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>data</name>-&gt;<name>rdh</name>.<name>dwSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>data</name>-&gt;<name>rdh</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name>-&gt;<name>rdh</name>.<name>iType</name></name> = <name>RDH_RECTANGLES</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name>-&gt;<name>rdh</name>.<name>nCount</name></name> = <call><name><name>aRects</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>bounds</name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>aRects</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>r</name> <init>= <expr><name><name>aRects</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>bounds</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>SetRect</name></name><argument_list>(<argument><expr>&amp;<name><name>rects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>r</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>y</name></name></expr></argument>, <argument><expr><call><name><name>r</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>r</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>::<name>SetRect</name></name><argument_list>(<argument><expr>&amp;<name><name>data</name>-&gt;<name>rdh</name>.<name>rcBound</name></name></expr></argument>, <argument><expr><name><name>bounds</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>bounds</name>.<name>y</name></name></expr></argument>, <argument><expr><call><name><name>bounds</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>bounds</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>::<name>ExtCreateRegion</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name><name>buf</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsWindow</name>::<name>SetWindowClipRegion</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIntRect</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aRects</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aIntersectWithExisting</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aIntersectWithExisting</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>StoreWindowClipRegion</name><argument_list>(<argument><expr><name>aRects</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>HRGN</name></type> <name>dest</name> <init>= <expr><call><name>CreateHRGNFromArray</name><argument_list>(<argument><expr><name>aRects</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>dest</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>aIntersectWithExisting</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>HRGN</name></type> <name>current</name> <init>= <expr><call><name>::<name>CreateRectRgn</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>current</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name>::<name>GetWindowRgn</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call> != 0</expr> <comment type="block">/*ERROR*/</comment>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>CombineRgn</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>current</name></expr></argument>, <argument><expr><name>RGN_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>::<name>SetWindowRgn</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// WM_DESTROY event handler</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>OnDestroy</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mOnDestroyCalled</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <comment type="line">// Make sure we don't get destroyed in the process of tearing down.</comment>
  <function_decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWidget</name></expr></argument>&gt;</argument_list></name></type> <name>kungFuDeathGrip</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  
  <comment type="line">// Dispatch the NS_DESTROY event. Must be called before mEventCallback is cleared.</comment>
  <if>if <condition>(<expr>!<name>mInDtor</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>DispatchStandardEvent</name><argument_list>(<argument><expr><name>NS_DESTROY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Prevent the widget from sending additional events.</comment>
  <expr_stmt><expr><name>mEventCallback</name> = <name>nsnull</name></expr>;</expr_stmt>

  <comment type="line">// Free our subclass and clear |this| stored in the window props. We will no longer</comment>
  <comment type="line">// receive events from Windows after this point.</comment>
  <expr_stmt><expr><call><name>SubclassWindow</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Once mEventCallback is cleared and the subclass is reset, sCurrentWindow can be</comment>
  <comment type="line">// cleared. (It's used in tracking windows for mouse events.)</comment>
  <if>if <condition>(<expr><name>sCurrentWindow</name> == <name>this</name></expr>)</condition><then>
    <expr_stmt><expr><name>sCurrentWindow</name> = <name>nsnull</name></expr>;</expr_stmt></then></if>

  <comment type="line">// Disconnects us from our parent, will call our GetParent().</comment>
  <expr_stmt><expr><call><name><name>nsBaseWidget</name>::<name>Destroy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Release references to children, device context, toolkit, and app shell.</comment>
  <expr_stmt><expr><call><name><name>nsBaseWidget</name>::<name>OnDestroy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Clear our native parent handle.</comment>
  <comment type="line">// XXX Windows will take care of this in the proper order, and SetParent(nsnull)'s</comment>
  <comment type="line">// remove child on the parent already took place in nsBaseWidget's Destroy call above.</comment>
  <comment type="line">//SetParent(nsnull);</comment>

  <comment type="line">// We have to destroy the native drag target before we null out our window pointer.</comment>
  <expr_stmt><expr><call><name>EnableDragDrop</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If we're going away and for some reason we're still the rollup widget, rollup and</comment>
  <comment type="line">// turn off capture.</comment>
  <if>if <condition>( <expr><name>this</name> == <name>sRollupWidget</name></expr> )</condition><then> <block>{
    <if>if <condition>( <expr><name>sRollupListener</name></expr> )</condition><then>
      <expr_stmt><expr><call><name><name>sRollupListener</name>-&gt;<name>Rollup</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>CaptureRollupEvents</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// If IME is disabled, restore it.</comment>
  <if>if <condition>(<expr><name>mOldIMC</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mOldIMC</name> = <call><name>::<name>ImmAssociateContext</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>mOldIMC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mOldIMC</name></expr></argument>, <argument><expr>"Another IMC was associated"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Turn off mouse trails if enabled.</comment>
  <decl_stmt><decl><type><name>MouseTrailer</name>*</type> <name>mtrailer</name> <init>= <expr><name><name>nsToolkit</name>::<name>gMouseTrailer</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mtrailer</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>mtrailer</name>-&gt;<name>GetMouseTrailerWindow</name></name><argument_list>()</argument_list></call> == <name>mWnd</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mtrailer</name>-&gt;<name>DestroyTimer</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name><name>mtrailer</name>-&gt;<name>GetCaptureWindow</name></name><argument_list>()</argument_list></call> == <name>mWnd</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mtrailer</name>-&gt;<name>SetCaptureWindow</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <comment type="line">// Free GDI window class objects</comment>
  <if>if <condition>(<expr><name>mBrush</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>VERIFY</name><argument_list>(<argument><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>mBrush</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mBrush</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Free app icon resources.</comment>
  <decl_stmt><decl><type><name>HICON</name></type> <name>icon</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>icon</name> = (<name>HICON</name>) <call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_SETICON</name></expr></argument>, <argument><expr>(<name>WPARAM</name>)<name>ICON_BIG</name></expr></argument>, <argument><expr>(<name>LPARAM</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>icon</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>DestroyIcon</name></name><argument_list>(<argument><expr><name>icon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>icon</name> = (<name>HICON</name>) <call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>WM_SETICON</name></expr></argument>, <argument><expr>(<name>WPARAM</name>)<name>ICON_SMALL</name></expr></argument>, <argument><expr>(<name>LPARAM</name>) 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>icon</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>DestroyIcon</name></name><argument_list>(<argument><expr><name>icon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// Destroy any custom cursor resources.</comment>
  <if>if <condition>(<expr><name>mCursor</name> == -1</expr>)</condition><then>
    <expr_stmt><expr><call><name>SetCursor</name><argument_list>(<argument><expr><name>eCursor_standard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <comment type="line">// Reset transparency</comment>
  <if>if <condition>(<expr><name>eTransparencyTransparent</name> == <name>mTransparencyMode</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SetupTranslucentWindowMemoryBitmap</name><argument_list>(<argument><expr><name>eTransparencyOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_HAVE_SOFTKB</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// Revert the changes made for the software keyboard settings</comment>
  <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>ResetSoftKB</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Clear the main HWND.</comment>
  <expr_stmt><expr><name>mWnd</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">// OnMove</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>OnMove</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aX</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aY</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>mBounds</name>.<name>x</name></name> = <name>aX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBounds</name>.<name>y</name></name> = <name>aY</name></expr>;</expr_stmt>

  <function_decl><type><name>nsGUIEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MOVE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>x</name></name> = <name>aX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>refPoint</name>.<name>y</name></name> = <name>aY</name></expr>;</expr_stmt>

  <return>return <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Send a resize message to the listener</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>OnResize</name></name><parameter_list>(<param><decl><type><name>nsIntRect</name> &amp;</type><name>aWindowRect</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
  <if>if <condition>(<expr><name>mD2DWindowSurface</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mD2DWindowSurface</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="line">// call the event callback</comment>
  <if>if <condition>(<expr><name>mEventCallback</name></expr>)</condition><then> <block>{
    <function_decl><type><name>nsSizeEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_SIZE</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event</name>.<name>windowSize</name></name> = &amp;<name>aWindowRect</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>event</name>.<name>mWinWidth</name></name>  = <call><name>PRInt32</name><argument_list>(<argument><expr><name><name>r</name>.<name>right</name></name> - <name><name>r</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>event</name>.<name>mWinHeight</name></name> = <call><name>PRInt32</name><argument_list>(<argument><expr><name><name>r</name>.<name>bottom</name></name> - <name><name>r</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name><name>event</name>.<name>mWinWidth</name></name>  = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>event</name>.<name>mWinHeight</name></name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if> <comment type="line">// implemented in nsWindowCE.cpp</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>OnHotKey</name></name><parameter_list>(<param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !defined(WINCE)</comment>

<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>OnSettingsChange</name></name><parameter_list>(<param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mWindowType</name> == <name>eWindowType_dialog</name> ||
      <name>mWindowType</name> == <name>eWindowType_toplevel</name></expr> )</condition><then>
    <expr_stmt><expr><call><name><name>nsWindowGfx</name>::<name>OnSettingsChangeGfx</name></name><argument_list>(<argument><expr><name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="line">// Scrolling helper function for handling plugins.  </comment>
<comment type="line">// Return value indicates whether the calling function should handle this</comment>
<comment type="line">// aHandled indicates whether this was handled at all</comment>
<comment type="line">// aQuitProcessing tells whether or not to continue processing the message</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>HandleScrollingPlugins</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>aMsg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>aWParam</name></decl></param>,
                                        <param><decl><type><name>LPARAM</name></type> <name>aLParam</name></decl></param>, <param><decl><type><name>PRBool</name>&amp;</type> <name>aHandled</name></decl></param>,
                                        <param><decl><type><name>LRESULT</name>*</type> <name>aRetValue</name></decl></param>,
                                        <param><decl><type><name>PRBool</name>&amp;</type> <name>aQuitProcessing</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The scroll event will be dispatched to the toplevel</comment>
  <comment type="line">// window.  We need to give it to the child window</comment>
  <expr_stmt><expr><name>aQuitProcessing</name> = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">// default is to not stop processing</comment>
  <decl_stmt><decl><type><name>POINT</name></type> <name>point</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwPoints</name> <init>= <expr><call><name>::<name>GetMessagePos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>point</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>dwPoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>point</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>dwPoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>sIsProcessing</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>sIsProcessing</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>  <comment type="line">// the caller should handle this.</comment>
  }</block></then></if>

  <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>sMayBeUsingLogitechMouse</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aMsg</name> == <name>WM_MOUSEHWHEEL</name></expr>)</condition><then> <block>{
    <comment type="line">// Logitech (Logicool) mouse driver (confirmed with 4.82.11 and MX-1100)</comment>
    <comment type="line">// always sets 0 to the lParam of WM_MOUSEHWHEEL.  The driver SENDs one</comment>
    <comment type="line">// message at first time, this time, ::GetMessagePos works fine.</comment>
    <comment type="line">// Then, we will return 0 (0 means we process it) to the message. Then, the</comment>
    <comment type="line">// driver will POST the same messages continuously during the wheel tilted.</comment>
    <comment type="line">// But ::GetMessagePos API always returns (0, 0), even if the actual mouse</comment>
    <comment type="line">// cursor isn't 0,0.  Therefore, we cannot trust the result of</comment>
    <comment type="line">// ::GetMessagePos API if the sender is the driver.</comment>
    <if>if <condition>(<expr>!<name>sMayBeUsingLogitechMouse</name> &amp;&amp; <name>aLParam</name> == 0 &amp;&amp; <name>aLParam</name> != <name>dwPoints</name> &amp;&amp;
        <call><name>::<name>InSendMessage</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>sMayBeUsingLogitechMouse</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>sMayBeUsingLogitechMouse</name> &amp;&amp; <name>aLParam</name> != 0 &amp;&amp; <call><name>::<name>InSendMessage</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// The user has changed the mouse from Logitech's to another one (e.g.,</comment>
      <comment type="line">// the user has changed to the touchpad of the notebook.</comment>
      <expr_stmt><expr><name>sMayBeUsingLogitechMouse</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <comment type="line">// If the WM_MOUSEHWHEEL comes from Logitech's mouse driver, and the</comment>
    <comment type="line">// ::GetMessagePos isn't correct, probably, we should use ::GetCursorPos</comment>
    <comment type="line">// instead.</comment>
    <if>if <condition>(<expr><name>sMayBeUsingLogitechMouse</name> &amp;&amp; <name>aLParam</name> == 0 &amp;&amp; <name>dwPoints</name> == 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>GetCursorPos</name></name><argument_list>(<argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>HWND</name></type> <name>destWnd</name> <init>= <expr><call><name>::<name>WindowFromPoint</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Since we receive scroll events for as long as</comment>
  <comment type="line">// we are focused, it's entirely possible that there</comment>
  <comment type="line">// is another app's window or no window under the</comment>
  <comment type="line">// pointer.</comment>

  <if>if <condition>(<expr>!<name>destWnd</name></expr>)</condition><then> <block>{
    <comment type="line">// No window is under the pointer</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// break, but continue processing</comment>
  }</block></then></if>
  <comment type="line">// We don't care about windows belonging to other processes.</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>processId</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetWindowThreadProcessId</name><argument_list>(<argument><expr><name>destWnd</name></expr></argument>, <argument><expr>&amp;<name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>processId</name> != <call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr>)</condition><then>
  <block>{
    <comment type="line">// Somebody elses window</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// break, but continue processing</comment>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>destWindow</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>destWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>destWindow</name> || <name><name>destWindow</name>-&gt;<name>mWindowType</name></name> == <name>eWindowType_plugin</name></expr>)</condition><then> <block>{
    <comment type="line">// Some other app, or a plugin window.</comment>
    <comment type="line">// Windows directs scrolling messages to the focused window.</comment>
    <comment type="line">// However, Mozilla does not like plugins having focus, so a</comment>
    <comment type="line">// Mozilla window (ie, the plugin's parent (us!) has focus.)</comment>
    <comment type="line">// Therefore, plugins etc _should_ get first grab at the</comment>
    <comment type="line">// message, but this focus vaguary means the plugin misses</comment>
    <comment type="line">// out. If the window is a child of ours, forward it on.</comment>
    <comment type="line">// Determine if a child by walking the parent list until</comment>
    <comment type="line">// we find a parent matching our wndproc.</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>parentWnd</name> <init>= <expr><call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>destWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>parentWnd</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>parentWindow</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>parentWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>parentWindow</name></expr>)</condition><then> <block>{
        <comment type="line">// We have a child window - quite possibly a plugin window.</comment>
        <comment type="line">// However, not all plugins are created equal - some will handle this </comment>
        <comment type="line">// message themselves, some will forward directly back to us, while </comment>
        <comment type="line">// others will call DefWndProc, which itself still forwards back to us.</comment>
        <comment type="line">// So if we have sent it once, we need to handle it ourself.</comment>

        <comment type="line">// First time we have seen this message.</comment>
        <comment type="line">// Call the child - either it will consume it, or</comment>
        <comment type="line">// it will wind it's way back to us,triggering the destWnd case above</comment>
        <comment type="line">// either way,when the call returns,we are all done with the message,</comment>
        <expr_stmt><expr><name>sIsProcessing</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>0 == <call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>destWnd</name></expr></argument>, <argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>aWParam</name></expr></argument>, <argument><expr><name>aLParam</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>aHandled</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>sIsProcessing</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// break, but continue processing</comment>
      }</block></then></if>
      <expr_stmt><expr><name>parentWnd</name> = <call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>parentWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while> <comment type="line">// while parentWnd</comment>
  }</block></then></if>
  <if>if <condition>(<expr><name>destWnd</name> == <name>nsnull</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name>destWnd</name> != <name>mWnd</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>destWindow</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>sIsProcessing</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aHandled</name> = <call><name><name>destWindow</name>-&gt;<name>ProcessMessage</name></name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>aWParam</name></expr></argument>, <argument><expr><name>aLParam</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sIsProcessing</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aQuitProcessing</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">// break, and stop processing</comment>
    }</block></then>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <else>else
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"WARNING: couldn't get child window for SCROLL event\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>  <comment type="line">// caller should handle this</comment>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>OnScroll</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>aMsg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>aWParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>aLParam</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRInt8</name></type> <name>sMouseWheelEmulation</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>sMouseWheelEmulation</name> &lt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefService</name></expr></argument>&gt;</argument_list></name></type> <name>prefs</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>prefs</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>prefBranch</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>prefs</name>-&gt;<name>GetBranch</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>prefBranch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>prefBranch</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>emulate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=
      <expr><call><name><name>prefBranch</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"mousewheel.emulate_at_wm_scroll"</expr></argument>, <argument><expr>&amp;<name>emulate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sMouseWheelEmulation</name> = <call><name>PRInt8</name><argument_list>(<argument><expr><name>emulate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aLParam</name> || <name>sMouseWheelEmulation</name></expr>)</condition><then> <block>{
    <comment type="line">// Scroll message generated by Thinkpad Trackpoint Driver or similar</comment>
    <comment type="line">// Treat as a mousewheel message and scroll appropriately</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>quit</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LRESULT</name></type> <name>retVal</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>HandleScrollingPlugins</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>, <argument><expr><name>aWParam</name></expr></argument>, <argument><expr><name>aLParam</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>retVal</name></expr></argument>, <argument><expr><name>quit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>quit</name></expr>;</return></then></if>  <comment type="line">// Return if it's not our message or has been dispatched</comment>

    <function_decl><type><name>nsMouseScrollEvent</name></type> <name>scrollevent</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_MOUSE_SCROLL</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name><name>scrollevent</name>.<name>scrollFlags</name></name> = (<name>aMsg</name> == <name>WM_VSCROLL</name>) 
                              ? <name><name>nsMouseScrollEvent</name>::<name>kIsVertical</name></name>
                              : <name><name>nsMouseScrollEvent</name>::<name>kIsHorizontal</name></name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>LOWORD</name><argument_list>(<argument><expr><name>aWParam</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{
      <case>case <expr><name>SB_PAGEDOWN</name></expr>:
        <expr_stmt><expr><name><name>scrollevent</name>.<name>scrollFlags</name></name> |= <name><name>nsMouseScrollEvent</name>::<name>kIsFullPage</name></name></expr>;</expr_stmt>
      </case><case>case <expr><name>SB_LINEDOWN</name></expr>:
        <expr_stmt><expr><name><name>scrollevent</name>.<name>delta</name></name> = 1</expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>SB_PAGEUP</name></expr>:
        <expr_stmt><expr><name><name>scrollevent</name>.<name>scrollFlags</name></name> |= <name><name>nsMouseScrollEvent</name>::<name>kIsFullPage</name></name></expr>;</expr_stmt>
      </case><case>case <expr><name>SB_LINEUP</name></expr>:
        <expr_stmt><expr><name><name>scrollevent</name>.<name>delta</name></name> = -1</expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    </default>}</block></switch>
    <expr_stmt><expr><name><name>scrollevent</name>.<name>isShift</name></name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scrollevent</name>.<name>isControl</name></name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scrollevent</name>.<name>isMeta</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scrollevent</name>.<name>isAlt</name></name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitEvent</name><argument_list>(<argument><expr><name>scrollevent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nsnull</name> != <name>mEventCallback</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>scrollevent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Scroll message generated by external application</comment>
  <function_decl><type><name>nsContentCommandEvent</name></type> <name>command</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_CONTENT_COMMAND_SCROLL</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

  <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mIsHorizontal</name></name> = (<name>aMsg</name> == <name>WM_HSCROLL</name>)</expr>;</expr_stmt>

  <switch>switch <condition>(<expr><call><name>LOWORD</name><argument_list>(<argument><expr><name>aWParam</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{
    <case>case <expr><name>SB_LINEUP</name></expr>:   <comment type="line">// SB_LINELEFT</comment>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mUnit</name></name> = <name><name>nsContentCommandEvent</name>::<name>eCmdScrollUnit_Line</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mAmount</name></name> = -1</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SB_LINEDOWN</name></expr>: <comment type="line">// SB_LINERIGHT</comment>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mUnit</name></name> = <name><name>nsContentCommandEvent</name>::<name>eCmdScrollUnit_Line</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mAmount</name></name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SB_PAGEUP</name></expr>:   <comment type="line">// SB_PAGELEFT</comment>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mUnit</name></name> = <name><name>nsContentCommandEvent</name>::<name>eCmdScrollUnit_Page</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mAmount</name></name> = -1</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SB_PAGEDOWN</name></expr>: <comment type="line">// SB_PAGERIGHT</comment>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mUnit</name></name> = <name><name>nsContentCommandEvent</name>::<name>eCmdScrollUnit_Page</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mAmount</name></name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SB_TOP</name></expr>:      <comment type="line">// SB_LEFT</comment>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mUnit</name></name> = <name><name>nsContentCommandEvent</name>::<name>eCmdScrollUnit_Whole</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mAmount</name></name> = -1</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SB_BOTTOM</name></expr>:   <comment type="line">// SB_RIGHT</comment>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mUnit</name></name> = <name><name>nsContentCommandEvent</name>::<name>eCmdScrollUnit_Whole</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>command</name>.<name>mScroll</name>.<name>mAmount</name></name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>DispatchWindowEvent</name><argument_list>(<argument><expr>&amp;<name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Return the brush used to paint the background of this control</comment>
<function><type><name>HBRUSH</name></type> <name><name>nsWindow</name>::<name>OnControlColor</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><name>mBrush</name></expr>;</return>
}</block></function>

<comment type="line">// Can be overriden. Controls auto-erase of background.</comment>
<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>AutoErase</name></name><parameter_list>(<param><decl><type><name>HDC</name></type> <name>dc</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: IME management and accessibility
 **
 ** Handles managing IME input and accessibility.
 **
 **************************************************************
 **************************************************************/</comment>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>ResetInputState</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_KBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"ResetInputState\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>CommitComposition</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>

  <function_decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><parameter_list>(<param><decl><type><name>mWnd</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><call><name><name>IMEContext</name>.<name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>ImmNotifyIME</name></name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NI_COMPOSITIONSTR</name></expr></argument>, <argument><expr><name>CPS_COMPLETE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>ImmNotifyIME</name></name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NI_COMPOSITIONSTR</name></expr></argument>, <argument><expr><name>CPS_CANCEL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>SetIMEOpenState</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aState</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_KBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SetIMEOpenState %s\n"</expr></argument>, <argument><expr>(<name>aState</name> ? "Open" : "Close")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>SetIMEOpenState</name></name><argument_list>(<argument><expr><name>aState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>

  <function_decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><parameter_list>(<param><decl><type><name>mWnd</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><call><name><name>IMEContext</name>.<name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>ImmSetOpenStatus</name></name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aState</name> ? <name>TRUE</name> : <name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>GetIMEOpenState</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><parameter_list>(<param><decl><type><name>mWnd</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><call><name><name>IMEContext</name>.<name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>BOOL</name></type> <name>isOpen</name> <init>= <expr><call><name>::<name>ImmGetOpenStatus</name></name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>aState</name> = <name>isOpen</name> ? <name>PR_TRUE</name> : <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then> <else>else 
    <expr_stmt><expr>*<name>aState</name> = <name>PR_FALSE</name></expr>;</expr_stmt></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
  <expr_stmt><expr>*<name>aState</name> |= <call><name><name>nsTextStore</name>::<name>GetIMEOpenState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>SetIMEEnabled</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aState</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>SetIMEEnabled</name></name><argument_list>(<argument><expr><name>aState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_KBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SetIMEEnabled: %s\n"</expr></argument>, <argument><expr>(<name>aState</name> == <name><name>nsIWidget</name>::<name>IME_STATUS_ENABLED</name></name> ||
                                 <name>aState</name> == <name><name>nsIWidget</name>::<name>IME_STATUS_PLUGIN</name></name>)? 
                                "Enabled": "Disabled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
  <if>if <condition>(<expr><call><name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>ResetInputState</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>mIMEEnabled</name> = <name>aState</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>enable</name> <init>= <expr>(<name>aState</name> == <name><name>nsIWidget</name>::<name>IME_STATUS_ENABLED</name></name> ||
                   <name>aState</name> == <name><name>nsIWidget</name>::<name>IME_STATUS_PLUGIN</name></name>)</expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WINCE_HAVE_SOFTKB</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>sSoftKeyboardState</name> = (<name>aState</name> != <name><name>nsIWidget</name>::<name>IME_STATUS_DISABLED</name></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>nsWindowCE</name>::<name>ToggleSoftKB</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>sSoftKeyboardState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!<name>enable</name> != !<name>mOldIMC</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <expr_stmt><expr><name>mOldIMC</name> = <call><name>::<name>ImmAssociateContext</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>enable</name> ? <name>mOldIMC</name> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>enable</name> || !<name>mOldIMC</name></expr></argument>, <argument><expr>"Another IMC was associated"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>GetIMEEnabled</name></name><parameter_list>(<param><decl><type><name>PRUint32</name>*</type> <name>aState</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_KBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"GetIMEEnabled: %s\n"</expr></argument>, <argument><expr><name>mIMEEnabled</name>? "Enabled": "Disabled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
  <expr_stmt><expr>*<name>aState</name> = <name>mIMEEnabled</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsWindow</name>::<name>CancelIMEComposition</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_KBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"CancelIMEComposition\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>nsTextStore</name>::<name>CommitComposition</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>

  <function_decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><parameter_list>(<param><decl><type><name>mWnd</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><call><name><name>IMEContext</name>.<name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>ImmNotifyIME</name></name><argument_list>(<argument><expr><call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NI_COMPOSITIONSTR</name></expr></argument>, <argument><expr><name>CPS_CANCEL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>GetToggledKeyState</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aKeyCode</name></decl></param>, <param><decl><type><name>PRBool</name>*</type> <name>aLEDState</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_KBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"GetToggledKeyState\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aLEDState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aLEDState</name> = (<call><name>::<name>GetKeyState</name></name><argument_list>(<argument><expr><name>aKeyCode</name></expr></argument>)</argument_list></call> &amp; 1) != 0</expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_ENABLE_TSF</name></cpp:ifdef>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>OnIMEFocusChange</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aFocus</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>nsTextStore</name>::<name>OnFocusChange</name></name><argument_list>(<argument><expr><name>aFocus</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>mIMEEnabled</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_NOT_AVAILABLE</name></expr>)</condition><then>
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</expr_stmt></then></if> <comment type="line">// TSF is not enabled, maybe.</comment>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>OnIMETextChange</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aStart</name></decl></param>,
                          <param><decl><type><name>PRUint32</name></type> <name>aOldEnd</name></decl></param>,
                          <param><decl><type><name>PRUint32</name></type> <name>aNewEnd</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>nsTextStore</name>::<name>OnTextChange</name></name><argument_list>(<argument><expr><name>aStart</name></expr></argument>, <argument><expr><name>aOldEnd</name></expr></argument>, <argument><expr><name>aNewEnd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsWindow</name>::<name>OnIMESelectionChange</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>nsTextStore</name>::<name>OnSelectionChange</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//NS_ENABLE_TSF</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsIAccessible</name></expr></argument>&gt;</argument_list></name></type> <name><name>nsWindow</name>::<name>GetRootAccessible</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// We want the ability to forcibly disable a11y on windows, because</comment>
  <comment type="line">// some non-a11y-related components attempt to bring it up.  See bug</comment>
  <comment type="line">// 538530 for details; we have a pref here that allows it to be disabled</comment>
  <comment type="line">// for performance and testing resons.</comment>
  <comment type="line">//</comment>
  <comment type="line">// This pref is checked only once, and the browser needs a restart to</comment>
  <comment type="line">// pick up any changes.</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>accForceDisable</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>accForceDisable</name> == -1</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>prefs</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>b</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>prefs</name>-&gt;<name>GetBoolPref</name></name><argument_list>(<argument><expr>"accessibility.win32.force_disabled"</expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>b</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>accForceDisable</name> = 1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>accForceDisable</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <comment type="line">// If the pref was true, return null here, disabling a11y.</comment>
  <if>if <condition>(<expr><name>accForceDisable</name></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>nsWindow</name>::<name>sIsAccessibilityOn</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mInDtor</name> || <name>mOnDestroyCalled</name> || <name>mWindowType</name> == <name>eWindowType_invisible</name></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIAccessible</name> *</type><name>rootAccessible</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// If accessibility is turned on, we create this even before it is requested</comment>
  <comment type="line">// when the window gets focused. We need it to be created early so it can </comment>
  <comment type="line">// generate accessibility events right away</comment>
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>accessibleWindow</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mContentType</name> != <name>eContentTypeInherit</name></expr>)</condition><then> <block>{
    <comment type="line">// We're on a MozillaContentWindowClass or MozillaUIWindowClass window.</comment>
    <comment type="line">// Search for the correct visible child window to get an accessible </comment>
    <comment type="line">// document from. Make sure to use an active child window</comment>
    <decl_stmt><decl><type><name>HWND</name></type> <name>accessibleWnd</name> <init>= <expr><call><name>::<name>GetTopWindow</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>accessibleWnd</name></expr>)</condition> <block>{
      <comment type="line">// Loop through windows and find the first one with accessibility info</comment>
      <expr_stmt><expr><name>accessibleWindow</name> = <call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>accessibleWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>accessibleWindow</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>accessibleWindow</name>-&gt;<name>DispatchAccessibleEvent</name></name><argument_list>(<argument><expr><name>NS_GETACCESSIBLE</name></expr></argument>, <argument><expr>&amp;<name>rootAccessible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rootAccessible</name></expr>)</condition><then> <block>{
          <break>break;</break>  <comment type="line">// Success, one of the child windows was active</comment>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>accessibleWnd</name> = <call><name>::<name>GetNextWindow</name></name><argument_list>(<argument><expr><name>accessibleWnd</name></expr></argument>, <argument><expr><name>GW_HWNDNEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>DispatchAccessibleEvent</name><argument_list>(<argument><expr><name>NS_GETACCESSIBLE</name></expr></argument>, <argument><expr>&amp;<name>rootAccessible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rootAccessible</name></expr>;</return>
}</block></function>

<macro><name>STDMETHODIMP_</name><argument_list>(<argument>LRESULT</argument>)</argument_list></macro>
<macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>LresultFromObject</name></name>(<name>REFIID</name> <name>riid</name>, <name>WPARAM</name> <name>wParam</name>, <name>LPUNKNOWN</name> <name>pAcc</name>)
<block>{
  <comment type="line">// open the dll dynamically</comment>
  <if>if <condition>(<expr>!<name>sAccLib</name></expr>)</condition><then>
    <expr_stmt><expr><name>sAccLib</name> =<call><name>::<name>LoadLibraryW</name></name><argument_list>(<argument><expr>L"OLEACC.DLL"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></block></expr></expr_stmt>

  <if>if <condition>(<expr><name>sAccLib</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name>sLresultFromObject</name></expr>)</condition><then>
      <expr_stmt><expr><name>sLresultFromObject</name> = (<name>LPFNLRESULTFROMOBJECT</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>sAccLib</name></expr></argument>,<argument><expr>"LresultFromObject"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>sLresultFromObject</name></expr>)</condition><then>
      <return>return <expr><call><name>sLresultFromObject</name><argument_list>(<argument><expr><name>riid</name></expr></argument>,<argument><expr><name>wParam</name></expr></argument>,<argument><expr><name>pAcc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block></then></if>

  <return>return <expr>0</expr>;</return>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Transparency
 **
 ** Window transparency helpers.
 **
 **************************************************************
 **************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>

void <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>ResizeTranslucentWindow</name></name>(<name>PRInt32</name> <name>aNewWidth</name>, <name>PRInt32</name> <name>aNewHeight</name>, <name>PRBool</name> <name>force</name>)
<block>{
  <if>if <condition>(<expr>!<name>force</name> &amp;&amp; <name>aNewWidth</name> == <name><name>mBounds</name>.<name>width</name></name> &amp;&amp; <name>aNewHeight</name> == <name><name>mBounds</name>.<name>height</name></name></expr>)</condition><then>
    <return>return;</return></then></if>

  <name>mTransparentSurface</name> = new <call><name>gfxWindowsSurface</name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name>aNewWidth</name></expr></argument>, <argument><expr><name>aNewHeight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
  <expr_stmt><expr><name>mMemoryDC</name> = <call><name><name>mTransparentSurface</name>-&gt;<name>GetDC</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}

void <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>SetWindowTranslucencyInner</name></name>(<name>nsTransparencyMode</name> <name>aMode</name>)
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>

  <if>if <condition>(<expr><name>aMode</name> == <name>mTransparencyMode</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <name>HWND</name> <name>hWnd</name> = <call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>topWindow</name> <init>= <expr><call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>topWindow</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Trying to use transparent chrome in an embedded context"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>LONG_PTR</name></type> <name>style</name> <init>= <expr>0</expr></init>, <name>exStyle</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <switch>switch<condition>(<expr><name>aMode</name></expr>)</condition> <block>{
    <case>case <expr><name>eTransparencyTransparent</name></expr>:
      <expr_stmt><expr><name>exStyle</name> |= <name>WS_EX_LAYERED</name></expr>;</expr_stmt>
    </case><case>case <expr><name>eTransparencyOpaque</name></expr>:
    </case><case>case <expr><name>eTransparencyGlass</name></expr>:
      <expr_stmt><expr><name><name>topWindow</name>-&gt;<name>mTransparencyMode</name></name> = <name>aMode</name></expr>;</expr_stmt>
      <break>break;</break>
  </case>}</block></switch>

  <expr_stmt><expr><name>style</name> |= <call><name><name>topWindow</name>-&gt;<name>WindowStyle</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>exStyle</name> |= <call><name><name>topWindow</name>-&gt;<name>WindowExStyle</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aMode</name> == <name>eTransparencyTransparent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>style</name> &amp;= ~(<name>WS_CAPTION</name> | <name>WS_THICKFRAME</name> | <name>WS_SYSMENU</name> | <name>WS_MINIMIZEBOX</name> | <name>WS_MAXIMIZEBOX</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>exStyle</name> &amp;= ~(<name>WS_EX_DLGMODALFRAME</name> | <name>WS_EX_WINDOWEDGE</name> | <name>WS_EX_CLIENTEDGE</name> | <name>WS_EX_STATICEDGE</name>)</expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>VERIFY_WINDOW_STYLE</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>, <argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>GWL_EXSTYLE</name></expr></argument>, <argument><expr><name>exStyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mTransparencyMode</name> = <name>aMode</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SetupTranslucentWindowMemoryBitmap</name><argument_list>(<argument><expr><name>aMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UpdateGlass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #ifndef WINCE</comment>
}

void <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>SetupTranslucentWindowMemoryBitmap</name></name>(<name>nsTransparencyMode</name> <name>aMode</name>)
<block>{
  <if>if <condition>(<expr><name>eTransparencyTransparent</name> == <name>aMode</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ResizeTranslucentWindow</name><argument_list>(<argument><expr><name><name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt> <else>else <block>{
    <expr_stmt><expr><name>mTransparentSurface</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mMemoryDC</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></else>
}

nsresult <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>UpdateTranslucentWindow</name></name>()
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <if>if <condition>(<expr><call><name><name>mBounds</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <call><name>::<name>GdiFlush</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>BLENDFUNCTION</name></type> <name>bf</name> <init>= <expr><block>{ <expr><name>AC_SRC_OVER</name></expr>, <expr>0</expr>, <expr>255</expr>, <expr><name>AC_SRC_ALPHA</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIZE</name></type> <name>winSize</name> <init>= <expr><block>{ <expr><name><name>mBounds</name>.<name>width</name></name></expr>, <expr><name><name>mBounds</name>.<name>height</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>POINT</name></type> <name>srcPos</name> <init>= <expr><block>{ <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HWND</name></type> <name>hWnd</name> <init>= <expr><call><name>GetTopLevelHWND</name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RECT</name></type> <name>winRect</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>&amp;<name>winRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// perform the alpha blend</comment>
  <if>if <condition>(<expr>!<call><name>::<name>UpdateLayeredWindow</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>POINT</name>*)&amp;<name>winRect</name></expr></argument>, <argument><expr>&amp;<name>winSize</name></expr></argument>, <argument><expr><name>mMemoryDC</name></expr></argument>, <argument><expr>&amp;<name>srcPos</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>bf</name></expr></argument>, <argument><expr><name>ULW_ALPHA</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MOZ_XUL</comment>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Popup rollup hooks
 **
 ** Deals with CaptureRollup on popup windows.
 **
 **************************************************************
 **************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
<comment type="line">// Schedules a timer for a window, so we can rollup after processing the hook event</comment>
void <macro><name>nsWindow</name></macro><expr_stmt><expr><name>::<name>ScheduleHookTimer</name></name>(<name>HWND</name> <name>aWnd</name>, <name>UINT</name> <name>aMsgId</name>)
<block>{
  <comment type="line">// In some cases multiple hooks may be scheduled</comment>
  <comment type="line">// so ignore any other requests once one timer is scheduled</comment>
  <if>if <condition>(<expr><name>sHookTimerId</name> == 0</expr>)</condition><then> <block>{
    <comment type="line">// Remember the window handle and the message ID to be used later</comment>
    <expr_stmt><expr><name>sRollupMsgId</name> = <name>aMsgId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sRollupMsgWnd</name> = <name>aWnd</name></expr>;</expr_stmt>
    <comment type="line">// Schedule native timer for doing the rollup after</comment>
    <comment type="line">// this event is done being processed</comment>
    <expr_stmt><expr><name>sHookTimerId</name> = <call><name>::<name>SetTimer</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>TIMERPROC</name>)<name>HookTimerForPopups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>sHookTimerId</name></expr></argument>, <argument><expr>"Timer couldn't be created."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POPUP_ROLLUP_DEBUG_OUTPUT</name></cpp:ifdef>
int <expr_stmt><expr><name>gLastMsgCode</name> = 0</expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>MSGFEventMsgInfo</name></type> <name><name>gMSGFEvents</name><index>[]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Process Menu messages, rollup when popup is clicked.</comment>
<function><type><name>LRESULT</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>MozSpecialMsgFilter</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POPUP_ROLLUP_DEBUG_OUTPUT</name></cpp:ifdef>
  <if>if <condition>(<expr><name>sProcessHook</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>MSG</name>*</type> <name>pMsg</name> <init>= <expr>(<name>MSG</name>*)<name>lParam</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>inx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>gMSGFEvents</name><index>[<expr><name>inx</name></expr>]</index></name>.<name>mId</name> != <name>code</name> &amp;&amp; <name><name>gMSGFEvents</name><index>[<expr><name>inx</name></expr>]</index></name>.<name>mStr</name> != <name>NULL</name></expr>)</condition> <block>{
      <expr_stmt><expr><name>inx</name>++</expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>code</name> != <name>gLastMsgCode</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name><name>gMSGFEvents</name><index>[<expr><name>inx</name></expr>]</index></name>.<name>mId</name> == <name>code</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"MozSpecialMessageProc - code: 0x%X  - %s  hw: %p\n"</expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>gMSGFEvents</name><index>[<expr><name>inx</name></expr>]</index></name>.<name>mStr</name></expr></argument>, <argument><expr><name><name>pMsg</name>-&gt;<name>hwnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"MozSpecialMessageProc - code: 0x%X  - %d  hw: %p\n"</expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>gMSGFEvents</name><index>[<expr><name>inx</name></expr>]</index></name>.<name>mId</name></expr></argument>, <argument><expr><name><name>pMsg</name>-&gt;<name>hwnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></else></if>
      <expr_stmt><expr><name>gLastMsgCode</name> = <name>code</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>PrintEvent</name><argument_list>(<argument><expr><name><name>pMsg</name>-&gt;<name>message</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #ifdef POPUP_ROLLUP_DEBUG_OUTPUT</comment>

  <if>if <condition>(<expr><name>sProcessHook</name> &amp;&amp; <name>code</name> == <name>MSGF_MENU</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>MSG</name>*</type> <name>pMsg</name> <init>= <expr>(<name>MSG</name>*)<name>lParam</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ScheduleHookTimer</name><argument_list>( <argument><expr><name><name>pMsg</name>-&gt;<name>hwnd</name></name></expr></argument>, <argument><expr><name><name>pMsg</name>-&gt;<name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><call><name>::<name>CallNextHookEx</name></name><argument_list>(<argument><expr><name>sMsgFilterHook</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Process all mouse messages. Roll up when a click is in a native window</comment>
<comment type="line">// that doesn't have an nsIWidget.</comment>
<function><type><name>LRESULT</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>MozSpecialMouseProc</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>sProcessHook</name></expr>)</condition><then> <block>{
    <switch>switch <condition>(<expr><name>wParam</name></expr>)</condition> <block>{
      <case>case <expr><name>WM_LBUTTONDOWN</name></expr>:
      </case><case>case <expr><name>WM_RBUTTONDOWN</name></expr>:
      </case><case>case <expr><name>WM_MBUTTONDOWN</name></expr>:
      </case><case>case <expr><name>WM_MOUSEWHEEL</name></expr>:
      </case><case>case <expr><name>WM_MOUSEHWHEEL</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>MOUSEHOOKSTRUCT</name>*</type> <name>ms</name> <init>= <expr>(<name>MOUSEHOOKSTRUCT</name>*)<name>lParam</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>mozWin</name> <init>= <expr>(<name>nsIWidget</name>*)<call><name>GetNSWindowPtr</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>hwnd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mozWin</name></expr>)</condition><then> <block>{
          <comment type="line">// If this window is windowed plugin window, the mouse events are not</comment>
          <comment type="line">// sent to us.</comment>
          <if>if <condition>(<expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsWindow</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mozWin</name></expr></argument>)</argument_list></call>-&gt;<name>mWindowType</name> == <name>eWindowType_plugin</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ScheduleHookTimer</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>hwnd</name></name></expr></argument>, <argument><expr>(<name>UINT</name>)<name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><call><name>ScheduleHookTimer</name><argument_list>(<argument><expr><name><name>ms</name>-&gt;<name>hwnd</name></name></expr></argument>, <argument><expr>(<name>UINT</name>)<name>wParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      }</block>
    </case>}</block></switch>
  }</block></then></if>
  <return>return <expr><call><name>::<name>CallNextHookEx</name></name><argument_list>(<argument><expr><name>sCallMouseHook</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Process all messages. Roll up when the window is moving, or</comment>
<comment type="line">// is resizing or when maximized or mininized.</comment>
<function><type><name>LRESULT</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>MozSpecialWndProc</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POPUP_ROLLUP_DEBUG_OUTPUT</name></cpp:ifdef>
  <if>if <condition>(<expr><name>sProcessHook</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>CWPSTRUCT</name>*</type> <name>cwpt</name> <init>= <expr>(<name>CWPSTRUCT</name>*)<name>lParam</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PrintEvent</name><argument_list>(<argument><expr><name><name>cwpt</name>-&gt;<name>message</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>sProcessHook</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>CWPSTRUCT</name>*</type> <name>cwpt</name> <init>= <expr>(<name>CWPSTRUCT</name>*)<name>lParam</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>cwpt</name>-&gt;<name>message</name></name> == <name>WM_MOVING</name> ||
        <name><name>cwpt</name>-&gt;<name>message</name></name> == <name>WM_SIZING</name> ||
        <name><name>cwpt</name>-&gt;<name>message</name></name> == <name>WM_GETMINMAXINFO</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>ScheduleHookTimer</name><argument_list>(<argument><expr><name><name>cwpt</name>-&gt;<name>hwnd</name></name></expr></argument>, <argument><expr>(<name>UINT</name>)<name><name>cwpt</name>-&gt;<name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><call><name>::<name>CallNextHookEx</name></name><argument_list>(<argument><expr><name>sCallProcHook</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Register the special "hooks" for dropdown processing.</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>RegisterSpecialDropdownHooks</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>sMsgFilterHook</name></expr></argument>, <argument><expr>"sMsgFilterHook must be NULL!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>sCallProcHook</name></expr></argument>,  <argument><expr>"sCallProcHook must be NULL!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***************** Installing Msg Hooks ***************\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//HMODULE hMod = GetModuleHandle("gkwidget.dll");</comment>

  <comment type="line">// Install msg hook for moving the window and resizing</comment>
  <if>if <condition>(<expr>!<name>sMsgFilterHook</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** Hooking sMsgFilterHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sMsgFilterHook</name> = <call><name>SetWindowsHookEx</name><argument_list>(<argument><expr><name>WH_MSGFILTER</name></expr></argument>, <argument><expr><name>MozSpecialMsgFilter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POPUP_ROLLUP_DEBUG_OUTPUT</name></cpp:ifdef>
    <if>if <condition>(<expr>!<name>sMsgFilterHook</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"***** SetWindowsHookEx is NOT installed for WH_MSGFILTER!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>

  <comment type="line">// Install msg hook for menus</comment>
  <if>if <condition>(<expr>!<name>sCallProcHook</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** Hooking sCallProcHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sCallProcHook</name>  = <call><name>SetWindowsHookEx</name><argument_list>(<argument><expr><name>WH_CALLWNDPROC</name></expr></argument>, <argument><expr><name>MozSpecialWndProc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POPUP_ROLLUP_DEBUG_OUTPUT</name></cpp:ifdef>
    <if>if <condition>(<expr>!<name>sCallProcHook</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"***** SetWindowsHookEx is NOT installed for WH_CALLWNDPROC!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>

  <comment type="line">// Install msg hook for the mouse</comment>
  <if>if <condition>(<expr>!<name>sCallMouseHook</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** Hooking sCallMouseHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sCallMouseHook</name>  = <call><name>SetWindowsHookEx</name><argument_list>(<argument><expr><name>WH_MOUSE</name></expr></argument>, <argument><expr><name>MozSpecialMouseProc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POPUP_ROLLUP_DEBUG_OUTPUT</name></cpp:ifdef>
    <if>if <condition>(<expr>!<name>sCallMouseHook</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"***** SetWindowsHookEx is NOT installed for WH_MOUSE!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
}</block></function>

<comment type="line">// Unhook special message hooks for dropdowns.</comment>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>UnregisterSpecialDropdownHooks</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***************** De-installing Msg Hooks ***************\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>sCallProcHook</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** Unhooking sCallProcHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>UnhookWindowsHookEx</name></name><argument_list>(<argument><expr><name>sCallProcHook</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** UnhookWindowsHookEx failed for sCallProcHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sCallProcHook</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>sMsgFilterHook</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** Unhooking sMsgFilterHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>UnhookWindowsHookEx</name></name><argument_list>(<argument><expr><name>sMsgFilterHook</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** UnhookWindowsHookEx failed for sMsgFilterHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sMsgFilterHook</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>sCallMouseHook</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** Unhooking sCallMouseHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>::<name>UnhookWindowsHookEx</name></name><argument_list>(<argument><expr><name>sCallMouseHook</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DISPLAY_NMM_PRT</name><argument_list>(<argument><expr>"***** UnhookWindowsHookEx failed for sCallMouseHook!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sCallMouseHook</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// This timer is designed to only fire one time at most each time a "hook" function</comment>
<comment type="line">// is used to rollup the dropdown. In some cases, the timer may be scheduled from the</comment>
<comment type="line">// hook, but that hook event or a subsequent event may roll up the dropdown before</comment>
<comment type="line">// this timer function is executed.</comment>
<comment type="line">//</comment>
<comment type="line">// For example, if an MFC control takes focus, the combobox will lose focus and rollup</comment>
<comment type="line">// before this function fires.</comment>
<function><type><name>VOID</name> <name>CALLBACK</name></type> <name><name>nsWindow</name>::<name>HookTimerForPopups</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hwnd</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>uMsg</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>idEvent</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>dwTime</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>sHookTimerId</name> != 0</expr>)</condition><then> <block>{
    <comment type="line">// if the window is NULL then we need to use the ID to kill the timer</comment>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>status</name> <init>= <expr><call><name>::<name>KillTimer</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sHookTimerId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr>"Hook Timer was not killed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sHookTimerId</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>sRollupMsgId</name> != 0</expr>)</condition><then> <block>{
    <comment type="line">// Note: DealWithPopups does the check to make sure that</comment>
    <comment type="line">// sRollupListener and sRollupWidget are not NULL</comment>
    <decl_stmt><decl><type><name>LRESULT</name></type> <name>popupHandlingResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsAutoRollup</name></type> <name>autoRollup</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DealWithPopups</name><argument_list>(<argument><expr><name>sRollupMsgWnd</name></expr></argument>, <argument><expr><name>sRollupMsgId</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>popupHandlingResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sRollupMsgId</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sRollupMsgWnd</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WinCE</comment>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsDifferentThreadWindow</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>::<name>GetCurrentThreadId</name></name><argument_list>()</argument_list></call> != <call><name>::<name>GetWindowThreadProcessId</name></name><argument_list>(<argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsWindow</name>::<name>EventIsInsideWindow</name></name><parameter_list>(<param><decl><type><name>UINT</name></type> <name>Msg</name></decl></param>, <param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>RECT</name></type> <name>r</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <if>if <condition>(<expr><name>Msg</name> == <name>WM_ACTIVATEAPP</name></expr>)</condition><then>
    <comment type="line">// don't care about activation/deactivation</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if>if <condition>(<expr><name>Msg</name> == <name>WM_ACTIVATE</name></expr>)</condition><then>
    <comment type="line">// but on Windows CE we do care about</comment>
    <comment type="line">// activation/deactivation because there doesn't exist</comment>
    <comment type="line">// cancelable Mouse Activation events</comment>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name><name>aWindow</name>-&gt;<name>mWnd</name></name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>pos</name> <init>= <expr><call><name>::<name>GetMessagePos</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>POINT</name></type> <name>mp</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>mp</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mp</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// was the event inside this window?</comment>
  <return>return <expr>(<name>PRBool</name>) <call><name>PtInRect</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Handle events that may cause a popup (combobox, XPMenu, etc) to need to rollup.</comment>
<function><type><name>BOOL</name></type>
<name><name>nsWindow</name>::<name>DealWithPopups</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>inWnd</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>inMsg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>inWParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>inLParam</name></decl></param>, <param><decl><type><name>LRESULT</name>*</type> <name>outResult</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>sRollupListener</name> &amp;&amp; <name>sRollupWidget</name> &amp;&amp; <call><name>::<name>IsWindowVisible</name></name><argument_list>(<argument><expr><name>inWnd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

    <if>if <condition>(<expr><name>inMsg</name> == <name>WM_LBUTTONDOWN</name> || <name>inMsg</name> == <name>WM_RBUTTONDOWN</name> || <name>inMsg</name> == <name>WM_MBUTTONDOWN</name> ||
        <name>inMsg</name> == <name>WM_MOUSEWHEEL</name> || <name>inMsg</name> == <name>WM_MOUSEHWHEEL</name> || <name>inMsg</name> == <name>WM_ACTIVATE</name> ||
        (<name>inMsg</name> == <name>WM_KILLFOCUS</name> &amp;&amp; <call><name>IsDifferentThreadWindow</name><argument_list>(<argument><expr>(<name>HWND</name>)<name>inWParam</name></expr></argument>)</argument_list></call>)
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
        ||
        <name>inMsg</name> == <name>WM_NCRBUTTONDOWN</name> ||
        <name>inMsg</name> == <name>WM_MOVING</name> ||
        <name>inMsg</name> == <name>WM_SIZING</name> ||
        <name>inMsg</name> == <name>WM_NCLBUTTONDOWN</name> ||
        <name>inMsg</name> == <name>WM_NCMBUTTONDOWN</name> ||
        <name>inMsg</name> == <name>WM_MOUSEACTIVATE</name> ||
        <name>inMsg</name> == <name>WM_ACTIVATEAPP</name> ||
        <name>inMsg</name> == <name>WM_MENUSELECT</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><then>
    <block>{
      <comment type="line">// Rollup if the event is outside the popup.</comment>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>rollup</name> <init>= <expr>!<call><name><name>nsWindow</name>::<name>EventIsInsideWindow</name></name><argument_list>(<argument><expr><name>inMsg</name></expr></argument>, <argument><expr>(<name>nsWindow</name>*)<name>sRollupWidget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>rollup</name> &amp;&amp; (<name>inMsg</name> == <name>WM_MOUSEWHEEL</name> || <name>inMsg</name> == <name>WM_MOUSEHWHEEL</name>)</expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name><name>sRollupListener</name>-&gt;<name>ShouldRollupOnMouseWheelEvent</name></name><argument_list>(<argument><expr>&amp;<name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>outResult</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="line">// If we're dealing with menus, we probably have submenus and we don't</comment>
      <comment type="line">// want to rollup if the click is in a parent menu of the current submenu.</comment>
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>popupsToRollup</name> <init>= <expr><name>PR_UINT32_MAX</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>rollup</name></expr>)</condition><then> <block>{
        <if>if <condition>( <expr><name>sMenuRollup</name></expr> )</condition><then> <block>{
          <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsIWidget</name>*</expr></argument>, <argument><expr>5</expr></argument>&gt;</argument_list></name></type> <name>widgetChain</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRUint32</name></type> <name>sameTypeCount</name> <init>= <expr><call><name><name>sMenuRollup</name>-&gt;<name>GetSubmenuWidgetChain</name></name><argument_list>(<argument><expr>&amp;<name>widgetChain</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for ( <init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>widgetChain</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> ) <block>{
            <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>widget</name> <init>= <expr><name><name>widgetChain</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>( <expr><call><name><name>nsWindow</name>::<name>EventIsInsideWindow</name></name><argument_list>(<argument><expr><name>inMsg</name></expr></argument>, <argument><expr>(<name>nsWindow</name>*)<name>widget</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
              <comment type="line">// don't roll up if the mouse event occured within a menu of the</comment>
              <comment type="line">// same type. If the mouse event occured in a menu higher than</comment>
              <comment type="line">// that, roll up, but pass the number of popups to Rollup so</comment>
              <comment type="line">// that only those of the same type close up.</comment>
              <if>if <condition>(<expr><name>i</name> &lt; <name>sameTypeCount</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rollup</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
              }</block></then>
              <else>else <block>{
                <expr_stmt><expr><name>popupsToRollup</name> = <name>sameTypeCount</name></expr>;</expr_stmt>
              }</block></else></if>
              <break>break;</break>
            }</block></then></if>
          }</block></for> <comment type="line">// foreach parent menu widget</comment>
        }</block></then></if> <comment type="line">// if rollup listener knows about menus</comment>
      }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
      <if>if <condition>(<expr><name>inMsg</name> == <name>WM_MOUSEACTIVATE</name> &amp;&amp; <name>popupsToRollup</name> == <name>PR_UINT32_MAX</name></expr>)</condition><then> <block>{
        <comment type="line">// Prevent the click inside the popup from causing a change in window</comment>
        <comment type="line">// activation. Since the popup is shown non-activated, we need to eat</comment>
        <comment type="line">// any requests to activate the window while it is displayed. Windows</comment>
        <comment type="line">// will automatically activate the popup on the mousedown otherwise.</comment>
        <if>if <condition>(<expr>!<name>rollup</name></expr>)</condition><then> <block>{
          <expr_stmt><expr>*<name>outResult</name> = <name>MA_NOACTIVATE</name></expr>;</expr_stmt>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then>
        <else>else
        <block>{
          <decl_stmt><decl><type><name>UINT</name></type> <name>uMsg</name> <init>= <expr><call><name>HIWORD</name><argument_list>(<argument><expr><name>inLParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>uMsg</name> == <name>WM_MOUSEMOVE</name></expr>)</condition><then>
          <block>{
            <comment type="line">// WM_MOUSEACTIVATE cause by moving the mouse - X-mouse (eg. TweakUI)</comment>
            <comment type="line">// must be enabled in Windows.</comment>
            <expr_stmt><expr><call><name><name>sRollupListener</name>-&gt;<name>ShouldRollupOnMouseActivate</name></name><argument_list>(<argument><expr>&amp;<name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>rollup</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr>*<name>outResult</name> = <name>MA_NOACTIVATE</name></expr>;</expr_stmt>
              <return>return <expr>true</expr>;</return>
            }</block></then></if>
          }</block></then></if>
        }</block></else></if>
      }</block></then>
      <comment type="line">// if we've still determined that we should still rollup everything, do it.</comment>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>( <expr><name>rollup</name></expr> )</condition><then> <block>{
        <comment type="line">// sRollupConsumeEvent may be modified by</comment>
        <comment type="line">// nsIRollupListener::Rollup.</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>consumeRollupEvent</name> <init>= <expr><name>sRollupConsumeEvent</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// only need to deal with the last rollup for left mouse down events.</comment>
        <expr_stmt><expr><call><name><name>sRollupListener</name>-&gt;<name>Rollup</name></name><argument_list>(<argument><expr><name>popupsToRollup</name></expr></argument>, <argument><expr><name>inMsg</name> == <name>WM_LBUTTONDOWN</name> ? &amp;<name>mLastRollup</name> : <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Tell hook to stop processing messages</comment>
        <expr_stmt><expr><name>sProcessHook</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sRollupMsgId</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>sRollupMsgWnd</name> = <name>NULL</name></expr>;</expr_stmt>

        <comment type="line">// return TRUE tells Windows that the event is consumed,</comment>
        <comment type="line">// false allows the event to be dispatched</comment>
        <comment type="line">//</comment>
        <comment type="line">// So if we are NOT supposed to be consuming events, let it go through</comment>
        <if>if <condition>(<expr><name>consumeRollupEvent</name> &amp;&amp; <name>inMsg</name> != <name>WM_RBUTTONDOWN</name></expr>)</condition><then> <block>{
          <expr_stmt><expr>*<name>outResult</name> = <name>TRUE</name></expr>;</expr_stmt>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
        <comment type="line">// if we are only rolling up some popups, don't activate and don't let</comment>
        <comment type="line">// the event go through. This prevents clicks menus higher in the</comment>
        <comment type="line">// chain from opening when a context menu is open</comment>
        <if>if <condition>(<expr><name>popupsToRollup</name> != <name>PR_UINT32_MAX</name> &amp;&amp; <name>inMsg</name> == <name>WM_MOUSEACTIVATE</name></expr>)</condition><then> <block>{
          <expr_stmt><expr>*<name>outResult</name> = <name>MA_NOACTIVATEANDEAT</name></expr>;</expr_stmt>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if></else></if>
    }</block></then></if> <comment type="line">// if event that might trigger a popup to rollup</comment>
  }</block></then></if> <comment type="line">// if rollup listeners registered</comment>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: Misc. utility methods and functions.
 **
 ** General use.
 **
 **************************************************************
 **************************************************************/</comment>

<comment type="line">// nsModifierKeyState used in various character processing. </comment>
<constructor><name><name>nsModifierKeyState</name>::<name>nsModifierKeyState</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mIsShiftDown</name>   = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsControlDown</name> = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_CONTROL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsAltDown</name>     = <call><name>IS_VK_DOWN</name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>


<function><type><name>PRInt32</name></type> <name><name>nsWindow</name>::<name>GetWindowsVersion</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
  <return>return <expr>0x500</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRInt32</name></type> <name>version</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>didCheck</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>didCheck</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>didCheck</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>OSVERSIONINFOEX</name></type> <name>osInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>osInfo</name>.<name>dwOSVersionInfoSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>OSVERSIONINFOEX</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="line">// This cast is safe and supposed to be here, don't worry</comment>
    <expr_stmt><expr><call><name>::<name>GetVersionEx</name></name><argument_list>(<argument><expr>(<name>OSVERSIONINFO</name>*)&amp;<name>osInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>version</name> = (<name><name>osInfo</name>.<name>dwMajorVersion</name></name> &amp; 0xff) &lt;&lt; 8 | (<name><name>osInfo</name>.<name>dwMinorVersion</name></name> &amp; 0xff)</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>version</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line">// Note that the result of GetTopLevelWindow method can be different from the</comment>
<comment type="line">// result of GetTopLevelHWND method.  The result can be non-floating window.</comment>
<comment type="line">// Because our top level window may be contained in another window which is</comment>
<comment type="line">// not managed by us.</comment>
<function><type><name>nsWindow</name>*</type> <name><name>nsWindow</name>::<name>GetTopLevelWindow</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aStopOnDialogOrPopup</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>curWindow</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>PR_TRUE</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name>aStopOnDialogOrPopup</name></expr>)</condition><then> <block>{
      <switch>switch <condition>(<expr><name><name>curWindow</name>-&gt;<name>mWindowType</name></name></expr>)</condition> <block>{
        <case>case <expr><name>eWindowType_dialog</name></expr>:
        </case><case>case <expr><name>eWindowType_popup</name></expr>:
          <return>return <expr><name>curWindow</name></expr>;</return>
      </case>}</block></switch>
    }</block></then></if>

    <comment type="line">// Retrieve the top level parent or owner window</comment>
    <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>parentWindow</name> <init>= <expr><call><name><name>curWindow</name>-&gt;<name>GetParentWindow</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>parentWindow</name></expr>)</condition><then>
      <return>return <expr><name>curWindow</name></expr>;</return></then></if>

    <expr_stmt><expr><name>curWindow</name> = <name>parentWindow</name></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="line">// Note that the result of GetTopLevelHWND can be different from the result</comment>
<comment type="line">// of GetTopLevelWindow method.  Because this is checking whether the window</comment>
<comment type="line">// is top level only in Win32 window system.  Therefore, the result window</comment>
<comment type="line">// may not be managed by us.</comment>
<function><type><name>HWND</name></type> <name><name>nsWindow</name>::<name>GetTopLevelHWND</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aStopOnDialogOrPopup</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HWND</name></type> <name>curWnd</name> <init>= <expr><name>aWnd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HWND</name></type> <name>topWnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HWND</name></type> <name>upWnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>curWnd</name></expr>)</condition> <block>{
    <expr_stmt><expr><name>topWnd</name> = <name>curWnd</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aStopOnDialogOrPopup</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>style</name> <init>= <expr><call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>curWnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>VERIFY_WINDOW_STYLE</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>!(<name>style</name> &amp; <name>WS_CHILD</name>)</expr>)</condition><then> <comment type="line">// first top-level window</comment>
        <break>break;</break></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>upWnd</name> = <call><name>::<name>GetParent</name></name><argument_list>(<argument><expr><name>curWnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Parent or owner (if has no parent)</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
    <comment type="line">// For dialog windows, we want just the parent, not the owner.</comment>
    <comment type="line">// For other/popup windows, we want to find the first owner/parent</comment>
    <comment type="line">// that's a dialog and/or has an owner.</comment>
    <if>if <condition>(<expr><name>upWnd</name> &amp;&amp; <call><name>::<name>GetWindow</name></name><argument_list>(<argument><expr><name>curWnd</name></expr></argument>, <argument><expr><name>GW_OWNER</name></expr></argument>)</argument_list></call> == <name>upWnd</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>style</name> <init>= <expr><call><name>::<name>GetWindowLongPtrW</name></name><argument_list>(<argument><expr><name>curWnd</name></expr></argument>, <argument><expr><name>GWL_STYLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>style</name> &amp; <name>WS_DLGFRAME</name>) != 0</expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>curWnd</name> = <name>upWnd</name></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>topWnd</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name> <name>CALLBACK</name></type> <name>gEnumWindowsProc</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hwnd</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>DWORD</name></type> <name>pid</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetWindowThreadProcessId</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>pid</name> == <call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>::<name>IsWindowVisible</name></name><argument_list>(<argument><expr><name>hwnd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>gWindowsVisible</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsWindow</name>::<name>CanTakeFocus</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>gWindowsVisible</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>EnumWindows</name><argument_list>(<argument><expr><name>gEnumWindowsProc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>gWindowsVisible</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>HWND</name></type> <name>fgWnd</name> <init>= <expr><call><name>::<name>GetForegroundWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>fgWnd</name></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>pid</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetWindowThreadProcessId</name><argument_list>(<argument><expr><name>fgWnd</name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pid</name> == <call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name><name>nsWindow</name>::<name>InitTrackPointHack</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// Init Trackpoint Hack</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>lHackValue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>lResult</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>WCHAR</name></type> <name><name>wstrKeys</name><index>[]</index><index>[<expr>40</expr>]</index></name> <init>= <expr><block>{<expr>L"Software\\Lenovo\\TrackPoint"</expr>,
                                <expr>L"Software\\Lenovo\\UltraNav"</expr>,
                                <expr>L"Software\\Alps\\Apoint\\TrackPoint"</expr>,
                                <expr>L"Software\\Synaptics\\SynTPEnh\\UltraNavUSB"</expr>,
                                <expr>L"Software\\Synaptics\\SynTPEnh\\UltraNavPS2"</expr>}</block></expr></init></decl>;</decl_stmt>    
  <comment type="line">// If anything fails turn the hack off</comment>
  <expr_stmt><expr><name>sTrackPointHack</name> = false</expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>prefs</name><argument_list>(<argument><expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if<condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>prefs</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>prefs</name>-&gt;<name>GetIntPref</name></name><argument_list>(<argument><expr>"ui.trackpoint_hack.enabled"</expr></argument>, <argument><expr>&amp;<name>lHackValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>lHackValue</name></expr>)</condition> <block>{
      <comment type="line">// 0 means hack disabled</comment>
      <case>case <expr>0</expr>:
        <break>break;</break>
      <comment type="line">// 1 means hack enabled</comment>
      </case><case>case <expr>1</expr>:
        <expr_stmt><expr><name>sTrackPointHack</name> = true</expr>;</expr_stmt>
        <break>break;</break>
      <comment type="line">// -1 means autodetect</comment>
      </case><case>case <expr>-1</expr>:
        <for>for(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>wstrKeys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <decl_stmt><decl><type><name>HKEY</name></type> <name>hKey</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>lResult</name> = <call><name>::<name>RegOpenKeyExW</name></name><argument_list>(<argument><expr><name>HKEY_CURRENT_USER</name></expr></argument>, <argument><expr>(<name>LPCWSTR</name>)&amp;<name><name>wstrKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                    <argument><expr>0</expr></argument>, <argument><expr><name>KEY_READ</name></expr></argument>, <argument><expr>&amp;<name>hKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>::<name>RegCloseKey</name></name><argument_list>(<argument><expr><name>hKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><name>lResult</name> == <name>ERROR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="line">// If we detected a registry key belonging to a TrackPoint driver</comment>
            <comment type="line">// Turn on the hack</comment>
            <expr_stmt><expr><name>sTrackPointHack</name> = true</expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></for>
        <break>break;</break>
      <comment type="line">// Shouldn't be any other values, but treat them as disabled</comment>
      </case><default>default:
        <break>break;</break>
    </default>}</block></switch>
  }</block></then></if>
  <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #if !defined(WINCE)</comment>

<function><type><name>LPARAM</name></type> <name><name>nsWindow</name>::<name>lParamToScreen</name></name><parameter_list>(<param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>POINT</name></type> <name>pt</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pt</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>ClientToScreen</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>MAKELPARAM</name><argument_list>(<argument><expr><name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LPARAM</name></type> <name><name>nsWindow</name>::<name>lParamToClient</name></name><parameter_list>(<param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>POINT</name></type> <name>pt</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pt</name>.<name>x</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name>.<name>y</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>ScreenToClient</name></name><argument_list>(<argument><expr><name>mWnd</name></expr></argument>, <argument><expr>&amp;<name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>MAKELPARAM</name><argument_list>(<argument><expr><name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**************************************************************
 **************************************************************
 **
 ** BLOCK: ChildWindow impl.
 **
 ** Child window overrides.
 **
 **************************************************************
 **************************************************************/</comment>

<comment type="line">// Deal with all sort of mouse event</comment>
<function><type><name>PRBool</name></type> <name><name>ChildWindow</name>::<name>DispatchMouseEvent</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aEventType</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type> <name>aIsContextMenuKey</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>aButton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>nsnull</name> == <name>mEventCallback</name></expr>)</condition><then> <block>{
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

  <switch>switch <condition>(<expr><name>aEventType</name></expr>)</condition> <block>{
    <case>case <expr><name>NS_MOUSE_BUTTON_DOWN</name></expr>:
      <expr_stmt><expr><call><name>CaptureMouse</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <comment type="line">// NS_MOUSE_MOVE and NS_MOUSE_EXIT are here because we need to make sure capture flag</comment>
    <comment type="line">// isn't left on after a drag where we wouldn't see a button up message (see bug 324131).</comment>
    </case><case>case <expr><name>NS_MOUSE_BUTTON_UP</name></expr>:
    </case><case>case <expr><name>NS_MOUSE_MOVE</name></expr>:
    </case><case>case <expr><name>NS_MOUSE_EXIT</name></expr>:
      <if>if <condition>(<expr>!(<name>wParam</name> &amp; (<name>MK_LBUTTON</name> | <name>MK_MBUTTON</name> | <name>MK_RBUTTON</name>)) &amp;&amp; <name>mIsInMouseCapture</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>CaptureMouse</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <break>break;</break>

    </case><default>default:
      <break>break;</break>

  </default>}</block></switch> <comment type="line">// switch</comment>

  <return>return <expr><call><name><name>nsWindow</name>::<name>DispatchMouseEvent</name></name><argument_list>(<argument><expr><name>aEventType</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>,
                                      <argument><expr><name>aIsContextMenuKey</name></expr></argument>, <argument><expr><name>aButton</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// return the style for a child nsWindow</comment>
<function><type><name>DWORD</name></type> <name><name>ChildWindow</name>::<name>WindowStyle</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>DWORD</name></type> <name>style</name> <init>= <expr><name>WS_CLIPCHILDREN</name> | <call><name><name>nsWindow</name>::<name>WindowStyle</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!(<name>style</name> &amp; <name>WS_POPUP</name>)</expr>)</condition><then>
    <expr_stmt><expr><name>style</name> |= <name>WS_CHILD</name></expr>;</expr_stmt></then></if> <comment type="line">// WS_POPUP and WS_CHILD are mutually exclusive.</comment>
  <expr_stmt><expr><call><name>VERIFY_WINDOW_STYLE</name><argument_list>(<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>style</name></expr>;</return>
}</block></function>
</unit>
