<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00511316922b2abe5674d6d2f84de5da5c7e682d.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Robert Churchill &lt;rjc@netscape.com&gt;
 *   David Hyatt &lt;hyatt@netscape.com&gt;
 *   Chris Waterson &lt;waterson@netscape.com&gt;
 *   Pierre Phaneuf &lt;pp@ludusdesign.com&gt;
 *   Joe Hewitt &lt;hewitt@netscape.com&gt;
 *   Neil Deakin &lt;enndeakin@sympatico.ca&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRDFNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRDFObserver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRDFRemoteDataSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRDFService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRDFCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsINameSpaceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIXULDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsUnicharUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAttrName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rdf.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentTestNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRDFConInstanceTestNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRDFConMemberTestNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRDFPropertyTestNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsInstantiationNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRDFTestNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXULContentUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXULTemplateBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXULTemplateResultRDF.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXULTemplateResultSetRDF.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXULTemplateQueryProcessorRDF.h"</cpp:file></cpp:include>

<comment type="line">//----------------------------------------------------------------------</comment>

<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kRDFContainerUtilsCID</name></expr></argument>,      <argument><expr><name>NS_RDFCONTAINERUTILS_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kRDFServiceCID</name></expr></argument>,             <argument><expr><name>NS_RDFSERVICE_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_TYPE_INTEGER</name></cpp:macro>  <cpp:value>"Integer"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>nsrefcnt</name></type>                  <name><name>nsXULTemplateQueryProcessorRDF</name>::<name>gRefCnt</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsIRDFService</name>*</type>            <name><name>nsXULTemplateQueryProcessorRDF</name>::<name>gRDFService</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsIRDFContainerUtils</name>*</type>     <name><name>nsXULTemplateQueryProcessorRDF</name>::<name>gRDFContainerUtils</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsIRDFResource</name>*</type>           <name><name>nsXULTemplateQueryProcessorRDF</name>::<name>kNC_BookmarkSeparator</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsIRDFResource</name>*</type>           <name><name>nsXULTemplateQueryProcessorRDF</name>::<name>kRDF_type</name></name></decl>;</decl_stmt>

<macro><name>NS_IMPL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>nsXULTemplateQueryProcessorRDF</argument>)</argument_list></macro>
<macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_0</name><argument_list>(<argument>nsXULTemplateQueryProcessorRDF</argument>)</argument_list></macro>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PLDHashOperator</argument>)</argument_list></macro>
<macro><name>BindingDependenciesTraverser</name><argument_list>(<argument>nsISupports* key</argument>,
                             <argument>nsCOMArray&lt;nsXULTemplateResultRDF&gt;* array</argument>,
                             <argument>void* userArg</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>nsCycleCollectionTraversalCallback</name> *</type><name>cb</name> <init>= 
        <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsCycleCollectionTraversalCallback</name>*</expr></argument>, <argument><expr><name>userArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name><name>array</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>cb</name>-&gt;<name>NoteXPCOMChild</name></name><argument_list>(<argument><expr><call><name><name>array</name>-&gt;<name>ObjectAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PLDHashOperator</argument>)</argument_list></macro>
<macro><name>MemoryElementTraverser</name><argument_list>(<argument>const PRUint32&amp; key</argument>,
                       <argument>nsCOMArray&lt;nsXULTemplateResultRDF&gt;* array</argument>,
                       <argument>void* userArg</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>nsCycleCollectionTraversalCallback</name> *</type><name>cb</name> <init>= 
        <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsCycleCollectionTraversalCallback</name>*</expr></argument>, <argument><expr><name>userArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name><name>array</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>cb</name>-&gt;<name>NoteXPCOMChild</name></name><argument_list>(<argument><expr><call><name><name>array</name>-&gt;<name>ObjectAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block>

<macro><name>PR_STATIC_CALLBACK</name><argument_list>(<argument>PLDHashOperator</argument>)</argument_list></macro>
<macro><name>RuleToBindingTraverser</name><argument_list>(<argument>nsISupports* key</argument>, <argument>RDFBindingSet* binding</argument>, <argument>void* userArg</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>nsCycleCollectionTraversalCallback</name> *</type><name>cb</name> <init>= 
        <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsCycleCollectionTraversalCallback</name>*</expr></argument>, <argument><expr><name>userArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>cb</name>-&gt;<name>NoteXPCOMChild</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block>

<macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN</name><argument_list>(<argument>nsXULTemplateQueryProcessorRDF</argument>)</argument_list></macro>
    <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mDB</argument>)</argument_list></macro>
    <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mLastRef</argument>)</argument_list></macro>
    <if>if <condition>(<expr><call><name><name>tmp</name>-&gt;<name>mBindingDependencies</name>.<name>IsInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>tmp</name>-&gt;<name>mBindingDependencies</name>.<name>EnumerateRead</name></name><argument_list>(<argument><expr><name>BindingDependenciesTraverser</name></expr></argument>,
                                                <argument><expr>&amp;<name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>tmp</name>-&gt;<name>mMemoryElementToResultMap</name>.<name>IsInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>tmp</name>-&gt;<name>mMemoryElementToResultMap</name>.<name>EnumerateRead</name></name><argument_list>(<argument><expr><name>MemoryElementTraverser</name></expr></argument>,
                                                     <argument><expr>&amp;<name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>tmp</name>-&gt;<name>mRuleToBindingsMap</name>.<name>IsInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>tmp</name>-&gt;<name>mRuleToBindingsMap</name>.<name>EnumerateRead</name></name><argument_list>(<argument><expr><name>RuleToBindingTraverser</name></expr></argument>, <argument><expr>&amp;<name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY</name><argument_list>(<argument>mQueries</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</name></type>

<name>NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsXULTemplateQueryProcessorRDF</name></expr></argument>,
                                          <argument><expr><name>nsIXULTemplateQueryProcessor</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsXULTemplateQueryProcessorRDF</name></expr></argument>,
                                           <argument><expr><name>nsIXULTemplateQueryProcessor</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument><expr><name>nsXULTemplateQueryProcessorRDF</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsIXULTemplateQueryProcessor</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsIRDFObserver</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_MAP_ENTRY_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsISupports</name></expr></argument>, <argument><expr><name>nsIXULTemplateQueryProcessor</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION</name><argument_list>(<argument><expr><name>nsXULTemplateQueryProcessorRDF</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_END</name>

<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>nsXULTemplateQueryProcessorRDF</name></name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
    <range>: <expr><call><name>mDB</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></range>,
      <name>mBuilder</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></decl>,
      <decl><type ref="prev"/><name>mQueryProcessorRDFInited</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></decl>,
      <decl><type ref="prev"/><name>mGenerationStarted</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></decl>,
      <decl><type ref="prev"/><name>mUpdateBatchNest</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></decl>,
      <decl><type ref="prev"/><name>mSimpleRuleMemberTest</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>gRefCnt</name>++</expr></argument>;
}</argument_list>

<name><name>nsXULTemplateQueryProcessorRDF</name>::~<name>nsXULTemplateQueryProcessorRDF</name></name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<argument_list>{
    if <argument><expr>(--<name>gRefCnt</name> == 0) <block>{
        <expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>gRDFService</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>gRDFContainerUtils</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>kNC_BookmarkSeparator</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>kRDF_type</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></argument>
}</argument_list>

<name>nsresult</name>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>InitGlobals</name></name><argument_list>()</argument_list>
<argument_list>{
    <argument><expr><name>nsresult</name> <name>rv</name></expr></argument>;

    <comment type="line">// Initialize the global shared reference to the service</comment>
    <comment type="line">// manager and get some shared resource objects.</comment>
    if <argument><expr>(!<name>gRDFService</name>) <block>{
        <expr><name>rv</name> = <call><name>CallGetService</name><argument_list>(<argument><expr><name>kRDFServiceCID</name></expr></argument>, <argument><expr>&amp;<name>gRDFService</name></expr></argument>)</argument_list></call></expr>;
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></expr></argument>

    <if>if <condition>(<expr>!<name>gRDFContainerUtils</name></expr>)</condition><then> <expr_stmt><expr><block>{
        <expr><name>rv</name> = <call><name>CallGetService</name><argument_list>(<argument><expr><name>kRDFContainerUtilsCID</name></expr></argument>, <argument><expr>&amp;<name>gRDFContainerUtils</name></expr></argument>)</argument_list></call></expr>;</block></expr></expr_stmt></then></if></argument_list></decl></decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }
  
    if <expr_stmt><expr>(!<name>kNC_BookmarkSeparator</name>) <block>{
        <expr><call><name><name>gRDFService</name>-&gt;<name>GetResource</name></name><argument_list>(
          <argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr><name>NC_NAMESPACE_URI</name> "BookmarkSeparator"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>&amp;<name>kNC_BookmarkSeparator</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr></expr_stmt>

    <if>if <condition>(<expr>!<name>kRDF_type</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>gRDFService</name>-&gt;<name>GetResource</name></name><argument_list>(
          <argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr><name>RDF_NAMESPACE_URI</name> "type"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>&amp;<name>kRDF_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">//</comment>
<comment type="line">// nsIXULTemplateQueryProcessor interface</comment>
<comment type="line">//</comment>


NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>InitializeForBuilding</name></name>(<name>nsISupports</name>* <name>aDatasource</name>,
                                                      <name>nsIXULTemplateBuilder</name>* <name>aBuilder</name>,
                                                      <name>nsIDOMNode</name>* <name>aRootNode</name>)
<block>{
    <if>if <condition>(<expr>!<name>mQueryProcessorRDFInited</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>InitGlobals</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<call><name><name>mMemoryElementToResultMap</name>.<name>IsInitialized</name></name><argument_list>()</argument_list></call> &amp;&amp;
            !<call><name><name>mMemoryElementToResultMap</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name><name>mBindingDependencies</name>.<name>IsInitialized</name></name><argument_list>()</argument_list></call> &amp;&amp;
            !<call><name><name>mBindingDependencies</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name><name>mRuleToBindingsMap</name>.<name>IsInitialized</name></name><argument_list>()</argument_list></call> &amp;&amp;
            !<call><name><name>mRuleToBindingsMap</name>.<name>Init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name><name>bucketsizes</name><index>[]</index></name> <init>= <expr><block>{
            <expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>nsRDFConMemberTestNode</name>::<name>Element</name></name></expr></argument>)</argument_list></sizeof></expr>,
            <expr>sizeof (<name><name>nsRDFPropertyTestNode</name>::<name>Element</name></name>)</expr>
        }</block></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mPool</name>.<name>Init</name></name><argument_list>(<argument><expr>"nsXULTemplateQueryProcessorRDF"</expr></argument>, <argument><expr><name>bucketsizes</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>256</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>mQueryProcessorRDFInited</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt/></block></then></if>}</block></expr></expr_stmt>

    <comment type="line">// don't do anything if generation has already been done</comment>
    <if>if <condition>(<expr><name>mGenerationStarted</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mDB</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aDatasource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mBuilder</name> = <name>aBuilder</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ComputeContainmentProperties</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Add ourselves as a datasource observer</comment>
    <if>if <condition>(<expr><name>mDB</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mDB</name>-&gt;<name>AddObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>Done</name></name>()
<block>{
    <if>if <condition>(<expr>!<name>mQueryProcessorRDFInited</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if></block></expr></expr_stmt>

    <if>if <condition>(<expr><name>mDB</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mDB</name>-&gt;<name>RemoveObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>mDB</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mBuilder</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mRefVariable</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mLastRef</name> = <name>nsnull</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mGenerationStarted</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mUpdateBatchNest</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mContainmentProperties</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name><name>ReteNodeSet</name>::<name>Iterator</name></name></type> <name>node</name> <init>= <expr><call><name><name>mAllTests</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>node</name> != <call><name><name>mAllTests</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>node</name></expr></incr>)
        <expr_stmt><expr>delete *<name>node</name></expr>;</expr_stmt></for>

    <expr_stmt><expr><call><name><name>mAllTests</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mRDFTests</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mQueries</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mSimpleRuleMemberTest</name> = <name>nsnull</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mBindingDependencies</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mMemoryElementToResultMap</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mRuleToBindingsMap</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>CompileQuery</name></name>(<name>nsIXULTemplateBuilder</name>* <name>aBuilder</name>,
                                             <name>nsIDOMNode</name>* <name>aQueryNode</name>,
                                             <name>nsIAtom</name>* <name>aRefVariable</name>,
                                             <name>nsIAtom</name>* <name>aMemberVariable</name>,
                                             <name>nsISupports</name>** <name>_retval</name>)
<block>{
    <expr><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsRDFQuery</name></expr></argument>&gt;</argument_list></name> <name>query</name> = new <call><name>nsRDFQuery</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
    <if>if <condition>(<expr>!<name>query</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <name><name>query</name>-&gt;<name>mRefVariable</name></name> = <name>aRefVariable</name></block></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mRefVariable</name></expr>)</condition><then>
      <expr_stmt><expr><name>mRefVariable</name> = <name>aRefVariable</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<name>aMemberVariable</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>query</name>-&gt;<name>mMemberVariable</name></name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr>"?"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name><name>query</name>-&gt;<name>mMemberVariable</name></name> = <name>aMemberVariable</name></expr>;</expr_stmt></else></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TestNode</name> *</type><name>lastnode</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aQueryNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>content</name>-&gt;<name>NodeInfo</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Equals</name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>_template</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_XUL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// simplified syntax with no rules</comment>

        <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetSimple</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mSimpleRuleMemberTest</name></expr></argument>,
                     <argument><expr>"CompileQuery called twice with the same template"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>mSimpleRuleMemberTest</name></expr>)</condition><then>
            <expr_stmt><expr><name>rv</name> = <call><name>CompileSimpleQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr>&amp;<name>lastnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_FAILURE</name></expr>;</expr_stmt></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>content</name>-&gt;<name>NodeInfo</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Equals</name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>rule</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_XUL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// simplified syntax with at least one rule</comment>
        <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetSimple</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>CompileSimpleQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr>&amp;<name>lastnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>CompileExtendedQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr>&amp;<name>lastnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetQueryNode</name></name><argument_list>(<argument><expr><name>aQueryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsInstantiationNode</name>*</type> <name>instnode</name> <init>= <expr>new <call><name>nsInstantiationNode</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>instnode</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// this and other functions always add nodes to mAllTests first. That</comment>
    <comment type="line">// way if something fails, the node will just sit harmlessly in mAllTests</comment>
    <comment type="line">// where it can be deleted later. </comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>instnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>instnode</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>lastnode</name>-&gt;<name>AddChild</name></name><argument_list>(<argument><expr><name>instnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mQueries</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>_retval</name> = <name>query</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>_retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>GenerateResults</name></name>(<name>nsISupports</name>* <name>aDatasource</name>,
                                                <name>nsIXULTemplateResult</name>* <name>aRef</name>,
                                                <name>nsISupports</name>* <name>aQuery</name>,
                                                <name>nsISimpleEnumerator</name>** <name>aResults</name>)
<block>{
    <expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsITemplateRDFQuery</name></expr></argument>&gt;</argument_list></name> <name>rdfquery</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aQuery</name></expr></argument>)</argument_list></call></expr>;
    <if>if <condition>(<expr>! <name>rdfquery</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

    <name>mGenerationStarted</name> = <name>PR_TRUE</name></block></expr>;</expr_stmt>

    <comment type="line">// should be safe to cast here since the query is a</comment>
    <comment type="line">// non-scriptable nsITemplateRDFQuery</comment>
    <decl_stmt><decl><type><name>nsRDFQuery</name>*</type> <name>query</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsRDFQuery</name> *</expr></argument>, <argument><expr><name>aQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>aResults</name> = <name>nsnull</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISimpleEnumerator</name></expr></argument>&gt;</argument_list></name></type> <name>results</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>aRef</name></expr>)</condition><then> <block>{
        <comment type="line">// make sure that cached results were generated for this ref, and if not,</comment>
        <comment type="line">// regenerate them. Otherwise, things will go wrong for templates bound to</comment>
        <comment type="line">// an HTML element as they are not generated lazily.</comment>
        <if>if <condition>(<expr><name>aRef</name> == <name>mLastRef</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>query</name>-&gt;<name>UseCachedResults</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="line">// clear the cached results</comment>
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>count</name> <init>= <expr><call><name><name>mQueries</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>PRInt32</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name><name>mQueries</name><index>[<expr><name>r</name></expr>]</index></name>-&gt;<call><name>ClearCachedResults</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>

        <if>if <condition>(<expr>! <name>results</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>! <name><name>query</name>-&gt;<name>mRefVariable</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>query</name>-&gt;<name>mRefVariable</name></name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr>"?uri"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>refResource</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>aRef</name>-&gt;<name>GetResource</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>refResource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>! <name>refResource</name></expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

            <comment type="line">// Propagate the assignments through the network</comment>
            <decl_stmt><decl><type><name>TestNode</name>*</type> <name>root</name> <init>= <expr><call><name><name>query</name>-&gt;<name>GetRoot</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>query</name>-&gt;<name>IsSimple</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>mSimpleRuleMemberTest</name></expr>)</condition><then> <block>{
                <comment type="line">// get the top node in the simple rule tree</comment>
                <expr_stmt><expr><name>root</name> = <call><name><name>mSimpleRuleMemberTest</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mLastRef</name> = <name>aRef</name></expr>;</expr_stmt>
            }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
            <if>if <condition>(<expr><call><name>PR_LOG_TEST</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>nsAutoString</name></type> <name>id</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>aRef</name>-&gt;<name>GetId</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>nsAutoString</name></type> <name>rvar</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>query</name>-&gt;<name>mRefVariable</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>rvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>nsAutoString</name></type> <name>mvar</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>query</name>-&gt;<name>mMemberVariable</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>mvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
                       <argument><expr>("QueryProcessor::GenerateResults using ref %s and vars [ ref: %s  member: %s]",
                       <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>,
                       <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>rvar</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>,
                       <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>mvar</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if>if <condition>(<expr><name>root</name></expr>)</condition><then> <block>{
                <comment type="line">// the seed is the initial instantiation, which has a single</comment>
                <comment type="line">// assignment holding the reference point</comment>
                <decl_stmt><decl><type><name>Instantiation</name></type> <name>seed</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>seed</name>.<name>AddAssignment</name></name><argument_list>(<argument><expr><name><name>query</name>-&gt;<name>mRefVariable</name></name></expr></argument>, <argument><expr><name>refResource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>InstantiationSet</name>*</type> <name>instantiations</name> <init>= <expr>new <call><name>InstantiationSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>instantiations</name></expr>)</condition><then>
                    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name><name>instantiations</name>-&gt;<name>Append</name></name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// if the propagation caused a match, then the results will be</comment>
                <comment type="line">// cached in the query, retrieved below by calling</comment>
                <comment type="line">// UseCachedResults. The matching result set owns the</comment>
                <comment type="line">// instantiations and will delete them when results have been</comment>
                <comment type="line">// iterated over. If the propagation did not match, the</comment>
                <comment type="line">// instantiations need to be deleted.</comment>
                <decl_stmt><decl><type><name>PRBool</name></type> <name>owned</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>root</name>-&gt;<name>Propagate</name></name><argument_list>(<argument><expr>*<name>instantiations</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>owned</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>! <name>owned</name></expr>)</condition><then>
                    <expr_stmt><expr>delete <name>instantiations</name></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>rv</name></expr>;</return></then></if>

                <expr_stmt><expr><call><name><name>query</name>-&gt;<name>UseCachedResults</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>! <name>results</name></expr>)</condition><then> <block>{
        <comment type="line">// no results were found so create an empty set</comment>
        <expr_stmt><expr><name>results</name> = new <call><name>nsXULTemplateResultSetRDF</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>! <name>results</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>results</name>.<name>swap</name></name><argument_list>(<argument><expr>*<name>aResults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>AddBinding</name></name>(<name>nsIDOMNode</name>* <name>aRuleNode</name>,
                                           <name>nsIAtom</name>* <name>aVar</name>,
                                           <name>nsIAtom</name>* <name>aRef</name>,
                                           const <name>nsAString</name>&amp; <name>aExpr</name>)
<block>{
    <comment type="line">// add a &lt;binding&gt; to a rule. When a result is matched, the bindings are</comment>
    <comment type="line">// examined to add additional variable assignments</comment>

    <comment type="line">// bindings can't be added once result generation has started, otherwise</comment>
    <comment type="line">// the array sizes will get out of sync</comment>
    <if>if <condition>(<expr><name>mGenerationStarted</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name> <name>property</name></block></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>aExpr</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>RDFBindingSet</name></expr></argument>&gt;</argument_list></name></type> <name>bindings</name> <init>= <expr><call><name><name>mRuleToBindingsMap</name>.<name>GetWeak</name></name><argument_list>(<argument><expr><name>aRuleNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>bindings</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>bindings</name> = new <call><name>RDFBindingSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bindings</name> || !<call><name><name>mRuleToBindingsMap</name>.<name>Put</name></name><argument_list>(<argument><expr><name>aRuleNode</name></expr></argument>, <argument><expr><name>bindings</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><call><name><name>bindings</name>-&gt;<name>AddBinding</name></name><argument_list>(<argument><expr><name>aVar</name></expr></argument>, <argument><expr><name>aRef</name></expr></argument>, <argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>TranslateRef</name></name>(<name>nsISupports</name>* <name>aDatasource</name>,
                                                           const <name>nsAString</name>&amp; <name>aRefString</name>,
                                                           <name>nsIXULTemplateResult</name>** <name>aRef</name>)
<block>{
    <comment type="line">// make sure the RDF service is set up</comment>
    <expr><name>nsresult</name> <name>rv</name> = <call><name>InitGlobals</name><argument_list>()</argument_list></call></expr>;
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name> <name>uri</name></block></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>aRefString</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>refresult</name> <init>= <expr>new <call><name>nsXULTemplateResultRDF</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>! <name>refresult</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aRef</name> = <name>refresult</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>CompareResults</name></name>(<name>nsIXULTemplateResult</name>* <name>aLeft</name>,
                                                             <name>nsIXULTemplateResult</name>* <name>aRight</name>,
                                                             <name>nsIAtom</name>* <name>aVar</name>,
                                                             <name>PRInt32</name>* <name>aResult</name>)
<block>{
    <expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aLeft</name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aRight</name></expr></argument>)</argument_list></call></expr>;

    <expr>*<name>aResult</name> = 0</expr>;

    <comment type="line">// for natural order sorting, use the index in the RDF container for the</comment>
    <comment type="line">// order. If there is no container, just sort them arbitrarily.</comment>
    <if>if <condition>(<expr>!<name>aVar</name></expr>)</condition><then> <block>{
        <comment type="line">// if a result has a negative index, just sort it first</comment>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>leftindex</name> <init>= <expr><call><name>GetContainerIndexOf</name><argument_list>(<argument><expr><name>aLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>rightindex</name> <init>= <expr><call><name>GetContainerIndexOf</name><argument_list>(<argument><expr><name>aRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>aResult</name> = <name>leftindex</name> == <name>rightindex</name> ? 0 :
                   <name>leftindex</name> &gt; <name>rightindex</name> ? 1 :
                   -1</expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    <expr_stmt/></block></then></if>}</block>

    <name>nsAutoString</name> <name>sortkey</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aVar</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>sortkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>leftNode</name></decl>, <decl><type ref="prev"/><name>rightNode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name><name>sortkey</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>sortkey</name><index>[<expr>0</expr>]</index></name> != '?' &amp;&amp;
        !<call><name>StringBeginsWith</name><argument_list>(<argument><expr><name>sortkey</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"rdf:"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
        <name>mDB</name></expr>)</condition><then> <block>{
        <comment type="line">// if the sort key is not a template variable, it should be an RDF</comment>
        <comment type="line">// predicate. Get the targets and compare those instead.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>predicate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>sortkey</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// create a predicate with '?sort=true' appended. This special</comment>
        <comment type="line">// predicate may be used to have a different sort value than the</comment>
        <comment type="line">// displayed value</comment>
        <expr_stmt><expr><call><name><name>sortkey</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"?sort=true"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>sortPredicate</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>sortkey</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sortPredicate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>GetSortValue</name><argument_list>(<argument><expr><name>aLeft</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>sortPredicate</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>GetSortValue</name><argument_list>(<argument><expr><name>aRight</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>sortPredicate</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="line">// get the values for the sort key from the results</comment>
        <expr_stmt><expr><call><name><name>aLeft</name>-&gt;<name>GetBindingObjectFor</name></name><argument_list>(<argument><expr><name>aVar</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aRight</name>-&gt;<name>GetBindingObjectFor</name></name><argument_list>(<argument><expr><name>aVar</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <block>{
        <comment type="line">// Literals?</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFLiteral</name></expr></argument>&gt;</argument_list></name></type> <name>l</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>l</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFLiteral</name></expr></argument>&gt;</argument_list></name></type> <name>r</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name>lstr</name></decl>, *<decl><type ref="prev"/><name>rstr</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>l</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>lstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>r</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>rstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>nsICollation</name>*</type> <name>collation</name> <init>= <expr><call><name><name>nsXULContentUtils</name>::<name>GetCollation</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>collation</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>collation</name>-&gt;<name>CompareString</name></name><argument_list>(<argument><expr><name><name>nsICollation</name>::<name>kCollationCaseInSensitive</name></name></expr></argument>,
                                             <argument><expr><call><name>nsDependentString</name><argument_list>(<argument><expr><name>lstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>nsDependentString</name><argument_list>(<argument><expr><name>rstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                    <expr_stmt><expr>*<name>aResult</name> = <call><name>::<name>Compare</name></name><argument_list>(<argument><expr><call><name>nsDependentString</name><argument_list>(<argument><expr><name>lstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>nsDependentString</name><argument_list>(<argument><expr><name>rstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>nsCaseInsensitiveStringComparator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></then></if>
        }</block></then></if>
    }</block>

    <block>{
        <comment type="line">// Dates?</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFDate</name></expr></argument>&gt;</argument_list></name></type> <name>l</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>l</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFDate</name></expr></argument>&gt;</argument_list></name></type> <name>r</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRTime</name></type> <name>ldate</name></decl>, <decl><type ref="prev"/><name>rdate</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>l</name>-&gt;<name>GetValue</name></name><argument_list>(<argument><expr>&amp;<name>ldate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>r</name>-&gt;<name>GetValue</name></name><argument_list>(<argument><expr>&amp;<name>rdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>PRInt64</name></type> <name>delta</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>LL_SUB</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>ldate</name></expr></argument>, <argument><expr><name>rdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><call><name>LL_IS_ZERO</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr>*<name>aResult</name> = 0</expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name>LL_GE_ZERO</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr>*<name>aResult</name> = 1</expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr>*<name>aResult</name> = -1</expr>;</expr_stmt></else></if></else></if>
            }</block></then></if>
        }</block></then></if>
    }</block>

    <block>{
        <comment type="line">// Integers?</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFInt</name></expr></argument>&gt;</argument_list></name></type> <name>l</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>l</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFInt</name></expr></argument>&gt;</argument_list></name></type> <name>r</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRInt32</name></type> <name>lval</name></decl>, <decl><type ref="prev"/><name>rval</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>l</name>-&gt;<name>GetValue</name></name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>r</name>-&gt;<name>GetValue</name></name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr>*<name>aResult</name> = <name>lval</name> - <name>rval</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block>

    <decl_stmt><decl><type><name>nsICollation</name>*</type> <name>collation</name> <init>= <expr><call><name><name>nsXULContentUtils</name>::<name>GetCollation</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>collation</name></expr>)</condition><then> <block>{
        <comment type="line">// Blobs? (We can only compare these reasonably if we have a</comment>
        <comment type="line">// collation object.)</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFBlob</name></expr></argument>&gt;</argument_list></name></type> <name>l</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>l</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFBlob</name></expr></argument>&gt;</argument_list></name></type> <name>r</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>PRUint8</name> *</type><name>lval</name></decl>, *<decl><type ref="prev"/><name>rval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PRInt32</name></type> <name>llen</name></decl>, <decl><type ref="prev"/><name>rlen</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>l</name>-&gt;<name>GetValue</name></name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>l</name>-&gt;<name>GetLength</name></name><argument_list>(<argument><expr>&amp;<name>llen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>r</name>-&gt;<name>GetValue</name></name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>r</name>-&gt;<name>GetLength</name></name><argument_list>(<argument><expr>&amp;<name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name><name>collation</name>-&gt;<name>CompareRawSortKey</name></name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><name>llen</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// if the results are none of the above, just pretend that they are equal</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}

<comment type="line">//----------------------------------------------------------------------</comment>
<comment type="line">//</comment>
<comment type="line">// nsIRDFObserver interface</comment>
<comment type="line">//</comment>


NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>OnAssert</name></name>(<name>nsIRDFDataSource</name>* <name>aDataSource</name>,
                                         <name>nsIRDFResource</name>* <name>aSource</name>,
                                         <name>nsIRDFResource</name>* <name>aProperty</name>,
                                         <name>nsIRDFNode</name>* <name>aTarget</name>)
<block>{
    <comment type="line">// Ignore updates if we're batching</comment>
    <if>if <condition>(<expr><name>mUpdateBatchNest</name></expr>)</condition><then>
        <return>return<expr>(<name>NS_OK</name>)</expr>;</return></then></if></block></expr></expr_stmt>

    <if>if <condition>(<expr>! <name>mBuilder</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>"onassert"</expr></argument>, <argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Propagate</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SynchronizeAll</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}



NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>OnUnassert</name></name>(<name>nsIRDFDataSource</name>* <name>aDataSource</name>,
                                           <name>nsIRDFResource</name>* <name>aSource</name>,
                                           <name>nsIRDFResource</name>* <name>aProperty</name>,
                                           <name>nsIRDFNode</name>* <name>aTarget</name>)
<block>{
    <comment type="line">// Ignore updates if we're batching</comment>
    <if>if <condition>(<expr><name>mUpdateBatchNest</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if></block></expr></expr_stmt>

    <if>if <condition>(<expr>! <name>mBuilder</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>"onunassert"</expr></argument>, <argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Retract</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SynchronizeAll</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}


NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>OnChange</name></name>(<name>nsIRDFDataSource</name>* <name>aDataSource</name>,
                                         <name>nsIRDFResource</name>* <name>aSource</name>,
                                         <name>nsIRDFResource</name>* <name>aProperty</name>,
                                         <name>nsIRDFNode</name>* <name>aOldTarget</name>,
                                         <name>nsIRDFNode</name>* <name>aNewTarget</name>)
<block>{
    <comment type="line">// Ignore updates if we're batching</comment>
    <if>if <condition>(<expr><name>mUpdateBatchNest</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if></block></expr></expr_stmt>

    <if>if <condition>(<expr>! <name>mBuilder</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>"onchange"</expr></argument>, <argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aNewTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aOldTarget</name></expr>)</condition><then> <block>{
        <comment type="line">// Pull any old results that were relying on aOldTarget</comment>
        <expr_stmt><expr><call><name>Retract</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aOldTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>aNewTarget</name></expr>)</condition><then> <block>{
        <comment type="line">// Fire any new results that are activated by aNewTarget</comment>
        <expr_stmt><expr><call><name>Propagate</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aNewTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Synchronize any of the content model that may have changed.</comment>
    <expr_stmt><expr><call><name>SynchronizeAll</name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aOldTarget</name></expr></argument>, <argument><expr><name>aNewTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}


NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>OnMove</name></name>(<name>nsIRDFDataSource</name>* <name>aDataSource</name>,
                                       <name>nsIRDFResource</name>* <name>aOldSource</name>,
                                       <name>nsIRDFResource</name>* <name>aNewSource</name>,
                                       <name>nsIRDFResource</name>* <name>aProperty</name>,
                                       <name>nsIRDFNode</name>* <name>aTarget</name>)
<block>{
    <comment type="line">// Ignore updates if we're batching</comment>
    <if>if <condition>(<expr><name>mUpdateBatchNest</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <call><name>NS_NOTYETIMPLEMENTED</name><argument_list>(<argument><expr>"write me"</expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}


NS_IMETHODIMP
<macro><name>nsXULTemplateQueryProcessorRDF</name></macro><expr_stmt><expr><name>::<name>OnBeginUpdateBatch</name></name>(<name>nsIRDFDataSource</name>* <name>aDataSource</name>)
<block>{
    <expr><name>mUpdateBatchNest</name>++</expr>;
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>OnEndUpdateBatch</name></name><parameter_list>(<param><decl><type><name>nsIRDFDataSource</name>*</type> <name>aDataSource</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mUpdateBatchNest</name> &gt; 0</expr></argument>, <argument><expr>"badly nested update batch"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>--<name>mUpdateBatchNest</name> &lt;= 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mUpdateBatchNest</name> = 0</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>mBuilder</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mBuilder</name>-&gt;<name>Rebuild</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>Propagate</name></name><parameter_list>(<param><decl><type><name>nsIRDFResource</name>*</type> <name>aSource</name></decl></param>,
                                          <param><decl><type><name>nsIRDFResource</name>*</type> <name>aProperty</name></decl></param>,
                                          <param><decl><type><name>nsIRDFNode</name>*</type> <name>aTarget</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// When a new assertion is added to the graph, determine any new matches</comment>
    <comment type="line">// that must be added to the template builder. First, iterate through all</comment>
    <comment type="line">// the RDF tests (&lt;member&gt; and &lt;triple&gt; tests), and find the topmost test</comment>
    <comment type="line">// that would be affected by the new assertion.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ReteNodeSet</name></type> <name>livenodes</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>PR_LOG_TEST</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>sourceStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aSource</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>sourceStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>propertyStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aProperty</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>propertyStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>targetStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>nsXULContentUtils</name>::<name>GetTextForNode</name></name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>targetStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("nsXULTemplateQueryProcessorRDF::Propagate: [%s] -&gt; [%s] -&gt; [%s]\n",
               <name>sourceStr</name>, <name>propertyStr</name>, <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>targetStr</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <block>{
        <decl_stmt><decl><type><name><name>ReteNodeSet</name>::<name>Iterator</name></name></type> <name>last</name> <init>= <expr><call><name><name>mRDFTests</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>ReteNodeSet</name>::<name>Iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>mRDFTests</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> != <name>last</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>nsRDFTestNode</name>*</type> <name>rdftestnode</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsRDFTestNode</name>*</expr></argument>, <argument><expr>*<name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Instantiation</name></type> <name>seed</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>rdftestnode</name>-&gt;<name>CanPropagate</name></name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name><name>livenodes</name>.<name>Add</name></name><argument_list>(<argument><expr><name>rdftestnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>rv</name></expr>;</return></then></if>
            }</block></then></if>
        }</block></for>
    }</block>

    <comment type="line">// Now, we'll go through each, and any that aren't dominated by</comment>
    <comment type="line">// another live node will be used to propagate the assertion</comment>
    <comment type="line">// through the rule network</comment>
    <block>{
        <decl_stmt><decl><type><name><name>ReteNodeSet</name>::<name>Iterator</name></name></type> <name>last</name> <init>= <expr><call><name><name>livenodes</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>ReteNodeSet</name>::<name>Iterator</name></name></type> <name>i</name> <init>= <expr><call><name><name>livenodes</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> != <name>last</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>nsRDFTestNode</name>*</type> <name>rdftestnode</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr><name>nsRDFTestNode</name>*</expr></argument>, <argument><expr>*<name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// What happens here is we create an instantiation as if we were</comment>
            <comment type="line">// at the found test in the rule network. For example, if the</comment>
            <comment type="line">// found test was a member test (parent =&gt; child), the parent</comment>
            <comment type="line">// and child variables are assigned the values provided by the new</comment>
            <comment type="line">// RDF assertion in the graph. The Constrain call is used to go</comment>
            <comment type="line">// up to earlier RDF tests, filling in variables as it goes.</comment>
            <comment type="line">// Constrain will eventually get up to the top node, an</comment>
            <comment type="line">// nsContentTestNode, which takes the value of the reference</comment>
            <comment type="line">// variable and calls the template builder to see if a result has</comment>
            <comment type="line">// been generated already for the reference value. If it hasn't,</comment>
            <comment type="line">// the new assertion couldn't cause a new match. If the result</comment>
            <comment type="line">// exists, call Propagate to continue to the later RDF tests to</comment>
            <comment type="line">// fill in the rest of the variable assignments.</comment>

            <comment type="line">// Bogus, to get the seed instantiation</comment>
            <decl_stmt><decl><type><name>Instantiation</name></type> <name>seed</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>rdftestnode</name>-&gt;<name>CanPropagate</name></name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>InstantiationSet</name>*</type> <name>instantiations</name> <init>= <expr>new <call><name>InstantiationSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>instantiations</name></expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name><name>instantiations</name>-&gt;<name>Append</name></name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name><name>rdftestnode</name>-&gt;<name>Constrain</name></name><argument_list>(<argument><expr>*<name>instantiations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>delete <name>instantiations</name></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>PRBool</name></type> <name>owned</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>instantiations</name>-&gt;<name>Empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>rv</name> = <call><name><name>rdftestnode</name>-&gt;<name>Propagate</name></name><argument_list>(<argument><expr>*<name>instantiations</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>owned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <comment type="line">// owned should always be false in update mode, but check just</comment>
            <comment type="line">// to be sure</comment>
            <if>if <condition>(<expr>!<name>owned</name></expr>)</condition><then>
                <expr_stmt><expr>delete <name>instantiations</name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></for>
    }</block>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>Retract</name></name><parameter_list>(<param><decl><type><name>nsIRDFResource</name>*</type> <name>aSource</name></decl></param>,
                                        <param><decl><type><name>nsIRDFResource</name>*</type> <name>aProperty</name></decl></param>,
                                        <param><decl><type><name>nsIRDFNode</name>*</type> <name>aTarget</name></decl></param>)</parameter_list>
<block>{

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>PR_LOG_TEST</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>sourceStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aSource</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>sourceStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>propertyStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aProperty</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>propertyStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>targetStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>nsXULContentUtils</name>::<name>GetTextForNode</name></name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>targetStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("nsXULTemplateQueryProcessorRDF::Retract: [%s] -&gt; [%s] -&gt; [%s]\n",
               <name>sourceStr</name>, <name>propertyStr</name>, <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>targetStr</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Retract any currently active rules that will no longer be matched.</comment>
    <decl_stmt><decl><type><name><name>ReteNodeSet</name>::<name>ConstIterator</name></name></type> <name>lastnode</name> <init>= <expr><call><name><name>mRDFTests</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name><name>ReteNodeSet</name>::<name>ConstIterator</name></name></type> <name>node</name> <init>= <expr><call><name><name>mRDFTests</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>node</name> != <name>lastnode</name></expr>;</condition> <incr><expr>++<name>node</name></expr></incr>) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>nsRDFTestNode</name>*</type> <name>rdftestnode</name> <init>= <expr><call><name>NS_STATIC_CAST</name><argument_list>(<argument><expr>const <name>nsRDFTestNode</name>*</expr></argument>, <argument><expr>*<name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>rdftestnode</name>-&gt;<name>Retract</name></name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Now fire any newly revealed rules</comment>
        <comment type="line">// XXXwaterson yo. write me.</comment>
        <comment type="line">// The intent here is to handle any rules that might be</comment>
        <comment type="line">// "revealed" by the removal of an assertion from the datasource.</comment>
        <comment type="line">// Waterson doesn't think we support negated conditions in a rule.</comment>
        <comment type="line">// Nor is he sure that this is currently useful.</comment>
    }</block></for>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>SynchronizeAll</name></name><parameter_list>(<param><decl><type><name>nsIRDFResource</name>*</type> <name>aSource</name></decl></param>,
                                               <param><decl><type><name>nsIRDFResource</name>*</type> <name>aProperty</name></decl></param>,
                                               <param><decl><type><name>nsIRDFNode</name>*</type> <name>aOldTarget</name></decl></param>,
                                               <param><decl><type><name>nsIRDFNode</name>*</type> <name>aNewTarget</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Update each match that contains &lt;aSource, aProperty, aOldTarget&gt;.</comment>

    <comment type="line">// Get all the matches whose assignments are currently supported</comment>
    <comment type="line">// by aSource and aProperty: we'll need to recompute them.</comment>
    <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name>*</type> <name>results</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>mBindingDependencies</name>.<name>Get</name></name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr>&amp;<name>results</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name><name>results</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>r</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>r</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>result</name> <init>= <expr>(*<name>results</name>)<index>[<expr><name>r</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
            <comment type="line">// synchronize the result's bindings and then update the builder</comment>
            <comment type="line">// so that content can be updated</comment>
            <if>if <condition>(<expr><call><name><name>result</name>-&gt;<name>SyncAssignments</name></name><argument_list>(<argument><expr><name>aSource</name></expr></argument>, <argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>aNewTarget</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>nsITemplateRDFQuery</name>*</type> <name>query</name> <init>= <expr><call><name><name>result</name>-&gt;<name>Query</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>query</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>querynode</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>query</name>-&gt;<name>GetQueryNode</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>querynode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name><name>mBuilder</name>-&gt;<name>ResultBindingChanged</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>Log</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aOperation</name></decl></param>,
                                    <param><decl><type><name>nsIRDFResource</name>*</type> <name>aSource</name></decl></param>,
                                    <param><decl><type><name>nsIRDFResource</name>*</type> <name>aProperty</name></decl></param>,
                                    <param><decl><type><name>nsIRDFNode</name>*</type> <name>aTarget</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>PR_LOG_TEST</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>sourceStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>aSource</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>sourceStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>,
               <argument><expr>("xultemplate[%p] %8s [%s]--", <name>this</name>, <name>aOperation</name>, <name>sourceStr</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>propertyStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>aProperty</name>-&gt;<name>GetValueConst</name></name><argument_list>(<argument><expr>&amp;<name>propertyStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>targetStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>nsXULContentUtils</name>::<name>GetTextForNode</name></name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>targetStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>targetstrC</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>targetstrC</name>.<name>AssignWithConversion</name></name><argument_list>(<argument><expr><name>targetStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>,
               <argument><expr>("                        --[%s]--&gt;[%s]",
                <name>propertyStr</name>,
                <call><name><name>targetstrC</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CheckContainer</name></name><parameter_list>(<param><decl><type><name>nsIRDFResource</name>*</type> <name>aResource</name></decl></param>,
                                               <param><decl><type><name>PRBool</name>*</type> <name>aIsContainer</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aIsContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We have to look at all of the arcs extending out of the</comment>
    <comment type="line">// resource: if any of them are that "containment" property, then</comment>
    <comment type="line">// we know we'll have children.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>isContainer</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><decl><type><name><name>nsResourceSet</name>::<name>ConstIterator</name></name></type> <name>property</name> <init>= <expr><call><name><name>mContainmentProperties</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>property</name> != <call><name><name>mContainmentProperties</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr>;</condition>
         <incr><expr><name>property</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>hasArc</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mDB</name>-&gt;<name>HasArcOut</name></name><argument_list>(<argument><expr><name>aResource</name></expr></argument>, <argument><expr>*<name>property</name></expr></argument>, <argument><expr>&amp;<name>hasArc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>hasArc</name></expr>)</condition><then> <block>{
            <comment type="line">// Well, it's a container...</comment>
            <expr_stmt><expr><name>isContainer</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>

    <comment type="line">// If we get here, and we're still not sure if it's a container,</comment>
    <comment type="line">// then see if it's an RDF container</comment>
    <if>if <condition>(<expr>! <name>isContainer</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>gRDFContainerUtils</name>-&gt;<name>IsContainer</name></name><argument_list>(<argument><expr><name>mDB</name></expr></argument>, <argument><expr><name>aResource</name></expr></argument>, <argument><expr>&amp;<name>isContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>*<name>aIsContainer</name> = <name>isContainer</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CheckEmpty</name></name><parameter_list>(<param><decl><type><name>nsIRDFResource</name>*</type> <name>aResource</name></decl></param>,
                                           <param><decl><type><name>PRBool</name>*</type> <name>aIsEmpty</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aIsEmpty</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <for>for (<init><decl><type><name><name>nsResourceSet</name>::<name>ConstIterator</name></name></type> <name>property</name> <init>= <expr><call><name><name>mContainmentProperties</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>property</name> != <call><name><name>mContainmentProperties</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr>;</condition>
         <incr><expr><name>property</name>++</expr></incr>) <block>{

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFNode</name></expr></argument>&gt;</argument_list></name></type> <name>dummy</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mDB</name>-&gt;<name>GetTarget</name></name><argument_list>(<argument><expr><name>aResource</name></expr></argument>, <argument><expr>*<name>property</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>dummy</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>aIsEmpty</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr>*<name>aIsEmpty</name></expr>)</condition><then><block>{
        <return>return <expr><call><name><name>nsXULTemplateQueryProcessorRDF</name>::<name>gRDFContainerUtils</name>-&gt;
                   <name>IsEmpty</name></name><argument_list>(<argument><expr><name>mDB</name></expr></argument>, <argument><expr><name>aResource</name></expr></argument>, <argument><expr><name>aIsEmpty</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CheckIsSeparator</name></name><parameter_list>(<param><decl><type><name>nsIRDFResource</name>*</type> <name>aResource</name></decl></param>,
                                                 <param><decl><type><name>PRBool</name>*</type> <name>aIsSeparator</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>mDB</name>-&gt;<name>HasAssertion</name></name><argument_list>(<argument><expr><name>aResource</name></expr></argument>, <argument><expr><name>kRDF_type</name></expr></argument>, <argument><expr><name>kNC_BookmarkSeparator</name></expr></argument>,
                             <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>aIsSeparator</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>ComputeContainmentProperties</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aRootNode</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// The 'containment' attribute on the root node is a</comment>
    <comment type="line">// whitespace-separated list that tells us which properties we</comment>
    <comment type="line">// should use to test for containment.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>mContainmentProperties</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>containment</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>content</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>containment</name></name></expr></argument>, <argument><expr><name>containment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><call><name><name>containment</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>offset</name> &lt; <name>len</name></expr>)</condition> <block>{
        <while>while <condition>(<expr><name>offset</name> &lt; <name>len</name> &amp;&amp; <call><name><name>nsCRT</name>::<name>IsAsciiSpace</name></name><argument_list>(<argument><expr><name><name>containment</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>++<name>offset</name></expr>;</expr_stmt></while>

        <if>if <condition>(<expr><name>offset</name> &gt;= <name>len</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <decl_stmt><decl><type><name>PRUint32</name></type> <name>end</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>end</name> &lt; <name>len</name> &amp;&amp; !<call><name><name>nsCRT</name>::<name>IsAsciiSpace</name></name><argument_list>(<argument><expr><name><name>containment</name><index>[<expr><name>end</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>++<name>end</name></expr>;</expr_stmt></while>

        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>propertyStr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>containment</name>.<name>Mid</name></name><argument_list>(<argument><expr><name>propertyStr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>end</name> - <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>property</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>propertyStr</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mContainmentProperties</name>.<name>Add</name></name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>offset</name> = <name>end</name></expr>;</expr_stmt>
    }</block></while>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_PROPERTY_HACK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TREE_PROPERTY_HACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if <condition>(<expr>! <name>len</name></expr>)</condition><then> <block>{
        <comment type="line">// Some ever-present membership tests.</comment>
        <expr_stmt><expr><call><name><name>mContainmentProperties</name>.<name>Add</name></name><argument_list>(<argument><expr><name><name>nsXULContentUtils</name>::<name>NC_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mContainmentProperties</name>.<name>Add</name></name><argument_list>(<argument><expr><name><name>nsXULContentUtils</name>::<name>NC_Folder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CompileExtendedQuery</name></name><parameter_list>(<param><decl><type><name>nsRDFQuery</name>*</type> <name>aQuery</name></decl></param>,
                                                     <param><decl><type><name>nsIContent</name>*</type> <name>aConditions</name></decl></param>,
                                                     <param><decl><type><name>TestNode</name>**</type> <name>aLastNode</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Compile an extended query's children</comment>

    <decl_stmt><decl><type><name>nsContentTestNode</name>*</type> <name>idnode</name> <init>=
        <expr>new <call><name>nsContentTestNode</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>aQuery</name>-&gt;<name>mRefVariable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>! <name>idnode</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>aQuery</name>-&gt;<name>SetRoot</name></name><argument_list>(<argument><expr><name>idnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>idnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>idnode</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>TestNode</name>*</type> <name>prevnode</name> <init>= <expr><name>idnode</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>count</name> <init>= <expr><call><name><name>aConditions</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsIContent</name> *</type><name>condition</name> <init>= <expr><call><name><name>aConditions</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// the &lt;content&gt; condition should always be the first child</comment>
        <if>if <condition>(<expr><call><name><name>condition</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>content</name></name> &amp;&amp; !<name>i</name></expr>)</condition><then> <block>{
            <comment type="line">// check for &lt;content tag='tag'/&gt; which indicates that matches</comment>
            <comment type="line">// should only be generated for items inside content with that tag</comment>
            <decl_stmt><decl><type><name>nsAutoString</name></type> <name>tagstr</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>condition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>tag</name></name></expr></argument>, <argument><expr><name>tagstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>tag</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>! <call><name><name>tagstr</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>tag</name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name>tagstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>doc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>condition</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>! <name>doc</name></expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name><name>idnode</name>-&gt;<name>SetTag</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <decl_stmt><decl><type><name>TestNode</name>*</type> <name>testnode</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CompileQueryChild</name><argument_list>(<argument><expr><call><name><name>condition</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aQuery</name></expr></argument>, <argument><expr><name>condition</name></expr></argument>,
                                        <argument><expr><name>prevnode</name></expr></argument>, <argument><expr>&amp;<name>testnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>testnode</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name><name>prevnode</name>-&gt;<name>AddChild</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><name>prevnode</name> = <name>testnode</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr>*<name>aLastNode</name> = <name>prevnode</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CompileQueryChild</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aTag</name></decl></param>,
                                                  <param><decl><type><name>nsRDFQuery</name>*</type> <name>aQuery</name></decl></param>,
                                                  <param><decl><type><name>nsIContent</name>*</type> <name>aCondition</name></decl></param>,
                                                  <param><decl><type><name>TestNode</name>*</type> <name>aParentNode</name></decl></param>,
                                                  <param><decl><type><name>TestNode</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>aTag</name> == <name><name>nsGkAtoms</name>::<name>triple</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>CompileTripleCondition</name><argument_list>(<argument><expr><name>aQuery</name></expr></argument>, <argument><expr><name>aCondition</name></expr></argument>, <argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>aTag</name> == <name><name>nsGkAtoms</name>::<name>member</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>CompileMemberCondition</name><argument_list>(<argument><expr><name>aQuery</name></expr></argument>, <argument><expr><name>aCondition</name></expr></argument>, <argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>tagstr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aTag</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>tagstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>tagstrC</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tagstrC</name>.<name>AssignWithConversion</name></name><argument_list>(<argument><expr><name>tagstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("xultemplate[%p] unrecognized condition test &lt;%s&gt;",
                <name>this</name>, <call><name><name>tagstrC</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>ParseLiteral</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aParseType</name></decl></param>, 
                                             <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aValue</name></decl></param>,
                                             <param><decl><type><name>nsIRDFNode</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>aResult</name> = <name>nsnull</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>aParseType</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr><name>PARSE_TYPE_INTEGER</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFInt</name></expr></argument>&gt;</argument_list></name></type> <name>intLiteral</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>errorCode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>intValue</name> <init>= <expr><call><name><name>aValue</name>.<name>ToInteger</name></name><argument_list>(<argument><expr>&amp;<name>errorCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>errorCode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name><name>gRDFService</name>-&gt;<name>GetIntLiteral</name></name><argument_list>(<argument><expr><name>intValue</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>intLiteral</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
            <return>return <expr><name>rv</name></expr>;</return></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>intLiteral</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFLiteral</name></expr></argument>&gt;</argument_list></name></type> <name>literal</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>gRDFService</name>-&gt;<name>GetLiteral</name></name><argument_list>(<argument><expr><call><name><name>aValue</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>literal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
            <return>return <expr><name>rv</name></expr>;</return></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>literal</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CompileTripleCondition</name></name><parameter_list>(<param><decl><type><name>nsRDFQuery</name>*</type> <name>aQuery</name></decl></param>,
                                                       <param><decl><type><name>nsIContent</name>*</type> <name>aCondition</name></decl></param>,
                                                       <param><decl><type><name>TestNode</name>*</type> <name>aParentNode</name></decl></param>,
                                                       <param><decl><type><name>TestNode</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Compile a &lt;triple&gt; condition, which must be of the form:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   &lt;triple subject="?var1|resource"</comment>
    <comment type="line">//           predicate="resource"</comment>
    <comment type="line">//           object="?var2|resource|literal" /&gt;</comment>
    <comment type="line">//</comment>
    <comment type="line">// XXXwaterson Some day it would be cool to allow the 'predicate'</comment>
    <comment type="line">// to be bound to a variable.</comment>

    <comment type="line">// subject</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>subject</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aCondition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>subject</name></name></expr></argument>, <argument><expr><name>subject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>svar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>sres</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>subject</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>subject</name><index>[<expr>0</expr>]</index></name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'?'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>svar</name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name>subject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>subject</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>sres</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <comment type="line">// predicate</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>predicate</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aCondition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>predicate</name></name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>pres</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>predicate</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>predicate</name><index>[<expr>0</expr>]</index></name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'?'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("xultemplate[%p] cannot handle variables in &lt;triple&gt; 'predicate'", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>pres</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// object</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>object</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aCondition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>object</name></name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>ovar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFNode</name></expr></argument>&gt;</argument_list></name></type> <name>onode</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>object</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>object</name><index>[<expr>0</expr>]</index></name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'?'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ovar</name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>object</name>.<name>FindChar</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{ <comment type="line">// XXXwaterson evil.</comment>
        <comment type="line">// treat as resource</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>resource</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>onode</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>parseType</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aCondition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>parsetype</name></name></expr></argument>, <argument><expr><name>parseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>ParseLiteral</name><argument_list>(<argument><expr><name>parseType</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>onode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></else></if></else></if>

    <decl_stmt><decl><type><name>nsRDFPropertyTestNode</name>*</type> <name>testnode</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>svar</name> &amp;&amp; <name>ovar</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>testnode</name> = new <call><name>nsRDFPropertyTestNode</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>svar</name></expr></argument>, <argument><expr><name>pres</name></expr></argument>, <argument><expr><name>ovar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>svar</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>testnode</name> = new <call><name>nsRDFPropertyTestNode</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>svar</name></expr></argument>, <argument><expr><name>pres</name></expr></argument>, <argument><expr><name>onode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>ovar</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>testnode</name> = new <call><name>nsRDFPropertyTestNode</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>sres</name></expr></argument>, <argument><expr><name>pres</name></expr></argument>, <argument><expr><name>ovar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("xultemplate[%p] tautology in &lt;triple&gt; test", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></else></if></else></if></else></if>

    <if>if <condition>(<expr>! <name>testnode</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// add testnode to mAllTests first. If adding to mRDFTests fails, just</comment>
    <comment type="line">// leave it in the list so that it can be deleted later.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>testnode</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mRDFTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>testnode</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CompileMemberCondition</name></name><parameter_list>(<param><decl><type><name>nsRDFQuery</name>*</type> <name>aQuery</name></decl></param>,
                                                       <param><decl><type><name>nsIContent</name>*</type> <name>aCondition</name></decl></param>,
                                                       <param><decl><type><name>TestNode</name>*</type> <name>aParentNode</name></decl></param>,
                                                       <param><decl><type><name>TestNode</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Compile a &lt;member&gt; condition, which must be of the form:</comment>
    <comment type="line">//</comment>
    <comment type="line">//   &lt;member container="?var1" child="?var2" /&gt;</comment>
    <comment type="line">//</comment>

    <comment type="line">// container</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>container</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aCondition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>container</name></name></expr></argument>, <argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name><name>container</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>container</name><index>[<expr>0</expr>]</index></name> != <call><name>PRUnichar</name><argument_list>(<argument><expr>'?'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("xultemplate[%p] on &lt;member&gt; test, expected 'container' attribute to name a variable", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>containervar</name> <init>= <expr><call><name>do_GetAtom</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// child</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>child</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aCondition</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>child</name></name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name><name>child</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>child</name><index>[<expr>0</expr>]</index></name> != <call><name>PRUnichar</name><argument_list>(<argument><expr>'?'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gXULTemplateLog</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
               <argument><expr>("xultemplate[%p] on &lt;member&gt; test, expected 'child' attribute to name a variable", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>childvar</name> <init>= <expr><call><name>do_GetAtom</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TestNode</name>*</type> <name>testnode</name> <init>=
        <expr>new <call><name>nsRDFConMemberTestNode</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>,
                                   <argument><expr><name>this</name></expr></argument>,
                                   <argument><expr><name>containervar</name></expr></argument>,
                                   <argument><expr><name>childvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>! <name>testnode</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// add testnode to mAllTests first. If adding to mRDFTests fails, just</comment>
    <comment type="line">// leave it in the list so that it can be deleted later.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>testnode</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mRDFTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>aResult</name> = <name>testnode</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>AddDefaultSimpleRules</name></name><parameter_list>(<param><decl><type><name>nsRDFQuery</name>*</type> <name>aQuery</name></decl></param>,
                                                      <param><decl><type><name>TestNode</name>**</type> <name>aChildNode</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// XXXndeakin should check for tag in query processor instead of builder?</comment>
    <decl_stmt><decl><type><name>nsContentTestNode</name>*</type> <name>idnode</name> <init>=
        <expr>new <call><name>nsContentTestNode</name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                              <argument><expr><name><name>aQuery</name>-&gt;<name>mRefVariable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>! <name>idnode</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// Create (?container ^member ?member)</comment>
    <decl_stmt><decl><type><name>nsRDFConMemberTestNode</name>*</type> <name>membernode</name> <init>=
        <expr>new <call><name>nsRDFConMemberTestNode</name><argument_list>(<argument><expr><name>idnode</name></expr></argument>,
                                   <argument><expr><name>this</name></expr></argument>,
                                   <argument><expr><name><name>aQuery</name>-&gt;<name>mRefVariable</name></name></expr></argument>,
                                   <argument><expr><name><name>aQuery</name>-&gt;<name>mMemberVariable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>! <name>membernode</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>idnode</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// add nodes to mAllTests first. If later calls fail, just leave them in</comment>
    <comment type="line">// the list so that they can be deleted later.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>idnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>idnode</name></expr>;</expr_stmt>
        <expr_stmt><expr>delete <name>membernode</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>membernode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>membernode</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mRDFTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>membernode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>idnode</name>-&gt;<name>AddChild</name></name><argument_list>(<argument><expr><name>membernode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mSimpleRuleMemberTest</name> = <name>membernode</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aChildNode</name> = <name>membernode</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>CompileSimpleQuery</name></name><parameter_list>(<param><decl><type><name>nsRDFQuery</name>*</type> <name>aQuery</name></decl></param>,
                                                   <param><decl><type><name>nsIContent</name>*</type> <name>aQueryElement</name></decl></param>,
                                                   <param><decl><type><name>TestNode</name>**</type> <name>aLastNode</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Compile a "simple" (or old-school style) &lt;template&gt; query.</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TestNode</name>*</type> <name>parentNode</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>! <name>mSimpleRuleMemberTest</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>AddDefaultSimpleRules</name><argument_list>(<argument><expr><name>aQuery</name></expr></argument>, <argument><expr>&amp;<name>parentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>hasContainerTest</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TestNode</name>*</type> <name>prevnode</name> <init>= <expr><name>mSimpleRuleMemberTest</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Add constraints for the LHS</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsAttrName</name>*</type> <name>name</name></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr>(<name>name</name> = <call><name><name>aQueryElement</name>-&gt;<name>GetAttrNameAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <comment type="line">// Note: some attributes must be skipped on XUL template query subtree</comment>

        <comment type="line">// never compare against rdf:property, rdf:instanceOf, {}:id or {}:parsetype attribute</comment>
        <if>if <condition>(<expr><call><name><name>name</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>property</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_RDF</name></expr></argument>)</argument_list></call> ||
            <call><name><name>name</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>instanceOf</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_RDF</name></expr></argument>)</argument_list></call> ||
            <call><name><name>name</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>id</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_None</name></expr></argument>)</argument_list></call> ||
            <call><name><name>name</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>parsetype</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_None</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <decl_stmt><decl><type><name>PRInt32</name></type> <name>attrNameSpaceID</name> <init>= <expr><call><name><name>name</name>-&gt;<name>NamespaceID</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>attrNameSpaceID</name> == <name>kNameSpaceID_XMLNS</name></expr>)</condition><then>
          <continue>continue;</continue></then></if>
        <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>attr</name> <init>= <expr><call><name><name>name</name>-&gt;<name>LocalName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>value</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aQueryElement</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>attrNameSpaceID</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>TestNode</name>*</type> <name>testnode</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>name</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>iscontainer</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_None</name></expr></argument>)</argument_list></call> ||
            <call><name><name>name</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>isempty</name></name></expr></argument>, <argument><expr><name>kNameSpaceID_None</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Tests about containerhood and emptiness. These can be</comment>
            <comment type="line">// globbed together, mostly. Check to see if we've already</comment>
            <comment type="line">// added a container test: we only need one.</comment>
            <if>if <condition>(<expr><name>hasContainerTest</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <decl_stmt><decl><type><name><name>nsRDFConInstanceTestNode</name>::<name>Test</name></name></type> <name>iscontainer</name> <init>=
                <expr><name><name>nsRDFConInstanceTestNode</name>::<name>eDontCare</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><specifier>static</specifier> <name><name>nsIContent</name>::<name>AttrValuesArray</name></name></type> <name><name>strings</name><index>[]</index></name> <init>=
              <expr><block>{<expr>&amp;<name><name>nsGkAtoms</name>::<name>_true</name></name></expr>, <expr>&amp;<name><name>nsGkAtoms</name>::<name>_false</name></name></expr>, <expr><name>nsnull</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><call><name><name>aQueryElement</name>-&gt;<name>FindAttrValueIn</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>,
                                                   <argument><expr><name><name>nsGkAtoms</name>::<name>iscontainer</name></name></expr></argument>,
                                                   <argument><expr><name>strings</name></expr></argument>, <argument><expr><name>eCaseMatters</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <case>case <expr>0</expr>: <expr_stmt><expr><name>iscontainer</name> = <name><name>nsRDFConInstanceTestNode</name>::<name>eTrue</name></name></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr>1</expr>: <expr_stmt><expr><name>iscontainer</name> = <name><name>nsRDFConInstanceTestNode</name>::<name>eFalse</name></name></expr>;</expr_stmt> <break>break;</break>
            </case>}</block></switch>

            <decl_stmt><decl><type><name><name>nsRDFConInstanceTestNode</name>::<name>Test</name></name></type> <name>isempty</name> <init>=
                <expr><name><name>nsRDFConInstanceTestNode</name>::<name>eDontCare</name></name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><call><name><name>aQueryElement</name>-&gt;<name>FindAttrValueIn</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>,
                                                   <argument><expr><name><name>nsGkAtoms</name>::<name>isempty</name></name></expr></argument>,
                                                   <argument><expr><name>strings</name></expr></argument>, <argument><expr><name>eCaseMatters</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <case>case <expr>0</expr>: <expr_stmt><expr><name>isempty</name> = <name><name>nsRDFConInstanceTestNode</name>::<name>eTrue</name></name></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr>1</expr>: <expr_stmt><expr><name>isempty</name> = <name><name>nsRDFConInstanceTestNode</name>::<name>eFalse</name></name></expr>;</expr_stmt> <break>break;</break>
            </case>}</block></switch>

            <expr_stmt><expr><name>testnode</name> = new <call><name>nsRDFConInstanceTestNode</name><argument_list>(<argument><expr><name>prevnode</name></expr></argument>,
                                                    <argument><expr><name>this</name></expr></argument>,
                                                    <argument><expr><name><name>aQuery</name>-&gt;<name>mMemberVariable</name></name></expr></argument>,
                                                    <argument><expr><name>iscontainer</name></expr></argument>,
                                                    <argument><expr><name>isempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>! <name>testnode</name></expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>delete <name>testnode</name></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>mRDFTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>attrNameSpaceID</name> != <name>kNameSpaceID_None</name> || <name>attr</name> != <name><name>nsGkAtoms</name>::<name>parent</name></name></expr>)</condition><then> <block>{
            <comment type="line">// It's a simple RDF test</comment>
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>property</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name><name>nsXULContentUtils</name>::<name>GetResource</name></name><argument_list>(<argument><expr><name>attrNameSpaceID</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <comment type="line">// XXXwaterson this is so manky</comment>
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFNode</name></expr></argument>&gt;</argument_list></name></type> <name>target</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>value</name>.<name>FindChar</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{ <comment type="line">// XXXwaterson WRONG WRONG WRONG!</comment>
                <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>resource</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name><name>gRDFService</name>-&gt;<name>GetUnicodeResource</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>rv</name></expr>;</return></then></if>

                <expr_stmt><expr><name>target</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{                
              <decl_stmt><decl><type><name>nsAutoString</name></type> <name>parseType</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>aQueryElement</name>-&gt;<name>GetAttr</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>parsetype</name></name></expr></argument>, <argument><expr><name>parseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>rv</name> = <call><name>ParseLiteral</name><argument_list>(<argument><expr><name>parseType</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                  <return>return <expr><name>rv</name></expr>;</return></then></if>
            }</block></else></if>

            <expr_stmt><expr><name>testnode</name> = new <call><name>nsRDFPropertyTestNode</name><argument_list>(<argument><expr><name>prevnode</name></expr></argument>, <argument><expr><name>this</name></expr></argument>,
                                                 <argument><expr><name><name>aQuery</name>-&gt;<name>mMemberVariable</name></name></expr></argument>, <argument><expr><name>property</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>! <name>testnode</name></expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>mAllTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>delete <name>testnode</name></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>mRDFTests</name>.<name>Add</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then></if></else></if>

        <if>if <condition>(<expr><name>testnode</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>prevnode</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name><name>prevnode</name>-&gt;<name>AddChild</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>rv</name></expr>;</return></then></if>
            }</block></then>                
            <else>else <block>{
                <expr_stmt><expr><call><name><name>aQuery</name>-&gt;<name>SetRoot</name></name><argument_list>(<argument><expr><name>testnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><name>prevnode</name> = <name>testnode</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr>*<name>aLastNode</name> = <name>prevnode</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>RDFBindingSet</name>*</type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>GetBindingsForRule</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aRuleNode</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>mRuleToBindingsMap</name>.<name>GetWeak</name></name><argument_list>(<argument><expr><name>aRuleNode</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>AddBindingDependency</name></name><parameter_list>(<param><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>aResult</name></decl></param>,
                                                     <param><decl><type><name>nsIRDFResource</name>*</type> <name>aResource</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name>*</type> <name>arr</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>mBindingDependencies</name>.<name>Get</name></name><argument_list>(<argument><expr><name>aResource</name></expr></argument>, <argument><expr>&amp;<name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>arr</name> = new <call><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<call><name><name>mBindingDependencies</name>.<name>Put</name></name><argument_list>(<argument><expr><name>aResource</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>delete <name>arr</name></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>index</name> == -1</expr>)</condition><then>
        <return>return <expr><call><name><name>arr</name>-&gt;<name>AppendObject</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>RemoveBindingDependency</name></name><parameter_list>(<param><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>aResult</name></decl></param>,
                                                        <param><decl><type><name>nsIRDFResource</name>*</type> <name>aResource</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name>*</type> <name>arr</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>mBindingDependencies</name>.<name>Get</name></name><argument_list>(<argument><expr><name>aResource</name></expr></argument>, <argument><expr>&amp;<name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then>
            <return>return <expr><call><name><name>arr</name>-&gt;<name>RemoveObjectAt</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>AddMemoryElements</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Instantiation</name>&amp;</type> <name>aInst</name></decl></param>,
                                                  <param><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Add the result to a table indexed by supporting MemoryElement</comment>
    <decl_stmt><decl><type><name><name>MemoryElementSet</name>::<name>ConstIterator</name></name></type> <name>last</name> <init>= <expr><call><name><name>aInst</name>.<name>mSupport</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name><name>MemoryElementSet</name>::<name>ConstIterator</name></name></type> <name>element</name> <init>= <expr><call><name><name>aInst</name>.<name>mSupport</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
                                         <condition><expr><name>element</name> != <name>last</name></expr>;</condition> <incr><expr>++<name>element</name></expr></incr>) <block>{

        <decl_stmt><decl><type><name>PLHashNumber</name></type> <name>hash</name> <init>= <expr>(<call><name><name>element</name>.<name>operator-&gt;</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>Hash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name>*</type> <name>arr</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>mMemoryElementToResultMap</name>.<name>Get</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr>&amp;<name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>arr</name> = new <call><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then>
                <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

            <if>if <condition>(<expr>!<call><name><name>mMemoryElementToResultMap</name>.<name>Put</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>delete <name>arr</name></expr>;</expr_stmt>
                <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <comment type="line">// results may be added more than once so they will all get deleted properly</comment>
        <expr_stmt><expr><call><name><name>arr</name>-&gt;<name>AppendObject</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>RemoveMemoryElements</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Instantiation</name>&amp;</type> <name>aInst</name></decl></param>,
                                                     <param><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Remove the results mapped by the supporting MemoryElement</comment>
    <decl_stmt><decl><type><name><name>MemoryElementSet</name>::<name>ConstIterator</name></name></type> <name>last</name> <init>= <expr><call><name><name>aInst</name>.<name>mSupport</name>.<name>Last</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name><name>MemoryElementSet</name>::<name>ConstIterator</name></name></type> <name>element</name> <init>= <expr><call><name><name>aInst</name>.<name>mSupport</name>.<name>First</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
                                         <condition><expr><name>element</name> != <name>last</name></expr>;</condition> <incr><expr>++<name>element</name></expr></incr>) <block>{

        <decl_stmt><decl><type><name>PLHashNumber</name></type> <name>hash</name> <init>= <expr>(<call><name><name>element</name>.<name>operator-&gt;</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>Hash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name>*</type> <name>arr</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>mMemoryElementToResultMap</name>.<name>Get</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr>&amp;<name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>arr</name>-&gt;<name>RemoveObjectAt</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>! <name>length</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>mMemoryElementToResultMap</name>.<name>Remove</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>RetractElement</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>MemoryElement</name>&amp;</type> <name>aMemoryElement</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>! <name>mBuilder</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <comment type="line">// when an assertion is removed, look through the memory elements and</comment>
    <comment type="line">// find results that are associated with them. Those results will need</comment>
    <comment type="line">// to be removed because they no longer match.</comment>
    <decl_stmt><decl><type><name>PLHashNumber</name></type> <name>hash</name> <init>= <expr><call><name><name>aMemoryElement</name>.<name>Hash</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsXULTemplateResultRDF</name></expr></argument>&gt;</argument_list></name>*</type> <name>arr</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>mMemoryElementToResultMap</name>.<name>Get</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr>&amp;<name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>PRInt32</name></type> <name>r</name> <init>= <expr><name>length</name> - 1</expr></init></decl>;</init> <condition><expr><name>r</name> &gt;= 0</expr>;</condition> <incr><expr><name>r</name>--</expr></incr>) <block>{
            <decl_stmt><decl><type><name>nsXULTemplateResultRDF</name>*</type> <name>result</name> <init>= <expr>(*<name>arr</name>)<index>[<expr><name>r</name></expr>]</index></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
                <comment type="line">// because the memory elements are hashed by an integer,</comment>
                <comment type="line">// sometimes two different memory elements will have the same</comment>
                <comment type="line">// hash code. In this case we check the result to make sure</comment>
                <comment type="line">// and only remove those that refer to that memory element.</comment>
                <if>if <condition>(<expr><call><name><name>result</name>-&gt;<name>HasMemoryElement</name></name><argument_list>(<argument><expr><name>aMemoryElement</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>nsITemplateRDFQuery</name>*</type> <name>query</name> <init>= <expr><call><name><name>result</name>-&gt;<name>Query</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>query</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>querynode</name></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>query</name>-&gt;<name>GetQueryNode</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>querynode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name><name>mBuilder</name>-&gt;<name>RemoveResult</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="line">// a call to RemoveMemoryElements may have removed it</comment>
                    <if>if <condition>(<expr>!<call><name><name>mMemoryElementToResultMap</name>.<name>Get</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return;</return></then></if>

                    <comment type="line">// the array should have been reduced by one, but check</comment>
                    <comment type="line">// just to make sure</comment>
                    <decl_stmt><decl><type><name>PRUint32</name></type> <name>newlength</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>r</name> &gt; (<name>PRInt32</name>)<name>newlength</name></expr>)</condition><then>
                        <expr_stmt><expr><name>r</name> = <name>newlength</name></expr>;</expr_stmt></then></if>
                }</block></then></if>
            }</block></then></if>
        }</block></for>

        <comment type="line">// if there are no items left, remove the memory element from the hashtable</comment>
        <if>if <condition>(<expr>!<call><name><name>arr</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mMemoryElementToResultMap</name>.<name>Remove</name></name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>GetContainerIndexOf</name></name><parameter_list>(<param><decl><type><name>nsIXULTemplateResult</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// get the reference variable and look up the container in the result</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>ref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aResult</name>-&gt;<name>GetBindingObjectFor</name></name><argument_list>(<argument><expr><name>mRefVariable</name></expr></argument>,
                                               <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>container</name></expr>)</condition><then> <block>{
        <comment type="line">// if the container is an RDF Seq, return the index of the result</comment>
        <comment type="line">// in the container.</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>isSequence</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>gRDFContainerUtils</name>-&gt;<name>IsSeq</name></name><argument_list>(<argument><expr><name>mDB</name></expr></argument>, <argument><expr><name>container</name></expr></argument>, <argument><expr>&amp;<name>isSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>isSequence</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>resource</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>aResult</name>-&gt;<name>GetResource</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>resource</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>gRDFContainerUtils</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>mDB</name></expr></argument>, <argument><expr><name>container</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>index</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// if the container isn't a Seq, or the result isn't in the container,</comment>
    <comment type="line">// return -1 indicating no index.</comment>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsXULTemplateQueryProcessorRDF</name>::<name>GetSortValue</name></name><parameter_list>(<param><decl><type><name>nsIXULTemplateResult</name>*</type> <name>aResult</name></decl></param>,
                                             <param><decl><type><name>nsIRDFResource</name>*</type> <name>aPredicate</name></decl></param>,
                                             <param><decl><type><name>nsIRDFResource</name>*</type> <name>aSortPredicate</name></decl></param>,
                                             <param><decl><type><name>nsISupports</name>**</type> <name>aResultNode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFResource</name></expr></argument>&gt;</argument_list></name></type> <name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aResult</name>-&gt;<name>GetResource</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRDFNode</name></expr></argument>&gt;</argument_list></name></type> <name>value</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>source</name></expr>)</condition><then> <block>{
        <comment type="line">// first check predicate?sort=true so that datasources may use a</comment>
        <comment type="line">// custom value for sorting</comment>
        <expr_stmt><expr><name>rv</name> = <call><name><name>mDB</name>-&gt;<name>GetTarget</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>aSortPredicate</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>,
                            <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name><name>mDB</name>-&gt;<name>GetTarget</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>aPredicate</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>,
                                <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr>*<name>aResultNode</name> = <name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aResultNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
</unit>
