<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0071a6fafae3714b0137fb89100244b2dfe42a8b.c"><comment type="block">/* cairo - a vector graphics library with display and print output
 *
 * Copyright Â© 2002 University of Southern California
 *
 * This library is free software; you can redistribute it and/or
 * modify it either under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation
 * (the "LGPL") or, at your option, under the terms of the Mozilla
 * Public License Version 1.1 (the "MPL"). If you do not alter this
 * notice, a recipient may use your version of this file under either
 * the MPL or the LGPL.
 *
 * You should have received a copy of the LGPL along with this library
 * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * You should have received a copy of the MPL along with this library
 * in the file COPYING-MPL-1.1
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
 * OF ANY KIND, either express or implied. See the LGPL or the MPL for
 * the specific language governing rights and limitations.
 *
 * The Original Code is the cairo graphics library.
 *
 * The Initial Developer of the Original Code is University of Southern
 * California.
 *
 * Contributor(s):
 *	Carl D. Worth &lt;cworth@cworth.org&gt;
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cairoint.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_spline_grow_by</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>int</name></type> <name>additional</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_spline_add_point</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>point</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>_lerp_half</name> <parameter_list>(<param><decl><type><name>cairo_point_t</name> *</type><name>a</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>result</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>_de_casteljau</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>cairo_spline_t</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>cairo_spline_t</name> *</type><name>s2</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>double</name></type>
<name>_cairo_spline_error_squared</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_spline_decompose_into</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>double</name></type> <name>tolerance_squared</name></decl></param>, <param><decl><type><name>cairo_spline_t</name> *</type><name>result</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>cairo_int_status_t</name></type>
<name>_cairo_spline_init</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>,
		    <param><decl><type><name>cairo_point_t</name> *</type><name>a</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>b</name></decl></param>,
		    <param><decl><type><name>cairo_point_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>d</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>a</name></name> = *<name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>b</name></name> = *<name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>c</name></name> = *<name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>d</name></name> = *<name>d</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>x</name></name> != <name><name>b</name>-&gt;<name>x</name></name> || <name><name>a</name>-&gt;<name>y</name></name> != <name><name>b</name>-&gt;<name>y</name></name></expr>)</condition><then>
	<expr_stmt><expr><call><name>_cairo_slope_init</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>initial_slope</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>x</name></name> != <name><name>c</name>-&gt;<name>x</name></name> || <name><name>a</name>-&gt;<name>y</name></name> != <name><name>c</name>-&gt;<name>y</name></name></expr>)</condition><then>
	<expr_stmt><expr><call><name>_cairo_slope_init</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>initial_slope</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>x</name></name> != <name><name>d</name>-&gt;<name>x</name></name> || <name><name>a</name>-&gt;<name>y</name></name> != <name><name>d</name>-&gt;<name>y</name></name></expr>)</condition><then>
	<expr_stmt><expr><call><name>_cairo_slope_init</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>initial_slope</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
	<return>return <expr><name>CAIRO_INT_STATUS_DEGENERATE</name></expr>;</return></else></if></else></if></else></if>

    <if>if <condition>(<expr><name><name>c</name>-&gt;<name>x</name></name> != <name><name>d</name>-&gt;<name>x</name></name> || <name><name>c</name>-&gt;<name>y</name></name> != <name><name>d</name>-&gt;<name>y</name></name></expr>)</condition><then>
	<expr_stmt><expr><call><name>_cairo_slope_init</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>final_slope</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>x</name></name> != <name><name>d</name>-&gt;<name>x</name></name> || <name><name>b</name>-&gt;<name>y</name></name> != <name><name>d</name>-&gt;<name>y</name></name></expr>)</condition><then>
	<expr_stmt><expr><call><name>_cairo_slope_init</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>final_slope</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
	<expr_stmt><expr><call><name>_cairo_slope_init</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>final_slope</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

    <expr_stmt><expr><name><name>spline</name>-&gt;<name>num_points</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points_size</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>_cairo_spline_fini</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>num_points</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points_size</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>spline</name>-&gt;<name>points</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_spline_grow_by</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>int</name></type> <name>additional</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_point_t</name> *</type><name>new_points</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>old_size</name> <init>= <expr><name><name>spline</name>-&gt;<name>points_size</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_size</name> <init>= <expr><name><name>spline</name>-&gt;<name>num_points</name></name> + <name>additional</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>new_size</name> &lt;= <name><name>spline</name>-&gt;<name>points_size</name></name></expr>)</condition><then>
	<return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points_size</name></name> = <name>new_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_points</name> = <call><name>realloc</name> <argument_list>(<argument><expr><name><name>spline</name>-&gt;<name>points</name></name></expr></argument>, <argument><expr><name><name>spline</name>-&gt;<name>points_size</name></name> * <sizeof>sizeof <argument_list>(<argument><expr><name>cairo_point_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>new_points</name> == <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>spline</name>-&gt;<name>points_size</name></name> = <name>old_size</name></expr>;</expr_stmt>
	<return>return <expr><name>CAIRO_STATUS_NO_MEMORY</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points</name></name> = <name>new_points</name></expr>;</expr_stmt>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_spline_add_point</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>point</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_point_t</name> *</type><name>prev</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>spline</name>-&gt;<name>num_points</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>prev</name> = &amp;<name><name>spline</name>-&gt;<name>points</name><index>[<expr><name><name>spline</name>-&gt;<name>num_points</name></name> - 1</expr>]</index></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>prev</name>-&gt;<name>x</name></name> == <name><name>point</name>-&gt;<name>x</name></name> &amp;&amp; <name><name>prev</name>-&gt;<name>y</name></name> == <name><name>point</name>-&gt;<name>y</name></name></expr>)</condition><then>
	    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>spline</name>-&gt;<name>num_points</name></name> &gt;= <name><name>spline</name>-&gt;<name>points_size</name></name></expr>)</condition><then> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>additional</name> <init>= <expr><name><name>spline</name>-&gt;<name>points_size</name></name> ? <name><name>spline</name>-&gt;<name>points_size</name></name> : 32</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>status</name> = <call><name>_cairo_spline_grow_by</name> <argument_list>(<argument><expr><name>spline</name></expr></argument>, <argument><expr><name>additional</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>status</name></expr>)</condition><then>
	    <return>return <expr><name>status</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>spline</name>-&gt;<name>points</name><index>[<expr><name><name>spline</name>-&gt;<name>num_points</name></name></expr>]</index></name> = *<name>point</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>spline</name>-&gt;<name>num_points</name></name>++</expr>;</expr_stmt>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_lerp_half</name> <parameter_list>(<param><decl><type><name>cairo_point_t</name> *</type><name>a</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>result</name>-&gt;<name>x</name></name> = <name><name>a</name>-&gt;<name>x</name></name> + ((<name><name>b</name>-&gt;<name>x</name></name> - <name><name>a</name>-&gt;<name>x</name></name>) &gt;&gt; 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>y</name></name> = <name><name>a</name>-&gt;<name>y</name></name> + ((<name><name>b</name>-&gt;<name>y</name></name> - <name><name>a</name>-&gt;<name>y</name></name>) &gt;&gt; 1)</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_de_casteljau</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>cairo_spline_t</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>cairo_spline_t</name> *</type><name>s2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_point_t</name></type> <name>ab</name></decl>, <decl><type ref="prev"/><name>bc</name></decl>, <decl><type ref="prev"/><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_point_t</name></type> <name>abbc</name></decl>, <decl><type ref="prev"/><name>bccd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_point_t</name></type> <name>final</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>_lerp_half</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr>&amp;<name>ab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_lerp_half</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr>&amp;<name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_lerp_half</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>, <argument><expr>&amp;<name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_lerp_half</name> <argument_list>(<argument><expr>&amp;<name>ab</name></expr></argument>, <argument><expr>&amp;<name>bc</name></expr></argument>, <argument><expr>&amp;<name>abbc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_lerp_half</name> <argument_list>(<argument><expr>&amp;<name>bc</name></expr></argument>, <argument><expr>&amp;<name>cd</name></expr></argument>, <argument><expr>&amp;<name>bccd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_lerp_half</name> <argument_list>(<argument><expr>&amp;<name>abbc</name></expr></argument>, <argument><expr>&amp;<name>bccd</name></expr></argument>, <argument><expr>&amp;<name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s1</name>-&gt;<name>a</name></name> = <name><name>spline</name>-&gt;<name>a</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s1</name>-&gt;<name>b</name></name> = <name>ab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s1</name>-&gt;<name>c</name></name> = <name>abbc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s1</name>-&gt;<name>d</name></name> = <name>final</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s2</name>-&gt;<name>a</name></name> = <name>final</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s2</name>-&gt;<name>b</name></name> = <name>bccd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s2</name>-&gt;<name>c</name></name> = <name>cd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s2</name>-&gt;<name>d</name></name> = <name><name>spline</name>-&gt;<name>d</name></name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>_PointDistanceSquaredToPoint</name> <parameter_list>(<param><decl><type><name>cairo_point_t</name> *</type><name>a</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name>dx</name> <init>= <expr><call><name>_cairo_fixed_to_double</name> <argument_list>(<argument><expr><name><name>b</name>-&gt;<name>x</name></name> - <name><name>a</name>-&gt;<name>x</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dy</name> <init>= <expr><call><name>_cairo_fixed_to_double</name> <argument_list>(<argument><expr><name><name>b</name>-&gt;<name>y</name></name> - <name><name>a</name>-&gt;<name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><name>dx</name>*<name>dx</name> + <name>dy</name>*<name>dy</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>_PointDistanceSquaredToSegment</name> <parameter_list>(<param><decl><type><name>cairo_point_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>p1</name></decl></param>, <param><decl><type><name>cairo_point_t</name> *</type><name>p2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>dx</name></decl>, <decl><type ref="prev"/><name>dy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>pdx</name></decl>, <decl><type ref="prev"/><name>pdy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_point_t</name></type> <name>px</name></decl>;</decl_stmt>

    <comment type="block">/* intersection point (px):

       px = p1 + u(p2 - p1)
       (p - px) . (p2 - p1) = 0

       Thus:

       u = ((p - p1) . (p2 - p1)) / (||(p2 - p1)|| ^ 2);
    */</comment>

    <expr_stmt><expr><name>dx</name> = <call><name>_cairo_fixed_to_double</name> <argument_list>(<argument><expr><name><name>p2</name>-&gt;<name>x</name></name> - <name><name>p1</name>-&gt;<name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dy</name> = <call><name>_cairo_fixed_to_double</name> <argument_list>(<argument><expr><name><name>p2</name>-&gt;<name>y</name></name> - <name><name>p1</name>-&gt;<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>dx</name> == 0 &amp;&amp; <name>dy</name> == 0</expr>)</condition><then>
	<return>return <expr><call><name>_PointDistanceSquaredToPoint</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>pdx</name> = <call><name>_cairo_fixed_to_double</name> <argument_list>(<argument><expr><name><name>p</name>-&gt;<name>x</name></name> - <name><name>p1</name>-&gt;<name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pdy</name> = <call><name>_cairo_fixed_to_double</name> <argument_list>(<argument><expr><name><name>p</name>-&gt;<name>y</name></name> - <name><name>p1</name>-&gt;<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>u</name> = (<name>pdx</name> * <name>dx</name> + <name>pdy</name> * <name>dy</name>) / (<name>dx</name>*<name>dx</name> + <name>dy</name>*<name>dy</name>)</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>u</name> &lt;= 0</expr>)</condition><then>
	<return>return <expr><call><name>_PointDistanceSquaredToPoint</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else <if>if <condition>(<expr><name>u</name> &gt;= 1</expr>)</condition><then>
	<return>return <expr><call><name>_PointDistanceSquaredToPoint</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

    <expr_stmt><expr><name><name>px</name>.<name>x</name></name> = <name><name>p1</name>-&gt;<name>x</name></name> + <call><name>u</name> * <argument_list>(<argument><expr><name><name>p2</name>-&gt;<name>x</name></name> - <name><name>p1</name>-&gt;<name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>px</name>.<name>y</name></name> = <name><name>p1</name>-&gt;<name>y</name></name> + <call><name>u</name> * <argument_list>(<argument><expr><name><name>p2</name>-&gt;<name>y</name></name> - <name><name>p1</name>-&gt;<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>_PointDistanceSquaredToPoint</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>px</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return an upper bound on the error (squared) that could result from approximating
   a spline as a line segment connecting the two endpoints */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>_cairo_spline_error_squared</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name>berr</name></decl>, <decl><type ref="prev"/><name>cerr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>berr</name> = <call><name>_PointDistanceSquaredToSegment</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cerr</name> = <call><name>_PointDistanceSquaredToSegment</name> <argument_list>(<argument><expr>&amp;<name><name>spline</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>berr</name> &gt; <name>cerr</name></expr>)</condition><then>
	<return>return <expr><name>berr</name></expr>;</return></then>
    <else>else
	<return>return <expr><name>cerr</name></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>cairo_status_t</name></type>
<name>_cairo_spline_decompose_into</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>double</name></type> <name>tolerance_squared</name></decl></param>, <param><decl><type><name>cairo_spline_t</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cairo_spline_t</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>_cairo_spline_error_squared</name> <argument_list>(<argument><expr><name>spline</name></expr></argument>)</argument_list></call> &lt; <name>tolerance_squared</name></expr>)</condition><then> <block>{
	<return>return <expr><call><name>_cairo_spline_add_point</name> <argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>a</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>_de_casteljau</name> <argument_list>(<argument><expr><name>spline</name></expr></argument>, <argument><expr>&amp;<name>s1</name></expr></argument>, <argument><expr>&amp;<name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>status</name> = <call><name>_cairo_spline_decompose_into</name> <argument_list>(<argument><expr>&amp;<name>s1</name></expr></argument>, <argument><expr><name>tolerance_squared</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
	<return>return <expr><name>status</name></expr>;</return></then></if>

    <expr_stmt><expr><name>status</name> = <call><name>_cairo_spline_decompose_into</name> <argument_list>(<argument><expr>&amp;<name>s2</name></expr></argument>, <argument><expr><name>tolerance_squared</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
	<return>return <expr><name>status</name></expr>;</return></then></if>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>cairo_status_t</name></type>
<name>_cairo_spline_decompose</name> <parameter_list>(<param><decl><type><name>cairo_spline_t</name> *</type><name>spline</name></decl></param>, <param><decl><type><name>double</name></type> <name>tolerance</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cairo_status_t</name></type> <name>status</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>spline</name>-&gt;<name>points_size</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>_cairo_spline_fini</name> <argument_list>(<argument><expr><name>spline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>status</name> = <call><name>_cairo_spline_decompose_into</name> <argument_list>(<argument><expr><name>spline</name></expr></argument>, <argument><expr><name>tolerance</name> * <name>tolerance</name></expr></argument>, <argument><expr><name>spline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
	<return>return <expr><name>status</name></expr>;</return></then></if>

    <expr_stmt><expr><name>status</name> = <call><name>_cairo_spline_add_point</name> <argument_list>(<argument><expr><name>spline</name></expr></argument>, <argument><expr>&amp;<name><name>spline</name>-&gt;<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
	<return>return <expr><name>status</name></expr>;</return></then></if>

    <return>return <expr><name>CAIRO_STATUS_SUCCESS</name></expr>;</return>
}</block></function>
</unit>
