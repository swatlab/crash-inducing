<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00616b4d7a1cee87e32107006cae1c0bb27671cd.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS script operations.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdbgapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsemit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstracer.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XDR</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsxdrapi.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscriptinlines.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SCRIPT_OBJECT</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>js_script_exec_str</name><index>[]</index></name>    <init>= <expr>"Script.prototype.exec"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>js_script_compile_str</name><index>[]</index></name> <init>= <expr>"Script.prototype.compile"</expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This routine requires that obj has been locked previously.
 */</comment>
<function><type><specifier>static</specifier> <name>jsint</name></type>
<name>GetScriptExecDepth</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_IS_OBJ_LOCKED</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> = <call><name>LOCKED_OBJ_GET_SLOT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>JSSLOT_START</name><argument_list>(<argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustScriptExecDepth</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsint</name></type> <name>delta</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsint</name></type> <name>execDepth</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>execDepth</name> = <call><name>GetScriptExecDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOCKED_OBJ_SET_SLOT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>JSSLOT_START</name><argument_list>(<argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>execDepth</name> + <name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_toSource</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>indent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>obj</name> = <call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>indent</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>indent</name> = <call><name>js_ValueToECMAUint32</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>script</name> = (<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Let n count the source string length, j the "front porch" length. */</comment>
    <expr_stmt><expr><name>j</name> = <call><name>JS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>, <argument><expr>"(new %s("</expr></argument>, <argument><expr><name><name>js_ScriptClass</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> = <name>j</name> + 2</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then> <block>{
        <comment type="block">/* Let k count the constructor argument string length. */</comment>
        <expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> = <name>NULL</name></expr>;</expr_stmt>               <comment type="block">/* quell GCC overwarning */</comment>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>str</name> = <call><name>JS_DecompileScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr>"Script.prototype.toSource"</expr></argument>,
                                 <argument><expr>(<name>uintN</name>)<name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>str</name> = <call><name>js_QuoteString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>'\''</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>str</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> += <name>k</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Allocate the source string and copy into it. */</comment>
    <expr_stmt><expr><name>t</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>n</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>t</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>k</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>)
        <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>
    <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <comment type="block">/* Create and return a JS string for t. */</comment>
    <expr_stmt><expr><name>str</name> = <call><name>JS_NewUCString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_TOSOURCE */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_toString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>indent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>indent</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>indent</name> = <call><name>js_ValueToECMAUint32</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>obj</name> = <call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>script</name> = (<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>str</name> = <call><name>JS_DecompileScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr>"Script.prototype.toString"</expr></argument>,
                             <argument><expr>(<name>uintN</name>)<name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_compile_sub</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>,
                   <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>scopeobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>, *<decl><type ref="prev"/><name>oldscript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>caller</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrincipals</name> *</type><name>principals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tcflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>execDepth</name></decl>;</decl_stmt>

    <comment type="block">/* Make sure obj is a Script object. */</comment>
    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/* If no args, leave private undefined and return early. */</comment>
    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <comment type="block">/* Otherwise, the first arg is the script source to compile. */</comment>
    <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scopeobj</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> &gt;= 2</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_ValueToObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>scopeobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>scopeobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Compile using the caller's scope chain, which js_Invoke passes to fp. */</comment>
    <expr_stmt><expr><name>caller</name> = <call><name>js_GetScriptedCaller</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>caller</name> || <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name> == <name><name>caller</name>-&gt;<name>scopeChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>caller</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>scopeobj</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>scopeobj</name> = <call><name>js_GetScopeChain</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>scopeobj</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <expr_stmt><expr><name>principals</name> = <call><name>JS_EvalFramePrincipals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name>caller</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>file</name> = <call><name>js_ComputeFilename</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>principals</name></expr></argument>, <argument><expr>&amp;<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>file</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>line</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>principals</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Ensure we compile this script with the right (inner) principals. */</comment>
    <expr_stmt><expr><name>scopeobj</name> = <call><name>js_CheckScopeChainValidity</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>scopeobj</name></expr></argument>, <argument><expr><name>js_script_compile_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>scopeobj</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/*
     * Compile the new script using the caller's scope chain, a la eval().
     * Unlike jsobj.c:obj_eval, however, we do not pass TCF_COMPILE_N_GO in
     * tcflags and use NULL for the callerFrame argument, because compilation
     * is here separated from execution, and the run-time scope chain may not
     * match the compile-time. TCF_COMPILE_N_GO is tested in jsemit.c and
     * jsparse.c to optimize based on identity of run- and compile-time scope.
     */</comment>
    <expr_stmt><expr><name>tcflags</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>script</name> = <call><name><name>JSCompiler</name>::<name>compileScript</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>scopeobj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>principals</name></expr></argument>, <argument><expr><name>tcflags</name></expr></argument>,
                                       <argument><expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>execDepth</name> = <call><name>GetScriptExecDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * execDepth must be 0 to allow compilation here, otherwise the JSScript
     * struct can be released while running.
     */</comment>
    <if>if <condition>(<expr><name>execDepth</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_COMPILE_EXECED_SCRIPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Swap script for obj's old script, if any. */</comment>
    <expr_stmt><expr><name>oldscript</name> = (<name>JSScript</name>*) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>oldscript</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_DestroyScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>oldscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>script</name>-&gt;<name>u</name>.<name>object</name></name> = <name>obj</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_CallNewScriptHook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
    <comment type="block">/* Return the object. */</comment>
    <expr_stmt><expr>*<name>rval</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_compile</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>script_compile_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_exec_sub</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>,
                <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>scopeobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>caller</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrincipals</name> *</type><name>principals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>scopeobj</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_ValueToObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>scopeobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>scopeobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Emulate eval() by using caller's this, var object, sharp array, etc.,
     * all propagated by js_Execute via a non-null fourth (down) argument to
     * js_Execute.  If there is no scripted caller, js_Execute uses its second
     * (chain) argument to set the exec frame's varobj, thisv, and scopeChain.
     *
     * Unlike eval, which the compiler detects, Script.prototype.exec may be
     * called from a lightweight function, or even from native code (in which
     * case fp-&gt;varobj and fp-&gt;scopeChain are null).  If exec is called from
     * a lightweight function, we will need to get a Call object representing
     * its frame, to act as the var object and scope chain head.
     */</comment>
    <expr_stmt><expr><name>caller</name> = <call><name>js_GetScriptedCaller</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>caller</name> &amp;&amp; !<name><name>caller</name>-&gt;<name>varobj</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Called from a lightweight function. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>caller</name>-&gt;<name>fun</name></name> &amp;&amp; !<call><name>JSFUN_HEAVYWEIGHT_TEST</name><argument_list>(<argument><expr><name><name>caller</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Scope chain links from Call object to caller's scope chain. */</comment>
        <if>if <condition>(<expr>!<call><name>js_GetCallObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>scopeobj</name></expr>)</condition><then> <block>{
        <comment type="block">/* No scope object passed in: try to use the caller's scope chain. */</comment>
        <if>if <condition>(<expr><name>caller</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Load caller-&gt;scopeChain after the conditional js_GetCallObject
             * call above, which resets scopeChain as well as varobj.
             */</comment>
            <expr_stmt><expr><name>scopeobj</name> = <call><name>js_GetScopeChain</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>scopeobj</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * Called from native code, so we don't know what scope object to
             * use.  We could use the caller's scope chain (see above), but Script.prototype.exec
             * might be a shared/sealed "superglobal" method.  A more general
             * approach would use cx-&gt;globalObject, which will be the same as
             * exec.__parent__ in the non-superglobal case.  In the superglobal
             * case it's the right object: the global, not the superglobal.
             */</comment>
            <expr_stmt><expr><name>scopeobj</name> = <name><name>cx</name>-&gt;<name>globalObject</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>scopeobj</name> = <call><name>js_CheckScopeChainValidity</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>scopeobj</name></expr></argument>, <argument><expr><name>js_script_exec_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>scopeobj</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/* Keep track of nesting depth for the script. */</comment>
    <expr_stmt><expr><call><name>AdjustScriptExecDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Must get to out label after this */</comment>
    <expr_stmt><expr><name>script</name> = (<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <comment type="block">/* Belt-and-braces: check that this script object has access to scopeobj. */</comment>
    <expr_stmt><expr><name>principals</name> = <name><name>script</name>-&gt;<name>principals</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>js_CheckPrincipalsAccess</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>scopeobj</name></expr></argument>, <argument><expr><name>principals</name></expr></argument>,
                                  <argument><expr><call><name>CLASS_ATOM</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>Script</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <expr_stmt><expr><name>ok</name> = <call><name>js_Execute</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>scopeobj</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>JSFRAME_EVAL</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
    <expr_stmt><expr><call><name>AdjustScriptExecDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_exec</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>script_exec_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SCRIPT_OBJECT */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XDR</name></expr></cpp:if>

<function><type><name>JSBool</name></type>
<name>js_XDRScript</name><parameter_list>(<param><decl><type><name>JSXDRState</name> *</type><name>xdr</name></decl></param>, <param><decl><type><name>JSScript</name> **</type><name>scriptp</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>hasMagic</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>, *<decl><type ref="prev"/><name>oldscript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>lineno</name></decl>, <decl><type ref="prev"/><name>nslots</name></decl>, <decl><type ref="prev"/><name>magic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>natoms</name></decl>, <decl><type ref="prev"/><name>nsrcnotes</name></decl>, <decl><type ref="prev"/><name>ntrynotes</name></decl>, <decl><type ref="prev"/><name>nobjects</name></decl>, <decl><type ref="prev"/><name>nupvars</name></decl>, <decl><type ref="prev"/><name>nregexps</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>prologLength</name></decl>, <decl><type ref="prev"/><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTempValueRooter</name></type> <name>tvr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPrincipals</name> *</type><name>principals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>encodeable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>filenameWasSaved</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>notes</name></decl>, *<decl><type ref="prev"/><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSecurityCallbacks</name> *</type><name>callbacks</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cx</name> = <name><name>xdr</name>-&gt;<name>cx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>script</name> = *<name>scriptp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nsrcnotes</name> = <name>ntrynotes</name> = <name>natoms</name> = <name>nobjects</name> = <name>nupvars</name> = <name>nregexps</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>filenameWasSaved</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>notes</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then>
        <expr_stmt><expr><name>magic</name> = <name>JSXDR_MAGIC_SCRIPT_CURRENT</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>magic</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>magic</name> != <name>JSXDR_MAGIC_SCRIPT_CURRENT</name></expr>)</condition><then> <block>{
        <comment type="block">/* We do not provide binary compatibility with older scripts. */</comment>
        <if>if <condition>(<expr>!<name>hasMagic</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>JSMSG_BAD_SCRIPT_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr>*<name>hasMagic</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>hasMagic</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>hasMagic</name> = <name>JS_TRUE</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>length</name> = <name><name>script</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prologLength</name> = <name><name>script</name>-&gt;<name>main</name></name> - <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>int16</name>)<name><name>script</name>-&gt;<name>version</name></name> != <name>JSVERSION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>version</name> = (<name>uint32</name>)<name><name>script</name>-&gt;<name>version</name></name> | (<name><name>script</name>-&gt;<name>nfixed</name></name> &lt;&lt; 16)</expr>;</expr_stmt>
        <expr_stmt><expr><name>lineno</name> = (<name>uint32</name>)<name><name>script</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nslots</name> = (<name>uint32</name>)<name><name>script</name>-&gt;<name>nslots</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nslots</name> = <call>(<name>uint32</name>)<argument_list>(<argument><expr>(<name><name>script</name>-&gt;<name>staticLevel</name></name> &lt;&lt; 16) | <name><name>script</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>natoms</name> = (<name>uint32</name>)<name><name>script</name>-&gt;<name>atomMap</name>.<name>length</name></name></expr>;</expr_stmt>

        <comment type="block">/* Count the srcnotes, keeping notes pointing at the first one. */</comment>
        <expr_stmt><expr><name>notes</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>sn</name> = <name>notes</name></expr>;</init> <condition><expr>!<call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>)
            <continue>continue;</continue></for>
        <expr_stmt><expr><name>nsrcnotes</name> = <name>sn</name> - <name>notes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nsrcnotes</name>++</expr>;</expr_stmt>            <comment type="block">/* room for the terminator */</comment>

        <if>if <condition>(<expr><name><name>script</name>-&gt;<name>objectsOffset</name></name> != 0</expr>)</condition><then>
            <expr_stmt><expr><name>nobjects</name> = <call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>script</name>-&gt;<name>upvarsOffset</name></name> != 0</expr>)</condition><then>
            <expr_stmt><expr><name>nupvars</name> = <call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>script</name>-&gt;<name>regexpsOffset</name></name> != 0</expr>)</condition><then>
            <expr_stmt><expr><name>nregexps</name> = <call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>script</name>-&gt;<name>trynotesOffset</name></name> != 0</expr>)</condition><then>
            <expr_stmt><expr><name>ntrynotes</name> = <call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>prologLength</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>version</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/*
     * To fuse allocations, we need srcnote, atom, objects, upvar, regexp,
     * and trynote counts early.
     */</comment>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>natoms</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>nsrcnotes</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>ntrynotes</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>nobjects</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>nupvars</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>nregexps</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_DECODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>script</name> = <call><name>js_NewScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>nsrcnotes</name></expr></argument>, <argument><expr><name>natoms</name></expr></argument>, <argument><expr><name>nobjects</name></expr></argument>, <argument><expr><name>nupvars</name></expr></argument>,
                              <argument><expr><name>nregexps</name></expr></argument>, <argument><expr><name>ntrynotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name><name>script</name>-&gt;<name>main</name></name> += <name>prologLength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>version</name></name> = <call><name>JSVersion</name><argument_list>(<argument><expr><name>version</name> &amp; 0xffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>nfixed</name></name> = <call><name>uint16</name><argument_list>(<argument><expr><name>version</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we know nsrcnotes, we allocated space for notes in script. */</comment>
        <expr_stmt><expr><name>notes</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>scriptp</name> = <name>script</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_PUSH_TEMP_ROOT_SCRIPT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Control hereafter must goto error on failure, in order for the
     * DECODE case to destroy script.
     */</comment>
    <expr_stmt><expr><name>oldscript</name> = <name><name>xdr</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> = <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>code</name> = <call><name>js_UntrapScriptCode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>code</name></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>xdr</name>-&gt;<name>script</name></name> = <name>script</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>JS_XDRBytes</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>code</name></expr></argument>, <argument><expr><name>length</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>code</name> != <name><name>script</name>-&gt;<name>code</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>error</name>;</goto></then></if>

    <if>if <condition>(<expr>!<call><name>JS_XDRBytes</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>notes</name></expr></argument>, <argument><expr><name>nsrcnotes</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> ||
        !<call><name>JS_XDRCStringOrNull</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>(<name>char</name> **)&amp;<name><name>script</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call> ||
        !<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>lineno</name></expr></argument>)</argument_list></call> ||
        !<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>nslots</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <goto>goto <name>error</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>callbacks</name> = <call><name>JS_GetSecurityCallbacks</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>principals</name> = <name><name>script</name>-&gt;<name>principals</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>encodeable</name> = <name>callbacks</name> &amp;&amp; <name><name>callbacks</name>-&gt;<name>principalsTranscoder</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>encodeable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
        <if>if <condition>(<expr><name>encodeable</name> &amp;&amp;
            !<call><name><name>callbacks</name>-&gt;<name>principalsTranscoder</name></name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>principals</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <goto>goto <name>error</name>;</goto>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>encodeable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
        <if>if <condition>(<expr><name>encodeable</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!(<name>callbacks</name> &amp;&amp; <name><name>callbacks</name>-&gt;<name>principalsTranscoder</name></name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_CANT_DECODE_PRINCIPALS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>error</name>;</goto>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name><name>callbacks</name>-&gt;<name>principalsTranscoder</name></name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>principals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>error</name>;</goto></then></if>
            <expr_stmt><expr><name><name>script</name>-&gt;<name>principals</name></name> = <name>principals</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_DECODE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><name><name>script</name>-&gt;<name>filename</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>filename</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>filename</name> = <call><name>js_SaveScriptFilename</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>filename</name></expr>)</condition><then>
                <goto>goto <name>error</name>;</goto></then></if>
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>script</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>script</name>-&gt;<name>filename</name></name> = <name>filename</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>filenameWasSaved</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>lineno</name></name> = (<name>uintN</name>)<name>lineno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>nslots</name></name> = (<name>uint16</name>)<name>nslots</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>staticLevel</name></name> = <call>(<name>uint16</name>)<argument_list>(<argument><expr><name>nslots</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>natoms</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name>js_XDRAtom</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name><name>script</name>-&gt;<name>atomMap</name>.<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
    }</block></for>

    <comment type="block">/*
     * Here looping from 0-to-length to xdr objects is essential. It ensures
     * that block objects from the script-&gt;objects array will be written and
     * restored in the outer-to-inner order. js_XDRBlockObject relies on this
     * to restore the parent chain.
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>nobjects</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>JSObject</name> **</type><name>objp</name> <init>= <expr>&amp;<call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>isBlock</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSClass</name> *</type><name>clasp</name> <init>= <expr><call><name>STOBJ_GET_CLASS</name><argument_list>(<argument><expr>*<name>objp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>clasp</name> == &amp;<name>js_FunctionClass</name> ||
                      <name>clasp</name> == &amp;<name>js_BlockClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isBlock</name> = (<name>clasp</name> == &amp;<name>js_BlockClass</name>) ? 1 : 0</expr>;</expr_stmt>
         }</block></then></if>
        <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>isBlock</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
        <if>if <condition>(<expr><name>isBlock</name> == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_XDRFunctionObject</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr><name>objp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>error</name>;</goto></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>isBlock</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_XDRBlockObject</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr><name>objp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>error</name>;</goto></then></if>
        }</block></else></if>
    }</block></for>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>nupvars</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
    }</block></for>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>nregexps</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name>js_XDRRegExpObject</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>ntrynotes</name> != 0</expr>)</condition><then> <block>{
        <comment type="block">/*
         * We combine tn-&gt;kind and tn-&gt;stackDepth when serializing as XDR is not
         * efficient when serializing small integer types.
         */</comment>
        <decl_stmt><decl><type><name>JSTryNote</name> *</type><name>tn</name></decl>, *<decl><type ref="prev"/><name>tnfirst</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>kindAndDepth</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tn</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tn</name>-&gt;<name>stackDepth</name></name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tnfirst</name> = <call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call>-&gt;<name>vector</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name> == <name>ntrynotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tn</name> = <name>tnfirst</name> + <name>ntrynotes</name></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr>--<name>tn</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>kindAndDepth</name> = ((<name>uint32</name>)<name><name>tn</name>-&gt;<name>kind</name></name> &lt;&lt; 16)
                               | (<name>uint32</name>)<name><name>tn</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>kindAndDepth</name></expr></argument>)</argument_list></call> ||
                !<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name><name>tn</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call> ||
                !<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name><name>tn</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <goto>goto <name>error</name>;</goto>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_DECODE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tn</name>-&gt;<name>kind</name></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>kindAndDepth</name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tn</name>-&gt;<name>stackDepth</name></name> = (<name>uint16</name>)<name>kindAndDepth</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block> while <condition>(<expr><name>tn</name> != <name>tnfirst</name></expr>)</condition>;</do>
    }</block></then></if>

    <expr_stmt><expr><name><name>xdr</name>-&gt;<name>script</name></name> = <name>oldscript</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_DECODE</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

  <label><name>error</name>:</label>
    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_DECODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>script</name>-&gt;<name>filename</name></name> &amp;&amp; !<name>filenameWasSaved</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>script</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>script</name>-&gt;<name>filename</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>js_DestroyScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>scriptp</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>xdr</name>-&gt;<name>script</name></name> = <name>oldscript</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SCRIPT_OBJECT</name> &amp;&amp; <name>JS_HAS_XDR_FREEZE_THAW</name></expr></cpp:if>
<comment type="block">/*
 * These cannot be exposed to web content, and chrome does not need them, so
 * we take them out of the Mozilla client altogether.  Fortunately, there is
 * no way to serialize a native function (see fun_xdrObject in jsfun.c).
 */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_freeze</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSXDRState</name> *</type><name>xdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>hasMagic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>obj</name> = <call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>script</name> = (<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <comment type="block">/* create new XDR */</comment>
    <expr_stmt><expr><name>xdr</name> = <call><name>JS_XDRNewMem</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSXDR_ENCODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>xdr</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/* write  */</comment>
    <expr_stmt><expr><name>ok</name> = <call><name>js_XDRScript</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>script</name></expr></argument>, <argument><expr>&amp;<name>hasMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
    <if>if <condition>(<expr>!<name>hasMagic</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>buf</name> = <call><name>JS_XDRMemGetData</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>buf</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>jsword</name>)<name>buf</name> % <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> /= <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IS_BIG_ENDIAN</name></expr></cpp:if>
  <block>{
    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Swap bytes in Unichars to keep frozen strings machine-independent. */</comment>
    <expr_stmt><expr><name>chars</name> = (<name>jschar</name> *)<name>buf</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>JSXDR_SWAB16</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>str</name> = <call><name>JS_NewUCStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jschar</name> *)<name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_XDRDestroy</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_thaw</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSXDRState</name> *</type><name>xdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>, *<decl><type ref="prev"/><name>oldscript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>hasMagic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>execDepth</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>obj</name> = <call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* create new XDR */</comment>
    <expr_stmt><expr><name>xdr</name> = <call><name>JS_XDRNewMem</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSXDR_DECODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>xdr</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>str</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IS_BIG_ENDIAN</name></expr></cpp:if>
  <block>{
    <decl_stmt><decl><type><name>jschar</name> *</type><name>from</name></decl>, *<decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Swap bytes in Unichars to keep frozen strings machine-independent. */</comment>
    <expr_stmt><expr><name>from</name> = (<name>jschar</name> *)<name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>to</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>to</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_XDRDestroy</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>to</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>JSXDR_SWAB16</name><argument_list>(<argument><expr><name><name>from</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><name>buf</name> = (<name>char</name> *)<name>to</name></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>len</name> *= <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_XDRMemSetData</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* XXXbe should magic mismatch be error, or false return value? */</comment>
    <expr_stmt><expr><name>ok</name> = <call><name>js_XDRScript</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>script</name></expr></argument>, <argument><expr>&amp;<name>hasMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
    <if>if <condition>(<expr>!<name>hasMagic</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_FALSE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>execDepth</name> = <call><name>GetScriptExecDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * execDepth must be 0 to allow compilation here, otherwise the JSScript
     * struct can be released while running.
     */</comment>
    <if>if <condition>(<expr><name>execDepth</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_COMPILE_EXECED_SCRIPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <comment type="block">/* Swap script for obj's old script, if any. */</comment>
    <expr_stmt><expr><name>oldscript</name> = (<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>oldscript</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_DestroyScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>oldscript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>script</name>-&gt;<name>u</name>.<name>object</name></name> = <name>obj</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_CallNewScriptHook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
    <comment type="block">/*
     * We reset the buffer to be NULL so that it doesn't free the chars
     * memory owned by str (vp[2]).
     */</comment>
    <expr_stmt><expr><call><name>JS_XDRMemSetData</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_XDRDestroy</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>IS_BIG_ENDIAN</name></expr></cpp:if>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>js_thaw_str</name><index>[]</index></name> <init>= <expr>"thaw"</expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SCRIPT_OBJECT &amp;&amp; JS_HAS_XDR_FREEZE_THAW */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XDR */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SCRIPT_OBJECT</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>script_methods</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toSource_str</name></expr></argument>,   <argument><expr><name>script_toSource</name></expr></argument>,   <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toString_str</name></expr></argument>,   <argument><expr><name>script_toString</name></expr></argument>,   <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"compile"</expr></argument>,         <argument><expr><name>script_compile</name></expr></argument>,    <argument><expr>2</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"exec"</expr></argument>,            <argument><expr><name>script_exec</name></expr></argument>,       <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XDR_FREEZE_THAW</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"freeze"</expr></argument>,          <argument><expr><name>script_freeze</name></expr></argument>,     <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_thaw_str</name></expr></argument>,       <argument><expr><name>script_thaw</name></expr></argument>,       <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XDR_FREEZE_THAW */</comment>
    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SCRIPT_OBJECT */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>script_finalize</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr>(<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>script</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_DestroyScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_call</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SCRIPT_OBJECT</name></expr></cpp:if>
    <return>return <expr><call><name>script_exec_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>script_trace</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr>(<name>JSScript</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>script</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_TraceScript</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>JS_HAS_SCRIPT_OBJECT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSProto_Script</name></cpp:macro>  <cpp:value>JSProto_Object</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>JS_FRIEND_DATA</name><argument_list>(<argument>JSClass</argument>)</argument_list></macro> <expr_stmt><expr><name>js_ScriptClass</name> = <block>{
    <expr><name>js_Script_str</name></expr>,
    <expr><name>JSCLASS_HAS_PRIVATE</name> | <call><name>JSCLASS_HAS_RESERVED_SLOTS</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> |
    <name>JSCLASS_MARK_IS_TRACE</name> | <call><name>JSCLASS_HAS_CACHED_PROTO</name><argument_list>(<argument><expr><name>JSProto_Script</name></expr></argument>)</argument_list></call></expr>,
    <expr><name>JS_PropertyStub</name></expr>,  <expr><name>JS_PropertyStub</name></expr>,  <expr><name>JS_PropertyStub</name></expr>,  <expr><name>JS_PropertyStub</name></expr>,
    <expr><name>JS_EnumerateStub</name></expr>, <expr><name>JS_ResolveStub</name></expr>,   <expr><name>JS_ConvertStub</name></expr>,   <expr><name>script_finalize</name></expr>,
    <expr><name>NULL</name></expr>,             <expr><name>NULL</name></expr>,             <expr><name>script_call</name></expr>,      <expr><name>NULL</name></expr>,<comment type="block">/*XXXbe xdr*/</comment>
    <expr><name>NULL</name></expr>,             <expr><name>NULL</name></expr>,             <expr><call><name>JS_CLASS_TRACE</name><argument_list>(<argument><expr><name>script_trace</name></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>
}</block></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SCRIPT_OBJECT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>Script</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* If not constructing, replace obj with a new Script object. */</comment>
    <if>if <condition>(<expr>!<call><name>JS_IsConstructing</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>obj</name> = <call><name>js_NewObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * script_compile_sub does not use rval to root its temporaries so we
         * can use it to root obj.
         */</comment>
        <expr_stmt><expr>*<name>rval</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>JS_SetReservedSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <return>return <expr><call><name>script_compile_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SCRIPT_OBJECT</name> &amp;&amp; <name>JS_HAS_XDR_FREEZE_THAW</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>script_static_thaw</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>obj</name> = <call><name>js_NewObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>script_thaw</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>vp</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>script_static_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_thaw_str</name></expr></argument>,       <argument><expr><name>script_static_thaw</name></expr></argument>,     <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* !JS_HAS_SCRIPT_OBJECT || !JS_HAS_XDR_FREEZE_THAW */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>script_static_methods</name></cpp:macro>   <cpp:value>NULL</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !JS_HAS_SCRIPT_OBJECT || !JS_HAS_XDR_FREEZE_THAW */</comment>

<function><type><name>JSObject</name> *</type>
<name>js_InitScriptClass</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>JS_InitClass</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>js_ScriptClass</name></expr></argument>, <argument><expr><name>Script</name></expr></argument>, <argument><expr>1</expr></argument>,
                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>script_methods</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>script_static_methods</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SCRIPT_OBJECT */</comment>

<comment type="block">/*
 * Shared script filename management.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>js_compare_strings</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>k1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>k2</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>k1</name></expr></argument>, <argument><expr>(const <name>char</name> *) <name>k2</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>

<comment type="block">/* NB: This struct overlays JSHashEntry -- see jshash.h, do not reorganize. */</comment>
<typedef>typedef <type><struct>struct <name>ScriptFilenameEntry</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSHashEntry</name>         *</type><name>next</name></decl>;</decl_stmt>          <comment type="block">/* hash chain linkage */</comment>
    <decl_stmt><decl><type><name>JSHashNumber</name></type>        <name>keyHash</name></decl>;</decl_stmt>        <comment type="block">/* key hash function result */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name>          *</type><name>key</name></decl>;</decl_stmt>           <comment type="block">/* ptr to filename, below */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>flags</name></decl>;</decl_stmt>          <comment type="block">/* user-defined filename prefix flags */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>mark</name></decl>;</decl_stmt>           <comment type="block">/* GC mark flag */</comment>
    <decl_stmt><decl><type><name>char</name></type>                <name><name>filename</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* two or more bytes, NUL-terminated */</comment>
</public>}</block></struct></type> <name>ScriptFilenameEntry</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name> *</type>
<name>js_alloc_table_space</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>priv</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>js_free_table_space</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>priv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>item</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSHashEntry</name> *</type>
<name>js_alloc_sftbl_entry</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>priv</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ScriptFilenameEntry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> +
                    <call><name>strlen</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>

    <return>return <expr>(<name>JSHashEntry</name> *) <call><name>js_malloc</name><argument_list>(<argument><expr><call><name>JS_MAX</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>js_free_sftbl_entry</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>priv</name></decl></param>, <param><decl><type><name>JSHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flag</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>flag</name> != <name>HT_FREE_ENTRY</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSHashAllocOps</name></type> <name>sftbl_alloc_ops</name> <init>= <expr><block>{
    <expr><name>js_alloc_table_space</name></expr>,   <expr><name>js_free_table_space</name></expr>,
    <expr><name>js_alloc_sftbl_entry</name></expr>,   <expr><name>js_free_sftbl_entry</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishRuntimeScriptState</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_HashTableDestroy</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_DESTROY_LOCK</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_InitRuntimeScriptState</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name> = <call><name>JS_NEW_LOCK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name> =
        <call><name>JS_NewHashTable</name><argument_list>(<argument><expr>16</expr></argument>, <argument><expr><name>JS_HashString</name></expr></argument>, <argument><expr><name>js_compare_strings</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                        <argument><expr>&amp;<name>sftbl_alloc_ops</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>FinishRuntimeScriptState</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* free lock if threadsafe */</comment>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_INIT_CLIST</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>scriptFilenamePrefixes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>ScriptFilenamePrefix</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSCList</name></type>     <name>links</name></decl>;</decl_stmt>      <comment type="block">/* circular list linkage for easy deletion */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>name</name></decl>;</decl_stmt>      <comment type="block">/* pointer to pinned ScriptFilenameEntry string */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>      <name>length</name></decl>;</decl_stmt>     <comment type="block">/* prefix string length, precomputed */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>      <name>flags</name></decl>;</decl_stmt>      <comment type="block">/* user-defined flags to inherit from this prefix */</comment>
</public>}</block></struct></type> <name>ScriptFilenamePrefix</name>;</typedef>

<function><type><name>void</name></type>
<name>js_FreeRuntimeScriptState</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <while>while <condition>(<expr>!<call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>scriptFilenamePrefixes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>ScriptFilenamePrefix</name> *</type><name>sfp</name> <init>= <expr>(<name>ScriptFilenamePrefix</name> *)
                                    <name><name>rt</name>-&gt;<name>scriptFilenamePrefixes</name>.<name>next</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_REMOVE_LINK</name><argument_list>(<argument><expr>&amp;<name><name>sfp</name>-&gt;<name>links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>sfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>FinishRuntimeScriptState</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_SFTBL</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SFTBL</name></cpp:ifdef>
<decl_stmt><decl><type><name>size_t</name></type> <name>sftbl_savings</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>ScriptFilenameEntry</name> *</type>
<name>SaveScriptFilename</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSHashTable</name> *</type><name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSHashNumber</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSHashEntry</name> **</type><name>hep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCList</name> *</type><name>head</name></decl>, *<decl><type ref="prev"/><name>link</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScriptFilenamePrefix</name> *</type><name>sfp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>table</name> = <name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hash</name> = <call><name>JS_HashString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hep</name> = <call><name>JS_HashTableRawLookup</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sfe</name> = (<name>ScriptFilenameEntry</name> *) *<name>hep</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SFTBL</name></cpp:ifdef>
    <if>if <condition>(<expr><name>sfe</name></expr>)</condition><then>
        <expr_stmt><expr><name>sftbl_savings</name> += <call><name>strlen</name><argument_list>(<argument><expr><name><name>sfe</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr>!<name>sfe</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sfe</name> = (<name>ScriptFilenameEntry</name> *)
              <call><name>JS_HashTableRawAdd</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>hep</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>sfe</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>sfe</name>-&gt;<name>key</name></name> = <call><name>strcpy</name><argument_list>(<argument><expr><name><name>sfe</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sfe</name>-&gt;<name>flags</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sfe</name>-&gt;<name>mark</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If saving a prefix, add it to the set in rt-&gt;scriptFilenamePrefixes. */</comment>
    <if>if <condition>(<expr><name>flags</name> != 0</expr>)</condition><then> <block>{
        <comment type="block">/* Search in case filename was saved already; we must be idempotent. */</comment>
        <expr_stmt><expr><name>sfp</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>head</name> = <name>link</name> = &amp;<name><name>rt</name>-&gt;<name>scriptFilenamePrefixes</name></name></expr>;</init>
             <condition><expr><name><name>link</name>-&gt;<name>next</name></name> != <name>head</name></expr>;</condition>
             <incr><expr><name>link</name> = <name><name>link</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <comment type="block">/* Lag link behind sfp to insert in non-increasing length order. */</comment>
            <expr_stmt><expr><name>sfp</name> = (<name>ScriptFilenamePrefix</name> *) <name><name>link</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>sfp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr><name><name>sfp</name>-&gt;<name>length</name></name> &lt;= <name>length</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>sfp</name> = <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>sfp</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr>!<name>sfp</name></expr>)</condition><then> <block>{
            <comment type="block">/* No such prefix: add one now. */</comment>
            <expr_stmt><expr><name>sfp</name> = (<name>ScriptFilenamePrefix</name> *) <call><name>js_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScriptFilenamePrefix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>sfp</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>JS_INSERT_AFTER</name><argument_list>(<argument><expr>&amp;<name><name>sfp</name>-&gt;<name>links</name></name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sfp</name>-&gt;<name>name</name></name> = <name><name>sfe</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sfp</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sfp</name>-&gt;<name>flags</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * Accumulate flags in both sfe and sfp: sfe for later access from the
         * JS_GetScriptedCallerFilenameFlags debug-API, and sfp so that longer
         * filename entries can inherit by prefix.
         */</comment>
        <expr_stmt><expr><name><name>sfe</name>-&gt;<name>flags</name></name> |= <name>flags</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sfp</name>-&gt;<name>flags</name></name> |= <name>flags</name></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_FUNCTION_METERING</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>sfe</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>len</name> &gt;= sizeof <name><name>rt</name>-&gt;<name>lastScriptFilename</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>len</name> = sizeof <name><name>rt</name>-&gt;<name>lastScriptFilename</name></name> - 1</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>lastScriptFilename</name></name></expr></argument>, <argument><expr><name><name>sfe</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>lastScriptFilename</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>sfe</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>js_SaveScriptFilename</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCList</name> *</type><name>head</name></decl>, *<decl><type ref="prev"/><name>link</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScriptFilenamePrefix</name> *</type><name>sfp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ACQUIRE_LOCK</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sfe</name> = <call><name>SaveScriptFilename</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sfe</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_RELEASE_LOCK</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Try to inherit flags by prefix.  We assume there won't be more than a
     * few (dozen! ;-) prefixes, so linear search is tolerable.
     * XXXbe every time I've assumed that in the JS engine, I've been wrong!
     */</comment>
    <for>for (<init><expr><name>head</name> = &amp;<name><name>rt</name>-&gt;<name>scriptFilenamePrefixes</name></name></expr>, <expr><name>link</name> = <name><name>head</name>-&gt;<name>next</name></name></expr>;</init>
         <condition><expr><name>link</name> != <name>head</name></expr>;</condition>
         <incr><expr><name>link</name> = <name><name>link</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><name>sfp</name> = (<name>ScriptFilenamePrefix</name> *) <name>link</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name><name>sfp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>sfp</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>sfe</name>-&gt;<name>flags</name></name> |= <name><name>sfp</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_RELEASE_LOCK</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>sfe</name>-&gt;<name>filename</name></name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>js_SaveScriptFilenameRT</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name></decl>;</decl_stmt>

    <comment type="block">/* This may be called very early, via the jsdbgapi.h entry point. */</comment>
    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name> &amp;&amp; !<call><name>js_InitRuntimeScriptState</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_ACQUIRE_LOCK</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sfe</name> = <call><name>SaveScriptFilename</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_RELEASE_LOCK</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTableLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>sfe</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr><name><name>sfe</name>-&gt;<name>filename</name></name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Back up from a saved filename by its offset within its hash table entry.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILENAME_TO_SFE</name><parameter_list>(<param><type><name>fn</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((ScriptFilenameEntry *) ((fn) - offsetof(ScriptFilenameEntry, filename)))</cpp:value></cpp:define>

<comment type="block">/*
 * The sfe-&gt;key member, redundant given sfe-&gt;filename but required by the old
 * jshash.c code, here gives us a useful sanity check.  This assertion will
 * very likely botch if someone tries to mark a string that wasn't allocated
 * as an sfe-&gt;filename.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_SFE</name><parameter_list>(<param><type><name>sfe</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>JS_ASSERT((sfe)-&gt;key == (sfe)-&gt;filename)</cpp:value></cpp:define>

<function><type><name>uint32</name></type>
<name>js_GetScriptFilenameFlags</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sfe</name> = <call><name>FILENAME_TO_SFE</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_VALID_SFE</name><argument_list>(<argument><expr><name>sfe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>sfe</name>-&gt;<name>flags</name></name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_MarkScriptFilename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sfe</name> = <call><name>FILENAME_TO_SFE</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_VALID_SFE</name><argument_list>(<argument><expr><name>sfe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sfe</name>-&gt;<name>mark</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>intN</name></type>
<name>js_script_filename_marker</name><parameter_list>(<param><decl><type><name>JSHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>intN</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name> <init>= <expr>(<name>ScriptFilenameEntry</name> *) <name>he</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>sfe</name>-&gt;<name>mark</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_MarkScriptFilenames</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>keepAtoms</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSCList</name> *</type><name>head</name></decl>, *<decl><type ref="prev"/><name>link</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScriptFilenamePrefix</name> *</type><name>sfp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name>keepAtoms</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr></argument>,
                                     <argument><expr><name>js_script_filename_marker</name></expr></argument>,
                                     <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <for>for (<init><expr><name>head</name> = &amp;<name><name>rt</name>-&gt;<name>scriptFilenamePrefixes</name></name></expr>, <expr><name>link</name> = <name><name>head</name>-&gt;<name>next</name></name></expr>;</init>
         <condition><expr><name>link</name> != <name>head</name></expr>;</condition>
         <incr><expr><name>link</name> = <name><name>link</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><name>sfp</name> = (<name>ScriptFilenamePrefix</name> *) <name>link</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_MarkScriptFilename</name><argument_list>(<argument><expr><name><name>sfp</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>intN</name></type>
<name>js_script_filename_sweeper</name><parameter_list>(<param><decl><type><name>JSHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>intN</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ScriptFilenameEntry</name> *</type><name>sfe</name> <init>= <expr>(<name>ScriptFilenameEntry</name> *) <name>he</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>sfe</name>-&gt;<name>mark</name></name></expr>)</condition><then>
        <return>return <expr><name>HT_ENUMERATE_REMOVE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>sfe</name>-&gt;<name>mark</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <return>return <expr><name>HT_ENUMERATE_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_SweepScriptFilenames</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <comment type="block">/*
     * JS_HashTableEnumerateEntries shrinks the table if many entries are
     * removed preventing wasting memory on a too sparse table.
     */</comment>
    <expr_stmt><expr><call><name>JS_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr></argument>,
                                 <argument><expr><name>js_script_filename_sweeper</name></expr></argument>,
                                 <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_notme</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SFTBL</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"script filename table savings so far: %u\n"</expr></argument>, <argument><expr><name>sftbl_savings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
 * JSScript data structures memory alignment:
 *
 * JSScript
 * JSObjectArray    script objects' descriptor if JSScript.objectsOffset != 0,
 *                    use script-&gt;objects() to access it.
 * JSObjectArray    script regexps' descriptor if JSScript.regexpsOffset != 0,
 *                    use script-&gt;regexps() to access it.
 * JSTryNoteArray   script try notes' descriptor if JSScript.tryNotesOffset
 *                    != 0, use script-&gt;trynotes() to access it.
 * JSAtom *a[]      array of JSScript.atomMap.length atoms pointed by
 *                    JSScript.atomMap.vector if any.
 * JSObject *o[]    array of script-&gt;objects()-&gt;length objects if any
 *                    pointed by script-&gt;objects()-&gt;vector.
 * JSObject *r[]    array of script-&gt;regexps()-&gt;length regexps if any
 *                    pointed by script-&gt;regexps()-&gt;vector.
 * JSTryNote t[]    array of script-&gt;trynotes()-&gt;length try notes if any
 *                    pointed by script-&gt;trynotes()-&gt;vector.
 * jsbytecode b[]   script bytecode pointed by JSScript.code.
 * jssrcnote  s[]   script source notes, use script-&gt;notes() to access it
 *
 * The alignment avoids gaps between entries as alignment requirement for each
 * subsequent structure or array is the same or divides the alignment
 * requirement for the previous one.
 *
 * The followings asserts checks that assuming that the alignment requirement
 * for JSObjectArray and JSTryNoteArray are sizeof(void *) and for JSTryNote
 * it is sizeof(uint32) as the structure consists of 3 uint32 fields.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSScript</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSTryNoteArray</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSAtom</name> *</expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name> *</expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSTryNote</name></expr></argument>)</argument_list></sizeof> == 3 * <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Check that uint8 offset for object, upvar, regexp, and try note arrays is
 * sufficient.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSScript</name></expr></argument>)</argument_list></sizeof> + 2 * <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof> +
                 <sizeof>sizeof<argument_list>(<argument><expr><name>JSUpvarArray</name></expr></argument>)</argument_list></sizeof> &lt; <call><name>JS_BIT</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>JSScript</name> *</type>
<name>js_NewScript</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>length</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nsrcnotes</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>natoms</name></decl></param>,
             <param><decl><type><name>uint32</name></type> <name>nobjects</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nupvars</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nregexps</name></decl></param>,
             <param><decl><type><name>uint32</name></type> <name>ntrynotes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>vectorSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>cursor</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>JSScript</name></expr></argument>)</argument_list></sizeof> +
           <sizeof>sizeof<argument_list>(<argument><expr><name>JSAtom</name> *</expr></argument>)</argument_list></sizeof> * <name>natoms</name> +
           <name>length</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof> +
           <name>nsrcnotes</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nobjects</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof> + <name>nobjects</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>nupvars</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSUpvarArray</name></expr></argument>)</argument_list></sizeof> + <name>nupvars</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>nregexps</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof> + <name>nregexps</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>ntrynotes</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><name>size</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSTryNoteArray</name></expr></argument>)</argument_list></sizeof> + <name>ntrynotes</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>JSTryNote</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>script</name> = (<name>JSScript</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSScript</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>version</name></name> = <name><name>cx</name>-&gt;<name>version</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>cursor</name> = (<name>uint8</name> *)<name>script</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>JSScript</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nobjects</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>script</name>-&gt;<name>objectsOffset</name></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>cursor</name> - (<name>uint8</name> *)<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>nupvars</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>script</name>-&gt;<name>upvarsOffset</name></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>cursor</name> - (<name>uint8</name> *)<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSUpvarArray</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>nregexps</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>script</name>-&gt;<name>regexpsOffset</name></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>cursor</name> - (<name>uint8</name> *)<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectArray</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>ntrynotes</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>script</name>-&gt;<name>trynotesOffset</name></name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>cursor</name> - (<name>uint8</name> *)<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>JSTryNoteArray</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>natoms</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>script</name>-&gt;<name>atomMap</name>.<name>length</name></name> = <name>natoms</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name> = (<name>JSAtom</name> **)<name>cursor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vectorSize</name> = <name>natoms</name> * <sizeof>sizeof<argument_list>(<argument><expr><name><name>script</name>-&gt;<name>atomMap</name>.<name>vector</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <comment type="block">/*
         * Clear object map's vector so the GC tracing can run when not yet
         * all atoms are copied to the array.
         */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <name>vectorSize</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>nobjects</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name> = <name>nobjects</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call>-&gt;<name>vector</name> = (<name>JSObject</name> **)<name>cursor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vectorSize</name> = <name>nobjects</name> * <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <name>vectorSize</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>nregexps</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name> = <name>nregexps</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call>-&gt;<name>vector</name> = (<name>JSObject</name> **)<name>cursor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vectorSize</name> = <name>nregexps</name> * <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <name>vectorSize</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>ntrynotes</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name> = <name>ntrynotes</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call>-&gt;<name>vector</name> = (<name>JSTryNote</name> *)<name>cursor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vectorSize</name> = <name>ntrynotes</name> * <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>cursor</name> += <name>vectorSize</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * NB: We allocate the vector of uint32 upvar cookies after all vectors of
     * pointers, to avoid misalignment on 64-bit platforms. See bug 514645.
     */</comment>
    <if>if <condition>(<expr><name>nupvars</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name> = <name>nupvars</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name>vector</name> = (<name>uint32</name> *)<name>cursor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vectorSize</name> = <name>nupvars</name> * <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name><name>vector</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursor</name> += <name>vectorSize</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>script</name>-&gt;<name>code</name></name> = <name><name>script</name>-&gt;<name>main</name></name> = (<name>jsbytecode</name> *)<name>cursor</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>cursor</name> +
              <name>length</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof> +
              <name>nsrcnotes</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></sizeof> ==
              (<name>uint8</name> *)<name>script</name> + <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_SCRIPT_OWNER</name></cpp:ifdef>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>owner</name></name> = <name><name>cx</name>-&gt;<name>thread</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>script</name></expr>;</return>
}</block></function>

<function><type><name>JSScript</name> *</type>
<name>js_NewScriptFromCG</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>mainLength</name></decl>, <decl><type ref="prev"/><name>prologLength</name></decl>, <decl><type ref="prev"/><name>nsrcnotes</name></decl>, <decl><type ref="prev"/><name>nfixed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name></decl>;</decl_stmt>

    <comment type="block">/* The counts of indexed things must be checked during code generation. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>atomList</name>.<name>count</name></name> &lt;= <name>INDEX_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>objectList</name>.<name>length</name></name> &lt;= <name>INDEX_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>regexpList</name>.<name>length</name></name> &lt;= <name>INDEX_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mainLength</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>prologLength</name> = <call><name>CG_PROLOG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CG_COUNT_FINAL_SRCNOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>nsrcnotes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>script</name> = <call><name>js_NewScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prologLength</name> + <name>mainLength</name></expr></argument>, <argument><expr><name>nsrcnotes</name></expr></argument>,
                          <argument><expr><name><name>cg</name>-&gt;<name>atomList</name>.<name>count</name></name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>objectList</name>.<name>length</name></name></expr></argument>,
                          <argument><expr><name><name>cg</name>-&gt;<name>upvarList</name>.<name>count</name></name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>regexpList</name>.<name>length</name></name></expr></argument>,
                          <argument><expr><name><name>cg</name>-&gt;<name>ntrynotes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>script</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Now that we have script, error control flow must go to label bad. */</comment>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>main</name></name> += <name>prologLength</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><call><name>CG_PROLOG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prologLength</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>script</name>-&gt;<name>main</name></name></expr></argument>, <argument><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mainLength</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nfixed</name> = (<name><name>cg</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)
             ? <name><name>cg</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nvars</name></name>
             : <name><name>cg</name>-&gt;<name>ngvars</name></name> + <name><name>cg</name>-&gt;<name>regexpList</name>.<name>length</name></name> + <call><name><name>cg</name>-&gt;<name>sharpSlots</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nfixed</name> &lt; <name>SLOTNO_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>nfixed</name></name> = (<name>uint16</name>) <name>nfixed</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_InitAtomMap</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>script</name>-&gt;<name>atomMap</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>filename</name> = <name><name>cg</name>-&gt;<name>compiler</name>-&gt;<name>tokenStream</name>.<name>filename</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>filename</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>script</name>-&gt;<name>filename</name></name> = <call><name>js_SaveScriptFilename</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>script</name>-&gt;<name>filename</name></name></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
    }</block></then></if>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>lineno</name></name> = <name><name>cg</name>-&gt;<name>firstLine</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>nfixed</name></name> + <name><name>cg</name>-&gt;<name>maxStackDepth</name></name> &gt;= <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>CG_TS</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                    <argument><expr><name>JSMSG_NEED_DIET</name></expr></argument>, <argument><expr>"script"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>bad</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>nslots</name></name> = <name><name>script</name>-&gt;<name>nfixed</name></name> + <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>staticLevel</name></name> = <name><name>cg</name>-&gt;<name>staticLevel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>script</name>-&gt;<name>principals</name></name> = <name><name>cg</name>-&gt;<name>compiler</name>-&gt;<name>principals</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>principals</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JSPRINCIPALS_HOLD</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>principals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<call><name>js_FinishTakingSrcNotes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>bad</name>;</goto></then></if>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>ntrynotes</name></name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>js_FinishTakingTryNotes</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name><name>script</name>-&gt;<name>trynotes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>objectList</name>.<name>length</name></name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cg</name>-&gt;<name>objectList</name>.<name>finish</name></name><argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>regexpList</name>.<name>length</name></name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cg</name>-&gt;<name>regexpList</name>.<name>finish</name></name><argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>flags</name></name> &amp; <name>TCF_NO_SCRIPT_RVAL</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>noScriptRval</name></name> = true</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name><name>cg</name>-&gt;<name>hasSharps</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>hasSharps</name></name> = true</expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>upvarList</name>.<name>count</name></name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>upvarList</name>.<name>count</name></name> &lt;= <name><name>cg</name>-&gt;<name>upvarMap</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name>vector</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>upvarMap</name>.<name>vector</name></name></expr></argument>,
               <argument><expr><name><name>cg</name>-&gt;<name>upvarList</name>.<name>count</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cg</name>-&gt;<name>upvarList</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>upvarMap</name>.<name>vector</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>upvarMap</name>.<name>vector</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * We initialize fun-&gt;u.script to be the script constructed above
     * so that the debugger has a valid FUN_SCRIPT(fun).
     */</comment>
    <expr_stmt><expr><name>fun</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>fun</name> = <name><name>cg</name>-&gt;<name>fun</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>FUN_SCRIPT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>script</name>-&gt;<name>upvarsOffset</name></name> != 0</expr></argument>,
                     <argument><expr><call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call>-&gt;<name>length</name> == <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nupvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>js_FreezeLocalNames</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name> = <name>script</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_SCRIPT_OWNER</name></cpp:ifdef>
        <expr_stmt><expr><name><name>script</name>-&gt;<name>owner</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>flags</name></name> &amp; <name>TCF_FUN_HEAVYWEIGHT</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>fun</name>-&gt;<name>flags</name></name> |= <name>JSFUN_HEAVYWEIGHT</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <comment type="block">/* Tell the debugger about this compiled script. */</comment>
    <expr_stmt><expr><call><name>js_CallNewScriptHook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>script</name></expr>;</return>

<label><name>bad</name>:</label>
    <expr_stmt><expr><call><name>js_DestroyScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_CallNewScriptHook</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script</argument>, <argument>JSFunction *fun</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSNewScriptHook</name></type> <name>hook</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hook</name> = <name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>newScriptHook</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hook</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_KEEP_ATOMS</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>,
             <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>newScriptHookData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_UNKEEP_ATOMS</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_CallDestroyScriptHook</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSDestroyScriptHook</name></type> <name>hook</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hook</name> = <name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>destroyScriptHook</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hook</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>destroyScriptHookData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block>

<function><type><name>void</name></type>
<name>js_DestroyScript</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>js_CallDestroyScriptHook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ClearScriptTraps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>principals</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JSPRINCIPALS_DROP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>principals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>code</name> == <name><name>script</name>-&gt;<name>code</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_PURGE_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * Worry about purging the property cache and any compiled traces related
     * to its bytecode if this script is being destroyed from JS_DestroyScript
     * or equivalent according to a mandatory "New/Destroy" protocol.
     *
     * The GC purges all property caches when regenerating shapes upon shape
     * generator overflow, so no need in that event to purge just the entries
     * for this script.
     *
     * The GC purges trace-JITted code on every GC activation, not just when
     * regenerating shapes, so we don't have to purge fragments if the GC is
     * currently running.
     *
     * JS_THREADSAFE note: js_PurgePropertyCacheForScript purges only the
     * current thread's property cache, so a script not owned by a function
     * or object, which hands off lifetime management for that script to the
     * GC, must be used by only one thread over its lifetime.
     *
     * This should be an API-compatible change, since a script is never safe
     * against premature GC if shared among threads without a rooted object
     * wrapping it to protect the script's mapped atoms against GC. We use
     * script-&gt;owner to enforce this requirement via assertions.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_SCRIPT_OWNER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRunning</name></name></expr></argument>, <argument><expr>!<name><name>script</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* FIXME: bug 506341; would like to do this only if regenerating shapes. */</comment>
    <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRunning</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name>js_GetTopStackFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!(<name>fp</name> &amp;&amp; (<name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_EVAL</name>))</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_PurgePropertyCacheForScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_SCRIPT_OWNER</name></cpp:ifdef>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>script</name>-&gt;<name>owner</name></name> == <name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>js_PurgeScriptFragments</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>js_TraceScript</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtomMap</name> *</type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> **</type><name>vector</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObjectArray</name> *</type><name>objarray</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>map</name> = &amp;<name><name>script</name>-&gt;<name>atomMap</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> = <name><name>map</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>vector</name> = <name><name>map</name>-&gt;<name>vector</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>v</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_TRACEABLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_SET_TRACING_INDEX</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"atomMap"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_TRACEABLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JSVAL_TRACE_KIND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>objectsOffset</name></name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>objarray</name> = <call><name><name>script</name>-&gt;<name>objects</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = <name><name>objarray</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>objarray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_SET_TRACING_INDEX</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"objects"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>objarray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>JSTRACE_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block> while <condition>(<expr><name>i</name> != 0</expr>)</condition>;</do>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>regexpsOffset</name></name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>objarray</name> = <call><name><name>script</name>-&gt;<name>regexps</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = <name><name>objarray</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>objarray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_SET_TRACING_INDEX</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"regexps"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>objarray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>JSTRACE_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block> while <condition>(<expr><name>i</name> != 0</expr>)</condition>;</do>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>u</name>.<name>object</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_SET_TRACING_NAME</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>u</name>.<name>object</name></name></expr></argument>, <argument><expr><name>JSTRACE_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>IS_GC_MARKING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>script</name>-&gt;<name>filename</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_MarkScriptFilename</name><argument_list>(<argument><expr><name><name>script</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<typedef>typedef <type><struct>struct <name>GSNCacheEntry</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name>          *</type><name>pc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name>           *</type><name>sn</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>GSNCacheEntry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_THRESHOLD</name></cpp:macro>     <cpp:value>100</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>js_PurgeGSNCache</name><parameter_list>(<param><decl><type><name>JSGSNCache</name> *</type><name>cache</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>cache</name>-&gt;<name>code</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>table</name>.<name>ops</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_DHashTableFinish</name><argument_list>(<argument><expr>&amp;<name><name>cache</name>-&gt;<name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cache</name>-&gt;<name>table</name>.<name>ops</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>GSN_CACHE_METER</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>purges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>jssrcnote</name> *</type>
<name>js_GetSrcNoteCached</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>target</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GSNCacheEntry</name> *</type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>nsrcnotes</name></decl>;</decl_stmt>


    <expr_stmt><expr><name>target</name> = <name>pc</name> - <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>uint32</name>)<name>target</name> &gt;= <name><name>script</name>-&gt;<name>length</name></name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>code</name> == <name><name>script</name>-&gt;<name>code</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_METER_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>entry</name> = (<name>GSNCacheEntry</name> *)
                <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>table</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>,
                                     <argument><expr><name>JS_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>entry</name>-&gt;<name>sn</name></name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_METER_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>misses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</init> <condition>;</condition> <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>offset</name> += <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>offset</name> == <name>target</name> &amp;&amp; <call><name>SN_IS_GETTABLE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>sn</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>code</name> != <name><name>script</name>-&gt;<name>code</name></name> &amp;&amp;
        <name><name>script</name>-&gt;<name>length</name></name> &gt;= <name>GSN_CACHE_THRESHOLD</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_PURGE_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nsrcnotes</name> = 0</expr>;</expr_stmt>
        <for>for (<init><expr><name>sn</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>SN_IS_GETTABLE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr>++<name>nsrcnotes</name></expr>;</expr_stmt></then></if>
        }</block></for>
        <if>if <condition>(<expr>!<call><name>JS_DHashTableInit</name><argument_list>(<argument><expr>&amp;<call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>table</name></expr></argument>, <argument><expr><call><name>JS_DHashGetStubOps</name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GSNCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                               <argument><expr><call><name>JS_DHASH_DEFAULT_CAPACITY</name><argument_list>(<argument><expr><name>nsrcnotes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name><name>table</name>.<name>ops</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>pc</name> = <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
            <for>for (<init><expr><name>sn</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</condition>
                 <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
                <expr_stmt><expr><name>pc</name> += <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>SN_IS_GETTABLE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>entry</name> = (<name>GSNCacheEntry</name> *)
                            <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>table</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>,
                                                 <argument><expr><name>JS_DHASH_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>entry</name>-&gt;<name>pc</name></name> = <name>pc</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>entry</name>-&gt;<name>sn</name></name> = <name>sn</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><call><name>JS_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>code</name> = <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_METER_GSN_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fills</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>uintN</name></type>
<name>js_FramePCToLineNumber</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_PCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>imacpc</name></name> ? <name><name>fp</name>-&gt;<name>imacpc</name></name> : <name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>uintN</name></type>
<name>js_PCToLineNumber</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>lineno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>target</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSrcNoteType</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* Cope with JSStackFrame.pc value prior to entering js_Interpret. */</comment>
    <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <comment type="block">/*
     * Special case: function definition needs no line number note because
     * the function's script contains its starting line number.
     */</comment>
    <expr_stmt><expr><name>op</name> = <call><name>js_GetOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_INDEXBASE</name></expr>)</condition><then>
        <expr_stmt><expr><name>pc</name> += <name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>length</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_DEFFUN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>GET_FUNCTION_FROM_BYTECODE</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>lineno</name></name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * General case: walk through source notes accumulating their deltas,
     * keeping track of line-number notes, until we pass the note for pc's
     * offset within script-&gt;code.
     */</comment>
    <expr_stmt><expr><name>lineno</name> = <name><name>script</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name> = <name>pc</name> - <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <expr_stmt><expr><name>offset</name> += <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = (<name>JSSrcNoteType</name>) <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> == <name>SRC_SETLINE</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>offset</name> &lt;= <name>target</name></expr>)</condition><then>
                <expr_stmt><expr><name>lineno</name> = (<name>uintN</name>) <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>type</name> == <name>SRC_NEWLINE</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>offset</name> &lt;= <name>target</name></expr>)</condition><then>
                <expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt></then></if>
        }</block></then></if></else></if>
        <if>if <condition>(<expr><name>offset</name> &gt; <name>target</name></expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></for>
    <return>return <expr><name>lineno</name></expr>;</return>
}</block></function>

<comment type="block">/* The line number limit is the same as the jssrcnote offset limit. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_LINE_LIMIT</name></cpp:macro>   <cpp:value>(SN_3BYTE_OFFSET_FLAG &lt;&lt; 16)</cpp:value></cpp:define>

<function><type><name>jsbytecode</name> *</type>
<name>js_LineNumberToPC</name><parameter_list>(<param><decl><type><name>JSScript</name> *</type><name>script</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>best</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>lineno</name></decl>, <decl><type ref="prev"/><name>bestdiff</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSrcNoteType</name></type> <name>type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>best</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>lineno</name> = <name><name>script</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bestdiff</name> = <name>SN_LINE_LIMIT</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <comment type="block">/*
         * Exact-match only if offset is not in the prolog; otherwise use
         * nearest greater-or-equal line number match.
         */</comment>
        <if>if <condition>(<expr><name>lineno</name> == <name>target</name> &amp;&amp; <name><name>script</name>-&gt;<name>code</name></name> + <name>offset</name> &gt;= <name><name>script</name>-&gt;<name>main</name></name></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <if>if <condition>(<expr><name>lineno</name> &gt;= <name>target</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>diff</name> = <name>lineno</name> - <name>target</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>diff</name> &lt; <name>bestdiff</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>bestdiff</name> = <name>diff</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>best</name> = <name>offset</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>offset</name> += <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = (<name>JSSrcNoteType</name>) <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> == <name>SRC_SETLINE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lineno</name> = (<name>uintN</name>) <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>type</name> == <name>SRC_NEWLINE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>best</name> &gt;= 0</expr>)</condition><then>
        <expr_stmt><expr><name>offset</name> = <name>best</name></expr>;</expr_stmt></then></if>
<label><name>out</name>:</label>
    <return>return <expr><name><name>script</name>-&gt;<name>code</name></name> + <name>offset</name></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>uintN</argument>)</argument_list></macro>
<macro><name>js_GetScriptLineExtent</name><argument_list>(<argument>JSScript *script</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>lineno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSrcNoteType</name></type> <name>type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lineno</name> = <name><name>script</name>-&gt;<name>lineno</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name> = <call><name><name>script</name>-&gt;<name>notes</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<call><name>SN_IS_TERMINATOR</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <expr_stmt><expr><name>type</name> = (<name>JSSrcNoteType</name>) <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> == <name>SRC_SETLINE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lineno</name> = (<name>uintN</name>) <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>type</name> == <name>SRC_NEWLINE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></for>
    <return>return <expr>1 + <name>lineno</name> - <name><name>script</name>-&gt;<name>lineno</name></name></expr>;</return>
}</block>
</unit>
