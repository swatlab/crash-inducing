<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0005ea73601b53441bf92ee69cb6964649c130fe.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=80:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS execution context.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;new&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdbgapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsexn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsiter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsmath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnativestack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspubtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstracer.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxtinlines.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOSMEMMGR</name></cpp:macro></cpp:define>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:if># <cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro> <cpp:value>MAP_ANON</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<using>using namespace <name>js</name>;</using>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>ARENA_HEADER_SIZE_HACK</name> <init>= <expr>40</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>TEMP_POOL_CHUNK_SIZE</name> <init>= <expr>4096 - <name>ARENA_HEADER_SIZE_HACK</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>FreeContext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>StackSegment</name>::<name>contains</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>inContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>stop</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>isActive</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>hasfp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>start</name> = <call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stop</name> = <call><name><name>cx</name>-&gt;<name>activeSegment</name></name><argument_list>()</argument_list></call>-&gt;<name><name>initialFrame</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>suspendedRegs</name> &amp;&amp; <name><name>suspendedRegs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>start</name> = <name><name>suspendedRegs</name>-&gt;<name>fp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>stop</name> = <name><name>initialFrame</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
    }</block></else></if>
    <for>for (<init><decl><type><name>JSStackFrame</name> *</type><name>f</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>f</name> != <name>stop</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name>f</name> == <name>fp</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
    }</block></for>
    <return>return <expr>false</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name><name>StackSpace</name>::<name>init</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
    <expr_stmt><expr><name>p</name> = <call><name>VirtualAlloc</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CAPACITY_BYTES</name></expr></argument>, <argument><expr><name>MEM_RESERVE</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>void</name> *</type><name>check</name> <init>= <expr><call><name>VirtualAlloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>COMMIT_BYTES</name></expr></argument>, <argument><expr><name>MEM_COMMIT</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name> != <name>check</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><name>base</name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>Value</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>commitEnd</name> = <name>base</name> + <name>COMMIT_VALS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>base</name> + <name>CAPACITY_VALS</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <if>if <condition>(<expr><call><name>DosAllocMem</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>CAPACITY_BYTES</name></expr></argument>, <argument><expr><name>PAG_COMMIT</name> | <name>PAG_READ</name> | <name>PAG_WRITE</name> | <name>OBJ_ANY</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name>DosAllocMem</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>CAPACITY_BYTES</name></expr></argument>, <argument><expr><name>PAG_COMMIT</name> | <name>PAG_READ</name> | <name>PAG_WRITE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><name>base</name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>Value</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>base</name> + <name>CAPACITY_VALS</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>CAPACITY_BYTES</name> % <call><name>getpagesize</name><argument_list>()</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CAPACITY_BYTES</name></expr></argument>, <argument><expr><name>PROT_READ</name> | <name>PROT_WRITE</name></expr></argument>, <argument><expr><name>MAP_PRIVATE</name> | <name>MAP_ANONYMOUS</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>p</name> == <name>MAP_FAILED</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><name>base</name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>Value</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>base</name> + <name>CAPACITY_VALS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>StackSpace</name>::<name>finish</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
    <expr_stmt><expr><call><name>VirtualFree</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>(<name>commitEnd</name> - <name>base</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>MEM_DECOMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VirtualFree</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>MEM_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><call><name>DosFreeMem</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SOLARIS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr>(<name>caddr_t</name>)<name>base</name></expr></argument>, <argument><expr><name>CAPACITY_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>CAPACITY_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
<macro><name>JS_FRIEND_API</name><argument_list>(<argument>bool</argument>)</argument_list></macro>
<macro><name>StackSpace</name></macro><expr_stmt><expr><name>::<name>bumpCommit</name></name>(<name>Value</name> *<name>from</name>, <name>ptrdiff_t</name> <name>nvals</name>) const
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>end</name> - <name>from</name> &gt;= <name>nvals</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>Value</name> *<name>newCommit</name> = <name>commitEnd</name></expr>;
    <expr><name>Value</name> *<name>request</name> = <name>from</name> + <name>nvals</name></expr>;

    <comment type="block">/* Use a dumb loop; will probably execute once. */</comment>
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>end</name> - <name>newCommit</name>) % <name>COMMIT_VALS</name> == 0</expr></argument>)</argument_list></call></expr>;
    <do>do <block>{
        <expr_stmt><expr><name>newCommit</name> += <name>COMMIT_VALS</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>end</name> - <name>newCommit</name>) &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt/></block></do>}</block></expr></expr_stmt> <while>while <condition>(<expr><name>newCommit</name> &lt; <name>request</name></expr>)</condition><empty_stmt>;</empty_stmt></while>

    <comment type="block">/* The cast is safe because CAPACITY_BYTES is small. */</comment>
    <decl_stmt><decl><type><name>int32</name></type> <name>size</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>int32</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>newCommit</name> - <name>commitEnd</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>VirtualAlloc</name><argument_list>(<argument><expr><name>commitEnd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MEM_COMMIT</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><name>commitEnd</name> = <name>newCommit</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

JS_REQUIRES_STACK <function><type><name>void</name></type>
<name><name>StackSpace</name>::<name>mark</name></name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * The correctness/completeness of marking depends on the continuity
     * invariants described by the StackSegment and StackSpace definitions.
     */</comment>
    <decl_stmt><decl><type><name>Value</name> *</type><name>end</name> <init>= <expr><call><name>firstUnused</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>StackSegment</name> *</type><name>seg</name> <init>= <expr><name>currentSegment</name></expr></init></decl>;</init> <condition><expr><name>seg</name></expr>;</condition> <incr><expr><name>seg</name> = <call><name><name>seg</name>-&gt;<name>getPreviousInMemory</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name><name>seg</name>-&gt;<name>inContext</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* This may be the only pointer to the initialVarObj. */</comment>
            <if>if <condition>(<decl><type><name>JSObject</name> *</type><name>varobj</name> <init>= <expr><call><name><name>seg</name>-&gt;<name>getInitialVarObj</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><then>
                <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>varobj</name></expr></argument>, <argument><expr>"varobj"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <comment type="block">/* Mark slots/args trailing off of the last stack frame. */</comment>
            <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>seg</name>-&gt;<name>getCurrentFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>MarkValueRange</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>slots</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>"stack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Mark stack frames and slots/args between stack frames. */</comment>
            <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>initialFrame</name> <init>= <expr><call><name><name>seg</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>JSStackFrame</name> *</type><name>f</name> <init>= <expr><name>fp</name></expr></init></decl>;</init> <condition><expr><name>f</name> != <name>initialFrame</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <expr_stmt><expr><call><name>js_TraceStackFrame</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MarkValueRange</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>down</name>-&gt;<name>slots</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>argEnd</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"stack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <comment type="block">/* Mark initialFrame stack frame and leading args. */</comment>
            <expr_stmt><expr><call><name>js_TraceStackFrame</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>initialFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MarkValueRange</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name><name>seg</name>-&gt;<name>getInitialArgBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>initialFrame</name>-&gt;<name>argEnd</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"stack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* Mark slots/args trailing off segment. */</comment>
            <expr_stmt><expr><call><name>MarkValueRange</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name><name>seg</name>-&gt;<name>getInitialArgBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>"stack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>end</name> = <call><name><name>seg</name>-&gt;<name>previousSegmentEnd</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>StackSpace</name>::<name>pushSegmentForInvoke</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>InvokeArgsGuard</name> &amp;</type><name>ag</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>start</name> <init>= <expr><call><name>firstUnused</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nvals</name> <init>= <expr><name>VALUES_PER_STACK_SEGMENT</name> + 2 + <name>argc</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ensureSpace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>StackSegment</name> *</type><name>seg</name> <init>= <expr>new(<name>start</name>) <name>StackSegment</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>seg</name>-&gt;<name>setPreviousInMemory</name></name><argument_list>(<argument><expr><name>currentSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <name>seg</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ag</name>.<name>cx</name></name> = <name>cx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ag</name>.<name>seg</name></name> = <name>seg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ag</name>.<name>argv_</name></name> = <call><name><name>seg</name>-&gt;<name>getInitialArgBegin</name></name><argument_list>()</argument_list></call> + 2</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ag</name>.<name>argc_</name></name> = <name>argc</name></expr>;</expr_stmt>

    <comment type="block">/* Use invokeArgEnd to root [vp, vpend) until the frame is pushed. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>ag</name>.<name>prevInvokeSegment</name></name> = <name>invokeSegment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>invokeSegment</name> = <name>seg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ag</name>.<name>prevInvokeFrame</name></name> = <name>invokeFrame</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>invokeFrame</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>ag</name>.<name>prevInvokeArgEnd</name></name> = <name>invokeArgEnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>invokeArgEnd</name> = <call><name><name>ag</name>.<name>argv</name></name><argument_list>()</argument_list></call> + <call><name><name>ag</name>.<name>argc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>StackSpace</name>::<name>popSegmentForInvoke</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>InvokeArgsGuard</name> &amp;</type><name>ag</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>currentSegment</name>-&gt;<name>inContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ag</name>.<name>seg</name></name> == <name>currentSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>invokeSegment</name> == <name>currentSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>invokeArgEnd</name> == <call><name><name>ag</name>.<name>argv</name></name><argument_list>()</argument_list></call> + <call><name><name>ag</name>.<name>argc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>currentSegment</name> = <call><name><name>currentSegment</name>-&gt;<name>getPreviousInMemory</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name>invokeSegment</name> = <name><name>ag</name>.<name>prevInvokeSegment</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>invokeFrame</name> = <name><name>ag</name>.<name>prevInvokeFrame</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>invokeArgEnd</name> = <name><name>ag</name>.<name>prevInvokeArgEnd</name></name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Always push a segment when starting a new execute frame since segments
 * provide initialVarObj, which may change.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>StackSpace</name>::<name>getExecuteFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>down</name></decl></param>,
                            <param><decl><type><name>uintN</name></type> <name>vplen</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>nfixed</name></decl></param>,
                            <param><decl><type><name>FrameGuard</name> &amp;</type><name>fg</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>start</name> <init>= <expr><call><name>firstUnused</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>nvals</name> <init>= <expr><name>VALUES_PER_STACK_SEGMENT</name> + <name>vplen</name> + <name>VALUES_PER_STACK_FRAME</name> + <name>nfixed</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ensureSpace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>nvals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><name><name>fg</name>.<name>seg</name></name> = new(<name>start</name>) <name>StackSegment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fg</name>.<name>vp</name></name> = <name>start</name> + <name>VALUES_PER_STACK_SEGMENT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fg</name>.<name>fp</name></name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>JSStackFrame</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>fg</name>.<name>vp</name></name> + <name>vplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fg</name>.<name>down</name></name> = <name>down</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>StackSpace</name>::<name>pushExecuteFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>FrameGuard</name> &amp;</type><name>fg</name></decl></param>,
                             <param><decl><type><name>JSFrameRegs</name> &amp;</type><name>regs</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>initialVarObj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>fg</name>.<name>fp</name>-&gt;<name>down</name></name> = <name><name>fg</name>.<name>down</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>StackSegment</name> *</type><name>seg</name> <init>= <expr><name><name>fg</name>.<name>seg</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>seg</name>-&gt;<name>setPreviousInMemory</name></name><argument_list>(<argument><expr><name>currentSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <name>seg</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>regs</name>.<name>fp</name></name> = <name><name>fg</name>.<name>fp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>pushSegmentAndFrame</name></name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>seg</name>-&gt;<name>setInitialVarObj</name></name><argument_list>(<argument><expr><name>initialVarObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fg</name>.<name>cx</name></name> = <name>cx</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>StackSpace</name>::<name>popFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isCurrentAndActive</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>hasActiveSegment</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>popSegmentAndFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <call><name><name>currentSegment</name>-&gt;<name>getPreviousInMemory</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><name>JS_REQUIRES_STACK</name>
<macro><name>FrameGuard</name></macro><name>::~<name>FrameGuard</name></name>()
<block>{
    <if>if <condition>(<expr>!<call><name>pushed</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>
    <call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>activeSegment</name></name><argument_list>()</argument_list></call> == <name>seg</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>maybefp</name></name><argument_list>()</argument_list></call> == <name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call>.<call><name>popFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

JS_REQUIRES_STACK <function><type><name>void</name></type>
<name><name>StackSpace</name>::<name>getSynthesizedSlowNativeFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>StackSegment</name> *&amp;</type><name>seg</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *&amp;</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>start</name> <init>= <expr><call><name>firstUnused</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>end</name> - <name>start</name></expr></argument>)</argument_list></call> &gt;= <name>VALUES_PER_STACK_SEGMENT</name> + <name>VALUES_PER_STACK_FRAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>seg</name> = new(<name>start</name>) <name>StackSegment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>fp</name> = <call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>JSStackFrame</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>seg</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>StackSpace</name>::<name>pushSynthesizedSlowNativeFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>StackSegment</name> *</type><name>seg</name></decl></param>, <param><decl><type><name>JSFrameRegs</name> &amp;</type><name>regs</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>regs</name>.<name>fp</name>-&gt;<name>hasScript</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>FUN_SLOW_NATIVE</name><argument_list>(<argument><expr><call><name><name>regs</name>.<name>fp</name>-&gt;<name>getFunction</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name>.<name>fp</name>-&gt;<name>down</name></name> = <call><name><name>cx</name>-&gt;<name>maybefp</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>seg</name>-&gt;<name>setPreviousInMemory</name></name><argument_list>(<argument><expr><name>currentSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <name>seg</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>pushSegmentAndFrame</name></name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>seg</name>-&gt;<name>setInitialVarObj</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>StackSpace</name>::<name>popSynthesizedSlowNativeFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isCurrentAndActive</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>hasActiveSegment</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>currentSegment</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call> == <call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasScript</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>FUN_SLOW_NATIVE</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>getFunction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>popSegmentAndFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <call><name><name>currentSegment</name>-&gt;<name>getPreviousInMemory</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>StackSpace</name>::<name>pushDummyFrame</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>FrameGuard</name> &amp;</type><name>fg</name></decl></param>, <param><decl><type><name>JSFrameRegs</name> &amp;</type><name>regs</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>scopeChain</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>getExecuteFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>maybefp</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name><name>fg</name>.<name>getFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PodZero</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>setScopeChain</name></name><argument_list>(<argument><expr><name>scopeChain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>flags</name></name> = <name>JSFRAME_DUMMY</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>regs</name>.<name>pc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name>.<name>sp</name></name> = <call><name><name>fp</name>-&gt;<name>slots</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pushExecuteFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fg</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>FrameRegsIter</name>::<name>initSlow</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>curseg</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>curfp</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cursp</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>curpc</name> = <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>curseg</name>-&gt;<name>isSuspended</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>curfp</name> = <call><name><name>curseg</name>-&gt;<name>getSuspendedFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cursp</name> = <call><name><name>curseg</name>-&gt;<name>getSuspendedRegs</name></name><argument_list>()</argument_list></call>-&gt;<name>sp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>curpc</name> = <call><name><name>curseg</name>-&gt;<name>getSuspendedRegs</name></name><argument_list>()</argument_list></call>-&gt;<name>pc</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Using the invariant described in the js::StackSegment comment, we know that,
 * when a pair of down-linked stack frames are in the same segment, the
 * up-frame's address is the top of the down-frame's stack, modulo missing
 * arguments.
 */</comment>
<function><type><name>void</name></type>
<name><name>FrameRegsIter</name>::<name>incSlow</name></name><parameter_list>(<param><decl><type><name>JSStackFrame</name> *</type><name>up</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>down</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>curpc</name> == <name><name>down</name>-&gt;<name>savedPC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>up</name> == <call><name><name>curseg</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the up-frame is in csup and the down-frame is in csdown, it is not
     * necessarily the case that |csup-&gt;getPreviousInContext == csdown| or that
     * |csdown-&gt;getSuspendedFrame == down| (because of indirect eval and
     * JS_EvaluateInStackFrame). To compute down's sp, we need to do a linear
     * scan, keeping track of what is immediately after down in memory.
     */</comment>
    <expr_stmt><expr><name>curseg</name> = <call><name><name>curseg</name>-&gt;<name>getPreviousInContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cursp</name> = <call><name><name>curseg</name>-&gt;<name>getSuspendedRegs</name></name><argument_list>()</argument_list></call>-&gt;<name>sp</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>f</name> <init>= <expr><call><name><name>curseg</name>-&gt;<name>getSuspendedFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>f</name> != <name>down</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name>f</name> == <call><name><name>curseg</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>curseg</name> = <call><name><name>curseg</name>-&gt;<name>getPreviousInContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cursp</name> = <call><name><name>curseg</name>-&gt;<name>getSuspendedRegs</name></name><argument_list>()</argument_list></call>-&gt;<name>sp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>f</name> = <call><name><name>curseg</name>-&gt;<name>getSuspendedFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>cursp</name> = <call><name>contiguousDownFrameSP</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>f</name> = <name><name>f</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></while>
}</block></function>

<function><type><name>bool</name></type>
<name><name>JSThreadData</name>::<name>init</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* The data must be already zeroed. */</comment>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> != <sizeof>sizeof<argument_list>(<argument><expr>*<name>this</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>uint8</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr>!<call><name><name>stackSpace</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>InitJIT</name><argument_list>(<argument><expr>&amp;<name>traceMonitor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>dtoaState</name> = <call><name>js_NewDtoaState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>dtoaState</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>nativeStackBase</name> = <call><name>GetNativeStackBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSThreadData</name>::<name>finish</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* All GC-related things must be already removed at this point. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>gcFreeLists</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> != <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>scriptsToGC</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>scriptsToGC</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>conservativeGC</name>.<name>hasStackToScan</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>dtoaState</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_DestroyDtoaState</name><argument_list>(<argument><expr><name>dtoaState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>js_FinishGSNCache</name><argument_list>(<argument><expr>&amp;<name>gsnCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>propertyCache</name>.~<name>PropertyCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_TRACER</name></expr></cpp:if>
    <expr_stmt><expr><call><name>FinishJIT</name><argument_list>(<argument><expr>&amp;<name>traceMonitor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name><name>stackSpace</name>.<name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSThreadData</name>::<name>mark</name></name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>stackSpace</name>.<name>mark</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>traceMonitor</name>.<name>mark</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSThreadData</name>::<name>purge</name></name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>gcFreeLists</name>.<name>purge</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>js_PurgeGSNCache</name><argument_list>(<argument><expr>&amp;<name>gsnCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* FIXME: bug 506341. */</comment>
    <expr_stmt><expr><call><name><name>propertyCache</name>.<name>purge</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/*
     * If we are about to regenerate shapes, we have to flush the JIT cache,
     * which will eventually abort any current recording.
     */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRegenShapes</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>traceMonitor</name>.<name>needFlush</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Destroy eval'ed scripts. */</comment>
    <expr_stmt><expr><call><name>js_DestroyScriptsToGC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Purge cached native iterators. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cachedNativeIterators</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cachedNativeIterators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dtoaCache</name>.<name>s</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>JSThread</name> *</type>
<name>NewThread</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>id</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>js_CurrentThreadId</name><argument_list>()</argument_list></call> == <name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name> <init>= <expr>(<name>JSThread</name> *) <call><name>js_calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSThread</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>thread</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_INIT_CLIST</name><argument_list>(<argument><expr>&amp;<name><name>thread</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thread</name>-&gt;<name>id</name></name> = <name>id</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>thread</name>-&gt;<name>data</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>thread</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyThread</name><parameter_list>(<param><decl><type><name>JSThread</name> *</type><name>thread</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* The thread must have zero contexts. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>thread</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>thread</name>-&gt;<name>titleToShare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>thread</name>-&gt;<name>data</name>.<name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSThread</name> *</type>
<name>js_CurrentThread</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>id</name> <init>= <expr><call><name>js_CurrentThreadId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We must not race with a GC that accesses cx-&gt;thread for JSContext
     * instances on all threads, see bug 476934.
     */</comment>
    <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>JSThread</name>::<name>Map</name>::<name>AddPtr</name></name></type> <name>p</name> <init>= <expr><call><name><name>rt</name>-&gt;<name>threads</name>.<name>lookupForAdd</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>thread</name> = <name><name>p</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thread</name> = <call><name>NewThread</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>thread</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>rt</name>-&gt;<name>threads</name>.<name>relookupOrAdd</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DestroyThread</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Another thread cannot add an entry for the current thread id. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>value</name></name> == <name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>thread</name>-&gt;<name>id</name></name> == <name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>thread</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_InitContextThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name> <init>= <expr><call><name>js_CurrentThread</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>thread</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_APPEND_LINK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>threadLinks</name></name></expr></argument>, <argument><expr>&amp;<name><name>thread</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>thread</name></name> = <name>thread</name></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_ClearContextThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_THREAD_IS_ME</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_REMOVE_AND_INIT_LINK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>threadLinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>thread</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>

<function><type><name>JSThreadData</name> *</type>
<name>js_CurrentThreadData</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name> <init>= <expr><call><name>js_CurrentThread</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>thread</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <return>return <expr>&amp;<name><name>thread</name>-&gt;<name>data</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr>&amp;<name><name>rt</name>-&gt;<name>threadData</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_InitThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr>!<call><name><name>rt</name>-&gt;<name>threads</name>.<name>init</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr>!<call><name><name>rt</name>-&gt;<name>threadData</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_FinishThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr>!<call><name><name>rt</name>-&gt;<name>threads</name>.<name>initialized</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>
    <for>for (<init><decl><type><name><name>JSThread</name>::<name>Map</name>::<name>Range</name></name></type> <name>r</name> <init>= <expr><call><name><name>rt</name>-&gt;<name>threads</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr>!<call><name><name>r</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>r</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name> <init>= <expr><call><name><name>r</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>value</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>thread</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DestroyThread</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>threads</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>threadData</name>.<name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>js_PurgeThreads</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <for>for (<init><expr><name><name>JSThread</name>::<name>Map</name>::<name>Enum</name></name> <call><name>e</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>threads</name></name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr>!<call><name><name>e</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition>
         <incr><expr><call><name><name>e</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name> <init>= <expr><call><name><name>e</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>value</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>thread</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name> != <name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_DestroyScriptsToGC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>thread</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The following is potentially suboptimal as it also zeros the
             * caches in data, but the code simplicity wins here.
             */</comment>
            <expr_stmt><expr><call><name><name>thread</name>-&gt;<name>data</name>.<name>gcFreeLists</name>.<name>purge</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DestroyThread</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>e</name>.<name>removeFront</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name><name>thread</name>-&gt;<name>data</name>.<name>purge</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>thread</name>-&gt;<name>gcThreadMallocBytes</name></name> = <name>JS_GC_THREAD_MALLOC_LIMIT</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>threadData</name>.<name>purge</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
 * JSOPTION_XML and JSOPTION_ANONFUNFIX must be part of the JS version
 * associated with scripts, so in addition to storing them in cx-&gt;options we
 * duplicate them in cx-&gt;version (script-&gt;version, etc.) and ensure each bit
 * remains synchronized between the two through these two functions.
 */</comment>
<function><type><name>void</name></type>
<name>js_SyncOptionsToVersion</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>options</name></name> &amp; <name>JSOPTION_XML</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>version</name></name> |= <name>JSVERSION_HAS_XML</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>version</name></name> &amp;= ~<name>JSVERSION_HAS_XML</name></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>options</name></name> &amp; <name>JSOPTION_ANONFUNFIX</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>version</name></name> |= <name>JSVERSION_ANONFUNFIX</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>version</name></name> &amp;= ~<name>JSVERSION_ANONFUNFIX</name></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><specifier>inline</specifier> <name>void</name></type>
<name>js_SyncVersionToOptions</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>version</name></name> &amp; <name>JSVERSION_HAS_XML</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>options</name></name> |= <name>JSOPTION_XML</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>options</name></name> &amp;= ~<name>JSOPTION_XML</name></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>version</name></name> &amp; <name>JSVERSION_ANONFUNFIX</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>options</name></name> |= <name>JSOPTION_ANONFUNFIX</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>options</name></name> &amp;= ~<name>JSOPTION_ANONFUNFIX</name></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>js_OnVersionChange</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSVersion</name></type> <name>version</name> <init>= <expr><call><name>JSVERSION_NUMBER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>version</name> == <name>JSVERSION_DEFAULT</name> || <name>version</name> &gt;= <name>JSVERSION_ECMA_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>js_SetVersion</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSVersion</name></type> <name>version</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>version</name></name> = <name>version</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_SyncVersionToOptions</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_OnVersionChange</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSContext</name> *</type>
<name>js_NewContext</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>stackChunkSize</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>first</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContextCallback</name></type> <name>cxCallback</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We need to initialize the new context fully before adding it to the
     * runtime list. After that it can be accessed from another thread via
     * js_ContextIterator.
     */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>mem</name> <init>= <expr><call><name>js_calloc</name><argument_list>(<argument><expr>sizeof *<name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>mem</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>cx</name> = new (<name>mem</name>) <call><name>JSContext</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>debugHooks</name></name> = &amp;<name><name>rt</name>-&gt;<name>globalDebugHooks</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_STACK_GROWTH_DIRECTION</name> &gt; 0</expr></cpp:if>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>stackLimit</name></name> = (<name>jsuword</name>) -1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>scriptStackQuota</name></name> = <name>JS_DEFAULT_SCRIPT_STACK_QUOTA</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSVERSION_DEFAULT</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>version</name></name> == <name>JSVERSION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_InitArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr>"temp"</expr></argument>, <argument><expr><name>TEMP_POOL_CHUNK_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                     <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_InitArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>regExpPool</name></name></expr></argument>, <argument><expr>"regExp"</expr></argument>, <argument><expr><name>TEMP_POOL_CHUNK_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                     <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>resolveFlags</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr>!<call><name>js_InitContextThread</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>FreeContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Here the GC lock is still held after js_InitContextThread took it and
     * the GC is not running on another thread.
     */</comment>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>state</name></name> == <name>JSRTS_UP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>first</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>state</name></name> == <name>JSRTS_DOWN</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>first</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>state</name></name> = <name>JSRTS_LAUNCHING</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_WAIT_CONDVAR</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>stateChange</name></name></expr></argument>, <argument><expr><name>JS_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * During the above wait after we are notified about the state change
         * but before we wake up, another thread could enter the GC from
         * js_DestroyContext, bug 478336. So we must wait here to ensure that
         * when we exit the loop with the first flag set to true, that GC is
         * finished.
         */</comment>
        <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>JS_APPEND_LINK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>link</name></name></expr></argument>, <argument><expr>&amp;<name><name>rt</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>js_InitRandom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If cx is the first context on this runtime, initialize well-known atoms,
     * keywords, numbers, and strings.  If one of these steps should fail, the
     * runtime will be left in a partially initialized state, with zeroes and
     * nulls stored in the default-initialized remainder of the struct.  We'll
     * clean the runtime up under js_DestroyContext, because cx will be "last"
     * as well as "first".
     */</comment>
    <if>if <condition>(<expr><name>first</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr_stmt><expr><call><name>JS_BeginRequest</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>ok</name> = <call><name>js_InitCommonAtoms</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * scriptFilenameTable may be left over from a previous episode of
         * non-zero contexts alive in rt, so don't re-init the table if it's
         * not necessary.
         */</comment>
        <if>if <condition>(<expr><name>ok</name> &amp;&amp; !<name><name>rt</name>-&gt;<name>scriptFilenameTable</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = <call><name>js_InitRuntimeScriptState</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
            <expr_stmt><expr><name>ok</name> = <call><name>js_InitRuntimeNumberState</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Ensure that the empty scopes initialized by
             * JSScope::initRuntimeState get the desired special shapes.
             * (The rt-&gt;state dance above guarantees that this abuse of
             * rt-&gt;shapeGen is thread-safe.)
             */</comment>
            <decl_stmt><decl><type><name>uint32</name></type> <name>shapeGen</name> <init>= <expr><name><name>rt</name>-&gt;<name>shapeGen</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>shapeGen</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> = <call><name><name>JSScope</name>::<name>initRuntimeState</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>shapeGen</name></name> &lt; <name>shapeGen</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>rt</name>-&gt;<name>shapeGen</name></name> = <name>shapeGen</name></expr>;</expr_stmt></then></if>
        }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr_stmt><expr><call><name>JS_EndRequest</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_DestroyContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSDCM_NEW_FAILED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <function_decl><type><name>AutoLockGC</name></type> <name>lock</name><parameter_list>(<param><decl><type><name>rt</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>state</name></name> = <name>JSRTS_UP</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_NOTIFY_ALL_CONDVAR</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>stateChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>cxCallback</name> = <name><name>rt</name>-&gt;<name>cxCallback</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cxCallback</name> &amp;&amp; !<call><name>cxCallback</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSCONTEXT_NEW</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_DestroyContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSDCM_NEW_FAILED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Using ContextAllocPolicy, so init after JSContext is ready. */</comment>
    <if>if <condition>(<expr>!<call><name><name>cx</name>-&gt;<name>busyArrays</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>FreeContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>cx</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name> &amp;&amp; <name>defined</name> <name>XP_UNIX</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<class>class <name>JSAutoFile</name> <block>{<private type="default">
</private><public>public:
    <constructor><name>JSAutoFile</name><parameter_list>()</parameter_list> <member_list>: <call><name>mFile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

    <destructor><name>~<name>JSAutoFile</name></name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name>mFile</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>mFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></destructor>

    <function><type><name>FILE</name> *</type><name>open</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name>mFile</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    <function><name>operator FILE *</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mFile</name></expr>;</return>
    }</block></function>

</public><private>private:
    <decl_stmt><decl><type><name>FILE</name> *</type><name>mFile</name></decl>;</decl_stmt>
</private>}</block>;</class>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DumpEvalCacheMeter</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"JS_EVALCACHE_STATFILE"</expr></argument>)</argument_list></call></expr></init></decl>)</condition><then> <block>{
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ptrdiff_t</name></type>  <name>offset</name></decl>;</decl_stmt>
        </public>}</block> <decl><name><name>table</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>frob</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ #x, offsetof(JSEvalCacheMeter, x) }</cpp:value></cpp:define>
            <macro><name>EVAL_CACHE_METER_LIST</name><argument_list>(<argument>frob</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>frob</name></cpp:undef>
        }</block></expr></init></decl>;</struct>
        <decl_stmt><decl><type><name>JSEvalCacheMeter</name> *</type><name>ecm</name> <init>= <expr>&amp;<call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>evalCacheMeter</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>static</specifier> <name>JSAutoFile</name></type> <name>fp</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>fp</name> &amp;&amp; !<call><name><name>fp</name>.<name>open</name></name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"eval cache meter (%p):\n"</expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
                <argument><expr>(<name>void</name> *) <name><name>cx</name>-&gt;<name>thread</name></name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                (<name>void</name> *) <name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>uintN</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%-8.8s  %llu\n"</expr></argument>,
                    <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>,
                    <argument><expr>(<name>unsigned</name> <name>long</name> <name>long</name> <name>int</name>) *(<name>uint64</name> *)((<name>uint8</name> *)<name>ecm</name> + <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>offset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"hit ratio %g%%\n"</expr></argument>, <argument><expr><name><name>ecm</name>-&gt;<name>hit</name></name> * 100. / <name><name>ecm</name>-&gt;<name>probe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"avg steps %g\n"</expr></argument>, <argument><expr><call><name>double</name><argument_list>(<argument><expr><name><name>ecm</name>-&gt;<name>step</name></name></expr></argument>)</argument_list></call> / <name><name>ecm</name>-&gt;<name>probe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_EVAL_CACHE_METER</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> <cpp:value>DumpEvalCacheMeter(cx)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DumpFunctionCountMap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>title</name></decl></param>, <param><decl><type><name><name>JSRuntime</name>::<name>FunctionCountMap</name></name> &amp;</type><name>map</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\n%s count map:\n"</expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name><name>JSRuntime</name>::<name>FunctionCountMap</name>::<name>Range</name></name></type> <name>r</name> <init>= <expr><call><name><name>map</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr>!<call><name><name>r</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>r</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr><call><name><name>r</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type> <name>count</name> <init>= <expr><call><name><name>r</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>value</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%10d %s:%u\n"</expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DumpFunctionMeter</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>functionMeterFilename</name></name></expr></init></decl>)</condition><then> <block>{
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ptrdiff_t</name></type>  <name>offset</name></decl>;</decl_stmt>
        </public>}</block> <decl><name><name>table</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>frob</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ #x, offsetof(JSFunctionMeter, x) }</cpp:value></cpp:define>
            <macro><name>FUNCTION_KIND_METER_LIST</name><argument_list>(<argument>frob</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>frob</name></cpp:undef>
        }</block></expr></init></decl>;</struct>
        <decl_stmt><decl><type><name>JSFunctionMeter</name> *</type><name>fm</name> <init>= <expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>functionMeter</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>static</specifier> <name>JSAutoFile</name></type> <name>fp</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>fp</name> &amp;&amp; !<call><name><name>fp</name>.<name>open</name></name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"function meter (%s):\n"</expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>lastScriptFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>uintN</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%-19.19s %d\n"</expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr>*(<name>int32</name> *)((<name>uint8</name> *)<name>fm</name> + <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>offset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <expr_stmt><expr><call><name>DumpFunctionCountMap</name><argument_list>(<argument><expr>"method read barrier"</expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>methodReadBarrierCountMap</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DumpFunctionCountMap</name><argument_list>(<argument><expr>"unjoined function"</expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>unjoinedFunctionCountMap</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_FUNCTION_METER</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>DumpFunctionMeter(cx)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG &amp;&amp; XP_UNIX */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DUMP_EVAL_CACHE_METER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_EVAL_CACHE_METER</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DUMP_FUNCTION_METER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_FUNCTION_METER</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>js_DestroyContext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSDestroyContextMode</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContextCallback</name></type> <name>cxCallback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>last</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>enumerators</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/*
     * For API compatibility we allow to destroy contexts without a thread in
     * optimized builds. We assume that the embedding knows that an OOM error
     * cannot happen in JS_SetContextThread.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name> &amp;&amp; <call><name>CURRENT_THREAD_IS_ME</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>thread</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_SetContextThread</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * For API compatibility we support destroying contexts with non-zero
     * cx-&gt;outstandingRequests but we assume that all JS_BeginRequest calls
     * on this cx contributes to cx-&gt;thread-&gt;requestDepth and there is no
     * JS_SuspendRequest calls that set aside the counter.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>outstandingRequests</name></name> &lt;= <name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>requestDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>mode</name> != <name>JSDCM_NEW_FAILED</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cxCallback</name> = <name><name>rt</name>-&gt;<name>cxCallback</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>cxCallback</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * JSCONTEXT_DESTROY callback is not allowed to fail and must
             * return true.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>JSBool</name></type> <name>callbackStatus</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr><call><name>cxCallback</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSCONTEXT_DESTROY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>callbackStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>state</name></name> == <name>JSRTS_UP</name> || <name><name>rt</name>-&gt;<name>state</name></name> == <name>JSRTS_LAUNCHING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/*
     * Typically we are called outside a request, so ensure that the GC is not
     * running before removing the context from rt-&gt;contextList, see bug 477021.
     */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>requestDepth</name></name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_REMOVE_LINK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>last</name> = (<name><name>rt</name>-&gt;<name>contextList</name>.<name>next</name></name> == &amp;<name><name>rt</name>-&gt;<name>contextList</name></name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>last</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>state</name></name> = <name>JSRTS_LANDING</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>last</name> || <name>mode</name> == <name>JSDCM_FORCE_GC</name> || <name>mode</name> == <name>JSDCM_MAYBE_GC</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        || <name><name>cx</name>-&gt;<name>outstandingRequests</name></name> != 0</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>last</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
            <comment type="block">/*
             * If this thread is not in a request already, begin one now so
             * that we wait for any racing GC started on a not-last context to
             * finish, before we plow ahead and unpin atoms. Note that even
             * though we begin a request here if necessary, we end all
             * thread's requests before forcing a final GC. This lets any
             * not-last context destruction racing in another thread try to
             * force or maybe run the GC, but by that point, rt-&gt;state will
             * not be JSRTS_UP, and that GC attempt will return early.
             */</comment>
            <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>requestDepth</name></name> == 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>JS_BeginRequest</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name><name>JSScope</name>::<name>finishRuntimeState</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_FinishRuntimeNumberState</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Unpin all common atoms before final GC. */</comment>
            <expr_stmt><expr><call><name>js_FinishCommonAtoms</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Clear debugging state to remove GC roots. */</comment>
            <expr_stmt><expr><call><name>JS_ClearAllTraps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ClearAllWatchPoints</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Remove more GC roots in regExpStatics, then collect garbage. */</comment>
        <expr_stmt><expr><call><name>JS_ClearRegExpRoots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <comment type="block">/*
         * Destroying a context implicitly calls JS_EndRequest().  Also, we must
         * end our request here in case we are "last" -- in that event, another
         * js_DestroyContext that was not last might be waiting in the GC for our
         * request to end.  We'll let it run below, just before we do the truly
         * final GC and then free atom state.
         */</comment>
        <while>while <condition>(<expr><name><name>cx</name>-&gt;<name>outstandingRequests</name></name> != 0</expr>)</condition>
            <expr_stmt><expr><call><name>JS_EndRequest</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><name>last</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_GC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GC_LAST_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DUMP_EVAL_CACHE_METER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DUMP_FUNCTION_METER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Take the runtime down, now that it has no contexts or atoms. */</comment>
            <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>state</name></name> = <name>JSRTS_DOWN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_NOTIFY_ALL_CONDVAR</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>stateChange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>mode</name> == <name>JSDCM_FORCE_GC</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>js_GC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>mode</name> == <name>JSDCM_MAYBE_GC</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>JS_MaybeGC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
            <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSThread</name> *</type><name>t</name> <init>= <expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>js_ClearContextThread</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name>JS_CLIST_IS_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>t</name>-&gt;<name>contextList</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>!<name><name>t</name>-&gt;<name>requestDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_METER_DST_OFFSET_CACHING</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>dstOffsetCache</name>.<name>dumpStats</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeContext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Free the stuff hanging off of cx. */</comment>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>regExpStatics</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>regExpPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>lastMessage</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>lastMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Remove any argument formatters. */</comment>
    <decl_stmt><decl><type><name>JSArgumentFormatMap</name> *</type><name>map</name> <init>= <expr><name><name>cx</name>-&gt;<name>argumentFormatMap</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>map</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>JSArgumentFormatMap</name> *</type><name>temp</name> <init>= <expr><name>map</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>map</name> = <name><name>map</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* Destroy the resolve recursion damper. */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>resolvingTable</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_DHashTableDestroy</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>resolvingTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>resolvingTable</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Finally, free cx itself. */</comment>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;~<name>JSContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ValidContextPointer</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSCList</name> *</type><name>cl</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>cl</name> = <name><name>rt</name>-&gt;<name>contextList</name>.<name>next</name></name></expr>;</init> <condition><expr><name>cl</name> != &amp;<name><name>rt</name>-&gt;<name>contextList</name></name></expr>;</condition> <incr><expr><name>cl</name> = <name><name>cl</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name>cl</name> == &amp;<name><name>cx</name>-&gt;<name>link</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_RUNTIME_METER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>deadContexts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>JSContext</name> *</type>
<name>js_ContextIterator</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>unlocked</name></decl></param>, <param><decl><type><name>JSContext</name> **</type><name>iterp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name> <init>= <expr>*<name>iterp</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Conditionally</name><argument_list>&lt;<argument><expr><name>AutoLockGC</name></expr></argument>&gt;</argument_list></name></type> <name>lockIf</name><argument_list>(<argument><expr>!!<name>unlocked</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>cx</name> = <call><name>js_ContextFromLinkField</name><argument_list>(<argument><expr><name>cx</name> ? <name><name>cx</name>-&gt;<name>link</name>.<name>next</name></name> : <name><name>rt</name>-&gt;<name>contextList</name>.<name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>&amp;<name><name>cx</name>-&gt;<name>link</name></name> == &amp;<name><name>rt</name>-&gt;<name>contextList</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>cx</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr>*<name>iterp</name> = <name>cx</name></expr>;</expr_stmt>
    <return>return <expr><name>cx</name></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSContext *</argument>)</argument_list></macro>
<macro><name>js_NextActiveContext</name><argument_list>(<argument>JSRuntime *rt</argument>, <argument>JSContext *cx</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>iter</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <while>while <condition>(<expr>(<name>cx</name> = <call><name>js_ContextIterator</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>outstandingRequests</name></name> &amp;&amp; <name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>requestDepth</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></while>
    <return>return <expr><name>cx</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>js_ContextIterator</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<function><type><specifier>static</specifier> <name>JSDHashNumber</name></type>
<name>resolving_HashKey</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSResolvingKey</name> *</type><name>key</name> <init>= <expr>(const <name>JSResolvingKey</name> *)<name>ptr</name></expr></init></decl>;</decl_stmt>

    <return>return <expr>(<call><name>JSDHashNumber</name><argument_list>(<argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name><name>key</name>-&gt;<name>obj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;&gt; <name>JS_GCTHING_ALIGN</name>) ^ <call><name>JSID_BITS</name><argument_list>(<argument><expr><name><name>key</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>resolving_MatchEntry</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSResolvingEntry</name> *</type><name>entry</name> <init>= <expr>(const <name>JSResolvingEntry</name> *)<name>hdr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSResolvingKey</name> *</type><name>key</name> <init>= <expr>(const <name>JSResolvingKey</name> *)<name>ptr</name></expr></init></decl>;</decl_stmt>

    <return>return <expr><name><name>entry</name>-&gt;<name>key</name>.<name>obj</name></name> == <name><name>key</name>-&gt;<name>obj</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>key</name>.<name>id</name></name> == <name><name>key</name>-&gt;<name>id</name></name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>JSDHashTableOps</name></type> <name>resolving_dhash_ops</name> <init>= <expr><block>{
    <expr><name>JS_DHashAllocTable</name></expr>,
    <expr><name>JS_DHashFreeTable</name></expr>,
    <expr><name>resolving_HashKey</name></expr>,
    <expr><name>resolving_MatchEntry</name></expr>,
    <expr><name>JS_DHashMoveEntryStub</name></expr>,
    <expr><name>JS_DHashClearEntryStub</name></expr>,
    <expr><name>JS_DHashFinalizeStub</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>JSBool</name></type>
<name>js_StartResolving</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSResolvingKey</name> *</type><name>key</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flag</name></decl></param>,
                  <param><decl><type><name>JSResolvingEntry</name> **</type><name>entryp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSResolvingEntry</name> *</type><name>entry</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>table</name> = <name><name>cx</name>-&gt;<name>resolvingTable</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>table</name> = <call><name>JS_NewDHashTable</name><argument_list>(<argument><expr>&amp;<name>resolving_dhash_ops</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSResolvingEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                 <argument><expr><name>JS_DHASH_MIN_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then>
            <goto>goto <name>outofmem</name>;</goto></then></if>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>resolvingTable</name></name> = <name>table</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>entry</name> = (<name>JSResolvingEntry</name> *)
            <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>JS_DHASH_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then>
        <goto>goto <name>outofmem</name>;</goto></then></if>

    <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>flags</name></name> &amp; <name>flag</name></expr>)</condition><then> <block>{
        <comment type="block">/* An entry for (key, flag) exists already -- dampen recursion. */</comment>
        <expr_stmt><expr><name>entry</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* Fill in key if we were the first to add entry, then set flag. */</comment>
        <if>if <condition>(<expr>!<name><name>entry</name>-&gt;<name>key</name>.<name>obj</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>entry</name>-&gt;<name>key</name></name> = *<name>key</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>flags</name></name> |= <name>flag</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr>*<name>entryp</name> = <name>entry</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<label><name>outofmem</name>:</label>
    <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_StopResolving</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSResolvingKey</name> *</type><name>key</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flag</name></decl></param>,
                 <param><decl><type><name>JSResolvingEntry</name> *</type><name>entry</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>generation</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Clear flag from entry-&gt;flags and return early if other flags remain.
     * We must take care to re-lookup entry if the table has changed since
     * it was found by js_StartResolving.
     */</comment>
    <expr_stmt><expr><name>table</name> = <name><name>cx</name>-&gt;<name>resolvingTable</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>entry</name> || <name><name>table</name>-&gt;<name>generation</name></name> != <name>generation</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>entry</name> = (<name>JSResolvingEntry</name> *)
                <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>JS_DHASH_LOOKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_DHASH_ENTRY_IS_BUSY</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>hdr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name>-&gt;<name>flags</name></name> &amp;= ~<name>flag</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>flags</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <comment type="block">/*
     * Do a raw remove only if fewer entries were removed than would cause
     * alpha to be less than .5 (alpha is at most .75).  Otherwise, we just
     * call JS_DHashTableOperate to re-lookup the key and remove its entry,
     * compressing or shrinking the table as needed.
     */</comment>
    <if>if <condition>(<expr><name><name>table</name>-&gt;<name><name>removedCount</name> <argument_list>&lt; <argument><expr><name>JS_DHASH_TABLE_SIZE</name>(<name>table</name>)</expr></argument> &gt;</argument_list></name></name>&gt; 2</expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_DHashTableRawRemove</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr>&amp;<name><name>entry</name>-&gt;<name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>JS_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportError</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl></param>, <param><decl><type><name>JSErrorReport</name> *</type><name>reportp</name></decl></param>,
            <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>, <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Check the error report, and set a JavaScript-catchable exception
     * if the error is defined to have an associated exception.  If an
     * exception is thrown, then the JSREPORT_EXCEPTION flag will be set
     * on the error report, and exception-aware hosts should ignore it.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>reportp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(!<name>callback</name> || <name>callback</name> == <name>js_GetErrorMessage</name>) &amp;&amp;
        <name><name>reportp</name>-&gt;<name>errorNumber</name></name> == <name>JSMSG_UNCAUGHT_EXCEPTION</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>reportp</name>-&gt;<name>flags</name></name> |= <name>JSREPORT_EXCEPTION</name></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * Call the error reporter only if an exception wasn't raised.
     *
     * If an exception was raised, then we call the debugErrorHook
     * (if present) to give it a chance to see the error before it
     * propagates out of scope.  This is needed for compatability
     * with the old scheme.
     */</comment>
    <if>if <condition>(<expr>!<call><name>JS_IsRunning</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> ||
        !<call><name>js_ErrorToException</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>reportp</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>userRef</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportErrorAgain</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>reportp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHook</name></name> &amp;&amp; <name><name>cx</name>-&gt;<name>errorReporter</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDebugErrorHook</name></type> <name>hook</name> <init>= <expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHook</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* test local in case debugErrorHook changed on another thread */</comment>
        <if>if <condition>(<expr><name>hook</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>reportp</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHookData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if></else></if>
}</block></function>

<comment type="block">/* The report must be initially zeroed. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PopulateReportBlame</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSErrorReport</name> *</type><name>report</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Walk stack until we find a frame that is associated with some script
     * rather than a native frame.
     */</comment>
    <for>for (<init><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name>js_GetTopStackFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>fp</name></expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name><name>fp</name>-&gt;<name>pc</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>report</name>-&gt;<name>filename</name></name> = <call><name><name>fp</name>-&gt;<name>getScript</name></name><argument_list>()</argument_list></call>-&gt;<name>filename</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>report</name>-&gt;<name>lineno</name></name> = <call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/*
 * We don't post an exception in this case, since doing so runs into
 * complications of pre-allocating an exception object which required
 * running the Exception class initializer early etc.
 * Instead we just invoke the errorReporter with an "Out Of Memory"
 * type message, and then hope the process ends swiftly.
 */</comment>
<function><type><name>void</name></type>
<name>js_ReportOutOfMemory</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/*
     * If we are in a builtin called directly from trace, don't report an
     * error. We will retry in the interpreter instead.
     */</comment>
    <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp; !<name><name>cx</name>-&gt;<name>bailExit</name></name></expr>)</condition><then>
        <return>return;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSErrorReport</name></type> <name>report</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSErrorReporter</name></type> <name>onError</name> <init>= <expr><name><name>cx</name>-&gt;<name>errorReporter</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get the message for this error, but we won't expand any arguments. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSErrorFormatString</name> *</type><name>efs</name> <init>=
        <expr><call><name>js_GetLocalizedErrorMessage</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name> <init>= <expr><name>efs</name> ? <name><name>efs</name>-&gt;<name>format</name></name> : "Out of memory"</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Fill out the report, but don't do anything that requires allocation. */</comment>
    <expr_stmt><expr><call><name>PodZero</name><argument_list>(<argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>flags</name></name> = <name>JSREPORT_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>errorNumber</name></name> = <name>JSMSG_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PopulateReportBlame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If debugErrorHook is present then we give it a chance to veto sending
     * the error on to the regular ErrorReporter. We also clear a pending
     * exception if any now so the hooks can replace the out-of-memory error
     * by a script-catchable exception.
     */</comment>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>onError</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDebugErrorHook</name></type> <name>hook</name> <init>= <expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHook</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>hook</name> &amp;&amp;
            !<call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHookData</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>onError</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>onError</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>onError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>js_ReportOutOfScriptQuota</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>JSMSG_SCRIPT_STACK_QUOTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_ReportOverRecursed</name><argument_list>(<argument>JSContext *cx</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_OVER_RECURSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<function><type><name>void</name></type>
<name>js_ReportAllocationOverflow</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_ALLOC_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Given flags and the state of cx, decide whether we should report an
 * error, a warning, or just continue execution normally.  Return
 * true if we should continue normally, without reporting anything;
 * otherwise, adjust *flags as appropriate and return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkReportFlags</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name> *</type><name>flags</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>JSREPORT_IS_STRICT_MODE_ERROR</name><argument_list>(<argument><expr>*<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Error in strict code; warning with strict option; okay otherwise.
         * We assume that if the top frame is a native, then it is strict if
         * the nearest scripted frame is strict, see bug 536306.
         */</comment>
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name>js_GetScriptedCaller</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>fp</name> &amp;&amp; <call><name><name>fp</name>-&gt;<name>getScript</name></name><argument_list>()</argument_list></call>-&gt;<name>strictModeCode</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>flags</name> &amp;= ~<name>JSREPORT_WARNING</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>flags</name> |= <name>JSREPORT_WARNING</name></expr>;</expr_stmt></then>
        <else>else
            <return>return <expr>true</expr>;</return></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSREPORT_IS_STRICT</name><argument_list>(<argument><expr>*<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Warning/error only when JSOPTION_STRICT is set. */</comment>
        <if>if <condition>(<expr>!<call><name>JS_HAS_STRICT_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
    }</block></then></if></else></if>

    <comment type="block">/* Warnings become errors when JSOPTION_WERROR is set. */</comment>
    <if>if <condition>(<expr><call><name>JSREPORT_IS_WARNING</name><argument_list>(<argument><expr>*<name>flags</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JS_HAS_WERROR_OPTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>*<name>flags</name> &amp;= ~<name>JSREPORT_WARNING</name></expr>;</expr_stmt></then></if>

    <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ReportErrorVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>ucmessage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>messagelen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSErrorReport</name></type> <name>report</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>warning</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>checkReportFlags</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>message</name> = <call><name>JS_vsmprintf</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>message</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>messagelen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PodZero</name><argument_list>(<argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>errorNumber</name></name> = <name>JSMSG_USER_DEFINED_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>ucmessage</name></name> = <name>ucmessage</name> = <call><name>js_InflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>&amp;<name>messagelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PopulateReportBlame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>warning</name> = <call><name>JSREPORT_IS_WARNING</name><argument_list>(<argument><expr><name><name>report</name>.<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReportError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>ucmessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>warning</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * The arguments from ap need to be packaged up into an array and stored
 * into the report struct.
 *
 * The format string addressed by the error number may contain operands
 * identified by the format {N}, where N is a decimal digit. Each of these
 * is to be replaced by the Nth argument from the va_list. The complete
 * message is placed into reportp-&gt;ucmessage converted to a JSString.
 *
 * Returns true if the expansion succeeds (can fail if out of memory).
 */</comment>
<function><type><name>JSBool</name></type>
<name>js_ExpandErrorArguments</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                        <param><decl><type><name>char</name> **</type><name>messagep</name></decl></param>, <param><decl><type><name>JSErrorReport</name> *</type><name>reportp</name></decl></param>,
                        <param><decl><type><name>bool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSErrorFormatString</name> *</type><name>efs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argCount</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>messagep</name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Most calls supply js_GetErrorMessage; if this is so, assume NULL. */</comment>
    <if>if <condition>(<expr>!<name>callback</name> || <name>callback</name> == <name>js_GetErrorMessage</name></expr>)</condition><then>
        <expr_stmt><expr><name>efs</name> = <call><name>js_GetLocalizedErrorMessage</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>userRef</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errorNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>efs</name> = <call><name>callback</name><argument_list>(<argument><expr><name>userRef</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errorNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name>efs</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>totalArgsLength</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name><name>argLengths</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* only {0} thru {9} supported */</comment>
        <expr_stmt><expr><name>argCount</name> = <name><name>efs</name>-&gt;<name>argCount</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>argCount</name> &lt;= 10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>argCount</name> &gt; 0</expr>)</condition><then> <block>{
            <comment type="block">/*
             * Gather the arguments into an array, and accumulate
             * their sizes. We allocate 1 more than necessary and
             * null it out to act as the caboose when we free the
             * pointers later.
             */</comment>
            <expr_stmt><expr><name><name>reportp</name>-&gt;<name>messageArgs</name></name> = (const <name>jschar</name> **)
                <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name> *</expr></argument>)</argument_list></sizeof> * (<name>argCount</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>reportp</name>-&gt;<name>messageArgs</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>argCount</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>argCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name>charArgs</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>char</name> *</type><name>charArg</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>size_t</name></type> <name>charArgLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>charArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name>
                        = <call><name>js_InflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>charArg</name></expr></argument>, <argument><expr>&amp;<name>charArgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                        <goto>goto <name>error</name>;</goto></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>jschar</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><name><name>argLengths</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>js_strlen</name><argument_list>(<argument><expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>totalArgsLength</name> += <name><name>argLengths</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
            <comment type="block">/* NULL-terminate for easy copying. */</comment>
            <expr_stmt><expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/*
         * Parse the error format, substituting the argument X
         * for {X} in the format.
         */</comment>
        <if>if <condition>(<expr><name>argCount</name> &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>efs</name>-&gt;<name>format</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>jschar</name> *</type><name>buffer</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>, *<decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>expandedArgs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>expandedLength</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>efs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>buffer</name> = <name>fmt</name> = <call><name>js_InflateString</name> <argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>efs</name>-&gt;<name>format</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>buffer</name></expr>)</condition><then>
                    <goto>goto <name>error</name>;</goto></then></if>
                <expr_stmt><expr><name>expandedLength</name> = <name>len</name>
                                 - (3 * <name>argCount</name>)       <comment type="block">/* exclude the {n} */</comment>
                                 + <name>totalArgsLength</name></expr>;</expr_stmt>

                <comment type="block">/*
                * Note - the above calculation assumes that each argument
                * is used once and only once in the expansion !!!
                */</comment>
                <expr_stmt><expr><name><name>reportp</name>-&gt;<name>ucmessage</name></name> = <name>out</name> = (<name>jschar</name> *)
                    <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>expandedLength</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>out</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>error</name>;</goto>
                }</block></then></if>
                <while>while <condition>(<expr>*<name>fmt</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr>*<name>fmt</name> == '{'</expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>fmt</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name><name>fmt</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>d</name> &lt; <name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>,
                                       <argument><expr><name><name>argLengths</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>out</name> += <name><name>argLengths</name><index>[<expr><name>d</name></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>fmt</name> += 3</expr>;</expr_stmt>
                            <expr_stmt><expr><name>expandedArgs</name>++</expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if>
                    <expr_stmt><expr>*<name>out</name>++ = *<name>fmt</name>++</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>expandedArgs</name> == <name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>out</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>messagep</name> =
                    <call><name>js_DeflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>reportp</name>-&gt;<name>ucmessage</name></name></expr></argument>,
                                     <argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>out</name> - <name><name>reportp</name>-&gt;<name>ucmessage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!*<name>messagep</name></expr>)</condition><then>
                    <goto>goto <name>error</name>;</goto></then></if>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * Zero arguments: the format string (if it exists) is the
             * entire message.
             */</comment>
            <if>if <condition>(<expr><name><name>efs</name>-&gt;<name>format</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
                <expr_stmt><expr>*<name>messagep</name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>efs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!*<name>messagep</name></expr>)</condition><then>
                    <goto>goto <name>error</name>;</goto></then></if>
                <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr>*<name>messagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>reportp</name>-&gt;<name>ucmessage</name></name> = <call><name>js_InflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name>messagep</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>reportp</name>-&gt;<name>ucmessage</name></name></expr>)</condition><then>
                    <goto>goto <name>error</name>;</goto></then></if>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>
    <if>if <condition>(<expr>*<name>messagep</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* where's the right place for this ??? */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>defaultErrorMessage</name>
            <init>= <expr>"No error message available for error number %d"</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>defaultErrorMessage</name></expr></argument>)</argument_list></call> + 16</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>messagep</name> = (<name>char</name> *)<call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!*<name>messagep</name></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr>*<name>messagep</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>defaultErrorMessage</name></expr></argument>, <argument><expr><name>errorNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<label><name>error</name>:</label>
    <if>if <condition>(<expr><name><name>reportp</name>-&gt;<name>messageArgs</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* free the arguments only if we allocated them */</comment>
        <if>if <condition>(<expr><name>charArgs</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>reportp</name>-&gt;<name>messageArgs</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>reportp</name>-&gt;<name>messageArgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reportp</name>-&gt;<name>messageArgs</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>reportp</name>-&gt;<name>ucmessage</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>reportp</name>-&gt;<name>ucmessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reportp</name>-&gt;<name>ucmessage</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>*<name>messagep</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)*<name>messagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>messagep</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ReportErrorNumberVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                       <param><decl><type><name>JSBool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSErrorReport</name></type> <name>report</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>message</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>warning</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>checkReportFlags</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>warning</name> = <call><name>JSREPORT_IS_WARNING</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PodZero</name><argument_list>(<argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>report</name>.<name>errorNumber</name></name> = <name>errorNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PopulateReportBlame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>js_ExpandErrorArguments</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>userRef</name></expr></argument>, <argument><expr><name>errorNumber</name></expr></argument>,
                                 <argument><expr>&amp;<name>message</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>, <argument><expr>!!<name>charArgs</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>ReportError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>&amp;<name>report</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>userRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>message</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>report</name>.<name>messageArgs</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * js_ExpandErrorArguments owns its messageArgs only if it had to
         * inflate the arguments (from regular |char *|s).
         */</comment>
        <if>if <condition>(<expr><name>charArgs</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name><name>report</name>.<name>messageArgs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>report</name>.<name>messageArgs</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>report</name>.<name>messageArgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>report</name>.<name>ucmessage</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr>(<name>void</name> *)<name><name>report</name>.<name>ucmessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>warning</name></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_ReportErrorAgain</name><argument_list>(<argument>JSContext *cx</argument>, <argument>const char *message</argument>, <argument>JSErrorReport *reportp</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSErrorReporter</name></type> <name>onError</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>message</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>lastMessage</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>lastMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>lastMessage</name></name> = <call><name>JS_strdup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>lastMessage</name></name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><name>onError</name> = <name><name>cx</name>-&gt;<name>errorReporter</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If debugErrorHook is present then we give it a chance to veto
     * sending the error on to the regular ErrorReporter.
     */</comment>
    <if>if <condition>(<expr><name>onError</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSDebugErrorHook</name></type> <name>hook</name> <init>= <expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHook</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>hook</name> &amp;&amp;
            !<call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>lastMessage</name></name></expr></argument>, <argument><expr><name>reportp</name></expr></argument>,
                  <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>debugErrorHookData</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>onError</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>onError</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>onError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>lastMessage</name></name></expr></argument>, <argument><expr><name>reportp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block>

<function><type><name>void</name></type>
<name>js_ReportIsNotDefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_NOT_DEFINED</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ReportIsNullOrUndefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>,
                           <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bytes</name> = <call><name>DecompileValueGenerator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>spindex</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>js_undefined_str</name></expr></argument>)</argument_list></call> == 0 ||
        <call><name>strcmp</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>js_null_str</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                          <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>JSMSG_NO_PROPERTIES</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>v</name>.<name>isUndefined</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                          <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>JSMSG_UNEXPECTED_TYPE</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
                                          <argument><expr><name>js_undefined_str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>v</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                          <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>JSMSG_UNEXPECTED_TYPE</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>,
                                          <argument><expr><name>js_null_str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_ReportMissingArg</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>argbuf</name><index>[<expr>11</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>argbuf</name></expr></argument>, <argument><expr>sizeof <name>argbuf</name></expr></argument>, <argument><expr>"%u"</expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bytes</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>IsFunctionObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>atom</name> = <call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<call><name><name>v</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-&gt;<name>atom</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes</name> = <call><name>DecompileValueGenerator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSDVG_SEARCH_STACK</name></expr></argument>,
                                        <argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
            <return>return;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>JSMSG_MISSING_FUN_ARG</name></expr></argument>, <argument><expr><name>argbuf</name></expr></argument>,
                         <argument><expr><name>bytes</name> ? <name>bytes</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ReportValueErrorFlags</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                         <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>js_ErrorFormatString</name><index>[<expr><name>errorNumber</name></expr>]</index></name>.<name>argCount</name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>js_ErrorFormatString</name><index>[<expr><name>errorNumber</name></expr>]</index></name>.<name>argCount</name> &lt;= 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bytes</name> = <call><name>DecompileValueGenerator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>spindex</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>bytes</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>ok</name> = <call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errorNumber</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name> &amp;&amp; <name>defined</name> <name>XP_UNIX</name></expr></cpp:if>
<comment type="block">/* For gdb usage. */</comment>
<function><type><name>void</name></type> <name>js_traceon</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>  <block>{ <expr_stmt><expr><name><name>cx</name>-&gt;<name>tracefp</name></name> = <name>stderr</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>cx</name>-&gt;<name>tracePrevPc</name></name> = <name>NULL</name></expr>;</expr_stmt> }</block></function>
<function><type><name>void</name></type> <name>js_traceoff</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name><name>cx</name>-&gt;<name>tracefp</name></name> = <name>NULL</name></expr>;</expr_stmt> }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>JSErrorFormatString</name></type> <name><name>js_ErrorFormatString</name><index>[<expr><name>JSErr_Limit</name></expr>]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_DEF</name><parameter_list>(<param><type><name>name</name></type></param>, <param><type><name>number</name></type></param>, <param><type><name>count</name></type></param>, <param><type><name>exception</name></type></param>, <param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ format, count, exception } ,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"js.msg"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MSG_DEF</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>const JSErrorFormatString *</argument>)</argument_list></macro>
<macro><name>js_GetErrorMessage</name><argument_list>(<argument>void *userRef</argument>, <argument>const char *locale</argument>, <argument>const uintN errorNumber</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr>(<name>errorNumber</name> &gt; 0) &amp;&amp; (<name>errorNumber</name> &lt; <name>JSErr_Limit</name>)</expr>)</condition><then>
        <return>return <expr>&amp;<name><name>js_ErrorFormatString</name><index>[<expr><name>errorNumber</name></expr>]</index></name></expr>;</return></then></if>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<function><type><name>JSBool</name></type>
<name>js_InvokeOperationCallback</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT_REQUEST_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>operationCallbackFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset the callback flag first, then yield. If another thread is racing
     * us here we will accumulate another callback request which will be
     * serviced at the next opportunity.
     */</comment>
    <expr_stmt><expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>operationCallbackFlag</name> = 0</expr>;</expr_stmt>

    <comment type="block">/*
     * Unless we are going to run the GC, we automatically yield the current
     * context every time the operation callback is hit since we might be
     * called as a result of an impending GC, which would deadlock if we do
     * not yield. Operation callbacks are supposed to happen rarely (seconds,
     * not milliseconds) so it is acceptable to yield at every callback.
     */</comment>
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcIsNeeded</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_GC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GC_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * On trace we can exceed the GC quota, see comments in NewGCArena. So
         * we check the quota and report OOM here when we are off trace.
         */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>delayedOutOfMemory</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>delayedOutOfMemory</name> = (<name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt; <name><name>rt</name>-&gt;<name>gcMaxBytes</name></name>)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>delayedOutOfMemory</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <else>else <block>{
        <expr_stmt><expr><call><name>JS_YieldRequest</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSOperationCallback</name></type> <name>cb</name> <init>= <expr><name><name>cx</name>-&gt;<name>operationCallback</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Important: Additional callbacks can occur inside the callback handler
     * if it re-enters the JS engine. The embedding must ensure that the
     * callback is disconnected before attempting such re-entry.
     */</comment>

    <return>return <expr>!<name>cb</name> || <call><name>cb</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_TriggerAllOperationCallbacks</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>gcLocked</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>Conditionally</name><argument_list>&lt;<argument><expr><name>AutoLockGC</name></expr></argument>&gt;</argument_list></name></type> <name>lockIf</name><argument_list>(<argument><expr>!<name>gcLocked</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for (<init><expr><name>ThreadDataIter</name> <call><name>i</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>!<call><name><name>i</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>i</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>)
        <expr_stmt><expr><call><name><name>i</name>.<name>threadData</name></name><argument_list>()</argument_list></call>-&gt;<call><name>triggerOperationCallback</name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
}</block></function>

<function><type><name>JSStackFrame</name> *</type>
<name>js_GetScriptedCaller</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
        <expr_stmt><expr><name>fp</name> = <call><name>js_GetTopStackFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <while>while <condition>(<expr><name>fp</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name><name>fp</name>-&gt;<name>hasScript</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>fp</name></expr>;</return></then></if>
        <expr_stmt><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>jsbytecode</name>*</type>
<name>js_GetCurrentBytecodePC</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>imacpc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pc</name> = <name><name>cx</name>-&gt;<name>bailExit</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>imacpc</name> = <name><name>cx</name>-&gt;<name>bailExit</name>-&gt;<name>imacpc</name></name></expr>;</expr_stmt>
    }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_NOT_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* for static analysis */</comment>
        <expr_stmt><expr><name>pc</name> = <name><name>cx</name>-&gt;<name>regs</name></name> ? <name><name>cx</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> : <name>NULL</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>imacpc</name> = <call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>maybeIMacroPC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * If we are inside GetProperty_tn or similar, return a pointer to the
     * current instruction in the script, not the CALL instruction in the
     * imacro, for the benefit of callers doing bytecode inspection.
     */</comment>
    <return>return <expr>(*<name>pc</name> == <name>JSOP_CALL</name> &amp;&amp; <name>imacpc</name>) ? <name>imacpc</name> : <name>pc</name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name>js_CurrentPCIsInImacro</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name><name>cx</name>-&gt;<name>bailExit</name>-&gt;<name>imacpc</name></name> != <name>NULL</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>cx</name>-&gt;<name>fp</name></name><argument_list>()</argument_list></call>-&gt;<call><name>hasIMacroPC</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr>false</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name><name>DSTOffsetCache</name>::<name>purge</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/*
     * NB: The initial range values are carefully chosen to result in a cache
     *     miss on first use given the range of possible values.  Be careful
     *     to keep these values and the caching algorithm in sync!
     */</comment>
    <expr_stmt><expr><name>offsetMilliseconds</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rangeStartSeconds</name> = <name>rangeEndSeconds</name> = <name>INT64_MIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldOffsetMilliseconds</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>oldRangeStartSeconds</name> = <name>oldRangeEndSeconds</name> = <name>INT64_MIN</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_METER_DST_OFFSET_CACHING</name></cpp:ifdef>
    <expr_stmt><expr><name>totalCalculations</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>hit</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>missIncreasing</name> = <name>missDecreasing</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>missIncreasingOffsetChangeExpand</name> = <name>missIncreasingOffsetChangeUpper</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>missDecreasingOffsetChangeExpand</name> = <name>missDecreasingOffsetChangeLower</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>missLargeIncrease</name> = <name>missLargeDecrease</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>sanityCheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Since getDSTOffsetMilliseconds guarantees that all times seen will be
 * positive, we can initialize the range at construction time with large
 * negative numbers to ensure the first computation is always a cache miss and
 * doesn't return a bogus offset.
 */</comment>
<constructor><name><name>DSTOffsetCache</name>::<name>DSTOffsetCache</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>purge</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>JSContext</name>::<name>JSContext</name></name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
  <member_list>: <call><name>runtime</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call>,
    <call><name>compartment</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>defaultCompartment</name></name></expr></argument>)</argument_list></call>,
    <call><name>regs</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>regExpStatics</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>,
    <call><name>busyArrays</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
</member_list><block>{}</block></constructor>

<function><type><name>void</name></type>
<name><name>JSContext</name>::<name>pushSegmentAndFrame</name></name><parameter_list>(<param><decl><type><name><name>js</name>::<name>StackSegment</name></name> *</type><name>newseg</name></decl></param>, <param><decl><type><name>JSFrameRegs</name> &amp;</type><name>newregs</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>hasActiveSegment</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> == <name><name>JSStackFrame</name>::<name>sInvalidPC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> = <name><name>regs</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>currentSegment</name>-&gt;<name>suspend</name></name><argument_list>(<argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>newseg</name>-&gt;<name>setPreviousInContext</name></name><argument_list>(<argument><expr><name>currentSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <name>newseg</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>newregs</name>.<name>fp</name>-&gt;<name>savedPC</name></name> = <name><name>JSStackFrame</name>::<name>sInvalidPC</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>setCurrentRegs</name><argument_list>(<argument><expr>&amp;<name>newregs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>newseg</name>-&gt;<name>joinContext</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>newregs</name>.<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSContext</name>::<name>popSegmentAndFrame</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>currentSegment</name>-&gt;<name>maybeContext</name></name><argument_list>()</argument_list></call> == <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>currentSegment</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call> == <name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> == <name><name>JSStackFrame</name>::<name>sInvalidPC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>currentSegment</name>-&gt;<name>leaveContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>currentSegment</name> = <call><name><name>currentSegment</name>-&gt;<name>getPreviousInContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>currentSegment</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>currentSegment</name>-&gt;<name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>setCurrentRegs</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>setCurrentRegs</name><argument_list>(<argument><expr><call><name><name>currentSegment</name>-&gt;<name>getSuspendedRegs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>currentSegment</name>-&gt;<name>resume</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <expr_stmt><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> = <name><name>JSStackFrame</name>::<name>sInvalidPC</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>down</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setCurrentRegs</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSContext</name>::<name>saveActiveSegment</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>hasActiveSegment</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>currentSegment</name>-&gt;<name>save</name></name><argument_list>(<argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> == <name><name>JSStackFrame</name>::<name>sInvalidPC</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> = <name><name>regs</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setCurrentRegs</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSContext</name>::<name>restoreSegment</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>js</name>::<name>StackSegment</name></name> *</type><name>ccs</name> <init>= <expr><name>currentSegment</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setCurrentRegs</name><argument_list>(<argument><expr><call><name><name>ccs</name>-&gt;<name>getSuspendedRegs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ccs</name>-&gt;<name>restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>regs</name>-&gt;<name>fp</name>-&gt;<name>savedPC</name></name> = <name><name>JSStackFrame</name>::<name>sInvalidPC</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>JSGenerator</name> *</type>
<name><name>JSContext</name>::<name>generatorFor</name></name><parameter_list>(<param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>stack</name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>fp</name>-&gt;<name>isGenerator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>fp</name>-&gt;<name>isFloatingGenerator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>genStack</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>JS_LIKELY</name><argument_list>(<argument><expr><name>fp</name> == <call><name><name>genStack</name>.<name>back</name></name><argument_list>()</argument_list></call>-&gt;<name>liveFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name><name>genStack</name>.<name>back</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* General case; should only be needed for debug APIs. */</comment>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>genStack</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>genStack</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>liveFrame</name> == <name>fp</name></expr>)</condition><then>
            <return>return <expr><name><name>genStack</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"no matching generator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>StackSegment</name> *</type>
<name><name>JSContext</name>::<name>containingSegment</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>JSStackFrame</name> *</type><name>target</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* The context may have nothing running. */</comment>
    <decl_stmt><decl><type><name>StackSegment</name> *</type><name>seg</name> <init>= <expr><name>currentSegment</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>seg</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* The active segments's top frame is cx-&gt;regs-&gt;fp. */</comment>
    <if>if <condition>(<expr><name>regs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>activeSegment</name><argument_list>()</argument_list></call> == <name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>f</name> <init>= <expr><name><name>regs</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>stop</name> <init>= <expr><call><name><name>seg</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call>-&gt;<name>down</name></expr></init></decl>;</decl_stmt>
        <for>for (<init>;</init> <condition><expr><name>f</name> != <name>stop</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>down</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name>f</name> == <name>target</name></expr>)</condition><then>
                <return>return <expr><name>seg</name></expr>;</return></then></if>
        }</block></for>
        <expr_stmt><expr><name>seg</name> = <call><name><name>seg</name>-&gt;<name>getPreviousInContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* A suspended segment's top frame is its suspended frame. */</comment>
    <for>for (<init>;</init> <condition><expr><name>seg</name></expr>;</condition> <incr><expr><name>seg</name> = <call><name><name>seg</name>-&gt;<name>getPreviousInContext</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>f</name> <init>= <expr><call><name><name>seg</name>-&gt;<name>getSuspendedFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>stop</name> <init>= <expr><call><name><name>seg</name>-&gt;<name>getInitialFrame</name></name><argument_list>()</argument_list></call>-&gt;<name>down</name></expr></init></decl>;</decl_stmt>
        <for>for (<init>;</init> <condition><expr><name>f</name> != <name>stop</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>down</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name>f</name> == <name>target</name></expr>)</condition><then>
                <return>return <expr><name>seg</name></expr>;</return></then></if>
        }</block></for>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSContext</name>::<name>checkMallocGCPressure</name></name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfMemory</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>thread</name>-&gt;<name>gcThreadMallocBytes</name></name> &lt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>n</name> <init>= <expr><name>JS_GC_THREAD_MALLOC_LIMIT</name> - <name><name>thread</name>-&gt;<name>gcThreadMallocBytes</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>thread</name>-&gt;<name>gcThreadMallocBytes</name></name> = <name>JS_GC_THREAD_MALLOC_LIMIT</name></expr>;</expr_stmt>

    <function_decl><type><name>AutoLockGC</name></type> <name>lock</name><parameter_list>(<param><decl><type><name>runtime</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name><name>runtime</name>-&gt;<name>gcMallocBytes</name></name> -= <name>n</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Trigger the GC on memory pressure but only if we are inside a request
     * and not inside a GC.
     */</comment>
    <if>if <condition>(<expr><call><name><name>runtime</name>-&gt;<name>isGCMallocLimitReached</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>thread</name>-&gt;<name>requestDepth</name></name> != 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
        <if>if <condition>(<expr>!<name><name>runtime</name>-&gt;<name>gcRunning</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>runtime</name>-&gt;<name>isGCMallocLimitReached</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>runtime</name>-&gt;<name>gcMallocBytes</name></name> = -1</expr>;</expr_stmt>

            <comment type="block">/*
             * Empty the GC free lists to trigger a last-ditch GC when any GC
             * thing is allocated later on this thread. This makes unnecessary
             * to check for the memory pressure on the fast path of the GC
             * allocator. We cannot touch the free lists on other threads as
             * their manipulation is not thread-safe.
             */</comment>
            <expr_stmt><expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>-&gt;<call><name><name>gcFreeLists</name>.<name>purge</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_TriggerGC</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>bool</name></type>
<name><name>JSContext</name>::<name>isConstructing</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>bailExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>*<name><name>bailExit</name>-&gt;<name>pc</name></name> == <name>JSOP_NEW</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name>js_GetTopStackFrame</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>fp</name> &amp;&amp; (<name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_CONSTRUCTING</name>)</expr>;</return>
}</block></function>


<comment type="block">/*
 * Release pool's arenas if the stackPool has existed for longer than the
 * limit specified by gcEmptyArenaPoolLifespan.
 */</comment>
<function><type><specifier>inline</specifier> <name>void</name></type>
<name>FreeOldArenas</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSArenaPool</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSArena</name> *</type><name>a</name> <init>= <expr><name><name>pool</name>-&gt;<name>current</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>a</name> == <name><name>pool</name>-&gt;<name>first</name>.<name>next</name></name> &amp;&amp; <name><name>a</name>-&gt;<name>avail</name></name> == <name><name>a</name>-&gt;<name>base</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int64</name></type> <name>age</name> <init>= <expr><call><name>JS_Now</name><argument_list>()</argument_list></call> - *(<name>int64</name> *) <name><name>a</name>-&gt;<name>base</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>age</name> &gt; <call><name>int64</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcEmptyArenaPoolLifespan</name></name></expr></argument>)</argument_list></call> * 1000</expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_FreeArenaPool</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSContext</name>::<name>purge</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>FreeOldArenas</name><argument_list>(<argument><expr><name>runtime</name></expr></argument>, <argument><expr>&amp;<name>regExpPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<namespace>namespace <name>js</name> <block>{

<function><type><name>void</name></type>
<name>SetPendingException</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>exception</name></name> = <name>v</name></expr>;</expr_stmt>
}</block></function>

}</block></namespace> <comment type="block">/* namespace js */</comment>
</unit>
