<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00567e7f0b38da3c6fa697a5595d0740d3231750.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   L. David Baron &lt;dbaron@dbaron.org&gt;, Mozilla Corporation
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/* a presentation of a document, part 1 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>nsPresContext_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsPresContext_h___</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupports.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsColor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCoord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFont.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIWeakReference.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITheme.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILanguageAtomService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIObserver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITimer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCRT.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrintSettings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPropertyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRefPtrHashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCycleCollectionParticipant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsChangeHint.h"</cpp:file></cpp:include>
<comment type="line">// This also pulls in gfxTypes.h, which we cannot include directly.</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxRect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIWidget.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/TimeStamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>class</name></type> <name>nsImageLoader</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
<decl_stmt><decl><type><name>class</name></type> <name>nsBidiPresUtils</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>

<struct_decl>struct <name>nsRect</name>;</struct_decl>

<decl_stmt><decl><type><name>class</name></type> <name>imgIRequest</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>nsIFontMetrics</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIFrame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsFrameManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsILinkHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsStyleContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIAtom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIEventStateManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIURI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsILookAndFeel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsICSSPseudoComparator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIAtom</name></decl>;</decl_stmt>
<struct_decl>struct <name>nsStyleBackground</name>;</struct_decl>
<struct_decl>struct <name>nsStyleBorder</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>nsIRunnable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>gfxUserFontSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsUserFontSet</name></decl>;</decl_stmt>
<struct_decl>struct <name>nsFontFaceRuleContainer</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>nsObjectFrame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsTransitionManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsRefreshDriver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>imgIContainer</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
<decl_stmt><decl><type><name>class</name></type> <name>nsIRenderingContext</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <name>nsWidgetType</name> <block>{
  <decl><name>eWidgetType_Button</name>  	<init>= <expr>1</expr></init></decl>,
  <decl><name>eWidgetType_Checkbox</name>	<init>= <expr>2</expr></init></decl>,
  <decl><name>eWidgetType_Radio</name>			<init>= <expr>3</expr></init></decl>,
  <decl><name>eWidgetType_Text</name>			<init>= <expr>4</expr></init></decl>
}</block>;</enum>

<enum>enum <name>nsLanguageSpecificTransformType</name> <block>{
  <decl><name>eLanguageSpecificTransformType_Unknown</name> <init>= <expr>-1</expr></init></decl>,
  <decl><name>eLanguageSpecificTransformType_None</name> <init>= <expr>0</expr></init></decl>,
  <decl><name>eLanguageSpecificTransformType_Japanese</name></decl>
}</block>;</enum>

<comment type="line">// supported values for cached bool types</comment>
<enum>enum <name>nsPresContext_CachedBoolPrefType</name> <block>{
  <decl><name>kPresContext_UseDocumentColors</name> <init>= <expr>1</expr></init></decl>,
  <decl><name>kPresContext_UseDocumentFonts</name></decl>,
  <decl><name>kPresContext_UnderlineLinks</name></decl>
}</block>;</enum>

<comment type="line">// supported values for cached integer pref types</comment>
<enum>enum <name>nsPresContext_CachedIntPrefType</name> <block>{
  <decl><name>kPresContext_MinimumFontSize</name> <init>= <expr>1</expr></init></decl>,
  <decl><name>kPresContext_ScrollbarSide</name></decl>,
  <decl><name>kPresContext_BidiDirection</name></decl>
}</block>;</enum>

<comment type="line">// IDs for the default variable and fixed fonts (not to be changed, see nsFont.h)</comment>
<comment type="line">// To be used for Get/SetDefaultFont(). The other IDs in nsFont.h are also supported.</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint8</name></type> <name>kPresContext_DefaultVariableFont_ID</name> <init>= <expr>0x00</expr></init></decl>;</decl_stmt> <comment type="line">// kGenericFont_moz_variable</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint8</name></type> <name>kPresContext_DefaultFixedFont_ID</name>    <init>= <expr>0x01</expr></init></decl>;</decl_stmt> <comment type="line">// kGenericFont_moz_fixed</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<struct_decl>struct <name>nsAutoLayoutPhase</name>;</struct_decl>

<enum>enum <name>nsLayoutPhase</name> <block>{
  <decl><name>eLayoutPhase_Paint</name></decl>,
  <decl><name>eLayoutPhase_Reflow</name></decl>,
  <decl><name>eLayoutPhase_FrameC</name></decl>,
  <decl><name>eLayoutPhase_COUNT</name></decl>
}</block>;</enum>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>class</name></type> <name>nsInvalidateRequestList</name> <block>{
<label><name>public</name>:</label>
  <struct>struct <name>Request</name> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type>   <name>mRect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>mFlags</name></decl>;</decl_stmt>
  }</block>;</struct>

  <expr_stmt><expr><name>nsTArray</name>&lt;<name>Request</name>&gt; <name>mRequests</name></expr>;</expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/* Used by nsPresContext::HasAuthorSpecifiedRules */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_AUTHOR_SPECIFIED_BACKGROUND</name></cpp:macro>      <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_AUTHOR_SPECIFIED_BORDER</name></cpp:macro>          <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_AUTHOR_SPECIFIED_PADDING</name></cpp:macro>         <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>nsRootPresContext</name></decl>;</decl_stmt>

<comment type="line">// An interface for presentation contexts. Presentation contexts are</comment>
<comment type="line">// objects that provide an outer context for a presentation shell.</comment>

<expr_stmt><expr><name>class</name> <name>nsPresContext</name> : <name>public</name> <name>nsIObserver</name> <block>{
<expr><name>public</name>:
  <name>NS_DECL_CYCLE_COLLECTING_ISUPPORTS</name>
  <name>NS_DECL_NSIOBSERVER</name>
  <name>NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW</name>
  <call><name>NS_DECL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument><expr><name>nsPresContext</name></expr></argument>)</argument_list></call>

  enum <name>nsPresContextType</name> <block>{
    <expr><name>eContext_Galley</name></expr>,       <comment type="line">// unpaginated screen presentation</comment>
    <expr><name>eContext_PrintPreview</name></expr>, <comment type="line">// paginated screen presentation</comment>
    <expr><name>eContext_Print</name></expr>,        <comment type="line">// paginated printer presentation</comment>
    <expr><name>eContext_PageLayout</name></expr>    <comment type="line">// paginated &amp; editable.</comment>
  }</block></expr>;

  <macro><name>nsPresContext</name><argument_list>(<argument>nsIDocument* aDocument</argument>, <argument>nsPresContextType aType</argument>)</argument_list></macro> <expr><name>NS_HIDDEN</name></expr>;

  <comment type="block">/**
   * Initialize the presentation context from a particular device.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>nsresult</argument>)</argument_list></macro> <expr><call><name>Init</name><argument_list>(<argument><expr><name>nsIDeviceContext</name>* <name>aDeviceContext</name></expr></argument>)</argument_list></call></expr>;

  <comment type="block">/**
   * Set the presentation shell that this context is bound to.
   * A presentation context may only be bound to a single shell.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>SetShell</name><argument_list>(<argument><expr><name>nsIPresShell</name>* <name>aShell</name></expr></argument>)</argument_list></call></expr>;


  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>nsPresContextType</argument>)</argument_list></macro> <macro><name>Type</name><argument_list>()</argument_list></macro> <expr>const <block>{ <return>return <expr><name>mType</name></expr>;</return></block></expr> }</block>

  <comment type="block">/**
   * Get the PresentationShell that this context is bound to.
   */</comment>
  <name>nsIPresShell</name>* <macro><name>PresShell</name><argument_list>()</argument_list></macro> const
  <block>{
    <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>, <argument><expr>"Null pres shell"</expr></argument>)</argument_list></call></expr>;
    <return>return <expr><name>mShell</name></expr>;</return>
  }</block></expr></expr_stmt>

  <expr_stmt><expr><name>nsIPresShell</name>* <macro><name>GetPresShell</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mShell</name></expr>;</return> }</block></expr></expr_stmt>

  <comment type="block">/**
   * Return the presentation context for the root of the view manager
   * hierarchy that contains this presentation context, or nsnull if it can't
   * be found (e.g. it's detached).
   */</comment>
  <function_decl><type><name>nsRootPresContext</name>*</type> <name>GetRootPresContext</name><parameter_list>()</parameter_list>;</function_decl>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>IsRoot</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>PR_FALSE</name></expr>;</return> }</block></function>

  <expr_stmt><expr><name>nsIDocument</name>* <macro><name>Document</name><argument_list>()</argument_list></macro> const
  <block>{
      <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mShell</name> || !<call><name><name>mShell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call> ||
                   <call><name><name>mShell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call> == <name>mDocument</name></expr></argument>,
                   <argument><expr>"nsPresContext doesn't have the same document as nsPresShell!"</expr></argument>)</argument_list></call></expr>;
      <return>return <expr><name>mDocument</name></expr>;</return>
  }</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_IMPL_NS_LAYOUT</name></cpp:ifdef>
  <function><type><name>nsStyleSet</name>*</type> <name>StyleSet</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>GetPresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>StyleSet</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

  <function><type><name>nsFrameManager</name>*</type> <name>FrameManager</name><parameter_list>()</parameter_list>
    <block>{ <return>return <expr><call><name>GetPresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call></expr>;</return> }</block></function> 

  <function><type><name>nsTransitionManager</name>*</type> <name>TransitionManager</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mTransitionManager</name></expr>;</return> }</block></function>

  <function><type><name>nsRefreshDriver</name>*</type> <name>RefreshDriver</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mRefreshDriver</name></expr>;</return> }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/**
   * Rebuilds all style data by throwing out the old rule tree and
   * building a new one, and additionally applying aExtraHint (which
   * must not contain nsChangeHint_ReconstructFrame) to the root frame.
   * Also rebuild the user font set.
   */</comment>
  <function_decl><type><name>void</name></type> <name>RebuildAllStyleData</name><parameter_list>(<param><decl><type><name>nsChangeHint</name></type> <name>aExtraHint</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * Just like RebuildAllStyleData, except (1) asynchronous and (2) it
   * doesn't rebuild the user font set.
   */</comment>
  <function_decl><type><name>void</name></type> <name>PostRebuildAllStyleDataEvent</name><parameter_list>(<param><decl><type><name>nsChangeHint</name></type> <name>aExtraHint</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>MediaFeatureValuesChanged</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCallerWillRebuildStyleData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>PostMediaFeatureValuesChangedEvent</name><parameter_list>()</parameter_list>;</function_decl>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>HandleMediaFeatureValuesChangedEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <function><type><name>void</name></type> <name>FlushPendingMediaFeatureValuesChanged</name><parameter_list>()</parameter_list> <block>{
    <if>if <condition>(<expr><name>mPendingMediaFeatureValuesChanged</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>MediaFeatureValuesChanged</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></function>

  <comment type="block">/**
   * Access compatibility mode for this context.  This is the same as
   * our document's compatibility mode.
   */</comment>
  <expr_stmt><expr><name>nsCompatibility</name> <macro><name>CompatibilityMode</name><argument_list>()</argument_list></macro> const <block>{
    <return>return <expr><call><name>Document</name><argument_list>()</argument_list></call>-&gt;<call><name>GetCompatibilityMode</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></expr></expr_stmt>
  <comment type="block">/**
   * Notify the context that the document's compatibility mode has changed
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>CompatibilityModeChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Access the image animation mode for this context
   */</comment>
  <expr_stmt><expr><name>PRUint16</name>     <macro><name>ImageAnimationMode</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mImageAnimationMode</name></expr>;</return> }</block></expr></expr_stmt>
  <function_decl><type><name>virtual</name></type> <name>NS_HIDDEN_</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> SetImageAnimationModeExternal<parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>aMode</name></decl></param>)</parameter_list>;</function_decl>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetImageAnimationModeInternal</name><argument_list>(<argument>PRUint16 aMode</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_IMPL_NS_LAYOUT</name></cpp:ifdef>
  <function><type><name>void</name></type> <name>SetImageAnimationMode</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>aMode</name></decl></param>)</parameter_list>
  <block>{ <expr_stmt><expr><call><name>SetImageAnimationModeInternal</name><argument_list>(<argument><expr><name>aMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <function><type><name>void</name></type> <name>SetImageAnimationMode</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>aMode</name></decl></param>)</parameter_list>
  <block>{ <expr_stmt><expr><call><name>SetImageAnimationModeExternal</name><argument_list>(<argument><expr><name>aMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/**
   * Get cached look and feel service.  This is faster than obtaining it
   * through the service manager.
   */</comment>
  <function><type><name>nsILookAndFeel</name>*</type> <name>LookAndFeel</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mLookAndFeel</name></expr>;</return> }</block></function>

  <comment type="block">/** 
   * Get medium of presentation
   */</comment>
  <function><type><name>nsIAtom</name>*</type> <name>Medium</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mMedium</name></expr>;</return> }</block></function>

  <function><type><name>void</name>*</type> <name>AllocateFromShell</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mShell</name></expr>)</condition><then>
      <return>return <expr><call><name><name>mShell</name>-&gt;<name>AllocateMisc</name></name><argument_list>(<argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></function>

  <function><type><name>void</name></type> <name>FreeToShell</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aFreeChunk</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>, <argument><expr>"freeing after shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mShell</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mShell</name>-&gt;<name>FreeMisc</name></name><argument_list>(<argument><expr><name>aSize</name></expr></argument>, <argument><expr><name>aFreeChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></function>

  <comment type="block">/**
   * Get the font metrics for a given font.
   *
   * If aUseUserFontSet is false, don't build or use the user font set.
   * This is intended only for nsRuleNode::CalcLengthWithInitialFont
   * (which is used from media query matching, which is in turn called
   * when building the user font set).
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>already_AddRefed&lt;nsIFontMetrics&gt;</argument>)</argument_list></macro>
  <macro><name>GetMetricsFor</name><argument_list>(<argument>const nsFont&amp; aFont</argument>, <argument>PRBool aUseUserFontSet = PR_TRUE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * Get the default font corresponding to the given ID.  This object is
   * read-only, you must copy the font to modify it.
   * 
   * When aFontID is kPresContext_DefaultVariableFontID or
   * kPresContext_DefaultFixedFontID (which equals
   * kGenericFont_moz_fixed, which is used for the -moz-fixed generic),
   * the nsFont returned has its name as a CSS generic family (serif or
   * sans-serif for the former, monospace for the latter), and its size
   * as the default font size for variable or fixed fonts for the pres
   * context's language group.
   *
   * For aFontID corresponds to a CSS Generic, the nsFont returned has
   * its name as the name or names of the fonts in the user's
   * preferences for the given generic and the pres context's language
   * group, and its size set to the default variable font size.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>const nsFont*</argument>)</argument_list></macro> <macro><name>GetDefaultFont</name><argument_list>(<argument>PRUint8 aFontID</argument>)</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>

  <comment type="block">/** Get a cached boolean pref, by its type */</comment>
  <comment type="line">// *  - initially created for bugs 31816, 20760, 22963</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>GetCachedBoolPref</name><argument_list>(<argument><expr><name>nsPresContext_CachedBoolPrefType</name> <name>aPrefType</name></expr></argument>)</argument_list> const
  <block>{
    <comment type="line">// If called with a constant parameter, the compiler should optimize</comment>
    <comment type="line">// this switch statement away.</comment>
    <switch>switch <condition>(<expr><name>aPrefType</name></expr>)</condition> <block>{
    <case>case <expr><name>kPresContext_UseDocumentFonts</name></expr>:
      <return>return <expr><name>mUseDocumentFonts</name></expr>;</return>
    </case><case>case <expr><name>kPresContext_UseDocumentColors</name></expr>:
      <return>return <expr><name>mUseDocumentColors</name></expr>;</return>
    </case><case>case <expr><name>kPresContext_UnderlineLinks</name></expr>:
      <return>return <expr><name>mUnderlineLinks</name></expr>;</return>
    </case><default>default:
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Invalid arg passed to GetCachedBoolPref"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>

    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></decl></decl_stmt>

  <comment type="block">/** Get a cached integer pref, by its type */</comment>
  <comment type="line">// *  - initially created for bugs 30910, 61883, 74186, 84398</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>GetCachedIntPref</name><argument_list>(<argument><expr><name>nsPresContext_CachedIntPrefType</name> <name>aPrefType</name></expr></argument>)</argument_list> const
  <block>{
    <comment type="line">// If called with a constant parameter, the compiler should optimize</comment>
    <comment type="line">// this switch statement away.</comment>
    <switch>switch <condition>(<expr><name>aPrefType</name></expr>)</condition> <block>{
    <case>case <expr><name>kPresContext_MinimumFontSize</name></expr>:
      <return>return <expr><name>mMinimumFontSize</name></expr>;</return>
    </case><case>case <expr><name>kPresContext_ScrollbarSide</name></expr>:
      <return>return <expr><name>mPrefScrollbarSide</name></expr>;</return>
    </case><case>case <expr><name>kPresContext_BidiDirection</name></expr>:
      <return>return <expr><name>mPrefBidiDirection</name></expr>;</return>
    </case><default>default:
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"invalid arg passed to GetCachedIntPref"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>

    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></decl></decl_stmt>

  <comment type="block">/**
   * Access Nav's magic font scaler value
   */</comment>
  <expr_stmt><expr><name>PRInt32</name> <macro><name>FontScaler</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFontScaler</name></expr>;</return> }</block></expr></expr_stmt>

  <comment type="block">/** 
   * Get the default colors
   */</comment>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>DefaultColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mDefaultColor</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>DefaultBackgroundColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mBackgroundColor</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>DefaultLinkColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mLinkColor</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>DefaultActiveLinkColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mActiveLinkColor</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>DefaultVisitedLinkColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mVisitedLinkColor</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>FocusBackgroundColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFocusBackgroundColor</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr>const <name>nscolor</name> <macro><name>FocusTextColor</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFocusTextColor</name></expr>;</return> }</block></expr></expr_stmt>

  <expr_stmt><expr><name>PRBool</name> <macro><name>GetUseFocusColors</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mUseFocusColors</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRUint8</name> <macro><name>FocusRingWidth</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFocusRingWidth</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRBool</name> <macro><name>GetFocusRingOnAnything</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFocusRingOnAnything</name></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRUint8</name> <macro><name>GetFocusRingStyle</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mFocusRingStyle</name></expr>;</return> }</block></expr></expr_stmt>

  <comment type="block">/**
   * The types of image load types that the pres context needs image
   * loaders to track invalidation for.
   */</comment>
  <enum>enum <name>ImageLoadType</name> <block>{
    <decl><name>BACKGROUND_IMAGE</name></decl>,
    <decl><name>BORDER_IMAGE</name></decl>,
    <decl><name>IMAGE_LOAD_TYPE_COUNT</name></decl>
  }</block>;</enum>

  <comment type="block">/**
   * Set the list of image loaders that track invalidation for a
   * specific frame and type of image.  This list will replace any
   * previous list for that frame and image type (and null will remove
   * any previous list).
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetImageLoaders</name><argument_list>(<argument>nsIFrame* aTargetFrame</argument>,
                                   <argument>ImageLoadType aType</argument>,
                                   <argument>nsImageLoader* aImageLoaders</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * Make an appropriate SetImageLoaders call (including potentially
   * with null aImageLoaders) given that aFrame draws its background
   * based on aStyleBackground.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SetupBackgroundImageLoaders</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>,
                                               <argument><expr>const <name>nsStyleBackground</name>*
                                                 <name>aStyleBackground</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Make an appropriate SetImageLoaders call (including potentially
   * with null aImageLoaders) given that aFrame draws its border
   * based on aStyleBorder.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SetupBorderImageLoaders</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aFrame</name></expr></argument>,
                                           <argument><expr>const <name>nsStyleBorder</name>* <name>aStyleBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * This method is called when a frame is being destroyed to
   * ensure that the image loads get disassociated from the prescontext
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>StopImagesFor</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aTargetFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SetContainer</name><argument_list>(<argument><expr><name>nsISupports</name>* <name>aContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>virtual</name></type> <name>NS_HIDDEN_</name><argument_list>(<argument><expr><name>already_AddRefed</name>&lt;<name>nsISupports</name>&gt;</expr></argument>)</argument_list> <name>GetContainerExternal</name><argument_list>()</argument_list> const</decl>;</decl_stmt>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>already_AddRefed&lt;nsISupports&gt;</argument>)</argument_list></macro> <macro><name>GetContainerInternal</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_IMPL_NS_LAYOUT</name></cpp:ifdef>
  <expr_stmt><expr><name>already_AddRefed</name>&lt;<name>nsISupports</name>&gt; <macro><name>GetContainer</name><argument_list>()</argument_list></macro> const
  <block>{ <return>return <expr><call><name>GetContainerInternal</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>already_AddRefed</name>&lt;<name>nsISupports</name>&gt; <macro><name>GetContainer</name><argument_list>()</argument_list></macro> const
  <block>{ <return>return <expr><call><name>GetContainerExternal</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// XXX this are going to be replaced with set/get container</comment>
  <function><type><name>void</name></type> <name>SetLinkHandler</name><parameter_list>(<param><decl><type><name>nsILinkHandler</name>*</type> <name>aHandler</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mLinkHandler</name> = <name>aHandler</name></expr>;</expr_stmt> }</block></function>
  <function><type><name>nsILinkHandler</name>*</type> <name>GetLinkHandler</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mLinkHandler</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * Get the visible area associated with this presentation context.
   * This is the size of the visible area that is used for
   * presenting the document. The returned value is in the standard
   * nscoord units (as scaled by the device context).
   */</comment>
  <function><type><name>nsRect</name></type> <name>GetVisibleArea</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mVisibleArea</name></expr>;</return> }</block></function>

  <comment type="block">/**
   * Set the currently visible area. The units for r are standard
   * nscoord units (as scaled by the device context).
   */</comment>
  <function><type><name>void</name></type> <name>SetVisibleArea</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>r</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr>!<call><name><name>r</name>.<name>IsExactEqual</name></name><argument_list>(<argument><expr><name>mVisibleArea</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mVisibleArea</name> = <name>r</name></expr>;</expr_stmt>
      <comment type="line">// Visible area does not affect media queries when paginated.</comment>
      <if>if <condition>(<expr>!<call><name>IsPaginated</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>HasCachedStyleData</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>PostMediaFeatureValuesChangedEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
  }</block></function>

  <comment type="block">/**
   * Return true if this presentation context is a paginated
   * context.
   */</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsPaginated</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mPaginated</name></expr>;</return> }</block></expr></expr_stmt>
  
  <comment type="block">/**
   * Sets whether the presentation context can scroll for a paginated
   * context.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetPaginatedScrolling</name><argument_list>(<argument>PRBool aResult</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * Return true if this presentation context can scroll for paginated
   * context.
   */</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>HasPaginatedScrolling</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mCanPaginatedScroll</name></expr>;</return> }</block></expr></expr_stmt>

  <comment type="block">/**
   * Get/set the size of a page
   */</comment>
  <function><type><name>nsSize</name></type> <name>GetPageSize</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mPageSize</name></expr>;</return> }</block></function>
  <function><type><name>void</name></type> <name>SetPageSize</name><parameter_list>(<param><decl><type><name>nsSize</name></type> <name>aSize</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mPageSize</name> = <name>aSize</name></expr>;</expr_stmt> }</block></function>

  <comment type="block">/**
   * Get/set whether this document should be treated as having real pages
   * XXX This raises the obvious question of why a document that isn't a page
   *     is paginated; there isn't a good reason except history
   */</comment>
  <function><type><name>PRBool</name></type> <name>IsRootPaginatedDocument</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIsRootPaginatedDocument</name></expr>;</return> }</block></function>
  <function><type><name>void</name></type> <name>SetIsRootPaginatedDocument</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIsRootPaginatedDocument</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><name>mIsRootPaginatedDocument</name> = <name>aIsRootPaginatedDocument</name></expr>;</expr_stmt> }</block></function>

  <comment type="block">/**
  * Get/set the print scaling level; used by nsPageFrame to scale up
  * pages.  Set safe to call before reflow, get guaranteed to be set
  * properly after reflow.
  */</comment>

  <function><type><name>float</name></type> <name>GetPageScale</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mPageScale</name></expr>;</return> }</block></function>
  <function><type><name>void</name></type> <name>SetPageScale</name><parameter_list>(<param><decl><type><name>float</name></type> <name>aScale</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mPageScale</name> = <name>aScale</name></expr>;</expr_stmt> }</block></function>

  <comment type="block">/**
  * Get/set the scaling facor to use when rendering the pages for print preview.
  * Only safe to get after print preview set up; safe to set anytime.
  * This is a scaling factor for the display of the print preview.  It
  * does not affect layout.  It only affects the size of the onscreen pages
  * in print preview.
  * XXX Temporary: see http://wiki.mozilla.org/Gecko:PrintPreview
  */</comment>
  <function><type><name>float</name></type> <name>GetPrintPreviewScale</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mPPScale</name></expr>;</return> }</block></function>
  <function><type><name>void</name></type> <name>SetPrintPreviewScale</name><parameter_list>(<param><decl><type><name>float</name></type> <name>aScale</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>mPPScale</name> = <name>aScale</name></expr>;</expr_stmt> }</block></function>

  <function><type><name>nsIDeviceContext</name>*</type> <name>DeviceContext</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mDeviceContext</name></expr>;</return> }</block></function>
  <function><type><name>nsIEventStateManager</name>*</type> <name>EventStateManager</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mEventManager</name></expr>;</return> }</block></function>
  <function><type><name>nsIAtom</name>*</type> <name>GetLangGroup</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mLangGroup</name></expr>;</return> }</block></function>

  <function><type><name>float</name></type> <name>TextZoom</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mTextZoom</name></expr>;</return> }</block></function>
  <function><type><name>void</name></type> <name>SetTextZoom</name><parameter_list>(<param><decl><type><name>float</name></type> <name>aZoom</name></decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>aZoom</name> == <name>mTextZoom</name></expr>)</condition><then>
      <return>return;</return></then></if>

    <expr_stmt><expr><name>mTextZoom</name> = <name>aZoom</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>HasCachedStyleData</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Media queries could have changed since we changed the meaning</comment>
      <comment type="line">// of 'em' units in them.</comment>
      <expr_stmt><expr><call><name>MediaFeatureValuesChanged</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RebuildAllStyleData</name><argument_list>(<argument><expr><name>NS_STYLE_HINT_REFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></function>

  <function><type><name>float</name></type> <name>GetFullZoom</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mFullZoom</name></expr>;</return> }</block></function>
  <function_decl><type><name>void</name></type> <name>SetFullZoom</name><parameter_list>(<param><decl><type><name>float</name></type> <name>aZoom</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>nscoord</name></type> <name>GetAutoQualityMinFontSize</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><call><name>DevPixelsToAppUnits</name><argument_list>(<argument><expr><name>mAutoQualityMinFontSizePixelsPref</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
  
  <function><type><specifier>static</specifier> <name>PRInt32</name></type> <name>AppUnitsPerCSSPixel</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>nsIDeviceContext</name>::<call><name>AppUnitsPerCSSPixel</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
  <expr_stmt><expr><name>PRInt32</name> <macro><name>AppUnitsPerDevPixel</name><argument_list>()</argument_list></macro> const  <block>{ <return>return <expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
  <expr_stmt><expr><name>PRInt32</name> <macro><name>AppUnitsPerInch</name><argument_list>()</argument_list></macro> const      <block>{ <return>return <expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerInch</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

  <function><type><specifier>static</specifier> <name>nscoord</name></type> <name>CSSPixelsToAppUnits</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aPixels</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>NSIntPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>,
                                 <argument><expr><name>nsIDeviceContext</name>::<call><name>AppUnitsPerCSSPixel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <function><type><specifier>static</specifier> <name>nscoord</name></type> <name>CSSPixelsToAppUnits</name><parameter_list>(<param><decl><type><name>float</name></type> <name>aPixels</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>,
             <argument><expr><call><name>float</name><argument_list>(<argument><expr><name>nsIDeviceContext</name>::<call><name>AppUnitsPerCSSPixel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <function><type><specifier>static</specifier> <name>PRInt32</name></type> <name>AppUnitsToIntCSSPixels</name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aAppUnits</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>NSAppUnitsToIntPixels</name><argument_list>(<argument><expr><name>aAppUnits</name></expr></argument>,
             <argument><expr><call><name>float</name><argument_list>(<argument><expr><name>nsIDeviceContext</name>::<call><name>AppUnitsPerCSSPixel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <function><type><specifier>static</specifier> <name>float</name></type> <name>AppUnitsToFloatCSSPixels</name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aAppUnits</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name>aAppUnits</name></expr></argument>,
             <argument><expr><call><name>float</name><argument_list>(<argument><expr><name>nsIDeviceContext</name>::<call><name>AppUnitsPerCSSPixel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>DevPixelsToAppUnits</name><argument_list>(<argument><expr><name>PRInt32</name> <name>aPixels</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>NSIntPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>,
                                 <argument><expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>AppUnitsToDevPixels</name><argument_list>(<argument><expr><name>nscoord</name> <name>aAppUnits</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>NSAppUnitsToIntPixels</name><argument_list>(<argument><expr><name>aAppUnits</name></expr></argument>,
             <argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <function><type><name>PRInt32</name></type> <name>CSSPixelsToDevPixels</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aPixels</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>AppUnitsToDevPixels</name><argument_list>(<argument><expr><call><name>CSSPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <function><type><name>float</name></type> <name>CSSPixelsToDevPixels</name><parameter_list>(<param><decl><type><name>float</name></type> <name>aPixels</name></decl></param>)</parameter_list>
  <block>{
    <return>return <expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><call><name>CSSPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerDevPixel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><name>PRInt32</name></type> <name>DevPixelsToIntCSSPixels</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aPixels</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>AppUnitsToIntCSSPixels</name><argument_list>(<argument><expr><call><name>DevPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <function><type><name>float</name></type> <name>DevPixelsToFloatCSSPixels</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aPixels</name></decl></param>)</parameter_list>
  <block>{ <return>return <expr><call><name>AppUnitsToFloatCSSPixels</name><argument_list>(<argument><expr><call><name>DevPixelsToAppUnits</name><argument_list>(<argument><expr><name>aPixels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

  <comment type="line">// If there is a remainder, it is rounded to nearest app units.</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>GfxUnitsToAppUnits</name><argument_list>(<argument><expr><name>gfxFloat</name> <name>aGfxUnits</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name><name>mDeviceContext</name>-&gt;<name>GfxUnitsToAppUnits</name></name><argument_list>(<argument><expr><name>aGfxUnits</name></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <decl_stmt><decl><type><name>gfxFloat</name></type> <name>AppUnitsToGfxUnits</name><argument_list>(<argument><expr><name>nscoord</name> <name>aAppUnits</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsToGfxUnits</name></name><argument_list>(<argument><expr><name>aAppUnits</name></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <decl_stmt><decl><type><name>gfxRect</name></type> <name>AppUnitsToGfxUnits</name><argument_list>(<argument><expr>const <name>nsRect</name>&amp; <name>aAppRect</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>gfxRect</name><argument_list>(<argument><expr><call><name>AppUnitsToGfxUnits</name><argument_list>(<argument><expr><name><name>aAppRect</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>AppUnitsToGfxUnits</name><argument_list>(<argument><expr><name><name>aAppRect</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>AppUnitsToGfxUnits</name><argument_list>(<argument><expr><name><name>aAppRect</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>AppUnitsToGfxUnits</name><argument_list>(<argument><expr><name><name>aAppRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>TwipsToAppUnits</name><argument_list>(<argument><expr><name>PRInt32</name> <name>aTwips</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>NSCoordSaturatingMultiply</name><argument_list>(<argument><expr><call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerInch</name></name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>NS_TWIPS_TO_INCHES</name><argument_list>(<argument><expr><name>aTwips</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <comment type="line">// Margin-specific version, since they often need TwipsToAppUnits</comment>
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>TwipsToAppUnits</name><argument_list>(<argument><expr>const <name>nsIntMargin</name> &amp;<name>marginInTwips</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>nsMargin</name><argument_list>(<argument><expr><call><name>TwipsToAppUnits</name><argument_list>(<argument><expr><name><name>marginInTwips</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></argument>, 
                    <argument><expr><call><name>TwipsToAppUnits</name><argument_list>(<argument><expr><name><name>marginInTwips</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>TwipsToAppUnits</name><argument_list>(<argument><expr><name><name>marginInTwips</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>TwipsToAppUnits</name><argument_list>(<argument><expr><name><name>marginInTwips</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>PointsToAppUnits</name><argument_list>(<argument><expr><name>float</name> <name>aPoints</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>NSToCoordRound</name><argument_list>(<argument><expr><name>aPoints</name> * <call><name><name>mDeviceContext</name>-&gt;<name>AppUnitsPerInch</name></name><argument_list>()</argument_list></call> /
                          <name>POINTS_PER_INCH_FLOAT</name></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>RoundAppUnitsToNearestDevPixels</name><argument_list>(<argument><expr><name>nscoord</name> <name>aAppUnits</name></expr></argument>)</argument_list> const
  <block>{ <return>return <expr><call><name>DevPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>AppUnitsToDevPixels</name><argument_list>(<argument><expr><name>aAppUnits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></decl></decl_stmt>

  <struct>struct <name>ScrollbarStyles</name> <block>{
    <comment type="line">// Always one of NS_STYLE_OVERFLOW_SCROLL, NS_STYLE_OVERFLOW_HIDDEN,</comment>
    <comment type="line">// or NS_STYLE_OVERFLOW_AUTO.</comment>
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>mHorizontal</name></decl>, <decl><type ref="prev"/><name>mVertical</name></decl>;</decl_stmt>
    <macro><name>ScrollbarStyles</name><argument_list>(<argument>PRUint8 h</argument>, <argument>PRUint8 v</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>mHorizontal</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>, <macro><name>mVertical</name><argument_list>(<argument>v</argument>)</argument_list></macro> <expr><block>{}</block>
    <macro><name>ScrollbarStyles</name><argument_list>()</argument_list></macro> <block>{}</block>
    <name>PRBool</name> <name>operator</name>==(const <name>ScrollbarStyles</name>&amp; <name>aStyles</name>) const <block>{
      <return>return <expr><name><name>aStyles</name>.<name>mHorizontal</name></name> == <name>mHorizontal</name> &amp;&amp; <name><name>aStyles</name>.<name>mVertical</name></name> == <name>mVertical</name></expr>;</return>
    }</block></expr></expr_stmt>
    <expr_stmt><expr><name>PRBool</name> <name>operator</name>!=(const <name>ScrollbarStyles</name>&amp; <name>aStyles</name>) const <block>{
      <return>return <expr><name><name>aStyles</name>.<name>mHorizontal</name></name> != <name>mHorizontal</name> || <name><name>aStyles</name>.<name>mVertical</name></name> != <name>mVertical</name></expr>;</return>
    }</block></expr></expr_stmt>
  }</block>;</struct>
  <function><type><name>void</name></type> <name>SetViewportOverflowOverride</name><parameter_list>(<param><decl><type><name>PRUint8</name></type> <name>aX</name></decl></param>, <param><decl><type><name>PRUint8</name></type> <name>aY</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name><name>mViewportStyleOverflow</name>.<name>mHorizontal</name></name> = <name>aX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mViewportStyleOverflow</name>.<name>mVertical</name></name> = <name>aY</name></expr>;</expr_stmt>
  }</block></function>
  <function><type><name>ScrollbarStyles</name></type> <name>GetViewportOverflowOverride</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><name>mViewportStyleOverflow</name></expr>;</return>
  }</block></function>

  <comment type="block">/**
   * Set and get methods for controlling the background drawing
  */</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>GetBackgroundImageDraw</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mDrawImageBackground</name></expr>;</return> }</block></expr></expr_stmt>
  <function><type><name>void</name></type>   <name>SetBackgroundImageDraw</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCanDraw</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>aCanDraw</name> &amp; ~1)</expr></argument>, <argument><expr>"Value must be true or false"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mDrawImageBackground</name> = <name>aCanDraw</name></expr>;</expr_stmt>
  }</block></function>

  <expr_stmt><expr><name>PRBool</name> <macro><name>GetBackgroundColorDraw</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mDrawColorBackground</name></expr>;</return> }</block></expr></expr_stmt>
  <function><type><name>void</name></type>   <name>SetBackgroundColorDraw</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCanDraw</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>aCanDraw</name> &amp; ~1)</expr></argument>, <argument><expr>"Value must be true or false"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mDrawColorBackground</name> = <name>aCanDraw</name></expr>;</expr_stmt>
  }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  <comment type="block">/**
   *  Check if bidi enabled (set depending on the presence of RTL
   *  characters or when default directionality is RTL).
   *  If enabled, we should apply the Unicode Bidi Algorithm
   *
   *  @lina 07/12/2000
   */</comment>
  <decl_stmt><decl><type><name>virtual</name></type> <name>NS_HIDDEN_</name><argument_list>(<argument><expr><name>PRBool</name></expr></argument>)</argument_list> <name>BidiEnabledExternal</name><argument_list>()</argument_list> const</decl>;</decl_stmt>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro> <macro><name>BidiEnabledInternal</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_IMPL_NS_LAYOUT</name></cpp:ifdef>
  <expr_stmt><expr><name>PRBool</name> <macro><name>BidiEnabled</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name>BidiEnabledInternal</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>PRBool</name> <macro><name>BidiEnabled</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name>BidiEnabledExternal</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/**
   *  Set bidi enabled. This means we should apply the Unicode Bidi Algorithm
   *
   *  @lina 07/12/2000
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetBidiEnabled</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>

  <comment type="block">/**
   *  Set visual or implicit mode into the pres context.
   *
   *  Visual directionality is a presentation method that displays text
   *  as if it were a uni-directional, according to the primary display
   *  direction only. 
   *
   *  Implicit directionality is a presentation method in which the
   *  direction is determined by the Bidi algorithm according to the
   *  category of the characters and the category of the adjacent
   *  characters, and according to their primary direction.
   *
   *  @lina 05/02/2000
   */</comment>
  <function><type><name>void</name></type> <name>SetVisualMode</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIsVisual</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>aIsVisual</name> &amp; ~1)</expr></argument>, <argument><expr>"Value must be true or false"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIsVisual</name> = <name>aIsVisual</name></expr>;</expr_stmt>
  }</block></function>

  <comment type="block">/**
   *  Check whether the content should be treated as visual.
   *
   *  @lina 05/02/2000
   */</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsVisualMode</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mIsVisual</name></expr>;</return> }</block></expr></expr_stmt>

<comment type="line">//Mohamed</comment>

  <comment type="block">/**
   * Get a Bidi presentation utilities object
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>nsBidiPresUtils*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>GetBidiUtils</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/**
   * Set the Bidi options for the presentation context
   */</comment>  
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetBidi</name><argument_list>(<argument>PRUint32 aBidiOptions</argument>,
                           <argument>PRBool aForceRestyle = PR_FALSE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/**
   * Get the Bidi options for the presentation context
   * Not inline so consumers of nsPresContext are not forced to
   * include nsIDocument.
   */</comment>  
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>PRUint32</argument>)</argument_list></macro> <macro><name>GetBidi</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>

  <comment type="block">/**
   * Render only Selection
   */</comment>
  <function><type><name>void</name></type> <name>SetIsRenderingOnlySelection</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aResult</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>aResult</name> &amp; ~1)</expr></argument>, <argument><expr>"Value must be true or false"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIsRenderingOnlySelection</name> = <name>aResult</name></expr>;</expr_stmt>
  }</block></function>

  <expr_stmt><expr><name>PRBool</name> <macro><name>IsRenderingOnlySelection</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mIsRenderingOnlySelection</name></expr>;</return> }</block></expr></expr_stmt>

  <comment type="block">/*
   * Obtain a native them for rendering our widgets (both form controls and html)
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>nsITheme*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>GetTheme</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Notify the pres context that the theme has changed.  An internal switch
   * means it's one of our Mozilla themes that changed (e.g., Modern to Classic).
   * Otherwise, the OS is telling us that the native theme for the platform
   * has changed.
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ThemeChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * Notify the pres context that a system color has changed
   */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SysColorChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/** Printing methods below should only be used for Medium() == print **/</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SetPrintSettings</name><argument_list>(<argument><expr><name>nsIPrintSettings</name> *<name>aPrintSettings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function><type><name>nsIPrintSettings</name>*</type> <name>GetPrintSettings</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mPrintSettings</name></expr>;</return> }</block></function>

  <comment type="block">/* Accessor for table of frame properties */</comment>
  <function><type><name>nsPropertyTable</name>*</type> <name>PropertyTable</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>&amp;<name>mPropertyTable</name></expr>;</return> }</block></function>

  <comment type="block">/* Helper function that ensures that this prescontext is shown in its
     docshell if it's the most recent prescontext for the docshell.  Returns
     whether the prescontext is now being shown.
  */</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro> <expr_stmt><expr><call><name>EnsureVisible</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>CountReflows</name><argument_list>(<argument><expr>const <name>char</name> * <name>aName</name></expr></argument>,
                                <argument><expr><name>nsIFrame</name> * <name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/**
   * This table maps border-width enums 'thin', 'medium', 'thick'
   * to actual nscoord values.
   */</comment>
  <function><type><specifier>const</specifier> <name>nscoord</name>*</type> <name>GetBorderWidthTable</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mBorderWidthTable</name></expr>;</return> }</block></function>

  <function><type><name>PRBool</name></type> <name>IsDynamic</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>mType</name> == <name>eContext_PageLayout</name> || <name>mType</name> == <name>eContext_Galley</name>)</expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type> <name>IsScreen</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>mMedium</name> == <name>nsGkAtoms</name>::<name>screen</name> ||
                              <name>mType</name> == <name>eContext_PageLayout</name> ||
                              <name>mType</name> == <name>eContext_PrintPreview</name>)</expr>;</return> }</block></function>

  <comment type="line">// Is this presentation in a chrome docshell?</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsChrome</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

  <comment type="line">// Public API for native theme code to get style internals.</comment>
  <decl_stmt><decl><type><name>virtual</name> <name>PRBool</name></type> <name>HasAuthorSpecifiedRules</name><argument_list>(<argument><expr><name>nsIFrame</name> *<name>aFrame</name></expr></argument>, <argument><expr><name>PRUint32</name> <name>ruleTypeMask</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

  <comment type="line">// Is it OK to let the page specify colors and backgrounds?</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>UseDocumentColors</name><argument_list>()</argument_list></macro> const <block>{
    <return>return <expr><call><name>GetCachedBoolPref</name><argument_list>(<argument><expr><name>kPresContext_UseDocumentColors</name></expr></argument>)</argument_list></call> || <call><name>IsChrome</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></expr></expr_stmt>

  <expr_stmt><expr><name>PRBool</name>           <macro><name>SupressingResizeReflow</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>mSupressResizeReflow</name></expr>;</return> }</block></expr></expr_stmt>
  
  <function_decl><type><name>virtual</name></type> <name>NS_HIDDEN_</name><parameter_list>(<param><decl><type><name>gfxUserFontSet</name>*</type></decl></param>)</parameter_list> GetUserFontSetExternal<parameter_list>()</parameter_list>;</function_decl>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>gfxUserFontSet*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>GetUserFontSetInternal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_IMPL_NS_LAYOUT</name></cpp:ifdef>
  <function><type><name>gfxUserFontSet</name>*</type> <name>GetUserFontSet</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>GetUserFontSetInternal</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <function><type><name>gfxUserFontSet</name>*</type> <name>GetUserFontSet</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>GetUserFontSetExternal</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function_decl><type><name>void</name></type> <name>FlushUserFontSet</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>RebuildUserFontSet</name><parameter_list>()</parameter_list>;</function_decl> <comment type="line">// asynchronously</comment>

  <comment type="line">// Should be called whenever the set of fonts available in the user</comment>
  <comment type="line">// font set changes (e.g., because a new font loads, or because the</comment>
  <comment type="line">// user font set is changed and fonts become unavailable).</comment>
  <function_decl><type><name>void</name></type> <name>UserFontSetUpdated</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Ensure that it is safe to hand out CSS rules outside the layout</comment>
  <comment type="line">// engine by ensuring that all CSS style sheets have unique inners</comment>
  <comment type="line">// and, if necessary, synchronously rebuilding all style data.</comment>
  <comment type="line">// Returns true on success and false on failure (not safe).</comment>
  <function_decl><type><name>PRBool</name></type> <name>EnsureSafeToHandOutCSSRules</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>NotifyInvalidation</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>NotifyInvalidateForScrolling</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aBlitRegion</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aInvalidateRegion</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>FireDOMPaintEvent</name><parameter_list>()</parameter_list>;</function_decl>
  <function><type><name>PRBool</name></type> <name>IsDOMPaintEventPending</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr>!<call><name><name>mInvalidateRequests</name>.<name>mRequests</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><name>void</name></type> <name>ClearMozAfterPaintEvents</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name><name>mInvalidateRequests</name>.<name>mRequests</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <expr_stmt><expr><name>PRBool</name> <macro><name>IsProcessingAnimationStyleChange</name><argument_list>()</argument_list></macro> const <block>{
    <return>return <expr><name>mProcessingAnimationStyleChange</name></expr>;</return>
  }</block></expr></expr_stmt>

  <function><type><name>void</name></type> <name>SetProcessingAnimationStyleChange</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aProcessing</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aProcessing</name> != <call><name>PRBool</name><argument_list>(<argument><expr><name>mProcessingAnimationStyleChange</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"should never nest"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProcessingAnimationStyleChange</name> = <name>aProcessing</name></expr>;</expr_stmt>
  }</block></function>

  <comment type="block">/**
   * Notify the prescontext that the presshell is about to reflow a reflow root.
   * The single argument indicates whether this reflow should be interruptible.
   * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
   * will always return false. If aInterruptible is true then CheckForInterrupt
   * will return true when a pending event is detected.  This is for use by the
   * presshell only.  Reflow code wanting to prevent interrupts should use
   * InterruptPreventer.
   */</comment>
  <function_decl><type><name>void</name></type> <name>ReflowStarted</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInterruptible</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/**
   * A class that can be used to temporarily disable reflow interruption.
   */</comment>
  <decl_stmt><decl><type><name>class</name></type> <name>InterruptPreventer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>InterruptPreventer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>class</name> <name>NS_STACK_CLASS</name></type> <name>InterruptPreventer</name> <block>{
  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>InterruptPreventer</name><argument_list>(<argument><expr><name>nsPresContext</name>* <name>aCtx</name></expr></argument>)</argument_list></call> :
      <call><name>mCtx</name><argument_list>(<argument><expr><name>aCtx</name></expr></argument>)</argument_list></call></expr>,
      <expr><call><name>mInterruptsEnabled</name><argument_list>(<argument><expr><name><name>aCtx</name>-&gt;<name>mInterruptsEnabled</name></name></expr></argument>)</argument_list></call></expr>,
      <macro><name>mHasPendingInterrupt</name><argument_list>(<argument>aCtx-&gt;mHasPendingInterrupt</argument>)</argument_list></macro>
    <expr><block>{
      <expr><name><name>mCtx</name>-&gt;<name>mInterruptsEnabled</name></name> = <name>PR_FALSE</name></expr>;
      <expr><name><name>mCtx</name>-&gt;<name>mHasPendingInterrupt</name></name> = <name>PR_FALSE</name></expr>;
    }</block>
    ~<macro><name>InterruptPreventer</name><argument_list>()</argument_list></macro> <block>{
      <expr><name><name>mCtx</name>-&gt;<name>mInterruptsEnabled</name></name> = <name>mInterruptsEnabled</name></expr>;
      <expr><name><name>mCtx</name>-&gt;<name>mHasPendingInterrupt</name></name> = <name>mHasPendingInterrupt</name></expr>;
    }</block>

  <name>private</name>:
    <name>nsPresContext</name>* <name>mCtx</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mInterruptsEnabled</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>mHasPendingInterrupt</name></decl>;</decl_stmt>
  }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
    
  <comment type="block">/**
   * Check for interrupts. This may return true if a pending event is
   * detected. Once it has returned true, it will keep returning true
   * until ReflowStarted is called. In all cases where this returns true,
   * the passed-in frame (which should be the frame whose reflow will be
   * interrupted if true is returned) will be passed to
   * nsIPresShell::FrameNeedsToContinueReflow.
   */</comment>
  <function_decl><type><name>PRBool</name></type> <name>CheckForInterrupt</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="block">/**
   * Returns true if CheckForInterrupt has returned true since the last
   * ReflowStarted call. Cannot itself trigger an interrupt check.
   */</comment>
  <function><type><name>PRBool</name></type> <name>HasPendingInterrupt</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mHasPendingInterrupt</name></expr>;</return> }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SMIL</name></cpp:ifdef>
  <comment type="block">/**
   * Indicates that the given element's SMIL Override Style has changed,
   * and as a result, we need to update our display.
   */</comment>
  <function_decl><type><name>void</name></type> <name>SMILOverrideStyleChanged</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_SMIL</comment>

  <comment type="block">/**
   * If we have a presshell, and if the given content's current
   * document is the same as our presshell's document, return the
   * content's primary frame.  Otherwise, return null.  Only use this
   * if you care about which presshell the primary frame is in.
   */</comment>
  <function><type><name>nsIFrame</name>*</type> <name>GetPrimaryFrameFor</name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr>"Don't do that"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>GetPresShell</name><argument_list>()</argument_list></call> &amp;&amp;
        <call><name>GetPresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>GetDocument</name><argument_list>()</argument_list></call> == <call><name><name>aContent</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><call><name><name>aContent</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></function>

<label><name>protected</name>:</label>
  <expr_stmt><expr><name>friend</name> <name>class</name> <name>nsRunnableMethod</name>&lt;<name>nsPresContext</name>&gt;</expr>;</expr_stmt>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ThemeChangedInternal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SysColorChangedInternal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetImgAnimations</name><argument_list>(<argument>nsIContent *aParent</argument>, <argument>PRUint16 aMode</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SMIL</name></cpp:ifdef>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetSMILAnimations</name><argument_list>(<argument>nsIDocument *aDoc</argument>, <argument>PRUint16 aNewMode</argument>,
                                     <argument>PRUint16 aOldMode</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_SMIL</comment>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>GetDocumentColorPreferences</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PreferenceChanged</name><argument_list>(<argument><expr>const <name>char</name>* <name>aPrefName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>static <macro><name>NS_HIDDEN_</name><argument_list>(<argument>int</argument>)</argument_list></macro> <call><name>PrefChangedCallback</name><argument_list>(<argument><expr>const <name>char</name>*</expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>UpdateAfterPreferencesChanged</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>static <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <call><name>PrefChangedUpdateTimerCallback</name><argument_list>(<argument><expr><name>nsITimer</name> *<name>aTimer</name></expr></argument>, <argument><expr><name>void</name> *<name>aClosure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>GetUserPreferences</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>GetFontPreferences</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <macro><name>NS_HIDDEN_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>UpdateCharSet</name><argument_list>(<argument><expr>const <name>nsAFlatCString</name>&amp; <name>aCharSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>PRBool</name></type> <name>MayHavePaintEventListener</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>NotifyInvalidateRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aRegion</name></decl></param>, <param><decl><type><name>nsPoint</name></type> <name>aOffset</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>void</name></type> <name>HandleRebuildUserFontSet</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><name>mPostedFlushUserFontSet</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FlushUserFontSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function_decl><type><name>PRBool</name></type> <name>HavePendingInputEvent</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Can't be inline because we can't include nsStyleSet.h.</comment>
  <function_decl><type><name>PRBool</name></type> <name>HasCachedStyleData</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// IMPORTANT: The ownership implicit in the following member variables</comment>
  <comment type="line">// has been explicitly checked.  If you add any members to this class,</comment>
  <comment type="line">// please make the ownership explicit (pinkerton, scc).</comment>
  
  <decl_stmt><decl><type><name>nsPresContextType</name></type>     <name>mType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIPresShell</name>*</type>         <name>mShell</name></decl>;</decl_stmt>         <comment type="line">// [WEAK]</comment>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIDocument</name>&gt; <name>mDocument</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIDeviceContext</name>*</type>     <name>mDeviceContext</name></decl>;</decl_stmt> <comment type="line">// [STRONG] could be weak, but</comment>
                                        <comment type="line">// better safe than sorry.</comment>
                                        <comment type="line">// Cannot reintroduce cycles</comment>
                                        <comment type="line">// since there is no dependency</comment>
                                        <comment type="line">// from gfx back to layout.</comment>
  <decl_stmt><decl><type><name>nsIEventStateManager</name>*</type> <name>mEventManager</name></decl>;</decl_stmt>  <comment type="line">// [STRONG]</comment>
  <decl_stmt><decl><type><name>nsILookAndFeel</name>*</type>       <name>mLookAndFeel</name></decl>;</decl_stmt>   <comment type="line">// [STRONG]</comment>
  <expr_stmt><expr><name>nsRefPtr</name>&lt;<name>nsRefreshDriver</name>&gt; <name>mRefreshDriver</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsRefPtr</name>&lt;<name>nsTransitionManager</name>&gt; <name>mTransitionManager</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type>              <name>mMedium</name></decl>;</decl_stmt>        <comment type="line">// initialized by subclass ctors;</comment>
                                        <comment type="line">// weak pointer to static atom</comment>

  <decl_stmt><decl><type><name>nsILinkHandler</name>*</type>       <name>mLinkHandler</name></decl>;</decl_stmt>   <comment type="line">// [WEAK]</comment>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type>              <name>mLangGroup</name></decl>;</decl_stmt>     <comment type="line">// [STRONG]</comment>

  <expr_stmt><expr><name>nsRefPtrHashtable</name>&lt;<name>nsVoidPtrHashKey</name></expr>, <expr><name>nsImageLoader</name>&gt;
                        <name><name>mImageLoaders</name><index>[<expr><name>IMAGE_LOAD_TYPE_COUNT</name></expr>]</index></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsWeakPtr</name></type>             <name>mContainer</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>float</name></type>                 <name>mTextZoom</name></decl>;</decl_stmt>      <comment type="line">// Text zoom, defaults to 1.0</comment>
  <decl_stmt><decl><type><name>float</name></type>                 <name>mFullZoom</name></decl>;</decl_stmt>      <comment type="line">// Page zoom, defaults to 1.0</comment>

  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>mCurAppUnitsPerDevPixel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>mAutoQualityMinFontSizePixelsPref</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  <decl_stmt><decl><type><name>nsBidiPresUtils</name>*</type>      <name>mBidiUtils</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsITheme</name>&gt; <name>mTheme</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsILanguageAtomService</name>&gt; <name>mLangService</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIPrintSettings</name>&gt; <name>mPrintSettings</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsITimer</name>&gt;    <name>mPrefChangedTimer</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsPropertyTable</name></type>       <name>mPropertyTable</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsInvalidateRequestList</name></type> <name>mInvalidateRequests</name></decl>;</decl_stmt>

  <comment type="line">// container for per-context fonts (downloadable, SVG, etc.)</comment>
  <decl_stmt><decl><type><name>nsUserFontSet</name>*</type>        <name>mUserFontSet</name></decl>;</decl_stmt>
  <comment type="line">// The list of @font-face rules that we put into mUserFontSet</comment>
  <expr_stmt><expr><name>nsTArray</name>&lt;<name>nsFontFaceRuleContainer</name>&gt; <name>mFontFaceRules</name></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>mFontScaler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type>               <name>mMinimumFontSize</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsRect</name></type>                <name>mVisibleArea</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsSize</name></type>                <name>mPageSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>                 <name>mPageScale</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>                 <name>mPPScale</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mDefaultColor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mBackgroundColor</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mLinkColor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mActiveLinkColor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mVisitedLinkColor</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mFocusBackgroundColor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type>               <name>mFocusTextColor</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>ScrollbarStyles</name></type>       <name>mViewportStyleOverflow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type>               <name>mFocusRingWidth</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRUint16</name></type>              <name>mImageAnimationMode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint16</name></type>              <name>mImageAnimationModePref</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultVariableFont</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultFixedFont</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultSerifFont</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultSansSerifFont</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultMonospaceFont</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultCursiveFont</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsFont</name></type>                <name>mDefaultFantasyFont</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type>               <name><name>mBorderWidthTable</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRUint32</name></type>              <name>mInterruptChecksToSkip</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>mozilla</name>::<name>TimeStamp</name>    <name>mReflowStartTime</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>unsigned</name>              <name>mHasPendingInterrupt</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mInterruptsEnabled</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mUseDocumentFonts</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mUseDocumentColors</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mUnderlineLinks</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mUseFocusColors</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mFocusRingOnAnything</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mFocusRingStyle</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mDrawImageBackground</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mDrawColorBackground</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mNeverAnimate</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mIsRenderingOnlySelection</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPaginated</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mCanPaginatedScroll</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mDoScaledTwips</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mEnableJapaneseTransform</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mIsRootPaginatedDocument</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPrefBidiDirection</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPrefScrollbarSide</name> : 2</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPendingSysColorChanged</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPendingThemeChanged</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPendingMediaFeatureValuesChanged</name> : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>unsigned</name>              <name>mPrefChangePendingNeedsReflow</name> : 1</expr>;</expr_stmt>

  <comment type="line">// Is the current mUserFontSet valid?</comment>
  <expr_stmt><expr><name>unsigned</name>              <name>mUserFontSetDirty</name> : 1</expr>;</expr_stmt>
  <comment type="line">// Has GetUserFontSet() been called?</comment>
  <expr_stmt><expr><name>unsigned</name>              <name>mGetUserFontSetCalled</name> : 1</expr>;</expr_stmt>
  <comment type="line">// Do we currently have an event posted to call FlushUserFontSet?</comment>
  <expr_stmt><expr><name>unsigned</name>              <name>mPostedFlushUserFontSet</name> : 1</expr>;</expr_stmt>

  <comment type="line">// resize reflow is supressed when the only change has been to zoom</comment>
  <comment type="line">// the document rather than to change the document's dimensions</comment>
  <expr_stmt><expr><name>unsigned</name>              <name>mSupressResizeReflow</name> : 1</expr>;</expr_stmt>

  <expr_stmt><expr><name>unsigned</name>              <name>mIsVisual</name> : 1</expr>;</expr_stmt>

  <expr_stmt><expr><name>unsigned</name>              <name>mProcessingAnimationStyleChange</name> : 1</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>PRBool</name></type>                <name>mInitialized</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<label><name>protected</name>:</label>

  <expr_stmt><expr><name>virtual</name> ~<macro><name>nsPresContext</name><argument_list>()</argument_list></macro> <name>NS_HIDDEN</name></expr>;</expr_stmt>

  <comment type="line">// these are private, use the list in nsFont.h if you want a public list</comment>
  <enum>enum <block>{
    <decl><name>eDefaultFont_Variable</name></decl>,
    <decl><name>eDefaultFont_Fixed</name></decl>,
    <decl><name>eDefaultFont_Serif</name></decl>,
    <decl><name>eDefaultFont_SansSerif</name></decl>,
    <decl><name>eDefaultFont_Monospace</name></decl>,
    <decl><name>eDefaultFont_Cursive</name></decl>,
    <decl><name>eDefaultFont_Fantasy</name></decl>,
    <decl><name>eDefaultFont_COUNT</name></decl>
  }</block>;</enum>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<label><name>private</name>:</label>
  <macro><name>friend</name></macro> <struct_decl>struct <name>nsAutoLayoutPhase</name>;</struct_decl>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name><name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
<label><name>public</name>:</label>
  <function><type><name>PRUint32</name></type> <name>LayoutPhaseCount</name><parameter_list>(<param><decl><type><name>nsLayoutPhase</name></type> <name>aPhase</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><name><name>mLayoutPhaseCount</name><index>[<expr><name>aPhase</name></expr>]</index></name></expr>;</return>
  }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

};

<expr_stmt><expr><name>class</name> <name>nsRootPresContext</name> : <name>public</name> <name>nsPresContext</name> <block>{
<expr><name>public</name>:
  <macro><name>nsRootPresContext</name><argument_list>(<argument>nsIDocument* aDocument</argument>, <argument>nsPresContextType aType</argument>)</argument_list></macro> <name>NS_HIDDEN</name></expr>;
  <expr><name>virtual</name> ~<call><name>nsRootPresContext</name><argument_list>()</argument_list></call></expr>;

  <comment type="block">/**
   * Registers a plugin to receive geometry updates (position and clip
   * region) so it can update its widget.
   * Callers must call UnregisterPluginForGeometryUpdates before
   * the aPlugin frame is destroyed.
   */</comment>
  <expr><name>void</name> <call><name>RegisterPluginForGeometryUpdates</name><argument_list>(<argument><expr><name>nsObjectFrame</name>* <name>aPlugin</name></expr></argument>)</argument_list></call></expr>;
  <comment type="block">/**
   * Stops a plugin receiving geometry updates (position and clip
   * region). If the plugin was not already registered, this does
   * nothing.
   */</comment>
  <expr><name>void</name> <call><name>UnregisterPluginForGeometryUpdates</name><argument_list>(<argument><expr><name>nsObjectFrame</name>* <name>aPlugin</name></expr></argument>)</argument_list></call></expr>;

  <comment type="block">/**
   * Iterate through all plugins that are registered for geometry updates
   * and update their position and clip region to match the current frame
   * tree. Only frames at or under aChangedRoot can have changed their
   * geometry.
   */</comment>
  <expr><name>void</name> <call><name>UpdatePluginGeometry</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aChangedRoot</name></expr></argument>)</argument_list></call></expr>;

  <comment type="block">/**
   * Iterate through all plugins that are registered for geometry updates
   * and compute their position and clip region according to the
   * current frame tree. Only frames at or under aChangedRoot can have
   * changed their geometry. The computed positions and clip regions are
   * appended to aConfigurations.
   */</comment>
  <expr><name>void</name> <call><name>GetPluginGeometryUpdates</name><argument_list>(<argument><expr><name>nsIFrame</name>* <name>aChangedRoot</name></expr></argument>,
                                <argument><expr><name>nsTArray</name>&lt;<name>nsIWidget</name>::<name>Configuration</name>&gt;* <name>aConfigurations</name></expr></argument>)</argument_list></call></expr>;

  <comment type="block">/**
   * When all geometry updates have been applied, call this function
   * in case the nsObjectFrames have work to do after the widgets
   * have been updated.
   */</comment>
  <expr><name>void</name> <call><name>DidApplyPluginGeometryUpdates</name><argument_list>()</argument_list></call></expr>;

  <expr><name>virtual</name> <name>PRBool</name> <macro><name>IsRoot</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>PR_TRUE</name></expr>;</return></block></expr> }</block>

<name>private</name>:
  <name>nsTHashtable</name>&lt;<name>nsPtrHashKey</name>&lt;<name>nsObjectFrame</name>&gt; &gt; <name>mRegisteredPlugins</name></expr>;</expr_stmt>
};

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

<struct>struct <name>nsAutoLayoutPhase</name> <block>{
  <macro><name>nsAutoLayoutPhase</name><argument_list>(<argument>nsPresContext* aPresContext</argument>, <argument>nsLayoutPhase aPhase</argument>)</argument_list></macro>
    : <expr_stmt><expr><call><name>mPresContext</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>mPhase</name><argument_list>(<argument><expr><name>aPhase</name></expr></argument>)</argument_list></call></expr>, <macro><name>mCount</name><argument_list>(<argument>0</argument>)</argument_list></macro>
  <expr><block>{
    <expr><call><name>Enter</name><argument_list>()</argument_list></call></expr>;
  }</block>

  ~<macro><name>nsAutoLayoutPhase</name><argument_list>()</argument_list></macro>
  <block>{
    <expr><call><name>Exit</name><argument_list>()</argument_list></call></expr>;
    <expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mCount</name> == 0</expr></argument>, <argument><expr>"imbalanced"</expr></argument>)</argument_list></call></expr>;
  }</block>

  <name>void</name> <macro><name>Enter</name><argument_list>()</argument_list></macro>
  <block>{
    <switch>switch <condition>(<expr><name>mPhase</name></expr>)</condition> <block>{
      <case>case <expr><name>eLayoutPhase_Paint</name></expr>:
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_Paint</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"recurring into paint"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_Reflow</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"painting in the middle of reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_FrameC</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"painting in the middle of frame construction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eLayoutPhase_Reflow</name></expr>:
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_Paint</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"reflowing in the middle of a paint"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_Reflow</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"recurring into reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_FrameC</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"reflowing in the middle of frame construction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eLayoutPhase_FrameC</name></expr>:
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_Paint</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"constructing frames in the middle of a paint"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_Reflow</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"constructing frames in the middle of reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>eLayoutPhase_FrameC</name></expr>]</index></name> == 0</expr></argument>,
                     <argument><expr>"recurring into frame construction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>nsContentUtils</name>::<call><name>IsSafeToRunScript</name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr>"constructing frames and scripts are not blocked"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <break>break;</break>
    <expr_stmt/></default></block></switch>}</block>
    ++(<name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>mPhase</name></expr>]</index></name>)</expr>;</expr_stmt>
    <expr_stmt><expr>++<name>mCount</name></expr>;</expr_stmt>
  }</block>

  <decl><name>void</name> <name>Exit</name><argument_list>()</argument_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mCount</name> &gt; 0 &amp;&amp; <name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>mPhase</name></expr>]</index></name> &gt; 0</expr></argument>,
                 <argument><expr>"imbalanced"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>--(<name><name>mPresContext</name>-&gt;<name>mLayoutPhaseCount</name><index>[<expr><name>mPhase</name></expr>]</index></name>)</expr>;</expr_stmt>
    <expr_stmt><expr>--<name>mCount</name></expr>;</expr_stmt>
  }</block></decl>

<decl><name>private</name>:
  <name>nsPresContext</name> *<name>mPresContext</name></decl>;</struct>
  <decl_stmt><decl><type><name>nsLayoutPhase</name></type> <name>mPhase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCount</name></decl>;</decl_stmt>
};

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTO_LAYOUT_PHASE_ENTRY_POINT</name><parameter_list>(<param><type><name>pc_</name></type></param>, <param><type><name>phase_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>nsAutoLayoutPhase autoLayoutPhase((pc_), (eLayoutPhase_##phase_))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAYOUT_PHASE_TEMP_EXIT</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>PR_BEGIN_MACRO \
    autoLayoutPhase.Exit(); \
  PR_END_MACRO</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAYOUT_PHASE_TEMP_REENTER</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>PR_BEGIN_MACRO \
    autoLayoutPhase.Enter(); \
  PR_END_MACRO</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTO_LAYOUT_PHASE_ENTRY_POINT</name><parameter_list>(<param><type><name>pc_</name></type></param>, <param><type><name>phase_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>PR_BEGIN_MACRO PR_END_MACRO</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAYOUT_PHASE_TEMP_EXIT</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>PR_BEGIN_MACRO PR_END_MACRO</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAYOUT_PHASE_TEMP_REENTER</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>PR_BEGIN_MACRO PR_END_MACRO</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_REFLOW_PERF</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GLOBAL_REFLOW_COUNT</name><parameter_list>(<param><type><name>_name</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>aPresContext-&gt;CountReflows((_name), (nsIFrame*)this);</cpp:value></cpp:define> 
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GLOBAL_REFLOW_COUNT</name><parameter_list>(<param><type><name>_name</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_REFLOW_PERF</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* nsPresContext_h___ */</comment>
</unit>
