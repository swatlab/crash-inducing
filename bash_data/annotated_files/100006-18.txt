 80748: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 53422:  * vim: set ts=4 sw=4 et tw=78:
 40383:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 40383: 
 40383: #ifndef jscntxtinlines_h___
 40383: #define jscntxtinlines_h___
 40383: 
 40383: #include "jscntxt.h"
 59733: #include "jscompartment.h"
 79734: #include "jsfriendapi.h"
 79734: #include "jsinterp.h"
 97465: #include "jsprobes.h"
 40383: #include "jsxml.h"
 55606: #include "jsgc.h"
 53858: 
 72579: #include "frontend/ParseMaps.h"
 79981: #include "vm/RegExpObject.h"
 72579: 
 97465: #include "jsgcinlines.h"
 97465: 
 62876: namespace js {
 62876: 
 97465: inline void
 97465: NewObjectCache::staticAsserts()
 97465: {
 97465:     JS_STATIC_ASSERT(NewObjectCache::MAX_OBJ_SIZE == sizeof(JSObject_Slots16));
 97465:     JS_STATIC_ASSERT(gc::FINALIZE_OBJECT_LAST == gc::FINALIZE_OBJECT16_BACKGROUND);
 97465: }
 97465: 
 97465: inline bool
 97465: NewObjectCache::lookup(Class *clasp, gc::Cell *key, gc::AllocKind kind, EntryIndex *pentry)
 97465: {
 97465:     uintptr_t hash = (uintptr_t(clasp) ^ uintptr_t(key)) + kind;
 97465:     *pentry = hash % js::ArrayLength(entries);
 97465: 
 97465:     Entry *entry = &entries[*pentry];
 97465: 
 97465:     /* N.B. Lookups with the same clasp/key but different kinds map to different entries. */
 97465:     return (entry->clasp == clasp && entry->key == key);
 97465: }
 97465: 
 97465: inline bool
 97465: NewObjectCache::lookupProto(Class *clasp, JSObject *proto, gc::AllocKind kind, EntryIndex *pentry)
 97465: {
 97465:     JS_ASSERT(!proto->isGlobal());
 97465:     return lookup(clasp, proto, kind, pentry);
 97465: }
 97465: 
 97465: inline bool
 97465: NewObjectCache::lookupGlobal(Class *clasp, js::GlobalObject *global, gc::AllocKind kind, EntryIndex *pentry)
 97465: {
 97465:     return lookup(clasp, global, kind, pentry);
 97465: }
 97465: 
 97465: inline bool
 97465: NewObjectCache::lookupType(Class *clasp, js::types::TypeObject *type, gc::AllocKind kind, EntryIndex *pentry)
 97465: {
 97465:     return lookup(clasp, type, kind, pentry);
 97465: }
 97465: 
 97465: inline void
 97465: NewObjectCache::fill(EntryIndex entry_, Class *clasp, gc::Cell *key, gc::AllocKind kind, JSObject *obj)
 97465: {
 97465:     JS_ASSERT(unsigned(entry_) < ArrayLength(entries));
 97465:     Entry *entry = &entries[entry_];
 97465: 
 97465:     JS_ASSERT(!obj->hasDynamicSlots() && !obj->hasDynamicElements());
 97465: 
 97465:     entry->clasp = clasp;
 97465:     entry->key = key;
 97465:     entry->kind = kind;
 97465: 
 97465:     entry->nbytes = obj->sizeOfThis();
 97465:     js_memcpy(&entry->templateObject, obj, entry->nbytes);
 97465: }
 97465: 
 97465: inline void
 97465: NewObjectCache::fillProto(EntryIndex entry, Class *clasp, JSObject *proto, gc::AllocKind kind, JSObject *obj)
 97465: {
 97465:     JS_ASSERT(!proto->isGlobal());
 97465:     JS_ASSERT(obj->getProto() == proto);
 97465:     return fill(entry, clasp, proto, kind, obj);
 97465: }
 97465: 
 97465: inline void
 97465: NewObjectCache::fillGlobal(EntryIndex entry, Class *clasp, js::GlobalObject *global, gc::AllocKind kind, JSObject *obj)
 97465: {
 97465:     //JS_ASSERT(global == obj->getGlobal());
 97465:     return fill(entry, clasp, global, kind, obj);
 97465: }
 97465: 
 97465: inline void
 97465: NewObjectCache::fillType(EntryIndex entry, Class *clasp, js::types::TypeObject *type, gc::AllocKind kind, JSObject *obj)
 97465: {
 97465:     JS_ASSERT(obj->type() == type);
 97465:     return fill(entry, clasp, type, kind, obj);
 97465: }
 97465: 
 97465: inline JSObject *
 97465: NewObjectCache::newObjectFromHit(JSContext *cx, EntryIndex entry_)
 97465: {
 97465:     JS_ASSERT(unsigned(entry_) < ArrayLength(entries));
 97465:     Entry *entry = &entries[entry_];
 97465: 
 97465:     JSObject *obj = js_TryNewGCObject(cx, entry->kind);
 97465:     if (obj) {
 97465:         copyCachedToObject(obj, reinterpret_cast<JSObject *>(&entry->templateObject));
 97465:         Probes::createObject(cx, obj);
 97465:         return obj;
 97465:     }
 97465: 
 97465:     /* Copy the entry to the stack first in case it is purged by a GC. */
 97465:     size_t nbytes = entry->nbytes;
 97465:     char stackObject[sizeof(JSObject_Slots16)];
 97465:     JS_ASSERT(nbytes <= sizeof(stackObject));
 97465:     js_memcpy(&stackObject, &entry->templateObject, nbytes);
 97465: 
 97465:     JSObject *baseobj = (JSObject *) stackObject;
 97465: 
 97465:     obj = js_NewGCObject(cx, entry->kind);
 97465:     if (obj) {
 97465:         copyCachedToObject(obj, baseobj);
 97465:         Probes::createObject(cx, obj);
 97465:         return obj;
 97465:     }
 97465: 
 97465:     return NULL;
 97465: }
 97465: 
 77343: struct PreserveRegsGuard
 77343: {
 77343:     PreserveRegsGuard(JSContext *cx, FrameRegs &regs)
 77343:       : prevContextRegs(cx->maybeRegs()), cx(cx), regs_(regs) {
 77343:         cx->stack.repointRegs(&regs_);
 77343:     }
 77343:     ~PreserveRegsGuard() {
 77343:         JS_ASSERT(cx->maybeRegs() == &regs_);
 77343:         *prevContextRegs = regs_;
 77343:         cx->stack.repointRegs(prevContextRegs);
 77343:     }
 77343: 
 77343:     FrameRegs *prevContextRegs;
 77343: 
 77343:   private:
 77343:     JSContext *cx;
 77343:     FrameRegs &regs_;
 77343: };
 77343: 
 68955: static inline GlobalObject *
 62876: GetGlobalForScopeChain(JSContext *cx)
 62876: {
 71696:     if (cx->hasfp())
 96793:         return &cx->fp()->global();
 62876: 
 79734:     JSObject *scope = JS_ObjectToInnerObject(cx, cx->globalObject);
 79734:     if (!scope)
 62876:         return NULL;
 86483:     return &scope->asGlobal();
 62876: }
 62876: 
 67915: inline GSNCache *
 67915: GetGSNCache(JSContext *cx)
 67915: {
 88135:     return &cx->runtime->gsnCache;
 67915: }
 67915: 
 98644: #if JS_HAS_XML_SUPPORT
 98644: 
 47478: class AutoNamespaceArray : protected AutoGCRooter {
 47478:   public:
 91250:     AutoNamespaceArray(JSContext *cx)
 91250:         : AutoGCRooter(cx, NAMESPACES), context(cx) {
 47478:         array.init();
 40383:     }
 40383: 
 47478:     ~AutoNamespaceArray() {
 94740:         array.finish(context->runtime->defaultFreeOp());
 47478:     }
 47478: 
 84755:     uint32_t length() const { return array.length; }
 47478: 
 91250:   private:
 91250:     JSContext *context;
 80748:     friend void AutoGCRooter::trace(JSTracer *trc);
 80744: 
 91250:   public:
 82129:     JSXMLArray<JSObject> array;
 40383: };
 40383: 
 98644: #endif /* JS_HAS_XML_SUPPORT */
 98644: 
 84073: template <typename T>
 84073: class AutoPtr
 84073: {
 84073:     JSContext *cx;
 84073:     T *value;
 84073: 
 84073:     AutoPtr(const AutoPtr &other) MOZ_DELETE;
 84073: 
 84073:   public:
 84073:     explicit AutoPtr(JSContext *cx) : cx(cx), value(NULL) {}
 84073:     ~AutoPtr() {
 84073:         cx->delete_<T>(value);
 84073:     }
 84073: 
 84073:     void operator=(T *ptr) { value = ptr; }
 84073: 
 84073:     typedef void ***** ConvertibleToBool;
 84073:     operator ConvertibleToBool() const { return (ConvertibleToBool) value; }
 84073: 
 84073:     const T *operator->() const { return value; }
 84073:     T *operator->() { return value; }
 84073: 
 84073:     T *get() { return value; }
 84073: };
 84073: 
 57743: #ifdef DEBUG
 47485: class CompartmentChecker
 47485: {
 47485:     JSContext *context;
 47485:     JSCompartment *compartment;
 47485: 
 47485:   public:
 47485:     explicit CompartmentChecker(JSContext *cx) : context(cx), compartment(cx->compartment) {
 71696:         check(cx->hasfp() ? JS_GetGlobalForScopeChain(cx) : cx->globalObject);
 47485:     }
 47485: 
 47485:     /*
 47485:      * Set a breakpoint here (break js::CompartmentChecker::fail) to debug
 47485:      * compartment mismatches.
 47485:      */
 47485:     static void fail(JSCompartment *c1, JSCompartment *c2) {
 47485:         printf("*** Compartment mismatch %p vs. %p\n", (void *) c1, (void *) c2);
 57743:         JS_NOT_REACHED("compartment mismatched");
 47485:     }
 47485: 
 60169:     /* Note: should only be used when neither c1 nor c2 may be the default compartment. */
 60169:     static void check(JSCompartment *c1, JSCompartment *c2) {
 60584:         JS_ASSERT(c1 != c1->rt->atomsCompartment);
 60584:         JS_ASSERT(c2 != c2->rt->atomsCompartment);
 60169:         if (c1 != c2)
 60169:             fail(c1, c2);
 60169:     }
 60169: 
 47485:     void check(JSCompartment *c) {
 60584:         if (c && c != context->runtime->atomsCompartment) {
 47485:             if (!compartment)
 47485:                 compartment = c;
 47485:             else if (c != compartment)
 47485:                 fail(compartment, c);
 47485:         }
 47485:     }
 47485: 
 47485:     void check(JSPrincipals *) { /* nothing for now */ }
 47485: 
 47485:     void check(JSObject *obj) {
 47485:         if (obj)
 61430:             check(obj->compartment());
 61430:     }
 61430: 
 61430:     void check(JSString *str) {
 64343:         if (!str->isAtom())
 64345:             check(str->compartment());
 47485:     }
 47485: 
 48470:     void check(const js::Value &v) {
 48470:         if (v.isObject())
 48470:             check(&v.toObject());
 61430:         else if (v.isString())
 61430:             check(v.toString());
 48470:     }
 48470: 
 47485:     void check(const ValueArray &arr) {
 47485:         for (size_t i = 0; i < arr.length; i++)
 47485:             check(arr.array[i]);
 47485:     }
 47485: 
 48470:     void check(const JSValueArray &arr) {
 48470:         for (size_t i = 0; i < arr.length; i++)
 48470:             check(arr.array[i]);
 48470:     }
 48470: 
 71695:     void check(const CallArgs &args) {
 71695:         for (Value *p = args.base(); p != args.end(); ++p)
 71695:             check(*p);
 71695:     }
 71695: 
 48470:     void check(jsid id) {
 48470:         if (JSID_IS_OBJECT(id))
 48470:             check(JSID_TO_OBJECT(id));
 48470:     }
 48470: 
 47485:     void check(JSIdArray *ida) {
 47485:         if (ida) {
 91450:             for (int i = 0; i < ida->length; i++) {
 48470:                 if (JSID_IS_OBJECT(ida->vector[i]))
 48470:                     check(ida->vector[i]);
 48470:             }
 47485:         }
 47485:     }
 47485: 
 47485:     void check(JSScript *script) {
 59220:         if (script) {
 77659:             check(script->compartment());
 82129:             if (!script->isCachedEval && script->globalObject)
 82129:                 check(script->globalObject);
 47485:         }
 55633:     }
 47485: 
 69223:     void check(StackFrame *fp) {
 84307:         if (fp)
 96793:             check(fp->scopeChain());
 56704:     }
 47485: };
 47485: 
 57743: #endif
 57743: 
 47485: /*
 47485:  * Don't perform these checks when called from a finalizer. The checking
 47485:  * depends on other objects not having been swept yet.
 47485:  */
 47485: #define START_ASSERT_SAME_COMPARTMENT()                                       \
 47485:     if (cx->runtime->gcRunning)                                               \
 47485:         return;                                                               \
 47485:     CompartmentChecker c(cx)
 47485: 
 47485: template <class T1> inline void
 98960: assertSameCompartment(JSContext *cx, const T1 &t1)
 47485: {
 57743: #ifdef DEBUG
 47485:     START_ASSERT_SAME_COMPARTMENT();
 47485:     c.check(t1);
 57743: #endif
 47485: }
 47485: 
 47485: template <class T1, class T2> inline void
 98960: assertSameCompartment(JSContext *cx, const T1 &t1, const T2 &t2)
 47485: {
 57743: #ifdef DEBUG
 47485:     START_ASSERT_SAME_COMPARTMENT();
 47485:     c.check(t1);
 47485:     c.check(t2);
 57743: #endif
 47485: }
 47485: 
 47485: template <class T1, class T2, class T3> inline void
 98960: assertSameCompartment(JSContext *cx, const T1 &t1, const T2 &t2, const T3 &t3)
 47485: {
 57743: #ifdef DEBUG
 47485:     START_ASSERT_SAME_COMPARTMENT();
 47485:     c.check(t1);
 47485:     c.check(t2);
 47485:     c.check(t3);
 57743: #endif
 47485: }
 47485: 
 47485: template <class T1, class T2, class T3, class T4> inline void
 98960: assertSameCompartment(JSContext *cx, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4)
 47485: {
 57743: #ifdef DEBUG
 47485:     START_ASSERT_SAME_COMPARTMENT();
 47485:     c.check(t1);
 47485:     c.check(t2);
 47485:     c.check(t3);
 47485:     c.check(t4);
 57743: #endif
 47485: }
 47485: 
 47485: template <class T1, class T2, class T3, class T4, class T5> inline void
 98960: assertSameCompartment(JSContext *cx, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5)
 47485: {
 57743: #ifdef DEBUG
 47485:     START_ASSERT_SAME_COMPARTMENT();
 47485:     c.check(t1);
 47485:     c.check(t2);
 47485:     c.check(t3);
 47485:     c.check(t4);
 47485:     c.check(t5);
 57743: #endif
 47485: }
 47485: 
 47485: #undef START_ASSERT_SAME_COMPARTMENT
 47485: 
 71695: STATIC_PRECONDITION_ASSUME(ubound(args.argv_) >= argc)
 53557: JS_ALWAYS_INLINE bool
 78614: CallJSNative(JSContext *cx, Native native, const CallArgs &args)
 47485: {
 53557: #ifdef DEBUG
 60211:     JSBool alreadyThrowing = cx->isExceptionPending();
 53557: #endif
 71695:     assertSameCompartment(cx, args);
 79387:     bool ok = native(cx, args.length(), args.base());
 53557:     if (ok) {
 71695:         assertSameCompartment(cx, args.rval());
 60211:         JS_ASSERT_IF(!alreadyThrowing, !cx->isExceptionPending());
 53557:     }
 47485:     return ok;
 47485: }
 47485: 
 91237: extern JSBool CallOrConstructBoundFunction(JSContext *, unsigned, js::Value *);
 62402: 
 71695: STATIC_PRECONDITION(ubound(args.argv_) >= argc)
 53557: JS_ALWAYS_INLINE bool
 78614: CallJSNativeConstructor(JSContext *cx, Native native, const CallArgs &args)
 47485: {
 53557: #ifdef DEBUG
 99421:     RootedObject callee(cx, &args.callee());
 53557: #endif
 53557: 
 71695:     JS_ASSERT(args.thisv().isMagic());
 71695:     if (!CallJSNative(cx, native, args))
 53557:         return false;
 53557: 
 53557:     /*
 53617:      * Native constructors must return non-primitive values on success.
 53617:      * Although it is legal, if a constructor returns the callee, there is a
 53617:      * 99.9999% chance it is a bug. If any valid code actually wants the
 54729:      * constructor to return the callee, the assertion can be removed or
 54729:      * (another) conjunct can be added to the antecedent.
 53617:      *
 53617:      * Proxies are exceptions to both rules: they can return primitives and
 53617:      * they allow content to return the callee.
 54729:      *
 62402:      * CallOrConstructBoundFunction is an exception as well because we
 62402:      * might have used bind on a proxy function.
 62402:      *
 54729:      * (new Object(Object)) returns the callee.
 53557:      */
 77817:     JS_ASSERT_IF(native != FunctionProxyClass.construct &&
 72094:                  native != js::CallOrConstructBoundFunction &&
 95355:                  (!callee->isFunction() || callee->toFunction()->native() != js_Object),
 95355:                  !args.rval().isPrimitive() && callee != &args.rval().toObject());
 53617: 
 53557:     return true;
 47485: }
 47485: 
 53557: JS_ALWAYS_INLINE bool
 98960: CallJSPropertyOp(JSContext *cx, PropertyOp op, HandleObject receiver, HandleId id, Value *vp)
 47485: {
 67941:     assertSameCompartment(cx, receiver, id, *vp);
 67941:     JSBool ok = op(cx, receiver, id, vp);
 47485:     if (ok)
 97353:         assertSameCompartment(cx, *vp);
 47485:     return ok;
 47485: }
 47485: 
 53557: JS_ALWAYS_INLINE bool
 98960: CallJSPropertyOpSetter(JSContext *cx, StrictPropertyOp op, HandleObject obj, HandleId id,
 78614:                        JSBool strict, Value *vp)
 47485: {
 48470:     assertSameCompartment(cx, obj, id, *vp);
 62395:     return op(cx, obj, id, strict, vp);
 47485: }
 47485: 
 56817: inline bool
 98960: CallSetter(JSContext *cx, HandleObject obj, HandleId id, StrictPropertyOp op, unsigned attrs,
 91237:            unsigned shortid, JSBool strict, Value *vp)
 56817: {
 56817:     if (attrs & JSPROP_SETTER)
 76829:         return InvokeGetterOrSetter(cx, obj, CastAsObjectJsval(op), 1, vp, vp);
 56817: 
 56817:     if (attrs & JSPROP_GETTER)
 56817:         return js_ReportGetterOnlyAssignment(cx);
 56817: 
 98960:     if (!(attrs & JSPROP_SHORTID))
 62395:         return CallJSPropertyOpSetter(cx, op, obj, id, strict, vp);
 98960: 
 99421:     RootedId nid(cx, INT_TO_JSID(shortid));
 98960: 
 98960:     return CallJSPropertyOpSetter(cx, op, obj, nid, strict, vp);
 56817: }
 56817: 
 94934: static inline HeapPtrAtom *
 79734: FrameAtomBase(JSContext *cx, js::StackFrame *fp)
 79734: {
 82642:     return fp->script()->atoms;
 79734: }
 79734: 
 48470: }  /* namespace js */
 40383: 
 79734: inline JSVersion
 79734: JSContext::findVersion() const
 79734: {
 79734:     if (hasVersionOverride)
 79734:         return versionOverride;
 79734: 
 79734:     if (stack.hasfp()) {
 79734:         /* There may be a scripted function somewhere on the stack! */
 79734:         js::StackFrame *f = fp();
 79734:         while (f && !f->isScriptFrame())
 79734:             f = f->prev();
 79734:         if (f)
 79734:             return f->script()->getVersion();
 79734:     }
 79734: 
 79734:     return defaultVersion;
 79734: }
 79734: 
 79734: inline bool
 79734: JSContext::canSetDefaultVersion() const
 79734: {
 79734:     return !stack.hasfp() && !hasVersionOverride;
 79734: }
 79734: 
 79734: inline void
 79734: JSContext::overrideVersion(JSVersion newVersion)
 79734: {
 79734:     JS_ASSERT(!canSetDefaultVersion());
 79734:     versionOverride = newVersion;
 79734:     hasVersionOverride = true;
 79734: }
 79734: 
 79734: inline bool
 79734: JSContext::maybeOverrideVersion(JSVersion newVersion)
 79734: {
 79734:     if (canSetDefaultVersion()) {
 79734:         setDefaultVersion(newVersion);
 79734:         return false;
 79734:     }
 79734:     overrideVersion(newVersion);
 79734:     return true;
 79734: }
 79734: 
 91237: inline unsigned
 79734: JSContext::getCompileOptions() const { return js::VersionFlagsToOptions(findVersion()); }
 79734: 
 91237: inline unsigned
 79734: JSContext::allOptions() const { return getRunOptions() | getCompileOptions(); }
 79734: 
 79734: inline void
 91237: JSContext::setCompileOptions(unsigned newcopts)
 79734: {
 79734:     JS_ASSERT((newcopts & JSCOMPILEOPTION_MASK) == newcopts);
 79734:     if (JS_LIKELY(getCompileOptions() == newcopts))
 79734:         return;
 79734:     JSVersion version = findVersion();
 79734:     JSVersion newVersion = js::OptionFlagsToVersion(newcopts, version);
 79734:     maybeOverrideVersion(newVersion);
 79734: }
 79734: 
100006: inline void
100006: JSContext::assertValidStackDepth(unsigned depth)
100006: {
100006: #ifdef DEBUG
100006:     JS_ASSERT(0 <= regs().sp - fp()->base());
100006:     JS_ASSERT(depth <= uintptr_t(regs().sp - fp()->base()));
100006: #endif
100006: }
 79734: 
 79410: inline js::LifoAlloc &
 79410: JSContext::typeLifoAlloc()
 79410: {
 79410:     return compartment->typeLifoAlloc;
 79410: }
 79410: 
100006: inline bool
100006: JSContext::ensureGeneratorStackSpace()
100006: {
100006:     bool ok = genStack.reserve(genStack.length() + 1);
100006:     if (!ok)
100006:         js_ReportOutOfMemory(this);
100006:     return ok;
100006: }
100006: 
 60211: inline void
 60211: JSContext::setPendingException(js::Value v) {
 97353:     JS_ASSERT(!IsPoisonedValue(v));
 60211:     this->throwing = true;
 60211:     this->exception = v;
 78613:     js::assertSameCompartment(this, v);
 60211: }
 60211: 
 72579: inline bool
 72579: JSContext::ensureParseMapPool()
 72579: {
 72579:     if (parseMapPool_)
 72579:         return true;
 72579:     parseMapPool_ = js::OffTheBooks::new_<js::ParseMapPool>(this);
 72579:     return parseMapPool_;
 72579: }
 72579: 
 98835: inline js::PropertyTree&
 98835: JSContext::propertyTree()
 98835: {
 98835:     return compartment->propertyTree;
 98835: }
 98835: 
 86484: /* Get the current frame, first lazily instantiating stack frames if needed. */
 86484: static inline js::StackFrame *
 79734: js_GetTopStackFrame(JSContext *cx, FrameExpandKind expand)
 79734: {
 79734: #ifdef JS_METHODJIT
 79734:     if (expand)
 79734:         js::mjit::ExpandInlineFrames(cx->compartment);
 79734: #endif
 79734: 
 79734:     return cx->maybefp();
 79734: }
 79734: 
 40383: #endif /* jscntxtinlines_h___ */
