    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * rendering object for the point that anchors out-of-flow rendering
    1:  * objects such as floats and absolutely positioned elements
    1:  */
    1: 
36646: #include "nsLayoutUtils.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsLineLayout.h"
    1: #include "nsIContent.h"
    1: #include "nsPresContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsFrameManager.h"
    1: #include "nsDisplayList.h"
    1: 
    1: nsIFrame*
34912: NS_NewPlaceholderFrame(nsIPresShell* aPresShell, nsStyleContext* aContext,
34912:                        nsFrameState aTypeBit)
    1: {
34912:   return new (aPresShell) nsPlaceholderFrame(aContext, aTypeBit);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsPlaceholderFrame)
32423: 
    1: nsPlaceholderFrame::~nsPlaceholderFrame()
    1: {
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsPlaceholderFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsPlaceholderFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_PREF_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
43887: /* virtual */ nsSize
43887: nsPlaceholderFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
43887: {
43887:   nsSize size(0, 0);
43887:   DISPLAY_MIN_SIZE(this, size);
43887:   return size;
43887: }
43887: 
43887: /* virtual */ nsSize
43887: nsPlaceholderFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
43887: {
43887:   nsSize size(0, 0);
43887:   DISPLAY_PREF_SIZE(this, size);
43887:   return size;
43887: }
43887: 
43887: /* virtual */ nsSize
43887: nsPlaceholderFrame::GetMaxSize(nsBoxLayoutState& aBoxLayoutState)
43887: {
43887:   nsSize size(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
43887:   DISPLAY_MAX_SIZE(this, size);
43887:   return size;
43887: }
43887: 
    1: /* virtual */ void
    1: nsPlaceholderFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                       nsIFrame::InlineMinWidthData *aData)
    1: {
    1:   // Override AddInlineMinWith so that *nothing* happens.  In
    1:   // particular, we don't want to zero out |aData->trailingWhitespace|,
    1:   // since nsLineLayout skips placeholders when trimming trailing
    1:   // whitespace, and we don't want to set aData->skipWhitespace to
    1:   // false.
    1: 
    1:   // ...but push floats onto the list
    1:   if (mOutOfFlowFrame->GetStyleDisplay()->mFloats != NS_STYLE_FLOAT_NONE)
    1:     aData->floats.AppendElement(mOutOfFlowFrame);
    1: }
    1: 
    1: /* virtual */ void
    1: nsPlaceholderFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                        nsIFrame::InlinePrefWidthData *aData)
    1: {
    1:   // Override AddInlinePrefWith so that *nothing* happens.  In
    1:   // particular, we don't want to zero out |aData->trailingWhitespace|,
    1:   // since nsLineLayout skips placeholders when trimming trailing
    1:   // whitespace, and we don't want to set aData->skipWhitespace to
    1:   // false.
    1: 
    1:   // ...but push floats onto the list
    1:   if (mOutOfFlowFrame->GetStyleDisplay()->mFloats != NS_STYLE_FLOAT_NONE)
    1:     aData->floats.AppendElement(mOutOfFlowFrame);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPlaceholderFrame::Reflow(nsPresContext*          aPresContext,
    1:                            nsHTMLReflowMetrics&     aDesiredSize,
    1:                            const nsHTMLReflowState& aReflowState,
    1:                            nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsPlaceholderFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1:   aDesiredSize.width = 0;
    1:   aDesiredSize.height = 0;
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: void
36647: nsPlaceholderFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
  238:   nsIPresShell* shell = PresContext()->GetPresShell();
36646:   nsIFrame* oof = mOutOfFlowFrame;
36646:   if (oof) {
36647:     // Unregister out-of-flow frame
31045:     shell->FrameManager()->UnregisterPlaceholderFrame(this);
36647:     mOutOfFlowFrame = nsnull;
36647:     // If aDestructRoot is not an ancestor of the out-of-flow frame,
36647:     // then call RemoveFrame on it here.
36647:     // Also destroy it here if it's a popup frame. (Bug 96291)
36647:     if (shell->FrameManager() &&
50895:         ((GetStateBits() & PLACEHOLDER_FOR_POPUP) ||
36647:          !nsLayoutUtils::IsProperAncestorFrame(aDestructRoot, oof))) {
36646:       nsIAtom* listName = nsLayoutUtils::GetChildListNameFor(oof);
36646:       shell->FrameManager()->RemoveFrame(listName, oof);
    1:     }
36647:     // else oof will be destroyed by its parent
36647:   }
    1: 
36647:   nsFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: nsIAtom*
    1: nsPlaceholderFrame::GetType() const
    1: {
    1:   return nsGkAtoms::placeholderFrame; 
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsPlaceholderFrame::CanContinueTextRun() const
    1: {
    1:   if (!mOutOfFlowFrame) {
    1:     return PR_FALSE;
    1:   }
    1:   // first-letter frames can continue text runs, and placeholders for floated
    1:   // first-letter frames can too
    1:   return mOutOfFlowFrame->CanContinueTextRun();
    1: }
    1: 
 3599: NS_IMETHODIMP
 3599: nsPlaceholderFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
 3599:                                                nsIFrame**      aProviderFrame,
 3599:                                                PRBool*         aIsChild)
 3599: {
 3599:   NS_PRECONDITION(GetParent(), "How can we not have a parent here?");
 3599:   *aIsChild = PR_FALSE;
 3599: 
 3599:   // Lie about our pseudo so we can step out of all anon boxes and
 3599:   // pseudo-elements.  The other option would be to reimplement the
 3599:   // {ib} split gunk here.
 3599:   *aProviderFrame =
 3599:     CorrectStyleParentFrame(GetParent(), nsGkAtoms::placeholderFrame);
 3600:   return NS_OK;
 3599: }
 3599: 
 3599: 
    1: #ifdef DEBUG
    1: static void
    1: PaintDebugPlaceholder(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                       const nsRect& aDirtyRect, nsPoint aPt)
    1: {
    1:   aCtx->SetColor(NS_RGB(0, 255, 255));
    1:   nscoord x = nsPresContext::CSSPixelsToAppUnits(-5);
    1:   aCtx->FillRect(aPt.x + x, aPt.y,
    1:                  nsPresContext::CSSPixelsToAppUnits(13), nsPresContext::CSSPixelsToAppUnits(3));
    1:   nscoord y = nsPresContext::CSSPixelsToAppUnits(-10);
    1:   aCtx->FillRect(aPt.x, aPt.y + y,
    1:                  nsPresContext::CSSPixelsToAppUnits(3), nsPresContext::CSSPixelsToAppUnits(10));
    1: }
    1: #endif // DEBUG
    1: 
    1: #if defined(DEBUG) || (defined(MOZ_REFLOW_PERF_DSP) && defined(MOZ_REFLOW_PERF))
    1: 
    1: NS_IMETHODIMP
    1: nsPlaceholderFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                      const nsRect&           aDirtyRect,
    1:                                      const nsDisplayListSet& aLists)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsPlaceholderFrame");
    1:   
    1: #ifdef DEBUG
    1:   if (!GetShowFrameBorders())
    1:     return NS_OK;
    1:   
    1:   return aLists.Outlines()->AppendNewToTop(new (aBuilder)
50433:       nsDisplayGeneric(this, PaintDebugPlaceholder, "DebugPlaceholder",
47732:                        nsDisplayItem::TYPE_DEBUG_PLACEHOLDER));
    1: #else // DEBUG
    1:   return NS_OK;
    1: #endif // DEBUG
    1: }
    1: #endif // DEBUG || (MOZ_REFLOW_PERF_DSP && MOZ_REFLOW_PERF)
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsPlaceholderFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Placeholder"), aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPlaceholderFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
 3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
    1: #endif
    1:   if (HasView()) {
    1:     fprintf(out, " [view=%p]", (void*)GetView());
    1:   }
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
43479:     fprintf(out, " [state=%016llx]", mState);
    1:   }
    1:   nsIFrame* prevInFlow = GetPrevInFlow();
    1:   nsIFrame* nextInFlow = GetNextInFlow();
    1:   if (nsnull != prevInFlow) {
 3233:     fprintf(out, " prev-in-flow=%p", static_cast<void*>(prevInFlow));
    1:   }
    1:   if (nsnull != nextInFlow) {
 3233:     fprintf(out, " next-in-flow=%p", static_cast<void*>(nextInFlow));
    1:   }
34444:   if (nsnull != mContent) {
34444:     fprintf(out, " [content=%p]", static_cast<void*>(mContent));
34444:   }
46249:   if (nsnull != mStyleContext) {
46249:     fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
46249:   }
    1:   if (mOutOfFlowFrame) {
    1:     fprintf(out, " outOfFlowFrame=");
    1:     nsFrame::ListTag(out, mOutOfFlowFrame);
    1:   }
    1:   fputs("\n", out);
    1:   return NS_OK;
    1: }
    1: #endif
