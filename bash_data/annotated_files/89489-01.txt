19963: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19963: // vim:cindent:ts=2:et:sw=2:
19963: /* ***** BEGIN LICENSE BLOCK *****
19963:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19963:  *
19963:  * The contents of this file are subject to the Mozilla Public License Version
19963:  * 1.1 (the "License"); you may not use this file except in compliance with
19963:  * the License. You may obtain a copy of the License at
19963:  * http://www.mozilla.org/MPL/
19963:  *
19963:  * Software distributed under the License is distributed on an "AS IS" basis,
19963:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19963:  * for the specific language governing rights and limitations under the
19963:  * License.
19963:  *
19963:  * The Original Code is Mozilla Foundation code.
19963:  *
19963:  * The Initial Developer of the Original Code is
19963:  * Mozilla Foundation.
19963:  * Portions created by the Initial Developer are Copyright (C) 2008
19963:  * the Initial Developer. All Rights Reserved.
19963:  *
19963:  * Contributor(s):
19963:  *   John Daggett <jdaggett@mozilla.com>
19963:  *
19963:  * Alternatively, the contents of this file may be used under the terms of
19963:  * either of the GNU General Public License Version 2 or later (the "GPL"),
19963:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19963:  * in which case the provisions of the GPL or the LGPL are applicable instead
19963:  * of those above. If you wish to allow use of your version of this file only
19963:  * under the terms of either the GPL or the LGPL, and not to allow others to
19963:  * use your version of this file under the terms of the MPL, indicate your
19963:  * decision by deleting the provisions above and replace them with the notice
19963:  * and other provisions required by the GPL or the LGPL. If you do not delete
19963:  * the provisions above, a recipient may use your version of this file under
19963:  * the terms of any one of the MPL, the GPL or the LGPL.
19963:  *
19963:  * ***** END LICENSE BLOCK ***** */
19963: 
19963: /* code for loading in @font-face defined font data */
19963: 
19963: #ifdef MOZ_LOGGING
19963: #define FORCE_PR_LOG /* Allow logging in the release build */
19963: #endif /* MOZ_LOGGING */
19963: #include "prlog.h"
19963: 
19963: #include "nsFontFaceLoader.h"
19963: 
21370: #include "nsError.h"
19963: #include "nsIFile.h"
19963: #include "nsILocalFile.h"
19963: #include "nsIStreamListener.h"
19963: #include "nsNetUtil.h"
19963: #include "nsIChannelEventSink.h"
19963: #include "nsIInterfaceRequestor.h"
19963: #include "nsContentUtils.h"
71641: #include "mozilla/Preferences.h"
19963: 
19963: #include "nsPresContext.h"
19963: #include "nsIPresShell.h"
19963: #include "nsIDocument.h"
19963: #include "nsIFrame.h"
19963: #include "nsIPrincipal.h"
19963: #include "nsIScriptSecurityManager.h"
19963: 
19963: #include "nsDirectoryServiceUtils.h"
19963: #include "nsDirectoryServiceDefs.h"
21370: #include "nsIContentPolicy.h"
21370: #include "nsContentPolicyUtils.h"
21370: #include "nsContentErrors.h"
21370: #include "nsCrossSiteListenerProxy.h"
41211: #include "nsIContentSecurityPolicy.h"
41211: #include "nsIChannelPolicy.h"
41211: #include "nsChannelPolicy.h"
19963: 
73711: #include "nsIConsoleService.h"
73711: 
68402: #include "nsStyleSet.h"
77158: #include "nsPrintfCString.h"
68402: 
71641: using namespace mozilla;
71641: 
19963: #ifdef PR_LOGGING
19963: static PRLogModuleInfo *gFontDownloaderLog = PR_NewLogModule("fontdownloader");
19963: #endif /* PR_LOGGING */
19963: 
19963: #define LOG(args) PR_LOG(gFontDownloaderLog, PR_LOG_DEBUG, args)
19963: #define LOG_ENABLED() PR_LOG_TEST(gFontDownloaderLog, PR_LOG_DEBUG)
19963: 
19963: 
69055: nsFontFaceLoader::nsFontFaceLoader(gfxProxyFontEntry *aProxy, nsIURI *aFontURI,
23932:                                    nsUserFontSet *aFontSet, nsIChannel *aChannel)
69055:   : mFontEntry(aProxy), mFontURI(aFontURI), mFontSet(aFontSet),
23932:     mChannel(aChannel)
19963: {
75102:   mFontFamily = aProxy->Family();
19963: }
19963: 
19963: nsFontFaceLoader::~nsFontFaceLoader()
19963: {
62296:   if (mLoadTimer) {
62296:     mLoadTimer->Cancel();
62296:     mLoadTimer = nsnull;
62296:   }
23932:   if (mFontSet) {
23932:     mFontSet->RemoveLoader(this);
23932:   }
19963: }
19963: 
62296: void
62296: nsFontFaceLoader::StartedLoading(nsIStreamLoader *aStreamLoader)
62296: {
71641:   PRInt32 loadTimeout =
71641:     Preferences::GetInt("gfx.downloadable_fonts.fallback_delay", 3000);
62296:   if (loadTimeout > 0) {
62296:     mLoadTimer = do_CreateInstance("@mozilla.org/timer;1");
62296:     if (mLoadTimer) {
62296:       mLoadTimer->InitWithFuncCallback(LoadTimerCallback,
62296:                                        static_cast<void*>(this),
62296:                                        loadTimeout,
62296:                                        nsITimer::TYPE_ONE_SHOT);
62296:     }
62296:   } else {
69055:     mFontEntry->mLoadingState = gfxProxyFontEntry::LOADING_SLOWLY;
62296:   }
62296:   mStreamLoader = aStreamLoader;
62296: }
62296: 
62296: void
62296: nsFontFaceLoader::LoadTimerCallback(nsITimer *aTimer, void *aClosure)
62296: {
62296:   nsFontFaceLoader *loader = static_cast<nsFontFaceLoader*>(aClosure);
62296: 
69055:   gfxProxyFontEntry *pe = loader->mFontEntry.get();
62296:   bool updateUserFontSet = true;
62296: 
62296:   // If the entry is loading, check whether it's >75% done; if so,
62296:   // we allow another timeout period before showing a fallback font.
62296:   if (pe->mLoadingState == gfxProxyFontEntry::LOADING_STARTED) {
62296:     PRInt32 contentLength;
62296:     PRUint32 numBytesRead;
77020:     if (NS_SUCCEEDED(loader->mChannel->GetContentLength(&contentLength)) &&
77020:         contentLength > 0 &&
77020:         NS_SUCCEEDED(loader->mStreamLoader->GetNumBytesRead(&numBytesRead)) &&
62296:         numBytesRead > 3 * (PRUint32(contentLength) >> 2))
62296:     {
62296:       // More than 3/4 the data has been downloaded, so allow 50% extra
62296:       // time and hope the remainder will arrive before the additional
62296:       // time expires.
62296:       pe->mLoadingState = gfxProxyFontEntry::LOADING_ALMOST_DONE;
62296:       PRUint32 delay;
62296:       loader->mLoadTimer->GetDelay(&delay);
62296:       loader->mLoadTimer->InitWithFuncCallback(LoadTimerCallback,
62296:                                                static_cast<void*>(loader),
62296:                                                delay >> 1,
62296:                                                nsITimer::TYPE_ONE_SHOT);
62296:       updateUserFontSet = false;
62296:       LOG(("fontdownloader (%p) 75%% done, resetting timer\n", loader));
62296:     }
62296:   }
62296: 
62296:   // If the font is not 75% loaded, or if we've already timed out once
62296:   // before, we mark this entry as "loading slowly", so the fallback
62296:   // font will be used in the meantime, and tell the context to refresh.
62296:   if (updateUserFontSet) {
62296:     pe->mLoadingState = gfxProxyFontEntry::LOADING_SLOWLY;
62296:     nsPresContext *ctx = loader->mFontSet->GetPresContext();
62296:     NS_ASSERTION(ctx, "fontSet doesn't have a presContext?");
62296:     gfxUserFontSet *fontSet;
62296:     if (ctx && (fontSet = ctx->GetUserFontSet()) != nsnull) {
62296:       fontSet->IncrementGeneration();
62296:       ctx->UserFontSetUpdated();
62296:       LOG(("fontdownloader (%p) timeout reflow\n", loader));
62296:     }
62296:   }
62296: }
62296: 
21067: NS_IMPL_ISUPPORTS1(nsFontFaceLoader, nsIStreamLoaderObserver)
19963: 
19963: NS_IMETHODIMP
21067: nsFontFaceLoader::OnStreamComplete(nsIStreamLoader* aLoader,
19963:                                    nsISupports* aContext,
19963:                                    nsresult aStatus,
21067:                                    PRUint32 aStringLen,
21067:                                    const PRUint8* aString)
19963: {
23932:   if (!mFontSet) {
23932:     // We've been canceled
23932:     return aStatus;
23932:   }
23932: 
23932:   mFontSet->RemoveLoader(this);
19963: 
19963: #ifdef PR_LOGGING
19963:   if (LOG_ENABLED()) {
19963:     nsCAutoString fontURI;
19963:     mFontURI->GetSpec(fontURI);
19963:     if (NS_SUCCEEDED(aStatus)) {
19963:       LOG(("fontdownloader (%p) download completed - font uri: (%s)\n", 
19963:            this, fontURI.get()));
19963:     } else {
19963:       LOG(("fontdownloader (%p) download failed - font uri: (%s) error: %8.8x\n", 
19963:            this, fontURI.get(), aStatus));
19963:     }
19963:   }
19963: #endif
19963: 
23932:   nsPresContext *ctx = mFontSet->GetPresContext();
23932:   NS_ASSERTION(ctx && !ctx->PresShell()->IsDestroying(),
23932:                "We should have been canceled already");
22722: 
19963:   // whether an error occurred or not, notify the user font set of the completion
23402:   gfxUserFontSet *userFontSet = ctx->GetUserFontSet();
23402:   if (!userFontSet) {
23402:     return aStatus;
23402:   }
23402: 
73732:   if (NS_SUCCEEDED(aStatus)) {
73732:     // for HTTP requests, check whether the request _actually_ succeeded;
73732:     // the "request status" in aStatus does not necessarily indicate this,
73732:     // because HTTP responses such as 404 (Not Found) will still result in
73732:     // a success code and potentially an HTML error page from the server
73732:     // as the resulting data. We don't want to use that as a font.
82121:     nsCOMPtr<nsIRequest> request;
82121:     nsCOMPtr<nsIHttpChannel> httpChannel;
82121:     aLoader->GetRequest(getter_AddRefs(request));
82121:     httpChannel = do_QueryInterface(request);
73732:     if (httpChannel) {
79445:       bool succeeded;
73732:       nsresult rv = httpChannel->GetRequestSucceeded(&succeeded);
73732:       if (NS_SUCCEEDED(rv) && !succeeded) {
73732:         aStatus = NS_ERROR_NOT_AVAILABLE;
73732:       }
73732:     }
73732:   }
73732: 
32808:   // The userFontSet is responsible for freeing the downloaded data
32808:   // (aString) when finished with it; the pointer is no longer valid
32808:   // after OnLoadComplete returns.
73732:   // This is called even in the case of a failed download (HTTP 404, etc),
73732:   // as there may still be data to be freed (e.g. an error page),
73732:   // and we need the fontSet to initiate loading the next source.
79445:   bool fontUpdate = userFontSet->OnLoadComplete(mFontEntry,
21067:                                                   aString, aStringLen,
19963:                                                   aStatus);
19963: 
19963:   // when new font loaded, need to reflow
19963:   if (fontUpdate) {
21925:     // Update layout for the presence of the new font.  Since this is
21925:     // asynchronous, reflows will coalesce.
22722:     ctx->UserFontSetUpdated();
19963:     LOG(("fontdownloader (%p) reflow\n", this));
19963:   }
19963: 
32808:   return NS_SUCCESS_ADOPTED_DATA;
19963: }
19963: 
23932: void
23932: nsFontFaceLoader::Cancel()
23932: {
69055:   mFontEntry->mLoadingState = gfxProxyFontEntry::NOT_LOADING;
23932:   mFontSet = nsnull;
62296:   if (mLoadTimer) {
62296:     mLoadTimer->Cancel();
62296:     mLoadTimer = nsnull;
62296:   }
23932:   mChannel->Cancel(NS_BINDING_ABORTED);
23932: }
23932: 
21370: nsresult
22722: nsFontFaceLoader::CheckLoadAllowed(nsIPrincipal* aSourcePrincipal,
22722:                                    nsIURI* aTargetURI,
22722:                                    nsISupports* aContext)
22722: {
22722:   nsresult rv;
22722:   
22722:   if (!aSourcePrincipal)
22722:     return NS_OK;
22722: 
42600:   // check with the security manager
42600:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
42600:   rv = secMan->CheckLoadURIWithPrincipal(aSourcePrincipal, aTargetURI,
42600:                                         nsIScriptSecurityManager::STANDARD);
42600:   if (NS_FAILED(rv)) {
42600:     return rv;
42600:   }
42600: 
22722:   // check content policy
22722:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
22722:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_FONT,
22722:                                  aTargetURI,
22722:                                  aSourcePrincipal,
22722:                                  aContext,
22722:                                  EmptyCString(), // mime type
22722:                                  nsnull,
22722:                                  &shouldLoad,
22722:                                  nsContentUtils::GetContentPolicy(),
22722:                                  nsContentUtils::GetSecurityManager());
22722: 
22722:   if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
22722:     return NS_ERROR_CONTENT_BLOCKED;
22722:   }
22722: 
22722:   return NS_OK;
22722: }
22722:   
22722: nsUserFontSet::nsUserFontSet(nsPresContext *aContext)
22722:   : mPresContext(aContext)
22722: {
22722:   NS_ASSERTION(mPresContext, "null context passed to nsUserFontSet");
23932:   mLoaders.Init();
22722: }
22722: 
22722: nsUserFontSet::~nsUserFontSet()
22722: {
23932:   NS_ASSERTION(mLoaders.Count() == 0, "mLoaders should have been emptied");
23932: }
22722: 
23932: static PLDHashOperator DestroyIterator(nsPtrHashKey<nsFontFaceLoader>* aKey,
23932:                                        void* aUserArg)
23932: {
23932:   aKey->GetKey()->Cancel();
23932:   return PL_DHASH_REMOVE;
23932: }
23932: 
23932: void
23932: nsUserFontSet::Destroy()
23932: {
23932:   mPresContext = nsnull;
23932:   mLoaders.EnumerateEntries(DestroyIterator, nsnull);
23932: }
23932: 
23932: void
23932: nsUserFontSet::RemoveLoader(nsFontFaceLoader *aLoader)
23932: {
23932:   mLoaders.RemoveEntry(aLoader);
22722: }
22722: 
22722: nsresult 
69055: nsUserFontSet::StartLoad(gfxProxyFontEntry *aProxy,
22722:                          const gfxFontFaceSrc *aFontFaceSrc)
19963: {
21370:   nsresult rv;
21370:   
19963:   // check same-site origin
22722:   nsIPresShell *ps = mPresContext->PresShell();
19963:   if (!ps)
21370:     return NS_ERROR_FAILURE;
19963:     
21983:   NS_ASSERTION(aFontFaceSrc && !aFontFaceSrc->mIsLocal, 
21983:                "bad font face url passed to fontloader");
21983:   NS_ASSERTION(aFontFaceSrc->mURI, "null font uri");
21983:   if (!aFontFaceSrc->mURI)
21370:     return NS_ERROR_FAILURE;
21370: 
21983:   // use document principal, original principal if flag set
21983:   // this enables user stylesheets to load font files via
21983:   // @font-face rules
21370:   nsCOMPtr<nsIPrincipal> principal = ps->GetDocument()->NodePrincipal();
21370: 
21983:   NS_ASSERTION(aFontFaceSrc->mOriginPrincipal, 
21983:                "null origin principal in @font-face rule");
21983:   if (aFontFaceSrc->mUseOriginPrincipal) {
21983:     principal = do_QueryInterface(aFontFaceSrc->mOriginPrincipal);
21983:   }
21983:   
22722:   rv = nsFontFaceLoader::CheckLoadAllowed(principal, aFontFaceSrc->mURI, 
22722:                                           ps->GetDocument());
21370:   if (NS_FAILED(rv)) {
73711:     LogMessage(aProxy, "download not allowed", nsIScriptError::errorFlag, rv);
21370:     return rv;
21370:   }
19963: 
23932:   nsCOMPtr<nsIStreamLoader> streamLoader;
23932:   nsCOMPtr<nsILoadGroup> loadGroup(ps->GetDocument()->GetDocumentLoadGroup());
23932: 
23932:   nsCOMPtr<nsIChannel> channel;
41211:   // get Content Security Policy from principal to pass into channel
41211:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
41211:   nsCOMPtr<nsIContentSecurityPolicy> csp;
41211:   rv = principal->GetCsp(getter_AddRefs(csp));
41211:   NS_ENSURE_SUCCESS(rv, rv);
41211:   if (csp) {
41211:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
41211:     channelPolicy->SetContentSecurityPolicy(csp);
41211:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_FONT);
41211:   }
23932:   rv = NS_NewChannel(getter_AddRefs(channel),
21983:                      aFontFaceSrc->mURI,
23932:                      nsnull,
23932:                      loadGroup,
23932:                      nsnull,
41211:                      nsIRequest::LOAD_NORMAL,
41211:                      channelPolicy);
23932: 
23932:   NS_ENSURE_SUCCESS(rv, rv);
23932: 
23932:   nsRefPtr<nsFontFaceLoader> fontLoader =
69055:     new nsFontFaceLoader(aProxy, aFontFaceSrc->mURI, this, channel);
23932: 
21067:   if (!fontLoader)
21370:     return NS_ERROR_OUT_OF_MEMORY;
19963: 
21067: #ifdef PR_LOGGING
21067:   if (LOG_ENABLED()) {
21370:     nsCAutoString fontURI, referrerURI;
21983:     aFontFaceSrc->mURI->GetSpec(fontURI);
21983:     if (aFontFaceSrc->mReferrer)
21983:       aFontFaceSrc->mReferrer->GetSpec(referrerURI);
21370:     LOG(("fontdownloader (%p) download start - font uri: (%s) "
21370:          "referrer uri: (%s)\n", 
21370:          fontLoader.get(), fontURI.get(), referrerURI.get()));
21067:   }
21067: #endif  
21067: 
21370:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
21370:   if (httpChannel)
21983:     httpChannel->SetReferrer(aFontFaceSrc->mReferrer);
21370:   rv = NS_NewStreamLoader(getter_AddRefs(streamLoader), fontLoader);
21370:   NS_ENSURE_SUCCESS(rv, rv);
21370:   
79445:   bool inherits = false;
21983:   rv = NS_URIChainHasFlags(aFontFaceSrc->mURI,
21983:                            nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
21983:                            &inherits);
21983:   if (NS_SUCCEEDED(rv) && inherits) {
21983:     // allow data, javascript, etc URI's
21370:     rv = channel->AsyncOpen(streamLoader, nsnull);
21370:   } else {
21370:     nsCOMPtr<nsIStreamListener> listener =
64070:       new nsCORSListenerProxy(streamLoader, principal, channel, 
80486:                               false, &rv);
24480:     if (NS_FAILED(rv)) {
24480:       fontLoader->DropChannel();  // explicitly need to break ref cycle
24480:     }
21370:     NS_ENSURE_TRUE(listener, NS_ERROR_OUT_OF_MEMORY);
21370:     NS_ENSURE_SUCCESS(rv, rv);
21370: 
21370:     rv = channel->AsyncOpen(listener, nsnull);
19963:   }
21067: 
23932:   if (NS_SUCCEEDED(rv)) {
23932:     mLoaders.PutEntry(fontLoader);
62296:     fontLoader->StartedLoading(streamLoader);
23932:   }
23932: 
21370:   return rv;
21370: }
68402: 
89331: static PLDHashOperator DetachFontEntries(const nsAString& aKey,
89331:                                          nsRefPtr<gfxMixedFontFamily>& aFamily,
89331:                                          void* aUserArg)
89331: {
89331:   aFamily->DetachFontEntries();
89331:   return PL_DHASH_NEXT;
89331: }
89331: 
79445: bool
68402: nsUserFontSet::UpdateRules(const nsTArray<nsFontFaceRuleContainer>& aRules)
68402: {
79445:   bool modified = false;
69181: 
69055:   // destroy any current loaders, as the entries they refer to
69055:   // may be about to get replaced
69181:   if (mLoaders.Count() > 0) {
80486:     modified = true; // trigger reflow so that any necessary downloads
69181:                         // will be reinitiated
69181:   }
69055:   mLoaders.EnumerateEntries(DestroyIterator, nsnull);
69055: 
68402:   nsTArray<FontFaceRuleRecord> oldRules;
68402:   mRules.SwapElements(oldRules);
68402: 
68402:   // destroy the font family records; we need to re-create them
68402:   // because we might end up with faces in a different order,
68402:   // even if they're the same font entries as before
89331:   mFontFamilies.Enumerate(DetachFontEntries, nsnull);
68402:   mFontFamilies.Clear();
68402: 
68402:   for (PRUint32 i = 0, i_end = aRules.Length(); i < i_end; ++i) {
68402:     // insert each rule into our list, migrating old font entries if possible
68402:     // rather than creating new ones; set  modified  to true if we detect
68402:     // that rule ordering has changed, or if a new entry is created
68402:     InsertRule(aRules[i].mRule, aRules[i].mSheetType, oldRules, modified);
68402:   }
68402: 
68402:   // if any rules are left in the old list, note that the set has changed
68402:   if (oldRules.Length() > 0) {
80486:     modified = true;
68402:   }
68402: 
68402:   if (modified) {
68402:     IncrementGeneration();
68402:   }
68402: 
68402:   return modified;
68402: }
68402: 
68402: void
68402: nsUserFontSet::InsertRule(nsCSSFontFaceRule *aRule, PRUint8 aSheetType,
68402:                           nsTArray<FontFaceRuleRecord>& aOldRules,
79445:                           bool& aFontSetModified)
68402: {
69440:   NS_ABORT_IF_FALSE(aRule->GetType() == mozilla::css::Rule::FONT_FACE_RULE,
68402:                     "InsertRule passed a non-fontface CSS rule");
68402: 
68402:   // set up family name
68402:   nsAutoString fontfamily;
68402:   nsCSSValue val;
68402:   PRUint32 unit;
68402: 
68402:   aRule->GetDesc(eCSSFontDesc_Family, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_String) {
68402:     val.GetStringValue(fontfamily);
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null,
68402:                  "@font-face family name has unexpected unit");
68402:   }
68402:   if (fontfamily.IsEmpty()) {
68402:     // If there is no family name, this rule cannot contribute a
68402:     // usable font, so there is no point in processing it further.
68402:     return;
68402:   }
68402: 
68402:   // first, we check in oldRules; if the rule exists there, just move it
68402:   // to the new rule list, and put the entry into the appropriate family
68402:   for (PRUint32 i = 0; i < aOldRules.Length(); ++i) {
68402:     const FontFaceRuleRecord& ruleRec = aOldRules[i];
68402:     if (ruleRec.mContainer.mRule == aRule &&
68402:         ruleRec.mContainer.mSheetType == aSheetType) {
68402:       AddFontFace(fontfamily, ruleRec.mFontEntry);
68402:       mRules.AppendElement(ruleRec);
68402:       aOldRules.RemoveElementAt(i);
68402:       // note the set has been modified if an old rule was skipped to find
68402:       // this one - something has been dropped, or ordering changed
68402:       if (i > 0) {
80486:         aFontSetModified = true;
68402:       }
68402:       return;
68402:     }
68402:   }
68402: 
68402:   // this is a new rule:
68402: 
68402:   PRUint32 weight = NS_STYLE_FONT_WEIGHT_NORMAL;
68402:   PRUint32 stretch = NS_STYLE_FONT_STRETCH_NORMAL;
68402:   PRUint32 italicStyle = FONT_STYLE_NORMAL;
68402:   nsString featureSettings, languageOverride;
68402: 
68402:   // set up weight
68402:   aRule->GetDesc(eCSSFontDesc_Weight, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_Integer || unit == eCSSUnit_Enumerated) {
68402:     weight = val.GetIntValue();
68402:   } else if (unit == eCSSUnit_Normal) {
68402:     weight = NS_STYLE_FONT_WEIGHT_NORMAL;
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null,
68402:                  "@font-face weight has unexpected unit");
68402:   }
68402: 
68402:   // set up stretch
68402:   aRule->GetDesc(eCSSFontDesc_Stretch, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_Enumerated) {
68402:     stretch = val.GetIntValue();
68402:   } else if (unit == eCSSUnit_Normal) {
68402:     stretch = NS_STYLE_FONT_STRETCH_NORMAL;
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null,
68402:                  "@font-face stretch has unexpected unit");
68402:   }
68402: 
68402:   // set up font style
68402:   aRule->GetDesc(eCSSFontDesc_Style, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_Enumerated) {
68402:     italicStyle = val.GetIntValue();
68402:   } else if (unit == eCSSUnit_Normal) {
68402:     italicStyle = FONT_STYLE_NORMAL;
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null,
68402:                  "@font-face style has unexpected unit");
68402:   }
68402: 
68402:   // set up font features
68402:   aRule->GetDesc(eCSSFontDesc_FontFeatureSettings, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_Normal) {
68402:     // empty feature string
68402:   } else if (unit == eCSSUnit_String) {
68402:     val.GetStringValue(featureSettings);
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null,
68402:                  "@font-face font-feature-settings has unexpected unit");
68402:   }
68402: 
68402:   // set up font language override
68402:   aRule->GetDesc(eCSSFontDesc_FontLanguageOverride, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_Normal) {
68402:     // empty feature string
68402:   } else if (unit == eCSSUnit_String) {
68402:     val.GetStringValue(languageOverride);
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null,
68402:                  "@font-face font-language-override has unexpected unit");
68402:   }
68402: 
68402:   // set up src array
68402:   nsTArray<gfxFontFaceSrc> srcArray;
68402: 
68402:   aRule->GetDesc(eCSSFontDesc_Src, val);
68402:   unit = val.GetUnit();
68402:   if (unit == eCSSUnit_Array) {
68402:     nsCSSValue::Array *srcArr = val.GetArrayValue();
68402:     size_t numSrc = srcArr->Count();
68402:     
68402:     for (size_t i = 0; i < numSrc; i++) {
68402:       val = srcArr->Item(i);
68402:       unit = val.GetUnit();
68402:       gfxFontFaceSrc *face = srcArray.AppendElements(1);
68402:       if (!face)
68402:         return;
68402: 
68402:       switch (unit) {
68402: 
68402:       case eCSSUnit_Local_Font:
68402:         val.GetStringValue(face->mLocalName);
80486:         face->mIsLocal = true;
68402:         face->mURI = nsnull;
68402:         face->mFormatFlags = 0;
68402:         break;
68402:       case eCSSUnit_URL:
80486:         face->mIsLocal = false;
68402:         face->mURI = val.GetURLValue();
68402:         NS_ASSERTION(face->mURI, "null url in @font-face rule");
68402:         face->mReferrer = val.GetURLStructValue()->mReferrer;
68402:         face->mOriginPrincipal = val.GetURLStructValue()->mOriginPrincipal;
68402:         NS_ASSERTION(face->mOriginPrincipal, "null origin principal in @font-face rule");
68402: 
68402:         // agent and user stylesheets are treated slightly differently,
68402:         // the same-site origin check and access control headers are
68402:         // enforced against the sheet principal rather than the document
68402:         // principal to allow user stylesheets to include @font-face rules
68402:         face->mUseOriginPrincipal = (aSheetType == nsStyleSet::eUserSheet ||
68402:                                      aSheetType == nsStyleSet::eAgentSheet);
68402: 
68402:         face->mLocalName.Truncate();
68402:         face->mFormatFlags = 0;
68402:         while (i + 1 < numSrc && (val = srcArr->Item(i+1), 
68402:                  val.GetUnit() == eCSSUnit_Font_Format)) {
68402:           nsDependentString valueString(val.GetStringBufferValue());
68402:           if (valueString.LowerCaseEqualsASCII("woff")) {
68402:             face->mFormatFlags |= FLAG_FORMAT_WOFF;
68402:           } else if (valueString.LowerCaseEqualsASCII("opentype")) {
68402:             face->mFormatFlags |= FLAG_FORMAT_OPENTYPE;
68402:           } else if (valueString.LowerCaseEqualsASCII("truetype")) {
68402:             face->mFormatFlags |= FLAG_FORMAT_TRUETYPE;
68402:           } else if (valueString.LowerCaseEqualsASCII("truetype-aat")) {
68402:             face->mFormatFlags |= FLAG_FORMAT_TRUETYPE_AAT;
68402:           } else if (valueString.LowerCaseEqualsASCII("embedded-opentype")) {
68402:             face->mFormatFlags |= FLAG_FORMAT_EOT;
68402:           } else if (valueString.LowerCaseEqualsASCII("svg")) {
68402:             face->mFormatFlags |= FLAG_FORMAT_SVG;
68402:           } else {
68402:             // unknown format specified, mark to distinguish from the
68402:             // case where no format hints are specified
68402:             face->mFormatFlags |= FLAG_FORMAT_UNKNOWN;
68402:           }
68402:           i++;
68402:         }
68402:         break;
68402:       default:
68402:         NS_ASSERTION(unit == eCSSUnit_Local_Font || unit == eCSSUnit_URL,
68402:                      "strange unit type in font-face src array");
68402:         break;
68402:       }
68402:      }
68402:   } else {
68402:     NS_ASSERTION(unit == eCSSUnit_Null, "@font-face src has unexpected unit");
68402:   }
68402: 
68402:   if (srcArray.Length() > 0) {
68402:     FontFaceRuleRecord ruleRec;
68402:     ruleRec.mContainer.mRule = aRule;
68402:     ruleRec.mContainer.mSheetType = aSheetType;
68402:     ruleRec.mFontEntry = AddFontFace(fontfamily, srcArray,
68402:                                      weight, stretch, italicStyle,
68402:                                      featureSettings, languageOverride);
68402:     if (ruleRec.mFontEntry) {
68402:       mRules.AppendElement(ruleRec);
68402:     }
68402:     // this was a new rule and fontEntry, so note that the set was modified
80486:     aFontSetModified = true;
68402:   }
68402: }
68402: 
68402: void
68402: nsUserFontSet::ReplaceFontEntry(gfxProxyFontEntry *aProxy,
68402:                                 gfxFontEntry *aFontEntry)
68402: {
68402:   for (PRUint32 i = 0; i < mRules.Length(); ++i) {
68402:     if (mRules[i].mFontEntry == aProxy) {
68402:       mRules[i].mFontEntry = aFontEntry;
68402:       break;
68402:     }
68402:   }
89489:   gfxMixedFontFamily *family =
89489:     static_cast<gfxMixedFontFamily*>(aProxy->Family());
89489:   if (family) {
89489:     family->ReplaceFontEntry(aProxy, aFontEntry);
89489:   }
68402: }
71909: 
71909: nsCSSFontFaceRule*
71909: nsUserFontSet::FindRuleForEntry(gfxFontEntry *aFontEntry)
71909: {
71909:   for (PRUint32 i = 0; i < mRules.Length(); ++i) {
71909:     if (mRules[i].mFontEntry == aFontEntry) {
71909:       return mRules[i].mContainer.mRule;
71909:     }
71909:   }
71909:   return nsnull;
71909: }
73711: 
73711: nsresult
73711: nsUserFontSet::LogMessage(gfxProxyFontEntry *aProxy,
73711:                           const char        *aMessage,
73711:                           PRUint32          aFlags,
73711:                           nsresult          aStatus)
73711: {
73711:   nsCOMPtr<nsIConsoleService>
73711:     console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
73711:   if (!console) {
73711:     return NS_ERROR_NOT_AVAILABLE;
73711:   }
73711: 
73711:   NS_ConvertUTF16toUTF8 familyName(aProxy->FamilyName());
73711:   nsCAutoString fontURI;
86676:   if (aProxy->mSrcIndex == aProxy->mSrcList.Length()) {
86676:     fontURI.AppendLiteral("(end of source list)");
86676:   } else {
73916:     if (aProxy->mSrcList[aProxy->mSrcIndex].mURI) {
73711:       aProxy->mSrcList[aProxy->mSrcIndex].mURI->GetSpec(fontURI);
73916:     } else {
73916:       fontURI.AppendLiteral("(invalid URI)");
73916:     }
86676:   }
73711: 
73711:   char weightKeywordBuf[8]; // plenty to sprintf() a PRUint16
73711:   const char *weightKeyword;
73711:   const nsAFlatCString& weightKeywordString =
73711:     nsCSSProps::ValueToKeyword(aProxy->Weight(),
73711:                                nsCSSProps::kFontWeightKTable);
73711:   if (weightKeywordString.Length() > 0) {
73711:     weightKeyword = weightKeywordString.get();
73711:   } else {
73711:     sprintf(weightKeywordBuf, "%u", aProxy->Weight());
73711:     weightKeyword = weightKeywordBuf;
73711:   }
73711: 
73711:   nsPrintfCString
73711:     msg(1024,
73711:         "downloadable font: %s "
73711:         "(font-family: \"%s\" style:%s weight:%s stretch:%s src index:%d)",
73711:         aMessage,
73711:         familyName.get(),
73711:         aProxy->IsItalic() ? "italic" : "normal",
73711:         weightKeyword,
73711:         nsCSSProps::ValueToKeyword(aProxy->Stretch(),
73711:                                    nsCSSProps::kFontStretchKTable).get(),
73711:         aProxy->mSrcIndex);
73711: 
73711:   if (aStatus != 0) {
73711:     msg.Append(": ");
73711:     switch (aStatus) {
73711:     case NS_ERROR_DOM_BAD_URI:
73711:       msg.Append("bad URI or cross-site access not allowed");
73711:       break;
73711:     case NS_ERROR_CONTENT_BLOCKED:
73711:       msg.Append("content blocked");
73711:       break;
73711:     default:
73711:       msg.Append("status=");
73711:       msg.AppendInt(aStatus);
73711:       break;
73711:     }
73711:   }
73711:   msg.Append("\nsource: ");
73711:   msg.Append(fontURI);
73711: 
73711: #ifdef PR_LOGGING
73711:   if (PR_LOG_TEST(sUserFontsLog, PR_LOG_DEBUG)) {
73711:     PR_LOG(sUserFontsLog, PR_LOG_DEBUG,
73711:            ("userfonts (%p) %s", this, msg.get()));
73711:   }
73711: #endif
73711: 
73711:   // try to give the user an indication of where the rule came from
73711:   nsCSSFontFaceRule* rule = FindRuleForEntry(aProxy);
73711:   nsString href;
73711:   nsString text;
73711:   nsresult rv;
73711:   if (rule) {
73711:     rv = rule->GetCssText(text);
73711:     NS_ENSURE_SUCCESS(rv, rv);
73711:     nsCOMPtr<nsIDOMCSSStyleSheet> sheet;
73711:     rv = rule->GetParentStyleSheet(getter_AddRefs(sheet));
73711:     NS_ENSURE_SUCCESS(rv, rv);
73711:     rv = sheet->GetHref(href);
73711:     NS_ENSURE_SUCCESS(rv, rv);
73711:   }
73711: 
86030:   nsCOMPtr<nsIScriptError> scriptError =
73711:     do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
73711:   NS_ENSURE_SUCCESS(rv, rv);
73711: 
77330:   PRUint64 innerWindowID = GetPresContext()->Document()->InnerWindowID();
73711:   rv = scriptError->InitWithWindowID(NS_ConvertUTF8toUTF16(msg).get(),
73711:                                      href.get(),   // file
73711:                                      text.get(),   // src line
73711:                                      0, 0,         // line & column number
73711:                                      aFlags,       // flags
73711:                                      "CSS Loader", // category (make separate?)
77330:                                      innerWindowID);
73711:   if (NS_SUCCEEDED(rv)) {
86030:     console->LogMessage(scriptError);
73711:   }
73711: 
73711:   return NS_OK;
73711: }
