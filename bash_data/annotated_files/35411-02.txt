11302: //* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
 5909:  * The Original Code is Mozilla History System.
    1:  *
 5909:  * The Initial Developer of the Original Code is Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com> (original author)
 5909:  *   Dietrich Ayala <dietrich@mozilla.com>
 5909:  *   Seth Spitzer <sspitzer@mozilla.com>
 5909:  *   Asaf Romano <mano@mozilla.com>
17044:  *   Marco Bonardo <mak77@bonardo.net>
12214:  *   Edward Lee <edward.lee@engineering.uiuc.edu>
20637:  *   Michael Ventnor <m.ventnor@gmail.com>
20637:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
27981:  *   Drew Willcoxon <adw@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <stdio.h>
34766: 
    1: #include "nsNavHistory.h"
34766: 
23904: #include "nsTArray.h"
    1: #include "nsCollationCID.h"
    1: #include "nsILocaleService.h"
    1: #include "nsIPrefBranch2.h"
34766: 
    1: #include "nsNetUtil.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsPromiseFlatString.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "prsystem.h"
    1: #include "prtime.h"
 2597: #include "nsEscape.h"
11302: #include "nsIEffectiveTLDService.h"
18819: #include "nsIClassInfoImpl.h"
18819: #include "nsThreadUtils.h"
    1: #include "nsAppDirectoryServiceDefs.h"
34766: #include "nsMathUtils.h"
34766: 
34766: #include "nsNavBookmarks.h"
34766: #include "nsAnnotationService.h"
34766: #include "nsILivemarkService.h"
34766: #include "nsFaviconService.h"
34766: 
34766: #include "nsPlacesTables.h"
34766: #include "nsPlacesIndexes.h"
34766: #include "nsPlacesTriggers.h"
34766: #include "nsPlacesMacros.h"
34766: #include "SQLFunctions.h"
34766: #include "Helpers.h"
30902: 
30902: #ifdef MOZ_XUL
30902: #include "nsIAutoCompleteInput.h"
30902: #include "nsIAutoCompletePopup.h"
30902: #endif
10669: 
30902: using namespace mozilla::places;
30902: 
    1: // Microsecond timeout for "recent" events such as typed and bookmark following.
    1: // If you typed it more than this time ago, it's not recent.
    1: // This is 15 minutes           m    s/m  us/s
22328: #define RECENT_EVENT_THRESHOLD (15 * 60 * PR_USEC_PER_SEC)
    1: 
    1: // Microseconds ago to look for redirects when updating bookmarks. Used to
    1: // compute the threshold for nsNavBookmarks::AddBookmarkToHash
22328: #define BOOKMARK_REDIRECT_TIME_THRESHOLD (2 * 60 * PR_USEC_PER_SEC)
    1: 
    1: // The maximum number of things that we will store in the recent events list
    1: // before calling ExpireNonrecentEvents. This number should be big enough so it
    1: // is very difficult to get that many unconsumed events (for example, typed but
    1: // never visited) in the RECENT_EVENT_THRESHOLD. Otherwise, we'll start
    1: // checking each one for every page visit, which will be somewhat slower.
    1: #define RECENT_EVENT_QUEUE_MAX_LENGTH 128
    1: 
    1: // preference ID strings
    1: #define PREF_BRANCH_BASE                        "browser."
 8761: #define PREF_BROWSER_HISTORY_EXPIRE_DAYS_MIN    "history_expire_days_min"
 8761: #define PREF_BROWSER_HISTORY_EXPIRE_DAYS_MAX    "history_expire_days"
 8761: #define PREF_BROWSER_HISTORY_EXPIRE_SITES       "history_expire_sites"
    1: #define PREF_DB_CACHE_PERCENTAGE                "history_cache_percentage"
10669: #define PREF_FRECENCY_NUM_VISITS                "places.frecency.numVisits"
10669: #define PREF_FRECENCY_FIRST_BUCKET_CUTOFF       "places.frecency.firstBucketCutoff"
10669: #define PREF_FRECENCY_SECOND_BUCKET_CUTOFF      "places.frecency.secondBucketCutoff"
10669: #define PREF_FRECENCY_THIRD_BUCKET_CUTOFF       "places.frecency.thirdBucketCutoff"
10669: #define PREF_FRECENCY_FOURTH_BUCKET_CUTOFF      "places.frecency.fourthBucketCutoff"
10669: #define PREF_FRECENCY_FIRST_BUCKET_WEIGHT       "places.frecency.firstBucketWeight"
10669: #define PREF_FRECENCY_SECOND_BUCKET_WEIGHT      "places.frecency.secondBucketWeight"
10669: #define PREF_FRECENCY_THIRD_BUCKET_WEIGHT       "places.frecency.thirdBucketWeight"
10669: #define PREF_FRECENCY_FOURTH_BUCKET_WEIGHT      "places.frecency.fourthBucketWeight"
10669: #define PREF_FRECENCY_DEFAULT_BUCKET_WEIGHT     "places.frecency.defaultBucketWeight"
10669: #define PREF_FRECENCY_EMBED_VISIT_BONUS         "places.frecency.embedVisitBonus"
10669: #define PREF_FRECENCY_LINK_VISIT_BONUS          "places.frecency.linkVisitBonus"
10669: #define PREF_FRECENCY_TYPED_VISIT_BONUS         "places.frecency.typedVisitBonus"
10669: #define PREF_FRECENCY_BOOKMARK_VISIT_BONUS      "places.frecency.bookmarkVisitBonus"
10669: #define PREF_FRECENCY_DOWNLOAD_VISIT_BONUS      "places.frecency.downloadVisitBonus"
10669: #define PREF_FRECENCY_PERM_REDIRECT_VISIT_BONUS "places.frecency.permRedirectVisitBonus"
10669: #define PREF_FRECENCY_TEMP_REDIRECT_VISIT_BONUS "places.frecency.tempRedirectVisitBonus"
10669: #define PREF_FRECENCY_DEFAULT_VISIT_BONUS       "places.frecency.defaultVisitBonus"
10669: #define PREF_FRECENCY_UNVISITED_BOOKMARK_BONUS  "places.frecency.unvisitedBookmarkBonus"
10669: #define PREF_FRECENCY_UNVISITED_TYPED_BONUS     "places.frecency.unvisitedTypedBonus"
32454: #define PREF_LAST_VACUUM                        "places.last_vacuum"
30902: 
    1: // Default (integer) value of PREF_DB_CACHE_PERCENTAGE from 0-100
    1: // This is 6% of machine memory, giving 15MB for a user with 256MB of memory.
    1: // The most that will be used is the size of the DB file. Normal history sizes
    1: // look like 10MB would be a high average for a typical user, so the maximum
    1: // should not normally be required.
    1: #define DEFAULT_DB_CACHE_PERCENTAGE 6
    1: 
 7275: // We set the default database page size to be larger. sqlite's default is 1K.
 7275: // This gives good performance when many small parts of the file have to be
 7275: // loaded for each statement. Because we try to keep large chunks of the file
 7275: // in memory, a larger page size should give better I/O performance. 32K is
 7275: // sqlite's default max page size.
 7275: #define DEFAULT_DB_PAGE_SIZE 4096
    1: 
    1: // the value of mLastNow expires every 3 seconds
    1: #define HISTORY_EXPIRE_NOW_TIMEOUT (3 * PR_MSEC_PER_SEC)
    1: 
    1: // see bug #319004 -- clamp title and URL to generously-large but not too large
    1: // length
    1: #define HISTORY_URI_LENGTH_MAX 65536
    1: #define HISTORY_TITLE_LENGTH_MAX 4096
    1: 
 2031: // db file name
 2031: #define DB_FILENAME NS_LITERAL_STRING("places.sqlite")
 2031: 
 2874: // db backup file name
 2874: #define DB_CORRUPT_FILENAME NS_LITERAL_STRING("places.sqlite.corrupt")
 2874: 
    1: // Lazy adding
    1: 
    1: #ifdef LAZY_ADD
    1: 
    1: // time that we'll wait before committing messages
    1: #define LAZY_MESSAGE_TIMEOUT (3 * PR_MSEC_PER_SEC)
    1: 
    1: // the maximum number of times we'll postpone a lazy timer before committing
    1: // See StartLazyTimer()
    1: #define MAX_LAZY_TIMER_DEFERMENTS 2
    1: 
    1: #endif // LAZY_ADD
    1: 
 8240: // Limit the number of items in the history for performance reasons
 8761: #define EXPIRATION_CAP_SITES 40000
 8240: 
14062: // character-set annotation
14062: #define CHARSET_ANNO NS_LITERAL_CSTRING("URIProperties/characterSet")
14062: 
28350: // We use the TRUNCATE journal mode to reduce the number of fsyncs.  Without
28350: // this setting we had a Ts hit on Linux.  See bug 460315 for details.
28350: #define DEFAULT_JOURNAL_MODE "TRUNCATE"
28350: 
28514: // These macros are used when splitting history by date.
28514: // These are the day containers and catch-all final container.
28514: #define ADDITIONAL_DATE_CONT_NUM 3
28514: // We use a guess of the number of months considering all of them 30 days
28514: // long, but we split only the last 6 months.
28514: #define DATE_CONT_NUM(_expireDays) \
28514:   (ADDITIONAL_DATE_CONT_NUM + PR_MIN(6, (_expireDays/30)))
28514: 
32454: // fraction of free pages in the database to force a vacuum between
32454: // MAX_TIME_BEFORE_VACUUM and MIN_TIME_BEFORE_VACUUM.
32454: #define VACUUM_FREEPAGES_THRESHOLD 0.1
32454: // This is the maximum time (in microseconds) that can pass between 2 VACUUM
32454: // operations.
32454: #define MAX_TIME_BEFORE_VACUUM (PRInt64)60 * 24 * 60 * 60 * 1000 * 1000
32454: // This is the minimum time (in microseconds) that should pass between 2 VACUUM
32454: // operations.
32454: #define MIN_TIME_BEFORE_VACUUM (PRInt64)30 * 24 * 60 * 60 * 1000 * 1000
32454: 
17109: NS_IMPL_THREADSAFE_ADDREF(nsNavHistory)
17109: NS_IMPL_THREADSAFE_RELEASE(nsNavHistory)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsNavHistory)
    1:   NS_INTERFACE_MAP_ENTRY(nsINavHistoryService)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIGlobalHistory2, nsIGlobalHistory3)
    1:   NS_INTERFACE_MAP_ENTRY(nsIGlobalHistory3)
 9621:   NS_INTERFACE_MAP_ENTRY(nsIDownloadHistory)
    1:   NS_INTERFACE_MAP_ENTRY(nsIBrowserHistory)
    1:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
14062:   NS_INTERFACE_MAP_ENTRY(nsICharsetResolver)
16749:   NS_INTERFACE_MAP_ENTRY(nsPIPlacesDatabase)
25698:   NS_INTERFACE_MAP_ENTRY(nsPIPlacesHistoryListenersNotifier)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsINavHistoryService)
18819:   NS_IMPL_QUERY_CLASSINFO(nsNavHistory)
    1: NS_INTERFACE_MAP_END
    1: 
18819: // We don't care about flattening everything
18819: NS_IMPL_CI_INTERFACE_GETTER5(
18819:   nsNavHistory
18819: , nsINavHistoryService
18819: , nsIGlobalHistory3
18819: , nsIGlobalHistory2
18819: , nsIDownloadHistory
18819: , nsIBrowserHistory
18819: )
18819: 
    1: static nsresult GetReversedHostname(nsIURI* aURI, nsAString& host);
    1: static void GetReversedHostname(const nsString& aForward, nsAString& aReversed);
    1: static PRInt64 GetSimpleBookmarksQueryFolder(
  809:     const nsCOMArray<nsNavHistoryQuery>& aQueries,
  809:     nsNavHistoryQueryOptions* aOptions);
 5909: static void ParseSearchTermsFromQueries(const nsCOMArray<nsNavHistoryQuery>& aQueries,
23904:                                         nsTArray<nsTArray<nsString>*>* aTerms);
    1: 
    1: inline void ReverseString(const nsString& aInput, nsAString& aReversed)
    1: {
    1:   aReversed.Truncate(0);
    1:   for (PRInt32 i = aInput.Length() - 1; i >= 0; i --)
    1:     aReversed.Append(aInput[i]);
    1: }
    1: 
28515: namespace mozilla {
28515:   namespace places {
28515: 
28515:     bool hasRecentCorruptDB()
28515:     {
28515:       nsCOMPtr<nsIFile> profDir;
28515:       nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
28515:                                            getter_AddRefs(profDir));
28515:       NS_ENSURE_SUCCESS(rv, false);
28515:       nsCOMPtr<nsISimpleEnumerator> entries;
28515:       rv = profDir->GetDirectoryEntries(getter_AddRefs(entries));
28515:       NS_ENSURE_SUCCESS(rv, false);
28515:       PRBool hasMore;
28515:       while (NS_SUCCEEDED(entries->HasMoreElements(&hasMore)) && hasMore) {
28515:         nsCOMPtr<nsISupports> next;
28515:         rv = entries->GetNext(getter_AddRefs(next));
28515:         NS_ENSURE_SUCCESS(rv, false);
28515:         nsCOMPtr<nsIFile> currFile = do_QueryInterface(next, &rv);
28515:         NS_ENSURE_SUCCESS(rv, false);
28515: 
28515:         nsAutoString leafName;
28515:         rv = currFile->GetLeafName(leafName);
28515:         NS_ENSURE_SUCCESS(rv, false);
28515:         if (leafName.Length() >= DB_CORRUPT_FILENAME.Length() &&
28515:             leafName.Find(".corrupt", DB_FILENAME.Length()) != -1) {
28515:           PRInt64 lastMod;
28515:           rv = currFile->GetLastModifiedTime(&lastMod);
28515:           NS_ENSURE_SUCCESS(rv, false);
28515:           if (PR_Now() - lastMod > (PRInt64)24 * 60 * 60 * 1000 * 1000)
28515:            return true;
28515:         }
28515:       }
28515:       return false;
28515:     }
28515: 
33458:     void GetTagsSqlFragment(PRInt64 aTagsFolder,
33458:                             const nsACString& aRelation,
33458:                             PRBool aHasSearchTerms,
33458:                             nsACString& _sqlFragment) {
33458:       if (!aHasSearchTerms)
33458:         _sqlFragment.AssignLiteral("null");
33458:       else {
33458:         _sqlFragment.Assign(NS_LITERAL_CSTRING(
33458:              "(SELECT GROUP_CONCAT(tag_title, ', ') "
33458:               "FROM ( "
33458:                 "SELECT t_t.title AS tag_title "
33458:                 "FROM moz_bookmarks b_t "
33458:                 "JOIN moz_bookmarks t_t ON t_t.id = b_t.parent  "
33458:                 "WHERE b_t.fk = ") +
33458:                 aRelation + NS_LITERAL_CSTRING(" "
33458:                 "AND LENGTH(t_t.title) > 0 "
33458:                 "AND t_t.parent = ") +
33458:                 nsPrintfCString("%lld", aTagsFolder) + NS_LITERAL_CSTRING(" "
33458:                 "ORDER BY t_t.title COLLATE NOCASE ASC "
33458:               ") "
33458:              ")"));
33458:       }
33458: 
33458:       _sqlFragment.AppendLiteral(" AS tags ");
33458:     }
33458: 
28515:   }
28515: }
28515: 
    1: // UpdateBatchScoper
    1: //
    1: //    This just sets begin/end of batch updates to correspond to C++ scopes so
    1: //    we can be sure end always gets called.
    1: 
    1: class UpdateBatchScoper
    1: {
    1: public:
    1:   UpdateBatchScoper(nsNavHistory& aNavHistory) : mNavHistory(aNavHistory)
    1:   {
    1:     mNavHistory.BeginUpdateBatch();
    1:   }
    1:   ~UpdateBatchScoper()
    1:   {
    1:     mNavHistory.EndUpdateBatch();
    1:   }
    1: protected:
    1:   nsNavHistory& mNavHistory;
    1: };
    1: 
23189: class PlacesEvent : public nsRunnable {
21600:   public:
23189:   PlacesEvent(const char* aTopic) {
23189:     mTopic = aTopic;
23189:   }
23189: 
21600:   NS_IMETHOD Run() {
21600:     nsresult rv;
21600:     nsCOMPtr<nsIObserverService> observerService =
21600:       do_GetService("@mozilla.org/observer-service;1", &rv);
21600:     NS_ENSURE_SUCCESS(rv, rv);
21600: 
23189:     rv = observerService->NotifyObservers(nsnull, mTopic, nsnull);
21600:     NS_ENSURE_SUCCESS(rv, rv);
21600: 
21600:     return NS_OK;
21600:   }
23189:   protected:
23189:   const char* mTopic;
21600: };
21600: 
    1: // if adding a new one, be sure to update nsNavBookmarks statements and
    1: // its kGetChildrenIndex_* constants
    1: const PRInt32 nsNavHistory::kGetInfoIndex_PageID = 0;
    1: const PRInt32 nsNavHistory::kGetInfoIndex_URL = 1;
    1: const PRInt32 nsNavHistory::kGetInfoIndex_Title = 2;
  809: const PRInt32 nsNavHistory::kGetInfoIndex_RevHost = 3;
  809: const PRInt32 nsNavHistory::kGetInfoIndex_VisitCount = 4;
  809: const PRInt32 nsNavHistory::kGetInfoIndex_VisitDate = 5;
  809: const PRInt32 nsNavHistory::kGetInfoIndex_FaviconURL = 6;
  809: const PRInt32 nsNavHistory::kGetInfoIndex_SessionId = 7;
 1337: const PRInt32 nsNavHistory::kGetInfoIndex_ItemId = 8;
 1604: const PRInt32 nsNavHistory::kGetInfoIndex_ItemDateAdded = 9;
 1604: const PRInt32 nsNavHistory::kGetInfoIndex_ItemLastModified = 10;
33458: const PRInt32 nsNavHistory::kGetInfoIndex_ItemParentId = 11;
33458: const PRInt32 nsNavHistory::kGetInfoIndex_ItemTags = 12;
    1: 
22574: 
    1: static const char* gXpcomShutdown = "xpcom-shutdown";
12214: static const char* gAutoCompleteFeedback = "autocomplete-will-enter-text";
24756: static const char* gIdleDaily = "idle-daily";
    1: 
    1: // annotation names
    1: const char nsNavHistory::kAnnotationPreviousEncoding[] = "history/encoding";
    1: 
12387: // code borrowed from mozilla/xpfe/components/history/src/nsGlobalHistory.cpp
12387: // pass in a pre-normalized now and a date, and we'll find
12387: // the difference since midnight on each of the days.
12387: //
12387: // USECS_PER_DAY == PR_USEC_PER_SEC * 60 * 60 * 24;
12387: static const PRInt64 USECS_PER_DAY = LL_INIT(20, 500654080);
    1: 
35298: PLACES_FACTORY_SINGLETON_IMPLEMENTATION(nsNavHistory, gHistoryService)
    1: 
    1: // nsNavHistory::nsNavHistory
    1: 
12001: nsNavHistory::nsNavHistory() : mBatchLevel(0),
12001:                                mBatchHasTransaction(PR_FALSE),
12001:                                mNowValid(PR_FALSE),
    1:                                mExpireNowTimer(nsnull),
 8761:                                mExpireDaysMin(0),
 8761:                                mExpireDaysMax(0),
 8761:                                mExpireSites(0),
11646:                                mNumVisitsForFrecency(10),
20637:                                mTagsFolder(-1),
21600:                                mInPrivateBrowsing(PRIVATEBROWSING_NOTINITED),
30050:                                mDatabaseStatus(DATABASE_STATUS_OK),
30050:                                mCanNotify(true),
30050:                                mCacheObservers("history-observers")
    1: {
    1: #ifdef LAZY_ADD
    1:   mLazyTimerSet = PR_TRUE;
    1:   mLazyTimerDeferments = 0;
    1: #endif
35298:   NS_ASSERTION(!gHistoryService,
35298:                "Attempting to create two instances of the service!");
    1:   gHistoryService = this;
    1: }
    1: 
    1: // nsNavHistory::~nsNavHistory
    1: 
    1: nsNavHistory::~nsNavHistory()
    1: {
    1:   // remove the static reference to the service. Check to make sure its us
    1:   // in case somebody creates an extra instance of the service.
35298:   NS_ASSERTION(gHistoryService == this,
35298:                "Deleting a non-singleton instance of the service");
35298:   if (gHistoryService == this)
    1:     gHistoryService = nsnull;
    1: }
    1: 
    1: 
    1: // nsNavHistory::Init
    1: 
    1: nsresult
    1: nsNavHistory::Init()
    1: {
    1:   nsresult rv;
    1: 
    1:   // prefs (must be before DB init, which uses the pref service)
    1:   nsCOMPtr<nsIPrefService> prefService =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = prefService->GetBranch(PREF_BRANCH_BASE, getter_AddRefs(mPrefBranch));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10669:   // prefs
10669:   LoadPrefs(PR_TRUE);
10669: 
28515:   // Init the database file.  If we won't be able to connect to the database it
28515:   // is most likely corrupt, so we will backup it and create a new one.
 2874:   rv = InitDBFile(PR_FALSE);
 2874:   NS_ENSURE_SUCCESS(rv, rv);
 2874: 
28515:   // Init the database schema.  If this will fail there's an high possibility
28515:   // the schema is corrupt or incorrect, so we will force a new database
28515:   // initialization.
23197:   rv = InitDB();
 2874:   if (NS_FAILED(rv)) {
28515:     // Forced InitDBFile will backup the old db and create a new one.
 2874:     rv = InitDBFile(PR_TRUE);
 2874:     NS_ENSURE_SUCCESS(rv, rv);
28515:     // Try to initialize the schema again on the new database.
23197:     rv = InitDB();
 2874:   }
 2874:   NS_ENSURE_SUCCESS(rv, rv);
 2874: 
28515:   // Initialize all the items that are not part of the on-disk database, like
28515:   // views, temp tables, functions.  Do not initialize these in InitDBFile, or
28515:   // in case of failure we would mark the database as corrupt and try to
28515:   // replace it, even if it's sane.
28515:   rv = InitAdditionalDBItems();
28515:   NS_ENSURE_SUCCESS(rv, rv);
28515: 
33704:   // Initialize expiration.  There's no need to do this before, since just now
33704:   // we have a valid database and a working connection.
33704:   mExpire = new nsNavHistoryExpire();
33704: 
28515:   // Notify we have finished database initialization.
21600:   // Enqueue the notification, so if we init another service that requires
21600:   // nsNavHistoryService we don't recursive try to get it.
28515:   nsRefPtr<PlacesEvent> completeEvent =
32454:     new PlacesEvent(PLACES_INIT_COMPLETE_TOPIC);
21600:   rv = NS_DispatchToMainThread(completeEvent);
21600:   NS_ENSURE_SUCCESS(rv, rv);
21600: 
    1:   // extract the last session ID so we know where to pick up. There is no index
    1:   // over sessions so the naive statement "SELECT MAX(session) FROM
28350:   // moz_historyvisits" won't have good performance.
20868:   // This is long before we use our temporary tables, so we do not have to join
20868:   // on moz_historyvisits_temp to get the right result here.
    1:   {
    1:     nsCOMPtr<mozIStorageStatement> selectSession;
    1:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
28350:         "SELECT session FROM moz_historyvisits "
28350:         "ORDER BY visit_date DESC LIMIT 1"),
    1:       getter_AddRefs(selectSession));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     PRBool hasSession;
    1:     if (NS_SUCCEEDED(selectSession->ExecuteStep(&hasSession)) && hasSession)
    1:       mLastSessionID = selectSession->AsInt64(0);
    1:     else
    1:       mLastSessionID = 1;
    1:   }
    1: 
    1:   // recent events hash tables
    1:   NS_ENSURE_TRUE(mRecentTyped.Init(128), NS_ERROR_OUT_OF_MEMORY);
    1:   NS_ENSURE_TRUE(mRecentBookmark.Init(128), NS_ERROR_OUT_OF_MEMORY);
    1:   NS_ENSURE_TRUE(mRecentRedirects.Init(128), NS_ERROR_OUT_OF_MEMORY);
    1: 
11253:   /*****************************************************************************
11253:    *** IMPORTANT NOTICE!
11253:    ***
11253:    *** Nothing after these add observer calls should return anything but NS_OK.
11253:    *** If a failure code is returned, this nsNavHistory object will be held onto
11253:    *** by the observer service and the preference service. 
11253:    ****************************************************************************/
    1: 
    1:   nsCOMPtr<nsIObserverService> observerService =
    1:     do_GetService("@mozilla.org/observer-service;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIPrefBranch2> pbi = do_QueryInterface(mPrefBranch);
    1:   if (pbi) {
 8761:     pbi->AddObserver(PREF_BROWSER_HISTORY_EXPIRE_DAYS_MAX, this, PR_FALSE);
 8761:     pbi->AddObserver(PREF_BROWSER_HISTORY_EXPIRE_DAYS_MIN, this, PR_FALSE);
 8761:     pbi->AddObserver(PREF_BROWSER_HISTORY_EXPIRE_SITES, this, PR_FALSE);
    1:   }
    1: 
    1:   observerService->AddObserver(this, gXpcomShutdown, PR_FALSE);
12214:   observerService->AddObserver(this, gAutoCompleteFeedback, PR_FALSE);
24756:   observerService->AddObserver(this, gIdleDaily, PR_FALSE);
20637:   observerService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_FALSE);
24566:   // In case we've either imported or done a migration from a pre-frecency
24566:   // build, we will calculate the first cutoff period's frecencies once the rest
24566:   // of the places infrastructure has been initialized.
24566:   if (mDatabaseStatus == DATABASE_STATUS_CREATE ||
24566:       mDatabaseStatus == DATABASE_STATUS_UPGRADED) {
32454:     (void)observerService->AddObserver(this, PLACES_INIT_COMPLETE_TOPIC,
24566:                                        PR_FALSE);
24566:   }
    1: 
11253:   /*****************************************************************************
11253:    *** IMPORTANT NOTICE!
11253:    ***
11253:    *** NO CODE SHOULD GO BEYOND THIS POINT THAT WOULD PROPAGATE AN ERROR.  IN
11253:    *** OTHER WORDS, THE ONLY THING THAT SHOULD BE RETURNED AFTER THIS POINT IS
11253:    *** NS_OK.
11253:    ****************************************************************************/
11253: 
23197:   if (mDatabaseStatus == DATABASE_STATUS_CREATE) {
    1:     nsCOMPtr<nsIFile> historyFile;
    1:     rv = NS_GetSpecialDirectory(NS_APP_HISTORY_50_FILE,
    1:                                 getter_AddRefs(historyFile));
    1:     if (NS_SUCCEEDED(rv) && historyFile) {
29144:       (void)ImportHistory(historyFile);
    1:     }
    1:   }
    1: 
    1:   // Don't add code that can fail here! Do it up above, before we add our
    1:   // observers.
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2874: // nsNavHistory::InitDBFile
 2874: nsresult
 2874: nsNavHistory::InitDBFile(PRBool aForceInit)
 2874: {
11470:   if (aForceInit) {
11470:     NS_ASSERTION(mDBConn,
11470:                  "When forcing initialization, a database connection must exist!");
13508:     NS_ASSERTION(mDBService,
13508:                  "When forcing initialization, the database service must exist!");
11470:   }
11470: 
 2874:   // get profile dir, file
 2874:   nsCOMPtr<nsIFile> profDir;
 2874:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
 2874:                                        getter_AddRefs(profDir));
 2874:   NS_ENSURE_SUCCESS(rv, rv);
 2874:   rv = profDir->Clone(getter_AddRefs(mDBFile));
 2874:   NS_ENSURE_SUCCESS(rv, rv);
 2874:   rv = mDBFile->Append(DB_FILENAME);
 2874:   NS_ENSURE_SUCCESS(rv, rv);
 2874: 
 2874:   if (aForceInit) {
28515:     // If forcing initialization, backup and remove the old file.  If we have
28515:     // already failed in the last 24 hours avoid to create another corrupt file,
28515:     // since doing so, in some situation, could cause us to create a new corrupt
28515:     // file at every try to access any Places service.  That is bad because it
28515:     // would quickly fill the user's disk space without any notice.
33458:     if (!hasRecentCorruptDB()) {
11470:       // backup the database
11470:       nsCOMPtr<nsIFile> backup;
13508:       rv = mDBService->BackupDatabaseFile(mDBFile, DB_CORRUPT_FILENAME, profDir,
13508:                                           getter_AddRefs(backup));
11470:       NS_ENSURE_SUCCESS(rv, rv);
28515:     }
28515: 
28515:     // Close database connection if open.
28515:     // If there's any not finalized statement or this fails for any reason
28515:     // we won't be able to remove the database.
 9970:     rv = mDBConn->Close();
 9970:     NS_ENSURE_SUCCESS(rv, rv);
11470: 
28515:     // Remove the broken database.
 9970:     rv = mDBFile->Remove(PR_FALSE);
28515:     if (NS_FAILED(rv)) {
28515:       // If the file is still in use this will fail and we won't be able to
28515:       // start with a clean database.  The process of backing up a corrupt
28515:       // database will loop on the same database file at any next service
28515:       // request.
28515:       // We can't do much at this point, so fire a locked event so that user is
28515:       // notified that we can't ensure Places to work.
28515:       nsRefPtr<PlacesEvent> lockedEvent =
32454:         new PlacesEvent(PLACES_DB_LOCKED_TOPIC);
28515:       (void)NS_DispatchToMainThread(lockedEvent);
28515:     }
 9970:     NS_ENSURE_SUCCESS(rv, rv);
21600: 
21600:     // If aForceInit is true we were unable to initialize or upgrade the current
21600:     // database, so it was corrupt.
21600:     mDatabaseStatus = DATABASE_STATUS_CORRUPT;
 9970:   }
 9970:   else {
 2874:     // file exists?
21600:     PRBool dbExists = PR_TRUE;
 2874:     rv = mDBFile->Exists(&dbExists);
 2874:     NS_ENSURE_SUCCESS(rv, rv);
21600:     // If the database didn't previously exist, we create it.
21600:     if (!dbExists)
21600:       mDatabaseStatus = DATABASE_STATUS_CREATE;
 9970:   }
 2874: 
 2874:   // open the database
 2874:   mDBService = do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
 2874:   NS_ENSURE_SUCCESS(rv, rv);
16750:   rv = mDBService->OpenUnsharedDatabase(mDBFile, getter_AddRefs(mDBConn));
13508:   if (rv == NS_ERROR_FILE_CORRUPTED) {
21600:     // The database is corrupt, we create a new one.
21600:     mDatabaseStatus = DATABASE_STATUS_CORRUPT;
 2874: 
 2874:     // backup file
11470:     nsCOMPtr<nsIFile> backup;
13508:     rv = mDBService->BackupDatabaseFile(mDBFile, DB_CORRUPT_FILENAME, profDir,
13508:                                         getter_AddRefs(backup));
11470:     NS_ENSURE_SUCCESS(rv, rv);
11470:  
11470:     // remove existing file 
11470:     rv = mDBFile->Remove(PR_FALSE);
11470:     NS_ENSURE_SUCCESS(rv, rv);
11470: 
11470:     // and try again
 2874:     rv = profDir->Clone(getter_AddRefs(mDBFile));
 2874:     NS_ENSURE_SUCCESS(rv, rv);
 2874:     rv = mDBFile->Append(DB_FILENAME);
 2874:     NS_ENSURE_SUCCESS(rv, rv);
16750:     rv = mDBService->OpenUnsharedDatabase(mDBFile, getter_AddRefs(mDBConn));
13508:   }
23189:  
23189:   if (rv != NS_OK && rv != NS_ERROR_FILE_CORRUPTED) {
23189:     // If the database cannot be opened for any reason other than corruption,
23189:     // send out a notification and do not continue initialization.
23189:     // Note: We swallow errors here, since we want service init to fail anyway.
28515:     nsRefPtr<PlacesEvent> lockedEvent =
32454:       new PlacesEvent(PLACES_DB_LOCKED_TOPIC);
23189:     (void)NS_DispatchToMainThread(lockedEvent);
23189:   }
13508:   NS_ENSURE_SUCCESS(rv, rv);
 2874: 
 2874:   return NS_OK;
 2874: }
    1: 
    1: // nsNavHistory::InitDB
    1: //
    1: 
29518: #define PLACES_SCHEMA_VERSION 10
  252: 
    1: nsresult
23197: nsNavHistory::InitDB()
    1: {
28350:   PRInt32 pageSize = DEFAULT_DB_PAGE_SIZE;
28350: 
28350:   // Get the places schema version, which we store in the user_version PRAGMA.
28350:   PRInt32 DBSchemaVersion = 0;
28350:   nsresult rv = mDBConn->GetSchemaVersion(&DBSchemaVersion);
28350:   NS_ENSURE_SUCCESS(rv, rv);
28350:   bool databaseInitialized = (DBSchemaVersion > 0);
28350: 
28350:   if (!databaseInitialized) {
 7275:     // IMPORTANT NOTE:
 7275:     // setting page_size must happen first, see bug #401985 for details
 7275:     //
28350:     // Set the database page size.
28350:     // This will only have any effect on empty files, so must be done before
28350:     // anything else. If the file already exists, we'll get that file's page
28350:     // size and this would have no effect.
    1:     nsCAutoString pageSizePragma("PRAGMA page_size = ");
28350:     pageSizePragma.AppendInt(pageSize);
    1:     rv = mDBConn->ExecuteSimpleSQL(pageSizePragma);
    1:     NS_ENSURE_SUCCESS(rv, rv);
28350:   }
28350:   else {
28350:     // Get the page size.  This may be different than the default if the
28350:     // database file already existed with a different page size.
28350:     nsCOMPtr<mozIStorageStatement> statement;
28350:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
28350:         "PRAGMA page_size"),
28350:       getter_AddRefs(statement));
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     PRBool hasResult;
28350:     rv = statement->ExecuteStep(&hasResult);
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350:     NS_ENSURE_TRUE(hasResult, NS_ERROR_FAILURE);
28350:     pageSize = statement->AsInt32(0);
28350:   }
28350: 
28350:   // Ensure that temp tables are held in memory, not on disk.  We use temp
28350:   // tables mainly for fsync and I/O reduction.
14936:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
14936:       "PRAGMA temp_store = MEMORY"));
14936:   NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:   // Set pragma synchronous to FULL to ensure maximum data integrity, even in
28350:   // case of crashes or unclean shutdowns.
28350:   // The suggested setting from SQLite is FULL, but Storage defaults to NORMAL.
23285:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
23285:       "PRAGMA synchronous = FULL"));
23285:   NS_ENSURE_SUCCESS(rv, rv);
23285: 
28350: 
28350:   // Compute the size of the database cache.
28350:   PRInt32 cachePercentage;
28350:   if (NS_FAILED(mPrefBranch->GetIntPref(PREF_DB_CACHE_PERCENTAGE,
28350:                                         &cachePercentage)))
28350:     cachePercentage = DEFAULT_DB_CACHE_PERCENTAGE;
28350:   if (cachePercentage > 50)
28350:     cachePercentage = 50; // sanity check, don't take too much
28350:   if (cachePercentage < 0)
28350:     cachePercentage = 0;
28350:   PRInt64 cacheSize = PR_GetPhysicalMemorySize() * cachePercentage / 100;
28350:   PRInt64 cachePages = cacheSize / pageSize;
28350: 
28350:   // Set the cache size.  We don't use default_cache_size so the database can
28350:   // be moved between computers and the value will change dynamically.
28350:   nsCAutoString pageSizePragma("PRAGMA cache_size = ");
28350:   pageSizePragma.AppendInt(cachePages);
28350:   rv = mDBConn->ExecuteSimpleSQL(pageSizePragma);
28350:   NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:   // Lock the db file.  This is done partly to avoid third party applications
28350:   // to access the database while it's in use, partly for performance reasons.
28350:   // http://www.sqlite.org/pragma.html#pragma_locking_mode
28350:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:       "PRAGMA locking_mode = EXCLUSIVE"));
28350:   NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:       "PRAGMA journal_mode = " DEFAULT_JOURNAL_MODE));
28350:   NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:   // We are going to initialize tables, so everything from now on should be in
28350:   // a transaction for performances.
    1:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 2713:   // Initialize the other places services' database tables. We do this before
 2713:   // creating our statements. Some of our statements depend on these external
    1:   // tables, such as the bookmarks or favicon tables.
    1:   rv = nsNavBookmarks::InitTables(mDBConn);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = nsFaviconService::InitTables(mDBConn);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = nsAnnotationService::InitTables(mDBConn);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
28350:   if (!databaseInitialized) {
28350:     // This is the first run, so we set schema version to the latest one, since
28350:     // we don't need to migrate anything.  We will create tables from scratch.
 1014:     rv = UpdateSchemaVersion();
 1014:     NS_ENSURE_SUCCESS(rv, rv);
28350:     DBSchemaVersion = PLACES_SCHEMA_VERSION;
28350:   }
  711: 
  711:   if (PLACES_SCHEMA_VERSION != DBSchemaVersion) {
  711:     // Migration How-to:
  338:     //
  711:     // 1. increment PLACES_SCHEMA_VERSION.
  711:     // 2. implement a method that performs up/sidegrade to your version
  711:     //    from the current version.
  711:     //
  711:     // NOTE: We don't support downgrading back to History-only Places.
  711:     // If you want to go from newer schema version back to V0, you'll need to
  711:     // blow away your sqlite file. Subsequent up/downgrades have backwards and
  711:     // forward migration code.
  711:     //
  711:     // XXX Backup places.sqlite to places-{version}.sqlite when doing db migration?
  711:     
  711:     if (DBSchemaVersion < PLACES_SCHEMA_VERSION) {
  711:       // Upgrading
23197:       mDatabaseStatus = DATABASE_STATUS_UPGRADED;
  711: 
 4037:       // Migrate anno tables up to V3
  711:       if (DBSchemaVersion < 3) {
  711:         rv = MigrateV3Up(mDBConn);
  711:         NS_ENSURE_SUCCESS(rv, rv);
  711:       }
  711: 
 1604:       // Migrate bookmarks tables up to V5
 1604:       if (DBSchemaVersion < 5) {
 1297:         rv = ForceMigrateBookmarksDB(mDBConn);
 1297:         NS_ENSURE_SUCCESS(rv, rv);
 1297:       }
 1297: 
 4037:       // Migrate anno tables up to V6
 4037:       if (DBSchemaVersion < 6) {
 4037:         rv = MigrateV6Up(mDBConn);
 4037:         NS_ENSURE_SUCCESS(rv, rv);
 4037:       }
 4037: 
16356:       // Migrate historyvisits and bookmarks up to V7
16356:       if (DBSchemaVersion < 7) {
16356:         rv = MigrateV7Up(mDBConn);
16356:         NS_ENSURE_SUCCESS(rv, rv);
16356:       }
16356: 
20868:       // Migrate historyvisits up to V8
20868:       if (DBSchemaVersion < 8) {
20868:         rv = MigrateV8Up(mDBConn);
20868:         NS_ENSURE_SUCCESS(rv, rv);
20868:       }
20868: 
28350:       // Migrate places up to V9
28350:       if (DBSchemaVersion < 9) {
28350:         rv = MigrateV9Up(mDBConn);
28350:         NS_ENSURE_SUCCESS(rv, rv);
28350:       }
28350: 
29518:       // Migrate places up to V10
29518:       if (DBSchemaVersion < 10) {
29518:         rv = MigrateV10Up(mDBConn);
29518:         NS_ENSURE_SUCCESS(rv, rv);
29518:       }
29518: 
29518:       // Schema Upgrades must add migration code here.
  711: 
  252:     } else {
  711:       // Downgrading
  711: 
  711:       // XXX Need to prompt user or otherwise notify of 
  711:       // potential dataloss when downgrading.
  711: 
 4037:       // XXX Downgrades from >V6 must add migration code here.
 1604: 
 1604:       // Downgrade v1,2,4,5
 4037:       // v3,6 have no backwards incompatible changes.
10239:       if (DBSchemaVersion > 2 && DBSchemaVersion < 6) {
  711:         // perform downgrade to v2
  338:         rv = ForceMigrateBookmarksDB(mDBConn);
  252:         NS_ENSURE_SUCCESS(rv, rv);
  252:       }
  711:     }
  252: 
28350:     // Update schema version to the current one.
 1014:     rv = UpdateSchemaVersion();
  252:     NS_ENSURE_SUCCESS(rv, rv);
  252:   }
  252: 
28350:   if (!databaseInitialized) {
28350:     // CREATE TABLE moz_places.
16361:     rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_URL);
 8225:     NS_ENSURE_SUCCESS(rv, rv);
 8225: 
 8225:     // This index is used for favicon expiration, see nsNavHistoryExpire::ExpireItems.
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FAVICON);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_REVHOST);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_VISITCOUNT);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FRECENCY);
10669:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_LASTVISITDATE);
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     // CREATE TABLE moz_historyvisits.
16361:     rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_PLACEDATE);
 8225:     NS_ENSURE_SUCCESS(rv, rv);
 8225: 
 8225:     // This makes a big difference in startup time for large profiles because of
 8225:     // finding bookmark redirects using the referring page. 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_FROMVISIT);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_VISITDATE);
 8225:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
12214:     // moz_inputhistory
16361:     rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_INPUTHISTORY);
12214:     NS_ENSURE_SUCCESS(rv, rv);
12214:   }
12214: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
28515:   // ANY FAILURE IN THIS METHOD WILL CAUSE US TO MARK THE DATABASE AS CORRUPT
28515:   // AND TRY TO REPLACE IT.
28515:   // DO NOT PUT HERE ANYTHING THAT IS NOT RELATED TO INITIALIZATION OR MODIFYING
28515:   // THE DISK DATABASE.
28515: 
28515:   return NS_OK;
28515: }
28515: 
28515: nsresult
28515: nsNavHistory::InitAdditionalDBItems()
28515: {
28515:   nsresult rv = InitTempTables();
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867:   rv = InitViews();
20867:   NS_ENSURE_SUCCESS(rv, rv);
12328:   rv = InitFunctions();
13613:   NS_ENSURE_SUCCESS(rv, rv);
 2874:   rv = InitStatements();
 2874:   NS_ENSURE_SUCCESS(rv, rv);
 2874: 
    1:   return NS_OK;
    1: }
    1: 
21600: NS_IMETHODIMP
21600: nsNavHistory::GetDatabaseStatus(PRUint16 *aDatabaseStatus)
21600: {
28236:   NS_ENSURE_ARG_POINTER(aDatabaseStatus);
21600:   *aDatabaseStatus = mDatabaseStatus;
21600:   return NS_OK;
21600: }
21600: 
 1014: // nsNavHistory::UpdateSchemaVersion
 1014: //
 1014: // Called by the individual services' InitTables()
 1014: nsresult
 1014: nsNavHistory::UpdateSchemaVersion()
 1014: {
 3036:   return mDBConn->SetSchemaVersion(PLACES_SCHEMA_VERSION);
 1014: }
    1: 
12328: // nsNavHistory::InitFunctions
12328: //
12328: //    Called after InitDB, this creates our own functions
12328: 
12328: class mozStorageFunctionGetUnreversedHost: public mozIStorageFunction
12328: {
12328: public:
12328:   NS_DECL_ISUPPORTS
12328:   NS_DECL_MOZISTORAGEFUNCTION
12328: };
12328: 
12328: NS_IMPL_ISUPPORTS1(mozStorageFunctionGetUnreversedHost, mozIStorageFunction)
12328: 
28236: NS_IMETHODIMP
28236: mozStorageFunctionGetUnreversedHost::OnFunctionCall(
12328:   mozIStorageValueArray* aFunctionArguments,
12328:   nsIVariant** _retval)
12328: {
28236:   NS_ASSERTION(aFunctionArguments, "Must have non-null function args");
28236:   NS_ASSERTION(_retval, "Must have non-null return pointer");
12328: 
12328:   nsAutoString src;
12328:   aFunctionArguments->GetString(0, src);
12328: 
12328:   nsresult rv;
12328:   nsCOMPtr<nsIWritableVariant> result(do_CreateInstance(
12328:       "@mozilla.org/variant;1", &rv));
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328: 
12328:   if (src.Length()>1) {
12328:     src.Truncate(src.Length() - 1);
12328:     nsAutoString dest;
12328:     ReverseString(src, dest);
12328:     result->SetAsAString(dest);
12328:   } else {
12328:     result->SetAsAString(NS_LITERAL_STRING(""));
12328:   }
12328:   NS_ADDREF(*_retval = result);
12328:   return NS_OK;
12332: }
12328: 
12328: nsresult
20867: nsNavHistory::InitTempTables()
20867: {
20867:   nsresult rv;
20867: 
20867:   // moz_places_temp
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES_TEMP);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_TEMP_URL);
28193:   NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_TEMP_FAVICON);
28193:   NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_TEMP_REVHOST);
28193:   NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_TEMP_VISITCOUNT);
28193:   NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_TEMP_FRECENCY);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
20869:   rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES_SYNC_TRIGGER);
20869:   NS_ENSURE_SUCCESS(rv, rv);
20869: 
20867: 
20867:   // moz_historyvisits_temp
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS_TEMP);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_TEMP_PLACEDATE);
28193:   NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_TEMP_FROMVISIT);
28193:   NS_ENSURE_SUCCESS(rv, rv);
28193: 
28193:   rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_TEMP_VISITDATE);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
20869:   rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS_SYNC_TRIGGER);
20869:   NS_ENSURE_SUCCESS(rv, rv);
20869: 
20867:   return NS_OK;
20867: }
20867: 
20867: nsresult
20867: nsNavHistory::InitViews()
20867: {
20867:   nsresult rv;
20867: 
20867:   // moz_places_view
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES_VIEW);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_PLACES_VIEW_INSERT_TRIGGER);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_PLACES_VIEW_DELETE_TRIGGER);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_PLACES_VIEW_UPDATE_TRIGGER);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
20867:   // moz_historyvisits_view
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS_VIEW);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_VIEW_INSERT_TRIGGER);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_VIEW_DELETE_TRIGGER);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867:   rv = mDBConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_VIEW_UPDATE_TRIGGER);
20867:   NS_ENSURE_SUCCESS(rv, rv);
20867: 
20867:   return NS_OK;
20867: }
20867: 
20867: nsresult
12328: nsNavHistory::InitFunctions()
12328: {
30902:   nsCOMPtr<mozIStorageFunction> func =
30902:     new mozStorageFunctionGetUnreversedHost;
30902:   NS_ENSURE_TRUE(func, NS_ERROR_OUT_OF_MEMORY);
30902:   nsresult rv = mDBConn->CreateFunction(
30902:     NS_LITERAL_CSTRING("get_unreversed_host"), 1, func
30902:   );
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902: 
30902:   rv = MatchAutoCompleteFunction::create(mDBConn);
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328: 
12328:   return NS_OK;
12328: }
12328: 
    1: // nsNavHistory::InitStatements
    1: //
    1: //    Called after InitDB, this creates our stored statements
    1: 
    1: nsresult
    1: nsNavHistory::InitStatements()
    1: {
    1:   // mDBGetURLPageInfo
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // have unique urls.
28350:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:     "SELECT id, url, title, rev_host, visit_count "
20868:     "FROM moz_places_temp "
20868:     "WHERE url = ?1 "
20868:     "UNION ALL "
20868:     "SELECT id, url, title, rev_host, visit_count "
20868:     "FROM moz_places "
20868:     "WHERE url = ?1 "
20868:     "LIMIT 1"),
    1:     getter_AddRefs(mDBGetURLPageInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // mDBGetIdPageInfo
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // have unique place ids.
    1:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT id, url, title, rev_host, visit_count "
20868:       "FROM moz_places_temp "
20868:       "WHERE id = ?1 "
20868:       "UNION ALL "
20868:       "SELECT id, url, title, rev_host, visit_count "
20868:       "FROM moz_places "
20868:       "WHERE id = ?1 "
20868:       "LIMIT 1"),
    1:     getter_AddRefs(mDBGetIdPageInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // mDBRecentVisitOfURL
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // expect visits in temp table being the most recent.
    1:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
28350:       "SELECT id, session, visit_date "
28350:       "FROM moz_historyvisits_temp "
28350:       "WHERE place_id = IFNULL((SELECT id FROM moz_places_temp WHERE url = ?1), "
20868:                               "(SELECT id FROM moz_places WHERE url = ?1)) "
20868:       "UNION ALL "
28350:       "SELECT id, session, visit_date "
28350:       "FROM moz_historyvisits "
28350:       "WHERE place_id = IFNULL((SELECT id FROM moz_places_temp WHERE url = ?1), "
20868:                               "(SELECT id FROM moz_places WHERE url = ?1)) "
28350:       "ORDER BY visit_date DESC "
    1:       "LIMIT 1 "),
    1:     getter_AddRefs(mDBRecentVisitOfURL));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
16751:   // mDBRecentVisitOfPlace
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // expect visits in temp table being the most recent.  
16751:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT id FROM moz_historyvisits_temp "
20868:       "WHERE place_id = ?1 "
20868:         "AND visit_date = ?2 "
20868:         "AND session = ?3 "
20868:       "UNION ALL "
20868:       "SELECT id FROM moz_historyvisits "
16751:       "WHERE place_id = ?1 "
16751:         "AND visit_date = ?2 "
16751:         "AND session = ?3 "
16751:       "LIMIT 1"),
16751:     getter_AddRefs(mDBRecentVisitOfPlace));
16751:   NS_ENSURE_SUCCESS(rv, rv);
16751: 
    1:   // mDBInsertVisit
    1:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "INSERT INTO moz_historyvisits_view "
    1:         "(from_visit, place_id, visit_date, visit_type, session) "
    1:       "VALUES (?1, ?2, ?3, ?4, ?5)"),
    1:     getter_AddRefs(mDBInsertVisit));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // mDBGetPageVisitStats (see InternalAdd)
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // have unique place ids.
    1:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
    1:       "SELECT id, visit_count, typed, hidden "
20868:       "FROM moz_places_temp "
20868:       "WHERE url = ?1 "
20868:       "UNION ALL "
20868:       "SELECT id, visit_count, typed, hidden "
    1:       "FROM moz_places "
20868:       "WHERE url = ?1 "
20868:       "LIMIT 1"),
    1:     getter_AddRefs(mDBGetPageVisitStats));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
13698:   // mDBIsPageVisited
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // only need to know if a visit exists.
13698:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT h.id "
20868:       "FROM moz_places_temp h "
20868:       "WHERE url = ?1 " 
20868:         "AND ( "
20868:           "EXISTS(SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id LIMIT 1) "
20868:           "OR EXISTS(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
20868:         ") "
20868:       "UNION ALL "
20868:       "SELECT h.id "
20868:       "FROM moz_places h "
20868:       "WHERE url = ?1 "
20868:       "AND ( "
20868:         "EXISTS(SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id LIMIT 1) "
20868:         "OR EXISTS(SELECT id FROM moz_historyvisits WHERE place_id = h.id LIMIT 1) "
20868:       ") "
20868:       "LIMIT 1"), 
13698:     getter_AddRefs(mDBIsPageVisited));
13698:   NS_ENSURE_SUCCESS(rv, rv);
13698: 
    1:   // mDBUpdatePageVisitStats (see InternalAdd)
13613:   // we don't need to update visit_count since it's maintained
13613:   // in sync by triggers, and we must NEVER touch it
    1:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "UPDATE moz_places_view "
13613:       "SET hidden = ?2, typed = ?3 "
    1:       "WHERE id = ?1"),
    1:     getter_AddRefs(mDBUpdatePageVisitStats));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // mDBAddNewPage (see InternalAddNewPage)
    1:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
23588:       "INSERT INTO moz_places_view "
13613:         "(url, title, rev_host, hidden, typed, frecency) "
13613:       "VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
    1:     getter_AddRefs(mDBAddNewPage));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
12338:   // mDBGetTags
 6755:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
27184:       "/* do not warn (bug 487594) */ "
33458:       "SELECT GROUP_CONCAT(tag_title, ', ') "
33458:       "FROM ( "
21343:         "SELECT t.title AS tag_title "
20868:         "FROM moz_bookmarks b "
20868:         "JOIN moz_bookmarks t ON t.id = b.parent "
33458:         "WHERE b.fk = IFNULL((SELECT id FROM moz_places_temp WHERE url = ?2), "
33458:                             "(SELECT id FROM moz_places WHERE url = ?2)) "
27691:           "AND LENGTH(t.title) > 0 "
20868:           "AND b.type = ") +
12338:             nsPrintfCString("%d", nsINavBookmarksService::TYPE_BOOKMARK) +
33458:           NS_LITERAL_CSTRING(" AND t.parent = ?1 "
28350:         "ORDER BY t.title COLLATE NOCASE ASC)"),
12338:     getter_AddRefs(mDBGetTags));
 6755:   NS_ENSURE_SUCCESS(rv, rv);
 6755: 
33458:   // mDBGetItemsWithAnno
 6822:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT a.item_id, a.content "
20868:       "FROM moz_anno_attributes n "
20868:       "JOIN moz_items_annos a ON n.id = a.anno_attribute_id "
20868:       "WHERE n.name = ?1"),
33458:     getter_AddRefs(mDBGetItemsWithAnno));
 6822:    NS_ENSURE_SUCCESS(rv, rv);
 6822: 
20871:   // mDBSetPlaceTitle
20871:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20871:       "UPDATE moz_places_view "
20871:       "SET title = ?1 "
20871:       "WHERE url = ?2"),
20871:     getter_AddRefs(mDBSetPlaceTitle));
20871:   NS_ENSURE_SUCCESS(rv, rv);
20871: 
20871: 
10669:   // mDBVisitsForFrecency
13613:   // NOTE: we are not limiting to visits with "visit_type NOT IN (0,4,7)"
10669:   // because if we do that, mDBVisitsForFrecency would return no visits
10669:   // for places with only embed (or undefined) visits.  That would
10669:   // cause use to estimate a frecency based on what information we do have,
11985:   // see CalculateFrecencyInternal(). That would result in a non-zero frecency
11985:   // for a place with only embedded visits, instead of a frecency of 0. If we
11985:   // have a temporary or permanent redirect, calculate the frecency as if it
11985:   // was the original page visited.
10669:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
26042:       "SELECT v.visit_date, COALESCE( "
26042:         "(SELECT r.visit_type FROM moz_historyvisits_temp r "
26042:           "WHERE v.visit_type IN ") +
26042:             nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
26042:                                         TRANSITION_REDIRECT_TEMPORARY) +
26042:             NS_LITERAL_CSTRING(" AND r.id = v.from_visit), "
26042:         "(SELECT r.visit_type FROM moz_historyvisits r "
26042:           "WHERE v.visit_type IN ") +
26042:             nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
26042:                                         TRANSITION_REDIRECT_TEMPORARY) +
26042:             NS_LITERAL_CSTRING(" AND r.id = v.from_visit), "
26042:         "visit_type) "
26042:       "FROM moz_historyvisits_temp v "
26042:       "WHERE v.place_id = ?1 "
20868:       "UNION ALL "
26042:       "SELECT v.visit_date, COALESCE( "
26042:         "(SELECT r.visit_type FROM moz_historyvisits_temp r "
26042:           "WHERE v.visit_type IN ") +
11985:             nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
26042:                                         TRANSITION_REDIRECT_TEMPORARY) +
26042:             NS_LITERAL_CSTRING(" AND r.id = v.from_visit), "
26042:         "(SELECT r.visit_type FROM moz_historyvisits r "
26042:           "WHERE v.visit_type IN ") +
20868:             nsPrintfCString("(%d,%d) ", TRANSITION_REDIRECT_PERMANENT,
26042:                                         TRANSITION_REDIRECT_TEMPORARY) +
26042:             NS_LITERAL_CSTRING(" AND r.id = v.from_visit), "
26042:         "visit_type) "
26042:       "FROM moz_historyvisits v "
26042:       "WHERE v.place_id = ?1 "
26042:         "AND v.id NOT IN (SELECT id FROM moz_historyvisits_temp) "
28350:       "ORDER BY visit_date DESC LIMIT ") +
10669:         nsPrintfCString("%d", mNumVisitsForFrecency),
10669:     getter_AddRefs(mDBVisitsForFrecency));
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // mDBUpdateFrecencyAndHidden
10669:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "UPDATE moz_places_view SET frecency = ?2, hidden = ?3 WHERE id = ?1"),
10669:     getter_AddRefs(mDBUpdateFrecencyAndHidden));
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // mDBGetPlaceVisitStats
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // have unique place ids.
10669:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT typed, hidden, frecency "
20868:       "FROM moz_places_temp WHERE id = ?1 "
20868:       "UNION ALL "
20868:       "SELECT typed, hidden, frecency "
20868:       "FROM moz_places WHERE id = ?1 "
20868:       "LIMIT 1"),
10669:     getter_AddRefs(mDBGetPlaceVisitStats));
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // when calculating frecency, we want the visit count to be 
10669:   // all the visits.
20868:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT "
20868:         "(SELECT COUNT(*) FROM moz_historyvisits WHERE place_id = ?1) + "
20868:         "(SELECT COUNT(*) FROM moz_historyvisits_temp WHERE place_id = ?1 "
20868:             "AND id NOT IN (SELECT id FROM moz_historyvisits))"),
13613:     getter_AddRefs(mDBFullVisitCount));
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
    1:   return NS_OK;
    1: }
    1: 
  338: // nsNavHistory::ForceMigrateBookmarksDB
  252: //
  252: //    This dumps all bookmarks-related tables, and recreates them,
  252: //    forcing a re-import of bookmarks.html.
  338: //
  338: //    NOTE: This may cause data-loss if downgrading!
  338: //    Only use this for migration if you're sure that bookmarks.html
  338: //    and the target version support all bookmarks fields.
  252: nsresult
  338: nsNavHistory::ForceMigrateBookmarksDB(mozIStorageConnection* aDBConn) 
  252: {
  252:   // drop bookmarks tables
20868:   nsresult rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DROP TABLE IF EXISTS moz_bookmarks"));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20868:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DROP TABLE IF EXISTS moz_bookmarks_folders"));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20868:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DROP TABLE IF EXISTS moz_bookmarks_roots"));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20868:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DROP TABLE IF EXISTS moz_keywords"));
  252:   NS_ENSURE_SUCCESS(rv, rv);
  252: 
  252:   // initialize bookmarks tables
  252:   rv = nsNavBookmarks::InitTables(aDBConn);
  252:   NS_ENSURE_SUCCESS(rv, rv);
 1297: 
21600:   // We have done a new database init, so we mark this as if the database has
21600:   // been created now, so the frontend can distinguish this status and import
21600:   // if needed.
21600:   mDatabaseStatus = DATABASE_STATUS_CREATE;
21600: 
21600:   return NS_OK;
  252: }
  252: 
  711: // nsNavHistory::MigrateV3Up
  711: nsresult
  711: nsNavHistory::MigrateV3Up(mozIStorageConnection* aDBConn) 
  711: {
  818:   // if type col is already there, then a partial update occurred.
  818:   // return, making no changes, and allowing db version to be updated.
  818:   nsCOMPtr<mozIStorageStatement> statement;
20868:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT type from moz_annos"),
  818:     getter_AddRefs(statement));
  818:   if (NS_SUCCEEDED(rv))
  818:     return NS_OK;
  818: 
  711:   // add type column to moz_annos
  818:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
  711:       "ALTER TABLE moz_annos ADD type INTEGER DEFAULT 0"));
  818:   if (NS_FAILED(rv)) {
  818:     // if the alteration failed, force-migrate
20868:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:         "DROP TABLE IF EXISTS moz_annos"));
  818:     NS_ENSURE_SUCCESS(rv, rv);
  818:     rv = nsAnnotationService::InitTables(mDBConn);
  818:     NS_ENSURE_SUCCESS(rv, rv);
  818:   }
  711:   NS_ENSURE_SUCCESS(rv, rv);
  711:   return NS_OK;
  711: }
    1: 
 4037: // nsNavHistory::MigrateV6Up
 4037: nsresult
 4037: nsNavHistory::MigrateV6Up(mozIStorageConnection* aDBConn) 
 4037: {
16356:   mozStorageTransaction transaction(aDBConn, PR_FALSE);
16356: 
 9328:   // if dateAdded & lastModified cols are already there, then a partial update occurred,
 9328:   // and so we should not attempt to add these cols.
 4037:   nsCOMPtr<mozIStorageStatement> statement;
 4037:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
 9328:       "SELECT a.dateAdded, a.lastModified FROM moz_annos a"), 
 9328:     getter_AddRefs(statement));
 4037:   if (NS_FAILED(rv)) {
 4037:     // add dateAdded and lastModified columns to moz_annos
 4037:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
 4037:         "ALTER TABLE moz_annos ADD dateAdded INTEGER DEFAULT 0"));
 4037:     NS_ENSURE_SUCCESS(rv, rv);
 4037:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
 4037:         "ALTER TABLE moz_annos ADD lastModified INTEGER DEFAULT 0"));
 4037:     NS_ENSURE_SUCCESS(rv, rv);
 9328:   }
 9328: 
 9328:   // if dateAdded & lastModified cols are already there, then a partial update occurred,
 9328:   // and so we should not attempt to add these cols.  see bug #408443 for details.
 9328:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
 9328:       "SELECT b.dateAdded, b.lastModified FROM moz_items_annos b"), 
 9328:     getter_AddRefs(statement));
 9328:   if (NS_FAILED(rv)) {
 4037:     // add dateAdded and lastModified columns to moz_items_annos
 4037:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
 4037:         "ALTER TABLE moz_items_annos ADD dateAdded INTEGER DEFAULT 0"));
 4037:     NS_ENSURE_SUCCESS(rv, rv);
 4037:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
 4037:         "ALTER TABLE moz_items_annos ADD lastModified INTEGER DEFAULT 0"));
 4037:     NS_ENSURE_SUCCESS(rv, rv);
 4037:   }
 4037: 
 4037:   // we used to create an indexes on moz_favicons.url and
 4037:   // moz_anno_attributes.name, but those indexes are not needed
 4037:   // because those columns are UNIQUE, so remove them.
 4037:   // see bug #386303 for more details
20868:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DROP INDEX IF EXISTS moz_favicons_url"));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20868:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DROP INDEX IF EXISTS moz_anno_attributes_nameindex"));
 4037:   NS_ENSURE_SUCCESS(rv, rv);
 4037: 
21258: 
21258:   // bug #371800 - remove moz_places.user_title
21258:   // test for moz_places.user_title
21258:   nsCOMPtr<mozIStorageStatement> statement2;
21258:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
21258:       "SELECT user_title FROM moz_places"),
21258:     getter_AddRefs(statement2));
21258:   if (NS_SUCCEEDED(rv)) {
21258:     // 1. Indexes are moved along with the renamed table. Since we're dropping
21258:     // that table, we're also dropping its indexes, and later re-creating them
21258:     // for the new table.
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP INDEX IF EXISTS moz_places_urlindex"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP INDEX IF EXISTS moz_places_titleindex"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP INDEX IF EXISTS moz_places_faviconindex"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP INDEX IF EXISTS moz_places_hostindex"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP INDEX IF EXISTS moz_places_visitcount"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP INDEX IF EXISTS moz_places_frecencyindex"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258: 
21258:     // 2. remove any duplicate URIs
21258:     rv = RemoveDuplicateURIs();
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258: 
21258:     // 3. rename moz_places to moz_places_backup
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "ALTER TABLE moz_places RENAME TO moz_places_backup"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258: 
21258:     // 4. create moz_places w/o user_title
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "CREATE TABLE moz_places ("
21258:           "id INTEGER PRIMARY KEY, "
21258:           "url LONGVARCHAR, "
21258:           "title LONGVARCHAR, "
21258:           "rev_host LONGVARCHAR, "
21258:           "visit_count INTEGER DEFAULT 0, "
21258:           "hidden INTEGER DEFAULT 0 NOT NULL, "
21258:           "typed INTEGER DEFAULT 0 NOT NULL, "
21258:           "favicon_id INTEGER, "
21258:           "frecency INTEGER DEFAULT -1 NOT NULL)"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258: 
21258:     // 5. recreate the indexes
21258:     // NOTE: tests showed that it's faster to create the indexes prior to filling
21258:     // the table than it is to add them afterwards.
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_URL);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FAVICON);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_REVHOST);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_VISITCOUNT);
28193:     NS_ENSURE_SUCCESS(rv, rv);
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FRECENCY);
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258: 
21258:     // 6. copy all data into moz_places
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28193:         "INSERT INTO moz_places (" MOZ_PLACES_COLUMNS ")"
28193:         "SELECT " MOZ_PLACES_COLUMNS " FROM moz_places_backup"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258: 
21258:     // 7. drop moz_places_backup
21258:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21258:         "DROP TABLE moz_places_backup"));
21258:     NS_ENSURE_SUCCESS(rv, rv);
21258:   }
21258: 
16356:   return transaction.Commit();
16356: }
16356: 
16356: // nsNavHistory::MigrateV7Up
16356: nsresult
16356: nsNavHistory::MigrateV7Up(mozIStorageConnection* aDBConn) 
16356: {
16356:   mozStorageTransaction transaction(aDBConn, PR_FALSE);
16356: 
23197:   // We need an index on lastModified to catch quickly last modified bookmark
23197:   // title for tag container's children. This will be useful for sync too.
23197:   PRBool lastModIndexExists = PR_FALSE;
23197:   nsresult rv = aDBConn->IndexExists(
23197:     NS_LITERAL_CSTRING("moz_bookmarks_itemlastmodifiedindex"),
23197:     &lastModIndexExists);
23197:   NS_ENSURE_SUCCESS(rv, rv);
23197: 
23197:   if (!lastModIndexExists) {
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACELASTMODIFIED);
23197:     NS_ENSURE_SUCCESS(rv, rv);
23197:   }
23197: 
23197:   // We need to do a one-time change of the moz_historyvisits.pageindex
23197:   // to speed up finding last visit date when joinin with moz_places.
23197:   // See bug 392399 for more details.
23197:   PRBool pageIndexExists = PR_FALSE;
23197:   rv = aDBConn->IndexExists(
23197:     NS_LITERAL_CSTRING("moz_historyvisits_pageindex"), &pageIndexExists);
23197:   NS_ENSURE_SUCCESS(rv, rv);
23197: 
23197:   if (pageIndexExists) {
23197:     // drop old index
23197:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
23197:         "DROP INDEX IF EXISTS moz_historyvisits_pageindex"));
23197:     NS_ENSURE_SUCCESS(rv, rv);
23197: 
23197:     // create the new multi-column index
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_PLACEDATE);
23197:     NS_ENSURE_SUCCESS(rv, rv);
23197:   }
23197: 
23197:   // for existing profiles, we may not have a frecency column
23197:   nsCOMPtr<mozIStorageStatement> hasFrecencyStatement;
23197:   rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
23197:       "SELECT frecency FROM moz_places"),
23197:     getter_AddRefs(hasFrecencyStatement));
23197: 
23197:   if (NS_FAILED(rv)) {
27190:     // Add frecency column to moz_places, default to -1 so that all the
27190:     // frecencies are invalid
23197:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
23197:         "ALTER TABLE moz_places ADD frecency INTEGER DEFAULT -1 NOT NULL"));
23197:     NS_ENSURE_SUCCESS(rv, rv);
23197: 
23197:     // create index for the frecency column
23197:     // XXX multi column index with typed, and visit_count?
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FRECENCY);
23197:     NS_ENSURE_SUCCESS(rv, rv);
23197: 
23197:     // for place: items and unvisited livemark items, we need to set
23197:     // the frecency to 0 so that they don't show up in url bar autocomplete
23197:     rv = FixInvalidFrecenciesForExcludedPlaces();
23197:     NS_ENSURE_SUCCESS(rv, rv);
23197:   }
23197: 
20874:   // Temporary migration code for bug 396300
20874:   nsCOMPtr<mozIStorageStatement> moveUnfiledBookmarks;
23197:   rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
24566:       "UPDATE moz_bookmarks "
24566:       "SET parent = ("
24566:         "SELECT folder_id "
24566:         "FROM moz_bookmarks_roots "
24566:         "WHERE root_name = ?1 "
24566:       ") "
24566:       "WHERE type = ?2 "
24566:       "AND parent = ("
24566:         "SELECT folder_id "
24566:         "FROM moz_bookmarks_roots "
24566:         "WHERE root_name = ?3 "
24566:       ")"),
20874:     getter_AddRefs(moveUnfiledBookmarks));
24566:   rv = moveUnfiledBookmarks->BindUTF8StringParameter(0, NS_LITERAL_CSTRING("unfiled"));
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   rv = moveUnfiledBookmarks->BindInt32Parameter(1, nsINavBookmarksService::TYPE_BOOKMARK);
20874:   NS_ENSURE_SUCCESS(rv, rv);
24566:   rv = moveUnfiledBookmarks->BindUTF8StringParameter(2, NS_LITERAL_CSTRING("places"));
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   rv = moveUnfiledBookmarks->Execute();
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874: 
16356:   // Create a statement to test for trigger creation
16356:   nsCOMPtr<mozIStorageStatement> triggerDetection;
20874:   rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
16356:       "SELECT name "
16356:       "FROM sqlite_master "
16356:       "WHERE type = 'trigger' "
20868:       "AND name = ?"),
20868:     getter_AddRefs(triggerDetection));
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356: 
16360:   // Check for existence
16356:   PRBool triggerExists;
16356:   rv = triggerDetection->BindUTF8StringParameter(
16356:     0, NS_LITERAL_CSTRING("moz_historyvisits_afterinsert_v1_trigger")
16356:   );
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356:   rv = triggerDetection->ExecuteStep(&triggerExists);
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356:   rv = triggerDetection->Reset();
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356: 
16356:   // We need to create two triggers on moz_historyvists to maintain the
16356:   // accuracy of moz_places.visit_count.  For this to work, we must ensure that
16356:   // all moz_places.visit_count values are correct.
16356:   // See bug 416313 for details.
16356:   if (!triggerExists) {
16356:     // First, we do a one-time reset of all the moz_places.visit_count values.
16356:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
16356:         "UPDATE moz_places SET visit_count = "
16356:           "(SELECT count(*) FROM moz_historyvisits "
16356:            "WHERE place_id = moz_places.id "
20868:             "AND visit_type NOT IN ") +
20868:               nsPrintfCString("(0,%d,%d) ",
20868:                               nsINavHistoryService::TRANSITION_EMBED,
20868:                               nsINavHistoryService::TRANSITION_DOWNLOAD) +
20868:           NS_LITERAL_CSTRING(")"));
20868:     NS_ENSURE_SUCCESS(rv, rv);
20868: 
20868:     // We used to create two triggers here, but we no longer need that with
20868:     // schema version eight and greater.  We've removed their creation here as
20868:     // a result.
16356:   }
16356: 
16360:   // Check for existence
16356:   rv = triggerDetection->BindUTF8StringParameter(
16356:     0, NS_LITERAL_CSTRING("moz_bookmarks_beforedelete_v1_trigger")
16356:   );
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356:   rv = triggerDetection->ExecuteStep(&triggerExists);
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356:   rv = triggerDetection->Reset();
16356:   NS_ENSURE_SUCCESS(rv, rv);
16356: 
16356:   // We need to create one trigger on moz_bookmarks to remove unused keywords.
16356:   // See bug 421180 for details.
16356:   if (!triggerExists) {
16356:     // First, remove any existing dangling keywords
16356:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
16356:         "DELETE FROM moz_keywords "
16356:         "WHERE id IN ("
16356:           "SELECT k.id "
16356:           "FROM moz_keywords k "
16356:           "LEFT OUTER JOIN moz_bookmarks b "
16356:           "ON b.keyword_id = k.id "
16356:           "WHERE b.id IS NULL"
20868:         ")"));
16356:     NS_ENSURE_SUCCESS(rv, rv);
16356: 
16356:     // Now we create our trigger
16356:     rv = aDBConn->ExecuteSimpleSQL(CREATE_KEYWORD_VALIDITY_TRIGGER);
16356:     NS_ENSURE_SUCCESS(rv, rv);
16356:   }
16356: 
16356:   return transaction.Commit();
 4108: }
 4108: 
 4108: nsresult
20868: nsNavHistory::MigrateV8Up(mozIStorageConnection *aDBConn)
20868: {
20868:   mozStorageTransaction transaction(aDBConn, PR_FALSE);
20868: 
20868:   nsresult rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21085:       "DROP TRIGGER IF EXISTS moz_historyvisits_afterinsert_v1_trigger"));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20868: 
20868:   rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
21085:       "DROP TRIGGER IF EXISTS moz_historyvisits_afterdelete_v1_trigger"));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20868: 
21260: 
21259:   // bug #381795 - remove unused indexes
28350:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:       "DROP INDEX IF EXISTS moz_places_titleindex"));
28350:   NS_ENSURE_SUCCESS(rv, rv);
28350:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:       "DROP INDEX IF EXISTS moz_annos_item_idindex"));
21259:   NS_ENSURE_SUCCESS(rv, rv);
21259: 
21260: 
21260:   // Do a one-time re-creation of the moz_annos indexes (bug 415201)
21260:   PRBool oldIndexExists = PR_FALSE;
21260:   rv = mDBConn->IndexExists(NS_LITERAL_CSTRING("moz_annos_attributesindex"), &oldIndexExists);
21260:   NS_ENSURE_SUCCESS(rv, rv);
21260:   if (oldIndexExists) {
21260:     // drop old uri annos index
21260:     rv = mDBConn->ExecuteSimpleSQL(
21260:         NS_LITERAL_CSTRING("DROP INDEX moz_annos_attributesindex"));
21260:     NS_ENSURE_SUCCESS(rv, rv);
21260: 
21260:     // create new uri annos index
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_ANNOS_PLACEATTRIBUTE);
21260:     NS_ENSURE_SUCCESS(rv, rv);
21260: 
21260:     // drop old item annos index
28350:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:         "DROP INDEX IF EXISTS moz_items_annos_attributesindex"));
21260:     NS_ENSURE_SUCCESS(rv, rv);
21260: 
21260:     // create new item annos index
28193:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_ITEMSANNOS_PLACEATTRIBUTE);
21260:     NS_ENSURE_SUCCESS(rv, rv);
21260:   }
21260: 
20868:   return transaction.Commit();
20868: }
20868: 
28350: nsresult
28350: nsNavHistory::MigrateV9Up(mozIStorageConnection *aDBConn)
28350: {
28350:   mozStorageTransaction transaction(aDBConn, PR_FALSE);
28350:   // Added in Bug 488966.  The last_visit_date column caches the last
28350:   // visit date, this enhances SELECT performances when we
28350:   // need to sort visits by visit date.
28350:   // The cached value is synced by INSERT and DELETE triggers on
28350:   // moz_historyvisits_view, on every added or removed visit.
28350:   // See nsPlacesTriggers.h for details on the triggers.
28350:   PRBool oldIndexExists = PR_FALSE;
28350:   nsresult rv = mDBConn->IndexExists(
28350:     NS_LITERAL_CSTRING("moz_places_lastvisitdateindex"), &oldIndexExists);
28350:   NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:   if (!oldIndexExists) {
28350:     // Add last_visit_date column to moz_places.
28350:     rv = aDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:         "ALTER TABLE moz_places ADD last_visit_date INTEGER"));
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     rv = mDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_LASTVISITDATE);
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     // Now let's sync the column contents with real visit dates.
28350:     // This query can be really slow due to disk access, since it will basically
28350:     // dupe the table contents in the journal file, and then write them down
28350:     // in the database.
28350:     // We will temporary use a memory journal file, this has the advantage of
28350:     // reducing write times by a half, but will temporary consume more memory
28350:     // and increase risks of corruption if we should crash in the middle of this
28350:     // update.
28350:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:         "PRAGMA journal_mode = MEMORY"));
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:         "UPDATE moz_places SET last_visit_date = "
28350:           "(SELECT MAX(visit_date) "
28350:            "FROM moz_historyvisits "
28350:            "WHERE place_id = moz_places.id)"));
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350: 
28350:     // Restore the default journal mode.
28350:     rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28350:         "PRAGMA journal_mode = " DEFAULT_JOURNAL_MODE));
28350:     NS_ENSURE_SUCCESS(rv, rv);
28350:   }
28350: 
28350:   return transaction.Commit();
28350: }
28350: 
29518: nsresult
29518: nsNavHistory::MigrateV10Up(mozIStorageConnection *aDBConn)
29518: {
29518:   // LastModified is set to the same value as dateAdded on item creation.
29518:   // This way we can use lastModified index to sort.
29518:   nsresult rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
29518:       "UPDATE moz_bookmarks SET lastModified = dateAdded "
29518:       "WHERE lastModified IS NULL"));
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   return NS_OK;
29518: }
29518:    
    1: // nsNavHistory::GetUrlIdFor
    1: //
    1: //    Called by the bookmarks and annotation services, this function returns the
    1: //    ID of the row for the given URL, optionally creating one if it doesn't
    1: //    exist. A newly created entry will have no visits.
    1: //
    1: //    If aAutoCreate is false and the item doesn't exist, the entry ID will be
    1: //    zero.
    1: //
    1: //    This DOES NOT check for bad URLs other than that they're nonempty.
    1: 
    1: nsresult
    1: nsNavHistory::GetUrlIdFor(nsIURI* aURI, PRInt64* aEntryID,
    1:                           PRBool aAutoCreate)
    1: {
    1:   *aEntryID = 0;
    1: 
    1:   mozStorageStatementScoper statementResetter(mDBGetURLPageInfo);
    1:   nsresult rv = BindStatementURI(mDBGetURLPageInfo, 0, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasEntry = PR_FALSE;
    1:   rv = mDBGetURLPageInfo->ExecuteStep(&hasEntry);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
28350:   if (hasEntry)
    1:     return mDBGetURLPageInfo->GetInt64(kGetInfoIndex_PageID, aEntryID);
28350: 
28350:   if (aAutoCreate) {
    1:     // create a new hidden, untyped, unvisited entry
    1:     mDBGetURLPageInfo->Reset();
    1:     statementResetter.Abandon();
    1:     nsString voidString;
    1:     voidString.SetIsVoid(PR_TRUE);
10669:     return InternalAddNewPage(aURI, voidString, PR_TRUE, PR_FALSE, 0, PR_TRUE, aEntryID);
28350:   }
28350: 
    1:   // Doesn't exist: don't do anything, entry ID was already set to 0 above
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::InternalAddNewPage
    1: //
 8225: //    Adds a new page to the DB.
 8225: //    THIS SHOULD BE THE ONLY PLACE NEW moz_places ROWS ARE
    1: //    CREATED. This allows us to maintain better consistency.
    1: //
    1: //    If non-null, the new page ID will be placed into aPageID.
    1: 
    1: nsresult
13613: nsNavHistory::InternalAddNewPage(nsIURI* aURI,
13613:                                  const nsAString& aTitle,
13613:                                  PRBool aHidden,
13613:                                  PRBool aTyped,
10669:                                  PRInt32 aVisitCount,
10669:                                  PRBool aCalculateFrecency,
10669:                                  PRInt64* aPageID)
    1: {
    1:   mozStorageStatementScoper scoper(mDBAddNewPage);
    1:   nsresult rv = BindStatementURI(mDBAddNewPage, 0, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // title
    1:   if (aTitle.IsVoid()) {
34766:     rv = mDBAddNewPage->BindNullParameter(1);
34766:   }
34766:   else {
    1:     rv = mDBAddNewPage->BindStringParameter(1,
    1:         StringHead(aTitle, HISTORY_TITLE_LENGTH_MAX));
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // host (reversed with trailing period)
    1:   nsAutoString revHost;
    1:   rv = GetReversedHostname(aURI, revHost);
    1:   // Not all URI types have hostnames, so this is optional.
    1:   if (NS_SUCCEEDED(rv)) {
    1:     rv = mDBAddNewPage->BindStringParameter(2, revHost);
    1:   } else {
    1:     rv = mDBAddNewPage->BindNullParameter(2);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // hidden
    1:   rv = mDBAddNewPage->BindInt32Parameter(3, aHidden);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // typed
    1:   rv = mDBAddNewPage->BindInt32Parameter(4, aTyped);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10669:   nsCAutoString url;
10669:   rv = aURI->GetSpec(url);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // frecency
10669:   PRInt32 frecency = -1;
10669:   if (aCalculateFrecency) {
10669:     rv = CalculateFrecency(-1 /* no page id, since this page doesn't exist */,
13613:                            aTyped, aVisitCount, url, &frecency);
13613:     NS_ENSURE_SUCCESS(rv, rv);
13613:   }
13613: 
13613:   rv = mDBAddNewPage->BindInt32Parameter(5, frecency);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
    1:   rv = mDBAddNewPage->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // If the caller wants the page ID, go get it
    1:   if (aPageID) {
16751:     mozStorageStatementScoper scoper(mDBGetURLPageInfo);
16751: 
16751:     rv = BindStatementURI(mDBGetURLPageInfo, 0, aURI);
16751:     NS_ENSURE_SUCCESS(rv, rv);
16751: 
16751:     PRBool hasResult = PR_FALSE;
16751:     rv = mDBGetURLPageInfo->ExecuteStep(&hasResult);
16751:     NS_ENSURE_SUCCESS(rv, rv);
16751:     NS_ASSERTION(hasResult, "hasResult is false but the call succeeded?");
16751: 
16751:     *aPageID = mDBGetURLPageInfo->AsInt64(0);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistory::InternalAddVisit
    1: //
    1: //    Just a wrapper for inserting a new visit in the DB.
    1: 
    1: nsresult
    1: nsNavHistory::InternalAddVisit(PRInt64 aPageID, PRInt64 aReferringVisit,
    1:                                PRInt64 aSessionID, PRTime aTime,
    1:                                PRInt32 aTransitionType, PRInt64* visitID)
    1: {
    1:   nsresult rv;
16751: 
16751:   {
    1:     mozStorageStatementScoper scoper(mDBInsertVisit);
    1:   
    1:     rv = mDBInsertVisit->BindInt64Parameter(0, aReferringVisit);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = mDBInsertVisit->BindInt64Parameter(1, aPageID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = mDBInsertVisit->BindInt64Parameter(2, aTime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = mDBInsertVisit->BindInt32Parameter(3, aTransitionType);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = mDBInsertVisit->BindInt64Parameter(4, aSessionID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:     rv = mDBInsertVisit->Execute();
    1:     NS_ENSURE_SUCCESS(rv, rv);
16751:   }
16751: 
16751:   {
16751:     mozStorageStatementScoper scoper(mDBRecentVisitOfPlace);
16751: 
16751:     rv = mDBRecentVisitOfPlace->BindInt64Parameter(0, aPageID);
16751:     NS_ENSURE_SUCCESS(rv, rv);
16751:     rv = mDBRecentVisitOfPlace->BindInt64Parameter(1, aTime);
16751:     NS_ENSURE_SUCCESS(rv, rv);
16751:     rv = mDBRecentVisitOfPlace->BindInt64Parameter(2, aSessionID);
16751:     NS_ENSURE_SUCCESS(rv, rv);
16751: 
16751:     PRBool hasResult;
16751:     rv = mDBRecentVisitOfPlace->ExecuteStep(&hasResult);
16751:     NS_ENSURE_SUCCESS(rv, rv);
16751:     NS_ASSERTION(hasResult, "hasResult is false but the call succeeded?");
16751: 
16751:     *visitID = mDBRecentVisitOfPlace->AsInt64(0);
16751:   }
20868: 
16751:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::FindLastVisit
    1: //
    1: //    This finds the most recent visit to the given URL. If found, it will put
    1: //    that visit's ID and session into the respective out parameters and return
    1: //    true. Returns false if no visit is found.
    1: //
    1: //    This is used to compute the referring visit.
    1: 
    1: PRBool
    1: nsNavHistory::FindLastVisit(nsIURI* aURI, PRInt64* aVisitID,
    1:                             PRInt64* aSessionID)
    1: {
    1:   mozStorageStatementScoper scoper(mDBRecentVisitOfURL);
    1:   nsresult rv = BindStatementURI(mDBRecentVisitOfURL, 0, aURI);
 9760:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   PRBool hasMore;
    1:   rv = mDBRecentVisitOfURL->ExecuteStep(&hasMore);
 9760:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1:   if (hasMore) {
    1:     *aVisitID = mDBRecentVisitOfURL->AsInt64(0);
    1:     *aSessionID = mDBRecentVisitOfURL->AsInt64(1);
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistory::IsURIStringVisited
    1: //
    1: //    Takes a URL as a string and returns true if we've visited it.
    1: //
    1: //    Be careful to always reset the statement since it will be reused.
    1: 
    1: PRBool nsNavHistory::IsURIStringVisited(const nsACString& aURIString)
    1: {
    1: #ifdef LAZY_ADD
    1:   // check the lazy list to see if this has recently been added
    1:   for (PRUint32 i = 0; i < mLazyMessages.Length(); i ++) {
    1:     if (mLazyMessages[i].type == LazyMessage::Type_AddURI) {
    1:       if (aURIString.Equals(mLazyMessages[i].uriSpec))
    1:         return PR_TRUE;
    1:     }
    1:   }
    1: #endif
    1: 
    1:   // check the main DB
13698:   mozStorageStatementScoper scoper(mDBIsPageVisited);
13698:   nsresult rv = mDBIsPageVisited->BindUTF8StringParameter(0, aURIString);
    1:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   PRBool hasMore = PR_FALSE;
13698:   rv = mDBIsPageVisited->ExecuteStep(&hasMore);
    1:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
13698:   return hasMore;
    1: }
    1: 
    1: 
    1: // nsNavHistory::LoadPrefs
    1: 
    1: nsresult
10669: nsNavHistory::LoadPrefs(PRBool aInitializing)
    1: {
    1:   if (! mPrefBranch)
    1:     return NS_OK;
    1: 
 8761:   mPrefBranch->GetIntPref(PREF_BROWSER_HISTORY_EXPIRE_DAYS_MAX, &mExpireDaysMax);
 8761:   mPrefBranch->GetIntPref(PREF_BROWSER_HISTORY_EXPIRE_DAYS_MIN, &mExpireDaysMin);
13237:   // Cap max days to min days to prevent expiring pages younger than min
13334:   // NOTE: if history is disabled in preferences, then mExpireDaysMax == 0
13334:   if (mExpireDaysMax && mExpireDaysMax < mExpireDaysMin)
13237:     mExpireDaysMax = mExpireDaysMin;
 8761:   if (NS_FAILED(mPrefBranch->GetIntPref(PREF_BROWSER_HISTORY_EXPIRE_SITES,
 8761:                                         &mExpireSites)))
 8761:     mExpireSites = EXPIRATION_CAP_SITES;
 8240: 
10669:   // get the frecency prefs
10669:   nsCOMPtr<nsIPrefBranch> prefs(do_GetService("@mozilla.org/preferences-service;1"));
10669:   if (prefs) {
10669:     prefs->GetIntPref(PREF_FRECENCY_NUM_VISITS, 
10669:       &mNumVisitsForFrecency);
10669:     prefs->GetIntPref(PREF_FRECENCY_FIRST_BUCKET_CUTOFF, 
10669:       &mFirstBucketCutoffInDays);
10669:     prefs->GetIntPref(PREF_FRECENCY_SECOND_BUCKET_CUTOFF,
10669:       &mSecondBucketCutoffInDays);
10669:     prefs->GetIntPref(PREF_FRECENCY_THIRD_BUCKET_CUTOFF, 
10669:       &mThirdBucketCutoffInDays);
10669:     prefs->GetIntPref(PREF_FRECENCY_FOURTH_BUCKET_CUTOFF, 
10669:       &mFourthBucketCutoffInDays);
10669:     prefs->GetIntPref(PREF_FRECENCY_EMBED_VISIT_BONUS, 
10669:       &mEmbedVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_LINK_VISIT_BONUS, 
10669:       &mLinkVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_TYPED_VISIT_BONUS, 
10669:       &mTypedVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_BOOKMARK_VISIT_BONUS, 
10669:       &mBookmarkVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_DOWNLOAD_VISIT_BONUS, 
10669:       &mDownloadVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_PERM_REDIRECT_VISIT_BONUS, 
10669:       &mPermRedirectVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_TEMP_REDIRECT_VISIT_BONUS, 
10669:       &mTempRedirectVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_DEFAULT_VISIT_BONUS, 
10669:       &mDefaultVisitBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_UNVISITED_BOOKMARK_BONUS, 
10669:       &mUnvisitedBookmarkBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_UNVISITED_TYPED_BONUS,
10669:       &mUnvisitedTypedBonus);
10669:     prefs->GetIntPref(PREF_FRECENCY_FIRST_BUCKET_WEIGHT, 
10669:       &mFirstBucketWeight);
10669:     prefs->GetIntPref(PREF_FRECENCY_SECOND_BUCKET_WEIGHT, 
10669:       &mSecondBucketWeight);
10669:     prefs->GetIntPref(PREF_FRECENCY_THIRD_BUCKET_WEIGHT, 
10669:       &mThirdBucketWeight);
10669:     prefs->GetIntPref(PREF_FRECENCY_FOURTH_BUCKET_WEIGHT, 
10669:       &mFourthBucketWeight);
10669:     prefs->GetIntPref(PREF_FRECENCY_DEFAULT_BUCKET_WEIGHT, 
10669:       &mDefaultWeight);
10669:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::GetNow
    1: //
    1: //    This is a hack to avoid calling PR_Now() too often, as is the case when
    1: //    we're asked the ageindays of many history entries in a row. A timer is
    1: //    set which will clear our valid flag after a short timeout.
    1: 
    1: PRTime
    1: nsNavHistory::GetNow()
    1: {
    1:   if (!mNowValid) {
    1:     mLastNow = PR_Now();
    1:     mNowValid = PR_TRUE;
    1:     if (!mExpireNowTimer)
    1:       mExpireNowTimer = do_CreateInstance("@mozilla.org/timer;1");
    1: 
    1:     if (mExpireNowTimer)
    1:       mExpireNowTimer->InitWithFuncCallback(expireNowTimerCallback, this,
    1:                                             HISTORY_EXPIRE_NOW_TIMEOUT,
    1:                                             nsITimer::TYPE_ONE_SHOT);
    1:   }
    1: 
    1:   return mLastNow;
    1: }
    1: 
    1: 
    1: // nsNavHistory::expireNowTimerCallback
    1: 
    1: void nsNavHistory::expireNowTimerCallback(nsITimer* aTimer, void* aClosure)
    1: {
 3233:   nsNavHistory *history = static_cast<nsNavHistory *>(aClosure);
    1:   history->mNowValid = PR_FALSE;
    1:   history->mExpireNowTimer = nsnull;
    1: }
    1: 
    1: static PRTime
    1: NormalizeTimeRelativeToday(PRTime aTime)
    1: {
    1:   // round to midnight this morning
    1:   PRExplodedTime explodedTime;
    1:   PR_ExplodeTime(aTime, PR_LocalTimeParameters, &explodedTime);
    1: 
    1:   // set to midnight (0:00)
    1:   explodedTime.tm_min =
    1:     explodedTime.tm_hour =
    1:     explodedTime.tm_sec =
    1:     explodedTime.tm_usec = 0;
    1: 
    1:   return PR_ImplodeTime(&explodedTime);
    1: }
    1: 
    1: // nsNavHistory::NormalizeTime
    1: //
    1: //    Converts a nsINavHistoryQuery reference+offset time into a PRTime
    1: //    relative to the epoch.
    1: //
    1: //    It is important that this function NOT use the current time optimization.
    1: //    It is called to update queries, and we really need to know what right
    1: //    now is because those incoming values will also have current times that
    1: //    we will have to compare against.
    1: 
    1: PRTime // static
    1: nsNavHistory::NormalizeTime(PRUint32 aRelative, PRTime aOffset)
    1: {
    1:   PRTime ref;
    1:   switch (aRelative)
    1:   {
    1:     case nsINavHistoryQuery::TIME_RELATIVE_EPOCH:
    1:       return aOffset;
    1:     case nsINavHistoryQuery::TIME_RELATIVE_TODAY:
    1:       ref = NormalizeTimeRelativeToday(PR_Now());
    1:       break;
    1:     case nsINavHistoryQuery::TIME_RELATIVE_NOW:
    1:       ref = PR_Now();
    1:       break;
    1:     default:
    1:       NS_NOTREACHED("Invalid relative time");
    1:       return 0;
    1:   }
    1:   return ref + aOffset;
    1: }
    1: 
12328: // nsNavHistory::GetUpdateRequirements
    1: //
12328: //    Returns conditions for query update.
    1: //
    1: //    QUERYUPDATE_TIME:
    1: //      This query is only limited by an inclusive time range on the first
    1: //      query object. The caller can quickly evaluate the time itself if it
    1: //      chooses. This is even simpler than "simple" below.
    1: //    QUERYUPDATE_SIMPLE:
    1: //      This query is evaluatable using EvaluateQueryForNode to do live
    1: //      updating.
    1: //    QUERYUPDATE_COMPLEX:
    1: //      This query is not evaluatable using EvaluateQueryForNode. When something
    1: //      happens that this query updates, you will need to re-run the query.
    1: //    QUERYUPDATE_COMPLEX_WITH_BOOKMARKS:
    1: //      A complex query that additionally has dependence on bookmarks. All
    1: //      bookmark-dependent queries fall under this category.
    1: //
    1: //    aHasSearchTerms will be set to true if the query has any dependence on
    1: //    keywords. When there is no dependence on keywords, we can handle title
    1: //    change operations as simple instead of complex.
    1: 
    1: PRUint32
    1: nsNavHistory::GetUpdateRequirements(const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:                                     nsNavHistoryQueryOptions* aOptions,
    1:                                     PRBool* aHasSearchTerms)
    1: {
    1:   NS_ASSERTION(aQueries.Count() > 0, "Must have at least one query");
    1: 
    1:   // first check if there are search terms
    1:   *aHasSearchTerms = PR_FALSE;
    1:   PRInt32 i;
    1:   for (i = 0; i < aQueries.Count(); i ++) {
    1:     aQueries[i]->GetHasSearchTerms(aHasSearchTerms);
    1:     if (*aHasSearchTerms)
    1:       break;
    1:   }
    1: 
    1:   PRBool nonTimeBasedItems = PR_FALSE;
12328:   PRBool domainBasedItems = PR_FALSE;
12328: 
    1:   for (i = 0; i < aQueries.Count(); i ++) {
    1:     nsNavHistoryQuery* query = aQueries[i];
    1: 
27981:     if (query->Folders().Length() > 0 ||
27981:         query->OnlyBookmarked() ||
27981:         query->Tags().Length() > 0) {
    1:       return QUERYUPDATE_COMPLEX_WITH_BOOKMARKS;
    1:     }
    1:     // Note: we don't currently have any complex non-bookmarked items, but these
    1:     // are expected to be added. Put detection of these items here.
    1:     if (! query->SearchTerms().IsEmpty() ||
    1:         ! query->Domain().IsVoid() ||
    1:         query->Uri() != nsnull)
    1:       nonTimeBasedItems = PR_TRUE;
12328: 
12328:     if (! query->Domain().IsVoid())
12328:       domainBasedItems = PR_TRUE;
    1:   }
    1: 
12737:   if (aOptions->ResultType() ==
12737:       nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY)
12737:     return QUERYUPDATE_COMPLEX_WITH_BOOKMARKS;
12737: 
 3544:   // Whenever there is a maximum number of results, 
 3544:   // and we are not a bookmark query we must requery. This
 3544:   // is because we can't generally know if any given addition/change causes
 3544:   // the item to be in the top N items in the database.
 3544:   if (aOptions->MaxResults() > 0)
 3544:     return QUERYUPDATE_COMPLEX;
 3544: 
12328:   if (aQueries.Count() == 1 && domainBasedItems)
12328:     return QUERYUPDATE_HOST;
    1:   if (aQueries.Count() == 1 && ! nonTimeBasedItems)
    1:     return QUERYUPDATE_TIME;
    1:   return QUERYUPDATE_SIMPLE;
    1: }
    1: 
    1: 
    1: // nsNavHistory::EvaluateQueryForNode
    1: //
    1: //    This runs the node through the given queries to see if satisfies the
    1: //    query conditions. Not every query parameters are handled by this code,
    1: //    but we handle the most common ones so that performance is better.
    1: //
    1: //    We assume that the time on the node is the time that we want to compare.
    1: //    This is not necessarily true because URL nodes have the last access time,
    1: //    which is not necessarily the same. However, since this is being called
    1: //    to update the list, we assume that the last access time is the current
    1: //    access time that we are being asked to compare so it works out.
    1: //
    1: //    Returns true if node matches the query, false if not.
    1: 
    1: PRBool
    1: nsNavHistory::EvaluateQueryForNode(const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:                                    nsNavHistoryQueryOptions* aOptions,
    1:                                    nsNavHistoryResultNode* aNode)
    1: {
    1:   // lazily created from the node's string when we need to match URIs
    1:   nsCOMPtr<nsIURI> nodeUri;
    1: 
    1:   for (PRInt32 i = 0; i < aQueries.Count(); i ++) {
    1:     PRBool hasIt;
    1:     nsCOMPtr<nsNavHistoryQuery> query = aQueries[i];
    1: 
    1:     // --- begin time ---
    1:     query->GetHasBeginTime(&hasIt);
    1:     if (hasIt) {
    1:       PRTime beginTime = NormalizeTime(query->BeginTimeReference(),
    1:                                        query->BeginTime());
    1:       if (aNode->mTime < beginTime)
    1:         continue; // before our time range
    1:     }
    1: 
    1:     // --- end time ---
    1:     query->GetHasEndTime(&hasIt);
    1:     if (hasIt) {
    1:       PRTime endTime = NormalizeTime(query->EndTimeReference(),
    1:                                      query->EndTime());
    1:       if (aNode->mTime > endTime)
    1:         continue; // after our time range
    1:     }
    1: 
    1:     // --- search terms ---
    1:     if (! query->SearchTerms().IsEmpty()) {
    1:       // we can use the existing filtering code, just give it our one object in
    1:       // an array.
    1:       nsCOMArray<nsNavHistoryResultNode> inputSet;
    1:       inputSet.AppendObject(aNode);
 5909:       nsCOMArray<nsNavHistoryQuery> queries;
 5909:       queries.AppendObject(query);
    1:       nsCOMArray<nsNavHistoryResultNode> filteredSet;
 6483:       nsresult rv = FilterResultSet(nsnull, inputSet, &filteredSet, queries, aOptions);
    1:       if (NS_FAILED(rv))
    1:         continue;
    1:       if (! filteredSet.Count())
    1:         continue; // did not make it through the filter, doesn't match
    1:     }
    1: 
    1:     // --- domain/host matching ---
    1:     query->GetHasDomain(&hasIt);
    1:     if (hasIt) {
    1:       if (! nodeUri) {
    1:         // lazy creation of nodeUri, which might be checked for multiple queries
    1:         if (NS_FAILED(NS_NewURI(getter_AddRefs(nodeUri), aNode->mURI)))
    1:           continue;
    1:       }
11302:       nsCAutoString asciiRequest;
11302:       if (NS_FAILED(AsciiHostNameFromHostString(query->Domain(), asciiRequest)))
11302:         continue;
11302: 
11302:       if (query->DomainIsHost()) {
11056:         nsCAutoString host;
11056:         if (NS_FAILED(nodeUri->GetAsciiHost(host)))
11056:           continue;
11302: 
    1:         if (! asciiRequest.Equals(host))
    1:           continue; // host names don't match
    1:       }
    1:       // check domain names
    1:       nsCAutoString domain;
11302:       DomainNameFromURI(nodeUri, domain);
    1:       if (! asciiRequest.Equals(domain))
    1:         continue; // domain names don't match
    1:     }
    1: 
    1:     // --- URI matching ---
    1:     if (query->Uri()) {
    1:       if (! nodeUri) { // lazy creation of nodeUri
    1:         if (NS_FAILED(NS_NewURI(getter_AddRefs(nodeUri), aNode->mURI)))
    1:           continue;
    1:       }
    1:       if (! query->UriIsPrefix()) {
    1:         // easy case: the URI is an exact match
    1:         PRBool equals;
    1:         nsresult rv = query->Uri()->Equals(nodeUri, &equals);
11019:         NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1:         if (! equals)
    1:           continue;
    1:       } else {
    1:         // harder case: match prefix, note that we need to get the ASCII string
    1:         // from the node's parsed URI instead of using the node's mUrl string,
    1:         // because that might not be normalized
    1:         nsCAutoString nodeUriString;
    1:         nodeUri->GetAsciiSpec(nodeUriString);
    1:         nsCAutoString queryUriString;
    1:         query->Uri()->GetAsciiSpec(queryUriString);
    1:         if (queryUriString.Length() > nodeUriString.Length())
    1:           continue; // not long enough to match as prefix
    1:         nodeUriString.SetLength(queryUriString.Length());
    1:         if (! nodeUriString.Equals(queryUriString))
    1:           continue; // prefixes don't match
    1:       }
    1:     }
    1: 
    1:     // If we ever make it to the bottom of this loop, that means it passed all
    1:     // tests for the given query. Since queries are ORed together, that means
    1:     // it passed everything and we are done.
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // didn't match any query
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistory::AsciiHostNameFromHostString
    1: //
    1: //    We might have interesting encodings and different case in the host name.
    1: //    This will convert that host name into an ASCII host name by sending it
    1: //    through the URI canonicalization. The result can be used for comparison
    1: //    with other ASCII host name strings.
    1: 
    1: nsresult // static
    1: nsNavHistory::AsciiHostNameFromHostString(const nsACString& aHostName,
    1:                                           nsACString& aAscii)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aHostName);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   return uri->GetAsciiHost(aAscii);
    1: }
    1: 
    1: 
11302: // nsNavHistory::DomainNameFromURI
    1: //
    1: //    This does the www.mozilla.org -> mozilla.org and
    1: //    foo.theregister.co.uk -> theregister.co.uk conversion
    1: 
11302: void
11302: nsNavHistory::DomainNameFromURI(nsIURI *aURI,
    1:                                 nsACString& aDomainName)
    1: {
11316:   // lazily get the effective tld service
11316:   if (!mTLDService)
11316:     mTLDService = do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID);
11316: 
11316:   if (mTLDService) {
11302:     // get the base domain for a given hostname.
11302:     // e.g. for "images.bbc.co.uk", this would be "bbc.co.uk".
11302:     nsresult rv = mTLDService->GetBaseDomain(aURI, 0, aDomainName);
11316:     if (NS_SUCCEEDED(rv))
11316:       return;
11316:   }
11316: 
11302:   // just return the original hostname
11302:   // (it's also possible the host is an IP address)
11302:   aURI->GetAsciiHost(aDomainName);
    1: }
    1: 
    1: 
    1: // Nav history *****************************************************************
    1: 
    1: 
    1: // nsNavHistory::GetHasHistoryEntries
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::GetHasHistoryEntries(PRBool* aHasEntries)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG_POINTER(aHasEntries);
18819: 
    1:   nsCOMPtr<mozIStorageStatement> dbSelectStatement;
20868:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT 1 "
20868:       "WHERE EXISTS (SELECT id FROM moz_historyvisits_temp LIMIT 1) "
20868:         "OR EXISTS (SELECT id FROM moz_historyvisits LIMIT 1)"),
    1:     getter_AddRefs(dbSelectStatement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   return dbSelectStatement->ExecuteStep(aHasEntries);
    1: }
    1: 
10669: nsresult
10669: nsNavHistory::FixInvalidFrecenciesForExcludedPlaces()
10669: {
13613:   // for every moz_place that has an invalid frecency (< 0) and
13613:   // is an unvisited child of a livemark feed, or begins with "place:",
10669:   // set frecency to 0 so that it is excluded from url bar autocomplete.
10669:   nsCOMPtr<mozIStorageStatement> dbUpdateStatement;
13613:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "UPDATE moz_places_view "
13613:       "SET frecency = 0 WHERE id IN ("
13613:         "SELECT h.id FROM moz_places h "
20868:         "WHERE h.url >= 'place:' AND h.url < 'place;' "
20868:         "UNION "
20868:         "SELECT h.id FROM moz_places_temp h "
20868:         "WHERE  h.url >= 'place:' AND h.url < 'place;' "
20868:         "UNION "
20868:         // Unvisited child of a livemark
20868:         "SELECT b.fk FROM moz_bookmarks b "
23196:         "JOIN moz_bookmarks bp ON bp.id = b.parent "
23196:         "JOIN moz_items_annos a ON a.item_id = bp.id "
20868:         "JOIN moz_anno_attributes n ON n.id = a.anno_attribute_id "
20868:         "WHERE n.name = ?1 "
23196:         "AND b.fk IN( "
20868:           "SELECT id FROM moz_places WHERE visit_count = 0 AND frecency < 0 "
20868:           "UNION ALL "
20868:           "SELECT id FROM moz_places_temp WHERE visit_count = 0 AND frecency < 0 "
20868:         ") "
20868:       ")"),
10669:     getter_AddRefs(dbUpdateStatement));
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   rv = dbUpdateStatement->BindUTF8StringParameter(0, NS_LITERAL_CSTRING(LMANNO_FEEDURI));
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   rv = dbUpdateStatement->Execute();
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   return NS_OK;
10669: }
10669: 
10669: nsresult
13613: nsNavHistory::CalculateFullVisitCount(PRInt64 aPlaceId, PRInt32 *aVisitCount)
10669: {
13613:   mozStorageStatementScoper scope(mDBFullVisitCount);
13613: 
13613:   nsresult rv = mDBFullVisitCount->BindInt64Parameter(0, aPlaceId);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   PRBool hasVisits = PR_TRUE;
13613:   rv = mDBFullVisitCount->ExecuteStep(&hasVisits);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   if (hasVisits) {
13613:     rv = mDBFullVisitCount->GetInt32(0, aVisitCount);
10669:     NS_ENSURE_SUCCESS(rv, rv);
10669:   }
10669:   else
10669:     *aVisitCount = 0;
10669:   
10669:   return NS_OK;
10669: }
    1: 
    1: // nsNavHistory::MarkPageAsFollowedBookmark
    1: //
 9700: // We call MarkPageAsFollowedBookmark() before visiting a URL in order to 
 9700: // help determine the transition type of the visit.  
 9700: // We keep track of the URL so that later, in AddVisitChain() 
 9700: // we can use TRANSITION_BOOKMARK as the transition.
 9700: // Note, AddVisitChain() is not called immediately when we are doing LAZY_ADDs
 9700: //
    1: // @see MarkPageAsTyped
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::MarkPageAsFollowedBookmark(nsIURI* aURI)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
    1:   // don't add when history is disabled
    1:   if (IsHistoryDisabled())
    1:     return NS_OK;
    1: 
    1:   nsCAutoString uriString;
10669:   nsresult rv = aURI->GetSpec(uriString);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // if URL is already in the bookmark queue, then we need to remove the old one
    1:   PRInt64 unusedEventTime;
    1:   if (mRecentBookmark.Get(uriString, &unusedEventTime))
    1:     mRecentBookmark.Remove(uriString);
    1: 
    1:   if (mRecentBookmark.Count() > RECENT_EVENT_QUEUE_MAX_LENGTH)
    1:     ExpireNonrecentEvents(&mRecentBookmark);
    1: 
 9700:   mRecentBookmark.Put(uriString, GetNow());
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::CanAddURI
    1: //
    1: //    Filter out unwanted URIs such as "chrome:", "mailbox:", etc.
    1: //
    1: //    The model is if we don't know differently then add which basically means
    1: //    we are suppose to try all the things we know not to allow in and then if
    1: //    we don't bail go on and allow it in.
    1: 
14666: NS_IMETHODIMP
    1: nsNavHistory::CanAddURI(nsIURI* aURI, PRBool* canAdd)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
28236:   NS_ENSURE_ARG_POINTER(canAdd);
14666: 
20637:   // If the user is in private browsing mode, don't add any entry.
20637:   if (InPrivateBrowsingMode()) {
20637:     *canAdd = PR_FALSE;
20637:     return NS_OK;
20637:   }
20637: 
10669:   nsCAutoString scheme;
10669:   nsresult rv = aURI->GetScheme(scheme);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // first check the most common cases (HTTP, HTTPS) to allow in to avoid most
    1:   // of the work
    1:   if (scheme.EqualsLiteral("http")) {
    1:     *canAdd = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   if (scheme.EqualsLiteral("https")) {
    1:     *canAdd = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // now check for all bad things
    1:   if (scheme.EqualsLiteral("about") ||
    1:       scheme.EqualsLiteral("imap") ||
    1:       scheme.EqualsLiteral("news") ||
    1:       scheme.EqualsLiteral("mailbox") ||
    1:       scheme.EqualsLiteral("moz-anno") ||
    1:       scheme.EqualsLiteral("view-source") ||
    1:       scheme.EqualsLiteral("chrome") ||
19906:       scheme.EqualsLiteral("data") ||
19906:       scheme.EqualsLiteral("wyciwyg")) {
    1:     *canAdd = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1:   *canAdd = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistory::AddVisit
    1: //
    1: //    Adds or updates a page with the given URI. The ID of the new visit will
    1: //    be put into aVisitID.
    1: //
    1: //    THE RETURNED NEW VISIT ID MAY BE 0 indicating that this page should not be
    1: //    added to the history.
    1: 
    1: NS_IMETHODIMP
 9607: nsNavHistory::AddVisit(nsIURI* aURI, PRTime aTime, nsIURI* aReferringURI,
    1:                        PRInt32 aTransitionType, PRBool aIsRedirect,
    1:                        PRInt64 aSessionID, PRInt64* aVisitID)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
28236:   NS_ENSURE_ARG_POINTER(aVisitID);
14666: 
    1:   // Filter out unwanted URIs, silently failing
    1:   PRBool canAdd = PR_FALSE;
10669:   nsresult rv = CanAddURI(aURI, &canAdd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!canAdd) {
    1:     *aVisitID = 0;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // This will prevent corruption since we have to do a two-phase add.
    1:   // Generally this won't do anything because AddURI has its own transaction.
 8239:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
    1:   // see if this is an update (revisit) or a new page
    1:   mozStorageStatementScoper scoper(mDBGetPageVisitStats);
    1:   rv = BindStatementURI(mDBGetPageVisitStats, 0, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
14273:   PRBool alreadyVisited = PR_FALSE;
    1:   rv = mDBGetPageVisitStats->ExecuteStep(&alreadyVisited);
14273:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt64 pageID = 0;
23588:   PRInt32 hidden;
23588:   PRInt32 typed;
    1:   PRBool newItem = PR_FALSE; // used to send out notifications at the end
    1:   if (alreadyVisited) {
    1:     // Update the existing entry...
    1:     rv = mDBGetPageVisitStats->GetInt64(0, &pageID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRInt32 oldVisitCount = 0;
    1:     rv = mDBGetPageVisitStats->GetInt32(1, &oldVisitCount);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRInt32 oldTypedState = 0;
    1:     rv = mDBGetPageVisitStats->GetInt32(2, &oldTypedState);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
11019:     PRBool oldHiddenState = 0;
    1:     rv = mDBGetPageVisitStats->GetInt32(3, &oldHiddenState);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // free the previous statement before we make a new one
    1:     mDBGetPageVisitStats->Reset();
    1:     scoper.Abandon();
    1: 
    1:     // embedded links and redirects will be hidden, but don't hide pages that
    1:     // are already unhidden.
    1:     //
    1:     // Note that we test the redirect flag and not for the redirect transition
    1:     // type. The transition type refers to how we got here, and whether a page
    1:     // is shown does not depend on whether you got to it through a redirect.
27702:     // Rather, we want to hide pages that redirect themselves somewhere
    1:     // else, which is what the redirect flag means.
 4837:     //
 4837:     // note, we want to unhide any hidden pages that the user explicitly types
 4837:     // (aTransitionType == TRANSITION_TYPED) so that they will appear in
 4837:     // the history UI (sidebar, history menu, url bar autocomplete, etc)
    1:     hidden = oldHiddenState;
23588:     if (hidden == 1 && (!aIsRedirect || aTransitionType == TRANSITION_TYPED) &&
14564:         aTransitionType != TRANSITION_EMBED)
23588:       hidden = 0; // unhide
23588: 
23588:     typed = (PRInt32)(oldTypedState == 1 || (aTransitionType == TRANSITION_TYPED));
    1: 
13613:     // some items may have a visit count of 0 which will not count for link
    1:     // visiting, so be sure to note this transition
13613:     if (oldVisitCount == 0)
    1:       newItem = PR_TRUE;
    1: 
    1:     // update with new stats
    1:     mozStorageStatementScoper updateScoper(mDBUpdatePageVisitStats);
    1:     rv = mDBUpdatePageVisitStats->BindInt64Parameter(0, pageID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
10669: 
13613:     rv = mDBUpdatePageVisitStats->BindInt32Parameter(1, hidden);
13613:     NS_ENSURE_SUCCESS(rv, rv);
13613:     rv = mDBUpdatePageVisitStats->BindInt32Parameter(2, typed);
    1:     NS_ENSURE_SUCCESS(rv, rv);
10669: 
    1:     rv = mDBUpdatePageVisitStats->Execute();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     // New page
    1:     newItem = PR_TRUE;
    1: 
    1:     // free the previous statement before we make a new one
    1:     mDBGetPageVisitStats->Reset();
    1:     scoper.Abandon();
    1: 
14564:     // Hide only embedded links and redirects
    1:     // See the hidden computation code above for a little more explanation.
23588:     hidden = (PRInt32)(aTransitionType == TRANSITION_EMBED || aIsRedirect);
23588: 
23588:     typed = (PRInt32)(aTransitionType == TRANSITION_TYPED);
    1: 
    1:     // set as visited once, no title
    1:     nsString voidString;
    1:     voidString.SetIsVoid(PR_TRUE);
23588:     rv = InternalAddNewPage(aURI, voidString, hidden == 1, typed == 1, 1,
23588:                             PR_TRUE, &pageID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
 9607:   // Get the place id for the referrer, if we have one
 9607:   PRInt64 referringVisitID = 0;
 9607:   PRInt64 referringSessionID;
 9607:   if (aReferringURI &&
 9607:       !FindLastVisit(aReferringURI, &referringVisitID, &referringSessionID)) {
 9607:     // Add the referrer
 9607:     rv = AddVisit(aReferringURI, aTime - 1, nsnull, TRANSITION_LINK, PR_FALSE,
 9607:                   aSessionID, &referringVisitID);
 9607:     if (NS_FAILED(rv))
 9607:       referringVisitID = 0;
 9607:   }
 9607: 
 9607:   rv = InternalAddVisit(pageID, referringVisitID, aSessionID, aTime,
    1:                         aTransitionType, aVisitID);
10669:   transaction.Commit();
10669: 
10669:   // Update frecency (*after* the visit info is in the db)
10669:   // Swallow errors here, since if we've gotten this far, it's more
10669:   // important to notify the observers below.
24324:   nsNavBookmarks *bs = nsNavBookmarks::GetBookmarksService();
35298:   NS_ENSURE_TRUE(bs, NS_ERROR_OUT_OF_MEMORY);
24324:   (void)UpdateFrecency(pageID, bs->IsRealBookmark(pageID));
    1: 
    1:   // Notify observers: The hidden detection code must match that in
    1:   // GetQueryResults to maintain consistency.
    1:   // FIXME bug 325241: make a way to observe hidden URLs
12328:   PRUint32 added = 0;
13613:   if (!hidden && aTransitionType != TRANSITION_EMBED &&
13613:                  aTransitionType != TRANSITION_DOWNLOAD) {
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavHistoryObserver,
    1:                         OnVisit(aURI, *aVisitID, aTime, aSessionID,
12328:                                 referringVisitID, aTransitionType, &added));
    1:   }
    1: 
10669:   // Normally docshell sends the link visited observer notification for us (this
    1:   // will tell all the documents to update their visited link coloring).
 9689:   // However, for redirects (since we implement nsIGlobalHistory3) and downloads
 9689:   // (since we implement nsIDownloadHistory) this will not happen and we need to
 9689:   // send it ourselves.
 9689:   if (newItem && (aIsRedirect || aTransitionType == TRANSITION_DOWNLOAD)) {
    1:     nsCOMPtr<nsIObserverService> obsService =
    1:       do_GetService("@mozilla.org/observer-service;1");
    1:     if (obsService)
    1:       obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::GetNewQuery
    1: 
28236: NS_IMETHODIMP
28236: nsNavHistory::GetNewQuery(nsINavHistoryQuery **_retval)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG_POINTER(_retval);
18819: 
    1:   *_retval = new nsNavHistoryQuery();
    1:   if (! *_retval)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistory::GetNewQueryOptions
    1: 
28236: NS_IMETHODIMP
28236: nsNavHistory::GetNewQueryOptions(nsINavHistoryQueryOptions **_retval)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG_POINTER(_retval);
18819: 
    1:   *_retval = new nsNavHistoryQueryOptions();
    1:   NS_ENSURE_TRUE(*_retval, NS_ERROR_OUT_OF_MEMORY);
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistory::ExecuteQuery
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::ExecuteQuery(nsINavHistoryQuery *aQuery, nsINavHistoryQueryOptions *aOptions,
    1:                            nsINavHistoryResult** _retval)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aQuery);
28236:   NS_ENSURE_ARG(aOptions);
28236:   NS_ENSURE_ARG_POINTER(_retval);
18819: 
    1:   return ExecuteQueries(&aQuery, 1, aOptions, _retval);
    1: }
    1: 
    1: 
    1: // nsNavHistory::ExecuteQueries
    1: //
    1: //    This function is actually very simple, we just create the proper root node (either
    1: //    a bookmark folder or a complex query node) and assign it to the result. The node
    1: //    will then populate itself accordingly.
    1: //
    1: //    Quick overview of query operation: When you call this function, we will construct
    1: //    the correct container node and set the options you give it. This node will then
    1: //    fill itself. Folder nodes will call nsNavBookmarks::QueryFolderChildren, and
    1: //    all other queries will call GetQueryResults. If these results contain other
    1: //    queries, those will be populated when the container is opened.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::ExecuteQueries(nsINavHistoryQuery** aQueries, PRUint32 aQueryCount,
    1:                              nsINavHistoryQueryOptions *aOptions,
    1:                              nsINavHistoryResult** _retval)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aQueries);
28236:   NS_ENSURE_ARG(aOptions);
28236:   NS_ENSURE_ARG(aQueryCount);
28236:   NS_ENSURE_ARG_POINTER(_retval);
18819: 
    1:   nsresult rv;
    1:   // concrete options
    1:   nsCOMPtr<nsNavHistoryQueryOptions> options = do_QueryInterface(aOptions);
    1:   NS_ENSURE_TRUE(options, NS_ERROR_INVALID_ARG);
    1: 
    1:   // concrete queries array
    1:   nsCOMArray<nsNavHistoryQuery> queries;
    1:   for (PRUint32 i = 0; i < aQueryCount; i ++) {
    1:     nsCOMPtr<nsNavHistoryQuery> query = do_QueryInterface(aQueries[i], &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     queries.AppendObject(query);
    1:   }
    1: 
    1:   // root node
    1:   nsRefPtr<nsNavHistoryContainerResultNode> rootNode;
  809:   PRInt64 folderId = GetSimpleBookmarksQueryFolder(queries, options);
    1:   if (folderId) {
    1:     // In the simple case where we're just querying children of a single bookmark
    1:     // folder, we can more efficiently generate results.
    1:     nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
    1:     NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
 7025:     nsRefPtr<nsNavHistoryResultNode> tempRootNode;
 4179:     rv = bookmarks->ResultNodeForContainer(folderId, options,
    1:                                            getter_AddRefs(tempRootNode));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rootNode = tempRootNode->GetAsContainer();
    1:   } else {
    1:     // complex query
    1:     rootNode = new nsNavHistoryQueryResultNode(EmptyCString(), EmptyCString(),
    1:                                                queries, options);
    1:     NS_ENSURE_TRUE(rootNode, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   // result object
    1:   nsRefPtr<nsNavHistoryResult> result;
    1:   rv = nsNavHistoryResult::NewHistoryResult(aQueries, aQueryCount, options, rootNode,
    1:                                             getter_AddRefs(result));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   NS_ADDREF(*_retval = result);
    1:   return NS_OK;
    1: }
    1: 
 4049: // determine from our nsNavHistoryQuery array and nsNavHistoryQueryOptions
 4049: // if this is the place query from the history menu.
 4049: // from browser-menubar.inc, our history menu query is:
26258: // place:redirectsMode=2&sort=4&maxResults=10
 4049: // note, any maxResult > 0 will still be considered a history menu query
 8789: // or if this is the place query from the "Most Visited" item in the "Smart Bookmarks" folder:
26258: // place:redirectsMode=2&sort=8&maxResults=10
 8789: // note, any maxResult > 0 will still be considered a Most Visited menu query
 4049: static
27459: PRBool IsOptimizableHistoryQuery(const nsCOMArray<nsNavHistoryQuery>& aQueries,
27459:                                  nsNavHistoryQueryOptions *aOptions,
27459:                                  PRUint16 aSortMode)
 4049: {
 4049:   if (aQueries.Count() != 1)
 4049:     return PR_FALSE;
 4049: 
 4049:   nsNavHistoryQuery *aQuery = aQueries[0];
 4049:  
 4049:   if (aOptions->QueryType() != nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY)
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aOptions->ResultType() != nsINavHistoryQueryOptions::RESULTS_AS_URI)
 4049:     return PR_FALSE;
 4049: 
 8789:   if (aOptions->SortingMode() != aSortMode)
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aOptions->MaxResults() <= 0)
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aOptions->ExcludeItems())
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aOptions->IncludeHidden())
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->MinVisits() != -1 || aQuery->MaxVisits() != -1)
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->BeginTime() || aQuery->BeginTimeReference()) 
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->EndTime() || aQuery->EndTimeReference()) 
 4049:     return PR_FALSE;
 4049: 
 4049:   if (!aQuery->SearchTerms().IsEmpty()) 
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->OnlyBookmarked()) 
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->DomainIsHost() || !aQuery->Domain().IsEmpty())
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->AnnotationIsNot() || !aQuery->Annotation().IsEmpty()) 
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->UriIsPrefix() || aQuery->Uri()) 
 4049:     return PR_FALSE;
 4049: 
 4049:   if (aQuery->Folders().Length() > 0)
 4049:     return PR_FALSE;
 4049: 
27981:   if (aQuery->Tags().Length() > 0)
27981:     return PR_FALSE;
27981: 
 4049:   return PR_TRUE;
 4049: }
    1: 
 6483: static
 6483: PRBool NeedToFilterResultSet(const nsCOMArray<nsNavHistoryQuery>& aQueries, 
 6483:                              nsNavHistoryQueryOptions *aOptions)
 6483: {
26880:   // Never filter queries returning queries
26880:   PRUint16 resultType = aOptions->ResultType();
26880:   if (resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY ||
26880:       resultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY ||
26880:       resultType == nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY ||
26880:       resultType == nsINavHistoryQueryOptions::RESULTS_AS_SITE_QUERY)
26880:     return PR_FALSE;
26880: 
22327:   // Always filter bookmarks queries to avoid the inclusion of query nodes,
22327:   // but RESULTS AS TAG QUERY never needs to be filtered.
26880:   if (aOptions->QueryType() == nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS)
 6483:     return PR_TRUE;
 6483: 
 6822:   nsCString parentAnnotationToExclude;
 6822:   nsresult rv = aOptions->GetExcludeItemIfParentHasAnnotation(parentAnnotationToExclude);
 6822:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
 6822:   if (!parentAnnotationToExclude.IsEmpty())
 6822:     return PR_TRUE;
 6822: 
 6483:   PRInt32 i;
 6483:   for (i = 0; i < aQueries.Count(); i ++) {
 6483:     if (aQueries[i]->Folders().Length() != 0) {
 6483:       return PR_TRUE;
 6483:     } else {
 6483:       PRBool hasSearchTerms;
 6483:       nsresult rv = aQueries[i]->GetHasSearchTerms(&hasSearchTerms);
 6483:       if (NS_FAILED(rv) || hasSearchTerms)
 6483:         return PR_TRUE;
 6483:     }
 6483:   }
 6483:   return PR_FALSE;
 6483: }
 6483: 
12328: // ** Helper class for ConstructQueryString **/
12328: 
12328: class PlacesSQLQueryBuilder
12328: {
12328: public:
12328:   PlacesSQLQueryBuilder(const nsCString& aConditions,
12328:                         nsNavHistoryQueryOptions* aOptions,
13310:                         PRBool aUseLimit,
33458:                         nsNavHistory::StringHash& aAddParams,
33458:                         PRBool aHasSearchTerms);
12328: 
12328:   nsresult GetQueryString(nsCString& aQueryString);
12328: 
12328: private:
12328:   nsresult Select();
12328: 
12328:   nsresult SelectAsURI();
12328:   nsresult SelectAsVisit();
12328:   nsresult SelectAsDay();
12328:   nsresult SelectAsSite();
12328:   nsresult SelectAsTag();
12328: 
12328:   nsresult Where();
12328:   nsresult GroupBy();
12328:   nsresult OrderBy();
12328:   nsresult Limit();
12328: 
12328:   void OrderByColumnIndexAsc(PRInt32 aIndex);
12328:   void OrderByColumnIndexDesc(PRInt32 aIndex);
27616:   // Use these if you want a case insensitive sorting.
27616:   void OrderByTextColumnIndexAsc(PRInt32 aIndex);
27616:   void OrderByTextColumnIndexDesc(PRInt32 aIndex);
12328: 
12328:   const nsCString& mConditions;
12328:   PRBool mUseLimit;
33458:   PRBool mHasSearchTerms;
12328: 
12328:   PRUint16 mResultType;
12328:   PRUint16 mQueryType;
12328:   PRBool mIncludeHidden;
26258:   PRUint16 mRedirectsMode;
12328:   PRUint16 mSortingMode;
12328:   PRUint32 mMaxResults;
12328: 
12328:   nsCString mQueryString;
12328:   nsCString mGroupBy;
12386:   PRBool mHasDateColumns;
12328:   PRBool mSkipOrderBy;
13310:   nsNavHistory::StringHash& mAddParams;
12328: };
12328: 
12328: PlacesSQLQueryBuilder::PlacesSQLQueryBuilder(
12328:     const nsCString& aConditions, 
12328:     nsNavHistoryQueryOptions* aOptions, 
13310:     PRBool aUseLimit,
33458:     nsNavHistory::StringHash& aAddParams,
33458:     PRBool aHasSearchTerms) :
12328:   mConditions(aConditions),
14274:   mUseLimit(aUseLimit),
12328:   mResultType(aOptions->ResultType()),
12328:   mQueryType(aOptions->QueryType()),
12328:   mIncludeHidden(aOptions->IncludeHidden()),
26258:   mRedirectsMode(aOptions->RedirectsMode()),
12328:   mSortingMode(aOptions->SortingMode()),
12328:   mMaxResults(aOptions->MaxResults()),
13310:   mSkipOrderBy(PR_FALSE),
33458:   mAddParams(aAddParams),
33458:   mHasSearchTerms(aHasSearchTerms)
12328: {
12386:   mHasDateColumns = (mQueryType == nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS);
12328: }
12328: 
    1: nsresult
12328: PlacesSQLQueryBuilder::GetQueryString(nsCString& aQueryString)
12328: {
12328:   nsresult rv = Select();
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328:   rv = Where();
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328:   rv = GroupBy();
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328:   rv = OrderBy();
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328:   rv = Limit();
12328:   NS_ENSURE_SUCCESS(rv, rv);
12328: 
12328:   aQueryString = mQueryString;
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::Select()
12328: {
12328:   nsresult rv;
12328: 
12328:   switch (mResultType)
12328:   {
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_URI:
14224:     case nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS:
12328:       rv = SelectAsURI();
12328:       NS_ENSURE_SUCCESS(rv, rv);
12328:       break;
12328: 
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_VISIT:
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_FULL_VISIT:
12328:       rv = SelectAsVisit();
12328:       NS_ENSURE_SUCCESS(rv, rv);
12328:       break;
12328: 
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY:
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_DATE_SITE_QUERY:
12328:       rv = SelectAsDay();
12328:       NS_ENSURE_SUCCESS(rv, rv);
12328:       break;
12328: 
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_SITE_QUERY:
12328:       rv = SelectAsSite();
12328:       NS_ENSURE_SUCCESS(rv, rv);
12328:       break;
12328: 
12328:     case nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY:
12328:       rv = SelectAsTag();
12328:       NS_ENSURE_SUCCESS(rv, rv);
12328:       break;
12328: 
12328:     default:
12328:       NS_NOTREACHED("Invalid result type");
12328:   }
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::SelectAsURI()
12328: {
33458:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
33458:   nsCAutoString tagsSqlFragment;
33458: 
28350:   switch (mQueryType) {
12328:     case nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY:
33458:       GetTagsSqlFragment(history->GetTagsFolder(),
33458:                          NS_LITERAL_CSTRING("h.id"),
33458:                          mHasSearchTerms,
33458:                          tagsSqlFragment);
33458: 
12328:       mQueryString = NS_LITERAL_CSTRING(
28350:         "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:         "h.last_visit_date, f.url, v.session, null, null, null, null, ") +
33458:         tagsSqlFragment + NS_LITERAL_CSTRING(
28350:         "FROM moz_places_temp h "
28350:         "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
20868:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
28350:         // WHERE 1 is a no-op since additonal conditions will start with AND.
28350:         "WHERE 1 "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
26258:           "{ADDITIONAL_CONDITIONS} "
29272:         "GROUP BY h.id "
29272:         "UNION ALL "
28350:         "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:         "h.last_visit_date, f.url, v.session, null, null, null, null, ") +
33458:         tagsSqlFragment + NS_LITERAL_CSTRING(
20868:         "FROM moz_places_temp h "
20868:         "JOIN moz_historyvisits v ON h.id = v.place_id "
20868:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
29272:         "WHERE h.id NOT IN (SELECT place_id FROM moz_historyvisits_temp) "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
26258:           "{ADDITIONAL_CONDITIONS} "
29272:         "GROUP BY h.id "
29272:         "UNION ALL "
28350:         "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:         "h.last_visit_date, f.url, v.session, null, null, null, null, ") +
33458:         tagsSqlFragment + NS_LITERAL_CSTRING(
20868:         "FROM moz_places h "
20868:         "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
20868:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20868:         "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
29272:         "GROUP BY h.id "
29272:         "UNION ALL "
28350:         "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:         "h.last_visit_date, f.url, v.session, null, null, null, null, ") +
33458:         tagsSqlFragment + NS_LITERAL_CSTRING(
28350:         "FROM moz_places h "
28350:         "JOIN moz_historyvisits v ON h.id = v.place_id "
20868:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
28350:         "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
29272:           "AND h.id NOT IN (SELECT place_id FROM moz_historyvisits_temp) "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
28350:         "GROUP BY h.id ");
12328:       break;
12328: 
12328:     case nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS:
14224:       if (mResultType == nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS) {
14224:         // Order-by clause is hardcoded because we need to discard duplicates
14224:         // in FilterResultSet. We will retain only the last modified item,
14224:         // so we are ordering by place id and last modified to do a faster
14224:         // filtering.
14224:         mSkipOrderBy = PR_TRUE;
14224: 
33458:         GetTagsSqlFragment(history->GetTagsFolder(),
33458:                            NS_LITERAL_CSTRING("b2.fk"),
33458:                            mHasSearchTerms,
33458:                            tagsSqlFragment);
33458: 
14224:         mQueryString = NS_LITERAL_CSTRING(
14224:           "SELECT b2.fk, h.url, COALESCE(b2.title, h.title), h.rev_host, "
28350:             "h.visit_count, h.last_visit_date, f.url, null, b2.id, "
33458:             "b2.dateAdded, b2.lastModified, b2.parent, ") +
33458:             tagsSqlFragment + NS_LITERAL_CSTRING(
14224:           "FROM moz_bookmarks b2 "
29831:           "JOIN (SELECT b.fk "
29831:                 "FROM moz_bookmarks b "
29831:                 // ADDITIONAL_CONDITIONS will filter on parent.
29831:                 "WHERE b.type = 1 {ADDITIONAL_CONDITIONS} "
29831:                 ") AS seed ON b2.fk = seed.fk "
29831:           "JOIN moz_places_temp h ON h.id = b2.fk "
20868:           "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
29831:           "WHERE NOT EXISTS ( "
29831:             "SELECT id FROM moz_bookmarks WHERE id = b2.parent AND parent = ") +
20868:                 nsPrintfCString("%lld", history->GetTagsFolder()) +
20868:           NS_LITERAL_CSTRING(") "
20868:           "UNION ALL "
20868:           "SELECT b2.fk, h.url, COALESCE(b2.title, h.title), h.rev_host, "
28350:             "h.visit_count, h.last_visit_date, f.url, null, b2.id, "
33458:             "b2.dateAdded, b2.lastModified, b2.parent, ") +
33458:             tagsSqlFragment + NS_LITERAL_CSTRING(
20868:           "FROM moz_bookmarks b2 "
29831:           "JOIN (SELECT b.fk "
29831:                 "FROM moz_bookmarks b "
29831:                 // ADDITIONAL_CONDITIONS will filter on parent.
29831:                 "WHERE b.type = 1 {ADDITIONAL_CONDITIONS} "
29831:                 ") AS seed ON b2.fk = seed.fk "
29831:           "JOIN moz_places h ON h.id = b2.fk "
14224:           "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
29831:           "WHERE NOT EXISTS ( "
29831:             "SELECT id FROM moz_bookmarks WHERE id = b2.parent AND parent = ") +
14781:                 nsPrintfCString("%lld", history->GetTagsFolder()) +
20868:           NS_LITERAL_CSTRING(") "
29831:             "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
20868:           "ORDER BY b2.fk DESC, b2.lastModified DESC");
14224:       }
14224:       else {
33458:         GetTagsSqlFragment(history->GetTagsFolder(),
33458:                            NS_LITERAL_CSTRING("b.fk"),
33458:                            mHasSearchTerms,
33458:                            tagsSqlFragment);
12328:         mQueryString = NS_LITERAL_CSTRING(
12328:           "SELECT b.fk, h.url, COALESCE(b.title, h.title), h.rev_host, "
28350:             "h.visit_count, h.last_visit_date, f.url, null, b.id, "
33458:             "b.dateAdded, b.lastModified, b.parent, ") +
33458:             tagsSqlFragment + NS_LITERAL_CSTRING(
12328:           "FROM moz_bookmarks b "
20868:           "JOIN moz_places_temp h ON b.fk = h.id AND b.type = 1 "
20868:           "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
20868:           "WHERE NOT EXISTS "
20868:             "(SELECT id FROM moz_bookmarks "
20868:               "WHERE id = b.parent AND parent = ") +
20868:                 nsPrintfCString("%lld", history->GetTagsFolder()) +
20868:             NS_LITERAL_CSTRING(") "
20868:             "{ADDITIONAL_CONDITIONS}"
20868:           "UNION ALL "
20868:           "SELECT b.fk, h.url, COALESCE(b.title, h.title), h.rev_host, "
28350:             "h.visit_count, h.last_visit_date, f.url, null, b.id, "
33458:             "b.dateAdded, b.lastModified, b.parent, ") +
33458:             tagsSqlFragment + NS_LITERAL_CSTRING(
20868:           "FROM moz_bookmarks b "
20586:           "JOIN moz_places h ON b.fk = h.id AND b.type = 1 "
20569:           "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
20868:           "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
20868:             "AND NOT EXISTS "
20868:               "(SELECT id FROM moz_bookmarks "
20868:                 "WHERE id = b.parent AND parent = ") +
20569:                   nsPrintfCString("%lld", history->GetTagsFolder()) +
20868:               NS_LITERAL_CSTRING(") "
20868:             "{ADDITIONAL_CONDITIONS}");
14224:       }
12328:       break;
12328: 
12328:     default:
12328:       return NS_ERROR_NOT_IMPLEMENTED;
12328:   }
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::SelectAsVisit()
12328: {
33458:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
33458:   nsCAutoString tagsSqlFragment;
33458:   GetTagsSqlFragment(history->GetTagsFolder(),
33458:                      NS_LITERAL_CSTRING("h.id"),
33458:                      mHasSearchTerms,
33458:                      tagsSqlFragment);
12328:   mQueryString = NS_LITERAL_CSTRING(
12328:     "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:       "v.visit_date, f.url, v.session, null, null, null, null, ") +
33458:       tagsSqlFragment + NS_LITERAL_CSTRING(
28350:     "FROM moz_places_temp h "
28350:     "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
20868:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
28350:     // WHERE 1 is a no-op since additonal conditions will start with AND.
28350:     "WHERE 1 "
28350:       "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:       "{ADDITIONAL_CONDITIONS} "
20868:     "UNION ALL "
20868:     "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:       "v.visit_date, f.url, v.session, null, null, null, null, ") +
33458:       tagsSqlFragment + NS_LITERAL_CSTRING(
20868:     "FROM moz_places_temp h "
20868:     "JOIN moz_historyvisits v ON h.id = v.place_id "
20868:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
28350:     // WHERE 1 is a no-op since additonal conditions will start with AND.
28350:     "WHERE 1 "
28350:       "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
26258:       "{ADDITIONAL_CONDITIONS} "
20868:     "UNION ALL "
20868:     "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:       "v.visit_date, f.url, v.session, null, null, null, null, ") +
33458:       tagsSqlFragment + NS_LITERAL_CSTRING(
20868:     "FROM moz_places h "
20868:     "JOIN moz_historyvisits_temp v ON h.id = v.place_id "
20868:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
22310:     "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
28350:       "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
26258:       "{ADDITIONAL_CONDITIONS} "
20868:     "UNION ALL "
20868:     "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:       "v.visit_date, f.url, v.session, null, null, null, null, ") +
33458:       tagsSqlFragment + NS_LITERAL_CSTRING(
20868:     "FROM moz_places h "
20868:     "JOIN moz_historyvisits v ON h.id = v.place_id "
20868:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20868:     "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
28350:       "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
12328:       "{ADDITIONAL_CONDITIONS} ");
12328: 
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::SelectAsDay()
12328: {
12328:   mSkipOrderBy = PR_TRUE;
26467: 
27074:   // Sort child queries based on sorting mode if it's provided, otherwise
27074:   // fallback to default sort by title ascending.
27074:   PRUint16 sortingMode = nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING;
27074:   if (mSortingMode != nsINavHistoryQueryOptions::SORT_BY_NONE &&
27074:       mResultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY)
27074:     sortingMode = mSortingMode;
27074: 
26467:   PRUint16 resultType =
26467:     mResultType == nsINavHistoryQueryOptions::RESULTS_AS_DATE_QUERY ?
26467:                    nsINavHistoryQueryOptions::RESULTS_AS_URI :
26467:                    nsINavHistoryQueryOptions::RESULTS_AS_SITE_QUERY;
26467: 
26467:   // beginTime will become the node's time property, we don't use endTime
26467:   // because it could overlap, and we use time to sort containers and find
26467:   // insert position in a result.
26467:   mQueryString = nsPrintfCString(1024,
12328:      "SELECT null, "
12328:        "'place:type=%ld&sort=%ld&beginTime='||beginTime||'&endTime='||endTime, "
33458:       "dayTitle, null, null, beginTime, null, null, null, null, null, null "
12328:      "FROM (", // TOUTER BEGIN
26467:      resultType,
27074:      sortingMode);
12328:  
12328:    nsNavHistory *history = nsNavHistory::GetHistoryService();
12328:    NS_ENSURE_STATE(history);
12328: 
28514:   for (PRInt32 i = 0; i <= DATE_CONT_NUM(history->mExpireDaysMax); i++) {
12328:     nsCAutoString dateName;
26467:     // Timeframes are calculated as BeginTime <= container < EndTime.
26467:     // Notice times can't be relative to now, since to recognize a query we
26467:     // must ensure it won't change based on the time it is built.
26467:     // So, to select till now, we really select till start of tomorrow, that is
26467:     // a fixed timestamp.
27028:     // These are used as limits for the inside containers.
27028:     nsCAutoString sqlFragmentContainerBeginTime, sqlFragmentContainerEndTime;
27028:     // These are used to query if the container should be visible.
27028:     nsCAutoString sqlFragmentSearchBeginTime, sqlFragmentSearchEndTime;
26467:     switch(i) {
12328:        case 0:
26467:         // Today
12328:          history->GetStringFromName(
12328:           NS_LITERAL_STRING("finduri-AgeInDays-is-0").get(), dateName);
26467:         // From start of today
27028:         sqlFragmentContainerBeginTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','utc')*1000000)");
26467:         // To now (tomorrow)
27028:         sqlFragmentContainerEndTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','+1 day','utc')*1000000)");
27028:         // Search for the same timeframe.
27028:         sqlFragmentSearchBeginTime = sqlFragmentContainerBeginTime;
27028:         sqlFragmentSearchEndTime = sqlFragmentContainerEndTime;
12328:          break;
12328:        case 1:
26467:         // Yesterday
12328:          history->GetStringFromName(
12328:           NS_LITERAL_STRING("finduri-AgeInDays-is-1").get(), dateName);
26467:         // From start of yesterday
27028:         sqlFragmentContainerBeginTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','-1 day','utc')*1000000)");
26467:         // To start of today
27028:         sqlFragmentContainerEndTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','utc')*1000000)");
27028:         // Search for the same timeframe.
27028:         sqlFragmentSearchBeginTime = sqlFragmentContainerBeginTime;
27028:         sqlFragmentSearchEndTime = sqlFragmentContainerEndTime;
26467:         break;
26467:       case 2:
26467:         // Last 7 days
26467:         history->GetAgeInDaysString(7,
26467:           NS_LITERAL_STRING("finduri-AgeInDays-last-is").get(), dateName);
26467:         // From start of 7 days ago
27028:         sqlFragmentContainerBeginTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','-7 days','utc')*1000000)");
26467:         // To now (tomorrow)
27028:         sqlFragmentContainerEndTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','+1 day','utc')*1000000)");
27028:         // This is an overlapped container, but we show it only if there are
27028:         // visits older than yesterday.
27028:         sqlFragmentSearchBeginTime = sqlFragmentContainerBeginTime;
27028:         sqlFragmentSearchEndTime = NS_LITERAL_CSTRING(
27028:           "(strftime('%s','now','localtime','start of day','-2 days','utc')*1000000)");
26467:         break;
26467:       case 3:
26467:         // This month
26467:         history->GetStringFromName(
26467:           NS_LITERAL_STRING("finduri-AgeInMonths-is-0").get(), dateName);
26467:         // From start of this month
27028:         sqlFragmentContainerBeginTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of month','utc')*1000000)");
26467:         // To now (tomorrow)
27028:         sqlFragmentContainerEndTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of day','+1 day','utc')*1000000)");
27028:         // This is an overlapped container, but we show it only if there are
27028:         // visits older than 7 days ago.
27028:         sqlFragmentSearchBeginTime = sqlFragmentContainerBeginTime;
27028:         sqlFragmentSearchEndTime = NS_LITERAL_CSTRING(
27028:           "(strftime('%s','now','localtime','start of day','-7 days','utc')*1000000)");
12328:          break;
12328:        default:
28514:         if (i == ADDITIONAL_DATE_CONT_NUM + 6) {
26467:           // Older than 6 months
26467:           history->GetAgeInDaysString(6,
26467:             NS_LITERAL_STRING("finduri-AgeInMonths-isgreater").get(), dateName);
26467:           // From start of epoch
27028:           sqlFragmentContainerBeginTime = NS_LITERAL_CSTRING(
26467:             "(datetime(0, 'unixepoch')*1000000)");
30864:           // To start of 6 months ago ( 5 months + this month).
27028:           sqlFragmentContainerEndTime = NS_LITERAL_CSTRING(
30864:             "(strftime('%s','now','localtime','start of month','-5 months','utc')*1000000)");
27028:           // Search for the same timeframe.
27028:           sqlFragmentSearchBeginTime = sqlFragmentContainerBeginTime;
27028:           sqlFragmentSearchEndTime = sqlFragmentContainerEndTime;
12328:           break;
12328:         }
28514:         PRInt32 MonthIndex = i - ADDITIONAL_DATE_CONT_NUM;
26467:         // Previous months' titles are month's name if inside this year,
26467:         // month's name and year for previous years.
26467:         PRExplodedTime tm;
26467:         PR_ExplodeTime(PR_Now(), PR_LocalTimeParameters, &tm);
26467:         PRUint16 currentYear = tm.tm_year;
30864:         // Set day before month, setting month without day could cause issues.
30864:         // For example setting month to February when today is 30, since
30864:         // February has not 30 days, will return March instead.
30864:         tm.tm_mday = 1;
26467:         tm.tm_month -= MonthIndex;
26467:         PR_NormalizeTime(&tm, PR_LocalTimeParameters);
26467:         // tm_month starts from 0 while GetMonthName expects a 1-based index.
26467:         history->GetMonthName(tm.tm_month+1, dateName);
26467: 
26467:         // If the container is for a past year, add the year as suffix.
26467:         if (tm.tm_year < currentYear)
26467:           dateName.Append(nsPrintfCString(" %d", tm.tm_year));
26467: 
26467:         // From start of MonthIndex + 1 months ago
27028:         sqlFragmentContainerBeginTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of month','-");
27028:         sqlFragmentContainerBeginTime.AppendInt(MonthIndex);
27028:         sqlFragmentContainerBeginTime.Append(NS_LITERAL_CSTRING(
26467:             " months','utc')*1000000)"));
26467:         // To start of MonthIndex months ago
27028:         sqlFragmentContainerEndTime = NS_LITERAL_CSTRING(
26467:           "(strftime('%s','now','localtime','start of month','-");
27028:         sqlFragmentContainerEndTime.AppendInt(MonthIndex - 1);
27028:         sqlFragmentContainerEndTime.Append(NS_LITERAL_CSTRING(
26467:             " months','utc')*1000000)"));
27028:         // Search for the same timeframe.
27028:         sqlFragmentSearchBeginTime = sqlFragmentContainerBeginTime;
27028:         sqlFragmentSearchEndTime = sqlFragmentContainerEndTime;
26467:         break;
26467:     }
12328: 
28514:     nsPrintfCString dateParam("dayTitle%d", i);
28514:     mAddParams.Put(dateParam, dateName);
28514: 
12328:      nsPrintfCString dayRange(1024,
28514:         "SELECT :%s AS dayTitle, "
26467:                "%s AS beginTime, "
26467:                "%s AS endTime "
20868:          "WHERE EXISTS ( "
20868:            "SELECT id FROM moz_historyvisits_temp "
26467:           "WHERE visit_date >= %s "
26467:             "AND visit_date < %s "
26467:             "AND visit_type NOT IN (0,%d) "
28350:             "{QUERY_OPTIONS_VISITS} "
26467:           "UNION ALL "
26467:           "SELECT id FROM moz_historyvisits "
26467:           "WHERE visit_date >= %s "
26467:             "AND visit_date < %s "
22310:              "AND visit_type NOT IN (0,%d) "
28350:              "{QUERY_OPTIONS_VISITS} "
20868:            "LIMIT 1 "
26467:         ") ",
28514:       dateParam.get(),
27028:       sqlFragmentContainerBeginTime.get(),
27028:       sqlFragmentContainerEndTime.get(),
27028:       sqlFragmentSearchBeginTime.get(),
27028:       sqlFragmentSearchEndTime.get(),
22310:        nsINavHistoryService::TRANSITION_EMBED,
27028:       sqlFragmentSearchBeginTime.get(),
27028:       sqlFragmentSearchEndTime.get(),
26467:       nsINavHistoryService::TRANSITION_EMBED);
12328: 
12328:     mQueryString.Append(dayRange);
26467: 
28514:     if (i < DATE_CONT_NUM(history->mExpireDaysMax))
26467:         mQueryString.Append(NS_LITERAL_CSTRING(" UNION ALL "));
26467:   }
26467: 
26467:   mQueryString.Append(NS_LITERAL_CSTRING(") ")); // TOUTER END
12328: 
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::SelectAsSite()
12328: {
12328:   nsCAutoString localFiles;
12328: 
12328:   nsNavHistory *history = nsNavHistory::GetHistoryService();
12328:   NS_ENSURE_STATE(history);
12328: 
12328:   history->GetStringFromName(NS_LITERAL_STRING("localhost").get(), localFiles);
28260:   mAddParams.Put(NS_LITERAL_CSTRING("localhost"), localFiles);
12328: 
14997:   // We want just sites, but from whole database.
12328:   if (mConditions.IsEmpty()) {
12328:     mQueryString = nsPrintfCString(2048,
12328:       "SELECT DISTINCT null, "
12328:              "'place:type=%ld&sort=%ld&domain=&domainIsHost=true', "
33458:              ":localhost, :localhost, null, null, null, null, null, null, null "
20868:       "WHERE EXISTS ( "
20868:         "SELECT id FROM moz_places_temp "
20868:         "WHERE hidden <> 1 "
20868:           "AND rev_host = '.' "
14997:           "AND visit_count > 0 "
20868:           "AND url BETWEEN 'file://' AND 'file:/~' "
20868:         "UNION ALL "
20868:         "SELECT id FROM moz_places "
20868:         "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
20868:           "AND hidden <> 1 "
20868:           "AND rev_host = '.' "
20868:           "AND visit_count > 0 "
20868:           "AND url BETWEEN 'file://' AND 'file:/~' "
20868:       ") "
12328:       "UNION ALL "
12328:       "SELECT DISTINCT null, "
12328:              "'place:type=%ld&sort=%ld&domain='||host||'&domainIsHost=true', "
33458:              "host, host, null, null, null, null, null, null, null "
20868:       "FROM ( "
20868:         "SELECT get_unreversed_host(rev_host) host "
20868:         "FROM ( "
20868:           "SELECT DISTINCT rev_host FROM moz_places_temp "
20868:           "WHERE hidden <> 1 "
20868:             "AND rev_host <> '.' "
20868:             "AND visit_count > 0 "
20868:           "UNION ALL "
20868:           "SELECT DISTINCT rev_host FROM moz_places "
20868:           "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
20868:             "AND hidden <> 1 "
20868:             "AND rev_host <> '.' "
20868:             "AND visit_count > 0 "
20868:         ") "
20868:       "ORDER BY 1 ASC) ",
12328:       nsINavHistoryQueryOptions::RESULTS_AS_URI,
27616:       mSortingMode,
12328:       nsINavHistoryQueryOptions::RESULTS_AS_URI,
27616:       mSortingMode);
12328:   // Now we need to use the filters - we need them all
12328:   } else {
12328: 
12328:     mQueryString = nsPrintfCString(4096,
12328:       "SELECT DISTINCT null, "
12328:              "'place:type=%ld&sort=%ld&domain=&domainIsHost=true"
13310:                "&beginTime='||:begin_time||'&endTime='||:end_time, "
33458:              ":localhost, :localhost, null, null, null, null, null, null, null "
20868:       "WHERE EXISTS( "
20868:         "SELECT h.id "
12328:         "FROM moz_places h "
20868:         "JOIN moz_historyvisits v ON v.place_id = h.id "
12328:         "WHERE h.hidden <> 1 AND h.rev_host = '.' "
14997:           "AND h.visit_count > 0 "
12738:           "AND h.url BETWEEN 'file://' AND 'file:/~' "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
20868:         "UNION "
20868:         "SELECT h.id "
20868:         "FROM moz_places_temp h "
20868:         "JOIN moz_historyvisits v ON v.place_id = h.id "
20868:         "WHERE h.hidden <> 1 AND h.rev_host = '.' "
20868:           "AND h.visit_count > 0 "
20868:           "AND h.url BETWEEN 'file://' AND 'file:/~' "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
20868:         "UNION "
20868:         "SELECT h.id "
20868:         "FROM moz_places h "
20868:         "JOIN moz_historyvisits_temp v ON v.place_id = h.id "
20868:         "WHERE h.hidden <> 1 AND h.rev_host = '.' "
20868:           "AND h.visit_count > 0 "
20868:           "AND h.url BETWEEN 'file://' AND 'file:/~' "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
20868:         "UNION "
20868:         "SELECT h.id "
20868:         "FROM moz_places_temp h "
20868:         "JOIN moz_historyvisits_temp v ON v.place_id = h.id "
20868:         "WHERE h.hidden <> 1 AND h.rev_host = '.' "
20868:           "AND h.visit_count > 0 "
20868:           "AND h.url BETWEEN 'file://' AND 'file:/~' "
28350:           "{QUERY_OPTIONS_VISITS}  {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "        
20868:       ") "
12328:       "UNION ALL "
12328:       "SELECT DISTINCT null, "
12328:              "'place:type=%ld&sort=%ld&domain='||host||'&domainIsHost=true"
13310:                "&beginTime='||:begin_time||'&endTime='||:end_time, "
33458:              "host, host, null, null, null, null, null, null, null "
20868:       "FROM ( "
20868:         "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
12328:         "FROM moz_places h "
20868:         "JOIN moz_historyvisits v ON v.place_id = h.id "
28350:         "WHERE h.rev_host <> '.' "
14997:           "AND h.visit_count > 0 "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
20868:         "UNION "
20868:         "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
20868:         "FROM moz_places_temp h "
20868:         "JOIN moz_historyvisits v ON v.place_id = h.id "
28350:         "WHERE h.rev_host <> '.' "
20868:           "AND h.visit_count > 0 "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
20868:         "UNION "
20868:         "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
20868:         "FROM moz_places h "
20868:         "JOIN moz_historyvisits_temp v ON v.place_id = h.id "
28350:         "WHERE h.rev_host <> '.' "
20868:           "AND h.visit_count > 0 "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "
20868:         "UNION "
20868:         "SELECT DISTINCT get_unreversed_host(rev_host) AS host "
20868:         "FROM moz_places_temp h "
20868:         "JOIN moz_historyvisits_temp v ON v.place_id = h.id "        
28350:         "WHERE h.rev_host <> '.' "
20868:           "AND h.visit_count > 0 "
28350:           "{QUERY_OPTIONS_VISITS} {QUERY_OPTIONS_PLACES} "
20868:           "{ADDITIONAL_CONDITIONS} "        
20868:         "ORDER BY 1 ASC "
20868:       ") ",
12328:       nsINavHistoryQueryOptions::RESULTS_AS_URI,
27616:       mSortingMode,
12328:       nsINavHistoryQueryOptions::RESULTS_AS_URI,
27616:       mSortingMode);
12328:   }
12328: 
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::SelectAsTag()
12328: {
12328:   nsNavHistory *history = nsNavHistory::GetHistoryService();
12328:   NS_ENSURE_STATE(history);
12328: 
12386:   // This allows sorting by date fields what is not possible with
12386:   // other history queries.
12386:   mHasDateColumns = PR_TRUE; 
12386: 
12328:   mQueryString = nsPrintfCString(2048,
14224:     "SELECT null, 'place:folder=' || id || '&queryType=%d&type=%ld', "
33458:       "title, null, null, null, null, null, null, dateAdded, lastModified, "
33458:       "null, null "
12328:     "FROM   moz_bookmarks "
14344:     "WHERE  parent = %lld",
12328:     nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS,
14224:     nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS,
12328:     history->GetTagsFolder());
12328: 
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::Where()
12328: {
26258: 
26258:   // Set query options
28350:   nsCAutoString additionalVisitsConditions;
28350:   nsCAutoString additionalPlacesConditions;
28350: 
26258:   if (mRedirectsMode == nsINavHistoryQueryOptions::REDIRECTS_MODE_SOURCE) {
28350:     additionalVisitsConditions += NS_LITERAL_CSTRING(
28350:       "AND visit_type NOT IN ") +
28350:       nsPrintfCString("(%d,%d) ", nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
28350:                                   nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY);
26258:   }
26258:   else if (mRedirectsMode == nsINavHistoryQueryOptions::REDIRECTS_MODE_TARGET) {
28350:     additionalVisitsConditions += NS_LITERAL_CSTRING(
26258:       "AND NOT EXISTS ( "
26258:         "SELECT id FROM moz_historyvisits_temp WHERE from_visit = v.id "
28350:         "AND visit_type IN ") +
28350:         nsPrintfCString("(%d,%d) ", nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
28350:                                     nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
28350:       NS_LITERAL_CSTRING(") AND NOT EXISTS ( "
26258:         "SELECT id FROM moz_historyvisits WHERE from_visit = v.id "
28350:         "AND visit_type IN ") +
28350:         nsPrintfCString("(%d,%d) ", nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
28350:                                     nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
28350:       NS_LITERAL_CSTRING(") ");
28350:   }
28350: 
28350:   if (!mIncludeHidden) {
28350:     additionalVisitsConditions += NS_LITERAL_CSTRING(
28350:       "AND visit_type NOT IN ") +
28350:       nsPrintfCString("(0,%d) ", nsINavHistoryService::TRANSITION_EMBED);
28350:     additionalPlacesConditions += NS_LITERAL_CSTRING(
28350:       "AND hidden <> 1 ");
28350:   }
28350: 
28350:   mQueryString.ReplaceSubstring("{QUERY_OPTIONS_VISITS}",
28350:                                 additionalVisitsConditions.get());
28350:   mQueryString.ReplaceSubstring("{QUERY_OPTIONS_PLACES}",
28350:                                 additionalPlacesConditions.get());
26258: 
12328:   // If we used WHERE already, we inject the conditions 
12328:   // in place of {ADDITIONAL_CONDITIONS}
14274:   PRInt32 useInnerCondition;
12328:   useInnerCondition = mQueryString.Find("{ADDITIONAL_CONDITIONS}", 0);
12328:   if (useInnerCondition != kNotFound) {
12328: 
12328:     nsCAutoString innerCondition;
12328:     // If we have condition AND it
12328:     if (!mConditions.IsEmpty()) {
13310:       innerCondition = " AND (";
12328:       innerCondition += mConditions;
13310:       innerCondition += ")";
12328:     }
12328:     mQueryString.ReplaceSubstring("{ADDITIONAL_CONDITIONS}",
12328:                                   innerCondition.get());
12328: 
12328:   } else if (!mConditions.IsEmpty()) {
12328: 
12328:     mQueryString += "WHERE ";
12328:     mQueryString += mConditions;
12328: 
12328:   }
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::GroupBy()
12328: {
12328:   mQueryString += mGroupBy;
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: PlacesSQLQueryBuilder::OrderBy()
12328: {
12328:   if (mSkipOrderBy)
12328:     return NS_OK;
12328: 
12328:   // Sort clause: we will sort later, but if it comes out of the DB sorted,
12328:   // our later sort will be basically free. The DB can sort these for free
12328:   // most of the time anyway, because it has indices over these items.
12328:   switch(mSortingMode)
12328:   {
12328:     case nsINavHistoryQueryOptions::SORT_BY_NONE:
30050:       // If this is an URI query the sorting could change based on the
28670:       // sync status of disk and temp tables, we must ensure sorting does not
28670:       // change between queries.
30050:       if (mResultType == nsINavHistoryQueryOptions::RESULTS_AS_URI) {
30050:         if (mQueryType == nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS)
28670:           mQueryString += NS_LITERAL_CSTRING(" ORDER BY b.id ASC ");
30050:         else if (mQueryType == nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY)
30050:           mQueryString += NS_LITERAL_CSTRING(" ORDER BY h.id ASC ");
30050:       }
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING:
12328:     case nsINavHistoryQueryOptions::SORT_BY_TITLE_DESCENDING:
12328:       // If the user wants few results, we limit them by date, necessitating
27616:       // a sort by date here (see the IDL definition for maxResults).
27616:       // Otherwise we will do actual sorting by title, but since we could need
27616:       // to special sort for some locale we will repeat a second sorting at the
27616:       // end in nsNavHistoryResult, that should be faster since the list will be
27616:       // almost ordered.
12328:       if (mMaxResults > 0)
12328:         OrderByColumnIndexDesc(nsNavHistory::kGetInfoIndex_VisitDate);
27616:       else if (mSortingMode == nsINavHistoryQueryOptions::SORT_BY_TITLE_ASCENDING)
27616:         OrderByTextColumnIndexAsc(nsNavHistory::kGetInfoIndex_Title);
27616:       else
27616:         OrderByTextColumnIndexDesc(nsNavHistory::kGetInfoIndex_Title);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_DATE_ASCENDING:
12328:       OrderByColumnIndexAsc(nsNavHistory::kGetInfoIndex_VisitDate);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING:
12328:       OrderByColumnIndexDesc(nsNavHistory::kGetInfoIndex_VisitDate);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_URI_ASCENDING:
12328:       OrderByColumnIndexAsc(nsNavHistory::kGetInfoIndex_URL);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_URI_DESCENDING:
12328:       OrderByColumnIndexDesc(nsNavHistory::kGetInfoIndex_URL);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_ASCENDING:
12328:       OrderByColumnIndexAsc(nsNavHistory::kGetInfoIndex_VisitCount);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_DESCENDING:
12328:       OrderByColumnIndexDesc(nsNavHistory::kGetInfoIndex_VisitCount);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_DATEADDED_ASCENDING:
12386:       if (mHasDateColumns)
12328:         OrderByColumnIndexAsc(nsNavHistory::kGetInfoIndex_ItemDateAdded);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_DATEADDED_DESCENDING:
12386:       if (mHasDateColumns)
12328:         OrderByColumnIndexDesc(nsNavHistory::kGetInfoIndex_ItemDateAdded);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_LASTMODIFIED_ASCENDING:
12386:       if (mHasDateColumns)
12328:         OrderByColumnIndexAsc(nsNavHistory::kGetInfoIndex_ItemLastModified);
12328:       break;
12328:     case nsINavHistoryQueryOptions::SORT_BY_LASTMODIFIED_DESCENDING:
12386:       if (mHasDateColumns)
12328:         OrderByColumnIndexDesc(nsNavHistory::kGetInfoIndex_ItemLastModified);
12328:       break;
14053:     case nsINavHistoryQueryOptions::SORT_BY_TAGS_ASCENDING:
14053:     case nsINavHistoryQueryOptions::SORT_BY_TAGS_DESCENDING:
14053:     case nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_ASCENDING:
14053:     case nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_DESCENDING:
14053:       break; // Sort later in nsNavHistoryQueryResultNode::FillChildren()
12328:     default:
12328:       NS_NOTREACHED("Invalid sorting mode");
12328:   }
12328:   return NS_OK;
12328: }
12328: 
12328: void PlacesSQLQueryBuilder::OrderByColumnIndexAsc(PRInt32 aIndex)
12328: {
12328:   mQueryString += nsPrintfCString(128, " ORDER BY %d ASC", aIndex+1);
12328: }
12328: 
12328: void PlacesSQLQueryBuilder::OrderByColumnIndexDesc(PRInt32 aIndex)
12328: {
12328:   mQueryString += nsPrintfCString(128, " ORDER BY %d DESC", aIndex+1);
12328: }
12328: 
27616: void PlacesSQLQueryBuilder::OrderByTextColumnIndexAsc(PRInt32 aIndex)
27616: {
27616:   mQueryString += nsPrintfCString(128, " ORDER BY %d COLLATE NOCASE ASC",
27616:                                   aIndex+1);
27616: }
27616: 
27616: void PlacesSQLQueryBuilder::OrderByTextColumnIndexDesc(PRInt32 aIndex)
27616: {
27616:   mQueryString += nsPrintfCString(128, " ORDER BY %d COLLATE NOCASE DESC",
27616:                                   aIndex+1);
27616: }
27616: 
12328: nsresult
12328: PlacesSQLQueryBuilder::Limit()
12328: {
12328:   if (mUseLimit && mMaxResults > 0) {
12328:     mQueryString += NS_LITERAL_CSTRING(" LIMIT ");
12328:     mQueryString.AppendInt(mMaxResults);
12328:     mQueryString.AppendLiteral(" ");
12328:   }
12328:   return NS_OK;
12328: }
12328: 
12328: nsresult
12328: nsNavHistory::ConstructQueryString(
12328:     const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:     nsNavHistoryQueryOptions* aOptions, 
13310:     nsCString& queryString, 
13310:     PRBool& aParamsPresent,
13310:     nsNavHistory::StringHash& aAddParams)
    1: {
27459:   // For information about visit_type see nsINavHistoryService.idl.
27459:   // visitType == 0 is undefined (see bug #375777 for details).
12328:   // Some sites, especially Javascript-heavy ones, load things in frames to 
12328:   // display them, resulting in a lot of these entries. This is the reason 
12328:   // why such visits are filtered out.
27459:   nsresult rv;
12328:   aParamsPresent = PR_FALSE;
12328: 
    1:   PRInt32 sortingMode = aOptions->SortingMode();
27459:   NS_ASSERTION(sortingMode >= nsINavHistoryQueryOptions::SORT_BY_NONE &&
27459:                sortingMode <= nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_DESCENDING,
27459:                "Invalid sortingMode found while building query!");
27459: 
33458:   PRBool hasSearchTerms = PR_FALSE;
33458:   for (PRInt32 i = 0; i < aQueries.Count() && !hasSearchTerms; i++) {
33458:     aQueries[i]->GetHasSearchTerms(&hasSearchTerms);
33458:   }
33458: 
33458:   nsCAutoString tagsSqlFragment;
33458:   GetTagsSqlFragment(GetTagsFolder(),
33458:                      NS_LITERAL_CSTRING("h.id"),
33458:                      hasSearchTerms,
33458:                      tagsSqlFragment);
33458: 
27459:   if (IsOptimizableHistoryQuery(aQueries, aOptions,
27459:         nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING) ||
27459:       IsOptimizableHistoryQuery(aQueries, aOptions,
27459:         nsINavHistoryQueryOptions::SORT_BY_VISITCOUNT_DESCENDING)) {
27459:     // Generate an optimized query for the history menu and most visited
27459:     // smart bookmark.
 4049:     queryString = NS_LITERAL_CSTRING(
28350:       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, h.last_visit_date, "
33458:           "f.url, null, null, null, null, null, ") +
33458:           tagsSqlFragment + NS_LITERAL_CSTRING(
20868:         "FROM moz_places_temp h "
20868:         "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
27459:         "WHERE h.hidden <> 1 "
28350:           "AND EXISTS (SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id "
28350:                        "AND visit_type NOT IN ") +
28350:                        nsPrintfCString("(0,%d) ",
28350:                                        nsINavHistoryService::TRANSITION_EMBED) +
28350:                        NS_LITERAL_CSTRING("UNION ALL "
28350:                        "SELECT id FROM moz_historyvisits WHERE place_id = h.id "
28350:                        "AND visit_type NOT IN ") +
28350:                        nsPrintfCString("(0,%d) ",
28350:                                        nsINavHistoryService::TRANSITION_EMBED) +
28350:                        NS_LITERAL_CSTRING("LIMIT 1) "
27459:           "{QUERY_OPTIONS} "
23426:       "UNION ALL "
28350:       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, h.last_visit_date, "
33458:           "f.url, null, null, null, null, null, ") +
33458:           tagsSqlFragment + NS_LITERAL_CSTRING(
 4049:         "FROM moz_places h "
 9855:         "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
27459:         "WHERE h.hidden <> 1 "
23426:           "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
28350:           "AND EXISTS (SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id "
28350:                        "AND visit_type NOT IN ") +
28350:                        nsPrintfCString("(0,%d) ",
28350:                                        nsINavHistoryService::TRANSITION_EMBED) +
28350:                        NS_LITERAL_CSTRING("UNION ALL "
28350:                        "SELECT id FROM moz_historyvisits WHERE place_id = h.id "
28350:                        "AND visit_type NOT IN ") +
28350:                        nsPrintfCString("(0,%d) ",
28350:                                        nsINavHistoryService::TRANSITION_EMBED) +
28350:                        NS_LITERAL_CSTRING("LIMIT 1) "
27459:           "{QUERY_OPTIONS} "
27459:         );
27459: 
27459:     queryString.Append(NS_LITERAL_CSTRING("ORDER BY "));
27459:     if (sortingMode == nsINavHistoryQueryOptions::SORT_BY_DATE_DESCENDING)
27459:       queryString.Append(NS_LITERAL_CSTRING("last_visit_date DESC "));
27459:     else
27459:       queryString.Append(NS_LITERAL_CSTRING("visit_count DESC "));
27459: 
27459:     queryString.Append(NS_LITERAL_CSTRING("LIMIT "));
 4049:     queryString.AppendInt(aOptions->MaxResults());
26258: 
26258:     nsCAutoString additionalQueryOptions;
26258:     if (aOptions->RedirectsMode() ==
26258:           nsINavHistoryQueryOptions::REDIRECTS_MODE_SOURCE) {
27459:       additionalQueryOptions +=  nsPrintfCString(256,
27459:         "AND NOT EXISTS ( "
27459:           "SELECT id FROM moz_historyvisits_temp WHERE place_id = h.id "
27459:                                              "AND visit_type IN (%d,%d)"
27459:         ") "
27459:         "AND NOT EXISTS ( "
27459:           "SELECT id FROM moz_historyvisits WHERE place_id = h.id "
27459:                                              "AND visit_type IN (%d,%d)"
27459:         ") ",
27459:         TRANSITION_REDIRECT_PERMANENT,
27459:         TRANSITION_REDIRECT_TEMPORARY,
27459:         TRANSITION_REDIRECT_PERMANENT,
27459:         TRANSITION_REDIRECT_TEMPORARY);
26258:     }
26258:     else if (aOptions->RedirectsMode() ==
26258:               nsINavHistoryQueryOptions::REDIRECTS_MODE_TARGET) {
27459:       additionalQueryOptions += nsPrintfCString(1024,
26258:         "AND NOT EXISTS ( "
27459:           "SELECT id "
27459:           "FROM moz_historyvisits_temp v "
27459:           "WHERE place_id = h.id "
27459:             "AND EXISTS(SELECT id FROM moz_historyvisits_temp "
27459:                            "WHERE from_visit = v.id AND visit_type IN (%d,%d) "
27459:                         "UNION ALL "
27459:                         "SELECT id FROM moz_historyvisits "
27459:                            "WHERE from_visit = v.id AND visit_type IN (%d,%d)) "
27459:           "UNION ALL "
27459:           "SELECT id "
27459:           "FROM moz_historyvisits v "
27459:           "WHERE place_id = h.id "
27459:             "AND EXISTS(SELECT id FROM moz_historyvisits_temp "
27459:                            "WHERE from_visit = v.id AND visit_type IN (%d,%d) "
27459:                         "UNION ALL "
27459:                         "SELECT id FROM moz_historyvisits "
27459:                            "WHERE from_visit = v.id AND visit_type IN (%d,%d)) "
27459:         ") ",
27459:         TRANSITION_REDIRECT_PERMANENT,
27459:         TRANSITION_REDIRECT_TEMPORARY,
27459:         TRANSITION_REDIRECT_PERMANENT,
28669:         TRANSITION_REDIRECT_TEMPORARY,
28669:         TRANSITION_REDIRECT_PERMANENT,
28669:         TRANSITION_REDIRECT_TEMPORARY,
28669:         TRANSITION_REDIRECT_PERMANENT,
27459:         TRANSITION_REDIRECT_TEMPORARY);
26258:     }
26258:     queryString.ReplaceSubstring("{QUERY_OPTIONS}",
26258:                                   additionalQueryOptions.get());
 4049:     return NS_OK;
 4049:   }
 4049: 
12328:   nsCAutoString conditions;
27459:   for (PRInt32 i = 0; i < aQueries.Count(); i++) {
    1:     nsCString queryClause;
13310:     rv = QueryToSelectClause(aQueries[i], aOptions, i, &queryClause);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (! queryClause.IsEmpty()) {
12328:       aParamsPresent = PR_TRUE;
    1:       if (! conditions.IsEmpty()) // exists previous clause: multiple ones are ORed
    1:         conditions += NS_LITERAL_CSTRING(" OR ");
    1:       conditions += NS_LITERAL_CSTRING("(") + queryClause +
    1:         NS_LITERAL_CSTRING(")");
    1:     }
    1:   }
    1: 
12328:   // Determine whether we can push maxResults constraints into the queries
12328:   // as LIMIT, or if we need to do result count clamping later
 6483:   // using FilterResultSet()
12328:   PRBool useLimitClause = !NeedToFilterResultSet(aQueries, aOptions);
12328: 
12328:   PlacesSQLQueryBuilder queryStringBuilder(conditions, aOptions,
33458:                                            useLimitClause, aAddParams,
33458:                                            hasSearchTerms);
12328:   rv = queryStringBuilder.GetQueryString(queryString);
12328:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4049:   return NS_OK;
 4049: }
 4049: 
13310: PLDHashOperator BindAdditionalParameter(nsNavHistory::StringHash::KeyType aParamName, 
13310:                                         nsCString aParamValue,
13310:                                         void* aStatement)
13310: {
13310:   mozIStorageStatement* stmt = static_cast<mozIStorageStatement*>(aStatement);
13310: 
13310:   PRUint32 index;
13310:   nsresult rv = stmt->GetParameterIndex(aParamName, &index);
13310: 
13310:   if (NS_FAILED(rv))
13310:     return PL_DHASH_STOP;
13310: 
13310:   rv = stmt->BindUTF8StringParameter(index, aParamValue);
13310:   if (NS_FAILED(rv))
13310:     return PL_DHASH_STOP;
13310: 
13310:   return PL_DHASH_NEXT;
13310: }
13310: 
 4049: // nsNavHistory::GetQueryResults
 4049: //
 4049: //    Call this to get the results from a complex query. This is used by
 4049: //    nsNavHistoryQueryResultNode to populate its children. For simple bookmark
 4049: //    queries, use nsNavBookmarks::QueryFolderChildren.
 4049: //
 4049: //    THIS DOES NOT DO SORTING. You will need to sort the container yourself
 4049: //    when you get the results. This is because sorting depends on tree
 4049: //    statistics that will be built from the perspective of the tree. See
 4049: //    nsNavHistoryQueryResultNode::FillChildren
 4049: //
 4049: //    FIXME: This only does keyword searching for the first query, and does
 4049: //    it ANDed with the all the rest of the queries.
 4049: 
 4049: nsresult
 4049: nsNavHistory::GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,
 4049:                               const nsCOMArray<nsNavHistoryQuery>& aQueries,
 4049:                               nsNavHistoryQueryOptions *aOptions,
 4049:                               nsCOMArray<nsNavHistoryResultNode>* aResults)
 4049: {
 4049:   NS_ENSURE_ARG_POINTER(aOptions);
 4049:   NS_ASSERTION(aResults->Count() == 0, "Initial result array must be empty");
 4049:   if (! aQueries.Count())
 4049:     return NS_ERROR_INVALID_ARG;
 4049: 
 4049:   nsCString queryString;
12328:   PRBool paramsPresent = PR_FALSE;
13310:   nsNavHistory::StringHash addParams;
28514:   addParams.Init(DATE_CONT_NUM(mExpireDaysMax));
12328:   nsresult rv = ConstructQueryString(aQueries, aOptions, queryString, 
13310:                                      paramsPresent, addParams);
 4049:   NS_ENSURE_SUCCESS(rv,rv);
 4049: 
    1:   // create statement
    1:   nsCOMPtr<mozIStorageStatement> statement;
    1:   rv = mDBConn->CreateStatement(queryString, getter_AddRefs(statement));
27616: #ifdef DEBUG
27616:   if (NS_FAILED(rv)) {
27616:     nsCAutoString lastErrorString;
27616:     (void)mDBConn->GetLastErrorString(lastErrorString);
27616:     PRInt32 lastError = 0;
27616:     (void)mDBConn->GetLastError(&lastError);
28350:     printf("Places failed to create a statement from this query:\n%s\nStorage error (%d): %s\n",
27616:            PromiseFlatCString(queryString).get(),
27616:            lastError,
27616:            PromiseFlatCString(lastErrorString).get());
27616:   }
27616: #endif
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
12328:   if (paramsPresent) {
    1:     // bind parameters
 6426:     PRInt32 i;
 6426:     for (i = 0; i < aQueries.Count(); i++) {
13310:       rv = BindQueryClauseParameters(statement, i, aQueries[i], aOptions);
13310:       NS_ENSURE_SUCCESS(rv, rv);
13310:     }
13310:   }
13310: 
13310:   addParams.EnumerateRead(BindAdditionalParameter, statement.get());
 6483: 
 6483:   // optimize the case where we just use the results as is
 6483:   // and we don't need to do any post-query filtering
 6483:   if (NeedToFilterResultSet(aQueries, aOptions)) {
    1:     // generate the toplevel results
    1:     nsCOMArray<nsNavHistoryResultNode> toplevel;
    1:     rv = ResultsAsList(statement, aOptions, &toplevel);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6483:     FilterResultSet(aResultNode, toplevel, aResults, aQueries, aOptions);
    1:   } else {
 6483:     rv = ResultsAsList(statement, aOptions, aResults);
 6483:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } 
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistory::AddObserver
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::AddObserver(nsINavHistoryObserver* aObserver, PRBool aOwnsWeak)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aObserver);
18819: 
    1:   return mObservers.AppendWeakElement(aObserver, aOwnsWeak);
    1: }
    1: 
    1: 
    1: // nsNavHistory::RemoveObserver
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::RemoveObserver(nsINavHistoryObserver* aObserver)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aObserver);
18819: 
    1:   return mObservers.RemoveWeakElement(aObserver);
    1: }
    1: 
    1: // nsNavHistory::BeginUpdateBatch
12073: // See RunInBatchMode
 2051: nsresult
    1: nsNavHistory::BeginUpdateBatch()
    1: {
 4623:   if (mBatchLevel++ == 0) {
 4623:     PRBool transactionInProgress = PR_TRUE; // default to no transaction on err
 4623:     mDBConn->GetTransactionInProgress(&transactionInProgress);
 4623:     mBatchHasTransaction = ! transactionInProgress;
 4623:     if (mBatchHasTransaction)
 4623:       mDBConn->BeginTransaction();
 4623: 
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavHistoryObserver,
35298:                         OnBeginUpdateBatch());
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // nsNavHistory::EndUpdateBatch
 2051: nsresult
    1: nsNavHistory::EndUpdateBatch()
    1: {
 4623:   if (--mBatchLevel == 0) {
 4623:     if (mBatchHasTransaction)
 4623:       mDBConn->CommitTransaction();
 4623:     mBatchHasTransaction = PR_FALSE;
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavHistoryObserver,
35298:                         OnEndUpdateBatch());
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 2051: nsNavHistory::RunInBatchMode(nsINavHistoryBatchCallback* aCallback,
 4623:                              nsISupports* aUserData)
 4623: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aCallback);
 2051: 
 2051:   UpdateBatchScoper batch(*this);
12073:   return aCallback->RunBatched(aUserData);
 2051: }
 2051: 
 2051: NS_IMETHODIMP
    1: nsNavHistory::GetHistoryDisabled(PRBool *_retval)
    1: {
28236:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
    1:   NS_ENSURE_ARG_POINTER(_retval);
18819: 
    1:   *_retval = IsHistoryDisabled();
    1:   return NS_OK;
    1: }
    1: 
    1: // Browser history *************************************************************
    1: 
    1: 
    1: // nsNavHistory::AddPageWithDetails
    1: //
    1: //    This function is used by the migration components to import history.
    1: //
    1: //    Note that this always adds the page with one visit and no parent, which
    1: //    is appropriate for imported URIs.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::AddPageWithDetails(nsIURI *aURI, const PRUnichar *aTitle,
    1:                                  PRInt64 aLastVisited)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
34517:   // Don't update the page title inside the private browsing mode.
34517:   if (InPrivateBrowsingMode())
34517:     return NS_OK;
34517: 
    1:   PRInt64 visitID;
    1:   nsresult rv = AddVisit(aURI, aLastVisited, 0, TRANSITION_LINK, PR_FALSE,
    1:                          0, &visitID);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4037:   return SetPageTitleInternal(aURI, nsString(aTitle));
    1: }
    1: 
    1: 
    1: // nsNavHistory::GetLastPageVisited
    1: //
    1: //    This was once used when the new window is set to "previous page." It
    1: //    doesn't seem to be used anymore, so we don't spend any time precompiling
    1: //    the statement.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::GetLastPageVisited(nsACString & aLastPageVisited)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
18819: 
    1:   nsCOMPtr<mozIStorageStatement> statement;
20868:   // We are not checking for duplicated ids into the unified table
20868:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20868:   // expect newest visits being in temp table.
    1:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT url, visit_date FROM moz_historyvisits_temp v "
20868:       "JOIN moz_places_temp h ON v.place_id = h.id "
20868:       "WHERE h.hidden <> 1 "
20868:       "UNION ALL "
20868:       "SELECT url, visit_date FROM moz_historyvisits_temp v "
20868:       "JOIN moz_places h ON v.place_id = h.id "
20868:       "WHERE h.hidden <> 1 "
20868:       "UNION ALL "
28350:       "SELECT url, visit_date FROM moz_historyvisits v "
28350:       "JOIN moz_places_temp h ON v.place_id = h.id "
28350:       "WHERE h.hidden <> 1 "
28350:       "UNION ALL "
20868:       "SELECT url, visit_date FROM moz_historyvisits v "
20868:       "JOIN moz_places h ON v.place_id = h.id "
20868:       "WHERE h.hidden <> 1 "
28350:       "ORDER BY visit_date DESC "
28350:       "LIMIT 1 "),
    1:     getter_AddRefs(statement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMatch = PR_FALSE;
28350:   if (NS_SUCCEEDED(statement->ExecuteStep(&hasMatch)) && hasMatch)
    1:     return statement->GetUTF8String(0, aLastPageVisited);
28350: 
    1:   aLastPageVisited.Truncate(0);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::GetCount
    1: //
    1: //    This function is used in legacy code to see if there is any history to
    1: //    clear. Counting the actual number of history entries is very slow, so
    1: //    we just see if there are any and return 0 or 1, which is enough to make
    1: //    all the code that uses this function happy.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::GetCount(PRUint32 *aCount)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG_POINTER(aCount);
18819: 
    1:   PRBool hasEntries = PR_FALSE;
    1:   nsresult rv = GetHasHistoryEntries(&hasEntries);
    1:   if (hasEntries)
    1:     *aCount = 1;
    1:   else
    1:     *aCount = 0;
    1:   return rv;
    1: }
    1: 
    1: 
11424: // nsNavHistory::RemovePagesInternal
11424: //
11424: //    Deletes a list of placeIds from history.
32453: //    This is an internal method used by RemovePages, RemovePagesFromHost and
32453: //    RemovePagesByTimeframe.
11424: //    Takes a comma separated list of place ids.
11424: //    This method does not do any observer notification.
11424: 
11424: nsresult
11424: nsNavHistory::RemovePagesInternal(const nsCString& aPlaceIdsQueryString)
11424: {
11424:   // early return if there is nothing to delete
11424:   if (aPlaceIdsQueryString.IsEmpty())
11424:     return NS_OK;
11424: 
11424:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
11424: 
28485:   nsresult rv = PreparePlacesForVisitsDelete(aPlaceIdsQueryString);
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   // delete all visits
28485:   rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
28485:       "DELETE FROM moz_historyvisits_view WHERE place_id IN (") +
28485:         aPlaceIdsQueryString +
28485:         NS_LITERAL_CSTRING(")"));
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   rv = CleanupPlacesOnVisitsDelete(aPlaceIdsQueryString);
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   return transaction.Commit();
28485: }
28485: 
28485: 
28485: /**
28485:  * Prepares for deletion places that are about to have all their visits removed.
28485:  * This is an internal method used by RemovePagesInternal and
28485:  * RemoveVisitsByTimeframe.  This method does not execute in a transaction, so
28485:  * callers should make sure they begin one if needed.
28485:  *
28485:  * @param aPlaceIdsQueryString
28485:  *        A comma-separated list of place IDs, each of which is about to have
28485:  *        all its visits removed
28485:  */
28485: nsresult
28485: nsNavHistory::PreparePlacesForVisitsDelete(const nsCString& aPlaceIdsQueryString)
28485: {
28485:   // Return early if there is nothing to delete.
28485:   if (aPlaceIdsQueryString.IsEmpty())
28485:     return NS_OK;
28485: 
13613:   // if a moz_place is annotated or was a bookmark,
13613:   // we won't delete it, but we will delete the moz_visits
13613:   // so we need to reset the frecency.  Note, we set frecency to
13613:   // -visit_count, as we use that value in our "on idle" query
13613:   // to figure out which places to recalculate frecency first.
13613:   // Pay attention to not set frecency = 0 if visit_count = 0
13613:   nsresult rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "UPDATE moz_places_view "
13613:       "SET frecency = -MAX(visit_count, 1) "
20868:       "WHERE id IN ( "
20868:         "SELECT h.id " 
20868:         "FROM moz_places_temp h "
20868:         "WHERE h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
20868:           "AND ( "
20868:             "EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk =h.id) "
20868:             "OR EXISTS (SELECT a.id FROM moz_annos a WHERE a.place_id = h.id) "
20868:           ") "
20868:         "UNION ALL "
20868:         "SELECT h.id " 
20868:         "FROM moz_places h "
20868:         "WHERE h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
20868:           "AND h.id NOT IN (SELECT id FROM moz_places_temp) "
20868:           "AND ( "
20868:             "EXISTS (SELECT b.id FROM moz_bookmarks b WHERE b.fk =h.id) "
20868:             "OR EXISTS (SELECT a.id FROM moz_annos a WHERE a.place_id = h.id) "
20868:           ") "        
20868:       ")"));
13613:   NS_ENSURE_SUCCESS(rv, rv);
13613: 
28485:   return NS_OK;
28485: }
28485: 
28485: 
28485: /**
28485:  * Performs cleanup on places that just had all their visits removed, including
28485:  * deletion of those places.  This is an internal method used by
28485:  * RemovePagesInternal and RemoveVisitsByTimeframe.  This method does not
28485:  * execute in a transaction, so callers should make sure they begin one if
28485:  * needed.
28485:  *
28485:  * @param aPlaceIdsQueryString
28485:  *        A comma-separated list of place IDs, each of which just had all its
28485:  *        visits removed
28485:  */
28485: nsresult
28485: nsNavHistory::CleanupPlacesOnVisitsDelete(const nsCString& aPlaceIdsQueryString)
28485: {
28485:   // Return early if there is nothing to delete.
28485:   if (aPlaceIdsQueryString.IsEmpty())
28485:     return NS_OK;
11424: 
11424:   // now that visits have been removed, run annotation expiration.
11424:   // this will remove all expire-able annotations for these URIs.
33704:   (void)mExpire->OnDeleteVisits();
11424: 
14062:   // if the entry is not bookmarked and is not a place: uri
14062:   // then we can remove it from moz_places.
11424:   // Note that we do NOT delete favicons. Any unreferenced favicons will be
11424:   // deleted next time the browser is shut down.
28485:   nsresult rv = mDBConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
20868:       "DELETE FROM moz_places_view WHERE id IN ("
20868:         "SELECT h.id FROM moz_places_temp h "
20868:         "WHERE h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
27197:           "AND SUBSTR(h.url, 1, 6) <> 'place:' "
20868:           "AND NOT EXISTS "
20868:             "(SELECT b.id FROM moz_bookmarks b WHERE b.fk = h.id LIMIT 1) "
20868:         "UNION ALL "
20868:         "SELECT h.id FROM moz_places h "
20868:         "WHERE h.id NOT IN (SELECT id FROM moz_places_temp) "
20868:           "AND h.id IN ( ") + aPlaceIdsQueryString + NS_LITERAL_CSTRING(") "
27197:           "AND SUBSTR(h.url, 1, 6) <> 'place:' "
20868:           "AND NOT EXISTS "
20868:             "(SELECT b.id FROM moz_bookmarks b WHERE b.fk = h.id LIMIT 1) "
20868:     ")"));
11424:   NS_ENSURE_SUCCESS(rv, rv);
11424: 
23196:   // If we have removed all visits to a livemark's child, we need to fix its
23196:   // frecency, or it would appear in the url bar autocomplete.
11424:   // XXX this might be dog slow, further degrading delete perf.
11424:   rv = FixInvalidFrecenciesForExcludedPlaces();
11424:   NS_ENSURE_SUCCESS(rv, rv);
11424: 
28485:   return NS_OK;
11424: }
11424: 
11424: 
11137: // nsNavHistory::RemovePages
    1: //
11137: //    Removes a bunch of uris from history.
11137: //    Has better performance than RemovePage when deleting a lot of history.
11137: //    Notice that this function does not call the onDeleteURI observers,
11137: //    instead, if aDoBatchNotify is true, we call OnBegin/EndUpdateBatch.
11137: //    We don't do duplicates removal, URIs array should be cleaned-up before.
    1: 
    1: NS_IMETHODIMP
11137: nsNavHistory::RemovePages(nsIURI **aURIs, PRUint32 aLength, PRBool aDoBatchNotify)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURIs);
18819: 
32453: #ifdef LAZY_ADD
32453:   // We must ensure to remove pages from the lazy messages queue too.
32453:   CommitLazyMessages();
32453: #endif
32453: 
11424:   nsresult rv;
11137:   // build a list of place ids to delete
11137:   nsCString deletePlaceIdsQueryString;
14274:   for (PRUint32 i = 0; i < aLength; i++) {
 4037:     PRInt64 placeId;
11137:     rv = GetUrlIdFor(aURIs[i], &placeId, PR_FALSE);
11137:     NS_ENSURE_SUCCESS(rv, rv);
11137:     if (placeId != 0) {
11137:       if (!deletePlaceIdsQueryString.IsEmpty())
11137:         deletePlaceIdsQueryString.AppendLiteral(",");
11137:       deletePlaceIdsQueryString.AppendInt(placeId);
11137:     }
11137:   }
11137: 
11424:   rv = RemovePagesInternal(deletePlaceIdsQueryString);
11137:   NS_ENSURE_SUCCESS(rv, rv);
11137: 
11137:   // force a full refresh calling onEndUpdateBatch (will call Refresh())
11137:   if (aDoBatchNotify)
11137:     UpdateBatchScoper batch(*this); // sends Begin/EndUpdateBatch to observers
11137: 
11137:   return NS_OK;
11137: }
11137: 
11137: 
11137: // nsNavHistory::RemovePage
11137: //
11137: //    Removes all visits and the main history entry for the given URI.
11137: //    Silently fails if we have no knowledge of the page.
11137: 
11137: NS_IMETHODIMP
11137: nsNavHistory::RemovePage(nsIURI *aURI)
11137: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
27196:   // Before we remove, we have to notify our observers!
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
35298:                       nsINavHistoryObserver, OnBeforeDeleteURI(aURI));
27196: 
11137:   nsIURI** URIs = &aURI;
11137:   nsresult rv = RemovePages(URIs, 1, PR_FALSE);
11137:   NS_ENSURE_SUCCESS(rv, rv);
27196: 
27196:   // Notify our observers that the URI has been removed.
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
35298:                       nsINavHistoryObserver, OnDeleteURI(aURI));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::RemovePagesFromHost
    1: //
    1: //    This function will delete all history information about pages from a
    1: //    given host. If aEntireDomain is set, we will also delete pages from
    1: //    sub hosts (so if we are passed in "microsoft.com" we delete
    1: //    "www.microsoft.com", "msdn.microsoft.com", etc.). An empty host name
    1: //    means local files and anything else with no host name. You can also pass
    1: //    in the localized "(local files)" title given to you from a history query.
    1: //
 4037: //    Silently fails if we have no knowledge of the host.
    1: //
11424: //    This sends onBeginUpdateBatch/onEndUpdateBatch to observers
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::RemovePagesFromHost(const nsACString& aHost, PRBool aEntireDomain)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
18819: 
32453: #ifdef LAZY_ADD
32453:   // We must ensure to remove pages from the lazy messages queue too.
32453:   CommitLazyMessages();
32453: #endif
32453: 
    1:   nsresult rv;
    1:   // Local files don't have any host name. We don't want to delete all files in
    1:   // history when we get passed an empty string, so force to exact match
    1:   if (aHost.IsEmpty())
    1:     aEntireDomain = PR_FALSE;
    1: 
    1:   // translate "(local files)" to an empty host name
    1:   // be sure to use the TitleForDomain to get the localized name
    1:   nsCString localFiles;
    1:   TitleForDomain(EmptyCString(), localFiles);
    1:   nsAutoString host16;
    1:   if (!aHost.Equals(localFiles))
24715:     CopyUTF8toUTF16(aHost, host16);
    1: 
    1:   // nsISupports version of the host string for passing to observers
    1:   nsCOMPtr<nsISupportsString> hostSupports(do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = hostSupports->SetData(host16);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // see BindQueryClauseParameters for how this host selection works
    1:   nsAutoString revHostDot;
    1:   GetReversedHostname(host16, revHostDot);
    1:   NS_ASSERTION(revHostDot[revHostDot.Length() - 1] == '.', "Invalid rev. host");
    1:   nsAutoString revHostSlash(revHostDot);
    1:   revHostSlash.Truncate(revHostSlash.Length() - 1);
    1:   revHostSlash.Append(NS_LITERAL_STRING("/"));
    1: 
11424:   // build condition string based on host selection type
    1:   nsCAutoString conditionString;
    1:   if (aEntireDomain)
20868:     conditionString.AssignLiteral("rev_host >= ?1 AND rev_host < ?2 ");
    1:   else
20868:     conditionString.AssignLiteral("rev_host = ?1 ");
    1: 
11424:   nsCOMPtr<mozIStorageStatement> statement;
 4037: 
 4037:   // create statement depending on delete type
11424:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT id FROM moz_places_temp "
20868:       "WHERE ") + conditionString + NS_LITERAL_CSTRING(
20868:       "UNION ALL "
20868:       "SELECT id FROM moz_places "
20868:       "WHERE id NOT IN (SELECT id FROM moz_places_temp) "
20868:         "AND ") + conditionString,
20868:     getter_AddRefs(statement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = statement->BindStringParameter(0, revHostDot);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (aEntireDomain) {
    1:     rv = statement->BindStringParameter(1, revHostSlash);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
11424: 
11424:   nsCString hostPlaceIds;
    1:   PRBool hasMore = PR_FALSE;
28350:   while (NS_SUCCEEDED(statement->ExecuteStep(&hasMore)) && hasMore) {
11424:     if (!hostPlaceIds.IsEmpty())
11424:       hostPlaceIds.AppendLiteral(",");
 4037:     PRInt64 placeId;
 4037:     rv = statement->GetInt64(0, &placeId);
 4037:     NS_ENSURE_SUCCESS(rv, rv);
11424:     hostPlaceIds.AppendInt(placeId);
11424:   }
11424: 
11424:   // force a full refresh calling onEndUpdateBatch (will call Refresh())
11424:   UpdateBatchScoper batch(*this); // sends Begin/EndUpdateBatch to observers
11424: 
23747:   rv = RemovePagesInternal(hostPlaceIds);
23747:   NS_ENSURE_SUCCESS(rv, rv);
23747: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
12101: // nsNavHistory::RemovePagesByTimeframe
12101: //
12101: //    This function will delete all history information about
12101: //    pages for a given timeframe.
12101: //    Limits are included: aBeginTime <= timeframe <= aEndTime
12101: //
12101: //    This method sends onBeginUpdateBatch/onEndUpdateBatch to observers
12101: 
12101: NS_IMETHODIMP
12101: nsNavHistory::RemovePagesByTimeframe(PRTime aBeginTime, PRTime aEndTime)
12101: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
18819: 
32453: #ifdef LAZY_ADD
32453:   // We must ensure to remove pages from the lazy messages queue too.
32453:   CommitLazyMessages();
32453: #endif
32453: 
12101:   nsresult rv;
12101:   // build a list of place ids to delete
12101:   nsCString deletePlaceIdsQueryString;
12101: 
12101:   // we only need to know if a place has a visit into the given timeframe
12101:   // this query is faster than actually selecting in moz_historyvisits
12101:   nsCOMPtr<mozIStorageStatement> selectByTime;
12101:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT h.id FROM moz_places_temp h WHERE "
20868:         "EXISTS "
20868:           "(SELECT id FROM moz_historyvisits v WHERE v.place_id = h.id "
20868:             "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"
20868:         "OR EXISTS "
20868:           "(SELECT id FROM moz_historyvisits_temp v WHERE v.place_id = h.id "
20868:             "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1) "
20868:       "UNION "
12101:       "SELECT h.id FROM moz_places h WHERE "
20868:         "EXISTS "
20868:           "(SELECT id FROM moz_historyvisits v WHERE v.place_id = h.id "
20868:             "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"
20868:         "OR EXISTS "
20868:           "(SELECT id FROM moz_historyvisits_temp v WHERE v.place_id = h.id "
12101:             "AND v.visit_date >= ?1 AND v.visit_date <= ?2 LIMIT 1)"),
12101:     getter_AddRefs(selectByTime));
12101:   NS_ENSURE_SUCCESS(rv, rv);
12101:   rv = selectByTime->BindInt64Parameter(0, aBeginTime);
12101:   NS_ENSURE_SUCCESS(rv, rv);
12101:   rv = selectByTime->BindInt64Parameter(1, aEndTime);
12101:   NS_ENSURE_SUCCESS(rv, rv);
12101: 
12101:   PRBool hasMore = PR_FALSE;
12101:   while (NS_SUCCEEDED(selectByTime->ExecuteStep(&hasMore)) && hasMore) {
12101:     PRInt64 placeId;
12101:     rv = selectByTime->GetInt64(0, &placeId);
12101:     NS_ENSURE_SUCCESS(rv, rv);
12101:     if (placeId != 0) {
12101:       if (!deletePlaceIdsQueryString.IsEmpty())
12101:         deletePlaceIdsQueryString.AppendLiteral(",");
12101:       deletePlaceIdsQueryString.AppendInt(placeId);
12101:     }
12101:   }
12101: 
12101:   rv = RemovePagesInternal(deletePlaceIdsQueryString);
12101:   NS_ENSURE_SUCCESS(rv, rv);
12101: 
12101:   // force a full refresh calling onEndUpdateBatch (will call Refresh())
12101:   UpdateBatchScoper batch(*this); // sends Begin/EndUpdateBatch to observers
12101: 
12101:   return NS_OK;
12101: }
12101: 
12101: 
28485: /**
28485:  * Removes all visits in a given timeframe.  Limits are included:
28485:  * aBeginTime <= timeframe <= aEndTime.  Any place that becomes unvisited
28485:  * as a result will also be deleted.
28485:  *
28485:  * Note that removal is performed in batch, so observers will not be
28485:  * notified of individual places that are deleted.  Instead they will be
28485:  * notified onBeginUpdateBatch and onEndUpdateBatch.
28485:  *
28485:  * @param aBeginTime
28485:  *        The start of the timeframe, inclusive
28485:  * @param aEndTime
28485:  *        The end of the timeframe, inclusive
28485:  */
28485: NS_IMETHODIMP
28485: nsNavHistory::RemoveVisitsByTimeframe(PRTime aBeginTime, PRTime aEndTime)
28485: {
28485:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28485: 
32453: #ifdef LAZY_ADD
32453:   // We must ensure to remove pages from the lazy messages queue too.
32453:   CommitLazyMessages();
32453: #endif
32453: 
28485:   nsresult rv;
28485: 
28485:   // Build a list of place IDs whose visits fall entirely within the timespan.
28485:   // These places will be deleted by the call to CleanupPlacesOnVisitsDelete
28485:   // below.
28485:   nsCString deletePlaceIdsQueryString;
28485:   {
28485:     nsCOMPtr<mozIStorageStatement> selectByTime;
28485:     mozStorageStatementScoper scope(selectByTime);
28485:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
28485:         "SELECT place_id "
28485:         "FROM moz_historyvisits_temp "
28485:         "WHERE ?1 <= visit_date AND visit_date <= ?2 "
28485:         "UNION "
28485:         "SELECT place_id "
28485:         "FROM moz_historyvisits "
28485:         "WHERE ?1 <= visit_date AND visit_date <= ?2 "
28485:         "EXCEPT "
28485:         "SELECT place_id "
28485:         "FROM moz_historyvisits_temp "
28485:         "WHERE visit_date < ?1 OR ?2 < visit_date "
28485:         "EXCEPT "
28485:         "SELECT place_id "
28485:         "FROM moz_historyvisits "
28485:         "WHERE visit_date < ?1 OR ?2 < visit_date"),
28485:       getter_AddRefs(selectByTime));
28485:     NS_ENSURE_SUCCESS(rv, rv);
28485:     rv = selectByTime->BindInt64Parameter(0, aBeginTime);
28485:     NS_ENSURE_SUCCESS(rv, rv);
28485:     rv = selectByTime->BindInt64Parameter(1, aEndTime);
28485:     NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:     PRBool hasMore = PR_FALSE;
28485:     while (NS_SUCCEEDED(selectByTime->ExecuteStep(&hasMore)) && hasMore) {
28485:       PRInt64 placeId;
28485:       rv = selectByTime->GetInt64(0, &placeId);
28485:       NS_ENSURE_SUCCESS(rv, rv);
28485:       // placeId should not be <= 0, but be defensive.
28485:       if (placeId > 0) {
28485:         if (!deletePlaceIdsQueryString.IsEmpty())
28485:           deletePlaceIdsQueryString.AppendLiteral(",");
28485:         deletePlaceIdsQueryString.AppendInt(placeId);
28485:       }
28485:     }
28485:   }
28485: 
28485:   // force a full refresh calling onEndUpdateBatch (will call Refresh())
28485:   UpdateBatchScoper batch(*this); // sends Begin/EndUpdateBatch to observers
28485: 
28485:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
28485: 
28485:   rv = PreparePlacesForVisitsDelete(deletePlaceIdsQueryString);
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   // Delete all visits within the timeframe.
28485:   nsCOMPtr<mozIStorageStatement> deleteVisitsStmt;
28485:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
28485:       "DELETE FROM moz_historyvisits_view "
28485:       "WHERE ?1 <= visit_date AND visit_date <= ?2"),
28485:     getter_AddRefs(deleteVisitsStmt));
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485:   rv = deleteVisitsStmt->BindInt64Parameter(0, aBeginTime);
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485:   rv = deleteVisitsStmt->BindInt64Parameter(1, aEndTime);
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485:   rv = deleteVisitsStmt->Execute();
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   rv = CleanupPlacesOnVisitsDelete(deletePlaceIdsQueryString);
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   rv = transaction.Commit();
28485:   NS_ENSURE_SUCCESS(rv, rv);
28485: 
28485:   return NS_OK;
28485: }
28485: 
28485: 
    1: // nsNavHistory::RemoveAllPages
    1: //
    1: //    This function is used to clear history.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::RemoveAllPages()
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
18819: 
32453: #ifdef LAZY_ADD
32453:   // We must ensure to remove pages from the lazy messages queue too.
32453:   CommitLazyMessages();
32453: #endif
32453: 
    1:   // expire everything
33704:   mExpire->ClearHistory();
    1: 
13227:   // privacy cleanup, if there's an old history.dat around, just delete it
13227:   nsCOMPtr<nsIFile> oldHistoryFile;
13227:   nsresult rv = NS_GetSpecialDirectory(NS_APP_HISTORY_50_FILE,
13227:                                        getter_AddRefs(oldHistoryFile));
33829:   NS_ENSURE_SUCCESS(rv, rv);
13227: 
13227:   PRBool fileExists;
13227:   if (NS_SUCCEEDED(oldHistoryFile->Exists(&fileExists)) && fileExists) {
13227:     rv = oldHistoryFile->Remove(PR_FALSE);
13227:     NS_ENSURE_SUCCESS(rv, rv);
13227:   }
13227: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::HidePage
    1: //
    1: //    Sets the 'hidden' column to true. If we've not heard of the page, we
    1: //    succeed and do nothing.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::HidePage(nsIURI *aURI)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: // nsNavHistory::MarkPageAsTyped
    1: //
 9700: // We call MarkPageAsTyped() before visiting a URL in order to 
 9700: // help determine the transition type of the visit.  
 9700: // We keep track of the URL so that later, in AddVisitChain() 
 9700: // we can use TRANSITION_TYPED as the transition.
 9700: // Note, AddVisitChain() is not called immediately when we are doing LAZY_ADDs
    1: //
    1: // @see MarkPageAsFollowedBookmark
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::MarkPageAsTyped(nsIURI *aURI)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
    1:   // don't add when history is disabled
    1:   if (IsHistoryDisabled())
    1:     return NS_OK;
    1: 
    1:   nsCAutoString uriString;
10669:   nsresult rv = aURI->GetSpec(uriString);
10669:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // if URL is already in the typed queue, then we need to remove the old one
    1:   PRInt64 unusedEventTime;
    1:   if (mRecentTyped.Get(uriString, &unusedEventTime))
    1:     mRecentTyped.Remove(uriString);
    1: 
    1:   if (mRecentTyped.Count() > RECENT_EVENT_QUEUE_MAX_LENGTH)
    1:     ExpireNonrecentEvents(&mRecentTyped);
    1: 
    1:   mRecentTyped.Put(uriString, GetNow());
    1:   return NS_OK;
    1: }
    1: 
14062: 
14062: // nsNavHistory::SetCharsetForURI
14062: //
14062: // Sets the character-set for an URI.
14062: // If aCharset is empty remove character-set annotation for aURI.
14062: 
14062: NS_IMETHODIMP
14062: nsNavHistory::SetCharsetForURI(nsIURI* aURI,
14062:                                const nsAString& aCharset)
14062: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
14062:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
14062:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
14062: 
14062:   if (aCharset.IsEmpty()) {
14062:     // remove the current page character-set annotation
14062:     nsresult rv = annosvc->RemovePageAnnotation(aURI, CHARSET_ANNO);
14062:     NS_ENSURE_SUCCESS(rv, rv);
14062:   }
14062:   else {
14062:     // Set page character-set annotation, silently overwrite if already exists
14062:     nsresult rv = annosvc->SetPageAnnotationString(aURI, CHARSET_ANNO,
14062:                                                    aCharset, 0,
14062:                                                    nsAnnotationService::EXPIRE_NEVER);
14062:     NS_ENSURE_SUCCESS(rv, rv);
14062:   }
14062: 
14062:   return NS_OK;
14062: }
14062: 
14062: 
14062: // nsNavHistory::GetCharsetForURI
14062: //
14062: // Get the last saved character-set for an URI.
14062: 
14062: NS_IMETHODIMP
14062: nsNavHistory::GetCharsetForURI(nsIURI* aURI, 
14062:                                nsAString& aCharset)
14062: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
14062:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
14062:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
14062: 
14062:   nsAutoString charset;
14062:   nsresult rv = annosvc->GetPageAnnotationString(aURI, CHARSET_ANNO, aCharset);
14062:   if (NS_FAILED(rv)) {
14062:     // be sure to return an empty string if character-set is not found
14062:     aCharset.Truncate();
14062:   }
14062:   return NS_OK;
14062: }
14062: 
14062: 
    1: // nsGlobalHistory2 ************************************************************
    1: 
    1: 
    1: // nsNavHistory::AddURI
    1: //
    1: //    This is the main method of adding history entries.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::AddURI(nsIURI *aURI, PRBool aRedirect,
    1:                      PRBool aToplevel, nsIURI *aReferrer)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
    1:   // don't add when history is disabled
    1:   if (IsHistoryDisabled())
    1:     return NS_OK;
    1: 
 9486:   // filter out any unwanted URIs
 9486:   PRBool canAdd = PR_FALSE;
 9486:   nsresult rv = CanAddURI(aURI, &canAdd);
 9486:   NS_ENSURE_SUCCESS(rv, rv);
 9486:   if (!canAdd)
 9486:     return NS_OK;
 9486: 
    1:   PRTime now = PR_Now();
    1: 
    1: #ifdef LAZY_ADD
    1:   LazyMessage message;
    1:   rv = message.Init(LazyMessage::Type_AddURI, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   message.isRedirect = aRedirect;
    1:   message.isToplevel = aToplevel;
    1:   if (aReferrer) {
    1:     rv = aReferrer->Clone(getter_AddRefs(message.referrer));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   message.time = now;
    1:   rv = AddLazyMessage(message);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: #else
    1:   rv = AddURIInternal(aURI, now, aRedirect, aToplevel, aReferrer);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::AddURIInternal
    1: //
    1: //    This does the work of AddURI so it can be done lazily.
    1: 
    1: nsresult
    1: nsNavHistory::AddURIInternal(nsIURI* aURI, PRTime aTime, PRBool aRedirect,
    1:                              PRBool aToplevel, nsIURI* aReferrer)
    1: {
    1:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
    1:   PRInt64 redirectBookmark = 0;
    1:   PRInt64 visitID, sessionID;
    1:   nsresult rv = AddVisitChain(aURI, aTime, aToplevel, aRedirect, aReferrer,
    1:                               &visitID, &sessionID, &redirectBookmark);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // The bookmark cache of redirects may be out-of-date with this addition, so
    1:   // we need to update it. The issue here is if they bookmark "mozilla.org" by
    1:   // typing it in without ever having visited "www.mozilla.org". They will then
    1:   // get redirected to the latter, and we need to add mozilla.org ->
    1:   // www.mozilla.org to the bookmark hashtable.
    1:   //
    1:   // AddVisitChain will put the spec of a bookmarked URI if it encounters one
    1:   // into bookmarkURI. If this is non-empty, we know that something has happened
    1:   // with a bookmark and we should probably go update it.
    1:   if (redirectBookmark) {
    1:     nsNavBookmarks *bookmarkService = nsNavBookmarks::GetBookmarksService();
    1:     if (bookmarkService) {
    1:       PRTime now = GetNow();
    1:       bookmarkService->AddBookmarkToHash(redirectBookmark,
    1:                                          now - BOOKMARK_REDIRECT_TIME_THRESHOLD);
    1:     }
    1:   }
    1: 
    1:   return transaction.Commit();
    1: }
    1: 
    1: 
    1: // nsNavHistory::AddVisitChain
    1: //
    1: //    This function is sits between AddURI (which is called when a page is
    1: //    visited) and AddVisit (which creates the DB entries) to figure out what
    1: //    we should add and what are the detailed parameters that should be used
    1: //    (like referring visit ID and typed/bookmarked state).
    1: //
    1: //    This function walks up the referring chain and recursively calls itself,
    1: //    each time calling InternalAdd to create a new history entry. (When we
    1: //    get notified of redirects, we don't actually add any history entries, just
    1: //    save them in mRecentRedirects. This function will add all of them for a
    1: //    given destination page when that page is actually visited.)
    1: //    See GetRedirectFor for more information about how redirects work.
    1: //
    1: //    aRedirectBookmark should be empty when this function is first called. If
    1: //    there are any redirects that are bookmarks the specs will be placed in
    1: //    this buffer. The caller can then determine if any bookmarked items were
    1: //    visited so it knows whether to update the bookmark service's redirect
    1: //    hashtable.
    1: 
    1: nsresult
    1: nsNavHistory::AddVisitChain(nsIURI* aURI, PRTime aTime,
    1:                             PRBool aToplevel, PRBool aIsRedirect,
17044:                             nsIURI* aReferrerURI, PRInt64* aVisitID,
    1:                             PRInt64* aSessionID, PRInt64* aRedirectBookmark)
    1: {
    1:   PRUint32 transitionType = 0;
    1:   PRInt64 referringVisit = 0;
    1:   PRTime visitTime = 0;
17044:   nsCOMPtr<nsIURI> fromVisitURI = aReferrerURI;
    1: 
    1:   nsCAutoString spec;
    1:   nsresult rv = aURI->GetSpec(spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCAutoString redirectSource;
    1:   if (GetRedirectFor(spec, redirectSource, &visitTime, &transitionType)) {
    1:     // this was a redirect: See GetRedirectFor for info on how this works
    1:     nsCOMPtr<nsIURI> redirectURI;
    1:     rv = NS_NewURI(getter_AddRefs(redirectURI), redirectSource);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // remember if any redirect sources were bookmarked
    1:     nsNavBookmarks *bookmarkService = nsNavBookmarks::GetBookmarksService();
    1:     PRBool isBookmarked;
    1:     if (bookmarkService &&
    1:         NS_SUCCEEDED(bookmarkService->IsBookmarked(redirectURI, &isBookmarked))
    1:         && isBookmarked) {
    1:       GetUrlIdFor(redirectURI, aRedirectBookmark, PR_FALSE);
    1:     }
    1: 
    1:     // Find the visit for the source. Note that we decrease the time counter,
    1:     // which will ensure that the referrer and this page will appear in history
    1:     // in the correct order. Since the times are in microseconds, it should not
    1:     // normally be possible to get two pages within one microsecond of each
    1:     // other so the referrer won't appear before a previous page viewed.
17044:     rv = AddVisitChain(redirectURI, aTime - 1, aToplevel, PR_TRUE, aReferrerURI,
    1:                        &referringVisit, aSessionID, aRedirectBookmark);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
 1840:     // for redirects in frames, we don't want to see those items in history
 1840:     // see bug #381453 for more details
 1840:     if (!aToplevel) {
 1840:       transitionType = nsINavHistoryService::TRANSITION_EMBED;
 1840:     }
17044: 
26258:     // We have been redirected, if the previous site was not a redirect
26258:     // update the referrer so we can walk up the redirect chain.
26258:     // See bug 411966 and Bug 428690 for details.
17044:     fromVisitURI = redirectURI;
17044:   } else if (aReferrerURI) {
11121:     // We do not want to add a new visit if the referring site is the same as
11121:     // the new site.  This is the situation where a page refreshes itself to
11121:     // give the user updated information.
11121:     PRBool referrerIsSame;
17044:     if (NS_SUCCEEDED(aURI->Equals(aReferrerURI, &referrerIsSame)) && referrerIsSame)
11121:       return NS_OK;
11121: 
    1:     // If there is a referrer, we know you came from somewhere, either manually
    1:     // or automatically. For toplevel windows, assume its manual and you want
    1:     // to see this in history. For other things, it's some kind of embedded
    1:     // navigation. This is true of images and other content the user doesn't
    1:     // want to see in their history, but also of embedded frames that the user
    1:     // navigated manually and probably DOES want to see in history.
    1:     // Unfortunately, there isn't any easy way to distinguish these.
    1:     //
    1:     // Generally, it boils down to the problem of detecting whether a frame
    1:     // content change is the result of a user action, which isn't well defined
    1:     // since script could change a frame's source as a result of user request,
    1:     // or just because it feels like loading a new ad. The "back" button will
    1:     // undo either of these actions.
    1:     if (aToplevel)
    1:       transitionType = nsINavHistoryService::TRANSITION_LINK;
    1:     else
    1:       transitionType = nsINavHistoryService::TRANSITION_EMBED;
    1: 
    1:     // Note that here we should NOT use the GetNow function. That function
    1:     // caches the value of "now" until next time the event loop runs. This
    1:     // gives better performance, but here we may get many notifications without
    1:     // running the event loop. We must preserve these events' ordering. This
    1:     // most commonly happens on redirects.
    1:     visitTime = PR_Now();
    1: 
11121:     // Try to turn the referrer into a visit.
11121:     // This also populates the session id.
17044:     if (!FindLastVisit(aReferrerURI, &referringVisit, aSessionID)) {
    1:       // we couldn't find a visit for the referrer, don't set it
    1:       *aSessionID = GetNewSessionID();
    1:     }
    1:   } else {
    1:     // When there is no referrer, we know the user must have gotten the link
    1:     // from somewhere, so check our sources to see if it was recently typed or
    1:     // has a bookmark selected. We don't handle drag-and-drop operations.
 4163:     // note:  the link may have also come from a new window (set to load a homepage)
 4163:     // or on start up (if we've set to load the home page or restore tabs)
 4163:     // we treat these as TRANSITION_LINK (if they are top level) or
 4163:     // TRANSITION_EMBED (if not top level).  We don't want to to add visits to 
 4163:     // history without a transition type.
    1:     if (CheckIsRecentEvent(&mRecentTyped, spec))
    1:       transitionType = nsINavHistoryService::TRANSITION_TYPED;
    1:     else if (CheckIsRecentEvent(&mRecentBookmark, spec))
    1:       transitionType = nsINavHistoryService::TRANSITION_BOOKMARK;
 4163:     else if (aToplevel)
 4163:       transitionType = nsINavHistoryService::TRANSITION_LINK;
 4163:     else
 4163:       transitionType = nsINavHistoryService::TRANSITION_EMBED;
    1: 
    1:     visitTime = PR_Now();
    1:     *aSessionID = GetNewSessionID();
    1:   }
    1: 
    1:   // this call will create the visit and create/update the page entry
17044:   return AddVisit(aURI, visitTime, fromVisitURI, transitionType,
    1:                   aIsRedirect, *aSessionID, aVisitID);
    1: }
    1: 
    1: 
    1: // nsNavHistory::IsVisited
    1: //
    1: //    Note that this ignores the "hidden" flag. This function just checks if the
    1: //    given page is in the DB for link coloring. The "hidden" flag affects
    1: //    the history list view and autocomplete.
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::IsVisited(nsIURI *aURI, PRBool *_retval)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
28236:   NS_ENSURE_ARG_POINTER(_retval);
18819: 
    1:   // if history is disabled, we can optimize
    1:   if (IsHistoryDisabled()) {
    1:     *_retval = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCAutoString utf8URISpec;
    1:   nsresult rv = aURI->GetSpec(utf8URISpec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *_retval = IsURIStringVisited(utf8URISpec);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::SetPageTitle
    1: //
 4037: //    This sets the page title.
    1: //
    1: //    Note that we do not allow empty real titles and will silently ignore such
    1: //    requests. When a URL is added we give it a default title based on the
    1: //    URL. Most pages provide a title and it gets replaced to something better.
    1: //    Some pages don't: some say <title></title>, and some don't have any title
    1: //    element. In BOTH cases, we get SetPageTitle(URI, ""), but in both cases,
    1: //    our default title is more useful to the user than "(no title)".
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::SetPageTitle(nsIURI* aURI,
    1:                            const nsAString& aTitle)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
34517:   // Don't update the page title inside the private browsing mode.
34517:   if (InPrivateBrowsingMode())
34517:     return NS_OK;
34517: 
11935:   // if aTitle is empty we want to clear the previous title.
11935:   // We don't want to set it to an empty string, but to a NULL value,
11935:   // so we use SetIsVoid and SetPageTitleInternal will take care of that
    1: 
    1: #ifdef LAZY_ADD
    1:   LazyMessage message;
    1:   nsresult rv = message.Init(LazyMessage::Type_Title, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   message.title = aTitle;
11935:   if (aTitle.IsEmpty())
11935:     message.title.SetIsVoid(PR_TRUE);
    1:   return AddLazyMessage(message);
    1: #else
11935:   if (aTitle.IsEmpty()) {
11935:     nsString voidString;
11935:     voidString.SetIsVoid(PR_TRUE);
11935:     return SetPageTitleInternal(aURI, voidString);
11935:   }
 4037:   return SetPageTitleInternal(aURI, aTitle);
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::GetPageTitle(nsIURI* aURI, nsAString& aTitle)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
    1:   aTitle.Truncate(0);
    1: 
35411:   mozStorageStatementScoper scope(mDBGetURLPageInfo);
35411:   nsresult rv = BindStatementURI(mDBGetURLPageInfo, 0, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34766:   PRBool hasResults = PR_FALSE;
35411:   rv = mDBGetURLPageInfo->ExecuteStep(&hasResults);
34766:   NS_ENSURE_SUCCESS(rv, rv);
34766: 
34766:   if (!hasResults) {
    1:     aTitle.SetIsVoid(PR_TRUE);
35411:     return NS_OK; // Not found, return a void string.
35411:   }
35411: 
35411:   rv = mDBGetURLPageInfo->GetString(nsNavHistory::kGetInfoIndex_Title, aTitle);
34766:   NS_ENSURE_SUCCESS(rv, rv);
34766: 
34766:   return NS_OK;
34766: }
    1: 
    1: // nsNavHistory::GetURIGeckoFlags
    1: //
    1: //    FIXME: should we try to use annotations for this stuff?
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::GetURIGeckoFlags(nsIURI* aURI, PRUint32* aResult)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
28236:   NS_ENSURE_ARG_POINTER(aResult);
18819: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: // nsNavHistory::SetURIGeckoFlags
    1: //
    1: //    FIXME: should we try to use annotations for this stuff?
    1: 
    1: NS_IMETHODIMP
    1: nsNavHistory::SetURIGeckoFlags(nsIURI* aURI, PRUint32 aFlags)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aURI);
18819: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: // nsIGlobalHistory3 ***********************************************************
    1: 
    1: // nsNavHistory::AddDocumentRedirect
    1: //
    1: //    This adds a redirect mapping from the destination of the redirect to the
    1: //    source, time, and type. This mapping is used by GetRedirectFor when we
    1: //    get a page added to reconstruct the redirects that happened when a page
    1: //    is visited. See GetRedirectFor for more information
    1: 
    1: // this is the expiration callback function that deletes stale entries
20261: PLDHashOperator nsNavHistory::ExpireNonrecentRedirects(
    1:     nsCStringHashKey::KeyType aKey, RedirectInfo& aData, void* aUserArg)
    1: {
 3233:   PRInt64* threshold = reinterpret_cast<PRInt64*>(aUserArg);
    1:   if (aData.mTimeCreated < *threshold)
    1:     return PL_DHASH_REMOVE;
    1:   return PL_DHASH_NEXT;
    1: }
 4049: 
    1: NS_IMETHODIMP
    1: nsNavHistory::AddDocumentRedirect(nsIChannel *aOldChannel,
    1:                                   nsIChannel *aNewChannel,
    1:                                   PRInt32 aFlags,
    1:                                   PRBool aTopLevel)
    1: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aOldChannel);
28236:   NS_ENSURE_ARG(aNewChannel);
18819: 
24401:   // ignore internal redirects
24401:   if (aFlags & nsIChannelEventSink::REDIRECT_INTERNAL)
24401:     return NS_OK;
24401: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIURI> oldURI, newURI;
    1:   rv = aOldChannel->GetURI(getter_AddRefs(oldURI));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = aNewChannel->GetURI(getter_AddRefs(newURI));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCString oldSpec, newSpec;
    1:   rv = oldURI->GetSpec(oldSpec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = newURI->GetSpec(newSpec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (mRecentRedirects.Count() > RECENT_EVENT_QUEUE_MAX_LENGTH) {
    1:     // expire out-of-date ones
    1:     PRInt64 threshold = PR_Now() - RECENT_EVENT_THRESHOLD;
    1:     mRecentRedirects.Enumerate(ExpireNonrecentRedirects,
 3233:                                reinterpret_cast<void*>(&threshold));
    1:   }
    1: 
    1:   RedirectInfo info;
    1: 
    1:   // remove any old entries for this redirect destination
    1:   if (mRecentRedirects.Get(newSpec, &info))
    1:     mRecentRedirects.Remove(newSpec);
    1: 
    1:   // save the new redirect info
    1:   info.mSourceURI = oldSpec;
    1:   info.mTimeCreated = PR_Now();
    1:   if (aFlags & nsIChannelEventSink::REDIRECT_TEMPORARY)
    1:     info.mType = TRANSITION_REDIRECT_TEMPORARY;
    1:   else
    1:     info.mType = TRANSITION_REDIRECT_PERMANENT;
    1:   mRecentRedirects.Put(newSpec, info);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 9621: // nsIDownloadHistory **********************************************************
 9621: 
 9621: NS_IMETHODIMP
 9621: nsNavHistory::AddDownload(nsIURI* aSource, nsIURI* aReferrer,
 9621:                           PRTime aStartTime)
 9621: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aSource);
18819: 
22937:   // don't add when history is disabled and silently fail
22937:   if (IsHistoryDisabled())
22937:     return NS_OK;
22937: 
 9689:   PRInt64 visitID;
 9621:   return AddVisit(aSource, aStartTime, aReferrer, TRANSITION_DOWNLOAD, PR_FALSE,
 9689:                   0, &visitID);
 9621: }
 9621: 
16749: // nsPIPlacesDatabase **********************************************************
16749: 
16749: NS_IMETHODIMP
16749: nsNavHistory::GetDBConnection(mozIStorageConnection **_DBConnection)
16749: {
28236:   NS_ENSURE_ARG_POINTER(_DBConnection);
16749:   NS_ADDREF(*_DBConnection = mDBConn);
16749:   return NS_OK;
16749: }
16749: 
33829: NS_HIDDEN_(nsresult)
21642: nsNavHistory::FinalizeInternalStatements()
21642: {
21642:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
21642: 
21642:   // nsNavHistory
21642:   nsresult rv = FinalizeStatements();
21642:   NS_ENSURE_SUCCESS(rv, rv);
21642: 
21642:   // nsNavBookmarks
21642:   nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
21642:   NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
21642:   rv = bookmarks->FinalizeStatements();
21642:   NS_ENSURE_SUCCESS(rv, rv);
21642: 
21642:   // nsAnnotationService
21642:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
21642:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
21642:   rv = annosvc->FinalizeStatements();
21642:   NS_ENSURE_SUCCESS(rv, rv);
21642: 
21642:   // nsFaviconService
21642:   nsFaviconService* iconsvc = nsFaviconService::GetFaviconService();
21642:   NS_ENSURE_TRUE(iconsvc, NS_ERROR_OUT_OF_MEMORY);
21642:   rv = iconsvc->FinalizeStatements();
21642:   NS_ENSURE_SUCCESS(rv, rv);
21642: 
21642:   return NS_OK;
21642: }
21642: 
33829: // nsPIPlacesHistoryListenersNotifier ******************************************
33829: 
21642: NS_IMETHODIMP
33829: nsNavHistory::NotifyOnPageExpired(nsIURI *aURI, PRTime aVisitTime,
33829:                                   PRBool aWholeEntry)
33829: {
33829:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavHistoryObserver,
33829:                       OnPageExpired(aURI, aVisitTime, aWholeEntry));
33829:   if (aWholeEntry) {
33829:     // Notify our observers that the URI has been removed.
33829:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
35298:                         nsINavHistoryObserver, OnDeleteURI(aURI));
33829:   }
33829: 
33829:   return NS_OK;
33829: }
33829: 
33829: // nsIObserver *****************************************************************
33829: 
33829: NS_IMETHODIMP
33829: nsNavHistory::Observe(nsISupports *aSubject, const char *aTopic,
33829:                     const PRUnichar *aData)
33829: {
33829:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
33829: 
33829:   if (strcmp(aTopic, gXpcomShutdown) == 0) {
24787:     nsCOMPtr<nsIObserverService> os =
24787:       do_GetService("@mozilla.org/observer-service;1");
33829:     if (os) {
35411:       os->RemoveObserver(this, gAutoCompleteFeedback);
33829:       os->RemoveObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC);
33829:       os->RemoveObserver(this, gIdleDaily);
33829:       os->RemoveObserver(this, gXpcomShutdown);
33829:     }
33829: 
33829:     // If xpcom-shutdown is called in the same scope as the service init, we
33829:     // should Immediately serve topics we generated, this way they won't try to
33829:     // access the database later.
24787:     nsCOMPtr<nsISimpleEnumerator> e;
32454:     nsresult rv = os->EnumerateObservers(PLACES_INIT_COMPLETE_TOPIC,
24787:                                          getter_AddRefs(e));
24787:     if (NS_SUCCEEDED(rv) && e) {
24787:       nsCOMPtr<nsIObserver> observer;
24787:       PRBool loop = PR_TRUE;
24787:       while(NS_SUCCEEDED(e->HasMoreElements(&loop)) && loop)
24787:       {
24787:         e->GetNext(getter_AddRefs(observer));
24787:         rv = observer->Observe(observer,
32454:                                PLACES_INIT_COMPLETE_TOPIC,
24787:                                nsnull);
24787:       }
24787:     }
24787: 
    1:     nsCOMPtr<nsIPrefService> prefService =
33829:       do_GetService(NS_PREFSERVICE_CONTRACTID);
33829:     if (prefService)
    1:       prefService->SavePrefFile(nsnull);
    1: 
33704:     // Start shutdown expiration.
33704:     mExpire->OnQuit();
33829: 
33829: #ifdef LAZY_ADD
33829:     // Commit all pending lazy messages.
33829:     CommitLazyMessages(PR_TRUE);
33829: 
33829:     // Kill lazy timer or it could fire later when statements won't be valid
33829:     // anymore.
33829:     if (mLazyTimer) {
33829:       mLazyTimer->Cancel();
33829:       mLazyTimer = 0;
33829:     }
33829: #endif
33829: 
33829:     // Finalize all statements.
33829:     rv = FinalizeInternalStatements();
33829:     NS_ENSURE_SUCCESS(rv, rv);
33829: 
33829:     // NOTE: We don't close the connection because the sync service could still
33829:     // need it for a final flush.
24566:   }
18849: #ifdef MOZ_XUL
24566:   else if (strcmp(aTopic, gAutoCompleteFeedback) == 0) {
12214:     nsCOMPtr<nsIAutoCompleteInput> input = do_QueryInterface(aSubject);
12214:     if (!input)
12214:       return NS_OK;
12214: 
12214:     nsCOMPtr<nsIAutoCompletePopup> popup;
12214:     input->GetPopup(getter_AddRefs(popup));
12214:     if (!popup)
12214:       return NS_OK;
12214: 
12214:     nsCOMPtr<nsIAutoCompleteController> controller;
12214:     input->GetController(getter_AddRefs(controller));
12214:     if (!controller)
12214:       return NS_OK;
12214: 
12214:     // Don't bother if the popup is closed
12214:     PRBool open;
12214:     nsresult rv = popup->GetPopupOpen(&open);
12214:     NS_ENSURE_SUCCESS(rv, rv);
12214:     if (!open)
12214:       return NS_OK;
12214: 
12214:     // Ignore if nothing selected from the popup
12214:     PRInt32 selectedIndex;
12214:     rv = popup->GetSelectedIndex(&selectedIndex);
12214:     NS_ENSURE_SUCCESS(rv, rv);
12214:     if (selectedIndex == -1)
12214:       return NS_OK;
12214: 
12214:     rv = AutoCompleteFeedback(selectedIndex, controller);
12214:     NS_ENSURE_SUCCESS(rv, rv);
24566:   }
18849: #endif
24566:   else if (strcmp(aTopic, "nsPref:changed") == 0) {
 8761:     PRInt32 oldDaysMin = mExpireDaysMin;
 8761:     PRInt32 oldDaysMax = mExpireDaysMax;
 8761:     PRInt32 oldVisits = mExpireSites;
10669:     LoadPrefs(PR_FALSE);
 8761:     if (oldDaysMin != mExpireDaysMin || oldDaysMax != mExpireDaysMax ||
 8761:         oldVisits != mExpireSites)
33704:       mExpire->OnExpirationChanged();
24566:   }
24756:   else if (strcmp(aTopic, gIdleDaily) == 0) {
28513:     // Ensure our connection is still alive.  The idle-daily observer is removed
28513:     // on xpcom-shutdown, but we could have closed the connection earlier due
28513:     // to errors or during normal shutdown process.
28513:     NS_ENSURE_TRUE(mDBConn, NS_OK);
28513: 
32454:     (void)DecayFrecency();
32454:     (void)VacuumDatabase();
32454:   }
32454:   else if (strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC) == 0) {
32454:     if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).Equals(aData)) {
34517: #ifdef LAZY_ADD
34517:       // Commit all lazy messages in order to protect against edge cases where a
34517:       // lazy message which is not allowed in private browsing mode has been
34517:       // added before entering the private browsing mode, and is going to be
34517:       // scheduled to be processed after entering the private browsing mode.
34517:       CommitLazyMessages();
34517: #endif
34517: 
32454:       mInPrivateBrowsing = PR_TRUE;
32454:     }
32454:     else if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(aData)) {
34517: #ifdef LAZY_ADD
34517:       // Commit all lazy messages in order to protect against edge cases where a
34517:       // lazy message which should be processed in private browsing mode has been
34517:       // added before leaving the private browsing mode, and is going to be
34517:       // scheduled to be processed after leaving the private browsing mode.
34517:       CommitLazyMessages();
34517: #endif
34517: 
32454:       mInPrivateBrowsing = PR_FALSE;
32454:     }
32454:   }
32454:   else if (strcmp(aTopic, PLACES_INIT_COMPLETE_TOPIC) == 0) {
32454:     nsCOMPtr<nsIObserverService> os =
32454:       do_GetService("@mozilla.org/observer-service;1");
32454:     NS_ENSURE_TRUE(os, NS_ERROR_FAILURE);
32454:     (void)os->RemoveObserver(this, PLACES_INIT_COMPLETE_TOPIC);
32454: 
32454:     // This code is only called if we've either imported or done a migration
32454:     // from a pre-frecency build, so we will calculate all their frecencies.
27190:     (void)FixInvalidFrecencies();
32454:   }
32454: 
32454:   return NS_OK;
32454: }
32454: 
32454: NS_HIDDEN_(nsresult)
32454: nsNavHistory::VacuumDatabase()
32454: {
32454:   // SQLite cannot give us a real value for fragmentation percentage,
32454:   // we could analyze the database file page by page, and count fragmented
32454:   // space, but that would be slow and not maintainable across different SQLite
32454:   // versions.
32454:   // For this reason we just take a guess using the freelist count.
32454:   // This way we know how much pages are unused, but we don't know anything
32454:   // about fragmentation.
32454:   // This ratio is used in conjunction with a time pref to avoid vacuuming too
32454:   // often or too rarely.
32454: 
32454:   PRInt32 lastVacuumPref;
32454:   PRInt64 lastVacuumTime = 0;
32454:   nsCOMPtr<nsIPrefBranch> prefSvc =
32454:     do_GetService("@mozilla.org/preferences-service;1");
32454:   NS_ENSURE_TRUE(prefSvc, NS_ERROR_OUT_OF_MEMORY);
32454:   if (NS_SUCCEEDED(prefSvc->GetIntPref(PREF_LAST_VACUUM, &lastVacuumPref))) {
32454:     // Value are seconds till epoch, convert it to microseconds.
32454:     lastVacuumTime = (PRInt64)lastVacuumPref * PR_USEC_PER_SEC;
32454:   }
32454: 
32454:   nsresult rv;
32454:   float freePagesRatio = 0;
32454:   if (!lastVacuumTime ||
32454:       (lastVacuumTime < (PR_Now() - MIN_TIME_BEFORE_VACUUM) &&
32454:        lastVacuumTime > (PR_Now() - MAX_TIME_BEFORE_VACUUM))) {
32454:     // This is the first vacuum, or we are in the timeframe where vacuum could
32454:     // happen.  Calculate the vacuum ratio and vacuum if it is less then
32454:     // threshold.
32454:     nsCOMPtr<mozIStorageStatement> statement;
32454:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING("PRAGMA page_count"),
32454:                                   getter_AddRefs(statement));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454:     PRBool hasResult = PR_FALSE;
32454:     rv = statement->ExecuteStep(&hasResult);
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454:     NS_ENSURE_TRUE(hasResult, NS_ERROR_FAILURE);
32454:     PRInt32 pageCount = statement->AsInt32(0);
32454: 
32454:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING("PRAGMA freelist_count"),
32454:                                   getter_AddRefs(statement));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454:     hasResult = PR_FALSE;
32454:     rv = statement->ExecuteStep(&hasResult);
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454:     NS_ENSURE_TRUE(hasResult, NS_ERROR_FAILURE);
32454:     PRInt32 freelistCount = statement->AsInt32(0);
32454: 
32454:     freePagesRatio = (float)(freelistCount / pageCount);
32454:   }
32454:   
32454:   if (freePagesRatio > VACUUM_FREEPAGES_THRESHOLD ||
32454:       lastVacuumTime < (PR_Now() - MAX_TIME_BEFORE_VACUUM)) {
32454:     // We vacuum in 2 cases:
32454:     //  - We are in the valid vacuum timeframe and vacuum ratio is high.
32454:     //  - Last vacuum has been executed a lot of time ago.
32454: 
32454:     // Notify we are about to vacuum.  This is mostly for testability.
32454:     nsCOMPtr<nsIObserverService> observerService =
32454:       do_GetService("@mozilla.org/observer-service;1", &rv);
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454:     rv = observerService->NotifyObservers(nsnull,
32454:                                           PLACES_VACUUM_STARTING_TOPIC,
32454:                                           nsnull);
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:     // Actually vacuuming a database is a slow operation, since it could take
32454:     // seconds.  Part of the time is spent in updating the journal file on disk
32454:     // and this is particularly bad on devices with slow I/O.  Temporary
32454:     // moving the journal to memory could increase a bit the possibility of
32454:     // corruption if we crash during this time, but makes the process really
32454:     // faster.
32454:     nsCOMPtr<mozIStorageStatement> journalToMemory;
32454:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
32454:         "PRAGMA journal_mode = MEMORY"),
32454:       getter_AddRefs(journalToMemory));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:     nsCOMPtr<mozIStorageStatement> vacuum;
32454:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING("VACUUM"),
32454:                                   getter_AddRefs(vacuum));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:     nsCOMPtr<mozIStorageStatement> journalToDefault;
32454:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
32454:         "PRAGMA journal_mode = " DEFAULT_JOURNAL_MODE),
32454:       getter_AddRefs(journalToDefault));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:     mozIStorageStatement *stmts[] = {
32454:       journalToMemory,
32454:       vacuum,
32454:       journalToDefault
32454:     };
32454:     nsCOMPtr<mozIStoragePendingStatement> ps;
32454:     rv = mDBConn->ExecuteAsync(stmts, NS_ARRAY_LENGTH(stmts), nsnull,
32454:                                getter_AddRefs(ps));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:     rv = prefSvc->SetIntPref(PREF_LAST_VACUUM,
32454:                              (PRInt32)(PR_Now() / PR_USEC_PER_SEC));
32454:     NS_ENSURE_SUCCESS(rv, rv);
32454:   }
32454: 
32454:   return NS_OK;
32454: }
32454: 
32454: NS_HIDDEN_(nsresult)
32454: nsNavHistory::DecayFrecency()
32454: {
32454:   // Update frecency values.
32454:   nsresult rv = FixInvalidFrecencies();
32454:   NS_ENSURE_SUCCESS(rv, rv);
26145: 
26145:   // Globally decay places frecency rankings to estimate reduced frecency
26145:   // values of pages that haven't been visited for a while, i.e., they do
26145:   // not get an updated frecency. We directly modify moz_places to avoid
26145:   // bringing the whole database into places_temp through places_view. A
26145:   // scaling factor of .975 results in .5 the original value after 28 days.
26145:   nsCOMPtr<mozIStorageStatement> decayFrecency;
32454:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
26145:       "UPDATE moz_places SET frecency = ROUND(frecency * .975) "
26145:       "WHERE frecency > 0"),
26145:     getter_AddRefs(decayFrecency));
32454:   NS_ENSURE_SUCCESS(rv, rv);
26145: 
26145:   // Decay potentially unused adaptive entries (e.g. those that are at 1)
32454:   // to allow better chances for new entries that will start at 1.
26145:   nsCOMPtr<mozIStorageStatement> decayAdaptive;
26145:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
26145:       "UPDATE moz_inputhistory SET use_count = use_count * .975"),
26145:     getter_AddRefs(decayAdaptive));
32454:   NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:   // Delete any adaptive entries that won't help in ordering anymore.
26145:   nsCOMPtr<mozIStorageStatement> deleteAdaptive;
26145:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
26145:       "DELETE FROM moz_inputhistory WHERE use_count < .01"),
26145:     getter_AddRefs(deleteAdaptive));
32454:   NS_ENSURE_SUCCESS(rv, rv);
32454: 
26145:   mozIStorageStatement *stmts[] = {
26145:     decayFrecency,
26145:     decayAdaptive,
26145:     deleteAdaptive
26145:   };
32454:   nsCOMPtr<mozIStoragePendingStatement> ps;
26145:   rv = mDBConn->ExecuteAsync(stmts, NS_ARRAY_LENGTH(stmts), nsnull,
26145:                              getter_AddRefs(ps));
32454:   NS_ENSURE_SUCCESS(rv, rv);
32454: 
32454:   return NS_OK;
32454: }
    1: 
    1: // Lazy stuff ******************************************************************
    1: 
    1: #ifdef LAZY_ADD
    1: 
    1: // nsNavHistory::AddLazyLoadFaviconMessage
    1: 
    1: nsresult
    1: nsNavHistory::AddLazyLoadFaviconMessage(nsIURI* aPage, nsIURI* aFavicon,
    1:                                         PRBool aForceReload)
    1: {
    1:   LazyMessage message;
    1:   nsresult rv = message.Init(LazyMessage::Type_Favicon, aPage);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = aFavicon->Clone(getter_AddRefs(message.favicon));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   message.alwaysLoadFavicon = aForceReload;
    1:   return AddLazyMessage(message);
    1: }
    1: 
    1: 
    1: // nsNavHistory::StartLazyTimer
    1: //
    1: //    This schedules flushing of the lazy message queue for the future.
    1: //
    1: //    If we already have timer set, we canel it and schedule a new timer in
    1: //    the future. This saves you from having to wait if you open a bunch of
    1: //    pages in a row. However, we don't want to defer too long, so we'll only
    1: //    push it back MAX_LAZY_TIMER_DEFERMENTS times. After that we always
    1: //    let the timer go the next time.
    1: 
    1: nsresult
    1: nsNavHistory::StartLazyTimer()
    1: {
    1:   if (! mLazyTimer) {
    1:     mLazyTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     if (! mLazyTimer)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   } else {
    1:     if (mLazyTimerSet) {
    1:       if (mLazyTimerDeferments >= MAX_LAZY_TIMER_DEFERMENTS) {
    1:         // already set and we don't want to push it back any later, use that one
    1:         return NS_OK;
    1:       } else {
    1:         // push back the active timer
    1:         mLazyTimer->Cancel();
    1:         mLazyTimerDeferments ++;
    1:       }
    1:     }
    1:   }
    1:   nsresult rv = mLazyTimer->InitWithFuncCallback(LazyTimerCallback, this,
    1:                                                  LAZY_MESSAGE_TIMEOUT,
    1:                                                  nsITimer::TYPE_ONE_SHOT);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   mLazyTimerSet = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::AddLazyMessage
    1: 
    1: nsresult
    1: nsNavHistory::AddLazyMessage(const LazyMessage& aMessage)
    1: {
    1:   if (! mLazyMessages.AppendElement(aMessage))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   return StartLazyTimer();
    1: }
    1: 
    1: 
    1: // nsNavHistory::LazyTimerCallback
    1: 
    1: void // static
    1: nsNavHistory::LazyTimerCallback(nsITimer* aTimer, void* aClosure)
    1: {
 3233:   nsNavHistory* that = static_cast<nsNavHistory*>(aClosure);
    1:   that->mLazyTimerSet = PR_FALSE;
    1:   that->mLazyTimerDeferments = 0;
    1:   that->CommitLazyMessages();
    1: }
    1: 
    1: // nsNavHistory::CommitLazyMessages
    1: 
33829: NS_HIDDEN_(void)
33829: nsNavHistory::CommitLazyMessages(PRBool aIsShutdown)
    1: {
    1:   mozStorageTransaction transaction(mDBConn, PR_TRUE);
    1:   for (PRUint32 i = 0; i < mLazyMessages.Length(); i ++) {
    1:     LazyMessage& message = mLazyMessages[i];
    1:     switch (message.type) {
    1:       case LazyMessage::Type_AddURI:
    1:         AddURIInternal(message.uri, message.time, message.isRedirect,
    1:                        message.isToplevel, message.referrer);
    1:         break;
    1:       case LazyMessage::Type_Title:
 4037:         SetPageTitleInternal(message.uri, message.title);
    1:         break;
    1:       case LazyMessage::Type_Favicon: {
33829:         // Favicons cannot use async channels after xpcom-shutdown.
33829:         if (aIsShutdown)
33829:           continue;
    1:         nsFaviconService* faviconService = nsFaviconService::GetFaviconService();
    1:         if (faviconService) {
    1:           faviconService->DoSetAndLoadFaviconForPage(message.uri,
    1:                                                      message.favicon,
    1:                                                      message.alwaysLoadFavicon);
    1:         }
    1:         break;
    1:       }
    1:       default:
    1:         NS_NOTREACHED("Invalid lazy message type");
    1:     }
    1:   }
    1:   mLazyMessages.Clear();
    1: }
    1: #endif // LAZY_ADD
    1: 
    1: 
    1: // Query stuff *****************************************************************
    1: 
13310: // Helper class for QueryToSelectClause
13310: //
13310: // This class helps to build part of the WHERE clause. It supports 
13310: // multiple queries by appending the query index to the parameter name. 
13310: // For the query with index 0 the parameter name is not altered what
13310: // allows using this parameter in other situations (see SelectAsSite). 
13310: 
13310: class ConditionBuilder
13310: {
13310: public:
13310: 
13310:   ConditionBuilder(PRInt32 aQueryIndex): mQueryIndex(aQueryIndex)
13310:   { }
13310: 
13310:   ConditionBuilder& Condition(const char* aStr)
13310:   {
13310:     if (!mClause.IsEmpty())
13310:       mClause.AppendLiteral(" AND ");
13310:     Str(aStr);
13310:     return *this;
13310:   }
13310: 
13310:   ConditionBuilder& Str(const char* aStr)
13310:   {
13310:     mClause.Append(' ');
13310:     mClause.Append(aStr);
13310:     mClause.Append(' ');
13310:     return *this;
13310:   }
13310: 
13310:   ConditionBuilder& Param(const char* aParam)
13310:   {
13310:     mClause.Append(' ');
13310:     if (!mQueryIndex)
13310:       mClause.Append(aParam);
13310:     else
13310:       mClause += nsPrintfCString("%s%d", aParam, mQueryIndex);
13310: 
13310:     mClause.Append(' ');
13310:     return *this;
13310:   }
13310: 
13310:   void GetClauseString(nsCString& aResult) 
13310:   {
13310:     aResult = mClause;
13310:   }
13310: 
13310: private:
13310: 
13310:   PRInt32 mQueryIndex;
13310:   nsCString mClause;
13310: };
13310: 
    1: 
    1: // nsNavHistory::QueryToSelectClause
    1: //
13310: //    THE BEHAVIOR SHOULD BE IN SYNC WITH BindQueryClauseParameters
    1: //
    1: //    I don't check return values from the query object getters because there's
    1: //    no way for those to fail.
    1: 
    1: nsresult
    1: nsNavHistory::QueryToSelectClause(nsNavHistoryQuery* aQuery, // const
  809:                                   nsNavHistoryQueryOptions* aOptions,
13310:                                   PRInt32 aQueryIndex,
13310:                                   nsCString* aClause)
    1: {
    1:   PRBool hasIt;
    1: 
13310:   ConditionBuilder clause(aQueryIndex);
    1: 
    1:   // begin time
13310:   if (NS_SUCCEEDED(aQuery->GetHasBeginTime(&hasIt)) && hasIt) 
13310:     clause.Condition("v.visit_date >=").Param(":begin_time");
    1: 
    1:   // end time
13310:   if (NS_SUCCEEDED(aQuery->GetHasEndTime(&hasIt)) && hasIt)
13310:     clause.Condition("v.visit_date <=").Param(":end_time");
    1: 
    1:   // search terms FIXME
    1: 
    1:   // min and max visit count
13310:   if (aQuery->MinVisits() >= 0)
13310:     clause.Condition("h.visit_count >=").Param(":min_visits");
13310: 
13310:   if (aQuery->MaxVisits() >= 0)
13310:     clause.Condition("h.visit_count <=").Param(":max_visits");
13310:   
13310:   // only bookmarked, has no affect on bookmarks-only queries
 5909:   if (aOptions->QueryType() != nsINavHistoryQueryOptions::QUERY_TYPE_BOOKMARKS &&
13310:       aQuery->OnlyBookmarked())
13310:     clause.Condition("EXISTS (SELECT b.fk FROM moz_bookmarks b WHERE b.type = ")
13310:           .Str(nsPrintfCString("%d", nsNavBookmarks::TYPE_BOOKMARK).get())
13310:           .Str("AND b.fk = h.id)");
    1: 
    1:   // domain
    1:   if (NS_SUCCEEDED(aQuery->GetHasDomain(&hasIt)) && hasIt) {
    1:     PRBool domainIsHost = PR_FALSE;
    1:     aQuery->GetDomainIsHost(&domainIsHost);
13310:     if (domainIsHost)
13310:       clause.Condition("h.rev_host =").Param(":domain_lower");
13310:     else
    1:       // see domain setting in BindQueryClauseParameters for why we do this
13310:       clause.Condition("h.rev_host >=").Param(":domain_lower")
13310:             .Condition("h.rev_host <").Param(":domain_upper");
    1:   }
    1: 
    1:   // URI
    1:   if (NS_SUCCEEDED(aQuery->GetHasUri(&hasIt)) && hasIt) {
33458:     if (aQuery->UriIsPrefix()) {
33458:       clause.Condition("h.url >= ").Param(":uri")
33458:             .Condition("h.url <= ").Param(":uri_upper");
33458:     }
13310:     else
13310:       clause.Condition("h.url =").Param(":uri");
    1:   }
    1: 
    1:   // annotation
    1:   aQuery->GetHasAnnotation(&hasIt);
    1:   if (hasIt) {
13310:     clause.Condition("");
    1:     if (aQuery->AnnotationIsNot())
13310:       clause.Str("NOT");
13310:     clause.Str(
13310:       "EXISTS "
13310:         "(SELECT h.id "
13310:          "FROM moz_annos anno "
13310:          "JOIN moz_anno_attributes annoname "
13310:            "ON anno.anno_attribute_id = annoname.id "
13310:          "WHERE anno.place_id = h.id "
13310:            "AND annoname.name = ").Param(":anno").Str(")");
    1:     // annotation-based queries don't get the common conditions, so you get
    1:     // all URLs with that annotation
    1:   }
    1: 
27981:   // tags
27981:   const nsTArray<nsString> &tags = aQuery->Tags();
27981:   if (tags.Length() > 0) {
27981:     clause.Condition("h.id");
27981:     if (aQuery->TagsAreNot())
27981:       clause.Str("NOT");
27981:     clause.Str(
27981:       "IN "
27981:         "(SELECT bms.fk "
27981:          "FROM moz_bookmarks bms "
27981:          "JOIN moz_bookmarks tags ON bms.parent = tags.id "
27981:          "WHERE tags.parent =").
27981:            Param(":tags_folder").
27981:            Str("AND tags.title IN (");
27981:     for (PRUint32 i = 0; i < tags.Length(); ++i) {
27981:       nsPrintfCString param(":tag%d_", i);
27981:       clause.Param(param.get());
27981:       if (i < tags.Length() - 1)
27981:         clause.Str(",");
27981:     }
27981:     clause.Str(")");
27981:     if (!aQuery->TagsAreNot())
27981:       clause.Str("GROUP BY bms.fk HAVING count(*) >=").Param(":tag_count");
27981:     clause.Str(")");
27981:   }
27981: 
14224:   // parent parameter is used in tag contents queries.
14224:   // Only one folder should be defined for them.
14224:   if (aOptions->ResultType() == nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS &&
14224:       aQuery->Folders().Length() == 1) {
14224:     clause.Condition("b.parent =").Param(":parent");
14224:   }
14224: 
13310:   clause.GetClauseString(*aClause);
    1:   return NS_OK;
    1: }
    1: 
13310: // Helper class for BindQueryClauseParameters
13310: //
13310: // This class converts parameter names to parameter indexes. It supports 
13310: // multiple queries by appending the query index to the parameter name. 
13310: // For the query with index 0 the parameter name is not altered what
13310: // allows using this parameter in other situations (see SelectAsSite). 
13310: 
13310: class IndexGetter
13310: {
13310: public:
13310:   IndexGetter(PRInt32 aQueryIndex, mozIStorageStatement* aStatement) : 
13310:     mQueryIndex(aQueryIndex), mStatement(aStatement)
13310:   {
13310:     mResult = NS_OK;
13310:   }
13310: 
13310:   PRUint32 For(const char* aName) 
13310:   {
13310:     PRUint32 index;
13310: 
13310:     // Do not execute if we already had an error
13310:     if (NS_SUCCEEDED(mResult)) {
13310:       if (!mQueryIndex)
13310:         mResult = mStatement->GetParameterIndex(nsCAutoString(aName), &index);
13310:       else
13310:         mResult = mStatement->GetParameterIndex(
13310:                       nsPrintfCString("%s%d", aName, mQueryIndex), &index);
13310:     }
13310: 
13310:     if (NS_SUCCEEDED(mResult))
13310:       return index;
13310: 
13310:     return -1; // Invalid index
13310:   }
13310: 
13310:   nsresult Result() 
13310:   {
13310:     return mResult;
13310:   }
13310: 
13310: private:
13310:   PRInt32 mQueryIndex;
13310:   mozIStorageStatement* mStatement;
13310:   nsresult mResult;
13310: };
    1: 
    1: // nsNavHistory::BindQueryClauseParameters
    1: //
13310: //    THE BEHAVIOR SHOULD BE IN SYNC WITH QueryToSelectClause
    1: 
    1: nsresult
    1: nsNavHistory::BindQueryClauseParameters(mozIStorageStatement* statement,
13310:                                         PRInt32 aQueryIndex,
    1:                                         nsNavHistoryQuery* aQuery, // const
13310:                                         nsNavHistoryQueryOptions* aOptions)
    1: {
    1:   nsresult rv;
    1: 
    1:   PRBool hasIt;
13310:   IndexGetter index(aQueryIndex, statement);
    1: 
    1:   // begin time
    1:   if (NS_SUCCEEDED(aQuery->GetHasBeginTime(&hasIt)) && hasIt) {
    1:     PRTime time = NormalizeTime(aQuery->BeginTimeReference(),
    1:                                 aQuery->BeginTime());
28260:     rv = statement->BindInt64Parameter(index.For("begin_time"), time);
13310:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // end time
    1:   if (NS_SUCCEEDED(aQuery->GetHasEndTime(&hasIt)) && hasIt) {
    1:     PRTime time = NormalizeTime(aQuery->EndTimeReference(),
    1:                                 aQuery->EndTime());
28260:     rv = statement->BindInt64Parameter(index.For("end_time"), time);
13310:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // search terms FIXME
    1: 
    1:   // min and max visit count
    1:   PRInt32 visits = aQuery->MinVisits();
    1:   if (visits >= 0) {
28260:     rv = statement->BindInt32Parameter(index.For("min_visits"), visits);
13310:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   visits = aQuery->MaxVisits();
    1:   if (visits >= 0) {
28260:     rv = statement->BindInt32Parameter(index.For("max_visits"), visits);
13310:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // domain (see GetReversedHostname for more info on reversed host names)
    1:   if (NS_SUCCEEDED(aQuery->GetHasDomain(&hasIt)) && hasIt) {
    1:     nsString revDomain;
    1:     GetReversedHostname(NS_ConvertUTF8toUTF16(aQuery->Domain()), revDomain);
    1: 
    1:     if (aQuery->DomainIsHost()) {
28260:       rv = statement->BindStringParameter(index.For("domain_lower"), revDomain);
13310:       NS_ENSURE_SUCCESS(rv, rv);
    1:     } else {
    1:       // for "mozilla.org" do query >= "gro.allizom." AND < "gro.allizom/"
    1:       // which will get everything starting with "gro.allizom." while using the
    1:       // index (using SUBSTRING() causes indexes to be discarded).
    1:       NS_ASSERTION(revDomain[revDomain.Length() - 1] == '.', "Invalid rev. host");
28260:       rv = statement->BindStringParameter(index.For("domain_lower"), revDomain);
13310:       NS_ENSURE_SUCCESS(rv, rv);
    1:       revDomain.Truncate(revDomain.Length() - 1);
    1:       revDomain.Append(PRUnichar('/'));
28260:       rv = statement->BindStringParameter(index.For("domain_upper"), revDomain);
13310:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   // URI
33458:   if (aQuery->Uri()) {
28260:     BindStatementURI(statement, index.For("uri"), aQuery->Uri());
33458:     if (aQuery->UriIsPrefix()) {
33458:       nsCAutoString uriString;
33458:       aQuery->Uri()->GetSpec(uriString);
33458:       uriString.Append(char(0x7F)); // MAX_UTF8
33458:       rv = statement->BindUTF8StringParameter(index.For("uri_upper"),
33458:         StringHead(uriString, HISTORY_URI_LENGTH_MAX));
33458:       NS_ENSURE_SUCCESS(rv, rv);
33458:     }
33458:   }
    1: 
    1:   // annotation
33458:   if (!aQuery->Annotation().IsEmpty()) {
28260:     rv = statement->BindUTF8StringParameter(index.For("anno"), 
    1:                                             aQuery->Annotation());
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
27981:   // tags
27981:   const nsTArray<nsString> &tags = aQuery->Tags();
27981:   if (tags.Length() > 0) {
27981:     for (PRUint32 i = 0; i < tags.Length(); ++i) {
28260:       nsPrintfCString param("tag%d_", i);
27981:       NS_ConvertUTF16toUTF8 tag(tags[i]);
27981:       rv = statement->BindUTF8StringParameter(index.For(param.get()), tag);
27981:       NS_ENSURE_SUCCESS(rv, rv);
27981:     }
27981:     PRInt64 tagsFolder = GetTagsFolder();
28260:     rv = statement->BindInt64Parameter(index.For("tags_folder"), tagsFolder);
27981:     NS_ENSURE_SUCCESS(rv, rv);
27981:     if (!aQuery->TagsAreNot()) {
28260:       rv = statement->BindInt32Parameter(index.For("tag_count"), tags.Length());
27981:       NS_ENSURE_SUCCESS(rv, rv);
27981:     }
27981:   }
27981: 
14224:   // parent parameter
14224:   if (aOptions->ResultType() == nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS &&
14224:       aQuery->Folders().Length() == 1) {
28260:     rv = statement->BindInt64Parameter(index.For("parent"),
14224:                                        aQuery->Folders()[0]);
14224:     NS_ENSURE_SUCCESS(rv, rv);
14224:   }
14224: 
13310:   NS_ENSURE_SUCCESS(index.Result(), index.Result());
13310: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::ResultsAsList
    1: //
    1: 
    1: nsresult
    1: nsNavHistory::ResultsAsList(mozIStorageStatement* statement,
    1:                             nsNavHistoryQueryOptions* aOptions,
    1:                             nsCOMArray<nsNavHistoryResultNode>* aResults)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<mozIStorageValueArray> row = do_QueryInterface(statement, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMore = PR_FALSE;
    1:   while (NS_SUCCEEDED(statement->ExecuteStep(&hasMore)) && hasMore) {
 7025:     nsRefPtr<nsNavHistoryResultNode> result;
    1:     rv = RowToResult(row, aOptions, getter_AddRefs(result));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     aResults->AppendObject(result);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: static PRInt64
    1: GetAgeInDays(PRTime aNormalizedNow, PRTime aDate)
    1: {
    1:   PRTime dateMidnight = NormalizeTimeRelativeToday(aDate);
 2800:   // if the visit time is in the future
 2800:   // treat as "today" see bug #385867
 2800:   if (dateMidnight > aNormalizedNow)
 2800:     return 0;
 2800:   else
    1:     return ((aNormalizedNow - dateMidnight) / USECS_PER_DAY);
    1: }
    1: 
 6822: const PRInt64 UNDEFINED_URN_VALUE = -1;
 2597: 
 2597: // Create a urn (like
 2597: // urn:places-persist:place:group=0&group=1&sort=1&type=1,,%28local%20files%29)
 2597: // to be used to persist the open state of this container in localstore.rdf
 2597: nsresult
 2597: CreatePlacesPersistURN(nsNavHistoryQueryResultNode *aResultNode, 
 6822:                       PRInt64 aValue, const nsCString& aTitle, nsCString& aURN)
 2597: {
 2597:   nsCAutoString uri;
 2597:   nsresult rv = aResultNode->GetUri(uri);
 2597:   NS_ENSURE_SUCCESS(rv, rv);
 2597: 
 2597:   aURN.Assign(NS_LITERAL_CSTRING("urn:places-persist:"));
 2597:   aURN.Append(uri);
 2597: 
 2597:   aURN.Append(NS_LITERAL_CSTRING(","));
 6822:   if (aValue != UNDEFINED_URN_VALUE)
 6822:     aURN.AppendInt(aValue);
 2597: 
 2597:   aURN.Append(NS_LITERAL_CSTRING(","));
 2597:   if (!aTitle.IsEmpty()) {
 2597:     nsCAutoString escapedTitle;
 2597:     PRBool success = NS_Escape(aTitle, escapedTitle, url_XAlphas);
 2597:     NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
 2597:     aURN.Append(escapedTitle);
 2597:   }
 2597: 
 2597:   return NS_OK;
 2597: }
 2597: 
 6822: PRInt64
 8193: nsNavHistory::GetTagsFolder()
 6822: {
 8193:   // cache our tags folder
 6822:   // note, we can't do this in nsNavHistory::Init(), 
 6822:   // as getting the bookmarks service would initialize it.
 8193:   if (mTagsFolder == -1) {
 6822:     nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
 6822:     NS_ENSURE_TRUE(bookmarks, -1);
 6822:     
 8193:     nsresult rv = bookmarks->GetTagsFolder(&mTagsFolder);
 6822:     NS_ENSURE_SUCCESS(rv, -1);
 6822:   }
 8193:   return mTagsFolder;
 6822: }
 6822: 
    1: // nsNavHistory::FilterResultSet
    1: //
 5542: // This does some post-query-execution filtering:
 5542: //   - searching on title & url
 5909: //   - parent folder (recursively)
 5542: //   - excludeQueries
 6483: //   - tags
 6483: //   - limit count
 6822: //   - excludingLivemarkItems
 6483: //
 6483: // Note:  changes to filtering in FilterResultSet() 
 6483: // may require changes to NeedToFilterResultSet()
    1: 
    1: nsresult
 5909: nsNavHistory::FilterResultSet(nsNavHistoryQueryResultNode* aQueryNode,
 5542:                               const nsCOMArray<nsNavHistoryResultNode>& aSet,
    1:                               nsCOMArray<nsNavHistoryResultNode>* aFiltered,
 6483:                               const nsCOMArray<nsNavHistoryQuery>& aQueries,
 6483:                               nsNavHistoryQueryOptions *aOptions)
    1: {
 5542:   nsresult rv;
 5909: 
 5909:   // get the bookmarks service
 5909:   nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
 5909:   NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
 5909: 
 5909:   // parse the search terms
23904:   nsTArray<nsTArray<nsString>*> terms;
 5909:   ParseSearchTermsFromQueries(aQueries, &terms);
 5909: 
 5909:   // The includeFolders array for each query is initialized with its
 5909:   // query's folders array. We add sub-folders as we check items.
 5909:   nsTArray< nsTArray<PRInt64>* > includeFolders;
 5909:   nsTArray< nsTArray<PRInt64>* > excludeFolders;
33458:   for (PRInt32 queryIndex = 0;
 5909:        queryIndex < aQueries.Count(); queryIndex++) {
 5909:     includeFolders.AppendElement(new nsTArray<PRInt64>(aQueries[queryIndex]->Folders()));
 5909:     excludeFolders.AppendElement(new nsTArray<PRInt64>());
 5909:   }
    1: 
33458:   // Filter against query options.
33458:   // XXX Only excludeQueries and excludeItemIfParentHasAnnotation are supported
33458:   // at the moment.
 5542:   PRBool excludeQueries = PR_FALSE;
 5909:   if (aQueryNode) {
 5909:     rv = aQueryNode->mOptions->GetExcludeQueries(&excludeQueries);
 5909:     NS_ENSURE_SUCCESS(rv, rv);
 5909:   }
    1: 
 6822:   nsCString parentAnnotationToExclude;
 6822:   nsTArray<PRInt64> parentFoldersToExclude;
 6822:   if (aQueryNode) {
 6822:     rv = aQueryNode->mOptions->GetExcludeItemIfParentHasAnnotation(parentAnnotationToExclude);
 6822:     NS_ENSURE_SUCCESS(rv, rv);
 6822:   }
 6822: 
 6822:   if (!parentAnnotationToExclude.IsEmpty()) {
33458:     // Find all the folders with the annotation we are excluding and save their
33458:     // item ids.  When doing filtering, if item id of a result's parent
33458:     // matches one of the saved item ids, the result will be excluded.
33458:     mozStorageStatementScoper scope(mDBGetItemsWithAnno);
33458: 
33458:     rv = mDBGetItemsWithAnno->BindUTF8StringParameter(0, parentAnnotationToExclude);
 6822:     NS_ENSURE_SUCCESS(rv, rv);
 6822: 
 6822:     PRBool hasMore = PR_FALSE;
33458:     while (NS_SUCCEEDED(mDBGetItemsWithAnno->ExecuteStep(&hasMore)) && hasMore) {
 6822:       PRInt64 folderId = 0;
33458:       rv = mDBGetItemsWithAnno->GetInt64(0, &folderId);
 6822:       NS_ENSURE_SUCCESS(rv, rv);
 6822:       parentFoldersToExclude.AppendElement(folderId);
 6822:     }
 6822:   }
 6822: 
33458:   PRUint16 resultType = aOptions->ResultType();
    1:   for (PRInt32 nodeIndex = 0; nodeIndex < aSet.Count(); nodeIndex++) {
 7256:     // exclude-queries is implicit when searching, we're only looking at
 7256:     // plan URI nodes
 7256:     if (!aSet[nodeIndex]->IsURI())
 5542:       continue;
 5542: 
33458:     // RESULTS_AS_TAG_CONTENTS returns a set ordered by place_id and
33458:     // lastModified. So, to remove duplicates, we can retain the first result
33458:     // for each uri.
33458:     if (resultType == nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS &&
33458:         nodeIndex > 0 && aSet[nodeIndex]->mURI == aSet[nodeIndex-1]->mURI)
33458:       continue;
33458: 
 5909:     PRInt64 parentId = -1;
 5909:     if (aSet[nodeIndex]->mItemId != -1) {
26880:       if (aQueryNode && aQueryNode->mItemId == aSet[nodeIndex]->mItemId)
 5909:         continue;
33458:       parentId = aSet[nodeIndex]->mFolderId;
 5909:     }
 5909: 
 6822:     // if we are excluding items by parent annotation, 
 6822:     // exclude items who's parent is a folder with that annotation
33458:     if (!parentAnnotationToExclude.IsEmpty() &&
33458:         parentFoldersToExclude.Contains(parentId))
 6822:       continue;
 6822: 
33458:     // Append the node only if it matches one of the queries.
 5909:     PRBool appendNode = PR_FALSE;
33458:     for (PRInt32 queryIndex = 0;
 5909:          queryIndex < aQueries.Count() && !appendNode; queryIndex++) {
33458: 
33458:       if (terms[queryIndex]->Length()) {
33458:         // Filter based on search terms.
33458:         // Convert title and url for the current node to UTF16 strings.
33458:         NS_ConvertUTF8toUTF16 nodeTitle(aSet[nodeIndex]->mTitle);
33458:         // Unescape the URL for search terms matching.
33458:         NS_ConvertUTF8toUTF16 nodeURL(NS_UnescapeURL(aSet[nodeIndex]->mURI));
33458: 
33458:         // Determine if every search term matches anywhere in the title, url or
33458:         // tag.
33458:         PRBool matchAll = PR_TRUE;
33458:         for (PRInt32 termIndex = terms[queryIndex]->Length() - 1;
33458:              termIndex >= 0 && matchAll;
33458:              termIndex--) {
33458:           nsString& term = terms[queryIndex]->ElementAt(termIndex);
33458: 
33458:           // True if any of them match; false makes us quit the loop
33458:           matchAll = CaseInsensitiveFindInReadable(term, nodeTitle) ||
33458:                      CaseInsensitiveFindInReadable(term, nodeURL) ||
33458:                      CaseInsensitiveFindInReadable(term, aSet[nodeIndex]->mTags);
33458:         }
33458: 
33458:         // Skip the node if we don't match all terms in the title, url or tag
33458:         if (!matchAll)
33458:           continue;
33458:       }
33458: 
33458:       // Filter bookmarks on parent folder.
33458:       // RESULTS_AS_TAG_CONTENTS changes bookmarks' parents, so we cannot filter
14224:       // this kind of result based on the parent.
14224:       if (includeFolders[queryIndex]->Length() != 0 &&
14224:           resultType != nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS) {
33458:         // Filter out the node if its parent is in the excludeFolders
33458:         // cache.
23904:         if (excludeFolders[queryIndex]->Contains(parentId))
 5909:           continue;
 5909: 
23904:         if (!includeFolders[queryIndex]->Contains(parentId)) {
33458:           // If parent is not found in current includeFolders cache, we check
33458:           // its ancestors.
33458:           PRInt64 ancestor = parentId;
 5909:           PRBool belongs = PR_FALSE;
 6363:           nsTArray<PRInt64> ancestorFolders;
 5909: 
 5909:           while (!belongs) {
 5909:             // Avoid using |ancestor| itself if GetFolderIdForItem failed.
 6363:             ancestorFolders.AppendElement(ancestor);
 5909: 
 5909:             // GetFolderIdForItems throws when called for the places-root
 5909:             if (NS_FAILED(bookmarks->GetFolderIdForItem(ancestor, &ancestor))) {
 5909:               break;
23904:             } else if (excludeFolders[queryIndex]->Contains(ancestor)) {
 6363:               break;
23904:             } else if (includeFolders[queryIndex]->Contains(ancestor)) {
 5909:               belongs = PR_TRUE;
 5909:             }
 5909:           }
 6363:           // if the parentId or any of its ancestors "belong",
 6363:           // include all of them.  otherwise, exclude all of them.
 5909:           if (belongs) {
 6363:             includeFolders[queryIndex]->AppendElements(ancestorFolders);
 5909:           } else {
 6363:             excludeFolders[queryIndex]->AppendElements(ancestorFolders);
 5909:             continue;
 5909:           }
 5909:         }
 5909:       }
 5909: 
33458:       // We passed all filters, so we can append the node to filtered results.
 5909:       appendNode = PR_TRUE;
 5909:     }
14224: 
 5909:     if (appendNode)
    1:       aFiltered->AppendObject(aSet[nodeIndex]);
 6483:       
33458:     // Stop once we have reached max results.
12328:     if (aOptions->MaxResults() > 0 &&
26467:         (PRUint32)aFiltered->Count() >= aOptions->MaxResults())
 6483:       break;
    1:   }
 5909: 
33458:   // De-allocate the temporary matrixes.
26467:   for (PRInt32 i = 0; i < aQueries.Count(); i++) {
 5909:     delete terms[i];
 5909:     delete includeFolders[i];
 5909:     delete excludeFolders[i];
 5909:   }
 5909: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::CheckIsRecentEvent
    1: //
    1: //    Sees if this URL happened "recently."
    1: //
    1: //    It is always removed from our recent list no matter what. It only counts
 8761: //    as "recent" if the event happened more recently than our event
    1: //    threshold ago.
    1: 
    1: PRBool
    1: nsNavHistory::CheckIsRecentEvent(RecentEventHash* hashTable,
    1:                                  const nsACString& url)
    1: {
    1:   PRTime eventTime;
    1:   if (hashTable->Get(url, &eventTime)) {
    1:     hashTable->Remove(url);
    1:     if (eventTime > GetNow() - RECENT_EVENT_THRESHOLD)
    1:       return PR_TRUE;
    1:     return PR_FALSE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistory::ExpireNonrecentEvents
    1: //
    1: //    This goes through our
    1: 
20261: static PLDHashOperator
    1: ExpireNonrecentEventsCallback(nsCStringHashKey::KeyType aKey,
    1:                               PRInt64& aData,
    1:                               void* userArg)
    1: {
 3233:   PRInt64* threshold = reinterpret_cast<PRInt64*>(userArg);
    1:   if (aData < *threshold)
    1:     return PL_DHASH_REMOVE;
    1:   return PL_DHASH_NEXT;
    1: }
    1: void
    1: nsNavHistory::ExpireNonrecentEvents(RecentEventHash* hashTable)
    1: {
    1:   PRInt64 threshold = GetNow() - RECENT_EVENT_THRESHOLD;
    1:   hashTable->Enumerate(ExpireNonrecentEventsCallback,
 3233:                        reinterpret_cast<void*>(&threshold));
    1: }
    1: 
    1: 
    1: // nsNavHistory::GetRedirectFor
    1: //
    1: //    Given a destination URI, this finds a recent redirect that resulted in
    1: //    this URI. If it finds one, it will put the redirect source info into
    1: //    the out params and return true. If there is no matching redirect, it will
    1: //    return false.
    1: //
    1: //    @param aDestination The destination URI spec of the redirect to look for.
    1: //    @param aSource      Will be filled with the redirect source URI when a
    1: //                        redirect is found.
    1: //    @param aTime        Will be filled with the time the redirect happened
    1: //                         when a redirect is found.
    1: //    @param aRedirectType Will be filled with the redirect type when a redirect
    1: //                         is found. Will be either
    1: //                         TRANSITION_REDIRECT_PERMANENT or
    1: //                         TRANSITION_REDIRECT_TEMPORARY
    1: //    @returns True if the redirect is found.
    1: //
    1: //    HOW REDIRECT TRACKING WORKS
    1: //    ---------------------------
    1: //    When we get an AddDocumentRedirect message, we store the redirect in
    1: //    our mRecentRedirects which maps the destination URI to a source,time pair.
    1: //    When we get a new URI, we see if there were any redirects to this page
    1: //    in the hash table. If found, we know that the page came through the given
    1: //    redirect and add it.
    1: //
    1: //    Example: Page S redirects throught R1, then R2, to give page D. Page S
    1: //    will have been already added to history.
    1: //    - AddDocumentRedirect(R1, R2)
    1: //    - AddDocumentRedirect(R2, D)
    1: //    - AddURI(uri=D, referrer=S)
    1: //
    1: //    When we get the AddURI(D), we see the hash table has a value for D from R2.
    1: //    We have to recursively check that source since there could be more than
    1: //    one redirect, as in this case. Here we see there was a redirect to R2 from
    1: //    R1. The referrer for D is S, so we know S->R1->R2->D.
    1: //
    1: //    Alternatively, the user could have typed or followed a bookmark from S.
    1: //    In this case, with two redirects we'll get:
    1: //    - MarkPageAsTyped(S)
    1: //    - AddDocumentRedirect(S, R)
    1: //    - AddDocumentRedirect(R, D)
    1: //    - AddURI(uri=D, referrer=null)
    1: //    We need to be careful to add a visit to S in this case with an incoming
    1: //    transition of typed and an outgoing transition of redirect.
    1: //
    1: //    Note that this can get confused in some cases where you have a page
    1: //    open in more than one window loading at the same time. This should be rare,
    1: //    however, and should not affect much.
    1: 
    1: PRBool
    1: nsNavHistory::GetRedirectFor(const nsACString& aDestination,
    1:                              nsACString& aSource, PRTime* aTime,
    1:                              PRUint32* aRedirectType)
    1: {
    1:   RedirectInfo info;
    1:   if (mRecentRedirects.Get(aDestination, &info)) {
    1:     mRecentRedirects.Remove(aDestination);
    1:     if (info.mTimeCreated < GetNow() - RECENT_EVENT_THRESHOLD)
    1:       return PR_FALSE; // too long ago, probably invalid
    1:     aSource = info.mSourceURI;
    1:     *aTime = info.mTimeCreated;
    1:     *aRedirectType = info.mType;
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: // nsNavHistory::RowToResult
    1: //
    1: //    Here, we just have a generic row. It could be a query, URL, visit,
    1: //    or full visit.
    1: 
    1: nsresult
    1: nsNavHistory::RowToResult(mozIStorageValueArray* aRow,
    1:                           nsNavHistoryQueryOptions* aOptions,
    1:                           nsNavHistoryResultNode** aResult)
    1: {
    1:   *aResult = nsnull;
    1:   NS_ASSERTION(aRow && aOptions && aResult, "Null pointer in RowToResult");
    1: 
    1:   // URL
    1:   nsCAutoString url;
    1:   nsresult rv = aRow->GetUTF8String(kGetInfoIndex_URL, url);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // title
    1:   nsCAutoString title;
    1:   rv = aRow->GetUTF8String(kGetInfoIndex_Title, title);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 accessCount = aRow->AsInt32(kGetInfoIndex_VisitCount);
    1:   PRTime time = aRow->AsInt64(kGetInfoIndex_VisitDate);
    1: 
    1:   // favicon
    1:   nsCAutoString favicon;
    1:   rv = aRow->GetUTF8String(kGetInfoIndex_FaviconURL, favicon);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
33458:   // itemId
33458:   PRInt64 itemId = aRow->AsInt64(kGetInfoIndex_ItemId);
33458:   PRInt64 parentId = -1;
33458:   if (itemId == 0) {
33458:     // This is not a bookmark.  For non-bookmarks we use a -1 itemId value.
33458:     // Notice ids in sqlite tables start from 1, so itemId cannot ever be 0.
33458:     itemId = -1;
33458:   }
33458:   else {
33458:     // This is a bookmark, so it has a parent.
33458:     PRInt64 itemParentId = aRow->AsInt64(kGetInfoIndex_ItemParentId);
33458:     if (itemParentId > 0) {
33458:       // The Places root has parent == 0, but that item id does not really
33458:       // exist. We want to set the parent only if it's a real one.
33458:       parentId = itemParentId;
33458:     }
10046:   }
10046: 
    1:   if (IsQueryURI(url)) {
    1:     // special case "place:" URIs: turn them into containers
10046:       
10046:     // We should never expose the history title for query nodes if the
10046:     // bookmark-item's title is set to null (the history title may be the
10046:     // query string without the place: prefix). Thus we call getItemTitle
33458:     // explicitly. Doing this in the SQL query would be less performant since
33458:     // it should be done for all results rather than only for queries.
10046:     if (itemId != -1) {
10046:       nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
10046:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
10046: 
10046:       rv = bookmarks->GetItemTitle(itemId, title);
10046:       NS_ENSURE_SUCCESS(rv, rv);
10046:     }
10046: 
 8193:     rv = QueryRowToResult(itemId, url, title, accessCount, time, favicon, aResult);
 8193: 
 8193:     // If it's a simple folder node (i.e. a shortcut to another folder), apply
12328:     // our options for it. However, if the parent type was tag query, we do not
12328:     // apply them, because it would not yield any results.
12328:     if (*aResult && (*aResult)->IsFolder() &&
12328:          aOptions->ResultType() != 
12328:            nsINavHistoryQueryOptions::RESULTS_AS_TAG_QUERY)
 8193:       (*aResult)->GetAsContainer()->mOptions = aOptions;
14224: 
14224:     // RESULTS_AS_TAG_QUERY has date columns
14224:     if (aOptions->ResultType() == nsNavHistoryQueryOptions::RESULTS_AS_TAG_QUERY) {
14224:       (*aResult)->mDateAdded = aRow->AsInt64(kGetInfoIndex_ItemDateAdded);
14224:       (*aResult)->mLastModified = aRow->AsInt64(kGetInfoIndex_ItemLastModified);
14224:     }
14224: 
 8193:     return rv;
14224:   } else if (aOptions->ResultType() == nsNavHistoryQueryOptions::RESULTS_AS_URI ||
14224:              aOptions->ResultType() == nsNavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS) {
    1:     *aResult = new nsNavHistoryResultNode(url, title, accessCount, time,
    1:                                           favicon);
    1:     if (!*aResult)
    1:       return NS_ERROR_OUT_OF_MEMORY;
  809: 
10046:     if (itemId != -1) {
10046:       (*aResult)->mItemId = itemId;
33458:       (*aResult)->mFolderId = parentId;
 1604:       (*aResult)->mDateAdded = aRow->AsInt64(kGetInfoIndex_ItemDateAdded);
 1604:       (*aResult)->mLastModified = aRow->AsInt64(kGetInfoIndex_ItemLastModified);
  809:     }
33458: 
33458:     nsAutoString tags;
33458:     rv = aRow->GetString(kGetInfoIndex_ItemTags, tags);
33458:     NS_ENSURE_SUCCESS(rv, rv);
33458:     if (!tags.IsVoid())
33458:       (*aResult)->mTags.Assign(tags);
33458: 
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1:   }
    1:   // now we know the result type is some kind of visit (regular or full)
    1: 
    1:   // session
    1:   PRInt64 session = aRow->AsInt64(kGetInfoIndex_SessionId);
    1: 
    1:   if (aOptions->ResultType() == nsNavHistoryQueryOptions::RESULTS_AS_VISIT) {
    1:     *aResult = new nsNavHistoryVisitResultNode(url, title, accessCount, time,
    1:                                                favicon, session);
    1:     if (! *aResult)
    1:       return NS_ERROR_OUT_OF_MEMORY;
33458: 
33458:     nsAutoString tags;
33458:     rv = aRow->GetString(kGetInfoIndex_ItemTags, tags);
33458:     if (!tags.IsVoid())
33458:       (*aResult)->mTags.Assign(tags);
33458: 
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1:   }
    1: 
12328:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: // nsNavHistory::QueryRowToResult
    1: //
    1: //    Called by RowToResult when the URI is a place: URI to generate the proper
    1: //    folder or query node.
    1: 
    1: nsresult
 5542: nsNavHistory::QueryRowToResult(PRInt64 itemId, const nsACString& aURI,
 5542:                                const nsACString& aTitle,
    1:                                PRUint32 aAccessCount, PRTime aTime,
    1:                                const nsACString& aFavicon,
    1:                                nsNavHistoryResultNode** aNode)
    1: {
    1:   nsCOMArray<nsNavHistoryQuery> queries;
    1:   nsCOMPtr<nsNavHistoryQueryOptions> options;
    1:   nsresult rv = QueryStringToQueryArray(aURI, &queries,
    1:                                         getter_AddRefs(options));
    1:   if (NS_FAILED(rv)) {
    1:     // This was a query that did not parse, what do we do? We don't want to
    1:     // return failure since that will kill the whole query process. Instead
    1:     // make a query node with the query as a string. This way we have a valid
    1:     // node for the user to manipulate that will look like a query, but it will
    1:     // never populate since the query string is invalid.
    1:     *aNode = new nsNavHistoryQueryResultNode(aURI, aTitle, aFavicon);
    1:     if (! *aNode)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(*aNode);
    1:   } else {
  809:     PRInt64 folderId = GetSimpleBookmarksQueryFolder(queries, options);
    1:     if (folderId) {
    1:       // simple bookmarks folder, magically generate a bookmarks folder node
    1:       nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
    1:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       // this addrefs for us
 4179:       rv = bookmarks->ResultNodeForContainer(folderId, options, aNode);
    1:       NS_ENSURE_SUCCESS(rv, rv);
10046: 
10046:       // this is the query item-Id, and is what is exposed by node.itemId
10046:       (*aNode)->GetAsFolder()->mQueryItemId = itemId;
10046: 
10046:       // Use the query item title, unless it's void (in that case,
10046:       // we keep the concrete folder title set)
10046:       if (!aTitle.IsVoid())
10046:         (*aNode)->mTitle = aTitle;
    1:     } else {
    1:       // regular query
12328:       *aNode = new nsNavHistoryQueryResultNode(aTitle, EmptyCString(), aTime,
    1:                                                queries, options);
    1:       if (! *aNode)
    1:         return NS_ERROR_OUT_OF_MEMORY;
 5542:       (*aNode)->mItemId = itemId;
    1:       NS_ADDREF(*aNode);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavHistory::VisitIdToResultNode
    1: //
    1: //    Used by the query results to create new nodes on the fly when
    1: //    notifications come in. This just creates a node for the given visit ID.
    1: 
    1: nsresult
    1: nsNavHistory::VisitIdToResultNode(PRInt64 visitId,
    1:                                   nsNavHistoryQueryOptions* aOptions,
    1:                                   nsNavHistoryResultNode** aResult)
    1: {
    1:   mozIStorageStatement* statement; // non-owning!
12328: 
12328:   switch (aOptions->ResultType())
12328:   {
12328:     case nsNavHistoryQueryOptions::RESULTS_AS_VISIT:
12328:     case nsNavHistoryQueryOptions::RESULTS_AS_FULL_VISIT:
    1:       // visit query - want exact visit time
20879:       statement = GetDBVisitToVisitResult();
12328:       break;
12328: 
12328:     case nsNavHistoryQueryOptions::RESULTS_AS_URI:
    1:       // URL results - want last visit time
20879:       statement = GetDBVisitToURLResult();
12328:       break;
12328: 
12328:     default:
12328:       // Query base types like RESULTS_AS_*_QUERY handle additions
12328:       // by registering their own observers when they are expanded.
12328:       return NS_OK;
    1:   }
35411:   NS_ENSURE_STATE(statement);
    1: 
    1:   mozStorageStatementScoper scoper(statement);
    1:   nsresult rv = statement->BindInt64Parameter(0, visitId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMore = PR_FALSE;
    1:   rv = statement->ExecuteStep(&hasMore);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (! hasMore) {
    1:     NS_NOTREACHED("Trying to get a result node for an invalid visit");
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   return RowToResult(statement, aOptions, aResult);
    1: }
    1: 
  809: nsresult
  809: nsNavHistory::BookmarkIdToResultNode(PRInt64 aBookmarkId, nsNavHistoryQueryOptions* aOptions,
  809:                                      nsNavHistoryResultNode** aResult)
  809: {
20880:   mozIStorageStatement *stmt = GetDBBookmarkToUrlResult();
35411:   NS_ENSURE_STATE(stmt);
20880:   mozStorageStatementScoper scoper(stmt);
20880:   nsresult rv = stmt->BindInt64Parameter(0, aBookmarkId);
  809:   NS_ENSURE_SUCCESS(rv, rv);
  809: 
  809:   PRBool hasMore = PR_FALSE;
20880:   rv = stmt->ExecuteStep(&hasMore);
  809:   NS_ENSURE_SUCCESS(rv, rv);
  809:   if (!hasMore) {
  809:     NS_NOTREACHED("Trying to get a result node for an invalid bookmark identifier");
  809:     return NS_ERROR_INVALID_ARG;
  809:   }
  809: 
20880:   return RowToResult(stmt, aOptions, aResult);
  809: }
    1: 
30050: void
30050: nsNavHistory::SendPageChangedNotification(nsIURI* aURI, PRUint32 aWhat,
30050:                                           const nsAString& aValue)
30050: {
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavHistoryObserver,
30050:                       OnPageChanged(aURI, aWhat, aValue));
30050: }
30050: 
    1: // nsNavHistory::TitleForDomain
    1: //
    1: //    This computes the title for a given domain. Normally, this is just the
    1: //    domain name, but we specially handle empty cases to give you a nice
    1: //    localized string.
    1: 
    1: void
    1: nsNavHistory::TitleForDomain(const nsCString& domain, nsACString& aTitle)
    1: {
    1:   if (! domain.IsEmpty()) {
    1:     aTitle = domain;
    1:     return;
    1:   }
    1: 
    1:   // use the localized one instead
    1:   GetStringFromName(NS_LITERAL_STRING("localhost").get(), aTitle);
    1: }
    1: 
    1: void
26467: nsNavHistory::GetAgeInDaysString(PRInt32 aInt, const PRUnichar *aName,
26467:                                  nsACString& aResult)
    1: {
20877:   nsIStringBundle *bundle = GetBundle();
20877:   if (!bundle)
20877:     aResult.Truncate(0);
26467:   else {
    1:     nsAutoString intString;
    1:     intString.AppendInt(aInt);
    1:     const PRUnichar* strings[1] = { intString.get() };
    1:     nsXPIDLString value;
20877:     nsresult rv = bundle->FormatStringFromName(aName, strings,
    1:                                                1, getter_Copies(value));
    1:     if (NS_SUCCEEDED(rv))
    1:       CopyUTF16toUTF8(value, aResult);
    1:     else
    1:       aResult.Truncate(0);
    1:   }
26467: }
    1: 
    1: void
    1: nsNavHistory::GetStringFromName(const PRUnichar *aName, nsACString& aResult)
    1: {
20877:   nsIStringBundle *bundle = GetBundle();
20877:   if (!bundle)
20877:     aResult.Truncate(0);
20877: 
    1:   nsXPIDLString value;
20877:   nsresult rv = bundle->GetStringFromName(aName, getter_Copies(value));
    1:   if (NS_SUCCEEDED(rv))
    1:     CopyUTF16toUTF8(value, aResult);
    1:   else
    1:     aResult.Truncate(0);
    1: }
    1: 
26467: void
26467: nsNavHistory::GetMonthName(PRInt32 aIndex, nsACString& aResult)
26467: {
26467:   nsIStringBundle *bundle = GetDateFormatBundle();
26467:   if (!bundle)
26467:     aResult.Truncate(0);
26467:   else {
26467:     nsCString name = nsPrintfCString("month.%d.name", aIndex);
26467:     nsXPIDLString value;
26467:     nsresult rv = bundle->GetStringFromName(NS_ConvertUTF8toUTF16(name).get(),
26467:                                             getter_Copies(value));
26467:     if (NS_SUCCEEDED(rv))
26467:       CopyUTF16toUTF8(value, aResult);
26467:     else
26467:       aResult.Truncate(0);
26467:   }
26467: }
26467: 
    1: // nsNavHistory::SetPageTitleInternal
    1: //
 4037: //    Called to set the title for the given URI. Used as a
 4037: //    backend for SetTitle.
    1: //
    1: //    Will fail for pages that are not in the DB. To clear the corresponding
    1: //    title, use aTitle.SetIsVoid(). Sending an empty string will save an
    1: //    empty string instead of clearing it.
    1: 
    1: nsresult
 4037: nsNavHistory::SetPageTitleInternal(nsIURI* aURI, const nsAString& aTitle)
    1: {
    1:   nsresult rv;
    1: 
    1:   // first, make sure the page exists, and fetch the old title (we need the one
    1:   // that isn't changing to send notifications)
    1:   nsAutoString title;
    1:   { // scope for statement
    1:     mozStorageStatementScoper infoScoper(mDBGetURLPageInfo);
    1:     rv = BindStatementURI(mDBGetURLPageInfo, 0, aURI);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     PRBool hasURL = PR_FALSE;
    1:     rv = mDBGetURLPageInfo->ExecuteStep(&hasURL);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (! hasURL) {
    1:       // we don't have the URL, give up
    1:       return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
    1:     // page title
    1:     rv = mDBGetURLPageInfo->GetString(kGetInfoIndex_Title, title);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // It is actually common to set the title to be the same thing it used to
    1:   // be. For example, going to any web page will always cause a title to be set,
    1:   // even though it will often be unchanged since the last visit. In these
    1:   // cases, we can avoid DB writing and (most significantly) observer overhead.
11935:   if ((aTitle.IsVoid() && title.IsVoid()) || aTitle == title)
    1:     return NS_OK;
    1: 
20871:   mozStorageStatementScoper scoper(mDBSetPlaceTitle);
    1:   // title
    1:   if (aTitle.IsVoid())
20871:     rv = mDBSetPlaceTitle->BindNullParameter(0);
    1:   else
20871:     rv = mDBSetPlaceTitle->BindStringParameter(0, StringHead(aTitle, HISTORY_TITLE_LENGTH_MAX));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // url
20871:   rv = BindStatementURI(mDBSetPlaceTitle, 1, aURI);
20871:   NS_ENSURE_SUCCESS(rv, rv);
20871: 
20871:   rv = mDBSetPlaceTitle->Execute();
 8225:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // observers (have to check first if it's bookmarked)
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavHistoryObserver,
35298:                       OnTitleChanged(aURI, aTitle));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
23588: nsNavHistory::AddPageWithVisits(nsIURI *aURI,
    1:                                 const nsString &aTitle,
    1:                                 PRInt32 aVisitCount,
23588:                                 PRInt32 aTransitionType,
23588:                                 PRTime aFirstVisitDate,
    1:                                 PRTime aLastVisitDate)
    1: {
    1:   PRBool canAdd = PR_FALSE;
    1:   nsresult rv = CanAddURI(aURI, &canAdd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!canAdd) {
    1:     return NS_OK;
    1:   }
    1: 
23588:   // see if this is an update (revisit) or a new page
23588:   mozStorageStatementScoper scoper(mDBGetPageVisitStats);
23588:   rv = BindStatementURI(mDBGetPageVisitStats, 0, aURI);
23588:   NS_ENSURE_SUCCESS(rv, rv);
23588:   PRBool alreadyVisited = PR_FALSE;
23588:   rv = mDBGetPageVisitStats->ExecuteStep(&alreadyVisited);
23588:   NS_ENSURE_SUCCESS(rv, rv);
23588: 
23588:   PRInt64 placeId = 0;
23588:   PRInt32 typed = 0;
23588:   PRInt32 hidden = 0;
23588: 
23588:   if (alreadyVisited) {
23588:     // Update the existing entry
23588:     rv = mDBGetPageVisitStats->GetInt64(0, &placeId);
23588:     NS_ENSURE_SUCCESS(rv, rv);
23588:     // We don't mind visit_count
23588:     rv = mDBGetPageVisitStats->GetInt32(2, &typed);
23588:     NS_ENSURE_SUCCESS(rv, rv);
23588:     rv = mDBGetPageVisitStats->GetInt32(3, &hidden);
23588:     NS_ENSURE_SUCCESS(rv, rv);
23588: 
23588:     if (typed == 0 && aTransitionType == TRANSITION_TYPED) {
23588:       typed = 1;
23588:       // Update with new stats
23588:       mozStorageStatementScoper updateScoper(mDBUpdatePageVisitStats);
23588:       rv = mDBUpdatePageVisitStats->BindInt64Parameter(0, placeId);
23588:       NS_ENSURE_SUCCESS(rv, rv);
23588:       rv = mDBUpdatePageVisitStats->BindInt32Parameter(1, hidden);
23588:       NS_ENSURE_SUCCESS(rv, rv);
23588:       rv = mDBUpdatePageVisitStats->BindInt32Parameter(2, typed);
23588:       NS_ENSURE_SUCCESS(rv, rv);
23588: 
23588:       rv = mDBUpdatePageVisitStats->Execute();
23588:       NS_ENSURE_SUCCESS(rv, rv);
23588:     }
23588:   } else {
23588:     // Insert the new place entry
23588:     rv = InternalAddNewPage(aURI, aTitle, hidden == 1,
23588:                             aTransitionType == TRANSITION_TYPED, 0,
23588:                             PR_FALSE, &placeId);
23588:     NS_ENSURE_SUCCESS(rv, rv);
23588:   }
23588: 
23588:   NS_ASSERTION(placeId != 0, "Cannot add a visit to a not existant page");
23588: 
23588:   if (aFirstVisitDate != -1) {
23588:     // Add the first visit
23588:     PRInt64 visitId;
23588:     rv = InternalAddVisit(placeId, 0, 0,
23588:                           aFirstVisitDate, aTransitionType, &visitId);
23588:     aVisitCount--;
23588:     NS_ENSURE_SUCCESS(rv, rv);
23588:   }
    1: 
    1:   if (aLastVisitDate != -1) {
23588:    // Add remaining visits starting from the last one
23588:    for (PRInt64 i = 0; i < aVisitCount; i++) {
23588:       PRInt64 visitId;
23588:       rv = InternalAddVisit(placeId, 0, 0,
23588:                             aLastVisitDate - i, aTransitionType, &visitId);
23588:       NS_ENSURE_SUCCESS(rv, rv);
23588:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNavHistory::RemoveDuplicateURIs()
    1: {
 8205:   // this must be in a transaction because we do related queries
 3422:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
 3422: 
 8205:   // this query chooses an id for every duplicate uris
 8205:   // this id will be retained while duplicates will be discarded
 8205:   // total_visit_count is the sum of all duplicate uris visit_count
 8205:   nsCOMPtr<mozIStorageStatement> selectStatement;
20868:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT "
23198:         "(SELECT h.id FROM moz_places h WHERE h.url = url "
20868:          "ORDER BY h.visit_count DESC LIMIT 1), "
 8205:         "url, SUM(visit_count) "
23198:       "FROM moz_places "
 8205:       "GROUP BY url HAVING( COUNT(url) > 1)"),
 8205:     getter_AddRefs(selectStatement));
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:   // this query remaps history visits to the retained place_id
 8205:   nsCOMPtr<mozIStorageStatement> updateStatement;
20868:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
23198:       "UPDATE moz_historyvisits "
 8205:       "SET place_id = ?1 "
20868:       "WHERE place_id IN "
23198:         "(SELECT id FROM moz_places WHERE id <> ?1 AND url = ?2)"),
 8205:     getter_AddRefs(updateStatement));
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:   // this query remaps bookmarks to the retained place_id
 8205:   nsCOMPtr<mozIStorageStatement> bookmarkStatement;
20868:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
 8205:       "UPDATE moz_bookmarks "
 8205:       "SET fk = ?1 "
20868:       "WHERE fk IN "
23198:         "(SELECT id FROM moz_places WHERE id <> ?1 AND url = ?2)"),
 8205:     getter_AddRefs(bookmarkStatement));
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:   // this query remaps annotations to the retained place_id
 8205:   nsCOMPtr<mozIStorageStatement> annoStatement;
20868:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
 8205:       "UPDATE moz_annos "
 8205:       "SET place_id = ?1 "
20868:       "WHERE place_id IN "
23198:         "(SELECT id FROM moz_places WHERE id <> ?1 AND url = ?2)"),
 8205:     getter_AddRefs(annoStatement));
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205:   
23541:   // this query deletes all duplicate uris except the chosen id
 8205:   nsCOMPtr<mozIStorageStatement> deleteStatement;
20868:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
23198:       "DELETE FROM moz_places WHERE url = ?1 AND id <> ?2"),
 8205:     getter_AddRefs(deleteStatement));
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:   // this query updates visit_count to the sum of all visits
 8205:   nsCOMPtr<mozIStorageStatement> countStatement;
20868:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
23198:       "UPDATE moz_places SET visit_count = ?1 WHERE id = ?2"),
 8205:     getter_AddRefs(countStatement));
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:   // for each duplicate uri we update historyvisit and visit_count
 8205:   PRBool hasMore;
 8205:   while (NS_SUCCEEDED(selectStatement->ExecuteStep(&hasMore)) && hasMore) {
 8205:     PRUint64 id = selectStatement->AsInt64(0);
 8205:     nsCAutoString url;
 8205:     rv = selectStatement->GetUTF8String(1, url);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     PRUint64 visit_count = selectStatement->AsInt64(2);
 8205: 
 8205:     // update historyvisits so they are remapped to the retained uri
 8205:     rv = updateStatement->BindInt64Parameter(0, id);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = updateStatement->BindUTF8StringParameter(1, url);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = updateStatement->Execute();
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:     // remap bookmarks to the retained id
 8205:     rv = bookmarkStatement->BindInt64Parameter(0, id);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = bookmarkStatement->BindUTF8StringParameter(1, url);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = bookmarkStatement->Execute();
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:     // remap annotations to the retained id
 8205:     rv = annoStatement->BindInt64Parameter(0, id);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = annoStatement->BindUTF8StringParameter(1, url);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = annoStatement->Execute();
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     
 8205:     // remove duplicate uris from moz_places
 8205:     rv = deleteStatement->BindUTF8StringParameter(0, url);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = deleteStatement->BindInt64Parameter(1, id);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = deleteStatement->Execute();
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205: 
 8205:     // update visit_count to the sum of all visit_count
 8205:     rv = countStatement->BindInt64Parameter(0, visit_count);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = countStatement->BindInt64Parameter(1, id);
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:     rv = countStatement->Execute();
 8205:     NS_ENSURE_SUCCESS(rv, rv);
 8205:   }
 8205: 
 8205:   rv = transaction.Commit();
 8205:   NS_ENSURE_SUCCESS(rv, rv);
 8205:   return NS_OK;
    1: }
    1: 
    1: // Local function **************************************************************
    1: 
    1: 
    1: // GetReversedHostname
    1: //
    1: //    This extracts the hostname from the URI and reverses it in the
    1: //    form that we use (always ending with a "."). So
    1: //    "http://microsoft.com/" becomes "moc.tfosorcim."
    1: //
    1: //    The idea behind this is that we can create an index over the items in
    1: //    the reversed host name column, and then query for as much or as little
    1: //    of the host name as we feel like.
    1: //
    1: //    For example, the query "host >= 'gro.allizom.' AND host < 'gro.allizom/'
    1: //    Matches all host names ending in '.mozilla.org', including
    1: //    'developer.mozilla.org' and just 'mozilla.org' (since we define all
    1: //    reversed host names to end in a period, even 'mozilla.org' matches).
    1: //    The important thing is that this operation uses the index. Any substring
    1: //    calls in a select statement (even if it's for the beginning of a string)
    1: //    will bypass any indices and will be slow).
    1: 
    1: nsresult
    1: GetReversedHostname(nsIURI* aURI, nsAString& aRevHost)
    1: {
    1:   nsCString forward8;
    1:   nsresult rv = aURI->GetHost(forward8);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // can't do reversing in UTF8, better use 16-bit chars
24715:   NS_ConvertUTF8toUTF16 forward(forward8);
    1:   GetReversedHostname(forward, aRevHost);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // GetReversedHostname
    1: //
    1: //    Same as previous but for strings
    1: 
    1: void
    1: GetReversedHostname(const nsString& aForward, nsAString& aRevHost)
    1: {
    1:   ReverseString(aForward, aRevHost);
    1:   aRevHost.Append(PRUnichar('.'));
    1: }
    1: 
    1: 
    1: // GetSimpleBookmarksQueryFolder
    1: //
    1: //    Determines if this set of queries is a simple bookmarks query for a
    1: //    folder with no other constraints. In these common cases, we can more
    1: //    efficiently compute the results.
    1: //
 6822: //    A simple bookmarks query will result in a hierarchical tree of
 6822: //    bookmark items, folders and separators.
 6822: //
    1: //    Returns the folder ID if it is a simple folder query, 0 if not.
    1: static PRInt64
  809: GetSimpleBookmarksQueryFolder(const nsCOMArray<nsNavHistoryQuery>& aQueries,
  809:                               nsNavHistoryQueryOptions* aOptions)
    1: {
    1:   if (aQueries.Count() != 1)
    1:     return 0;
    1: 
    1:   nsNavHistoryQuery* query = aQueries[0];
    1:   if (query->Folders().Length() != 1)
    1:     return 0;
    1: 
    1:   PRBool hasIt;
    1:   query->GetHasBeginTime(&hasIt);
    1:   if (hasIt)
    1:     return 0;
    1:   query->GetHasEndTime(&hasIt);
    1:   if (hasIt)
    1:     return 0;
    1:   query->GetHasDomain(&hasIt);
    1:   if (hasIt)
    1:     return 0;
    1:   query->GetHasUri(&hasIt);
    1:   if (hasIt)
    1:     return 0;
 3734:   (void)query->GetHasSearchTerms(&hasIt);
 3734:   if (hasIt)
 3734:     return 0;
27981:   if (query->Tags().Length() > 0)
27981:     return 0;
  809:   if (aOptions->MaxResults() > 0)
  809:     return 0;
    1: 
14224:   // RESULTS_AS_TAG_CONTENTS is quite similar to a folder shortcut, but we must
14224:   // avoid treating it like that, since we need to retain all query options.
14224:   if(aOptions->ResultType() == nsINavHistoryQueryOptions::RESULTS_AS_TAG_CONTENTS)
14224:     return 0;
14224: 
    1:   // Note that we don't care about the onlyBookmarked flag, if you specify a bookmark
    1:   // folder, onlyBookmarked is inferred.
 3734:   NS_ASSERTION(query->Folders()[0] > 0, "bad folder id");
    1:   return query->Folders()[0];
    1: }
    1: 
    1: 
 5909: // ParseSearchTermsFromQueries
    1: //
 5909: //    Construct a matrix of search terms from the given queries array.
 5909: //    All of the query objects are ORed together. Within a query, all the terms
 8761: //    are ANDed together. See nsINavHistoryService.idl.
 5909: //
 8761: //    This just breaks the query up into words. We don't do anything fancy,
    1: //    not even quoting. We do, however, strip quotes, because people might
    1: //    try to input quotes expecting them to do something and get no results
    1: //    back.
    1: 
    1: inline PRBool isQueryWhitespace(PRUnichar ch)
    1: {
    1:   return ch == ' ';
    1: }
    1: 
 5909: void ParseSearchTermsFromQueries(const nsCOMArray<nsNavHistoryQuery>& aQueries,
23904:                                  nsTArray<nsTArray<nsString>*>* aTerms)
    1: {
    1:   PRInt32 lastBegin = -1;
26467:   for (PRInt32 i = 0; i < aQueries.Count(); i++) {
23904:     nsTArray<nsString> *queryTerms = new nsTArray<nsString>();
 5909:     PRBool hasSearchTerms;
 5909:     if (NS_SUCCEEDED(aQueries[i]->GetHasSearchTerms(&hasSearchTerms)) &&
 5909:         hasSearchTerms) {
 5909:       const nsString& searchTerms = aQueries[i]->SearchTerms();
 5909:       for (PRUint32 j = 0; j < searchTerms.Length(); j++) {
 5909:         if (isQueryWhitespace(searchTerms[j]) ||
 5909:             searchTerms[j] == '"') {
    1:           if (lastBegin >= 0) {
    1:             // found the end of a word
23904:             queryTerms->AppendElement(Substring(searchTerms, lastBegin,
 5909:                                                j - lastBegin));
    1:             lastBegin = -1;
    1:           }
    1:         } else {
    1:           if (lastBegin < 0) {
    1:             // found the beginning of a word
 5909:             lastBegin = j;
    1:           }
    1:         }
    1:       }
    1:       // last word
    1:       if (lastBegin >= 0)
23904:         queryTerms->AppendElement(Substring(searchTerms, lastBegin));
 5909:     }
 5909:     aTerms->AppendElement(queryTerms);
 5909:   }
    1: }
    1: 
    1: // BindStatementURI
    1: //
    1: //    Binds the specified URI as the parameter 'index' for the statment.
    1: //    URIs are always bound as UTF8
    1: 
28236: nsresult
28236: BindStatementURI(mozIStorageStatement* statement, PRInt32 index, nsIURI* aURI)
28236: {
28236:   NS_ASSERTION(statement, "Must have non-null statement");
28236:   NS_ASSERTION(aURI, "Must have non-null uri");
 2580: 
    1:   nsCAutoString utf8URISpec;
    1:   nsresult rv = aURI->GetSpec(utf8URISpec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = statement->BindUTF8StringParameter(index,
    1:       StringHead(utf8URISpec, HISTORY_URI_LENGTH_MAX));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   return NS_OK;
    1: }
10669: 
10669: nsresult
10669: nsNavHistory::UpdateFrecency(PRInt64 aPlaceId, PRBool aIsBookmarked)
10669: {
10669:   mozStorageStatementScoper statsScoper(mDBGetPlaceVisitStats);
10669:   nsresult rv = mDBGetPlaceVisitStats->BindInt64Parameter(0, aPlaceId);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   PRBool hasResults = PR_FALSE;
10669:   rv = mDBGetPlaceVisitStats->ExecuteStep(&hasResults);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   if (!hasResults) {
10669:     NS_WARNING("attempting to update frecency for a bogus place");
10669:     // before I added the check for itemType == TYPE_BOOKMARK
10669:     // I hit this with aPlaceId of 0 (on import)
10669:     return NS_OK;
10669:   }
10669: 
10669:   PRInt32 typed = 0;
10669:   rv = mDBGetPlaceVisitStats->GetInt32(0, &typed);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   PRInt32 hidden = 0;
10669:   rv = mDBGetPlaceVisitStats->GetInt32(1, &hidden);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   PRInt32 oldFrecency = 0;
10669:   rv = mDBGetPlaceVisitStats->GetInt32(2, &oldFrecency);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
27692:   rv = UpdateFrecencyInternal(aPlaceId, typed, hidden, oldFrecency,
27692:                               aIsBookmarked);
27692:   NS_ENSURE_SUCCESS(rv, rv);
27692: 
27692:   return NS_OK;
27692: }
27692: 
27692: nsresult
27692: nsNavHistory::UpdateFrecencyInternal(PRInt64 aPlaceId, PRInt32 aTyped,
27692:   PRInt32 aHidden, PRInt32 aOldFrecency, PRBool aIsBookmarked)
27692: {
10669:   PRInt32 visitCountForFrecency = 0;
10669: 
13613:   // because visit_count excludes visit with visit_type NOT IN(0,4,7)
10669:   // we can't use it for calculating frecency, so we must
10669:   // calculate it.
27692:   nsresult rv = CalculateFullVisitCount(aPlaceId, &visitCountForFrecency);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   PRInt32 newFrecency = 0;
27692:   rv = CalculateFrecencyInternal(aPlaceId, aTyped, visitCountForFrecency,
10669:                                  aIsBookmarked, &newFrecency);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // save ourselves the UPDATE if the frecency hasn't changed
10669:   // One way this can happen is with livemarks.
10669:   // when we added the livemark, the frecency was 0.  
10669:   // On refresh, when we remove and then add the livemark items,
10669:   // the frecency (for a given moz_places) will not have changed
10669:   // (if we've never visited that place).
13613:   // Additionally, don't bother overwriting a valid frecency with an invalid one
27692:   if (newFrecency == aOldFrecency || aOldFrecency && newFrecency < 0)
10669:     return NS_OK;
10669: 
10669:   mozStorageStatementScoper updateScoper(mDBUpdateFrecencyAndHidden);
10669:   rv = mDBUpdateFrecencyAndHidden->BindInt64Parameter(0, aPlaceId);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   rv = mDBUpdateFrecencyAndHidden->BindInt32Parameter(1, newFrecency);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // if we calculated a non-zero frecency we should unhide this place
10669:   // so that previously hidden (non-livebookmark item) bookmarks 
10669:   // will now appear in autocomplete
10669:   // if we calculated a zero frecency, we re-use the old hidden value.
10669:   rv = mDBUpdateFrecencyAndHidden->BindInt32Parameter(2, 
27692:          newFrecency ? 0 /* not hidden */ : aHidden);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   rv = mDBUpdateFrecencyAndHidden->Execute();
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   return NS_OK;
10669: }
10669: 
10669: nsresult
13613: nsNavHistory::CalculateFrecencyInternal(PRInt64 aPlaceId,
13613:                                         PRInt32 aTyped,
13613:                                         PRInt32 aVisitCount,
13613:                                         PRBool aIsBookmarked,
13613:                                         PRInt32 *aFrecency)
10669: {
10669:   PRTime normalizedNow = NormalizeTimeRelativeToday(GetNow());
10669: 
10669:   float pointsForSampledVisits = 0.0;
10669: 
10669:   if (aPlaceId != -1) {
10669:     PRInt32 numSampledVisits = 0;
10669: 
10669:     mozStorageStatementScoper scoper(mDBVisitsForFrecency);
10669:     nsresult rv = mDBVisitsForFrecency->BindInt64Parameter(0, aPlaceId);
10669:     NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:     // mDBVisitsForFrecency is limited by the browser.frecency.numVisits pref
10669:     PRBool hasMore = PR_FALSE;
10669:     while (NS_SUCCEEDED(mDBVisitsForFrecency->ExecuteStep(&hasMore)) 
10669:            && hasMore) {
10669:       numSampledVisits++;
10669: 
10669:       PRInt32 visitType = mDBVisitsForFrecency->AsInt32(1);
10669: 
10669:       PRInt32 bonus = 0;
10669: 
10669:       switch (visitType) {
10669:         case nsINavHistoryService::TRANSITION_EMBED:
10669:           bonus = mEmbedVisitBonus;
10669:           break;
10669:         case nsINavHistoryService::TRANSITION_LINK:
10669:           bonus = mLinkVisitBonus;
10669:           break;
10669:         case nsINavHistoryService::TRANSITION_TYPED:
10669:           bonus = mTypedVisitBonus;
10669:           break;
10669:         case nsINavHistoryService::TRANSITION_BOOKMARK:
10669:           bonus = mBookmarkVisitBonus;
10669:           break;
10669:         case nsINavHistoryService::TRANSITION_DOWNLOAD:
10669:           bonus = mDownloadVisitBonus;
10669:           break;
10669:         case nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT:
10669:           bonus = mPermRedirectVisitBonus;
10669:           break;
10669:         case nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY:
10669:           bonus = mTempRedirectVisitBonus;
10669:           break;
10669:         default:
10669:           // 0 == undefined (see bug #375777 for details)
29135:           NS_WARN_IF_FALSE(!visitType, "new transition but no weight for frecency");
10669:           bonus = mDefaultVisitBonus;
10669:           break;
10669:       }
10669: 
24324:       // Always add the bookmark visit bonus.
24324:       if (aIsBookmarked)
24324:         bonus += mBookmarkVisitBonus;
24324: 
24324: #ifdef DEBUG_FRECENCY
24324:       printf("CalculateFrecency() for place %lld has a bonus of %d\n", aPlaceId, bonus);
24324: #endif
24324: 
10669:       // if bonus was zero, we can skip the work to determine the weight
10669:       if (bonus) {
10669:         PRTime visitDate = mDBVisitsForFrecency->AsInt64(0);
10669:         PRInt64 ageInDays = GetAgeInDays(normalizedNow, visitDate);
10669: 
10669:         PRInt32 weight = 0;
10669: 
10669:         if (ageInDays <= mFirstBucketCutoffInDays)
10669:           weight = mFirstBucketWeight;
10669:         else if (ageInDays <= mSecondBucketCutoffInDays)
10669:           weight = mSecondBucketWeight;
10669:         else if (ageInDays <= mThirdBucketCutoffInDays)
10669:           weight = mThirdBucketWeight;
10669:         else if (ageInDays <= mFourthBucketCutoffInDays) 
10669:           weight = mFourthBucketWeight;
10669:         else
10669:           weight = mDefaultWeight;
10669: 
26467:         pointsForSampledVisits += (float)(weight * (bonus / 100.0));
10669:       }
10669:     }
10669: 
10669:     if (numSampledVisits) {
10669:       // fix for bug #412219
10669:       if (!pointsForSampledVisits) {
10669:         // For URIs with zero points in the sampled recent visits
13613:         // but "browsing" type visits outside the sampling range, set
13613:         // frecency to -visit_count, so they're still shown in autocomplete.
13613:         PRInt32 visitCount = 0;
13613:         mozStorageStatementScoper scoper(mDBGetIdPageInfo);
13613:         rv = mDBGetIdPageInfo->BindInt64Parameter(0, aPlaceId);
13613:         NS_ENSURE_SUCCESS(rv, rv);
13613: 
13613:         PRBool hasVisits = PR_TRUE;
13613:         if (NS_SUCCEEDED(mDBGetIdPageInfo->ExecuteStep(&hasVisits)) && hasVisits) {
13613:           rv = mDBGetIdPageInfo->GetInt32(nsNavHistory::kGetInfoIndex_VisitCount,
13613:                                           &visitCount);
13613:           NS_ENSURE_SUCCESS(rv, rv);
13613:         }
13613:         // If we don't have visits set to 0
13613:         *aFrecency = -visitCount;
10669:       }
10669:       else {
10669:         // Estimate frecency using the last few visits.
10669:         // Use NS_ceilf() so that we don't round down to 0, which
10669:         // would cause us to completely ignore the place during autocomplete.
10669:         *aFrecency = (PRInt32) NS_ceilf(aVisitCount * NS_ceilf(pointsForSampledVisits) / numSampledVisits);
10669:       }
10669: 
10669: #ifdef DEBUG_FRECENCY
10669:       printf("CalculateFrecency() for place %lld: %d = %d * %f / %d\n", aPlaceId, *aFrecency, aVisitCount, pointsForSampledVisits, numSampledVisits);
10669: #endif
10669: 
10669:       return NS_OK;
10669:     }
10669:   }
10669:  
10669:   // XXX the code below works well for guessing the frecency on import, and we'll correct later once we have
10669:   // visits.
10669:   // what if we don't have visits and we never visit?  we could end up with a really high value
10669:   // that keeps coming up in ac results?  only do this on import?  something to figure out.
10669:   PRInt32 bonus = 0;
10669: 
10669:   // not the same logic above, as a single visit could not be both
10669:   // a bookmark visit and a typed visit.  but when estimating a frecency
10669:   // for a place that doesn't have any visits, this will make it so
10669:   // something bookmarked and typed will have a higher frecency than
10669:   // something just typed or just bookmarked.
10669:   if (aIsBookmarked)
10669:     bonus += mUnvisitedBookmarkBonus;
10669:   if (aTyped)
10669:     bonus += mUnvisitedTypedBonus;
10669: 
10669:   // assume "now" as our ageInDays, so use the first bucket.
10669:   pointsForSampledVisits = mFirstBucketWeight * (bonus / (float)100.0); 
10669:    
10669:   // for a unvisited bookmark, produce a non-zero frecency
10669:   // so that unvisited bookmarks show up in URL bar autocomplete
10669:   if (!aVisitCount && aIsBookmarked)
10669:     aVisitCount = 1;
10669: 
10669:   // use NS_ceilf() so that we don't round down to 0, which
10669:   // would cause us to completely ignore the place during autocomplete
10669:   *aFrecency = (PRInt32) NS_ceilf(aVisitCount * NS_ceilf(pointsForSampledVisits));
10669: #ifdef DEBUG_FRECENCY
10669:   printf("CalculateFrecency() for unvisited: frecency %d = %f points (b: %d, t: %d) * visit count %d\n", *aFrecency, pointsForSampledVisits, aIsBookmarked, aTyped, aVisitCount);
10669: #endif
10669:   return NS_OK;
10669: }
10669: 
10669: nsresult
13613: nsNavHistory::CalculateFrecency(PRInt64 aPlaceId,
13613:                                 PRInt32 aTyped,
13613:                                 PRInt32 aVisitCount,
13613:                                 nsCAutoString &aURL,
13613:                                 PRInt32 *aFrecency)
10669: {
10669:   *aFrecency = 0;
10669: 
10669:   PRBool isBookmark = PR_FALSE;
10669: 
10669:   // determine if the place is a (non-livemark item) bookmark and prevent
10669:   // place: queries from showing up in the URL bar autocomplete results
10669:   if (!IsQueryURI(aURL) && aPlaceId != -1) {
24324:     nsNavBookmarks *bs = nsNavBookmarks::GetBookmarksService();
35298:     NS_ENSURE_TRUE(bs, NS_ERROR_OUT_OF_MEMORY);
24324:     isBookmark = bs->IsRealBookmark(aPlaceId);
24324:   }
24324: 
24324:   nsresult rv = CalculateFrecencyInternal(aPlaceId, aTyped, aVisitCount,
10669:                                           isBookmark, aFrecency);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669:   return NS_OK;
10669: }
10669: 
10669: nsresult
27190: nsNavHistory::FixInvalidFrecencies()
10669: {
10669:   mozStorageTransaction transaction(mDBConn, PR_TRUE);
10669: 
27190:   // Find all places with invalid frecencies (frecency < 0) that occur when:
27190:   // 1) we've done "clear private data"
27190:   // 2) we've expired or deleted visits
27190:   // 3) we've migrated from an older version, before global frecency
27190:   //
27190:   // From older versions, unmigrated bookmarks might be hidden, so we can't
27190:   // exclude hidden places (by doing "WHERE hidden <> 1") from our query, as we
27190:   // want to calculate the frecency for those places and unhide them (if they
27190:   // are not livemark items and not place: queries.)
27190:   //
27190:   // Note, we are not limiting ourselves to places with visits because we may
27190:   // not have any if the place is a bookmark and we expired or deleted all the
27190:   // visits.
27190:   nsCOMPtr<mozIStorageStatement> invalidFrecencies;
27190:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
27190:       "SELECT id, typed, hidden, frecency, url "
27190:       "FROM moz_places_view "
27190:       "WHERE frecency < 0"),
27190:     getter_AddRefs(invalidFrecencies));
11027:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   PRBool hasMore = PR_FALSE;
27190:   while (NS_SUCCEEDED(invalidFrecencies->ExecuteStep(&hasMore)) && hasMore) {
27190:     PRInt64 placeId = invalidFrecencies->AsInt64(0);
27190:     PRInt32 typed = invalidFrecencies->AsInt32(1);
27190:     PRInt32 hidden = invalidFrecencies->AsInt32(2);
27190:     PRInt32 oldFrecency = invalidFrecencies->AsInt32(3);
10669:     nsCAutoString url;
27190:     invalidFrecencies->GetUTF8String(4, url);
10669: 
27692:     PRBool isBook = PR_FALSE;
35298:     if (!IsQueryURI(url)) {
35298:       nsNavBookmarks *bookmarks = nsNavBookmarks::GetBookmarksService();
35298:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
35298:       isBook = bookmarks->IsRealBookmark(placeId);
35298:     }
27692: 
27692:     rv = UpdateFrecencyInternal(placeId, typed, hidden, oldFrecency, isBook);
10669:     NS_ENSURE_SUCCESS(rv, rv);
10669:   }
10669: 
10669:   return NS_OK;
10669: }
14062: 
20875: 
30902: #ifdef MOZ_XUL
30902: 
30902: namespace {
30902: 
30902: // Used to notify a topic to system observers on async execute completion.
34764: class AutoCompleteStatementCallbackNotifier : public AsyncStatementCallback
30902: {
30902: public:
30902:   NS_DECL_ISUPPORTS
34764:   NS_DECL_ASYNCSTATEMENTCALLBACK
30902: };
30902: 
30902: NS_IMPL_ISUPPORTS1(AutoCompleteStatementCallbackNotifier,
30902:                    mozIStorageStatementCallback)
30902: 
30902: NS_IMETHODIMP
30902: AutoCompleteStatementCallbackNotifier::HandleCompletion(PRUint16 aReason)
30902: {
30902:   if (aReason != mozIStorageStatementCallback::REASON_FINISHED)
30902:     return NS_ERROR_UNEXPECTED;
30902: 
30902:   nsresult rv;
30902:   nsCOMPtr<nsIObserverService> observerService =
30902:     do_GetService("@mozilla.org/observer-service;1", &rv);
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902:   rv = observerService->NotifyObservers(nsnull,
30902:                                         PLACES_AUTOCOMPLETE_FEEDBACK_UPDATED_TOPIC,
30902:                                         nsnull);
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902: 
30902:   return NS_OK;
30902: }
30902: 
30902: NS_IMETHODIMP
30902: AutoCompleteStatementCallbackNotifier::HandleResult(mozIStorageResultSet *aResultSet)
30902: {
30902:   NS_ASSERTION(PR_FALSE, "You cannot use AutoCompleteStatementCallbackNotifier to get async statements resultset");
30902:   return NS_OK;
30902: }
30902: 
30902: } // anonymous namespace
30902: 
30902: nsresult
30902: nsNavHistory::AutoCompleteFeedback(PRInt32 aIndex,
30902:                                    nsIAutoCompleteController *aController)
30902: {
30902:   // We do not track user choices in the location bar in private browsing mode.
30902:   if (InPrivateBrowsingMode())
30902:     return NS_OK;
30902: 
30902:   mozIStorageStatement *stmt = GetDBFeedbackIncrease();
35411:   NS_ENSURE_STATE(stmt);
30902:   mozStorageStatementScoper scope(stmt);
30902: 
30902:   nsAutoString input;
30902:   nsresult rv = aController->GetSearchString(input);
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902:   rv = stmt->BindStringParameter(0, input);
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902: 
30902:   nsAutoString url;
30902:   rv = aController->GetValueAt(aIndex, url);
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902:   rv = stmt->BindStringParameter(1, url);
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902: 
30902:   // We do the update asynchronously and we do not care about failures.
30902:   nsCOMPtr<AutoCompleteStatementCallbackNotifier> callback =
30902:     new AutoCompleteStatementCallbackNotifier();
30902:   nsCOMPtr<mozIStoragePendingStatement> canceler;
30902:   rv = stmt->ExecuteAsync(callback, getter_AddRefs(canceler));
30902:   NS_ENSURE_SUCCESS(rv, rv);
30902: 
30902:   return NS_OK;
30902: }
30902: 
30902: mozIStorageStatement *
30902: nsNavHistory::GetDBFeedbackIncrease()
30902: {
30902:   if (mDBFeedbackIncrease)
30902:     return mDBFeedbackIncrease;
30902: 
30902:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
30902:     // Leverage the PRIMARY KEY (place_id, input) to insert/update entries.
30902:     "INSERT OR REPLACE INTO moz_inputhistory "
30902:       // use_count will asymptotically approach the max of 10.
30902:       "SELECT h.id, IFNULL(i.input, ?1), IFNULL(i.use_count, 0) * .9 + 1 "
30902:       "FROM moz_places_temp h "
30902:       "LEFT JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = ?1 "
30902:       "WHERE url = ?2 "
30902:       "UNION ALL "
30902:       "SELECT h.id, IFNULL(i.input, ?1), IFNULL(i.use_count, 0) * .9 + 1 "
30902:       "FROM moz_places h "
30902:       "LEFT JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = ?1 "
30902:       "WHERE url = ?2 "
30902:         "AND h.id NOT IN (SELECT id FROM moz_places_temp)"),
30902:     getter_AddRefs(mDBFeedbackIncrease));
30902:   NS_ENSURE_SUCCESS(rv, nsnull);
30902: 
30902:   return mDBFeedbackIncrease;
30902: }
30902: #endif
30902: 
30902: 
20875: nsICollation *
20875: nsNavHistory::GetCollation()
20875: {
20875:   if (mCollation)
20875:     return mCollation;
20875: 
20875:   // locale
20875:   nsCOMPtr<nsILocale> locale;
20875:   nsCOMPtr<nsILocaleService> ls(do_GetService(NS_LOCALESERVICE_CONTRACTID));
20875:   NS_ENSURE_TRUE(ls, nsnull);
20875:   nsresult rv = ls->GetApplicationLocale(getter_AddRefs(locale));
20875:   NS_ENSURE_SUCCESS(rv, nsnull);
20875: 
20875:   // collation
20875:   nsCOMPtr<nsICollationFactory> cfact =
20875:     do_CreateInstance(NS_COLLATIONFACTORY_CONTRACTID);
20875:   NS_ENSURE_TRUE(cfact, nsnull);
20875:   rv = cfact->CreateCollation(locale, getter_AddRefs(mCollation));
20875:   NS_ENSURE_SUCCESS(rv, nsnull);
20875: 
20875:   return mCollation;
20875: }
20875: 
20877: nsIStringBundle *
20877: nsNavHistory::GetBundle()
20877: {
26467:   if (!mBundle) {
20877:     nsCOMPtr<nsIStringBundleService> bundleService =
20877:       do_GetService(NS_STRINGBUNDLE_CONTRACTID);
20877:     NS_ENSURE_TRUE(bundleService, nsnull);
20877:     nsresult rv = bundleService->CreateBundle(
20877:         "chrome://places/locale/places.properties",
20877:         getter_AddRefs(mBundle));
20877:     NS_ENSURE_SUCCESS(rv, nsnull);
26467:   }
20877:   return mBundle;
20877: }
20877: 
26467: nsIStringBundle *
26467: nsNavHistory::GetDateFormatBundle()
26467: {
26467:   if (!mDateFormatBundle) {
26467:     nsCOMPtr<nsIStringBundleService> bundleService =
26467:       do_GetService(NS_STRINGBUNDLE_CONTRACTID);
26467:     NS_ENSURE_TRUE(bundleService, nsnull);
26467:     nsresult rv = bundleService->CreateBundle(
26467:         "chrome://global/locale/dateFormat.properties",
26467:         getter_AddRefs(mDateFormatBundle));
26467:     NS_ENSURE_SUCCESS(rv, nsnull);
26467:   }
26467:   return mDateFormatBundle;
26467: }
26467: 
20879: mozIStorageStatement *
20879: nsNavHistory::GetDBVisitToVisitResult()
20879: {
20879:   if (mDBVisitToVisitResult)
20879:     return mDBVisitToVisitResult;
20879: 
20879:   // mDBVisitToVisitResult, should match kGetInfoIndex_* (see GetQueryResults)
20879:   // We are not checking for duplicated ids into the unified table
20879:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20879:   // have unique visit ids.
20879:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20879:       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:           "v.visit_date, f.url, v.session, null, null, null, null "
20879:         "FROM moz_places_temp h "
20879:         "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
20879:         "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
20879:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20879:         "WHERE v.id = ?1 OR v_t.id = ?1 "
20879:       "UNION ALL "
20879:       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:           "v.visit_date, f.url, v.session, null, null, null, null "
20879:         "FROM moz_places h "
20879:         "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
20879:         "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
20879:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20879:         "WHERE v.id = ?1 OR v_t.id = ?1 "
20879:       "LIMIT 1"),
20879:     getter_AddRefs(mDBVisitToVisitResult));
20879:   NS_ENSURE_SUCCESS(rv, nsnull);
20879: 
20879:   return mDBVisitToVisitResult;
20879: }
20879: 
20879: mozIStorageStatement *
20879: nsNavHistory::GetDBVisitToURLResult()
20879: {
20879:   if (mDBVisitToURLResult)
20879:     return mDBVisitToURLResult;
20879: 
20879:   // mDBVisitToURLResult, should match kGetInfoIndex_* (see GetQueryResults)
20879:   // We are not checking for duplicated ids into the unified table
20879:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20879:   // have unique visit ids.
20879:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
33458:       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:              "h.last_visit_date, f.url, null, null, null, null, null, null "
20879:         "FROM moz_places_temp h "
20879:         "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
20879:         "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
20879:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20879:         "WHERE v.id = ?1 OR v_t.id = ?1 "
20879:       "UNION ALL "
33458:       "SELECT h.id, h.url, h.title, h.rev_host, h.visit_count, "
33458:              "h.last_visit_date, f.url, null, null, null, null, null, null "
20879:         "FROM moz_places h "
20879:         "LEFT JOIN moz_historyvisits_temp v_t ON h.id = v_t.place_id "
20879:         "LEFT JOIN moz_historyvisits v ON h.id = v.place_id "
20879:         "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20879:         "WHERE v.id = ?1 OR v_t.id = ?1 "
20879:       "LIMIT 1"),
20879:     getter_AddRefs(mDBVisitToURLResult));
20879:   NS_ENSURE_SUCCESS(rv, nsnull);
20879: 
20879:   return mDBVisitToURLResult;
20879: }
20879: 
20880: mozIStorageStatement *
20880: nsNavHistory::GetDBBookmarkToUrlResult()
20880: {
20880:   if (mDBBookmarkToUrlResult)
20880:     return mDBBookmarkToUrlResult;
20880: 
20880:   // mDBBookmarkToUrlResult, should match kGetInfoIndex_*
20880:   // We are not checking for duplicated ids into the unified table
20880:   // for perf reasons, LIMIT 1 will discard duplicates faster since we
20880:   // have unique place ids.
20880:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20880:       "SELECT b.fk, h.url, COALESCE(b.title, h.title), "
28350:         "h.rev_host, h.visit_count, h.last_visit_date, f.url, null, b.id, "
33458:         "b.dateAdded, b.lastModified, b.parent, null "
20880:       "FROM moz_bookmarks b "
20880:       "JOIN moz_places_temp h ON b.fk = h.id "
20880:       "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
20880:       "WHERE b.id = ?1 "
20880:       "UNION ALL "
20880:       "SELECT b.fk, h.url, COALESCE(b.title, h.title), "
28350:         "h.rev_host, h.visit_count, h.last_visit_date, f.url, null, b.id, "
33458:         "b.dateAdded, b.lastModified, b.parent, null "
20880:       "FROM moz_bookmarks b "
20880:       "JOIN moz_places h ON b.fk = h.id "
20880:       "LEFT OUTER JOIN moz_favicons f ON h.favicon_id = f.id "
20880:       "WHERE b.id = ?1 "
20880:       "LIMIT 1"),
20880:     getter_AddRefs(mDBBookmarkToUrlResult));
20880:   NS_ENSURE_SUCCESS(rv, nsnull);
20880: 
20880:   return mDBBookmarkToUrlResult;
20880: }
20880: 
33829: NS_HIDDEN_(nsresult)
21642: nsNavHistory::FinalizeStatements() {
21642:   mozIStorageStatement* stmts[] = {
30902: #ifdef MOZ_XUL
30902:     mDBFeedbackIncrease,
30902: #endif
21642:     mDBGetURLPageInfo,
21642:     mDBGetIdPageInfo,
21642:     mDBRecentVisitOfURL,
21642:     mDBRecentVisitOfPlace,
21642:     mDBInsertVisit,
21642:     mDBGetPageVisitStats,
21642:     mDBIsPageVisited,
21642:     mDBUpdatePageVisitStats,
21642:     mDBAddNewPage,
21642:     mDBGetTags,
33458:     mDBGetItemsWithAnno,
21642:     mDBSetPlaceTitle,
21642:     mDBVisitToURLResult,
21642:     mDBVisitToVisitResult,
21642:     mDBBookmarkToUrlResult,
21642:     mDBVisitsForFrecency,
21642:     mDBUpdateFrecencyAndHidden,
21642:     mDBGetPlaceVisitStats,
21642:     mDBFullVisitCount,
21642:   };
21642: 
21642:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(stmts); i++) {
21642:     nsresult rv = nsNavHistory::FinalizeStatement(stmts[i]);
21642:     NS_ENSURE_SUCCESS(rv, rv);
21642:   }
21642: 
21642:   return NS_OK;
21642: }
21642: 
14062: // nsICharsetResolver **********************************************************
14062: 
14062: NS_IMETHODIMP
14062: nsNavHistory::RequestCharset(nsIWebNavigation* aWebNavigation,
14062:                              nsIChannel* aChannel,
14062:                              PRBool* aWantCharset,
14062:                              nsISupports** aClosure,
14062:                              nsACString& aResult)
14062: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
28236:   NS_ENSURE_ARG(aChannel);
28236:   NS_ENSURE_ARG_POINTER(aWantCharset);
28236:   NS_ENSURE_ARG_POINTER(aClosure);
18819: 
14062:   *aWantCharset = PR_FALSE;
14062:   *aClosure = nsnull;
14062: 
14062:   nsCOMPtr<nsIURI> uri;
14062:   nsresult rv = aChannel->GetURI(getter_AddRefs(uri));
14062:   if (NS_FAILED(rv))
14062:     return NS_OK;
14062: 
14062:   nsAutoString charset;
14062:   rv = GetCharsetForURI(uri, charset);
14062:   NS_ENSURE_SUCCESS(rv, rv);
14062: 
14062:   CopyUTF16toUTF8(charset, aResult);
14062:   return NS_OK;
14062: }
14062: 
14062: NS_IMETHODIMP
14062: nsNavHistory::NotifyResolvedCharset(const nsACString& aCharset,
14062:                                     nsISupports* aClosure)
14062: {
18819:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
18819: 
14062:   NS_ERROR("Unexpected call to NotifyResolvedCharset -- we never set aWantCharset to true!");
14062:   return NS_ERROR_NOT_IMPLEMENTED;
14062: }
