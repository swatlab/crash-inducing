43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@netscape.com> (original author)
43113:  *   Gagan Saksena <gagan@netscape.com>
43113:  *   Pierre Phaneuf <pp@ludusdesign.com>
43113:  *   Christopher Blizzard <blizzard@mozilla.org>
43113:  *   Adrian Havill <havill@redhat.com>
43113:  *   Gervase Markham <gerv@gerv.net>
43113:  *   Bradley Baetz <bbaetz@netscape.com>
43113:  *   Benjamin Smedberg <bsmedberg@covad.net>
43113:  *   Josh Aas <josh@mozilla.com>
51553:  *   DÃ£o Gottwald <dao@mozilla.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsHttp.h"
43113: #include "nsHttpHandler.h"
43113: #include "nsHttpChannel.h"
43113: #include "nsHttpConnection.h"
43113: #include "nsHttpResponseHead.h"
43113: #include "nsHttpTransaction.h"
43113: #include "nsHttpAuthCache.h"
43113: #include "nsStandardURL.h"
43113: #include "nsIHttpChannel.h"
43113: #include "nsIURL.h"
43113: #include "nsIStandardURL.h"
43113: #include "nsICacheService.h"
43113: #include "nsICategoryManager.h"
43113: #include "nsCategoryManagerUtils.h"
43113: #include "nsICacheService.h"
43113: #include "nsIPrefService.h"
43113: #include "nsIPrefBranch2.h"
43113: #include "nsIPrefLocalizedString.h"
43113: #include "nsISocketProviderService.h"
43113: #include "nsISocketProvider.h"
43113: #include "nsPrintfCString.h"
43113: #include "nsCOMPtr.h"
43113: #include "nsNetCID.h"
43113: #include "prprf.h"
43113: #include "nsReadableUtils.h"
43113: #include "nsQuickSort.h"
43113: #include "nsNetUtil.h"
43113: #include "nsIOService.h"
48304: #include "nsAsyncRedirectVerifyHelper.h"
56650: #include "nsSocketTransportService2.h"
81029: #include "nsAlgorithm.h"
43113: 
43113: #include "nsIXULAppInfo.h"
43113: 
46672: #include "mozilla/net/NeckoChild.h"
46672: 
63458: #if defined(XP_UNIX)
43113: #include <sys/utsname.h>
43113: #endif
43113: 
43113: #if defined(XP_WIN)
43113: #include <windows.h>
43113: #endif
43113: 
43113: #if defined(XP_MACOSX)
43113: #include <CoreServices/CoreServices.h>
43113: #endif
43113: 
43113: #if defined(XP_OS2)
43113: #define INCL_DOSMISC
43113: #include <os2.h>
43113: #endif
43113: 
46517: //-----------------------------------------------------------------------------
81029: using namespace mozilla;
46790: using namespace mozilla::net;
46672: #include "mozilla/net/HttpChannelChild.h"
46517: 
43113: #include "mozilla/FunctionTimer.h"
43113: 
43113: #ifdef DEBUG
43113: // defined by the socket transport service while active
43113: extern PRThread *gSocketThread;
43113: #endif
43113: 
43113: static NS_DEFINE_CID(kIOServiceCID, NS_IOSERVICE_CID);
43113: static NS_DEFINE_CID(kStreamConverterServiceCID, NS_STREAMCONVERTERSERVICE_CID);
43113: static NS_DEFINE_CID(kCookieServiceCID, NS_COOKIESERVICE_CID);
43113: static NS_DEFINE_CID(kCacheServiceCID, NS_CACHESERVICE_CID);
43113: static NS_DEFINE_CID(kSocketProviderServiceCID, NS_SOCKETPROVIDERSERVICE_CID);
43113: 
43113: #define UA_PREF_PREFIX          "general.useragent."
48898: #ifdef XP_WIN
48898: #define UA_SPARE_PLATFORM
48898: #endif
43113: 
43113: #define HTTP_PREF_PREFIX        "network.http."
43113: #define INTL_ACCEPT_LANGUAGES   "intl.accept_languages"
43113: #define NETWORK_ENABLEIDN       "network.enableIDN"
43113: #define BROWSER_PREF_PREFIX     "browser.cache."
61491: #define DONOTTRACK_HEADER_ENABLED "privacy.donottrackheader.enabled"
43113: 
43113: #define UA_PREF(_pref) UA_PREF_PREFIX _pref
43113: #define HTTP_PREF(_pref) HTTP_PREF_PREFIX _pref
43113: #define BROWSER_PREF(_pref) BROWSER_PREF_PREFIX _pref
43113: 
43113: #define NS_HTTP_PROTOCOL_FLAGS (URI_STD | ALLOWS_PROXY | ALLOWS_PROXY_HTTP | URI_LOADABLE_BY_ANYONE)
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: static nsresult
43113: NewURI(const nsACString &aSpec,
43113:        const char *aCharset,
43113:        nsIURI *aBaseURI,
43113:        PRInt32 aDefaultPort,
43113:        nsIURI **aURI)
43113: {
43113:     nsStandardURL *url = new nsStandardURL();
43113:     if (!url)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     NS_ADDREF(url);
43113: 
43113:     nsresult rv = url->Init(nsIStandardURL::URLTYPE_AUTHORITY,
43113:                             aDefaultPort, aSpec, aCharset, aBaseURI);
43113:     if (NS_FAILED(rv)) {
43113:         NS_RELEASE(url);
43113:         return rv;
43113:     }
43113: 
43113:     *aURI = url; // no QI needed
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler <public>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpHandler *gHttpHandler = nsnull;
43113: 
43113: nsHttpHandler::nsHttpHandler()
43113:     : mConnMgr(nsnull)
43113:     , mHttpVersion(NS_HTTP_VERSION_1_1)
43113:     , mProxyHttpVersion(NS_HTTP_VERSION_1_1)
43113:     , mCapabilities(NS_HTTP_ALLOW_KEEPALIVE)
43113:     , mProxyCapabilities(NS_HTTP_ALLOW_KEEPALIVE)
43113:     , mReferrerLevel(0xff) // by default we always send a referrer
80486:     , mFastFallbackToIPv4(false)
43113:     , mIdleTimeout(10)
43113:     , mMaxRequestAttempts(10)
43113:     , mMaxRequestDelay(10)
64613:     , mIdleSynTimeout(250)
43113:     , mMaxConnections(24)
43113:     , mMaxConnectionsPerServer(8)
43113:     , mMaxPersistentConnectionsPerServer(2)
43113:     , mMaxPersistentConnectionsPerProxy(4)
43113:     , mMaxPipelinedRequests(2)
43113:     , mRedirectionLimit(10)
43113:     , mPhishyUserPassLength(1)
43113:     , mQoSBits(0x00)
80486:     , mPipeliningOverSSL(false)
58165:     , mInPrivateBrowsingMode(PRIVATE_BROWSING_UNKNOWN)
43113:     , mLastUniqueID(NowInSeconds())
43113:     , mSessionStartTime(0)
51553:     , mLegacyAppName("Mozilla")
51553:     , mLegacyAppVersion("5.0")
51719:     , mProduct("Gecko")
80486:     , mUserAgentIsDirty(true)
80486:     , mUseCache(true)
80486:     , mPromptTempRedirect(true)
80486:     , mSendSecureXSiteReferrer(true)
80486:     , mEnablePersistentHttpsCaching(false)
80486:     , mDoNotTrackEnabled(false)
43113: {
43113: #if defined(PR_LOGGING)
43113:     gHttpLog = PR_NewLogModule("nsHttp");
43113: #endif
43113: 
43113:     LOG(("Creating nsHttpHandler [this=%x].\n", this));
43113: 
43113:     NS_ASSERTION(!gHttpHandler, "HTTP handler already created!");
43113:     gHttpHandler = this;
43113: }
43113: 
43113: nsHttpHandler::~nsHttpHandler()
43113: {
43113:     LOG(("Deleting nsHttpHandler [this=%x]\n", this));
43113: 
43113:     // make sure the connection manager is shutdown
43113:     if (mConnMgr) {
43113:         mConnMgr->Shutdown();
43113:         NS_RELEASE(mConnMgr);
43113:     }
43113: 
46672:     // Note: don't call NeckoChild::DestroyNeckoChild() here, as it's too late
46672:     // and it'll segfault.  NeckoChild will get cleaned up by process exit.
46672: 
43113:     nsHttp::DestroyAtomTable();
43113: 
43113:     gHttpHandler = nsnull;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::Init()
43113: {
43113:     NS_TIME_FUNCTION;
43113: 
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpHandler::Init\n"));
43113: 
43113:     rv = nsHttp::CreateAtomTable();
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     mIOService = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) {
43113:         NS_WARNING("unable to continue without io service");
43113:         return rv;
43113:     }
43113: 
46672:     if (IsNeckoChild())
46517:         NeckoChild::InitNeckoChild();
46517: 
43113:     InitUserAgentComponents();
43113: 
43113:     // monitor some preference changes
43113:     nsCOMPtr<nsIPrefBranch2> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:     if (prefBranch) {
80486:         prefBranch->AddObserver(HTTP_PREF_PREFIX, this, true);
80486:         prefBranch->AddObserver(UA_PREF_PREFIX, this, true);
80486:         prefBranch->AddObserver(INTL_ACCEPT_LANGUAGES, this, true); 
80486:         prefBranch->AddObserver(NETWORK_ENABLEIDN, this, true);
80486:         prefBranch->AddObserver(BROWSER_PREF("disk_cache_ssl"), this, true);
80486:         prefBranch->AddObserver(DONOTTRACK_HEADER_ENABLED, this, true);
43113: 
43113:         PrefsChanged(prefBranch, nsnull);
43113:     }
43113: 
43113:     mMisc.AssignLiteral("rv:" MOZILLA_VERSION);
43113: 
51553:     nsCOMPtr<nsIXULAppInfo> appInfo =
51553:         do_GetService("@mozilla.org/xre/app-info;1");
51553: 
51553:     mAppName.AssignLiteral(MOZ_APP_UA_NAME);
51553:     if (mAppName.Length() == 0 && appInfo) {
51553:         appInfo->GetName(mAppName);
51553:         appInfo->GetVersion(mAppVersion);
51889:         mAppName.StripChars(" ()<>@,;:\\\"/[]?={}");
51553:     } else {
51732:         mAppVersion.AssignLiteral(MOZ_APP_UA_VERSION);
51553:     }
51553: 
43113: #if DEBUG
43113:     // dump user agent prefs
51553:     LOG(("> legacy-app-name = %s\n", mLegacyAppName.get()));
51553:     LOG(("> legacy-app-version = %s\n", mLegacyAppVersion.get()));
43113:     LOG(("> platform = %s\n", mPlatform.get()));
43113:     LOG(("> oscpu = %s\n", mOscpu.get()));
43113:     LOG(("> misc = %s\n", mMisc.get()));
43113:     LOG(("> product = %s\n", mProduct.get()));
43113:     LOG(("> product-sub = %s\n", mProductSub.get()));
51553:     LOG(("> app-name = %s\n", mAppName.get()));
51553:     LOG(("> app-version = %s\n", mAppVersion.get()));
51553:     LOG(("> compat-firefox = %s\n", mCompatFirefox.get()));
43113:     LOG(("> user-agent = %s\n", UserAgent().get()));
43113: #endif
43113: 
43113:     mSessionStartTime = NowInSeconds();
43113: 
43113:     rv = mAuthCache.Init();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = InitConnectionMgr();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
51719:     mProductSub.AssignLiteral(MOZ_UA_BUILDID);
51719:     if (mProductSub.IsEmpty() && appInfo)
43113:         appInfo->GetPlatformBuildID(mProductSub);
43113:     if (mProductSub.Length() > 8)
43113:         mProductSub.SetLength(8);
43113: 
43113:     // Startup the http category
43113:     // Bring alive the objects in the http-protocol-startup category
43113:     NS_CreateServicesFromCategory(NS_HTTP_STARTUP_CATEGORY,
43113:                                   static_cast<nsISupports*>(static_cast<void*>(this)),
43113:                                   NS_HTTP_STARTUP_TOPIC);    
43113:     
43113:     mObserverService = mozilla::services::GetObserverService();
43113:     if (mObserverService) {
80486:         mObserverService->AddObserver(this, "profile-change-net-teardown", true);
80486:         mObserverService->AddObserver(this, "profile-change-net-restore", true);
80486:         mObserverService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, true);
80486:         mObserverService->AddObserver(this, "net:clear-active-logins", true);
80486:         mObserverService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, true);
80486:         mObserverService->AddObserver(this, "net:prune-dead-connections", true);
43113:     }
43113:  
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::InitConnectionMgr()
43113: {
43113:     NS_TIME_FUNCTION;
43113: 
43113:     nsresult rv;
43113: 
43113:     if (!mConnMgr) {
43113:         mConnMgr = new nsHttpConnectionMgr();
43113:         if (!mConnMgr)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         NS_ADDREF(mConnMgr);
43113:     }
43113: 
43113:     rv = mConnMgr->Init(mMaxConnections,
43113:                         mMaxConnectionsPerServer,
43113:                         mMaxConnectionsPerServer,
43113:                         mMaxPersistentConnectionsPerServer,
43113:                         mMaxPersistentConnectionsPerProxy,
43113:                         mMaxRequestDelay,
43113:                         mMaxPipelinedRequests);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::AddStandardRequestHeaders(nsHttpHeaderArray *request,
43113:                                          PRUint8 caps,
79445:                                          bool useProxy)
43113: {
43113:     nsresult rv;
43113: 
43113:     // Add the "User-Agent" header
43113:     rv = request->SetHeader(nsHttp::User_Agent, UserAgent());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // MIME based content negotiation lives!
43113:     // Add the "Accept" header
43113:     rv = request->SetHeader(nsHttp::Accept, mAccept);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // Add the "Accept-Language" header
43113:     if (!mAcceptLanguages.IsEmpty()) {
43113:         // Add the "Accept-Language" header
43113:         rv = request->SetHeader(nsHttp::Accept_Language, mAcceptLanguages);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     // Add the "Accept-Encoding" header
43113:     rv = request->SetHeader(nsHttp::Accept_Encoding, mAcceptEncodings);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // RFC2616 section 19.6.2 states that the "Connection: keep-alive"
43113:     // and "Keep-alive" request headers should not be sent by HTTP/1.1
43113:     // user-agents.  Otherwise, problems with proxy servers (especially
43113:     // transparent proxies) can result.
43113:     //
43113:     // However, we need to send something so that we can use keepalive
43113:     // with HTTP/1.0 servers/proxies. We use "Proxy-Connection:" when 
64672:     // we're talking to an http proxy, and "Connection:" otherwise.
64672:     // We no longer send the Keep-Alive request header.
43113:     
43113:     NS_NAMED_LITERAL_CSTRING(close, "close");
43113:     NS_NAMED_LITERAL_CSTRING(keepAlive, "keep-alive");
43113: 
43113:     const nsACString *connectionType = &close;
43113:     if (caps & NS_HTTP_ALLOW_KEEPALIVE) {
43113:         connectionType = &keepAlive;
43113:     } else if (useProxy) {
43113:         // Bug 92006
43113:         request->SetHeader(nsHttp::Connection, close);
43113:     }
43113: 
61491:     // Add the "Do-Not-Track" header
61491:     if (mDoNotTrackEnabled) {
61491:       rv = request->SetHeader(nsHttp::DoNotTrack,
61491:                               NS_LITERAL_CSTRING("1"));
61491:       if (NS_FAILED(rv)) return rv;
61491:     }
61491: 
43113:     const nsHttpAtom &header = useProxy ? nsHttp::Proxy_Connection
43113:                                         : nsHttp::Connection;
43113:     return request->SetHeader(header, *connectionType);
43113: }
43113: 
79445: bool
43113: nsHttpHandler::IsAcceptableEncoding(const char *enc)
43113: {
43113:     if (!enc)
80486:         return false;
43113: 
43113:     // HTTP 1.1 allows servers to send x-gzip and x-compress instead
43113:     // of gzip and compress, for example.  So, we'll always strip off
43113:     // an "x-" prefix before matching the encoding to one we claim
43113:     // to accept.
43113:     if (!PL_strncasecmp(enc, "x-", 2))
43113:         enc += 2;
43113:     
43113:     return nsHttp::FindToken(mAcceptEncodings.get(), enc, HTTP_LWS ",") != nsnull;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::GetCacheSession(nsCacheStoragePolicy storagePolicy,
43113:                                nsICacheSession **result)
43113: {
43113:     nsresult rv;
43113: 
43113:     // Skip cache if disabled in preferences
43113:     if (!mUseCache)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     // We want to get the pointer to the cache service each time we're called,
43113:     // because it's possible for some add-ons (such as Google Gears) to swap
43113:     // in new cache services on the fly, and we want to pick them up as
43113:     // appropriate.
43113:     nsCOMPtr<nsICacheService> serv = do_GetService(NS_CACHESERVICE_CONTRACTID,
43113:                                                    &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     const char *sessionName = "HTTP";
43113:     switch (storagePolicy) {
43113:     case nsICache::STORE_IN_MEMORY:
43113:         sessionName = "HTTP-memory-only";
43113:         break;
43113:     case nsICache::STORE_OFFLINE:
43113:         sessionName = "HTTP-offline";
43113:         break;
43113:     default:
43113:         break;
43113:     }
43113: 
43113:     nsCOMPtr<nsICacheSession> cacheSession;
43113:     rv = serv->CreateSession(sessionName,
43113:                              storagePolicy,
43113:                              nsICache::STREAM_BASED,
43113:                              getter_AddRefs(cacheSession));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
80486:     rv = cacheSession->SetDoomEntriesIfExpired(false);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     NS_ADDREF(*result = cacheSession);
43113: 
43113:     return NS_OK;
43113: }
43113: 
79445: bool
58165: nsHttpHandler::InPrivateBrowsingMode()
58165: {
58165:     if (PRIVATE_BROWSING_UNKNOWN == mInPrivateBrowsingMode) {
58165:         // figure out if we're starting in private browsing mode
58165:         nsCOMPtr<nsIPrivateBrowsingService> pbs =
58165:             do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
58165:         if (!pbs)
58165:             return PRIVATE_BROWSING_OFF;
58165: 
79445:         bool p = false;
58165:         pbs->GetPrivateBrowsingEnabled(&p);
58165:         mInPrivateBrowsingMode = p ? PRIVATE_BROWSING_ON : PRIVATE_BROWSING_OFF;
58165:     }
58165:     return PRIVATE_BROWSING_ON == mInPrivateBrowsingMode;
58165: }
58165: 
43113: nsresult
43113: nsHttpHandler::GetStreamConverterService(nsIStreamConverterService **result)
43113: {
43113:     if (!mStreamConvSvc) {
43113:         nsresult rv;
43113:         mStreamConvSvc = do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113:     *result = mStreamConvSvc;
43113:     NS_ADDREF(*result);
43113:     return NS_OK;
43113: }
43113: 
51363: nsIStrictTransportSecurityService*
51363: nsHttpHandler::GetSTSService()
51363: {
51363:     if (!mSTSService)
51363:       mSTSService = do_GetService(NS_STSSERVICE_CONTRACTID);
51363:     return mSTSService;
51363: }
51363: 
43113: nsICookieService *
43113: nsHttpHandler::GetCookieService()
43113: {
43113:     if (!mCookieService)
43113:         mCookieService = do_GetService(NS_COOKIESERVICE_CONTRACTID);
43113:     return mCookieService;
43113: }
43113: 
43113: nsresult 
43113: nsHttpHandler::GetIOService(nsIIOService** result)
43113: {
43113:     NS_ADDREF(*result = mIOService);
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsHttpHandler::NotifyObservers(nsIHttpChannel *chan, const char *event)
43113: {
43113:     LOG(("nsHttpHandler::NotifyObservers [chan=%x event=\"%s\"]\n", chan, event));
43113:     if (mObserverService)
43113:         mObserverService->NotifyObservers(chan, event, nsnull);
43113: }
43113: 
43113: nsresult
48304: nsHttpHandler::AsyncOnChannelRedirect(nsIChannel* oldChan, nsIChannel* newChan,
43113:                                  PRUint32 flags)
43113: {
48304:     // TODO E10S This helper has to be initialized on the other process
48304:     nsRefPtr<nsAsyncRedirectVerifyHelper> redirectCallbackHelper =
48304:         new nsAsyncRedirectVerifyHelper();
43113: 
48304:     return redirectCallbackHelper->Init(oldChan, newChan, flags);
43113: }
43113: 
43113: /* static */ nsresult
43113: nsHttpHandler::GenerateHostPort(const nsCString& host, PRInt32 port,
43113:                                 nsCString& hostLine)
43113: {
43113:     if (strchr(host.get(), ':')) {
43113:         // host is an IPv6 address literal and must be encapsulated in []'s
43113:         hostLine.Assign('[');
43113:         // scope id is not needed for Host header.
43113:         int scopeIdPos = host.FindChar('%');
43113:         if (scopeIdPos == kNotFound)
43113:             hostLine.Append(host);
43113:         else if (scopeIdPos > 0)
43113:             hostLine.Append(Substring(host, 0, scopeIdPos));
43113:         else
43113:           return NS_ERROR_MALFORMED_URI;
43113:         hostLine.Append(']');
43113:     }
43113:     else
43113:         hostLine.Assign(host);
43113:     if (port != -1) {
43113:         hostLine.Append(':');
43113:         hostLine.AppendInt(port);
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler <private>
43113: //-----------------------------------------------------------------------------
43113: 
43113: const nsAFlatCString &
43113: nsHttpHandler::UserAgent()
43113: {
43113:     if (mUserAgentOverride) {
43113:         LOG(("using general.useragent.override : %s\n", mUserAgentOverride.get()));
43113:         return mUserAgentOverride;
43113:     }
43113: 
43113:     if (mUserAgentIsDirty) {
43113:         BuildUserAgent();
80486:         mUserAgentIsDirty = false;
43113:     }
43113: 
43113:     return mUserAgent;
43113: }
43113: 
43113: void
43113: nsHttpHandler::BuildUserAgent()
43113: {
43113:     LOG(("nsHttpHandler::BuildUserAgent\n"));
43113: 
51553:     NS_ASSERTION(!mLegacyAppName.IsEmpty() &&
51553:                  !mLegacyAppVersion.IsEmpty() &&
43113:                  !mPlatform.IsEmpty() &&
43113:                  !mOscpu.IsEmpty(),
43113:                  "HTTP cannot send practical requests without this much");
43113: 
43113:     // preallocate to worst-case size, which should always be better
43113:     // than if we didn't preallocate at all.
51553:     mUserAgent.SetCapacity(mLegacyAppName.Length() + 
51553:                            mLegacyAppVersion.Length() + 
48898: #ifndef UA_SPARE_PLATFORM
43113:                            mPlatform.Length() + 
48898: #endif
43113:                            mOscpu.Length() +
43113:                            mMisc.Length() +
43113:                            mProduct.Length() +
43113:                            mProductSub.Length() +
51553:                            mAppName.Length() +
51553:                            mAppVersion.Length() +
51553:                            mCompatFirefox.Length() +
55839:                            13);
43113: 
43113:     // Application portion
51553:     mUserAgent.Assign(mLegacyAppName);
43113:     mUserAgent += '/';
51553:     mUserAgent += mLegacyAppVersion;
43113:     mUserAgent += ' ';
43113: 
43113:     // Application comment
43113:     mUserAgent += '(';
48898: #ifndef UA_SPARE_PLATFORM
43113:     mUserAgent += mPlatform;
43113:     mUserAgent.AppendLiteral("; ");
48898: #endif
43113:     mUserAgent += mOscpu;
43113:     mUserAgent.AppendLiteral("; ");
43113:     mUserAgent += mMisc;
43113:     mUserAgent += ')';
43113: 
43113:     // Product portion
43113:     mUserAgent += ' ';
43113:     mUserAgent += mProduct;
43113:     mUserAgent += '/';
43113:     mUserAgent += mProductSub;
43113: 
51554:     // "Firefox/x.y.z" compatibility token
51554:     if (!mCompatFirefox.IsEmpty()) {
51554:         mUserAgent += ' ';
51554:         mUserAgent += mCompatFirefox;
51554:     }
51554: 
51554:     // App portion
51554:     mUserAgent += ' ';
51554:     mUserAgent += mAppName;
51554:     mUserAgent += '/';
51554:     mUserAgent += mAppVersion;
43113: }
43113: 
43113: #ifdef XP_WIN
43113: typedef BOOL (WINAPI *IsWow64ProcessP) (HANDLE, PBOOL);
43113: 
43113: #define WNT_BASE "Windows NT %ld.%ld"
43113: #define W64_PREFIX "; Win64"
43113: #endif
43113: 
43113: void
43113: nsHttpHandler::InitUserAgentComponents()
43113: {
43113: 
43113:       // Gather platform.
43113:     mPlatform.AssignLiteral(
43113: #if defined(ANDROID)
43113:     "Android"
43113: #elif defined(XP_OS2)
43113:     "OS/2"
43113: #elif defined(XP_WIN)
43113:     "Windows"
43113: #elif defined(XP_MACOSX)
43113:     "Macintosh"
51502: #elif defined(MOZ_PLATFORM_MAEMO)
51502:     "Maemo"
43113: #elif defined(MOZ_X11)
43113:     "X11"
43113: #else
43113:     "?"
43113: #endif
43113:     );
43113: 
43113:     // Gather OS/CPU.
43113: #if defined(XP_OS2)
43113:     ULONG os2ver = 0;
43113:     DosQuerySysInfo(QSV_VERSION_MINOR, QSV_VERSION_MINOR,
43113:                     &os2ver, sizeof(os2ver));
43113:     if (os2ver == 11)
43113:         mOscpu.AssignLiteral("2.11");
43113:     else if (os2ver == 30)
43113:         mOscpu.AssignLiteral("Warp 3");
43113:     else if (os2ver == 40)
43113:         mOscpu.AssignLiteral("Warp 4");
43113:     else if (os2ver == 45)
43113:         mOscpu.AssignLiteral("Warp 4.5");
43113: 
69468: #elif defined(XP_WIN)
43113:     OSVERSIONINFO info = { sizeof(OSVERSIONINFO) };
43113:     if (GetVersionEx(&info)) {
43113:         const char *format;
69468: #if defined _M_IA64
43113:         format = WNT_BASE W64_PREFIX "; IA64";
43113: #elif defined _M_X64 || defined _M_AMD64
43113:         format = WNT_BASE W64_PREFIX "; x64";
43113: #else
43113:         BOOL isWow64 = FALSE;
43113:         IsWow64ProcessP fnIsWow64Process = (IsWow64ProcessP)
43113:           GetProcAddress(GetModuleHandleW(L"kernel32"), "IsWow64Process");
43113:         if (fnIsWow64Process &&
43113:             !fnIsWow64Process(GetCurrentProcess(), &isWow64)) {
43113:             isWow64 = FALSE;
43113:         }
43113:         format = isWow64
43113:           ? WNT_BASE "; WOW64"
43113:           : WNT_BASE;
43113: #endif
43113:         char *buf = PR_smprintf(format,
43113:                                 info.dwMajorVersion,
43113:                                 info.dwMinorVersion);
43113:         if (buf) {
43113:             mOscpu = buf;
43113:             PR_smprintf_free(buf);
43113:         }
43113:     }
43113: #elif defined (XP_MACOSX)
43113: #if defined(__ppc__)
43113:     mOscpu.AssignLiteral("PPC Mac OS X");
43113: #elif defined(__i386__) || defined(__x86_64__)
43113:     mOscpu.AssignLiteral("Intel Mac OS X");
43113: #endif
43113:     SInt32 majorVersion, minorVersion;
43113:     if ((::Gestalt(gestaltSystemVersionMajor, &majorVersion) == noErr) &&
43113:         (::Gestalt(gestaltSystemVersionMinor, &minorVersion) == noErr)) {
43113:         mOscpu += nsPrintfCString(" %d.%d", majorVersion, minorVersion);
43113:     }
63458: #elif defined (XP_UNIX)
43113:     struct utsname name;
43113:     
43113:     int ret = uname(&name);
43113:     if (ret >= 0) {
43113:         nsCAutoString buf;
43113:         buf =  (char*)name.sysname;
43113: 
43113:         if (strcmp(name.machine, "x86_64") == 0 &&
43113:             sizeof(void *) == sizeof(PRInt32)) {
43113:             // We're running 32-bit code on x86_64. Make this browser
43113:             // look like it's running on i686 hardware, but append "
43113:             // (x86_64)" to the end of the oscpu identifier to be able
43113:             // to differentiate this from someone running 64-bit code
43113:             // on x86_64..
43113: 
51573:             buf += " i686 on x86_64";
43113:         } else {
43113:             buf += ' ';
43113: 
43113: #ifdef AIX
43113:             // AIX uname returns machine specific info in the uname.machine
43113:             // field and does not return the cpu type like other platforms.
43113:             // We use the AIX version and release numbers instead.
43113:             buf += (char*)name.version;
43113:             buf += '.';
43113:             buf += (char*)name.release;
43113: #else
43113:             buf += (char*)name.machine;
43113: #endif
43113:         }
43113: 
43113:         mOscpu.Assign(buf);
43113:     }
43113: #endif
43113: 
80486:     mUserAgentIsDirty = true;
43113: }
43113: 
80847: PRUint32
80847: nsHttpHandler::MaxSocketCount()
80847: {
80847:     PR_CallOnce(&nsSocketTransportService::gMaxCountInitOnce,
80847:                 nsSocketTransportService::DiscoverMaxCount);
80847:     // Don't use the full max count because sockets can be held in
80847:     // the persistent connection pool for a long time and that could
80847:     // starve other users.
80847: 
80847:     PRUint32 maxCount = nsSocketTransportService::gMaxCount;
80847:     if (maxCount <= 8)
80847:         maxCount = 1;
80847:     else
80847:         maxCount -= 8;
80847: 
80847:     return maxCount;
80847: }
80847: 
43113: void
43113: nsHttpHandler::PrefsChanged(nsIPrefBranch *prefs, const char *pref)
43113: {
43113:     nsresult rv = NS_OK;
43113:     PRInt32 val;
43113: 
43113:     LOG(("nsHttpHandler::PrefsChanged [pref=%s]\n", pref));
43113: 
43113: #define PREF_CHANGED(p) ((pref == nsnull) || !PL_strcmp(pref, p))
43113: #define MULTI_PREF_CHANGED(p) \
43113:   ((pref == nsnull) || !PL_strncmp(pref, p, sizeof(p) - 1))
43113: 
43113:     //
43113:     // UA components
43113:     //
43113: 
79445:     bool cVar = false;
51553: 
51553:     if (PREF_CHANGED(UA_PREF("compatMode.firefox"))) {
51553:         rv = prefs->GetBoolPref(UA_PREF("compatMode.firefox"), &cVar);
51553:         if (NS_SUCCEEDED(rv) && cVar) {
51675:             mCompatFirefox.AssignLiteral("Firefox/" MOZ_UA_FIREFOX_VERSION);
51553:         } else {
51553:             mCompatFirefox.Truncate();
43113:         }
80486:         mUserAgentIsDirty = true;
43113:     }
43113: 
43113:     // general.useragent.override
43113:     if (PREF_CHANGED(UA_PREF("override"))) {
43113:         prefs->GetCharPref(UA_PREF("override"),
43113:                             getter_Copies(mUserAgentOverride));
80486:         mUserAgentIsDirty = true;
43113:     }
43113: 
43113:     //
43113:     // HTTP options
43113:     //
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("keep-alive.timeout"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("keep-alive.timeout"), &val);
43113:         if (NS_SUCCEEDED(rv))
81029:             mIdleTimeout = (PRUint16) clamped(val, 1, 0xffff);
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("request.max-attempts"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("request.max-attempts"), &val);
43113:         if (NS_SUCCEEDED(rv))
81029:             mMaxRequestAttempts = (PRUint16) clamped(val, 1, 0xffff);
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("request.max-start-delay"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("request.max-start-delay"), &val);
43113:         if (NS_SUCCEEDED(rv)) {
81029:             mMaxRequestDelay = (PRUint16) clamped(val, 0, 0xffff);
43113:             if (mConnMgr)
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_REQUEST_DELAY,
43113:                                       mMaxRequestDelay);
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("max-connections"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("max-connections"), &val);
43113:         if (NS_SUCCEEDED(rv)) {
80847: 
81029:             mMaxConnections = (PRUint16) clamped((PRUint32)val,
81029:                                                  (PRUint32)1, MaxSocketCount());
80847: 
43113:             if (mConnMgr)
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS,
43113:                                       mMaxConnections);
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("max-connections-per-server"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("max-connections-per-server"), &val);
43113:         if (NS_SUCCEEDED(rv)) {
81029:             mMaxConnectionsPerServer = (PRUint8) clamped(val, 1, 0xff);
43113:             if (mConnMgr) {
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS_PER_HOST,
43113:                                       mMaxConnectionsPerServer);
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS_PER_PROXY,
43113:                                       mMaxConnectionsPerServer);
43113:             }
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("max-persistent-connections-per-server"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("max-persistent-connections-per-server"), &val);
43113:         if (NS_SUCCEEDED(rv)) {
81029:             mMaxPersistentConnectionsPerServer = (PRUint8) clamped(val, 1, 0xff);
43113:             if (mConnMgr)
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PERSISTENT_CONNECTIONS_PER_HOST,
43113:                                       mMaxPersistentConnectionsPerServer);
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("max-persistent-connections-per-proxy"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("max-persistent-connections-per-proxy"), &val);
43113:         if (NS_SUCCEEDED(rv)) {
81029:             mMaxPersistentConnectionsPerProxy = (PRUint8) clamped(val, 1, 0xff);
43113:             if (mConnMgr)
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PERSISTENT_CONNECTIONS_PER_PROXY,
43113:                                       mMaxPersistentConnectionsPerProxy);
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("sendRefererHeader"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("sendRefererHeader"), &val);
43113:         if (NS_SUCCEEDED(rv))
81029:             mReferrerLevel = (PRUint8) clamped(val, 0, 0xff);
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("redirection-limit"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("redirection-limit"), &val);
43113:         if (NS_SUCCEEDED(rv))
81029:             mRedirectionLimit = (PRUint8) clamped(val, 0, 0xff);
43113:     }
43113: 
64613:     if (PREF_CHANGED(HTTP_PREF("connection-retry-timeout"))) {
64613:         rv = prefs->GetIntPref(HTTP_PREF("connection-retry-timeout"), &val);
64613:         if (NS_SUCCEEDED(rv))
81029:             mIdleSynTimeout = (PRUint16) clamped(val, 0, 3000);
64613:     }
64613: 
77314:     if (PREF_CHANGED(HTTP_PREF("fast-fallback-to-IPv4"))) {
77314:         rv = prefs->GetBoolPref(HTTP_PREF("fast-fallback-to-IPv4"), &cVar);
77314:         if (NS_SUCCEEDED(rv))
77314:             mFastFallbackToIPv4 = cVar;
77314:     }
77314: 
43113:     if (PREF_CHANGED(HTTP_PREF("version"))) {
43113:         nsXPIDLCString httpVersion;
43113:         prefs->GetCharPref(HTTP_PREF("version"), getter_Copies(httpVersion));
43113:         if (httpVersion) {
43113:             if (!PL_strcmp(httpVersion, "1.1"))
43113:                 mHttpVersion = NS_HTTP_VERSION_1_1;
43113:             else if (!PL_strcmp(httpVersion, "0.9"))
43113:                 mHttpVersion = NS_HTTP_VERSION_0_9;
43113:             else
43113:                 mHttpVersion = NS_HTTP_VERSION_1_0;
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("proxy.version"))) {
43113:         nsXPIDLCString httpVersion;
43113:         prefs->GetCharPref(HTTP_PREF("proxy.version"), getter_Copies(httpVersion));
43113:         if (httpVersion) {
43113:             if (!PL_strcmp(httpVersion, "1.1"))
43113:                 mProxyHttpVersion = NS_HTTP_VERSION_1_1;
43113:             else
43113:                 mProxyHttpVersion = NS_HTTP_VERSION_1_0;
43113:             // it does not make sense to issue a HTTP/0.9 request to a proxy server
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("keep-alive"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("keep-alive"), &cVar);
43113:         if (NS_SUCCEEDED(rv)) {
43113:             if (cVar)
43113:                 mCapabilities |= NS_HTTP_ALLOW_KEEPALIVE;
43113:             else
43113:                 mCapabilities &= ~NS_HTTP_ALLOW_KEEPALIVE;
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("proxy.keep-alive"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("proxy.keep-alive"), &cVar);
43113:         if (NS_SUCCEEDED(rv)) {
43113:             if (cVar)
43113:                 mProxyCapabilities |= NS_HTTP_ALLOW_KEEPALIVE;
43113:             else
43113:                 mProxyCapabilities &= ~NS_HTTP_ALLOW_KEEPALIVE;
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("pipelining"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining"), &cVar);
43113:         if (NS_SUCCEEDED(rv)) {
43113:             if (cVar)
43113:                 mCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
43113:             else
43113:                 mCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("pipelining.maxrequests"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("pipelining.maxrequests"), &val);
43113:         if (NS_SUCCEEDED(rv)) {
81029:             mMaxPipelinedRequests = clamped(val, 1, NS_HTTP_MAX_PIPELINED_REQUESTS);
43113:             if (mConnMgr)
43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PIPELINED_REQUESTS,
43113:                                       mMaxPipelinedRequests);
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("pipelining.ssl"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining.ssl"), &cVar);
43113:         if (NS_SUCCEEDED(rv))
43113:             mPipeliningOverSSL = cVar;
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("proxy.pipelining"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("proxy.pipelining"), &cVar);
43113:         if (NS_SUCCEEDED(rv)) {
43113:             if (cVar)
43113:                 mProxyCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
43113:             else
43113:                 mProxyCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("qos"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("qos"), &val);
43113:         if (NS_SUCCEEDED(rv))
81029:             mQoSBits = (PRUint8) clamped(val, 0, 0xff);
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("sendSecureXSiteReferrer"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("sendSecureXSiteReferrer"), &cVar);
43113:         if (NS_SUCCEEDED(rv))
43113:             mSendSecureXSiteReferrer = cVar;
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("accept.default"))) {
43113:         nsXPIDLCString accept;
43113:         rv = prefs->GetCharPref(HTTP_PREF("accept.default"),
43113:                                   getter_Copies(accept));
43113:         if (NS_SUCCEEDED(rv))
43113:             SetAccept(accept);
43113:     }
43113:     
43113:     if (PREF_CHANGED(HTTP_PREF("accept-encoding"))) {
43113:         nsXPIDLCString acceptEncodings;
43113:         rv = prefs->GetCharPref(HTTP_PREF("accept-encoding"),
43113:                                   getter_Copies(acceptEncodings));
43113:         if (NS_SUCCEEDED(rv))
43113:             SetAcceptEncodings(acceptEncodings);
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("use-cache"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("use-cache"), &cVar);
43113:         if (NS_SUCCEEDED(rv)) {
43113:             mUseCache = cVar;
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("default-socket-type"))) {
43113:         nsXPIDLCString sval;
43113:         rv = prefs->GetCharPref(HTTP_PREF("default-socket-type"),
43113:                                 getter_Copies(sval));
43113:         if (NS_SUCCEEDED(rv)) {
43113:             if (sval.IsEmpty())
43113:                 mDefaultSocketType.Adopt(0);
43113:             else {
43113:                 // verify that this socket type is actually valid
43113:                 nsCOMPtr<nsISocketProviderService> sps(
43113:                         do_GetService(NS_SOCKETPROVIDERSERVICE_CONTRACTID));
43113:                 if (sps) {
43113:                     nsCOMPtr<nsISocketProvider> sp;
43113:                     rv = sps->GetSocketProvider(sval, getter_AddRefs(sp));
43113:                     if (NS_SUCCEEDED(rv)) {
43113:                         // OK, this looks like a valid socket provider.
43113:                         mDefaultSocketType.Assign(sval);
43113:                     }
43113:                 }
43113:             }
43113:         }
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("prompt-temp-redirect"))) {
43113:         rv = prefs->GetBoolPref(HTTP_PREF("prompt-temp-redirect"), &cVar);
43113:         if (NS_SUCCEEDED(rv)) {
43113:             mPromptTempRedirect = cVar;
43113:         }
43113:     }
43113: 
43113:     // enable Persistent caching for HTTPS - bug#205921    
43113:     if (PREF_CHANGED(BROWSER_PREF("disk_cache_ssl"))) {
80486:         cVar = false;
43113:         rv = prefs->GetBoolPref(BROWSER_PREF("disk_cache_ssl"), &cVar);
43113:         if (NS_SUCCEEDED(rv))
43113:             mEnablePersistentHttpsCaching = cVar;
43113:     }
43113: 
43113:     if (PREF_CHANGED(HTTP_PREF("phishy-userpass-length"))) {
43113:         rv = prefs->GetIntPref(HTTP_PREF("phishy-userpass-length"), &val);
43113:         if (NS_SUCCEEDED(rv))
81029:             mPhishyUserPassLength = (PRUint8) clamped(val, 0, 0xff);
43113:     }
43113: 
43113:     //
43113:     // INTL options
43113:     //
43113: 
43113:     if (PREF_CHANGED(INTL_ACCEPT_LANGUAGES)) {
43113:         nsCOMPtr<nsIPrefLocalizedString> pls;
43113:         prefs->GetComplexValue(INTL_ACCEPT_LANGUAGES,
43113:                                 NS_GET_IID(nsIPrefLocalizedString),
43113:                                 getter_AddRefs(pls));
43113:         if (pls) {
43113:             nsXPIDLString uval;
43113:             pls->ToString(getter_Copies(uval));
43113:             if (uval)
43113:                 SetAcceptLanguages(NS_ConvertUTF16toUTF8(uval).get());
43113:         } 
43113:     }
43113: 
43113:     //
43113:     // IDN options
43113:     //
43113: 
43113:     if (PREF_CHANGED(NETWORK_ENABLEIDN)) {
79445:         bool enableIDN = false;
43113:         prefs->GetBoolPref(NETWORK_ENABLEIDN, &enableIDN);
43113:         // No locking is required here since this method runs in the main
43113:         // UI thread, and so do all the methods in nsHttpChannel.cpp
43113:         // (mIDNConverter is used by nsHttpChannel)
43113:         if (enableIDN && !mIDNConverter) {
43113:             mIDNConverter = do_GetService(NS_IDNSERVICE_CONTRACTID);
43113:             NS_ASSERTION(mIDNConverter, "idnSDK not installed");
43113:         }
43113:         else if (!enableIDN && mIDNConverter)
43113:             mIDNConverter = nsnull;
43113:     }
43113: 
61491:     //
61491:     // Tracking options
61491:     //
61491: 
61491:     if (PREF_CHANGED(DONOTTRACK_HEADER_ENABLED)) {
80486:         cVar = false;
61491:         rv = prefs->GetBoolPref(DONOTTRACK_HEADER_ENABLED, &cVar);
61491:         if (NS_SUCCEEDED(rv)) {
61491:             mDoNotTrackEnabled = cVar;
61491:         }
61491:     }
61491: 
43113: #undef PREF_CHANGED
43113: #undef MULTI_PREF_CHANGED
43113: }
43113: 
43113: /**
43113:  *  Allocates a C string into that contains a ISO 639 language list
43113:  *  notated with HTTP "q" values for output with a HTTP Accept-Language
43113:  *  header. Previous q values will be stripped because the order of
43113:  *  the langs imply the q value. The q values are calculated by dividing
43113:  *  1.0 amongst the number of languages present.
43113:  *
43113:  *  Ex: passing: "en, ja"
43113:  *      returns: "en,ja;q=0.5"
43113:  *
43113:  *      passing: "en, ja, fr_CA"
43113:  *      returns: "en,ja;q=0.7,fr_CA;q=0.3"
43113:  */
43113: static nsresult
43113: PrepareAcceptLanguages(const char *i_AcceptLanguages, nsACString &o_AcceptLanguages)
43113: {
43113:     if (!i_AcceptLanguages)
43113:         return NS_OK;
43113: 
43113:     PRUint32 n, size, wrote;
43113:     double q, dec;
43113:     char *p, *p2, *token, *q_Accept, *o_Accept;
43113:     const char *comma;
43113:     PRInt32 available;
43113: 
43113:     o_Accept = nsCRT::strdup(i_AcceptLanguages);
43113:     if (!o_Accept)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     for (p = o_Accept, n = size = 0; '\0' != *p; p++) {
43113:         if (*p == ',') n++;
43113:             size++;
43113:     }
43113: 
43113:     available = size + ++n * 11 + 1;
43113:     q_Accept = new char[available];
43113:     if (!q_Accept) {
43113:         nsCRT::free(o_Accept);
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113:     *q_Accept = '\0';
43113:     q = 1.0;
43113:     dec = q / (double) n;
43113:     n = 0;
43113:     p2 = q_Accept;
43113:     for (token = nsCRT::strtok(o_Accept, ",", &p);
43113:          token != (char *) 0;
43113:          token = nsCRT::strtok(p, ",", &p))
43113:     {
43113:         token = net_FindCharNotInSet(token, HTTP_LWS);
43113:         char* trim;
43113:         trim = net_FindCharInSet(token, ";" HTTP_LWS);
43113:         if (trim != (char*)0)  // remove "; q=..." if present
43113:             *trim = '\0';
43113: 
43113:         if (*token != '\0') {
43113:             comma = n++ != 0 ? "," : ""; // delimiter if not first item
43113:             PRUint32 u = QVAL_TO_UINT(q);
43113:             if (u < 10)
43113:                 wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
43113:             else
43113:                 wrote = PR_snprintf(p2, available, "%s%s", comma, token);
43113:             q -= dec;
43113:             p2 += wrote;
43113:             available -= wrote;
43113:             NS_ASSERTION(available > 0, "allocated string not long enough");
43113:         }
43113:     }
43113:     nsCRT::free(o_Accept);
43113: 
43113:     o_AcceptLanguages.Assign((const char *) q_Accept);
43113:     delete [] q_Accept;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::SetAcceptLanguages(const char *aAcceptLanguages) 
43113: {
43113:     nsCAutoString buf;
43113:     nsresult rv = PrepareAcceptLanguages(aAcceptLanguages, buf);
43113:     if (NS_SUCCEEDED(rv))
43113:         mAcceptLanguages.Assign(buf);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::SetAccept(const char *aAccept) 
43113: {
43113:     mAccept = aAccept;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpHandler::SetAcceptEncodings(const char *aAcceptEncodings) 
43113: {
43113:     mAcceptEncodings = aAcceptEncodings;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler::nsISupports
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS5(nsHttpHandler,
43113:                               nsIHttpProtocolHandler,
43113:                               nsIProxiedProtocolHandler,
43113:                               nsIProtocolHandler,
43113:                               nsIObserver,
43113:                               nsISupportsWeakReference)
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler::nsIProtocolHandler
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetScheme(nsACString &aScheme)
43113: {
43113:     aScheme.AssignLiteral("http");
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetDefaultPort(PRInt32 *result)
43113: {
43113:     *result = NS_HTTP_DEFAULT_PORT;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetProtocolFlags(PRUint32 *result)
43113: {
43113:     *result = NS_HTTP_PROTOCOL_FLAGS;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::NewURI(const nsACString &aSpec,
43113:                       const char *aCharset,
43113:                       nsIURI *aBaseURI,
43113:                       nsIURI **aURI)
43113: {
43113:     LOG(("nsHttpHandler::NewURI\n"));
43113:     return ::NewURI(aSpec, aCharset, aBaseURI, NS_HTTP_DEFAULT_PORT, aURI);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::NewChannel(nsIURI *uri, nsIChannel **result)
43113: {
43113:     LOG(("nsHttpHandler::NewChannel\n"));
43113: 
43113:     NS_ENSURE_ARG_POINTER(uri);
43113:     NS_ENSURE_ARG_POINTER(result);
43113: 
79445:     bool isHttp = false, isHttps = false;
43113: 
43113:     // Verify that we have been given a valid scheme
43113:     nsresult rv = uri->SchemeIs("http", &isHttp);
43113:     if (NS_FAILED(rv)) return rv;
43113:     if (!isHttp) {
43113:         rv = uri->SchemeIs("https", &isHttps);
43113:         if (NS_FAILED(rv)) return rv;
43113:         if (!isHttps) {
43113:             NS_WARNING("Invalid URI scheme");
43113:             return NS_ERROR_UNEXPECTED;
43113:         }
43113:     }
43113:     
43113:     return NewProxiedChannel(uri, nsnull, result);
43113: }
43113: 
43113: NS_IMETHODIMP 
79445: nsHttpHandler::AllowPort(PRInt32 port, const char *scheme, bool *_retval)
43113: {
43113:     // don't override anything.  
80486:     *_retval = false;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler::nsIProxiedProtocolHandler
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::NewProxiedChannel(nsIURI *uri,
43113:                                  nsIProxyInfo* givenProxyInfo,
43113:                                  nsIChannel **result)
43113: {
46790:     nsRefPtr<HttpBaseChannel> httpChannel;
46404: 
43113:     LOG(("nsHttpHandler::NewProxiedChannel [proxyInfo=%p]\n",
43113:         givenProxyInfo));
43113:     
43113:     nsCOMPtr<nsProxyInfo> proxyInfo;
43113:     if (givenProxyInfo) {
43113:         proxyInfo = do_QueryInterface(givenProxyInfo);
43113:         NS_ENSURE_ARG(proxyInfo);
43113:     }
43113: 
79445:     bool https;
43113:     nsresult rv = uri->SchemeIs("https", &https);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
46672:     if (IsNeckoChild()) {
46790:         httpChannel = new HttpChannelChild();
67579:     } else {
46790:         httpChannel = new nsHttpChannel();
46672:     }
43113: 
43113:     // select proxy caps if using a non-transparent proxy.  SSL tunneling
43113:     // should not use proxy settings.
43113:     PRInt8 caps;
43113:     if (proxyInfo && !nsCRT::strcmp(proxyInfo->Type(), "http") && !https)
43113:         caps = mProxyCapabilities;
43113:     else
43113:         caps = mCapabilities;
43113: 
43113:     if (https) {
43113:         // enable pipelining over SSL if requested
43113:         if (mPipeliningOverSSL)
43113:             caps |= NS_HTTP_ALLOW_PIPELINING;
43113: 
67579:         if (!IsNeckoChild()) {
43113:             // HACK: make sure PSM gets initialized on the main thread.
58031:             net_EnsurePSMInit();
43113:         }
54830:     }
43113: 
43113:     rv = httpChannel->Init(uri, caps, proxyInfo);
46790:     if (NS_FAILED(rv))
46790:         return rv;
43113: 
46790:     httpChannel.forget(result);
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler::nsIHttpProtocolHandler
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetUserAgent(nsACString &value)
43113: {
43113:     value = UserAgent();
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetAppName(nsACString &value)
43113: {
51553:     value = mLegacyAppName;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetAppVersion(nsACString &value)
43113: {
51553:     value = mLegacyAppVersion;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetProduct(nsACString &value)
43113: {
43113:     value = mProduct;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetProductSub(nsACString &value)
43113: {
43113:     value = mProductSub;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetPlatform(nsACString &value)
43113: {
43113:     value = mPlatform;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetOscpu(nsACString &value)
43113: {
43113:     value = mOscpu;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::GetMisc(nsACString &value)
43113: {
43113:     value = mMisc;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpHandler::nsIObserver
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpHandler::Observe(nsISupports *subject,
43113:                        const char *topic,
43113:                        const PRUnichar *data)
43113: {
43113:     LOG(("nsHttpHandler::Observe [topic=\"%s\"]\n", topic));
43113: 
43113:     if (strcmp(topic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) == 0) {
43113:         nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(subject);
43113:         if (prefBranch)
43113:             PrefsChanged(prefBranch, NS_ConvertUTF16toUTF8(data).get());
43113:     }
43113:     else if (strcmp(topic, "profile-change-net-teardown")    == 0 ||
43113:              strcmp(topic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)    == 0) {
43113: 
43113:         // clear cache of all authentication credentials.
43113:         mAuthCache.ClearAll();
43113: 
43113:         // ensure connection manager is shutdown
43113:         if (mConnMgr)
43113:             mConnMgr->Shutdown();
43113: 
43113:         // need to reset the session start time since cache validation may
43113:         // depend on this value.
43113:         mSessionStartTime = NowInSeconds();
43113:     }
43113:     else if (strcmp(topic, "profile-change-net-restore") == 0) {
43113:         // initialize connection manager
43113:         InitConnectionMgr();
43113:     }
43113:     else if (strcmp(topic, "net:clear-active-logins") == 0) {
43113:         mAuthCache.ClearAll();
43113:     }
51363:     else if (strcmp(topic, NS_PRIVATE_BROWSING_SWITCH_TOPIC) == 0) {
51363:         if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).Equals(data))
58165:             mInPrivateBrowsingMode = PRIVATE_BROWSING_ON;
51363:         else if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(data))
58165:             mInPrivateBrowsingMode = PRIVATE_BROWSING_OFF;
74328:         if (mConnMgr)
74328:             mConnMgr->ClosePersistentConnections();
51363:     }
55823:     else if (strcmp(topic, "net:prune-dead-connections") == 0) {
55823:         if (mConnMgr) {
55823:             mConnMgr->PruneDeadConnections();
55823:         }
55823:     }
43113:   
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpsHandler implementation
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS4(nsHttpsHandler,
43113:                               nsIHttpProtocolHandler,
43113:                               nsIProxiedProtocolHandler,
43113:                               nsIProtocolHandler,
43113:                               nsISupportsWeakReference)
43113: 
43113: nsresult
43113: nsHttpsHandler::Init()
43113: {
43113:     nsCOMPtr<nsIProtocolHandler> httpHandler(
43113:             do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http"));
43113:     NS_ASSERTION(httpHandler.get() != nsnull, "no http handler?");
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpsHandler::GetScheme(nsACString &aScheme)
43113: {
43113:     aScheme.AssignLiteral("https");
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpsHandler::GetDefaultPort(PRInt32 *aPort)
43113: {
43113:     *aPort = NS_HTTPS_DEFAULT_PORT;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpsHandler::GetProtocolFlags(PRUint32 *aProtocolFlags)
43113: {
43113:     *aProtocolFlags = NS_HTTP_PROTOCOL_FLAGS;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpsHandler::NewURI(const nsACString &aSpec,
43113:                        const char *aOriginCharset,
43113:                        nsIURI *aBaseURI,
43113:                        nsIURI **_retval)
43113: {
43113:     return ::NewURI(aSpec, aOriginCharset, aBaseURI, NS_HTTPS_DEFAULT_PORT, _retval);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpsHandler::NewChannel(nsIURI *aURI, nsIChannel **_retval)
43113: {
43113:     NS_ABORT_IF_FALSE(gHttpHandler, "Should have a HTTP handler by now.");
43113:     if (!gHttpHandler)
43113:       return NS_ERROR_UNEXPECTED;
43113:     return gHttpHandler->NewChannel(aURI, _retval);
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpsHandler::AllowPort(PRInt32 aPort, const char *aScheme, bool *_retval)
43113: {
43113:     // don't override anything.  
80486:     *_retval = false;
43113:     return NS_OK;
43113: }
