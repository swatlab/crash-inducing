 71095: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 71095: // vim:set ts=2 sts=2 sw=2 et cin:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 71095: 
 71095: #ifndef nsPluginInstanceOwner_h_
 71095: #define nsPluginInstanceOwner_h_
 71095: 
 71095: #include "prtypes.h"
 71095: #include "npapi.h"
 71095: #include "nsCOMPtr.h"
 71095: #include "nsIPluginInstanceOwner.h"
 71095: #include "nsIPluginTagInfo.h"
 96781: #include "nsIPrivacyTransitionObserver.h"
 75043: #include "nsIDOMEventListener.h"
 71095: #include "nsIScrollPositionListener.h"
 71095: #include "nsPluginHost.h"
 71095: #include "nsPluginNativeWindow.h"
 96781: #include "nsWeakReference.h"
 71095: #include "gfxRect.h"
 71095: 
 75043: // X.h defines KeyPress
 75043: #ifdef KeyPress
 75043: #undef KeyPress
 75043: #endif
 75043: 
 71095: #ifdef XP_MACOSX
106985: #include "mozilla/gfx/QuartzSupport.h"
 71095: #include <ApplicationServices/ApplicationServices.h>
 71095: #endif
 71095: 
 71095: class nsIInputStream;
 77539: struct nsIntRect;
 71095: class nsPluginDOMContextMenuListener;
 71095: class nsObjectFrame;
 71095: class nsDisplayListBuilder;
 71095: 
 71095: #ifdef MOZ_X11
 71095: class gfxXlibSurface;
 95793: #ifdef MOZ_WIDGET_QT
 95793: #include "gfxQtNativeRenderer.h"
 95793: #else
 71095: #include "gfxXlibNativeRenderer.h"
 71095: #endif
 77137: #endif
 71095: 
 74305: #ifdef XP_OS2
 74305: #define INCL_PM
 74305: #define INCL_GPI
 74305: #include <os2.h>
 74305: #endif
 74305: 
 75043: // X.h defines KeyPress
 75043: #ifdef KeyPress
 75043: #undef KeyPress
 75043: #endif
 75043: 
 71095: class nsPluginInstanceOwner : public nsIPluginInstanceOwner,
 71095:                               public nsIPluginTagInfo,
 75043:                               public nsIDOMEventListener,
 96781:                               public nsIScrollPositionListener,
 96781:                               public nsIPrivacyTransitionObserver,
 96781:                               public nsSupportsWeakReference
 71095: {
 71095: public:
 71095:   nsPluginInstanceOwner();
 71095:   virtual ~nsPluginInstanceOwner();
 71095:   
 71095:   NS_DECL_ISUPPORTS
 71095:   NS_DECL_NSIPLUGININSTANCEOWNER
 96781:   NS_DECL_NSIPRIVACYTRANSITIONOBSERVER
 71095:   
 71095:   NS_IMETHOD GetURL(const char *aURL, const char *aTarget,
 71095:                     nsIInputStream *aPostStream, 
108991:                     void *aHeadersData, uint32_t aHeadersDataLen);
 71095:   
 71095:   NS_IMETHOD ShowStatus(const PRUnichar *aStatusMsg);
 71095:   
 71095:   NPError    ShowNativeContextMenu(NPMenu* menu, void* event);
 71095:   
 71095:   NPBool     ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
 71095:                           double *destX, double *destY, NPCoordinateSpace destSpace);
 71095:   
 93035:   virtual NPError InitAsyncSurface(NPSize *size, NPImageFormat format,
 93035:                                    void *initData, NPAsyncSurface *surface);
 93035:   virtual NPError FinalizeAsyncSurface(NPAsyncSurface *surface);
 93035:   virtual void SetCurrentAsyncSurface(NPAsyncSurface *surface, NPRect *changed);
 93035: 
 71095:   //nsIPluginTagInfo interface
 71095:   NS_DECL_NSIPLUGINTAGINFO
 71095:   
 75043:   // nsIDOMEventListener interfaces 
 75043:   NS_DECL_NSIDOMEVENTLISTENER
 71095:   
 75043:   nsresult MouseDown(nsIDOMEvent* aKeyEvent);
 75043:   nsresult KeyPress(nsIDOMEvent* aKeyEvent);
 77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
 77498:   nsresult Text(nsIDOMEvent* aTextEvent);
 77498: #endif
 71095: 
 71095:   nsresult Destroy();  
 71095: 
 71095: #ifdef XP_WIN
 71095:   void Paint(const RECT& aDirty, HDC aDC);
 71095: #elif defined(XP_MACOSX)
 71095:   void Paint(const gfxRect& aDirtyRect, CGContextRef cgContext);  
 71095:   void RenderCoreAnimation(CGContextRef aCGContext, int aWidth, int aHeight);
 71095:   void DoCocoaEventDrawRect(const gfxRect& aDrawRect, CGContextRef cgContext);
 78424: #elif defined(MOZ_X11) || defined(ANDROID)
 71095:   void Paint(gfxContext* aContext,
 71095:              const gfxRect& aFrameRect,
 71095:              const gfxRect& aDirtyRect);
 71095: #elif defined(XP_OS2)
 71095:   void Paint(const nsRect& aDirtyRect, HPS aHPS);
 71095: #endif
 71095:   
 71095: #ifdef MAC_CARBON_PLUGINS
 71095:   void CancelTimer();
 79445:   void StartTimer(bool isVisible);
 71095: #endif
 71095:   void SendIdleEvent();
 71095:   
 71095:   // nsIScrollPositionListener interface
 71095:   virtual void ScrollPositionWillChange(nscoord aX, nscoord aY);
 71095:   virtual void ScrollPositionDidChange(nscoord aX, nscoord aY);
 71095:   
 71095:   //locals
 71095:   
 89114:   nsresult Init(nsIContent* aContent);
 71095:   
 71095:   void* GetPluginPortFromWidget();
 71095:   void ReleasePluginPort(void* pluginPort);
 71095: 
 71095:   nsEventStatus ProcessEvent(const nsGUIEvent & anEvent);
 71095:   
 71095: #ifdef XP_MACOSX
 71095:   enum { ePluginPaintEnable, ePluginPaintDisable };
 71095:   
 71095:   NPDrawingModel GetDrawingModel();
 79445:   bool IsRemoteDrawingCoreAnimation();
 71095:   NPEventModel GetEventModel();
 71095:   static void CARefresh(nsITimer *aTimer, void *aClosure);
 90335:   void AddToCARefreshTimer();
 90335:   void RemoveFromCARefreshTimer();
 80981:   // This calls into the plugin (NPP_SetWindow) and can run script.
108991:   void* FixUpPluginWindow(int32_t inPaintState);
 71095:   void HidePluginWindow();
 71095:   // Set a flag that (if true) indicates the plugin port info has changed and
 71095:   // SetWindow() needs to be called.
 79445:   void SetPluginPortChanged(bool aState) { mPluginPortChanged = aState; }
 71095:   // Return a pointer to the internal nsPluginPort structure that's used to
 71095:   // store a copy of plugin port info and to detect when it's been changed.
 71095:   void* GetPluginPortCopy();
 71095:   // Set plugin port info in the plugin (in the 'window' member of the
 71095:   // NPWindow structure passed to the plugin by SetWindow()) and set a
 71095:   // flag (mPluginPortChanged) to indicate whether or not this info has
 71095:   // changed, and SetWindow() needs to be called again.
 71095:   void* SetPluginPortAndDetectChange();
 71095:   // Flag when we've set up a Thebes (and CoreGraphics) context in
 71095:   // nsObjectFrame::PaintPlugin().  We need to know this in
 71095:   // FixUpPluginWindow() (i.e. we need to know when FixUpPluginWindow() has
 71095:   // been called from nsObjectFrame::PaintPlugin() when we're using the
 71095:   // CoreGraphics drawing model).
 71095:   void BeginCGPaint();
 71095:   void EndCGPaint();
 71095: #else // XP_MACOSX
 79445:   void UpdateWindowPositionAndClipRect(bool aSetWindow);
 79445:   void UpdateWindowVisibility(bool aVisible);
 79445:   void UpdateDocumentActiveState(bool aIsActive);
 71095: #endif // XP_MACOSX
 71095: 
 89114:   void SetFrame(nsObjectFrame *aFrame);
 89114:   nsObjectFrame* GetFrame();
 71095: 
108991:   uint32_t GetLastEventloopNestingLevel() const {
 71095:     return mLastEventloopNestingLevel; 
 71095:   }
 71095:   
108991:   static uint32_t GetEventloopNestingLevel();
 71095:   
 71095:   void ConsiderNewEventloopNestingLevel() {
108991:     uint32_t currentLevel = GetEventloopNestingLevel();
 71095:     
 71095:     if (currentLevel < mLastEventloopNestingLevel) {
 71095:       mLastEventloopNestingLevel = currentLevel;
 71095:     }
 71095:   }
 71095:   
 71095:   const char* GetPluginName()
 71095:   {
 71095:     if (mInstance && mPluginHost) {
 71095:       const char* name = NULL;
 71095:       if (NS_SUCCEEDED(mPluginHost->GetPluginName(mInstance, &name)) && name)
 71095:         return name;
 71095:     }
 71095:     return "";
 71095:   }
 71095:   
 71095: #ifdef MOZ_X11
 71095:   void GetPluginDescription(nsACString& aDescription)
 71095:   {
 71095:     aDescription.Truncate();
 71095:     if (mInstance && mPluginHost) {
 71095:       nsCOMPtr<nsIPluginTag> pluginTag;
 71095:       
 71095:       mPluginHost->GetPluginTagForInstance(mInstance,
 71095:                                            getter_AddRefs(pluginTag));
 71095:       if (pluginTag) {
 71095:         pluginTag->GetDescription(aDescription);
 71095:       }
 71095:     }
 71095:   }
 71095: #endif
 71095:   
 79445:   bool SendNativeEvents()
 71095:   {
 71095: #ifdef XP_WIN
 71095:     // XXX we should remove the plugin name check
 71095:     return mPluginWindow->type == NPWindowTypeDrawable &&
 71095:     (MatchPluginName("Shockwave Flash") ||
 71095:      MatchPluginName("Test Plug-in"));
 71095: #elif defined(MOZ_X11) || defined(XP_MACOSX)
 79533:     return true;
 71095: #else
 79533:     return false;
 71095: #endif
 71095:   }
 71095:   
 79445:   bool MatchPluginName(const char *aPluginName)
 71095:   {
 71095:     return strncmp(GetPluginName(), aPluginName, strlen(aPluginName)) == 0;
 71095:   }
 71095:   
 71095:   void NotifyPaintWaiter(nsDisplayListBuilder* aBuilder);
 89708: 
 89708:   // Returns the image container that has our currently displayed image.
 89708:   already_AddRefed<ImageContainer> GetImageContainer();
 89708: 
 71095:   /**
 71095:    * Returns the bounds of the current async-rendered surface. This can only
 71095:    * change in response to messages received by the event loop (i.e. not during
 71095:    * painting).
 71095:    */
 71095:   nsIntSize GetCurrentImageSize();
 71095:   
 71095:   // Methods to update the background image we send to async plugins.
 71095:   // The eventual target of these operations is PluginInstanceParent,
 71095:   // but it takes several hops to get there.
 71095:   void SetBackgroundUnknown();
 71095:   already_AddRefed<gfxContext> BeginUpdateBackground(const nsIntRect& aRect);
 71095:   void EndUpdateBackground(gfxContext* aContext, const nsIntRect& aRect);
 71095:   
 79445:   bool UseAsyncRendering();
 71095: 
 89241: #ifdef MOZ_WIDGET_ANDROID
106178:   // Returns the image container for the specified VideoInfo
106178:   void GetVideos(nsTArray<nsNPAPIPluginInstance::VideoInfo*>& aVideos);
106178:   already_AddRefed<ImageContainer> GetImageContainerForVideo(nsNPAPIPluginInstance::VideoInfo* aVideoInfo);
 89219: 
106178:   nsIntRect GetVisibleRect();
 89219: 
 89219:   void Invalidate();
 99806: 
 99806:   void RequestFullScreen();
 99806:   void ExitFullScreen();
 99806: 
 99806:   // Called from AndroidJNI when we removed the fullscreen view.
 99806:   static void ExitFullScreen(jobject view);
 89219: #endif
 89219:   
 71095: private:
 71095:   
 71095:   // return FALSE if LayerSurface dirty (newly created and don't have valid plugin content yet)
 79445:   bool IsUpToDate()
 71095:   {
 71095:     nsIntSize size;
 71095:     return NS_SUCCEEDED(mInstance->GetImageSize(&size)) &&
 71095:     size == nsIntSize(mPluginWindow->width, mPluginWindow->height);
 71095:   }
 71095:   
 71095:   void FixUpURLS(const nsString &name, nsAString &value);
 89241: #ifdef MOZ_WIDGET_ANDROID
101629:   gfxRect GetPluginRect();
 99806:   bool AddPluginView(const gfxRect& aRect = gfxRect(0, 0, 0, 0));
 78424:   void RemovePluginView();
 89219: 
 99806:   bool mFullScreen;
 99806:   void* mJavaView;
 78424: #endif 
 71095: 
114203: #if defined(XP_MACOSX) && !defined(NP_NO_CARBON)
114203:   void AddScrollPositionListener();
114203:   void RemoveScrollPositionListener();
114203: #endif
114203:  
 71095:   nsPluginNativeWindow       *mPluginWindow;
 71095:   nsRefPtr<nsNPAPIPluginInstance> mInstance;
 89114:   nsObjectFrame              *mObjectFrame;
 89114:   nsIContent                 *mContent; // WEAK, content owns us
 71095:   nsCString                   mDocumentBase;
 71095:   char                       *mTagText;
 89114:   bool                        mWidgetCreationComplete;
 71095:   nsCOMPtr<nsIWidget>         mWidget;
 71095:   nsRefPtr<nsPluginHost>      mPluginHost;
 71095:   
 71095: #ifdef XP_MACOSX
 71095:   NP_CGContext                              mCGPluginPortCopy;
108991:   int32_t                                   mInCGPaintLevel;
106985:   mozilla::RefPtr<MacIOSurface>             mIOSurface;
106985:   mozilla::RefPtr<nsCARenderer>             mCARenderer;
 71095:   CGColorSpaceRef                           mColorProfile;
 71095:   static nsCOMPtr<nsITimer>                *sCATimer;
 71095:   static nsTArray<nsPluginInstanceOwner*>  *sCARefreshListeners;
 79445:   bool                                      mSentInitialTopLevelWindowEvent;
 71095: #endif
 71095: 
 71095:   // Initially, the event loop nesting level we were created on, it's updated
 71095:   // if we detect the appshell is on a lower level as long as we're not stopped.
 71095:   // We delay DoStopPlugin() until the appshell reaches this level or lower.
108991:   uint32_t                    mLastEventloopNestingLevel;
 79445:   bool                        mContentFocused;
 79445:   bool                        mWidgetVisible;    // used on Mac to store our widget's visible state
 71095: #ifdef XP_MACOSX
 79445:   bool                        mPluginPortChanged;
 71095: #endif
 71095: #ifdef MOZ_X11
 71095:   // Used with windowless plugins only, initialized in CreateWidget().
 79445:   bool                        mFlash10Quirks;
 71095: #endif
 79445:   bool                        mPluginWindowVisible;
 79445:   bool                        mPluginDocumentActiveState;
114203: #if defined(XP_MACOSX) && !defined(NP_NO_CARBON)
114203:   bool                        mRegisteredScrollPositionListener;
114203: #endif
 71095: 
108991:   uint16_t          mNumCachedAttrs;
108991:   uint16_t          mNumCachedParams;
 71095:   char              **mCachedAttrParamNames;
 71095:   char              **mCachedAttrParamValues;
 71095:   
 71095: #ifdef XP_MACOSX
 71095:   NPEventModel mEventModel;
 89114:   // This is a hack! UseAsyncRendering() can incorrectly return false
 89114:   // when we don't have an object frame (possible as of bug 90268).
 89114:   // We hack around this by always returning true if we've ever
 89114:   // returned true.
 89114:   bool mUseAsyncRendering;
 71095: #endif
 71095:   
 71095:   // pointer to wrapper for nsIDOMContextMenuListener
 71095:   nsRefPtr<nsPluginDOMContextMenuListener> mCXMenuListener;
 71095:   
 71095:   nsresult DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent);
 71095:   nsresult DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent);
 71095:   nsresult DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent);
 71095:   
 71095:   nsresult EnsureCachedAttrParamArrays();
 71095:   
 71095: #ifdef MOZ_X11
 71095:   class Renderer
 95793: #if defined(MOZ_WIDGET_QT)
 95793:   : public gfxQtNativeRenderer
 95793: #else
 71095:   : public gfxXlibNativeRenderer
 71095: #endif
 71095:   {
 71095:   public:
 71095:     Renderer(NPWindow* aWindow, nsPluginInstanceOwner* aInstanceOwner,
 71095:              const nsIntSize& aPluginSize, const nsIntRect& aDirtyRect)
 71095:     : mWindow(aWindow), mInstanceOwner(aInstanceOwner),
 71095:     mPluginSize(aPluginSize), mDirtyRect(aDirtyRect)
 71095:     {}
 71095:     virtual nsresult DrawWithXlib(gfxXlibSurface* surface, nsIntPoint offset, 
108991:                                   nsIntRect* clipRects, uint32_t numClipRects);
 71095:   private:
 71095:     NPWindow* mWindow;
 71095:     nsPluginInstanceOwner* mInstanceOwner;
 71095:     const nsIntSize& mPluginSize;
 71095:     const nsIntRect& mDirtyRect;
 71095:   };
 71095: #endif
 71095: 
 79445:   bool mWaitingForPaint;
 71095: };
 71095: 
 71095: #endif // nsPluginInstanceOwner_h_
 71095: 
