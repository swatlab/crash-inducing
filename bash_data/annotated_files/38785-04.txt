    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Sean Echevarria <sean@beatnik.com>
12841:  *   HÃ¥kan Waara <hwaara@chello.se>
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
29956: /* nsPluginHost.cpp - top-level plugin management code */
    1: 
    1: #include "nscore.h"
29956: #include "nsPluginHost.h"
    1: 
    1: #include <stdio.h>
    1: #include "prio.h"
    1: #include "prmem.h"
19246: #include "nsNPAPIPlugin.h"
19246: #include "nsNPAPIPluginStreamListener.h"
    1: #include "nsIPlugin.h"
29834: #include "nsNPAPIPluginInstance.h"
    1: #include "nsIPluginStreamListener.h"
    1: #include "nsIHTTPHeaderListener.h"
    1: #include "nsIHttpHeaderVisitor.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIHttpProtocolHandler.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIHttpChannelInternal.h"
    1: #include "nsIUploadChannel.h"
    1: #include "nsIByteRangeRequest.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIInputStream.h"
    1: #include "nsIOutputStream.h"
    1: #include "nsIURL.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIProtocolProxyService.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsIFile.h"
    1: #include "nsIInputStream.h"
    1: #include "nsIIOService.h"
    1: #include "nsIURL.h"
    1: #include "nsIChannel.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIProgressEventSink.h"
    1: #include "nsIDocument.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsHashtable.h"
    1: #include "nsIProxyInfo.h"
    1: #include "nsObsoleteModuleLoading.h"
    1: #include "nsIComponentRegistrar.h"
    1: #include "nsPluginLogging.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIScriptChannel.h"
    1: #include "nsPrintfCString.h"
21189: #include "nsIBlocklistService.h"
21192: #include "nsVersionComparator.h"
24475: #include "nsIPrivateBrowsingService.h"
37151: #include "nsIObjectLoadingContent.h"
38026: #include "nsIWritablePropertyBag2.h"
    1: 
    1: #include "nsEnumeratorUtils.h"
    1: #include "nsXPCOM.h"
    1: #include "nsXPCOMCID.h"
    1: #include "nsISupportsPrimitives.h"
24790: 
    1: // for the dialog
    1: #include "nsIStringBundle.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsPIDOMWindow.h"
    1: 
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: #include "nsIPrincipal.h"
    1: 
    1: #include "nsNetCID.h"
    1: #include "nsIDOMPlugin.h"
    1: #include "nsIDOMMimeType.h"
    1: #include "nsMimeTypes.h"
    1: #include "prprf.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIInputStreamTee.h"
    1: #include "nsIInterfaceInfoManager.h"
    1: #include "xptinfo.h"
    1: 
    1: #include "nsIMIMEService.h"
    1: #include "nsCExternalHandlerService.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIFileChannel.h"
    1: 
    1: #include "nsPluginSafety.h"
    1: 
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsIPlatformCharset.h"
    1: 
    1: #include "nsIDirectoryService.h"
    1: #include "nsDirectoryServiceDefs.h"
32940: #include "nsXULAppAPI.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsIFile.h"
    1: #include "nsPluginDirServiceProvider.h"
    1: #include "nsInt64.h"
    1: #include "nsPluginError.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: #include "nsPluginManifestLineReader.h"
    1: 
    1: #include "nsDefaultPlugin.h"
38785: #include "nsWeakReference.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLEmbedElement.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsIDocShell.h"
    1: #include "nsPluginNativeWindow.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIContentPolicy.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsContentErrors.h"
37525: #include "mozilla/TimeStamp.h"
    1: 
24790: #if defined(XP_WIN)
24790: #include "windows.h"
24790: #include "winbase.h"
24790: #endif
24790: 
16528: #if defined(XP_UNIX) && defined(MOZ_WIDGET_GTK2) & defined(MOZ_X11)
    1: #include <gdk/gdkx.h> // for GDK_DISPLAY()
    1: #endif
    1: 
37525: using mozilla::TimeStamp;
37525: 
31646: // Null out a strong ref to a linked list iteratively to avoid
31646: // exhausting the stack (bug 486349).
31646: #define NS_ITERATIVE_UNREF_LIST(type_, list_, mNext_)                \
31646:   {                                                                  \
31646:     while (list_) {                                                  \
31646:       type_ temp = list_->mNext_;                                    \
31646:       list_->mNext_ = nsnull;                                        \
31646:       list_ = temp;                                                  \
31646:     }                                                                \
31646:   }
31646: 
    1: // this is the name of the directory which will be created
    1: // to cache temporary files.
    1: #define kPluginTmpDirName NS_LITERAL_CSTRING("plugtmp")
    1: 
    1: // Version of cached plugin info
    1: // 0.01 first implementation
    1: // 0.02 added caching of CanUnload to fix bug 105935
    1: // 0.03 changed name, description and mime desc from string to bytes, bug 108246
    1: // 0.04 added new mime entry point on Mac, bug 113464
    1: // 0.05 added new entry point check for the default plugin, bug 132430
    1: // 0.06 strip off suffixes in mime description strings, bug 53895
    1: // 0.07 changed nsIRegistry to flat file support for caching plugins info
    1: // 0.08 mime entry point on MachO, bug 137535
12841: // 0.09 the file encoding is changed to UTF-8, bug 420285
15947: // 0.10 added plugin versions on appropriate platforms, bug 427743
29020: // 0.11 file name and full path fields now store expected values on all platforms, bug 488181
21192: // The current plugin registry version (and the maximum version we know how to read)
29020: static const char *kPluginRegistryVersion = "0.11";
21192: // The minimum registry version we know how to read
21192: static const char *kMinimumRegistryVersion = "0.9";
21231: 
29952: static NS_DEFINE_IID(kIPluginTagInfoIID, NS_IPLUGINTAGINFO_IID);
    1: static const char kDirectoryServiceContractID[] = "@mozilla.org/file/directory_service;1";
    1: 
    1: // Registry keys for caching plugin info
    1: static const char kPluginsRootKey[] = "software/plugins";
    1: static const char kPluginsNameKey[] = "name";
    1: static const char kPluginsDescKey[] = "description";
    1: static const char kPluginsFilenameKey[] = "filename";
    1: static const char kPluginsFullpathKey[] = "fullpath";
    1: static const char kPluginsModTimeKey[] = "lastModTimeStamp";
    1: static const char kPluginsCanUnload[] = "canUnload";
    1: static const char kPluginsVersionKey[] = "version";
    1: static const char kPluginsMimeTypeKey[] = "mimetype";
    1: static const char kPluginsMimeDescKey[] = "description";
    1: static const char kPluginsMimeExtKey[] = "extension";
    1: 
    1: #define kPluginRegistryFilename NS_LITERAL_CSTRING("pluginreg.dat")
    1: 
    1: #ifdef PLUGIN_LOGGING
    1: PRLogModuleInfo* nsPluginLogging::gNPNLog = nsnull;
    1: PRLogModuleInfo* nsPluginLogging::gNPPLog = nsnull;
    1: PRLogModuleInfo* nsPluginLogging::gPluginLog = nsnull;
    1: #endif
    1: 
    1: #define BRAND_PROPERTIES_URL "chrome://branding/locale/brand.properties"
    1: #define PLUGIN_PROPERTIES_URL "chrome://global/locale/downloadProgress.properties"
    1: 
    1: // #defines for plugin cache and prefs
    1: #define NS_PREF_MAX_NUM_CACHED_PLUGINS "browser.plugins.max_num_cached_plugins"
    1: #define DEFAULT_NUMBER_OF_STOPPED_PLUGINS 10
    1: 
    1: #define MAGIC_REQUEST_CONTEXT 0x01020304
    1: 
    1: #ifdef CALL_SAFETY_ON
    1: PRBool gSkipPluginSafeCalls = PR_FALSE;
    1: #endif
    1: 
29956: nsIFile *nsPluginHost::sPluginTempDir;
29956: nsPluginHost *nsPluginHost::sInst;
    1: 
    1: // flat file reg funcs
    1: static
    1: PRBool ReadSectionHeader(nsPluginManifestLineReader& reader, const char *token)
    1: {
    1:   do {
    1:     if (*reader.LinePtr() == '[') {
    1:       char* p = reader.LinePtr() + (reader.LineLength() - 1);
    1:       if (*p != ']')
    1:         break;
    1:       *p = 0;
    1: 
    1:       char* values[1];
    1:       if (1 != reader.ParseLine(values, 1))
    1:         break;
    1:       // ignore the leading '['
    1:       if (PL_strcmp(values[0]+1, token)) {
    1:         break; // it's wrong token
    1:       }
    1:       return PR_TRUE;
    1:     }
    1:   } while (reader.NextLine());
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Little helper struct to asynchronously reframe any presentations (embedded)
    1: // or reload any documents (full-page), that contained plugins
    1: // which were shutdown as a result of a plugins.refresh(1)
    1: class nsPluginDocReframeEvent: public nsRunnable {
    1: public:
    1:   nsPluginDocReframeEvent(nsISupportsArray* aDocs) { mDocs = aDocs; }
    1: 
    1:   NS_DECL_NSIRUNNABLE
    1: 
    1:   nsCOMPtr<nsISupportsArray> mDocs;
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginDocReframeEvent::Run() {
    1:   NS_ENSURE_TRUE(mDocs, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 c;
    1:   mDocs->Count(&c);
    1: 
    1:   // for each document (which previously had a running instance), tell
    1:   // the frame constructor to rebuild
    1:   for (PRUint32 i = 0; i < c; i++) {
    1:     nsCOMPtr<nsIDocument> doc (do_QueryElementAt(mDocs, i));
    1:     if (doc) {
  981:       nsIPresShell *shell = doc->GetPrimaryShell();
    1: 
    1:       // if this document has a presentation shell, then it has frames and can be reframed
    1:       if (shell) {
21231:         /* A reframe will cause a fresh object frame, instance owner, and instance
    1:          * to be created. Reframing of the entire document is necessary as we may have
    1:          * recently found new plugins and we want a shot at trying to use them instead
    1:          * of leaving alternate renderings.
    1:          * We do not want to completely reload all the documents that had running plugins
    1:          * because we could possibly trigger a script to run in the unload event handler
    1:          * which may want to access our defunct plugin and cause us to crash.
    1:          */
    1: 
    1:         shell->ReconstructFrames(); // causes reframe of document
    1:       } else {  // no pres shell --> full-page plugin
    1: 
    1:         NS_NOTREACHED("all plugins should have a pres shell!");
    1: 
    1:       }
    1:     }
    1:   }
    1: 
    1:   return mDocs->Clear();
    1: }
    1: 
24790: // helper struct for asynchronous handling of plugin unloading
    1: class nsPluginUnloadEvent : public nsRunnable {
    1: public:
    1:   nsPluginUnloadEvent(PRLibrary* aLibrary)
    1:     : mLibrary(aLibrary)
    1:   {}
    1:  
    1:   NS_DECL_NSIRUNNABLE
    1:  
    1:   PRLibrary* mLibrary;
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginUnloadEvent::Run()
    1: {
    1:   if (mLibrary) {
24790:     // put our unload call in a safety wrapper
    1:     NS_TRY_SAFE_CALL_VOID(PR_UnloadLibrary(mLibrary), nsnull, nsnull);
    1:   } else {
    1:     NS_WARNING("missing library from nsPluginUnloadEvent");
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // unload plugin asynchronously if possible, otherwise just unload now
36266: nsresult nsPluginHost::PostPluginUnloadEvent(PRLibrary* aLibrary)
    1: {
    1:   nsCOMPtr<nsIRunnable> ev = new nsPluginUnloadEvent(aLibrary);
    1:   if (ev && NS_SUCCEEDED(NS_DispatchToCurrentThread(ev)))
    1:     return NS_OK;
    1: 
    1:   // failure case
    1:   NS_TRY_SAFE_CALL_VOID(PR_UnloadLibrary(aLibrary), nsnull, nsnull);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
38785: class nsPluginStreamListenerPeer;
38785: 
38785: class nsPluginStreamInfo : public nsINPAPIPluginStreamInfo
38785: {
38785: public:
38785:   nsPluginStreamInfo();
38785:   virtual ~nsPluginStreamInfo();
38785: 
38785:   NS_DECL_ISUPPORTS
38785: 
38785:   // nsINPAPIPluginStreamInfo interface
38785:  
38785:   NS_IMETHOD
38785:   GetContentType(char **result);
38785: 
38785:   NS_IMETHOD
38785:   IsSeekable(PRBool* result);
38785: 
38785:   NS_IMETHOD
38785:   GetLength(PRUint32* result);
38785: 
38785:   NS_IMETHOD
38785:   GetLastModified(PRUint32* result);
38785: 
38785:   NS_IMETHOD
38785:   GetURL(const char** result);
38785: 
38785:   NS_IMETHOD
38785:   RequestRead(NPByteRange* rangeList);
38785: 
38785:   NS_IMETHOD
38785:   GetStreamOffset(PRInt32 *result);
38785: 
38785:   NS_IMETHOD
38785:   SetStreamOffset(PRInt32 result);
38785: 
38785:   // local methods
38785: 
38785:   void
38785:   SetContentType(const char* contentType);
38785: 
38785:   void
38785:   SetSeekable(const PRBool seekable);
38785: 
38785:   void
38785:   SetLength(const PRUint32 length);
38785: 
38785:   void
38785:   SetLastModified(const PRUint32 modified);
38785: 
38785:   void
38785:   SetURL(const char* url);
38785: 
38785:   void
38785:   SetPluginInstance(nsIPluginInstance * aPluginInstance);
38785: 
38785:   void
38785:   SetPluginStreamListenerPeer(nsPluginStreamListenerPeer * aPluginStreamListenerPeer);
38785: 
38785:   void
38785:   MakeByteRangeString(NPByteRange* aRangeList, nsACString &string, PRInt32 *numRequests);
38785: 
38785:   PRBool
38785:   UseExistingPluginCacheFile(nsPluginStreamInfo* psi);
38785: 
38785:   void
38785:   SetStreamComplete(const PRBool complete);
38785: 
38785:   void
38785:   SetRequest(nsIRequest *request)
38785:   {
38785:     mRequest = request;
38785:   }
38785: 
38785: private:
38785: 
38785:   char* mContentType;
38785:   char* mURL;
38785:   PRBool mSeekable;
38785:   PRUint32 mLength;
38785:   PRUint32 mModified;
38785:   nsIPluginInstance * mPluginInstance;
38785:   nsPluginStreamListenerPeer * mPluginStreamListenerPeer;
38785:   PRInt32 mStreamOffset;
38785:   PRBool mStreamComplete;
38785: };
38785: 
    1: class nsPluginStreamListenerPeer : public nsIStreamListener,
    1:                                    public nsIProgressEventSink,
    1:                                    public nsIHttpHeaderVisitor,
38785:                                    public nsSupportsWeakReference
    1: {
    1: public:
    1:   nsPluginStreamListenerPeer();
    1:   virtual ~nsPluginStreamListenerPeer();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIPROGRESSEVENTSINK
    1:   NS_DECL_NSIREQUESTOBSERVER
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIHTTPHEADERVISITOR
    1: 
    1:   // Called by GetURL and PostURL (via NewStream)
    1:   nsresult Initialize(nsIURI *aURL,
    1:                       nsIPluginInstance *aInstance,
    1:                       nsIPluginStreamListener *aListener,
    1:                       PRInt32 requestCount = 1);
    1: 
    1:   nsresult InitializeEmbedded(nsIURI *aURL,
    1:                              nsIPluginInstance* aInstance,
37525:                              nsIPluginInstanceOwner *aOwner = nsnull);
    1: 
    1:   nsresult InitializeFullPage(nsIPluginInstance *aInstance);
    1: 
    1:   nsresult OnFileAvailable(nsIFile* aFile);
    1: 
    1:   nsresult ServeStreamAsFile(nsIRequest *request, nsISupports *ctxt);
    1:   
16367:   nsIPluginInstance *GetPluginInstance() { return mInstance; }
16367: 
    1: private:
    1:   nsresult SetUpStreamListener(nsIRequest* request, nsIURI* aURL);
    1:   nsresult SetupPluginCacheFile(nsIChannel* channel);
    1: 
38785:   nsIURI                  *mURL;
38785:   nsIPluginInstanceOwner  *mOwner;
38785:   nsIPluginInstance       *mInstance;
38785:   nsIPluginStreamListener *mPStreamListener;
38785:   nsRefPtr<nsPluginStreamInfo> mPluginStreamInfo;
    1: 
    1:   // Set to PR_TRUE if we request failed (like with a HTTP response of 404)
    1:   PRPackedBool            mRequestFailed;
    1: 
    1:   /*
29834:    * Set to PR_TRUE after nsIPluginStreamListener::OnStartBinding() has
    1:    * been called.  Checked in ::OnStopRequest so we can call the
    1:    * plugin's OnStartBinding if, for some reason, it has not already
    1:    * been called.
    1:    */
    1:   PRPackedBool      mStartBinding;
    1:   PRPackedBool      mHaveFiredOnStartRequest;
    1:   // these get passed to the plugin stream listener
38785:   char                    *mMIMEType;
    1:   PRUint32                mLength;
32799:   PRInt32                 mStreamType;
    1: 
    1:   // local cached file, we save the content into local cache if browser cache is not available,
    1:   // or plugin asks stream as file and it expects file extension until bug 90558 got fixed
38785:   nsIFile                 *mLocalCachedFile;
    1:   nsCOMPtr<nsIOutputStream> mFileCacheOutputStream;
    1:   nsHashtable             *mDataForwardToRequest;
    1: 
    1: public:
    1:   PRBool                  mAbort;
    1:   PRInt32                 mPendingRequests;
    1:   nsWeakPtr               mWeakPtrChannelCallbacks;
    1:   nsWeakPtr               mWeakPtrChannelLoadGroup;
    1: };
    1: 
    1: class nsPluginByteRangeStreamListener : public nsIStreamListener {
    1: public:
    1:   nsPluginByteRangeStreamListener(nsIWeakReference* aWeakPtr);
    1:   virtual ~nsPluginByteRangeStreamListener();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIREQUESTOBSERVER
    1:   NS_DECL_NSISTREAMLISTENER
    1: 
    1: private:
    1:   nsCOMPtr<nsIStreamListener> mStreamConverter;
    1:   nsWeakPtr mWeakPtrPluginStreamListenerPeer;
    1:   PRBool mRemoveMagicNumber;
    1: };
    1: 
38785: nsPluginStreamInfo::nsPluginStreamInfo()
38785: {
38785:   mPluginInstance = nsnull;
38785:   mPluginStreamListenerPeer = nsnull;
38785: 
38785:   mContentType = nsnull;
38785:   mURL = nsnull;
38785:   mSeekable = PR_FALSE;
38785:   mLength = 0;
38785:   mModified = 0;
38785:   mStreamOffset = 0;
38785:   mStreamComplete = PR_FALSE;
38785: }
38785: 
38785: nsPluginStreamInfo::~nsPluginStreamInfo()
38785: {
38785:   if (mContentType)
38785:     PL_strfree(mContentType);
38785:   if (mURL)
38785:     PL_strfree(mURL);
38785: 
38785:   NS_IF_RELEASE(mPluginInstance);
38785: }
38785: 
38785: NS_IMPL_ISUPPORTS2(nsPluginStreamInfo, nsIPluginStreamInfo,
38785:                    nsINPAPIPluginStreamInfo)
38785: 
38758: NS_IMETHODIMP
38785: nsPluginStreamInfo::GetContentType(char **result)
38693: {
38785:   *result = mContentType;
38758:   return NS_OK;
38758: }
38693: 
38667: NS_IMETHODIMP
38785: nsPluginStreamInfo::IsSeekable(PRBool* result)
    1: {
    1:   *result = mSeekable;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
38785: nsPluginStreamInfo::GetLength(PRUint32* result)
    1: {
    1:   *result = mLength;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
38785: nsPluginStreamInfo::GetLastModified(PRUint32* result)
    1: {
    1:   *result = mModified;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
38785: nsPluginStreamInfo::GetURL(const char** result)
    1: {
38785:   *result = mURL;
    1:   return NS_OK;
    1: }
    1: 
    1: void
38785: nsPluginStreamInfo::MakeByteRangeString(NPByteRange* aRangeList, nsACString &rangeRequest, PRInt32 *numRequests)
    1: {
    1:   rangeRequest.Truncate();
    1:   *numRequests  = 0;
    1:   //the string should look like this: bytes=500-700,601-999
    1:   if (!aRangeList)
    1:     return;
    1: 
    1:   PRInt32 requestCnt = 0;
    1:   nsCAutoString string("bytes=");
    1: 
32799:   for (NPByteRange * range = aRangeList; range != nsnull; range = range->next) {
    1:     // XXX zero length?
    1:     if (!range->length)
    1:       continue;
    1: 
    1:     // XXX needs to be fixed for negative offsets
    1:     string.AppendInt(range->offset);
    1:     string.Append("-");
    1:     string.AppendInt(range->offset + range->length - 1);
    1:     if (range->next)
    1:       string += ",";
    1: 
    1:     requestCnt++;
    1:   }
    1: 
    1:   // get rid of possible trailing comma
    1:   string.Trim(",", PR_FALSE);
    1: 
    1:   rangeRequest = string;
    1:   *numRequests  = requestCnt;
    1:   return;
    1: }
    1: 
    1: NS_IMETHODIMP
38785: nsPluginStreamInfo::RequestRead(NPByteRange* rangeList)
    1: {
    1:   nsCAutoString rangeString;
    1:   PRInt32 numRequests;
    1: 
38785:   //first of all lets see if mPluginStreamListenerPeer is still alive
38785:   nsCOMPtr<nsISupportsWeakReference> suppWeakRef(
38785:     do_QueryInterface((nsISupportsWeakReference *)(mPluginStreamListenerPeer)));
38785:   if (!suppWeakRef)
38785:     return NS_ERROR_FAILURE;
38785: 
38785:   nsCOMPtr<nsIWeakReference> pWeakRefPluginStreamListenerPeer =
38785:            do_GetWeakReference(suppWeakRef);
38785:   if (!pWeakRefPluginStreamListenerPeer)
38785:     return NS_ERROR_FAILURE;
38785: 
    1:   MakeByteRangeString(rangeList, rangeString, &numRequests);
    1: 
    1:   if (numRequests == 0)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsresult rv = NS_OK;
38785:   nsCOMPtr<nsIURI> url;
38785: 
38785:   rv = NS_NewURI(getter_AddRefs(url), nsDependentCString(mURL));
38785: 
38785:   nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryReferent(mPluginStreamListenerPeer->mWeakPtrChannelCallbacks);
38785:   nsCOMPtr<nsILoadGroup> loadGroup = do_QueryReferent(mPluginStreamListenerPeer->mWeakPtrChannelLoadGroup);
    1:   nsCOMPtr<nsIChannel> channel;
38785:   rv = NS_NewChannel(getter_AddRefs(channel), url, nsnull, loadGroup, callbacks);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:   if (!httpChannel)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Range"), rangeString, PR_FALSE);
    1: 
38785:   mPluginStreamListenerPeer->mAbort = PR_TRUE; // instruct old stream listener to cancel
    1:                                                // the request on the next ODA.
    1: 
    1:   nsCOMPtr<nsIStreamListener> converter;
    1: 
    1:   if (numRequests == 1) {
38785:     converter = mPluginStreamListenerPeer;
38785: 
    1:     // set current stream offset equal to the first offset in the range list
    1:     // it will work for single byte range request
    1:     // for multy range we'll reset it in ODA
    1:     SetStreamOffset(rangeList->offset);
    1:   } else {
    1:     nsPluginByteRangeStreamListener *brrListener =
38785:       new nsPluginByteRangeStreamListener(pWeakRefPluginStreamListenerPeer);
    1:     if (brrListener)
    1:       converter = brrListener;
    1:     else
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
38785:   mPluginStreamListenerPeer->mPendingRequests += numRequests;
    1: 
    1:   nsCOMPtr<nsISupportsPRUint32> container = do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   rv = container->SetData(MAGIC_REQUEST_CONTEXT);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return channel->AsyncOpen(converter, container);
    1: }
    1: 
    1: NS_IMETHODIMP
38785: nsPluginStreamInfo::GetStreamOffset(PRInt32 *result)
    1: {
    1:   *result = mStreamOffset;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
38785: nsPluginStreamInfo::SetStreamOffset(PRInt32 offset)
    1: {
38785:   mStreamOffset = offset;
    1:   return NS_OK;
    1: }
    1: 
38785: void
38785: nsPluginStreamInfo::SetContentType(const char* contentType)
38785: {
38785:   if (mContentType != nsnull)
38785:     PL_strfree(mContentType);
38785: 
38785:   mContentType = PL_strdup(contentType);
38785: }
38785: 
38785: void
38785: nsPluginStreamInfo::SetSeekable(const PRBool seekable)
38785: {
38785:   mSeekable = seekable;
38785: }
38785: 
38785: void
38785: nsPluginStreamInfo::SetLength(const PRUint32 length)
38785: {
38785:   mLength = length;
38785: }
38785: 
38785: void
38785: nsPluginStreamInfo::SetLastModified(const PRUint32 modified)
38785: {
38785:   mModified = modified;
38785: }
38785: 
38785: void
38785: nsPluginStreamInfo::SetURL(const char* url)
38785: {
38785:   if (mURL)
38785:     PL_strfree(mURL);
38785: 
38785:   mURL = PL_strdup(url);
38785: }
38785: 
38785: void
38785: nsPluginStreamInfo::SetPluginInstance(nsIPluginInstance * aPluginInstance)
38785: {
38785:   NS_IF_ADDREF(mPluginInstance = aPluginInstance);
38785: }
38785: 
38785: void
38785: nsPluginStreamInfo::SetPluginStreamListenerPeer(nsPluginStreamListenerPeer * aPluginStreamListenerPeer)
38785: {
38785:   // not addref'd - nsPluginStreamInfo is owned by mPluginStreamListenerPeer
38785:   mPluginStreamListenerPeer = aPluginStreamListenerPeer;
38785: }
38785: 
    1: class nsPluginCacheListener : public nsIStreamListener
    1: {
    1: public:
    1:   nsPluginCacheListener(nsPluginStreamListenerPeer* aListener);
    1:   virtual ~nsPluginCacheListener();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIREQUESTOBSERVER
    1:   NS_DECL_NSISTREAMLISTENER
    1: 
    1: private:
    1:   nsPluginStreamListenerPeer* mListener;
    1: };
    1: 
    1: nsPluginCacheListener::nsPluginCacheListener(nsPluginStreamListenerPeer* aListener)
    1: {
    1:   mListener = aListener;
    1:   NS_ADDREF(mListener);
    1: }
    1: 
    1: nsPluginCacheListener::~nsPluginCacheListener()
    1: {
    1:   NS_IF_RELEASE(mListener);
    1: }
    1: 
13322: NS_IMPL_ISUPPORTS1(nsPluginCacheListener, nsIStreamListener)
21231: 
    1: NS_IMETHODIMP
    1: nsPluginCacheListener::OnStartRequest(nsIRequest *request, nsISupports* ctxt)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginCacheListener::OnDataAvailable(nsIRequest *request, nsISupports* ctxt,
    1:                                        nsIInputStream* aIStream,
    1:                                        PRUint32 sourceOffset,
    1:                                        PRUint32 aLength)
    1: {
    1: 
    1:   PRUint32 readlen;
    1:   char* buffer = (char*) PR_Malloc(aLength);
    1: 
    1:   // if we don't read from the stream, OnStopRequest will never be called
    1:   if (!buffer)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv = aIStream->Read(buffer, aLength, &readlen);
    1: 
    1:   NS_ASSERTION(aLength == readlen, "nsCacheListener->OnDataAvailable: "
    1:                "readlen != aLength");
    1: 
    1:   PR_Free(buffer);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginCacheListener::OnStopRequest(nsIRequest *request,
    1:                                      nsISupports* aContext,
    1:                                      nsresult aStatus)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsPluginStreamListenerPeer::nsPluginStreamListenerPeer()
    1: {
38785:   mURL = nsnull;
38785:   mOwner = nsnull;
38785:   mInstance = nsnull;
38785:   mPStreamListener = nsnull;
32799:   mStreamType = NP_NORMAL;
    1:   mStartBinding = PR_FALSE;
    1:   mAbort = PR_FALSE;
    1:   mRequestFailed = PR_FALSE;
    1: 
    1:   mPendingRequests = 0;
    1:   mHaveFiredOnStartRequest = PR_FALSE;
    1:   mDataForwardToRequest = nsnull;
38785:   mLocalCachedFile = nsnull;
    1: }
    1: 
    1: nsPluginStreamListenerPeer::~nsPluginStreamListenerPeer()
    1: {
    1: #ifdef PLUGIN_LOGGING
38785:   nsCAutoString urlSpec;
38785:   if (mURL != nsnull) mURL->GetSpec(urlSpec);
38785: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
38785:     ("nsPluginStreamListenerPeer::dtor this=%p, url=%s%c",this, urlSpec.get(), mLocalCachedFile?',':'\n'));
    1: #endif
    1: 
38785:   NS_IF_RELEASE(mURL);
38785:   NS_IF_RELEASE(mOwner);
38785:   NS_IF_RELEASE(mInstance);
38785:   NS_IF_RELEASE(mPStreamListener);
38785: 
    1:   // close FD of mFileCacheOutputStream if it's still open
    1:   // or we won't be able to remove the cache file
    1:   if (mFileCacheOutputStream)
    1:     mFileCacheOutputStream = nsnull;
    1: 
    1:   // if we have mLocalCachedFile lets release it
    1:   // and it'll be fiscally remove if refcnt == 1
    1:   if (mLocalCachedFile) {
    1:     nsrefcnt refcnt;
    1:     NS_RELEASE2(mLocalCachedFile, refcnt);
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:     nsCAutoString filePath;
    1:     mLocalCachedFile->GetNativePath(filePath);
    1: 
    1:     PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
    1:       ("LocalyCachedFile=%s has %d refcnt and will %s be deleted now\n",filePath.get(),refcnt,refcnt==1?"":"NOT"));
    1: #endif
    1: 
    1:     if (refcnt == 1) {
    1:       mLocalCachedFile->Remove(PR_FALSE);
38785:       NS_RELEASE(mLocalCachedFile);
    1:     }
    1:   }
    1: 
    1:   delete mDataForwardToRequest;
    1: }
    1: 
38785: NS_IMPL_ISUPPORTS4(nsPluginStreamListenerPeer,
    1:                    nsIStreamListener,
    1:                    nsIRequestObserver,
    1:                    nsIHttpHeaderVisitor,
38785:                    nsISupportsWeakReference)
21231: 
21231: // Called as a result of GetURL and PostURL
    1: nsresult nsPluginStreamListenerPeer::Initialize(nsIURI *aURL,
    1:                                                 nsIPluginInstance *aInstance,
    1:                                                 nsIPluginStreamListener* aListener,
    1:                                                 PRInt32 requestCount)
    1: {
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
29956:   if (aURL != nsnull) aURL->GetAsciiSpec(urlSpec);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
    1:         ("nsPluginStreamListenerPeer::Initialize instance=%p, url=%s\n", aInstance, urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   mURL = aURL;
38785:   NS_ADDREF(mURL);
    1: 
    1:   mInstance = aInstance;
38785:   NS_ADDREF(mInstance);
38785: 
    1:   mPStreamListener = aListener;
38785:   NS_ADDREF(mPStreamListener);
38785: 
38785:   mPluginStreamInfo = new nsPluginStreamInfo();
38785:   if (!mPluginStreamInfo)
38785:     return NS_ERROR_OUT_OF_MEMORY;
38785: 
38785:   mPluginStreamInfo->SetPluginInstance(aInstance);
38785:   mPluginStreamInfo->SetPluginStreamListenerPeer(this);
    1: 
    1:   mPendingRequests = requestCount;
    1: 
    1:   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
    1:   if (!mDataForwardToRequest)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
21231: /* Called by NewEmbeddedPluginStream() - if this is called, we weren't
21231:  * able to load the plugin, so we need to load it later once we figure
21231:  * out the mimetype.  In order to load it later, we need the plugin
37525:  * instance owner.
    1:  */
    1: nsresult nsPluginStreamListenerPeer::InitializeEmbedded(nsIURI *aURL,
    1:                                                         nsIPluginInstance* aInstance,
37525:                                                         nsIPluginInstanceOwner *aOwner)
    1: {
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
29956:   aURL->GetSpec(urlSpec);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
    1:         ("nsPluginStreamListenerPeer::InitializeEmbedded url=%s\n", urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   mURL = aURL;
38785:   NS_ADDREF(mURL);
    1: 
21231:   if (aInstance) {
    1:     NS_ASSERTION(mInstance == nsnull, "nsPluginStreamListenerPeer::InitializeEmbedded mInstance != nsnull");
    1:     mInstance = aInstance;
38785:     NS_ADDREF(mInstance);
    1:   } else {
    1:     mOwner = aOwner;
38785:     NS_IF_ADDREF(mOwner);
38785:   }
38785: 
38785:   mPluginStreamInfo = new nsPluginStreamInfo();
38785:   if (!mPluginStreamInfo)
38785:     return NS_ERROR_OUT_OF_MEMORY;
38785: 
38785:   mPluginStreamInfo->SetPluginInstance(aInstance);
38785:   mPluginStreamInfo->SetPluginStreamListenerPeer(this);
    1: 
    1:   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
    1:   if (!mDataForwardToRequest)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
21231: // Called by NewFullPagePluginStream()
    1: nsresult nsPluginStreamListenerPeer::InitializeFullPage(nsIPluginInstance *aInstance)
    1: {
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
    1:   ("nsPluginStreamListenerPeer::InitializeFullPage instance=%p\n",aInstance));
    1: 
    1:   NS_ASSERTION(mInstance == nsnull, "nsPluginStreamListenerPeer::InitializeFullPage mInstance != nsnull");
    1:   mInstance = aInstance;
38785:   NS_ADDREF(mInstance);
38785: 
38785:   mPluginStreamInfo = new nsPluginStreamInfo();
38785:   if (!mPluginStreamInfo)
38785:     return NS_ERROR_OUT_OF_MEMORY;
38785: 
38785:   mPluginStreamInfo->SetPluginInstance(aInstance);
38785:   mPluginStreamInfo->SetPluginStreamListenerPeer(this);
    1: 
    1:   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
    1:   if (!mDataForwardToRequest)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // SetupPluginCacheFile is called if we have to save the stream to disk.
    1: // the most likely cause for this is either there is no disk cache available
    1: // or the stream is coming from a https server.
    1: //
    1: // These files will be deleted when the host is destroyed.
    1: //
    1: // TODO? What if we fill up the the dest dir?
    1: nsresult
    1: nsPluginStreamListenerPeer::SetupPluginCacheFile(nsIChannel* channel)
    1: {
    1:   nsresult rv = NS_OK;
37525: 
    1:   PRBool useExistingCacheFile = PR_FALSE;
37525: 
37525:   nsRefPtr<nsPluginHost> pluginHost = dont_AddRef(nsPluginHost::GetInst());
37841:   nsTArray< nsAutoPtr<nsPluginInstanceTag> > *instanceTags = pluginHost->InstanceTagArray();
37841:   for (PRUint32 i = 0; i < instanceTags->Length(); i++) {
37841:     nsPluginInstanceTag *instanceTag = (*instanceTags)[i];
37841:     if (instanceTag->mStreams) {
    1:       // most recent streams are at the end of list
37841:       PRInt32 cnt;
37841:       instanceTag->mStreams->Count((PRUint32*)&cnt);
37525:       while (--cnt >= 0) {
37841:         nsPluginStreamListenerPeer *lp =
37841:           reinterpret_cast<nsPluginStreamListenerPeer*>(instanceTag->mStreams->ElementAt(cnt));
38785:         if (lp && lp->mLocalCachedFile && lp->mPluginStreamInfo) {
38785:           useExistingCacheFile = lp->mPluginStreamInfo->UseExistingPluginCacheFile(mPluginStreamInfo);
37525:           if (useExistingCacheFile) {
37525:             mLocalCachedFile = lp->mLocalCachedFile;
38785:             NS_ADDREF(mLocalCachedFile);
37525:             break;
    1:           }
37841:           NS_RELEASE(lp);
    1:         }
    1:       }
37525:       if (useExistingCacheFile)
37525:         break;
37525:     }
37841:   }
    1: 
    1:   if (!useExistingCacheFile) {
    1:     nsCOMPtr<nsIFile> pluginTmp;
29956:     rv = nsPluginHost::GetPluginTempDir(getter_AddRefs(pluginTmp));
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     // Get the filename from the channel
    1:     nsCOMPtr<nsIURI> uri;
    1:     rv = channel->GetURI(getter_AddRefs(uri));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
    1:     if (!url)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsCAutoString filename;
    1:     url->GetFileName(filename);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // Create a file to save our stream into. Should we scramble the name?
18417:     filename.Insert(NS_LITERAL_CSTRING("plugin-"), 0);
    1:     rv = pluginTmp->AppendNative(filename);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // Yes, make it unique.
    1:     rv = pluginTmp->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // create a file output stream to write to...
    1:     nsCOMPtr<nsIOutputStream> outstream;
    1:     rv = NS_NewLocalFileOutputStream(getter_AddRefs(mFileCacheOutputStream), pluginTmp, -1, 00600);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // save the file.
38785:     CallQueryInterface(pluginTmp, &mLocalCachedFile); // no need to check return value, just addref
38785:     // add one extra refcnt, we can use NS_RELEASE2(mLocalCachedFile...) in dtor
    1:     // to remove this file when refcnt == 1
    1:     NS_ADDREF(mLocalCachedFile);
    1:   }
    1: 
    1:   // add this listenerPeer to list of stream peers for this instance
24790:   // it'll delay release of listenerPeer until nsPluginInstanceTag::~nsPluginInstanceTag
    1:   // and the temp file is going to stay alive until then
37841:   nsPluginInstanceTag *instanceTag = pluginHost->FindInstanceTag(mInstance);
37841:   if (instanceTag) {
37841:     if (!instanceTag->mStreams &&
37841:         (NS_FAILED(rv = NS_NewISupportsArray(getter_AddRefs(instanceTag->mStreams))))) {
37841:       return rv;
37841:     }
37841: 
37841:     nsISupports* supports = static_cast<nsISupports*>((static_cast<nsIStreamListener*>(this)));
37841:     instanceTag->mStreams->AppendElement(supports);
37841:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginStreamListenerPeer::OnStartRequest(nsIRequest *request,
    1:                                            nsISupports* aContext)
    1: {
    1:   nsresult  rv = NS_OK;
    1: 
    1:   if (mHaveFiredOnStartRequest) {
    1:       return NS_OK;
    1:   }
    1: 
    1:   mHaveFiredOnStartRequest = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
    1:   NS_ENSURE_TRUE(channel, NS_ERROR_FAILURE);
    1: 
    1:   // deal with 404 (Not Found) HTTP response,
    1:   // just return, this causes the request to be ignored.
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:   if (httpChannel) {
    1:     PRUint32 responseCode = 0;
    1:     rv = httpChannel->GetResponseStatus(&responseCode);
16367:     if (NS_FAILED(rv)) {
    1:       // NPP_Notify() will be called from OnStopRequest
19246:       // in nsNPAPIPluginStreamListener::CleanUpStream
    1:       // return error will cancel this request
    1:       // ...and we also need to tell the plugin that
    1:       mRequestFailed = PR_TRUE;
    1:       return NS_ERROR_FAILURE;
    1:     }
16367: 
16367:     if (responseCode > 206) { // not normal
16367:       PRBool bWantsAllNetworkStreams = PR_FALSE;
32799:       mInstance->GetValueFromPlugin(NPPVpluginWantsAllNetworkStreams,
16367:                                     (void*)&bWantsAllNetworkStreams);
16367:       if (!bWantsAllNetworkStreams) {
16367:         mRequestFailed = PR_TRUE;
16367:         return NS_ERROR_FAILURE;
16367:       }
16367:     }
    1:   }
    1: 
    1:   // do a little sanity check to make sure our frame isn't gone
    1:   // by getting the tag type and checking for an error, we can determine if
    1:   // the frame is gone
    1:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> pti = do_QueryInterface(mOwner);
29952:     NS_ENSURE_TRUE(pti, NS_ERROR_FAILURE);
    1:     nsPluginTagType tagType;
29952:     if (NS_FAILED(pti->GetTagType(&tagType)))
    1:       return NS_ERROR_FAILURE;  // something happened to our object frame, so bail!
    1:   }
    1: 
    1:   // Get the notification callbacks from the channel and save it as
    1:   // week ref we'll use it in nsPluginStreamInfo::RequestRead() when
    1:   // we'll create channel for byte range request.
    1:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
    1:   channel->GetNotificationCallbacks(getter_AddRefs(callbacks));
    1:   if (callbacks)
    1:     mWeakPtrChannelCallbacks = do_GetWeakReference(callbacks);
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup;
    1:   channel->GetLoadGroup(getter_AddRefs(loadGroup));
    1:   if (loadGroup)
    1:     mWeakPtrChannelLoadGroup = do_GetWeakReference(loadGroup);
    1: 
    1:   PRInt32 length;
    1:   rv = channel->GetContentLength(&length);
    1: 
    1:   // it's possible for the server to not send a Content-Length.
    1:   // we should still work in this case.
    1:   if (NS_FAILED(rv) || length == -1) {
    1:     // check out if this is file channel
    1:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(channel);
    1:     if (fileChannel) {
    1:       // file does not exist
    1:       mRequestFailed = PR_TRUE;
    1:       return NS_ERROR_FAILURE;
    1:     }
38785:     mPluginStreamInfo->SetLength(PRUint32(0));
    1:   }
    1:   else {
38785:     mPluginStreamInfo->SetLength(length);
38785:   }
38785: 
38785:   mPluginStreamInfo->SetRequest(request);
    1: 
    1:   nsCAutoString aContentType; // XXX but we already got the type above!
    1:   rv = channel->GetContentType(aContentType);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIURI> aURL;
    1:   rv = channel->GetURI(getter_AddRefs(aURL));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
38785:   nsCAutoString urlSpec;
38785:   aURL->GetSpec(urlSpec);
38785:   mPluginStreamInfo->SetURL(urlSpec.get());
    1: 
    1:   if (!aContentType.IsEmpty())
38785:     mPluginStreamInfo->SetContentType(aContentType.get());
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NOISY,
    1:   ("nsPluginStreamListenerPeer::OnStartRequest this=%p request=%p mime=%s, url=%s\n",
38785:   this, request, aContentType.get(), urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
32799:   NPWindow* window = nsnull;
    1: 
    1:   // if we don't have an nsIPluginInstance (mInstance), it means
    1:   // we weren't able to load a plugin previously because we
    1:   // didn't have the mimetype.  Now that we do (aContentType),
    1:   // we'll try again with SetUpPluginInstance()
    1:   // which is called by InstantiateEmbeddedPlugin()
    1:   // NOTE: we don't want to try again if we didn't get the MIME type this time
    1: 
21231:   if (!mInstance && mOwner && !aContentType.IsEmpty()) {
38785:     mOwner->GetInstance(mInstance);
    1:     mOwner->GetWindow(window);
37525:     if (!mInstance && window) {
37525:       nsRefPtr<nsPluginHost> pluginHost = dont_AddRef(nsPluginHost::GetInst());
37525: 
    1:       // determine if we need to try embedded again. FullPage takes a different code path
32799:       PRInt32 mode;
    1:       mOwner->GetMode(&mode);
32799:       if (mode == NP_EMBED)
37525:         rv = pluginHost->InstantiateEmbeddedPlugin(aContentType.get(), aURL, mOwner);
    1:       else
37525:         rv = pluginHost->SetUpPluginInstance(aContentType.get(), aURL, mOwner);
    1: 
21231:       if (NS_OK == rv) {
38785:         // GetInstance() adds a ref
38785:         mOwner->GetInstance(mInstance);
21231:         if (mInstance) {
    1:           mInstance->Start();
    1:           mOwner->CreateWidget();
21231:           // If we've got a native window, the let the plugin know about it.
21231:           if (window->window) {
    1:             nsCOMPtr<nsIPluginInstance> inst = mInstance;
    1:             ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Set up the stream listener...
    1:   rv = SetUpStreamListener(request, aURL);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginStreamListenerPeer::OnProgress(nsIRequest *request,
    1:                                                      nsISupports* aContext,
    1:                                                      PRUint64 aProgress,
    1:                                                      PRUint64 aProgressMax)
    1: {
    1:   nsresult rv = NS_OK;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginStreamListenerPeer::OnStatus(nsIRequest *request,
    1:                                                    nsISupports* aContext,
    1:                                                    nsresult aStatus,
    1:                                                    const PRUnichar* aStatusArg)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: class nsPRUintKey : public nsHashKey {
    1: protected:
    1:   PRUint32 mKey;
    1: public:
    1:   nsPRUintKey(PRUint32 key) : mKey(key) {}
    1: 
29956:   PRUint32 HashCode() const {
    1:     return mKey;
    1:   }
    1: 
    1:   PRBool Equals(const nsHashKey *aKey) const {
    1:     return mKey == ((const nsPRUintKey*)aKey)->mKey;
    1:   }
    1:   nsHashKey *Clone() const {
    1:     return new nsPRUintKey(mKey);
    1:   }
    1:   PRUint32 GetValue() { return mKey; }
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginStreamListenerPeer::OnDataAvailable(nsIRequest *request,
    1:                                                           nsISupports* aContext,
    1:                                                           nsIInputStream *aIStream,
    1:                                                           PRUint32 sourceOffset,
    1:                                                           PRUint32 aLength)
    1: {
    1:   if (mRequestFailed)
    1:     return NS_ERROR_FAILURE;
    1: 
21231:   if (mAbort) {
    1:       PRUint32 magicNumber = 0;  // set it to something that is not the magic number.
    1:       nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(aContext);
    1:       if (container)
    1:         container->GetData(&magicNumber);
    1: 
21231:       if (magicNumber != MAGIC_REQUEST_CONTEXT) {
    1:         // this is not one of our range requests
    1:         mAbort = PR_FALSE;
    1:         return NS_BINDING_ABORTED;
    1:       }
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
38785:   if (!mPStreamListener || !mPluginStreamInfo)
    1:     return NS_ERROR_FAILURE;
    1: 
38785:   mPluginStreamInfo->SetRequest(request);
    1: 
    1:   const char * url = nsnull;
38785:   mPluginStreamInfo->GetURL(&url);
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NOISY,
    1:   ("nsPluginStreamListenerPeer::OnDataAvailable this=%p request=%p, offset=%d, length=%d, url=%s\n",
    1:   this, request, sourceOffset, aLength, url ? url : "no url set"));
    1: 
    1:   // if the plugin has requested an AsFileOnly stream, then don't
    1:   // call OnDataAvailable
32799:   if (mStreamType != NP_ASFILEONLY) {
    1:     // get the absolute offset of the request, if one exists.
    1:     nsCOMPtr<nsIByteRangeRequest> brr = do_QueryInterface(request);
    1:     if (brr) {
    1:       if (!mDataForwardToRequest)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       PRInt64 absoluteOffset64 = LL_ZERO;
    1:       brr->GetStartRange(&absoluteOffset64);
    1: 
    1:       // XXX handle 64-bit for real
    1:       PRInt32 absoluteOffset = (PRInt32)nsInt64(absoluteOffset64);
    1: 
    1:       // we need to track how much data we have forwarded to the
    1:       // plugin.
    1: 
    1:       // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240130
    1:       //
    1:       // Why couldn't this be tracked on the plugin info, and not in a
    1:       // *hash table*?
    1:       nsPRUintKey key(absoluteOffset);
    1:       PRInt32 amtForwardToPlugin =
    1:         NS_PTR_TO_INT32(mDataForwardToRequest->Get(&key));
    1:       mDataForwardToRequest->Put(&key, NS_INT32_TO_PTR(amtForwardToPlugin + aLength));
    1: 
38785:       mPluginStreamInfo->SetStreamOffset(absoluteOffset + amtForwardToPlugin);
    1:     }
    1: 
    1:     nsCOMPtr<nsIInputStream> stream = aIStream;
    1: 
    1:     // if we are caching the file ourselves to disk, we want to 'tee' off
    1:     // the data as the plugin read from the stream.  We do this by the magic
    1:     // of an input stream tee.
    1: 
    1:     if (mFileCacheOutputStream) {
    1:         rv = NS_NewInputStreamTee(getter_AddRefs(stream), aIStream, mFileCacheOutputStream);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
38785:     rv =  mPStreamListener->OnDataAvailable(mPluginStreamInfo,
    1:                                             stream,
    1:                                             aLength);
    1: 
    1:     // if a plugin returns an error, the peer must kill the stream
    1:     //   else the stream and PluginStreamListener leak
    1:     if (NS_FAILED(rv))
    1:       request->Cancel(rv);
    1:   }
    1:   else
    1:   {
    1:     // if we don't read from the stream, OnStopRequest will never be called
    1:     char* buffer = new char[aLength];
    1:     PRUint32 amountRead, amountWrote = 0;
    1:     rv = aIStream->Read(buffer, aLength, &amountRead);
    1: 
    1:     // if we are caching this to disk ourselves, lets write the bytes out.
    1:     if (mFileCacheOutputStream) {
    1:       while (amountWrote < amountRead && NS_SUCCEEDED(rv)) {
    1:         rv = mFileCacheOutputStream->Write(buffer, amountRead, &amountWrote);
    1:       }
    1:     }
    1:     delete [] buffer;
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginStreamListenerPeer::OnStopRequest(nsIRequest *request,
    1:                                                         nsISupports* aContext,
    1:                                                         nsresult aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NOISY,
    1:   ("nsPluginStreamListenerPeer::OnStopRequest this=%p aStatus=%d request=%p\n",
    1:   this, aStatus, request));
    1: 
    1:   // for ByteRangeRequest we're just updating the mDataForwardToRequest hash and return.
    1:   nsCOMPtr<nsIByteRangeRequest> brr = do_QueryInterface(request);
    1:   if (brr) {
    1:     PRInt64 absoluteOffset64 = LL_ZERO;
    1:     brr->GetStartRange(&absoluteOffset64);
    1:     // XXX support 64-bit offsets
    1:     PRInt32 absoluteOffset = (PRInt32)nsInt64(absoluteOffset64);
    1: 
    1:     nsPRUintKey key(absoluteOffset);
    1: 
    1:     // remove the request from our data forwarding count hash.
29956:     mDataForwardToRequest->Remove(&key);
    1: 
    1: 
    1:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
    1:     ("                          ::OnStopRequest for ByteRangeRequest Started=%d\n",
    1:     absoluteOffset));
    1:   } else {
    1:     // if this is not byte range request and
    1:     // if we are writting the stream to disk ourselves,
    1:     // close & tear it down here
    1:     mFileCacheOutputStream = nsnull;
    1:   }
    1: 
    1:   // if we still have pending stuff to do, lets not close the plugin socket.
    1:   if (--mPendingRequests > 0)
    1:       return NS_OK;
    1: 
    1:   // we keep our connections around...
    1:   nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(aContext);
    1:   if (container) {
    1:     PRUint32 magicNumber = 0;  // set it to something that is not the magic number.
    1:     container->GetData(&magicNumber);
    1:     if (magicNumber == MAGIC_REQUEST_CONTEXT) {
    1:       // this is one of our range requests
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   if (!mPStreamListener)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
    1:   if (!channel)
    1:     return NS_ERROR_FAILURE;
    1:   // Set the content type to ensure we don't pass null to the plugin
    1:   nsCAutoString aContentType;
    1:   rv = channel->GetContentType(aContentType);
15572:   if (NS_FAILED(rv) && !mRequestFailed)
    1:     return rv;
    1: 
    1:   if (!aContentType.IsEmpty())
38785:     mPluginStreamInfo->SetContentType(aContentType.get());
    1: 
    1:   // set error status if stream failed so we notify the plugin
    1:   if (mRequestFailed)
    1:     aStatus = NS_ERROR_FAILURE;
    1: 
    1:   if (NS_FAILED(aStatus)) {
    1:     // on error status cleanup the stream
    1:     // and return w/o OnFileAvailable()
38785:     mPStreamListener->OnStopBinding(mPluginStreamInfo, aStatus);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // call OnFileAvailable if plugin requests stream type StreamType_AsFile or StreamType_AsFileOnly
32799:   if (mStreamType >= NP_ASFILE) {
38785:     nsCOMPtr<nsIFile> localFile = do_QueryInterface(mLocalCachedFile);
    1:     if (!localFile) {
    1:       nsCOMPtr<nsICachingChannel> cacheChannel = do_QueryInterface(request);
    1:       if (cacheChannel) {
    1:         cacheChannel->GetCacheFile(getter_AddRefs(localFile));
    1:       } else {
    1:         // see if it is a file channel.
    1:         nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(request);
    1:         if (fileChannel) {
    1:           fileChannel->GetFile(getter_AddRefs(localFile));
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (localFile) {
    1:       OnFileAvailable(localFile);
    1:     }
    1:   }
    1: 
21231:   if (mStartBinding) {
    1:     // On start binding has been called
38785:     mPStreamListener->OnStopBinding(mPluginStreamInfo, aStatus);
21231:   } else {
    1:     // OnStartBinding hasn't been called, so complete the action.
38785:     mPStreamListener->OnStartBinding(mPluginStreamInfo);
38785:     mPStreamListener->OnStopBinding(mPluginStreamInfo, aStatus);
38785:   }
38785: 
38785:   if (NS_SUCCEEDED(aStatus))
38785:     mPluginStreamInfo->SetStreamComplete(PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginStreamListenerPeer::SetUpStreamListener(nsIRequest *request,
    1:                                                          nsIURI* aURL)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // If we don't yet have a stream listener, we need to get
    1:   // one from the plugin.
    1:   // NOTE: this should only happen when a stream was NOT created
    1:   // with GetURL or PostURL (i.e. it's the initial stream we
    1:   // send to the plugin as determined by the SRC or DATA attribute)
29834:   if (!mPStreamListener && mInstance)
38785:     rv = mInstance->NewStreamToPlugin(&mPStreamListener);
29834: 
29834:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
29834:   if (!mPStreamListener)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRBool useLocalCache = PR_FALSE;
    1: 
    1:   // get httpChannel to retrieve some info we need for nsIPluginStreamInfo setup
    1:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
    1: 
    1:   /*
    1:    * Assumption
    1:    * By the time nsPluginStreamListenerPeer::OnDataAvailable() gets
    1:    * called, all the headers have been read.
    1:    */
    1:   if (httpChannel) {
    1:     // Reassemble the HTTP response status line and provide it to our
    1:     // listener.  Would be nice if we could get the raw status line,
    1:     // but nsIHttpChannel doesn't currently provide that.
    1:     nsCOMPtr<nsIHTTPHeaderListener> listener =
    1:       do_QueryInterface(mPStreamListener);
    1:     if (listener) {
    1:       // Status code: required; the status line isn't useful without it.
    1:       PRUint32 statusNum;
    1:       if (NS_SUCCEEDED(httpChannel->GetResponseStatus(&statusNum)) &&
    1:           statusNum < 1000) {
    1:         // HTTP version: provide if available.  Defaults to empty string.
    1:         nsCString ver;
    1:         nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal =
    1:           do_QueryInterface(channel);
    1:         if (httpChannelInternal) {
    1:           PRUint32 major, minor;
    1:           if (NS_SUCCEEDED(httpChannelInternal->GetResponseVersion(&major,
    1:                                                                    &minor))) {
    1:             ver = nsPrintfCString("/%lu.%lu", major, minor);
    1:           }
    1:         }
    1: 
    1:         // Status text: provide if available.  Defaults to "OK".
    1:         nsCString statusText;
   47:         if (NS_FAILED(httpChannel->GetResponseStatusText(statusText))) {
    1:           statusText = "OK";
    1:         }
    1: 
    1:         // Assemble everything and pass to listener.
    1:         nsPrintfCString status(100, "HTTP%s %lu %s", ver.get(), statusNum,
    1:                                statusText.get());
    1:         listener->StatusLine(status.get());
    1:       }
    1:     }
    1: 
    1:     // Also provide all HTTP response headers to our listener.
    1:     httpChannel->VisitResponseHeaders(this);
    1: 
38785:     PRBool bSeekable = PR_FALSE;
    1:     // first we look for a content-encoding header. If we find one, we tell the
    1:     // plugin that stream is not seekable, because the plugin always sees
    1:     // uncompressed data, so it can't make meaningful range requests on a
    1:     // compressed entity.  Also, we force the plugin to use
    1:     // nsPluginStreamType_AsFile stream type and we have to save decompressed
    1:     // file into local plugin cache, because necko cache contains original
    1:     // compressed file.
    1:     nsCAutoString contentEncoding;
    1:     if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("Content-Encoding"),
    1:                                                     contentEncoding))) {
    1:       useLocalCache = PR_TRUE;
    1:     } else {
    1:       // set seekability (seekable if the stream has a known length and if the
    1:       // http server accepts byte ranges).
    1:       PRUint32 length;
38785:       mPluginStreamInfo->GetLength(&length);
    1:       if (length) {
    1:         nsCAutoString range;
    1:         if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("accept-ranges"), range)) &&
    1:           range.Equals(NS_LITERAL_CSTRING("bytes"), nsCaseInsensitiveCStringComparator())) {
38785:           bSeekable = PR_TRUE;
38785:           // nsPluginStreamInfo.mSeekable intitialized by PR_FALSE in ctor of nsPluginStreamInfo
38785:           // so we reset it only here.
38785:           mPluginStreamInfo->SetSeekable(bSeekable);
    1:         }
    1:       }
    1:     }
    1: 
    1:     // we require a content len
    1:     // get Last-Modified header for plugin info
    1:     nsCAutoString lastModified;
    1:     if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"), lastModified)) &&
21231:         !lastModified.IsEmpty()) {
    1:       PRTime time64;
    1:       PR_ParseTimeString(lastModified.get(), PR_TRUE, &time64);  //convert string time to integer time
    1: 
    1:       // Convert PRTime to unix-style time_t, i.e. seconds since the epoch
    1:       double fpTime;
    1:       LL_L2D(fpTime, time64);
38785:       mPluginStreamInfo->SetLastModified((PRUint32)(fpTime * 1e-6 + 0.5));
38785:     }
38785:   }
38785: 
38785:   rv = mPStreamListener->OnStartBinding(mPluginStreamInfo);
    1: 
    1:   mStartBinding = PR_TRUE;
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   mPStreamListener->GetStreamType(&mStreamType);
    1: 
32799:   if (!useLocalCache && mStreamType >= NP_ASFILE) {
    1:     // check it out if this is not a file channel.
    1:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(request);
    1:     if (!fileChannel) {
    1:       // and browser cache is not available
    1:       nsCOMPtr<nsICachingChannel> cacheChannel = do_QueryInterface(request);
    1:       if (!(cacheChannel && (NS_SUCCEEDED(cacheChannel->SetCacheAsFile(PR_TRUE))))) {
    1:         useLocalCache = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (useLocalCache) {
    1:     SetupPluginCacheFile(channel);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPluginStreamListenerPeer::OnFileAvailable(nsIFile* aFile)
    1: {
    1:   nsresult rv;
    1:   if (!mPStreamListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString path;
    1:   rv = aFile->GetNativePath(path);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   if (path.IsEmpty()) {
    1:     NS_WARNING("empty path");
    1:     return NS_OK;
    1:   }
    1: 
38785:   rv = mPStreamListener->OnFileAvailable(mPluginStreamInfo, path.get());
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginStreamListenerPeer::VisitHeader(const nsACString &header, const nsACString &value)
    1: {
    1:   nsCOMPtr<nsIHTTPHeaderListener> listener = do_QueryInterface(mPStreamListener);
    1:   if (!listener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return listener->NewResponseHeader(PromiseFlatCString(header).get(),
    1:                                      PromiseFlatCString(value).get());
    1: }
    1: 
29956: nsPluginHost::nsPluginHost()
31646:   // No need to initialize members to nsnull, PR_FALSE etc because this class
31646:   // has a zeroing operator new.
31800: {
    1:   // check to see if pref is set at startup to let plugins take over in
    1:   // full page mode for certain image mime types that we handle internally
    1:   mPrefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (mPrefService) {
    1:     PRBool tmp;
    1:     nsresult rv = mPrefService->GetBoolPref("plugin.override_internal_types",
    1:                                             &tmp);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       mOverrideInternalTypes = tmp;
    1:     }
    1: 
    1:     rv = mPrefService->GetBoolPref("plugin.allow_alien_star_handler", &tmp);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       mAllowAlienStarHandler = tmp;
    1:     }
    1: 
    1:     rv = mPrefService->GetBoolPref("plugin.default_plugin_disabled", &tmp);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       mDefaultPluginDisabled = tmp;
    1:     }
    1: 
37523:     rv = mPrefService->GetBoolPref("plugin.disable", &tmp);
37523:     if (NS_SUCCEEDED(rv)) {
37523:       mPluginsDisabled = tmp;
37523:     }
37523: 
    1: #ifdef WINCE
    1:     mDefaultPluginDisabled = PR_TRUE;
    1: #endif
    1:   }
    1: 
    1:   nsCOMPtr<nsIObserverService> obsService = do_GetService("@mozilla.org/observer-service;1");
24475:   if (obsService) {
    1:     obsService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_FALSE);
24475:     obsService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_FALSE);
    1:   }
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsPluginLogging::gNPNLog = PR_NewLogModule(NPN_LOG_NAME);
    1:   nsPluginLogging::gNPPLog = PR_NewLogModule(NPP_LOG_NAME);
    1:   nsPluginLogging::gPluginLog = PR_NewLogModule(PLUGIN_LOG_NAME);
    1: 
    1:   PR_LOG(nsPluginLogging::gNPNLog, PLUGIN_LOG_ALWAYS,("NPN Logging Active!\n"));
29956:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_ALWAYS,("General Plugin Logging Active! (nsPluginHost::ctor)\n"));
    1:   PR_LOG(nsPluginLogging::gNPPLog, PLUGIN_LOG_ALWAYS,("NPP Logging Active!\n"));
    1: 
29956:   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHost::ctor\n"));
    1:   PR_LogFlush();
    1: #endif
36227: 
36227: #ifdef MAC_CARBON_PLUGINS
36227:   mVisiblePluginTimer = do_CreateInstance("@mozilla.org/timer;1");
36227:   mHiddenPluginTimer = do_CreateInstance("@mozilla.org/timer;1");
36227: #endif
    1: }
    1: 
29956: nsPluginHost::~nsPluginHost()
29956: {
29956:   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHost::dtor\n"));
    1: 
    1:   Destroy();
    1:   sInst = nsnull;
    1: }
    1: 
36297: NS_IMPL_ISUPPORTS4(nsPluginHost,
    1:                    nsIPluginHost,
    1:                    nsIObserver,
36297:                    nsITimerCallback,
    1:                    nsISupportsWeakReference)
21231: 
29956: nsPluginHost*
29956: nsPluginHost::GetInst()
    1: {
    1:   if (!sInst) {
29956:     sInst = new nsPluginHost();
21231:     if (!sInst)
    1:       return nsnull;
    1:     NS_ADDREF(sInst);
    1:   }
    1: 
    1:   NS_ADDREF(sInst);
    1:   return sInst;
    1: }
    1: 
29956: PRBool nsPluginHost::IsRunningPlugin(nsPluginTag * plugin)
    1: {
    1:   if (!plugin)
    1:     return PR_FALSE;
    1: 
    1:   if (!plugin->mLibrary)
    1:     return PR_FALSE;
    1: 
    1:   for (int i = 0; i < plugin->mVariants; i++) {
37841:     nsPluginInstanceTag *instanceTag = FindInstanceTag(plugin->mMimeTypeArray[i]);
37841:     if (instanceTag && instanceTag->mInstance->IsRunning())
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
29956: nsresult nsPluginHost::ReloadPlugins(PRBool reloadPages)
    1: {
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::ReloadPlugins Begin reloadPages=%d, active_instance_count=%d\n",
37841:   reloadPages, mInstanceTags.Length()));
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // this will create the initial plugin list out of cache
    1:   // if it was not created yet
    1:   if (!mPluginsLoaded)
    1:     return LoadPlugins();
    1: 
    1:   // we are re-scanning plugins. New plugins may have been added, also some
    1:   // plugins may have been removed, so we should probably shut everything down
    1:   // but don't touch running (active and  not stopped) plugins
    1: 
    1:   // check if plugins changed, no need to do anything else
    1:   // if no changes to plugins have been made
    1:   // PR_FALSE instructs not to touch the plugin list, just to
    1:   // look for possible changes
    1:   PRBool pluginschanged = PR_TRUE;
    1:   FindPlugins(PR_FALSE, &pluginschanged);
    1: 
    1:   // if no changed detected, return an appropriate error code
    1:   if (!pluginschanged)
    1:     return NS_ERROR_PLUGINS_PLUGINSNOTCHANGED;
    1: 
    1:   nsCOMPtr<nsISupportsArray> instsToReload;
    1:   if (reloadPages) {
    1:     NS_NewISupportsArray(getter_AddRefs(instsToReload));
    1: 
    1:     // Then stop any running plugin instances but hold on to the documents in the array
    1:     // We are going to need to restart the instances in these documents later
37525:     StopRunningInstances(instsToReload, nsnull);
37525:   }
    1: 
    1:   // shutdown plugins and kill the list if there are no running plugins
 3102:   nsRefPtr<nsPluginTag> prev;
 3102:   nsRefPtr<nsPluginTag> next;
 3102: 
 3102:   for (nsRefPtr<nsPluginTag> p = mPlugins; p != nsnull;) {
    1:     next = p->mNext;
    1: 
29079:     // only remove our plugin from the list if it's not running.
29079:     if (!IsRunningPlugin(p)) {
    1:       if (p == mPlugins)
    1:         mPlugins = next;
    1:       else
    1:         prev->mNext = next;
    1: 
 3102:       p->mNext = nsnull;
35426: 
35426:       // attempt to unload plugins whenever they are removed from the list
35426:       p->TryUnloadPlugin();
35426: 
    1:       p = next;
    1:       continue;
    1:     }
    1: 
    1:     prev = p;
    1:     p = next;
    1:   }
    1: 
    1:   // set flags
    1:   mPluginsLoaded = PR_FALSE;
    1: 
    1:   // load them again
    1:   rv = LoadPlugins();
    1: 
    1:   // If we have shut down any plugin instances, we've now got to restart them.
    1:   // Post an event to do the rest as we are going to be destroying the frame tree and we also want
    1:   // any posted unload events to finish
    1:   PRUint32 c;
    1:   if (reloadPages &&
    1:       instsToReload &&
    1:       NS_SUCCEEDED(instsToReload->Count(&c)) &&
    1:       c > 0) {
    1:     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
    1:     if (ev)
    1:       NS_DispatchToCurrentThread(ev);
    1:   }
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::ReloadPlugins End active_instance_count=%d\n",
37841:   mInstanceTags.Length()));
    1: 
    1:   return rv;
    1: }
    1: 
    1: #define NS_RETURN_UASTRING_SIZE 128
    1: 
29956: nsresult nsPluginHost::UserAgent(const char **retstring)
    1: {
    1:   static char resultString[NS_RETURN_UASTRING_SIZE];
    1:   nsresult res;
    1: 
    1:   nsCOMPtr<nsIHttpProtocolHandler> http = do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &res);
    1:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCAutoString uaString;
    1:   res = http->GetUserAgent(uaString);
    1: 
21231:   if (NS_SUCCEEDED(res)) {
21231:     if (NS_RETURN_UASTRING_SIZE > uaString.Length()) {
    1:       PL_strcpy(resultString, uaString.get());
21231:     } else {
16368:       // Copy as much of UA string as we can (terminate at right-most space).
16368:       PL_strncpy(resultString, uaString.get(), NS_RETURN_UASTRING_SIZE);
21231:       for (int i = NS_RETURN_UASTRING_SIZE - 1; i >= 0; i--) {
21231:         if (i == 0) {
16368:           resultString[NS_RETURN_UASTRING_SIZE - 1] = '\0';
21231:         }
21231:         else if (resultString[i] == ' ') {
16368:           resultString[i] = '\0';
16368:           break;
16368:         }
16368:       }
16368:     }
    1:     *retstring = resultString;
    1:   }
21231:   else {
    1:     *retstring = nsnull;
21231:   }
    1: 
29956:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::UserAgent return=%s\n", *retstring));
    1: 
    1:   return res;
    1: }
    1: 
29956: nsresult nsPluginHost::GetPrompt(nsIPluginInstanceOwner *aOwner, nsIPrompt **aPrompt)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrompt> prompt;
    1:   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1: 
    1:   if (wwatch) {
    1:     nsCOMPtr<nsIDOMWindow> domWindow;
    1:     if (aOwner) {
    1:       nsCOMPtr<nsIDocument> document;
    1:       aOwner->GetDocument(getter_AddRefs(document));
    1:       if (document) {
    1:         domWindow = document->GetWindow();
    1:       }
    1:     }
    1: 
    1:     if (!domWindow) {
    1:       wwatch->GetWindowByName(NS_LITERAL_STRING("_content").get(), nsnull, getter_AddRefs(domWindow));
    1:     }
    1:     rv = wwatch->GetNewPrompter(domWindow, getter_AddRefs(prompt));
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aPrompt = prompt);
    1:   return rv;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::GetURL(nsISupports* pluginInst,
    1:                                    const char* url,
    1:                                    const char* target,
    1:                                    nsIPluginStreamListener* streamListener,
    1:                                    const char* altHost,
    1:                                    const char* referrer,
    1:                                    PRBool forceJSEnabled)
    1: {
    1:   return GetURLWithHeaders(pluginInst, url, target, streamListener,
    1:                            altHost, referrer, forceJSEnabled, nsnull, nsnull);
    1: }
    1: 
29956: nsresult nsPluginHost::GetURLWithHeaders(nsISupports* pluginInst,
    1:                                          const char* url,
    1:                                          const char* target,
    1:                                          nsIPluginStreamListener* streamListener,
    1:                                          const char* altHost,
    1:                                          const char* referrer,
    1:                                          PRBool forceJSEnabled,
    1:                                          PRUint32 getHeadersLength,
    1:                                          const char* getHeaders)
    1: {
21231:   nsAutoString string;
21231:   string.AssignWithConversion(url);
    1: 
    1:   // we can only send a stream back to the plugin (as specified by a
    1:   // null target) if we also have a nsIPluginStreamListener to talk to
21231:   if (!target && !streamListener)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
21231:   nsresult rv;
    1:   nsCOMPtr<nsIPluginInstance> instance = do_QueryInterface(pluginInst, &rv);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
    1:   rv = DoURLLoadSecurityCheck(instance, url);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
21231:   if (target) {
    1:     nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:     rv = instance->GetOwner(getter_AddRefs(owner));
21231:     if (owner) {
    1:       if ((0 == PL_strcmp(target, "newwindow")) ||
    1:           (0 == PL_strcmp(target, "_new")))
    1:         target = "_blank";
    1:       else if (0 == PL_strcmp(target, "_current"))
    1:         target = "_self";
    1: 
36766:       rv = owner->GetURL(url, target, nsnull, nsnull, 0);
    1:     }
    1:   }
    1: 
34262:   if (streamListener)
    1:     rv = NewPluginURLStream(string, instance, streamListener, nsnull,
36766:                             getHeaders, getHeadersLength);
    1: 
    1:   return rv;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::PostURL(nsISupports* pluginInst,
    1:                                     const char* url,
    1:                                     PRUint32 postDataLen,
    1:                                     const char* postData,
    1:                                     PRBool isFile,
    1:                                     const char* target,
    1:                                     nsIPluginStreamListener* streamListener,
    1:                                     const char* altHost,
    1:                                     const char* referrer,
    1:                                     PRBool forceJSEnabled,
    1:                                     PRUint32 postHeadersLength,
    1:                                     const char* postHeaders)
    1: {
34262:   nsAutoString string;
    1:   nsresult rv;
    1: 
34262:   string.AssignWithConversion(url);
34262: 
    1:   // we can only send a stream back to the plugin (as specified
    1:   // by a null target) if we also have a nsIPluginStreamListener
    1:   // to talk to also
21231:   if (!target && !streamListener)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   nsCOMPtr<nsIPluginInstance> instance = do_QueryInterface(pluginInst, &rv);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
    1:   rv = DoURLLoadSecurityCheck(instance, url);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
36766:   nsCOMPtr<nsIInputStream> postStream;
    1:   if (isFile) {
36766:     nsCOMPtr<nsIFile> file;
36766:     rv = CreateTempFileToPost(postData, getter_AddRefs(file));
36766:     if (NS_FAILED(rv))
36766:       return rv;
36766: 
36766:     nsCOMPtr<nsIInputStream> fileStream;
36766:     rv = NS_NewLocalFileInputStream(getter_AddRefs(fileStream),
36766:                                     file,
36766:                                     PR_RDONLY,
36766:                                     0600,
36766:                                     nsIFileInputStream::DELETE_ON_CLOSE |
36766:                                     nsIFileInputStream::CLOSE_ON_EOF);
36766:     if (NS_FAILED(rv))
36766:       return rv;
36766: 
36766:     rv = NS_NewBufferedInputStream(getter_AddRefs(postStream), fileStream, 8192);
36766:     if (NS_FAILED(rv))
21231:       return rv;
    1:   } else {
36766:     char *dataToPost;
    1:     PRUint32 newDataToPostLen;
    1:     ParsePostBufferToFixHeaders(postData, postDataLen, &dataToPost, &newDataToPostLen);
    1:     if (!dataToPost)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
36766:     nsCOMPtr<nsIStringInputStream> sis = do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
36766:     if (!sis) {
36766:       NS_Free(dataToPost);
36766:       return rv;
36766:     }
36766: 
36766:     // data allocated by ParsePostBufferToFixHeaders() is managed and
36766:     // freed by the string stream.
    1:     postDataLen = newDataToPostLen;
36766:     sis->AdoptData(dataToPost, postDataLen);
36766:     postStream = sis;
    1:   }
    1: 
21231:   if (target) {
    1:     nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:     rv = instance->GetOwner(getter_AddRefs(owner));
21231:     if (owner) {
    1:       if (!target) {
    1:         target = "_self";
29834:       } else {
    1:         if ((0 == PL_strcmp(target, "newwindow")) ||
21231:             (0 == PL_strcmp(target, "_new"))) {
    1:           target = "_blank";
29834:         } else if (0 == PL_strcmp(target, "_current")) {
    1:           target = "_self";
    1:         }
21231:       }
36766:       rv = owner->GetURL(url, target, postStream,
36766:                          (void*)postHeaders, postHeadersLength);
    1:     }
    1:   }
    1: 
    1:   // if we don't have a target, just create a stream.  This does
    1:   // NS_OpenURI()!
21231:   if (streamListener)
    1:     rv = NewPluginURLStream(string, instance, streamListener,
36766:                             postStream, postHeaders, postHeadersLength);
    1: 
    1:   return rv;
    1: }
    1: 
21231: /* This method queries the prefs for proxy information.
    1:  * It has been tested and is known to work in the following three cases
    1:  * when no proxy host or port is specified
    1:  * when only the proxy host is specified
    1:  * when only the proxy port is specified
    1:  * This method conforms to the return code specified in
    1:  * http://developer.netscape.com/docs/manuals/proxy/adminnt/autoconf.htm#1020923
    1:  * with the exception that multiple values are not implemented.
    1:  */
    1: 
29956: NS_IMETHODIMP nsPluginHost::FindProxyForURL(const char* url, char* *result)
    1: {
    1:   if (!url || !result) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1:   nsresult res;
    1: 
    1:   nsCOMPtr<nsIURI> uriIn;
    1:   nsCOMPtr<nsIProtocolProxyService> proxyService;
    1:   nsCOMPtr<nsIIOService> ioService;
    1: 
    1:   proxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &res);
21231:   if (NS_FAILED(res) || !proxyService)
    1:     return res;
    1: 
    1:   ioService = do_GetService(NS_IOSERVICE_CONTRACTID, &res);
21231:   if (NS_FAILED(res) || !ioService)
    1:     return res;
    1: 
    1:   // make an nsURI from the argument url
    1:   res = ioService->NewURI(nsDependentCString(url), nsnull, nsnull, getter_AddRefs(uriIn));
21231:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCOMPtr<nsIProxyInfo> pi;
    1: 
    1:   res = proxyService->Resolve(uriIn, 0, getter_AddRefs(pi));
21231:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   nsCAutoString host, type;
    1:   PRInt32 port = -1;
    1: 
    1:   // These won't fail, and even if they do... we'll be ok.
    1:   if (pi) {
    1:     pi->GetType(type);
    1:     pi->GetHost(host);
    1:     pi->GetPort(&port);
    1:   }
    1: 
    1:   if (!pi || host.IsEmpty() || port <= 0 || host.EqualsLiteral("direct")) {
    1:     *result = PL_strdup("DIRECT");
    1:   } else if (type.EqualsLiteral("http")) {
    1:     *result = PR_smprintf("PROXY %s:%d", host.get(), port);
    1:   } else if (type.EqualsLiteral("socks4")) {
    1:     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
    1:   } else if (type.EqualsLiteral("socks")) {
    1:     // XXX - this is socks5, but there is no API for us to tell the
    1:     // plugin that fact. SOCKS for now, in case the proxy server
    1:     // speaks SOCKS4 as well. See bug 78176
    1:     // For a long time this was returning an http proxy type, so
    1:     // very little is probably broken by this
    1:     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
    1:   } else {
    1:     NS_ASSERTION(PR_FALSE, "Unknown proxy type!");
    1:     *result = PL_strdup("DIRECT");
    1:   }
    1: 
21231:   if (nsnull == *result)
    1:     res = NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return res;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::Init()
    1: {
    1:   return NS_OK;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::Destroy()
29956: {
29956:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::Destroy Called\n"));
    1: 
    1:   if (mIsDestroyed)
    1:     return NS_OK;
    1: 
    1:   mIsDestroyed = PR_TRUE;
    1: 
    1:   // we should call nsIPluginInstance::Stop and nsIPluginInstance::SetWindow
    1:   // for those plugins who want it
37525:   StopRunningInstances(nsnull, nsnull);
    1: 
35426:   nsPluginTag *pluginTag;
35426:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
35426:     pluginTag->TryUnloadPlugin();
    1:   }
    1: 
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mPlugins, mNext);
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
    1: 
    1:   // Lets remove any of the temporary files that we created.
    1:   if (sPluginTempDir) {
    1:     sPluginTempDir->Remove(PR_TRUE);
    1:     NS_RELEASE(sPluginTempDir);
    1:   }
    1: 
 3715: #ifdef XP_WIN
21231:   if (mPrivateDirServiceProvider) {
    1:     nsCOMPtr<nsIDirectoryService> dirService =
    1:       do_GetService(kDirectoryServiceContractID);
    1:     if (dirService)
    1:       dirService->UnregisterProvider(mPrivateDirServiceProvider);
    1:     mPrivateDirServiceProvider = nsnull;
    1:   }
 3715: #endif /* XP_WIN */
    1: 
    1:   mPrefService = nsnull; // release prefs service to avoid leaks!
    1: 
    1:   return NS_OK;
    1: }
    1: 
29956: void nsPluginHost::UnloadUnusedLibraries()
    1: {
    1:   // unload any remaining plugin libraries from memory
26912:   for (PRUint32 i = 0; i < mUnusedLibraries.Length(); i++) {
26912:     PRLibrary * library = mUnusedLibraries[i];
    1:     if (library)
    1:       PostPluginUnloadEvent(library);
    1:   }
    1:   mUnusedLibraries.Clear();
    1: }
    1: 
37525: void nsPluginHost::OnPluginInstanceDestroyed(nsPluginTag* aPluginTag)
37525: {
37525:   PRBool hasInstance = PR_FALSE;
37841:   for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:     if (mInstanceTags[i]->mPluginTag == aPluginTag) {
37525:       hasInstance = PR_TRUE;
37525:       break;
37525:     }
37525:   }
37525: 
37525:   if (!hasInstance) {
37525:     nsresult rv;
37525:     nsCOMPtr<nsIPrefBranch> pref(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
37525:     if (NS_FAILED(rv))
37525:       return;
37525: 
37525:     PRBool unloadPluginsASAP = PR_FALSE;
37525:     rv = pref->GetBoolPref("plugins.unloadASAP", &unloadPluginsASAP);
37525:     if (NS_SUCCEEDED(rv) && unloadPluginsASAP)
37525:       aPluginTag->TryUnloadPlugin();
37525:   }
37525: }
37525: 
    1: nsresult
29956: nsPluginHost::GetPluginTempDir(nsIFile **aDir)
    1: {
    1:   if (!sPluginTempDir) {
    1:     nsCOMPtr<nsIFile> tmpDir;
    1:     nsresult rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR,
    1:                                          getter_AddRefs(tmpDir));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = tmpDir->AppendNative(kPluginTmpDirName);
    1: 
    1:     // make it unique, and mode == 0700, not world-readable
    1:     rv = tmpDir->CreateUnique(nsIFile::DIRECTORY_TYPE, 0700);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     tmpDir.swap(sPluginTempDir);
    1:   }
    1: 
    1:   return sPluginTempDir->Clone(aDir);
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::InstantiatePluginForChannel(nsIChannel* aChannel,
    1:                                                             nsIPluginInstanceOwner* aOwner,
    1:                                                             nsIStreamListener** aListener)
    1: {
    1:   NS_PRECONDITION(aChannel && aOwner,
    1:                   "Invalid arguments to InstantiatePluginForChannel");
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = aChannel->GetURI(getter_AddRefs(uri));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   if (PR_LOG_TEST(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL)) {
    1:     nsCAutoString urlSpec;
    1:     uri->GetAsciiSpec(urlSpec);
    1: 
    1:     PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:            ("nsPluginHost::InstantiatePluginForChannel Begin owner=%p, url=%s\n",
    1:            aOwner, urlSpec.get()));
    1: 
    1:     PR_LogFlush();
    1:   }
    1: #endif
    1: 
    1:   // XXX do we need to look for stopped plugins, like InstantiateEmbeddedPlugin
    1:   // does?
    1: 
    1:   return NewEmbeddedPluginStreamListener(uri, aOwner, nsnull, aListener);
    1: }
    1: 
36227: // Called by nsPluginInstanceOwner
29956: NS_IMETHODIMP nsPluginHost::InstantiateEmbeddedPlugin(const char *aMimeType,
    1:                                                           nsIURI* aURL,
    1:                                                           nsIPluginInstanceOwner *aOwner)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOwner);
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
21231:   if (aURL)
21231:     aURL->GetAsciiSpec(urlSpec);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:         ("nsPluginHost::InstantiateEmbeddedPlugin Begin mime=%s, owner=%p, url=%s\n",
    1:         aMimeType, aOwner, urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   nsresult  rv;
    1:   nsIPluginInstance *instance = nsnull;
29952:   nsCOMPtr<nsIPluginTagInfo> pti;
    1:   nsPluginTagType tagType;
    1: 
29952:   rv = aOwner->QueryInterface(kIPluginTagInfoIID, getter_AddRefs(pti));
    1: 
21231:   if (rv != NS_OK)
    1:     return rv;
    1: 
29952:   rv = pti->GetTagType(&tagType);
    1: 
    1:   if ((rv != NS_OK) || !((tagType == nsPluginTagType_Embed)
    1:                         || (tagType == nsPluginTagType_Applet)
21231:                         || (tagType == nsPluginTagType_Object))) {
    1:     return rv;
    1:   }
    1: 
    1:   // Security checks
    1:   // Can't do security checks without a URI - hopefully the plugin will take
    1:   // care of that
    1:   if (aURL) {
    1:     nsCOMPtr<nsIScriptSecurityManager> secMan =
    1:                     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv))
    1:       return rv; // Better fail if we can't do security checks
    1: 
    1:     nsCOMPtr<nsIDocument> doc;
    1:     aOwner->GetDocument(getter_AddRefs(doc));
    1:     if (!doc)
    1:       return NS_ERROR_NULL_POINTER;
    1: 
    1:     rv = secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), aURL, 0);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDOMElement> elem;
29952:     pti->GetDOMElement(getter_AddRefs(elem));
    1: 
    1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT; // default permit
    1:     nsresult rv =
    1:       NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT,
    1:                                 aURL,
 4367:                                 doc->NodePrincipal(),
    1:                                 elem,
    1:                                 nsDependentCString(aMimeType ? aMimeType : ""),
    1:                                 nsnull, //extra
    1:                                 &shouldLoad);
    1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad))
    1:       return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
    1:   }
    1: 
    1:   // Look for even disabled plugins, because if the plugin for this type is
    1:   // disabled, we don't want to go on and end up in SetUpDefaultPluginInstance.
    1:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_FALSE);
    1:   if (pluginTag) {
21231:     if (!pluginTag->IsEnabled())
    1:       return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
 5649:   PRBool isJava = pluginTag && pluginTag->mIsJavaPlugin;
    1: 
    1:   // Determine if the scheme of this URL is one we can handle internaly because we should
    1:   // only open the initial stream if it's one that we can handle internally. Otherwise
    1:   // |NS_OpenURI| in |InstantiateEmbeddedPlugin| may open up a OS protocal registered helper app
    1:   PRBool bCanHandleInternally = PR_FALSE;
    1:   nsCAutoString scheme;
    1:   if (aURL && NS_SUCCEEDED(aURL->GetScheme(scheme))) {
    1:       nsCAutoString contractID(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX);
    1:       contractID += scheme;
    1:       ToLowerCase(contractID);
    1:       nsCOMPtr<nsIProtocolHandler> handler = do_GetService(contractID.get());
    1:       if (handler)
    1:         bCanHandleInternally = PR_TRUE;
    1:   }
    1: 
    1:   if (FindStoppedPluginForURL(aURL, aOwner) == NS_OK) {
    1: 
    1:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
29956:     ("nsPluginHost::InstantiateEmbeddedPlugin FoundStopped mime=%s\n", aMimeType));
    1: 
    1:     aOwner->GetInstance(instance);
    1:     if (!isJava && bCanHandleInternally)
    1:       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
    1: 
    1:     // notify Java DOM component
    1:     nsresult res;
    1:     nsCOMPtr<nsIPluginInstanceOwner> javaDOM =
    1:              do_GetService("@mozilla.org/blackwood/java-dom;1", &res);
    1:     if (NS_SUCCEEDED(res) && javaDOM)
    1:       javaDOM->SetInstance(instance);
    1: 
    1:     NS_IF_RELEASE(instance);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if we don't have a MIME type at this point, we still have one more chance by
    1:   // opening the stream and seeing if the server hands one back
    1:   if (!aMimeType)
    1:     return bCanHandleInternally ? NewEmbeddedPluginStream(aURL, aOwner, nsnull) : NS_ERROR_FAILURE;
    1: 
    1:   rv = SetUpPluginInstance(aMimeType, aURL, aOwner);
    1: 
21231:   if (rv == NS_OK) {
    1:     rv = aOwner->GetInstance(instance);
21231:   } else {
21231:    /* If we are here, it's time to either show the default plugin
    1:     * or return failure so layout will replace us.
    1:     *
    1:     * Currently, the default plugin is shown for all EMBED and APPLET
    1:     * tags and also any OBJECT tag that has a PLUGINURL PARAM tag name.
    1:     */
    1: 
    1:     PRBool bHasPluginURL = PR_FALSE;
29952:     nsCOMPtr<nsIPluginTagInfo> pti(do_QueryInterface(aOwner));
29952: 
29952:     if (pti) {
    1:       const char *value;
29952:       bHasPluginURL = NS_SUCCEEDED(pti->GetParameter("PLUGINURL", &value));
    1:     }
    1: 
    1:     // if we didn't find a pluginURL param on the object tag,
    1:     // there's nothing more to do here
    1:     if (nsPluginTagType_Object == tagType && !bHasPluginURL)
    1:       return rv;
    1: 
    1:     if (NS_FAILED(SetUpDefaultPluginInstance(aMimeType, aURL, aOwner)))
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     if (NS_FAILED(aOwner->GetInstance(instance)))
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     rv = NS_OK;
    1:   }
    1: 
    1:   // if we have a failure error, it means we found a plugin for the mimetype,
    1:   // but we had a problem with the entry point
    1:   if (rv == NS_ERROR_FAILURE)
    1:     return rv;
    1: 
    1:   // if we are here then we have loaded a plugin for this mimetype
    1:   // and it could be the Default plugin
    1: 
32799:   NPWindow *window = nsnull;
    1: 
    1:   //we got a plugin built, now stream
    1:   aOwner->GetWindow(window);
    1: 
21231:   if (instance) {
    1:     instance->Start();
    1:     aOwner->CreateWidget();
    1: 
    1:     // If we've got a native window, the let the plugin know about it.
21231:     if (window->window) {
    1:       nsCOMPtr<nsIPluginInstance> inst = instance;
    1:       ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
    1:     }
    1: 
    1:     // create an initial stream with data
    1:     // don't make the stream if it's a java applet or we don't have SRC or DATA attribute
    1:     PRBool havedata = PR_FALSE;
    1: 
    1:     nsCOMPtr<nsIPluginTagInfo> pti(do_QueryInterface(aOwner, &rv));
    1: 
    1:     if (pti) {
    1:       const char *value;
    1:       havedata = NS_SUCCEEDED(pti->GetAttribute("SRC", &value));
    1:       // no need to check for "data" as it would have been converted to "src"
    1:     }
    1: 
    1:     if (havedata && !isJava && bCanHandleInternally)
    1:       rv = NewEmbeddedPluginStream(aURL, aOwner, instance);
    1: 
    1:     // notify Java DOM component
    1:     nsresult res;
    1:     nsCOMPtr<nsIPluginInstanceOwner> javaDOM =
    1:              do_GetService("@mozilla.org/blackwood/java-dom;1", &res);
    1:     if (NS_SUCCEEDED(res) && javaDOM)
    1:       javaDOM->SetInstance(instance);
    1: 
    1:     NS_RELEASE(instance);
    1:   }
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec2;
29956:   if (aURL != nsnull) aURL->GetAsciiSpec(urlSpec2);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:         ("nsPluginHost::InstantiateEmbeddedPlugin Finished mime=%s, rv=%d, owner=%p, url=%s\n",
    1:         aMimeType, rv, aOwner, urlSpec2.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
21231: // Called by full-page case
29956: NS_IMETHODIMP nsPluginHost::InstantiateFullPagePlugin(const char *aMimeType,
    1:                                                           nsIURI* aURI,
    1:                                                           nsIStreamListener *&aStreamListener,
    1:                                                           nsIPluginInstanceOwner *aOwner)
    1: {
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
    1:   aURI->GetSpec(urlSpec);
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::InstantiateFullPagePlugin Begin mime=%s, owner=%p, url=%s\n",
    1:   aMimeType, aOwner, urlSpec.get()));
    1: #endif
    1: 
    1:   if (FindStoppedPluginForURL(aURI, aOwner) == NS_OK) {
    1:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
29956:     ("nsPluginHost::InstantiateFullPagePlugin FoundStopped mime=%s\n",aMimeType));
    1: 
    1:     nsIPluginInstance* instance;
    1:     aOwner->GetInstance(instance);
    1:     nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
 5649:     if (!pluginTag || !pluginTag->mIsJavaPlugin)
    1:       NewFullPagePluginStream(aStreamListener, instance);
    1:     NS_IF_RELEASE(instance);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = SetUpPluginInstance(aMimeType, aURI, aOwner);
    1: 
21231:   if (NS_OK == rv) {
    1:     nsCOMPtr<nsIPluginInstance> instance;
32799:     NPWindow* win = nsnull;
    1: 
    1:     aOwner->GetInstance(*getter_AddRefs(instance));
    1:     aOwner->GetWindow(win);
    1: 
21231:     if (win && instance) {
    1:       instance->Start();
    1:       aOwner->CreateWidget();
    1: 
    1:       // If we've got a native window, the let the plugin know about it.
    1:       nsPluginNativeWindow * window = (nsPluginNativeWindow *)win;
    1:       if (window->window)
    1:         window->CallSetWindow(instance);
    1: 
    1:       rv = NewFullPagePluginStream(aStreamListener, instance);
    1: 
    1:       // If we've got a native window, the let the plugin know about it.
    1:       if (window->window)
    1:         window->CallSetWindow(instance);
    1:     }
    1:   }
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::InstantiateFullPagePlugin End mime=%s, rv=%d, owner=%p, url=%s\n",
    1:   aMimeType, rv, aOwner, urlSpec.get()));
    1: 
    1:   return rv;
    1: }
    1: 
37199: nsPluginTag*
37841: nsPluginHost::FindTagForPlugin(nsIPlugin* aPlugin)
37199: {
37199:   nsPluginTag* pluginTag;
37199:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
37199:     if (pluginTag->mEntryPoint == aPlugin) {
37199:       return pluginTag;
37199:     }
37199:   }
37199:   return nsnull;
37199: }
37199: 
29956: nsresult nsPluginHost::FindStoppedPluginForURL(nsIURI* aURL,
    1:                                                nsIPluginInstanceOwner *aOwner)
    1: {
    1:   nsCAutoString url;
    1:   if (!aURL)
    1:     return NS_ERROR_FAILURE;
    1: 
21231:   aURL->GetAsciiSpec(url);
    1: 
37841:   nsPluginInstanceTag *instanceTag = FindStoppedInstanceTag(url.get());
37841: 
37841:   if (instanceTag && !instanceTag->mInstance->IsRunning()) {
32799:     NPWindow* window = nsnull;
    1:     aOwner->GetWindow(window);
    1: 
37841:     nsIPluginInstance* instance = static_cast<nsIPluginInstance*>(instanceTag->mInstance);
    1:     aOwner->SetInstance(instance);
29834:     instance->SetOwner(aOwner);
    1: 
    1:     instance->Start();
    1:     aOwner->CreateWidget();
    1: 
    1:     // If we've got a native window, the let the plugin know about it.
21231:     if (window->window) {
    1:       nsCOMPtr<nsIPluginInstance> inst = instance;
    1:       ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
37841: nsresult nsPluginHost::AddInstanceToActiveList(nsCOMPtr<nsIPlugin> aPlugin,
37841:                                                nsIPluginInstance* aInstance,
37841:                                                nsIURI* aURL,
37841:                                                PRBool aDefaultPlugin)
37841: {
37841:   nsCAutoString url;
37841:   // It's OK to not have a URL here, as is the case with the dummy
37841:   // Java plugin. In that case simply use an empty string...
37841:   if (aURL)
37841:     aURL->GetSpec(url);
37841: 
37841:   // Let's find the corresponding plugin tag by matching nsIPlugin pointer.
37841:   // It is going to be used later when we decide whether or not we should delay
37841:   // unloading NPAPI dll from memory.
37841:   nsPluginTag * pluginTag = nsnull;
37841:   if (aPlugin) {
37841:     pluginTag = FindTagForPlugin(aPlugin);
37841:     NS_ASSERTION(pluginTag, "Plugin tag not found");
37841:   }
37841: 
37841:   nsPluginInstanceTag *instanceTag = new nsPluginInstanceTag(pluginTag, aInstance, url.get(), aDefaultPlugin);
37841:   if (!instanceTag)
37841:     return NS_ERROR_OUT_OF_MEMORY;
37841: 
37841:   mInstanceTags.AppendElement(instanceTag);
37841:   return NS_OK;
37841: }
37841: 
29956: NS_IMETHODIMP nsPluginHost::SetUpPluginInstance(const char *aMimeType,
    1:                                                 nsIURI *aURL,
    1:                                                 nsIPluginInstanceOwner *aOwner)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
    1: 
    1:   // if we fail, refresh plugin list just in case the plugin has been
    1:   // just added and try to instantiate plugin instance again, see bug 143178
    1:   if (NS_FAILED(rv)) {
    1:     // we should also make sure not to do this more than once per page
    1:     // so if there are a few embed tags with unknown plugins,
    1:     // we don't get unnecessary overhead
    1:     // let's cache document to decide whether this is the same page or not
    1:     nsCOMPtr<nsIDocument> document;
    1:     if (aOwner)
    1:       aOwner->GetDocument(getter_AddRefs(document));
    1: 
    1:     nsCOMPtr<nsIDocument> currentdocument = do_QueryReferent(mCurrentDocument);
    1:     if (document == currentdocument)
    1:       return rv;
    1: 
    1:     mCurrentDocument = do_GetWeakReference(document);
    1: 
    1:     // ReloadPlugins will do the job smartly: nothing will be done
    1:     // if no changes detected, in such a case just return
    1:     if (NS_ERROR_PLUGINS_PLUGINSNOTCHANGED == ReloadPlugins(PR_FALSE))
    1:       return rv;
    1: 
    1:     // other failure return codes may be not fatal, so we can still try
31646:     aOwner->SetInstance(nsnull); // avoid assert about setting it twice
    1:     rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
29574: nsresult
29956: nsPluginHost::TrySetUpPluginInstance(const char *aMimeType,
    1:                                      nsIURI *aURL,
    1:                                      nsIPluginInstanceOwner *aOwner)
    1: {
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec;
29956:   if (aURL != nsnull) aURL->GetSpec(urlSpec);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
29956:         ("nsPluginHost::TrySetupPluginInstance Begin mime=%s, owner=%p, url=%s\n",
    1:         aMimeType, aOwner, urlSpec.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1: 
    1:   nsresult result = NS_ERROR_FAILURE;
    1:   nsCOMPtr<nsIPluginInstance> instance;
    1:   nsCOMPtr<nsIPlugin> plugin;
    1:   const char* mimetype = nsnull;
    1: 
    1:   // if don't have a mimetype or no plugin can handle this mimetype
    1:   // check by file extension
    1:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
13521:   if (!pluginTag) {
    1:     nsCOMPtr<nsIURL> url = do_QueryInterface(aURL);
    1:     if (!url) return NS_ERROR_FAILURE;
    1: 
    1:     nsCAutoString fileExtension;
    1:     url->GetFileExtension(fileExtension);
    1: 
    1:     // if we don't have an extension or no plugin for this extension,
    1:     // return failure as there is nothing more we can do
    1:     if (fileExtension.IsEmpty() ||
    1:         !(pluginTag = FindPluginEnabledForExtension(fileExtension.get(),
    1:                                                     mimetype))) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
29020:   else {
    1:     mimetype = aMimeType;
29020:   }
    1: 
    1:   NS_ASSERTION(pluginTag, "Must have plugin tag here!");
28071: 
30057:   GetPlugin(mimetype, getter_AddRefs(plugin));
    1: 
    1:   if (plugin) {
25861: #if defined(XP_WIN) && !defined(WINCE)
    1:     static BOOL firstJavaPlugin = FALSE;
    1:     BOOL restoreOrigDir = FALSE;
38313:     WCHAR origDir[_MAX_PATH];
29020:     if (pluginTag->mIsJavaPlugin && !firstJavaPlugin) {
38313:       DWORD dw = GetCurrentDirectoryW(_MAX_PATH, origDir);
34718:       NS_ASSERTION(dw <= _MAX_PATH, "Failed to obtain the current directory, which may lead to incorrect class loading");
    1:       nsCOMPtr<nsIFile> binDirectory;
    1:       result = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
    1:                                       getter_AddRefs(binDirectory));
    1: 
    1:       if (NS_SUCCEEDED(result)) {
38313:         nsAutoString path;
38313:         binDirectory->GetPath(path);
38313:         restoreOrigDir = SetCurrentDirectoryW(path.get());
    1:       }
    1:     }
    1: #endif
30057:     result = plugin->CreatePluginInstance(getter_AddRefs(instance));
    1: 
25861: #if defined(XP_WIN) && !defined(WINCE)
    1:     if (!firstJavaPlugin && restoreOrigDir) {
38313:       BOOL bCheck = SetCurrentDirectoryW(origDir);
34718:       NS_ASSERTION(bCheck, "Error restoring directory");
    1:       firstJavaPlugin = TRUE;
    1:     }
    1: #endif
    1:   }
    1: 
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   // it is adreffed here
    1:   aOwner->SetInstance(instance);
    1: 
36223:   // this should not addref the instance or owner
36223:   // except in some cases not Java, see bug 140931
36223:   // our COM pointer will free the peer
36223:   result = instance->Initialize(aOwner, mimetype);
36223:   if (NS_FAILED(result)) {
36223:     aOwner->SetInstance(nsnull);
36223:     return result;
36223:   }
    1: 
37841:   // instance and peer will be addreffed here
37841:   result = AddInstanceToActiveList(plugin, instance, aURL, PR_FALSE);
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString urlSpec2;
    1:   if (aURL)
    1:     aURL->GetSpec(urlSpec2);
    1: 
    1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
29956:         ("nsPluginHost::TrySetupPluginInstance Finished mime=%s, rv=%d, owner=%p, url=%s\n",
    1:         aMimeType, result, aOwner, urlSpec2.get()));
    1: 
    1:   PR_LogFlush();
    1: #endif
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
29956: nsPluginHost::SetUpDefaultPluginInstance(const char *aMimeType,
    1:                                          nsIURI *aURL,
    1:                                          nsIPluginInstanceOwner *aOwner)
    1: {
    1:   if (mDefaultPluginDisabled) {
    1:     // The default plugin is disabled, don't load it.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPluginInstance> instance;
    1:   nsCOMPtr<nsIPlugin> plugin = NULL;
    1:   const char* mimetype = aMimeType;
    1: 
    1:   if (!aURL)
    1:     return NS_ERROR_FAILURE;
    1: 
30057:   GetPlugin("*", getter_AddRefs(plugin));
    1: 
29079:   nsresult result = NS_ERROR_OUT_OF_MEMORY;
    1:   if (plugin)
30057:     result = plugin->CreatePluginInstance(getter_AddRefs(instance));
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   // it is adreffed here
    1:   aOwner->SetInstance(instance);
    1: 
    1:   // if we don't have a mimetype, check by file extension
    1:   nsXPIDLCString mt;
21231:   if (!mimetype || !*mimetype) {
    1:     nsresult res = NS_OK;
    1:     nsCOMPtr<nsIMIMEService> ms (do_GetService(NS_MIMESERVICE_CONTRACTID, &res));
21231:     if (NS_SUCCEEDED(res)) {
    1:       res = ms->GetTypeFromURI(aURL, mt);
    1:       if (NS_SUCCEEDED(res))
    1:         mimetype = mt.get();
    1:     }
    1:   }
    1: 
29834:   // this should not addref the instance or owner
29834:   result = instance->Initialize(aOwner, mimetype);
36223:   if (NS_FAILED(result)) {
36223:     aOwner->SetInstance(nsnull);
    1:     return result;
36223:   }
    1: 
29834:   // instance will be addreffed here
37841:   result = AddInstanceToActiveList(plugin, instance, aURL, PR_TRUE);
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::IsPluginEnabledForType(const char* aMimeType)
    1: {
37883:   nsPluginTag *plugin = FindPluginForType(aMimeType, PR_TRUE);
37883:   if (plugin)
37883:     return NS_OK;
37883: 
    1:   // Pass PR_FALSE as the second arg so we can return NS_ERROR_PLUGIN_DISABLED
    1:   // for disabled plug-ins.
37883:   plugin = FindPluginForType(aMimeType, PR_FALSE);
21231:   if (!plugin)
    1:     return NS_ERROR_FAILURE;
    1: 
13222:   if (!plugin->IsEnabled()) {
 3464:     if (plugin->HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED))
 3464:       return NS_ERROR_PLUGIN_BLOCKLISTED;
 3464:     else
    1:       return NS_ERROR_PLUGIN_DISABLED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // check comma delimitered extensions
    1: static int CompareExtensions(const char *aExtensionList, const char *aExtension)
    1: {
21231:   if (!aExtensionList || !aExtension)
    1:     return -1;
    1: 
    1:   const char *pExt = aExtensionList;
    1:   const char *pComma = strchr(pExt, ',');
21231:   if (!pComma)
    1:     return PL_strcasecmp(pExt, aExtension);
    1: 
    1:   int extlen = strlen(aExtension);
21231:   while (pComma) {
    1:     int length = pComma - pExt;
    1:     if (length == extlen && 0 == PL_strncasecmp(aExtension, pExt, length))
    1:       return 0;
    1:     pComma++;
    1:     pExt = pComma;
    1:     pComma = strchr(pExt, ',');
    1:   }
    1: 
    1:   // the last one
    1:   return PL_strcasecmp(pExt, aExtension);
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::IsPluginEnabledForExtension(const char* aExtension,
    1:                                           const char* &aMimeType)
    1: {
    1:   nsPluginTag *plugin = FindPluginEnabledForExtension(aExtension, aMimeType);
    1:   return plugin ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: class DOMMimeTypeImpl : public nsIDOMMimeType {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
12841:   DOMMimeTypeImpl(nsPluginTag* aTag, PRUint32 aMimeTypeIndex)
12841:   {
12841:     if (!aTag)
12841:       return;
12841:     CopyUTF8toUTF16(aTag->mMimeDescriptionArray[aMimeTypeIndex], mDescription);
12841:     if (aTag->mExtensionsArray)
12841:       CopyUTF8toUTF16(aTag->mExtensionsArray[aMimeTypeIndex], mSuffixes);
12841:     if (aTag->mMimeTypeArray)
12841:       CopyUTF8toUTF16(aTag->mMimeTypeArray[aMimeTypeIndex], mType);
    1:   }
    1: 
    1:   virtual ~DOMMimeTypeImpl() {
    1:   }
    1: 
    1:   NS_METHOD GetDescription(nsAString& aDescription)
    1:   {
    1:     aDescription.Assign(mDescription);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetEnabledPlugin(nsIDOMPlugin** aEnabledPlugin)
    1:   {
    1:     // this has to be implemented by the DOM version.
    1:     *aEnabledPlugin = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetSuffixes(nsAString& aSuffixes)
    1:   {
    1:     aSuffixes.Assign(mSuffixes);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetType(nsAString& aType)
    1:   {
    1:     aType.Assign(mType);
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsString mDescription;
    1:   nsString mSuffixes;
    1:   nsString mType;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(DOMMimeTypeImpl, nsIDOMMimeType)
21231: 
    1: class DOMPluginImpl : public nsIDOMPlugin {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   DOMPluginImpl(nsPluginTag* aPluginTag) : mPluginTag(aPluginTag)
    1:   {
    1:   }
    1: 
    1:   virtual ~DOMPluginImpl() {
    1:   }
    1: 
    1:   NS_METHOD GetDescription(nsAString& aDescription)
    1:   {
12841:     CopyUTF8toUTF16(mPluginTag.mDescription, aDescription);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetFilename(nsAString& aFilename)
    1:   {
    1:     PRBool bShowPath;
    1:     nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (prefService &&
    1:         NS_SUCCEEDED(prefService->GetBoolPref("plugin.expose_full_path", &bShowPath)) &&
21231:         bShowPath) {
12841:       CopyUTF8toUTF16(mPluginTag.mFullPath, aFilename);
29020:     } else {
28451:       CopyUTF8toUTF16(mPluginTag.mFileName, aFilename);
29020:     }
29020: 
28451:     return NS_OK;
28451:   }
28451: 
27645:   NS_METHOD GetVersion(nsAString& aVersion)
27645:   {
27645:     CopyUTF8toUTF16(mPluginTag.mVersion, aVersion);
27645:     return NS_OK;
27645:   }
27645: 
    1:   NS_METHOD GetName(nsAString& aName)
    1:   {
12841:     CopyUTF8toUTF16(mPluginTag.mName, aName);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD GetLength(PRUint32* aLength)
    1:   {
    1:     *aLength = mPluginTag.mVariants;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD Item(PRUint32 aIndex, nsIDOMMimeType** aReturn)
    1:   {
    1:     nsIDOMMimeType* mimeType = new DOMMimeTypeImpl(&mPluginTag, aIndex);
    1:     NS_IF_ADDREF(mimeType);
    1:     *aReturn = mimeType;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_METHOD NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
    1:   {
12841:     for (int i = mPluginTag.mVariants - 1; i >= 0; --i) {
12841:       if (aName.Equals(NS_ConvertUTF8toUTF16(mPluginTag.mMimeTypeArray[i])))
12841:         return Item(i, aReturn);
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsPluginTag mPluginTag;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(DOMPluginImpl, nsIDOMPlugin)
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::GetPluginCount(PRUint32* aPluginCount)
    1: {
    1:   LoadPlugins();
    1: 
    1:   PRUint32 count = 0;
    1: 
    1:   nsPluginTag* plugin = mPlugins;
    1:   while (plugin != nsnull) {
13222:     if (plugin->IsEnabled()) {
    1:       ++count;
    1:     }
    1:     plugin = plugin->mNext;
    1:   }
    1: 
    1:   *aPluginCount = count;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::GetPlugins(PRUint32 aPluginCount, nsIDOMPlugin** aPluginArray)
    1: {
    1:   LoadPlugins();
    1: 
    1:   nsPluginTag* plugin = mPlugins;
 3102:   for (PRUint32 i = 0; i < aPluginCount && plugin; plugin = plugin->mNext) {
13222:     if (plugin->IsEnabled()) {
    1:       nsIDOMPlugin* domPlugin = new DOMPluginImpl(plugin);
    1:       NS_IF_ADDREF(domPlugin);
 3102:       aPluginArray[i++] = domPlugin;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 3102: NS_IMETHODIMP
29956: nsPluginHost::GetPluginTags(PRUint32* aPluginCount, nsIPluginTag*** aResults)
 3102: {
 3102:   LoadPlugins();
 3102: 
 3102:   PRUint32 count = 0;
 3102:   nsRefPtr<nsPluginTag> plugin = mPlugins;
 3102:   while (plugin != nsnull) {
 3102:     count++;
 3102:     plugin = plugin->mNext;
 3102:   }
 3102: 
 3233:   *aResults = static_cast<nsIPluginTag**>
 3233:                          (nsMemory::Alloc(count * sizeof(**aResults)));
 3102:   if (!*aResults)
 3102:     return NS_ERROR_OUT_OF_MEMORY;
 3102: 
 3102:   *aPluginCount = count;
 3102: 
 3102:   plugin = mPlugins;
 3102:   PRUint32 i;
 3102:   for (i = 0; i < count; i++) {
 3102:     (*aResults)[i] = plugin;
 3102:     NS_ADDREF((*aResults)[i]);
 3102:     plugin = plugin->mNext;
 3102:   }
 3102: 
 3102:   return NS_OK;
 3102: }
    1: 
    1: nsPluginTag*
29956: nsPluginHost::FindPluginForType(const char* aMimeType,
    1:                                 PRBool aCheckEnabled)
    1: {
    1:   nsPluginTag *plugins = nsnull;
    1:   PRInt32     variants, cnt;
    1: 
    1:   LoadPlugins();
    1: 
    1:   // if we have a mimetype passed in, search the mPlugins
    1:   // linked list for a match
    1:   if (nsnull != aMimeType) {
    1:     plugins = mPlugins;
    1: 
    1:     while (nsnull != plugins) {
    1:       variants = plugins->mVariants;
    1:       for (cnt = 0; cnt < variants; cnt++) {
13222:         if ((!aCheckEnabled || plugins->IsEnabled()) &&
    1:             plugins->mMimeTypeArray[cnt] &&
    1:             (0 == PL_strcasecmp(plugins->mMimeTypeArray[cnt], aMimeType))) {
    1:           return plugins;
    1:         }
    1:       }
    1: 
    1:       plugins = plugins->mNext;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsPluginTag*
29956: nsPluginHost::FindPluginEnabledForExtension(const char* aExtension,
    1:                                             const char*& aMimeType)
    1: {
    1:   nsPluginTag *plugins = nsnull;
    1:   PRInt32     variants, cnt;
    1: 
    1:   LoadPlugins();
    1: 
    1:   // if we have a mimetype passed in, search the mPlugins linked
    1:   // list for a match
21231:   if (aExtension) {
    1:     plugins = mPlugins;
21231:     while (plugins) {
    1:       variants = plugins->mVariants;
21231:       if (plugins->mExtensionsArray) {
21231:         for (cnt = 0; cnt < variants; cnt++) {
    1:           // mExtensionsArray[cnt] is a list of extensions separated
    1:           // by commas
13222:           if (plugins->IsEnabled() &&
21231:               0 == CompareExtensions(plugins->mExtensionsArray[cnt], aExtension)) {
    1:             aMimeType = plugins->mMimeTypeArray[cnt];
    1:             return plugins;
    1:           }
    1:         }
    1:       }
    1: 
    1:       plugins = plugins->mNext;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
12841: static nsresult ConvertToNative(nsIUnicodeEncoder *aEncoder,
12841:                                 const nsACString& aUTF8String,
12841:                                 nsACString& aNativeString)
12841: {
12841:   NS_ConvertUTF8toUTF16 utf16(aUTF8String);
12841:   PRInt32 len = utf16.Length();
12841:   PRInt32 outLen;
12841:   nsresult rv = aEncoder->GetMaxLength(utf16.get(), len, &outLen);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841:   if (!EnsureStringLength(aNativeString, outLen))
12841:     return NS_ERROR_OUT_OF_MEMORY;
12841:   rv = aEncoder->Convert(utf16.get(), &len,
12841:                          aNativeString.BeginWriting(), &outLen);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841:   aNativeString.SetLength(outLen);
12841:   return NS_OK;
12841: }
12841: 
29583: static nsresult CreateNPAPIPlugin(const nsPluginTag *aPluginTag,
30057:                                   nsIPlugin **aOutNPAPIPlugin)
12841: {
12841:   nsresult rv;
12841:   nsCOMPtr <nsIPlatformCharset> pcs =
12841:     do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841: 
12841:   nsCAutoString charset;
12841:   rv = pcs->GetCharset(kPlatformCharsetSel_FileName, charset);
12841:   NS_ENSURE_SUCCESS(rv, rv);
12841: 
29020:   nsCAutoString fullPath;
12841:   if (!charset.LowerCaseEqualsLiteral("utf-8")) {
12841:     nsCOMPtr<nsIUnicodeEncoder> encoder;
12841:     nsCOMPtr<nsICharsetConverterManager> ccm =
12841:       do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
12841:     NS_ENSURE_SUCCESS(rv, rv);
12841:     rv = ccm->GetUnicodeEncoderRaw(charset.get(), getter_AddRefs(encoder));
12841:     NS_ENSURE_SUCCESS(rv, rv);
12841:     rv = ConvertToNative(encoder, aPluginTag->mFullPath, fullPath);
12841:     NS_ENSURE_SUCCESS(rv, rv);
12841:   } else {
12841:     fullPath = aPluginTag->mFullPath;
12841:   }
12841: 
29020:   return nsNPAPIPlugin::CreatePlugin(fullPath.get(),
12841:                                      aPluginTag->mLibrary,
30057:                                      aOutNPAPIPlugin);
30057: }
30057: 
30057: NS_IMETHODIMP nsPluginHost::GetPlugin(const char *aMimeType, nsIPlugin** aPlugin)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   *aPlugin = NULL;
    1: 
    1:   if (!aMimeType)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   // If plugins haven't been scanned yet, do so now
    1:   LoadPlugins();
    1: 
    1:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, PR_TRUE);
21231:   if (pluginTag) {
    1:     rv = NS_OK;
    1:     PLUGIN_LOG(PLUGIN_LOG_BASIC,
30057:     ("nsPluginHost::GetPlugin Begin mime=%s, plugin=%s\n",
12841:     aMimeType, pluginTag->mFileName.get()));
    1: 
    1: #ifdef NS_DEBUG
12841:     if (aMimeType && !pluginTag->mFileName.IsEmpty())
12841:       printf("For %s found plugin %s\n", aMimeType, pluginTag->mFileName.get());
    1: #endif
    1: 
21231:     if (!pluginTag->mLibrary) { // if we haven't done this yet
12841:       if (pluginTag->mFullPath.IsEmpty())
    1:         return NS_ERROR_FAILURE;
29020:       nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
12841:       file->InitWithPath(NS_ConvertUTF8toUTF16(pluginTag->mFullPath));
    1:       nsPluginFile pluginFile(file);
    1:       PRLibrary* pluginLibrary = NULL;
    1: 
    1:       if (pluginFile.LoadPlugin(pluginLibrary) != NS_OK || pluginLibrary == NULL)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       // remove from unused lib list, if it is there
26912:       if (mUnusedLibraries.Contains(pluginLibrary))
    1:         mUnusedLibraries.RemoveElement(pluginLibrary);
    1: 
    1:       pluginTag->mLibrary = pluginLibrary;
    1:     }
    1: 
35426:     nsCOMPtr<nsIPlugin> plugin = pluginTag->mEntryPoint;
21231:     if (!plugin) {
24475:       // Now lets try to get the entry point from an NPAPI plugin
35426:       rv = CreateNPAPIPlugin(pluginTag, getter_AddRefs(plugin));
36102:       if (NS_FAILED(rv))
36102:         return rv;
36102: 
36102:       NS_ASSERTION(plugin, "CreateNPAPIPlugin succeeded without setting 'plugin'");
12841:       pluginTag->mEntryPoint = plugin;
    1:     }
    1: 
35426:     NS_ADDREF(*aPlugin = plugin);
    1:     return NS_OK;
    1:   }
    1: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
30057:   ("nsPluginHost::GetPlugin End mime=%s, rv=%d, plugin=%p name=%s\n",
12841:   aMimeType, rv, *aPlugin,
12841:   (pluginTag ? pluginTag->mFileName.get() : "(not found)")));
    1: 
    1:   return rv;
    1: }
    1: 
    1: // XXX called from ScanPluginsDirectory only when told to filter
    1: // currently 'unwanted' plugins are Java, and all other plugins except
    1: // Acrobat, Flash, Quicktime and Shockwave
    1: static PRBool isUnwantedPlugin(nsPluginTag * tag)
    1: {
12841:   if (tag->mFileName.IsEmpty())
    1:     return PR_TRUE;
    1: 
    1:   for (PRInt32 i = 0; i < tag->mVariants; ++i) {
    1:     if (nsnull == PL_strcasecmp(tag->mMimeTypeArray[i], "application/pdf"))
    1:       return PR_FALSE;
    1: 
    1:     if (nsnull == PL_strcasecmp(tag->mMimeTypeArray[i], "application/x-shockwave-flash"))
    1:       return PR_FALSE;
    1: 
    1:     if (nsnull == PL_strcasecmp(tag->mMimeTypeArray[i],"application/x-director"))
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   // On Windows, we also want to include the Quicktime plugin from the 4.x directory
    1:   // But because it spans several DLL's, the best check for now is by filename
12841:   if (tag->mFileName.Find("npqtplugin", PR_TRUE, 0, -1) != kNotFound)
    1:     return PR_FALSE;
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
29956: PRBool nsPluginHost::IsJavaMIMEType(const char* aType)
    1: {
    1:   return aType &&
    1:     ((0 == PL_strncasecmp(aType, "application/x-java-vm",
    1:                           sizeof("application/x-java-vm") - 1)) ||
    1:      (0 == PL_strncasecmp(aType, "application/x-java-applet",
    1:                           sizeof("application/x-java-applet") - 1)) ||
    1:      (0 == PL_strncasecmp(aType, "application/x-java-bean",
    1:                           sizeof("application/x-java-bean") - 1)));
    1: }
    1: 
29956: nsPluginTag * nsPluginHost::HaveSamePlugin(nsPluginTag * aPluginTag)
    1: {
    1:   for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
    1:     if (tag->Equals(aPluginTag))
    1:       return tag;
    1:   }
    1:   return nsnull;
    1: }
    1: 
29956: PRBool nsPluginHost::IsDuplicatePlugin(nsPluginTag * aPluginTag)
    1: {
    1:   nsPluginTag * tag = HaveSamePlugin(aPluginTag);
    1:   if (tag) {
    1:     // if we got the same plugin, check the full path to see if this is a dup;
    1: 
    1:     // mFileName contains full path on Windows and Unix and leaf name on Mac
    1:     // if those are not equal, we have the same plugin with  different path,
    1:     // i.e. duplicate, return true
12841:     if (!tag->mFileName.Equals(aPluginTag->mFileName))
    1:       return PR_TRUE;
    1: 
    1:     // if they are equal, compare mFullPath fields just in case
    1:     // mFileName contained leaf name only, and if not equal, return true
12841:     if (!tag->mFullPath.Equals(aPluginTag->mFullPath))
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   // we do not have it at all, return false
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Structure for collecting plugin files found during directory scanning
    1: struct pluginFileinDirectory
    1: {
29020:   nsString mFilePath;
    1:   PRInt64  mModTime;
    1: 
    1:   pluginFileinDirectory()
    1:   {
    1:     mModTime = LL_ZERO;
    1:   }
    1: };
    1: 
    1: // QuickSort callback for comparing the modification time of two files
    1: // if the times are the same, compare the filenames
26912: 
26912: NS_SPECIALIZE_TEMPLATE
26912: class nsDefaultComparator<pluginFileinDirectory, pluginFileinDirectory>
26912: {
26912:   public:
26912:   PRBool Equals(const pluginFileinDirectory& aA,
26912:                 const pluginFileinDirectory& aB) const {
26912:     if (aA.mModTime == aB.mModTime &&
29020:         Compare(aA.mFilePath, aB.mFilePath,
26912:                 nsCaseInsensitiveStringComparator()) == 0)
26912:       return PR_TRUE;
    1:     else
26912:       return PR_FALSE;
26912:   }
26912:   PRBool LessThan(const pluginFileinDirectory& aA,
26912:                   const pluginFileinDirectory& aB) const {
26912:     if (aA.mModTime < aB.mModTime)
26912:       return PR_TRUE;
26912:     else if(aA.mModTime == aB.mModTime)
29020:       return Compare(aA.mFilePath, aB.mFilePath,
26912:                      nsCaseInsensitiveStringComparator()) < 0;
26912:     else
26912:       return PR_FALSE;
26912:   }
26912: };
    1: 
19246: typedef NS_NPAPIPLUGIN_CALLBACK(char *, NP_GETMIMEDESCRIPTION)(void);
    1: 
    1: static nsresult FixUpPluginInfo(nsPluginInfo &aInfo, nsPluginFile &aPluginFile)
    1: {
    1: #ifndef XP_WIN
    1:   return NS_OK;
    1: #endif
    1: 
    1:   for (PRUint32 i = 0; i < aInfo.fVariantCount; i++) {
    1:     if (PL_strcmp(aInfo.fMimeTypeArray[i], "*"))
    1:       continue;
    1: 
    1:     // we got "*" type
    1:     // check if this is an alien plugin (not our default plugin)
    1:     // by trying to find a special entry point
    1:     PRLibrary *library = nsnull;
    1:     if (NS_FAILED(aPluginFile.LoadPlugin(library)) || !library)
    1:       return NS_ERROR_FAILURE;
    1: 
 3571:     NP_GETMIMEDESCRIPTION pf = (NP_GETMIMEDESCRIPTION)PR_FindFunctionSymbol(library, "NP_GetMIMEDescription");
    1: 
    1:     if (pf) {
    1:       // if we found it, this is the default plugin, return
    1:       char * mimedescription = pf();
    1:       if (!PL_strncmp(mimedescription, NS_PLUGIN_DEFAULT_MIME_DESCRIPTION, 1))
    1:         return NS_OK;
    1:     }
    1: 
    1:     // if we are here that means we have an alien plugin
    1:     // which wants to take over "*" type
    1: 
    1:     // change its "*" mime type to "[*]"
    1:     PL_strfree(aInfo.fMimeTypeArray[i]);
    1:     aInfo.fMimeTypeArray[i] = PL_strdup("[*]");
    1: 
    1:     // continue the loop?
    1:   }
    1:   return NS_OK;
    1: }
    1: 
29956: nsresult nsPluginHost::ScanPluginsDirectory(nsIFile * pluginsDir,
    1:                                             nsIComponentManager * compManager,
    1:                                             PRBool aCreatePluginList,
    1:                                             PRBool * aPluginsChanged,
    1:                                             PRBool checkForUnwantedPlugins)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPluginsChanged);
    1:   nsresult rv;
    1: 
    1:   *aPluginsChanged = PR_FALSE;
    1: 
    1: #ifdef PLUGIN_LOGGING
    1:   nsCAutoString dirPath;
    1:   pluginsDir->GetNativePath(dirPath);
    1:   PLUGIN_LOG(PLUGIN_LOG_BASIC,
29956:   ("nsPluginHost::ScanPluginsDirectory dir=%s\n", dirPath.get()));
    1: #endif
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> iter;
    1:   rv = pluginsDir->GetDirectoryEntries(getter_AddRefs(iter));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
26912:   // Collect all the files in this directory in an array we can sort later
26912:   nsAutoTArray<pluginFileinDirectory, 8> pluginFilesArray;
    1: 
    1:   PRBool hasMore;
    1:   while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
    1:     nsCOMPtr<nsISupports> supports;
    1:     rv = iter->GetNext(getter_AddRefs(supports));
    1:     if (NS_FAILED(rv))
    1:       continue;
    1:     nsCOMPtr<nsILocalFile> dirEntry(do_QueryInterface(supports, &rv));
    1:     if (NS_FAILED(rv))
    1:       continue;
    1: 
    1:     // Sun's JRE 1.3.1 plugin must have symbolic links resolved or else it'll crash.
    1:     // See bug 197855.
    1:     dirEntry->Normalize();
    1: 
    1:     nsAutoString filePath;
    1:     rv = dirEntry->GetPath(filePath);
    1:     if (NS_FAILED(rv))
    1:       continue;
    1: 
    1:     if (nsPluginsDir::IsPluginFile(dirEntry)) {
26912:       pluginFileinDirectory * item = pluginFilesArray.AppendElement();
    1:       if (!item)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       // Get file mod time
    1:       PRInt64 fileModTime = LL_ZERO;
    1:       dirEntry->GetLastModifiedTime(&fileModTime);
    1: 
    1:       item->mModTime = fileModTime;
29020:       item->mFilePath = filePath;
    1:     }
    1:   } // end round of up of plugin files
    1: 
    1:   // now sort the array by file modification time or by filename, if equal
    1:   // put newer plugins first to weed out dups and catch upgrades, see bug 119966
26912:   pluginFilesArray.Sort();
    1: 
33384:   PRBool warnOutdated = PR_FALSE;
33384: 
    1:   // finally, go through the array, looking at each entry and continue processing it
26912:   for (PRUint32 i = 0; i < pluginFilesArray.Length(); i++) {
26912:     pluginFileinDirectory &pfd = pluginFilesArray[i];
    1:     nsCOMPtr <nsIFile> file = do_CreateInstance("@mozilla.org/file/local;1");
    1:     nsCOMPtr <nsILocalFile> localfile = do_QueryInterface(file);
29020:     localfile->InitWithPath(pfd.mFilePath);
26912:     PRInt64 fileModTime = pfd.mModTime;
    1: 
    1:     // Look for it in our cache
 3102:     nsRefPtr<nsPluginTag> pluginTag;
29020:     RemoveCachedPluginsInfo(NS_ConvertUTF16toUTF8(pfd.mFilePath).get(),
 3102:                             getter_AddRefs(pluginTag));
 3102: 
21189:     PRBool enabled = PR_TRUE;
21189:     PRBool seenBefore = PR_FALSE;
    1:     if (pluginTag) {
21189:       seenBefore = PR_TRUE;
    1:       // If plugin changed, delete cachedPluginTag and don't use cache
    1:       if (LL_NE(fileModTime, pluginTag->mLastModifiedTime)) {
    1:         // Plugins has changed. Don't use cached plugin info.
21189:         enabled = (pluginTag->Flags() & NS_PLUGIN_FLAG_ENABLED) != 0;
    1:         pluginTag = nsnull;
    1: 
    1:         // plugin file changed, flag this fact
    1:         *aPluginsChanged = PR_TRUE;
    1:       }
    1:       else {
    1:         // if it is unwanted plugin we are checking for, get it back to the cache info list
    1:         // if this is a duplicate plugin, too place it back in the cache info list marking unwantedness
    1:         if ((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
15819:            IsDuplicatePlugin(pluginTag)) {
    1:           if (!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED)) {
    1:             // Plugin switched from wanted to unwanted
    1:             *aPluginsChanged = PR_TRUE;
    1:           }
    1:           pluginTag->Mark(NS_PLUGIN_FLAG_UNWANTED);
    1:           pluginTag->mNext = mCachedPlugins;
    1:           mCachedPlugins = pluginTag;
    1:         } else if (pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED)) {
    1:           pluginTag->UnMark(NS_PLUGIN_FLAG_UNWANTED);
    1:           // Plugin switched from unwanted to wanted
    1:           *aPluginsChanged = PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       // plugin file was added, flag this fact
    1:       *aPluginsChanged = PR_TRUE;
    1:     }
    1: 
    1:     // if we are not creating the list, just continue the loop
    1:     // no need to proceed if changes are detected
    1:     if (!aCreatePluginList) {
    1:       if (*aPluginsChanged)
    1:         return NS_OK;
    1:       else
    1:         continue;
    1:     }
    1: 
    1:     // if it is not found in cache info list or has been changed, create a new one
    1:     if (!pluginTag) {
    1:       nsPluginFile pluginFile(file);
    1:       PRLibrary* pluginLibrary = nsnull;
    1: 
    1:       // load the plugin's library so we can ask it some questions, but not for Windows
    1: #ifndef XP_WIN
    1:       if (pluginFile.LoadPlugin(pluginLibrary) != NS_OK || pluginLibrary == nsnull)
    1:         continue;
    1: #endif
    1: 
    1:       // create a tag describing this plugin.
22547:       nsPluginInfo info;
22547:       memset(&info, 0, sizeof(info));
    1:       nsresult res = pluginFile.GetPluginInfo(info);
22547:       // if we don't have mime type don't proceed, this is not a plugin
22547:       if (NS_FAILED(res) || !info.fMimeTypeArray) {
    1:         pluginFile.FreePluginInfo(info);
    1:         continue;
    1:       }
    1: 
    1:       // Check for any potential '*' mime type handlers which are not our
    1:       // own default plugin and disable them as they will break the plugin
    1:       // finder service, see Bugzilla bug 132430
    1:       if (!mAllowAlienStarHandler)
    1:         FixUpPluginInfo(info, pluginFile);
    1: 
    1:       pluginTag = new nsPluginTag(&info);
    1:       pluginFile.FreePluginInfo(info);
    1: 
    1:       if (pluginTag == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       pluginTag->mLibrary = pluginLibrary;
    1:       pluginTag->mLastModifiedTime = fileModTime;
21189: 
21189:       nsCOMPtr<nsIBlocklistService> blocklist = do_GetService("@mozilla.org/extensions/blocklist;1");
21189:       if (blocklist) {
21189:         PRUint32 state;
21189:         rv = blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
21189:                                                 EmptyString(), &state);
21189: 
21189:         if (NS_SUCCEEDED(rv)) {
21189:           // If the blocklist says so then block the plugin. If the blocklist says
21189:           // it is risky and we have never seen this plugin before then disable it
21189:           if (state == nsIBlocklistService::STATE_BLOCKED)
21189:             pluginTag->Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
21189:           else if (state == nsIBlocklistService::STATE_SOFTBLOCKED && !seenBefore)
21189:             enabled = PR_FALSE;
33384:           else if (state == nsIBlocklistService::STATE_OUTDATED && !seenBefore)
33384:             warnOutdated = PR_TRUE;
21189:         }
21189:       }
21189: 
31800:       if (!enabled)
21186:         pluginTag->UnMark(NS_PLUGIN_FLAG_ENABLED);
21186: 
    1:       // if this is unwanted plugin we are checkin for, or this is a duplicate plugin,
    1:       // add it to our cache info list so we can cache the unwantedness of this plugin
    1:       // when we sync cached plugins to registry
    1:       NS_ASSERTION(!pluginTag->HasFlag(NS_PLUGIN_FLAG_UNWANTED),
    1:                    "Brand-new tags should not be unwanted");
    1:       if ((checkForUnwantedPlugins && isUnwantedPlugin(pluginTag)) ||
15819:          IsDuplicatePlugin(pluginTag)) {
    1:         pluginTag->Mark(NS_PLUGIN_FLAG_UNWANTED);
    1:         pluginTag->mNext = mCachedPlugins;
    1:         mCachedPlugins = pluginTag;
    1:       }
    1:     }
    1: 
    1:     // set the flag that we want to add this plugin to the list for now
    1:     // and see if it remains after we check several reasons not to do so
    1:     PRBool bAddIt = PR_TRUE;
    1: 
    1:     // check if this is a specific plugin we don't want
15819:     if (checkForUnwantedPlugins && isUnwantedPlugin(pluginTag))
    1:       bAddIt = PR_FALSE;
    1: 
    1:     // check if we already have this plugin in the list which
    1:     // is possible if we do refresh
    1:     if (bAddIt) {
    1:       if (HaveSamePlugin(pluginTag)) {
    1:         // we cannot get here if the plugin has just been added
    1:         // and thus |pluginTag| is not from cache, because otherwise
    1:         // it would not be present in the list;
    1:         bAddIt = PR_FALSE;
    1:       }
    1:     }
    1: 
21231:     // do it if we still want it
    1:     if (bAddIt) {
    1:       pluginTag->SetHost(this);
    1:       pluginTag->mNext = mPlugins;
    1:       mPlugins = pluginTag;
    1: 
13222:       if (pluginTag->IsEnabled())
    1:         pluginTag->RegisterWithCategoryManager(mOverrideInternalTypes);
    1:     }
    1:   }
33384:   
33384:   if (warnOutdated)
33384:     mPrefService->SetBoolPref("plugins.update.notifyUser", PR_TRUE);
33384: 
    1:   return NS_OK;
    1: }
    1: 
29956: nsresult nsPluginHost::ScanPluginsDirectoryList(nsISimpleEnumerator * dirEnum,
    1:                                                 nsIComponentManager * compManager,
    1:                                                 PRBool aCreatePluginList,
    1:                                                 PRBool * aPluginsChanged,
    1:                                                 PRBool checkForUnwantedPlugins)
    1: {
    1:     PRBool hasMore;
    1:     while (NS_SUCCEEDED(dirEnum->HasMoreElements(&hasMore)) && hasMore) {
    1:       nsCOMPtr<nsISupports> supports;
    1:       nsresult rv = dirEnum->GetNext(getter_AddRefs(supports));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1:       nsCOMPtr<nsIFile> nextDir(do_QueryInterface(supports, &rv));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       // don't pass aPluginsChanged directly to prevent it from been reset
    1:       PRBool pluginschanged = PR_FALSE;
    1:       ScanPluginsDirectory(nextDir, compManager, aCreatePluginList, &pluginschanged, checkForUnwantedPlugins);
    1: 
    1:       if (pluginschanged)
    1:         *aPluginsChanged = PR_TRUE;
    1: 
    1:       // if changes are detected and we are not creating the list, do not proceed
    1:       if (!aCreatePluginList && *aPluginsChanged)
    1:         break;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::LoadPlugins()
    1: {
    1:   // do not do anything if it is already done
    1:   // use ReloadPlugins() to enforce loading
    1:   if (mPluginsLoaded)
    1:     return NS_OK;
    1: 
37523:   if (mPluginsDisabled)
37523:     return NS_OK;
37523: 
    1:   PRBool pluginschanged;
    1:   nsresult rv = FindPlugins(PR_TRUE, &pluginschanged);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
29936:   // only if plugins have changed will we notify plugin-change observers
    1:   if (pluginschanged) {
 3464:     nsCOMPtr<nsIObserverService>
 3464:       obsService(do_GetService("@mozilla.org/observer-service;1"));
 3464:     if (obsService)
 3464:       obsService->NotifyObservers(nsnull, "plugins-list-updated", nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #include "nsITimelineService.h"
    1: 
    1: // if aCreatePluginList is false we will just scan for plugins
    1: // and see if any changes have been made to the plugins.
    1: // This is needed in ReloadPlugins to prevent possible recursive reloads
29956: nsresult nsPluginHost::FindPlugins(PRBool aCreatePluginList, PRBool * aPluginsChanged)
    1: {
    1:   // let's start timing if we are only really creating the plugin list
    1:   if (aCreatePluginList) {
    1:     NS_TIMELINE_START_TIMER("LoadPlugins");
    1:   }
    1: 
    1: #ifdef CALL_SAFETY_ON
    1:   // check preferences on whether or not we want to try safe calls to plugins
    1:   NS_INIT_PLUGIN_SAFE_CALLS;
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aPluginsChanged);
    1: 
    1:   *aPluginsChanged = PR_FALSE;
    1:   nsresult rv;
    1: 
32940:   // Read cached plugins info. If the profile isn't yet available then don't
32940:   // scan for plugins
32940:   if (ReadPluginInfo() == NS_ERROR_NOT_AVAILABLE)
32940:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIComponentManager> compManager;
    1:   NS_GetComponentManager(getter_AddRefs(compManager));
    1: 
 3715: #ifdef XP_WIN
    1:   // Failure here is not a show-stopper so just warn.
    1:   rv = EnsurePrivateDirServiceProvider();
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to register dir service provider.");
 3715: #endif /* XP_WIN */
    1: 
    1:   nsCOMPtr<nsIProperties> dirService(do_GetService(kDirectoryServiceContractID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> dirList;
    1: 
    1:   // Scan plugins directories;
    1:   // don't pass aPluginsChanged directly, to prevent its
    1:   // possible reset in subsequent ScanPluginsDirectory calls
    1:   PRBool pluginschanged = PR_FALSE;
    1: 
    1:   // Scan the app-defined list of plugin dirs.
    1:   rv = dirService->Get(NS_APP_PLUGINS_DIR_LIST, NS_GET_IID(nsISimpleEnumerator), getter_AddRefs(dirList));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     ScanPluginsDirectoryList(dirList, compManager, aCreatePluginList, &pluginschanged);
    1: 
    1:     if (pluginschanged)
    1:       *aPluginsChanged = PR_TRUE;
    1: 
    1:     // if we are just looking for possible changes,
    1:     // no need to proceed if changes are detected
    1:     if (!aCreatePluginList && *aPluginsChanged) {
31646:       NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   mPluginsLoaded = PR_TRUE; // at this point 'some' plugins have been loaded,
    1:                             // the rest is optional
    1: 
 3715: #ifdef XP_WIN
    1:   PRBool bScanPLIDs = PR_FALSE;
    1: 
    1:   if (mPrefService)
    1:     mPrefService->GetBoolPref("plugin.scan.plid.all", &bScanPLIDs);
    1: 
    1:     // Now lets scan any PLID directories
    1:   if (bScanPLIDs && mPrivateDirServiceProvider) {
    1:     rv = mPrivateDirServiceProvider->GetPLIDDirectories(getter_AddRefs(dirList));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       ScanPluginsDirectoryList(dirList, compManager, aCreatePluginList, &pluginschanged);
    1: 
    1:       if (pluginschanged)
    1:         *aPluginsChanged = PR_TRUE;
    1: 
    1:       // if we are just looking for possible changes,
    1:       // no need to proceed if changes are detected
    1:       if (!aCreatePluginList && *aPluginsChanged) {
31646:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1: 
    1:   // Scan the installation paths of our popular plugins if the prefs are enabled
    1: 
    1:   // This table controls the order of scanning
    1:   const char* const prefs[] = {NS_WIN_JRE_SCAN_KEY,         nsnull,
    1:                                NS_WIN_ACROBAT_SCAN_KEY,     nsnull,
    1:                                NS_WIN_QUICKTIME_SCAN_KEY,   nsnull,
    1:                                NS_WIN_WMP_SCAN_KEY,         nsnull,
    1:                                NS_WIN_4DOTX_SCAN_KEY,       "1"  /*  second column is flag for 4.x folder */ };
    1: 
    1:   PRUint32 size = sizeof(prefs) / sizeof(prefs[0]);
    1: 
    1:   for (PRUint32 i = 0; i < size; i+=2) {
    1:     nsCOMPtr<nsIFile> dirToScan;
    1:     PRBool bExists;
    1:     if (NS_SUCCEEDED(dirService->Get(prefs[i], NS_GET_IID(nsIFile), getter_AddRefs(dirToScan))) &&
    1:         dirToScan &&
    1:         NS_SUCCEEDED(dirToScan->Exists(&bExists)) &&
    1:         bExists) {
    1: 
    1:       PRBool bFilterUnwanted = PR_FALSE;
    1: 
    1:       // 4.x plugins folder stuff:
    1:       // Normally we "filter" the 4.x folder through |IsUnwantedPlugin|
    1:       // Check for a pref to see if we want to scan the entire 4.x plugins folder
    1:       if (prefs[i+1]) {
    1:         PRBool bScanEverything;
    1:         bFilterUnwanted = PR_TRUE;  // default to filter 4.x folder
    1:         if (mPrefService &&
    1:             NS_SUCCEEDED(mPrefService->GetBoolPref(prefs[i], &bScanEverything)) &&
    1:             bScanEverything)
    1:           bFilterUnwanted = PR_FALSE;
    1: 
    1:       }
    1:       ScanPluginsDirectory(dirToScan, compManager, aCreatePluginList, &pluginschanged, bFilterUnwanted);
    1: 
    1:       if (pluginschanged)
    1:         *aPluginsChanged = PR_TRUE;
    1: 
    1:       // if we are just looking for possible changes,
    1:       // no need to proceed if changes are detected
    1:       if (!aCreatePluginList && *aPluginsChanged) {
31646:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: #endif
    1: 
    1:   // if get to this point and did not detect changes in plugins
    1:   // that means no plugins got updated or added
    1:   // let's see if plugins have been removed
    1:   if (!*aPluginsChanged) {
    1:     // count plugins remained in cache, if there are some, that means some plugins were removed;
    1:     // while counting, we should ignore unwanted plugins which are also present in cache
    1:     PRUint32 cachecount = 0;
    1:     for (nsPluginTag * cachetag = mCachedPlugins; cachetag; cachetag = cachetag->mNext) {
    1:       if (!cachetag->HasFlag(NS_PLUGIN_FLAG_UNWANTED))
    1:         cachecount++;
    1:     }
    1:     // if there is something left in cache, some plugins got removed from the directory
    1:     // and therefor their info did not get removed from the cache info list during directory scan;
    1:     // flag this fact
    1:     if (cachecount > 0)
    1:       *aPluginsChanged = PR_TRUE;
    1:   }
    1: 
    1:   // if we are not creating the list, there is no need to proceed
    1:   if (!aCreatePluginList) {
31646:     NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if we are creating the list, it is already done;
    1:   // update the plugins info cache if changes are detected
    1:   if (*aPluginsChanged)
    1:     WritePluginInfo();
    1: 
    1:   // No more need for cached plugins. Clear it up.
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
    1: 
    1:   // reverse our list of plugins
 3102:   nsRefPtr<nsPluginTag> next;
 3102:   nsRefPtr<nsPluginTag> prev;
 3102:   for (nsRefPtr<nsPluginTag> cur = mPlugins; cur; cur = next) {
    1:     next = cur->mNext;
    1:     cur->mNext = prev;
    1:     prev = cur;
    1:   }
    1: 
    1:   mPlugins = prev;
    1: 
    1:   NS_TIMELINE_STOP_TIMER("LoadPlugins");
    1:   NS_TIMELINE_MARK_TIMER("LoadPlugins");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
29956: nsPluginHost::UpdatePluginInfo(nsPluginTag* aPluginTag)
 3102: {
 3102:   ReadPluginInfo();
 3102:   WritePluginInfo();
31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 3464: 
13222:   if (!aPluginTag || aPluginTag->IsEnabled())
 3464:     return NS_OK;
 3464: 
 3464:   nsCOMPtr<nsISupportsArray> instsToReload;
 3464:   NS_NewISupportsArray(getter_AddRefs(instsToReload));
37525:   StopRunningInstances(instsToReload, aPluginTag);
 3464:   
 3464:   PRUint32 c;
21231:   if (instsToReload && NS_SUCCEEDED(instsToReload->Count(&c)) && c > 0) {
 3464:     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
 3464:     if (ev)
 3464:       NS_DispatchToCurrentThread(ev);
 3464:   }
 3102: 
 3102:   return NS_OK;
 3102: }
 3102: 
 3102: nsresult
29956: nsPluginHost::WritePluginInfo()
    1: {
    1: 
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID,&rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 4030:   directoryService->Get(NS_APP_USER_PROFILE_50_DIR, NS_GET_IID(nsIFile),
    1:                         getter_AddRefs(mPluginRegFile));
    1: 
    1:   if (!mPluginRegFile)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRFileDesc* fd = nsnull;
    1: 
    1:   nsCOMPtr<nsIFile> pluginReg;
    1: 
    1:   rv = mPluginRegFile->Clone(getter_AddRefs(pluginReg));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = pluginReg->AppendNative(kPluginRegistryFilename);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(pluginReg, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = localFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 0600, &fd);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PR_fprintf(fd, "Generated File. Do not edit.\n");
    1: 
    1:   PR_fprintf(fd, "\n[HEADER]\nVersion%c%s%c%c\n",
    1:              PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:              kPluginRegistryVersion,
    1:              PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:              PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1: 
    1:   // Store all plugins in the mPlugins list - all plugins currently in use.
    1:   PR_fprintf(fd, "\n[PLUGINS]\n");
    1: 
    1:   nsPluginTag *taglist[] = {mPlugins, mCachedPlugins};
    1:   for (int i=0; i<(int)(sizeof(taglist)/sizeof(nsPluginTag *)); i++) {
    1:     for (nsPluginTag *tag = taglist[i]; tag; tag=tag->mNext) {
    1:       // from mCachedPlugins list write down only unwanted plugins
    1:       if ((taglist[i] == mCachedPlugins) && !tag->HasFlag(NS_PLUGIN_FLAG_UNWANTED))
    1:         continue;
    1:       // store each plugin info into the registry
    1:       // filename & fullpath are on separate line
    1:       // because they can contain field delimiter char
15947:       PR_fprintf(fd, "%s%c%c\n%s%c%c\n%s%c%c\n",
12841:         (!tag->mFileName.IsEmpty() ? tag->mFileName.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
12841:         (!tag->mFullPath.IsEmpty() ? tag->mFullPath.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
15947:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
15947:         (!tag->mVersion.IsEmpty() ? tag->mVersion.get() : ""),
15947:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1: 
    1:       // lastModifiedTimeStamp|canUnload|tag->mFlags
    1:       PR_fprintf(fd, "%lld%c%d%c%lu%c%c\n",
    1:         tag->mLastModifiedTime,
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         tag->mCanUnloadLibrary,
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         tag->Flags(),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1: 
    1:       //description, name & mtypecount are on separate line
    1:       PR_fprintf(fd, "%s%c%c\n%s%c%c\n%d\n",
12841:         (!tag->mDescription.IsEmpty() ? tag->mDescription.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
12841:         (!tag->mName.IsEmpty() ? tag->mName.get() : ""),
    1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 6774:         tag->mVariants + (tag->mIsNPRuntimeEnabledJavaPlugin ? 1 : 0));
    1: 
    1:       // Add in each mimetype this plugin supports
    1:       for (int i=0; i<tag->mVariants; i++) {
    1:         PR_fprintf(fd, "%d%c%s%c%s%c%s%c%c\n",
    1:           i,PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:           (tag->mMimeTypeArray && tag->mMimeTypeArray[i] ? tag->mMimeTypeArray[i] : ""),
    1:           PLUGIN_REGISTRY_FIELD_DELIMITER,
12841:           (!tag->mMimeDescriptionArray[i].IsEmpty() ? tag->mMimeDescriptionArray[i].get() : ""),
    1:           PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:           (tag->mExtensionsArray && tag->mExtensionsArray[i] ? tag->mExtensionsArray[i] : ""),
    1:           PLUGIN_REGISTRY_FIELD_DELIMITER,
    1:           PLUGIN_REGISTRY_END_OF_LINE_MARKER);
    1:       }
 6774: 
 6774:       if (tag->mIsNPRuntimeEnabledJavaPlugin) {
 6774:         PR_fprintf(fd, "%d%c%s%c%s%c%s%c%c\n",
 6774:           tag->mVariants, PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           "application/x-java-vm-npruntime",
 6774:           PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           "",
 6774:           PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           "",
 6774:           PLUGIN_REGISTRY_FIELD_DELIMITER,
 6774:           PLUGIN_REGISTRY_END_OF_LINE_MARKER);
 6774:       }
    1:     }
    1:   }
    1: 
36600:   if (fd) {
36600:     PR_Sync(fd);
    1:     PR_Close(fd);
36600:   }
    1:   return NS_OK;
    1: }
    1: 
    1: #define PLUGIN_REG_MIMETYPES_ARRAY_SIZE 12
    1: nsresult
29956: nsPluginHost::ReadPluginInfo()
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID,&rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 4030:   directoryService->Get(NS_APP_USER_PROFILE_50_DIR, NS_GET_IID(nsIFile),
    1:                         getter_AddRefs(mPluginRegFile));
    1: 
32940:   if (!mPluginRegFile) {
32940:     // There is no profile yet, this will tell us if there is going to be one
32940:     // in the future.
32940:     directoryService->Get(NS_APP_PROFILE_DIR_STARTUP, NS_GET_IID(nsIFile),
32940:                           getter_AddRefs(mPluginRegFile));
    1:     if (!mPluginRegFile)
    1:       return NS_ERROR_FAILURE;
32940:     else
32940:       return NS_ERROR_NOT_AVAILABLE;
32940:   }
    1: 
    1:   PRFileDesc* fd = nsnull;
    1: 
    1:   nsCOMPtr<nsIFile> pluginReg;
    1: 
    1:   rv = mPluginRegFile->Clone(getter_AddRefs(pluginReg));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = pluginReg->AppendNative(kPluginRegistryFilename);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(pluginReg, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PRInt64 fileSize;
    1:   rv = localFile->GetFileSize(&fileSize);
21231:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PRInt32 flen = nsInt64(fileSize);
    1:   if (flen == 0) {
    1:     NS_WARNING("Plugins Registry Empty!");
    1:     return NS_OK; // ERROR CONDITION
    1:   }
    1: 
    1:   nsPluginManifestLineReader reader;
    1:   char* registry = reader.Init(flen);
21231:   if (!registry)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0444, &fd);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // set rv to return an error on goto out
    1:   rv = NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 bread = PR_Read(fd, registry, flen);
    1:   PR_Close(fd);
    1: 
    1:   if (flen > bread)
    1:     return rv;
    1: 
21231:   if (!ReadSectionHeader(reader, "HEADER"))
    1:     return rv;;
21231: 
21231:   if (!reader.NextLine())
    1:     return rv;
    1: 
    1:   char* values[6];
    1: 
    1:   // VersionLiteral, kPluginRegistryVersion
21231:   if (2 != reader.ParseLine(values, 2))
    1:     return rv;
    1: 
    1:   // VersionLiteral
21231:   if (PL_strcmp(values[0], "Version"))
    1:     return rv;
    1: 
    1:   // kPluginRegistryVersion
21192:   PRInt32 vdiff = NS_CompareVersions(values[1], kPluginRegistryVersion);
21192:   // If this is a registry from some future version then don't attempt to read it
21231:   if (vdiff > 0)
    1:     return rv;
21192:   // If this is a registry from before the minimum then don't attempt to read it
21231:   if (NS_CompareVersions(values[1], kMinimumRegistryVersion) < 0)
21192:     return rv;
21192: 
21192:   // Registry v0.10 and upwards includes the plugin version field
21192:   PRBool regHasVersion = NS_CompareVersions(values[1], "0.10") >= 0;
    1: 
21231:   if (!ReadSectionHeader(reader, "PLUGINS"))
    1:     return rv;
    1: 
29020: #if defined(XP_MACOSX)
29020:   PRBool hasFullPathInFileNameField = PR_FALSE;
29020: #else
29020:   PRBool hasFullPathInFileNameField = (NS_CompareVersions(values[1], "0.11") < 0);
29020: #endif
29020: 
    1:   while (reader.NextLine()) {
29020:     const char *filename;
29020:     const char *fullpath;
29020:     nsCAutoString derivedFileName;
29020:     
29020:     if (hasFullPathInFileNameField) {
29020:       fullpath = reader.LinePtr();
    1:       if (!reader.NextLine())
    1:         return rv;
29020:       // try to derive a file name from the full path
29020:       if (fullpath) {
29020:         nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
29020:         file->InitWithNativePath(nsDependentCString(fullpath));
29020:         file->GetNativeLeafName(derivedFileName);
29020:         filename = derivedFileName.get();
29020:       } else {
29020:         filename = NULL;
29020:       }
29020: 
29020:       // skip the next line, useless in this version
    1:       if (!reader.NextLine())
    1:         return rv;
29020:     } else {
29020:       filename = reader.LinePtr();
29020:       if (!reader.NextLine())
29020:         return rv;
29020: 
29020:       fullpath = reader.LinePtr();
29020:       if (!reader.NextLine())
29020:         return rv;
29020:     }
    1: 
26026:     const char *version;
21192:     if (regHasVersion) {
21192:       version = reader.LinePtr();
15947:       if (!reader.NextLine())
15947:         return rv;
21231:     } else {
21192:       version = "0";
21192:     }
15947: 
    1:     // lastModifiedTimeStamp|canUnload|tag.mFlag
21231:     if (reader.ParseLine(values, 3) != 3)
    1:       return rv;
    1: 
21192:     // If this is an old plugin registry mark this plugin tag to be refreshed
29020:     PRInt64 lastmod = (vdiff == 0) ? nsCRT::atoll(values[0]) : -1;
    1:     PRBool canunload = atoi(values[1]);
    1:     PRUint32 tagflag = atoi(values[2]);
    1:     if (!reader.NextLine())
    1:       return rv;
    1: 
26026:     const char *description = reader.LinePtr();
    1:     if (!reader.NextLine())
    1:       return rv;
    1: 
26026:     const char *name = reader.LinePtr();
    1:     if (!reader.NextLine())
    1:       return rv;
    1: 
    1:     int mimetypecount = atoi(reader.LinePtr());
    1: 
    1:     char *stackalloced[PLUGIN_REG_MIMETYPES_ARRAY_SIZE * 3];
    1:     char **mimetypes;
    1:     char **mimedescriptions;
    1:     char **extensions;
    1:     char **heapalloced = 0;
    1:     if (mimetypecount > PLUGIN_REG_MIMETYPES_ARRAY_SIZE - 1) {
    1:       heapalloced = new char *[mimetypecount * 3];
    1:       mimetypes = heapalloced;
    1:     } else {
    1:       mimetypes = stackalloced;
    1:     }
    1:     mimedescriptions = mimetypes + mimetypecount;
    1:     extensions = mimedescriptions + mimetypecount;
    1: 
    1:     int mtr = 0; //mimetype read
    1:     for (; mtr < mimetypecount; mtr++) {
    1:       if (!reader.NextLine())
    1:         break;
    1: 
    1:       //line number|mimetype|description|extension
    1:       if (4 != reader.ParseLine(values, 4))
    1:         break;
    1:       int line = atoi(values[0]);
    1:       if (line != mtr)
    1:         break;
    1:       mimetypes[mtr] = values[1];
    1:       mimedescriptions[mtr] = values[2];
    1:       extensions[mtr] = values[3];
    1:     }
    1: 
    1:     if (mtr != mimetypecount) {
    1:       if (heapalloced) {
    1:         delete [] heapalloced;
    1:       }
    1:       return rv;
    1:     }
    1: 
 3102:     nsRefPtr<nsPluginTag> tag = new nsPluginTag(name,
    1:       description,
    1:       filename,
29020:       fullpath,
15947:       version,
    1:       (const char* const*)mimetypes,
    1:       (const char* const*)mimedescriptions,
    1:       (const char* const*)extensions,
12841:       mimetypecount, lastmod, canunload, PR_TRUE);
21231:     if (heapalloced)
    1:       delete [] heapalloced;
21231: 
21231:     if (!tag)
    1:       continue;
    1: 
    1:     // Mark plugin as loaded from cache
    1:     tag->Mark(tagflag | NS_PLUGIN_FLAG_FROMCACHE);
    1:     PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
12988:       ("LoadCachedPluginsInfo : Loading Cached plugininfo for %s\n", tag->mFileName.get()));
    1:     tag->mNext = mCachedPlugins;
    1:     mCachedPlugins = tag;
    1: 
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 3102: void
29956: nsPluginHost::RemoveCachedPluginsInfo(const char *filePath, nsPluginTag **result)
 3102: {
 3102:   nsRefPtr<nsPluginTag> prev;
 3102:   nsRefPtr<nsPluginTag> tag = mCachedPlugins;
 3102:   while (tag)
    1:   {
29020:     if (tag->mFullPath.Equals(filePath)) {
    1:       // Found it. Remove it from our list
 3102:       if (prev)
 3102:         prev->mNext = tag->mNext;
 3102:       else
 3102:         mCachedPlugins = tag->mNext;
 3102:       tag->mNext = nsnull;
 3102:       *result = tag;
 3102:       NS_ADDREF(*result);
 3102:       break;
 3102:     }
 3102:     prev = tag;
 3102:     tag = tag->mNext;
 3102:   }
    1: }
    1: 
 3715: #ifdef XP_WIN
    1: nsresult
29956: nsPluginHost::EnsurePrivateDirServiceProvider()
    1: {
21231:   if (!mPrivateDirServiceProvider) {
    1:     nsresult rv;
    1:     mPrivateDirServiceProvider = new nsPluginDirServiceProvider();
    1:     if (!mPrivateDirServiceProvider)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     nsCOMPtr<nsIDirectoryService> dirService(do_GetService(kDirectoryServiceContractID, &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = dirService->RegisterProvider(mPrivateDirServiceProvider);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1:   return NS_OK;
    1: }
 3715: #endif /* XP_WIN */
    1: 
29956: nsresult nsPluginHost::NewPluginURLStream(const nsString& aURL,
    1:                                           nsIPluginInstance *aInstance,
    1:                                           nsIPluginStreamListener* aListener,
36766:                                           nsIInputStream *aPostStream,
    1:                                           const char *aHeadersData,
    1:                                           PRUint32 aHeadersDataLen)
    1: {
    1:   nsCOMPtr<nsIURI> url;
    1:   nsAutoString absUrl;
    1:   nsresult rv;
    1: 
    1:   if (aURL.Length() <= 0)
    1:     return NS_OK;
    1: 
    1:   // get the full URL of the document that the plugin is embedded
    1:   //   in to create an absolute url in case aURL is relative
    1:   nsCOMPtr<nsIDocument> doc;
  353:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   aInstance->GetOwner(getter_AddRefs(owner));
21231:   if (owner) {
    1:     rv = owner->GetDocument(getter_AddRefs(doc));
21231:     if (NS_SUCCEEDED(rv) && doc) {
    1:       // Create an absolute URL
    1:       rv = NS_MakeAbsoluteURI(absUrl, aURL, doc->GetBaseURI());
    1:     }
    1:   }
    1: 
    1:   if (absUrl.IsEmpty())
    1:     absUrl.Assign(aURL);
    1: 
    1:   rv = NS_NewURI(getter_AddRefs(url), absUrl);
34262:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
29952:   nsCOMPtr<nsIPluginTagInfo> pti = do_QueryInterface(owner);
  353:   nsCOMPtr<nsIDOMElement> element;
29952:   if (pti)
29952:     pti->GetDOMElement(getter_AddRefs(element));
  353: 
  353:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT_SUBREQUEST,
  353:                                  url,
 4367:                                  (doc ? doc->NodePrincipal() : nsnull),
  353:                                  element,
  353:                                  EmptyCString(), //mime guess
  353:                                  nsnull,         //extra
  353:                                  &shouldLoad);
34262:   if (NS_FAILED(rv))
34262:     return rv;
  353:   if (NS_CP_REJECTED(shouldLoad)) {
  353:     // Disallowed by content policy
  353:     return NS_ERROR_CONTENT_BLOCKED;
  353:   }
  353: 
36766:   nsRefPtr<nsPluginStreamListenerPeer> listenerPeer = new nsPluginStreamListenerPeer();
    1:   if (listenerPeer == NULL)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = listenerPeer->Initialize(url, aInstance, aListener);
36766:   if (NS_FAILED(rv))
34262:     return rv;
34262: 
    1:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
21231:   if (doc) {
    1:     // Get the script global object owner and use that as the
    1:     // notification callback.
    1:     nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();
21231:     if (global) {
 4431:       nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(global);
 4431:       callbacks = do_QueryInterface(webNav);
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIChannel> channel;
    1: 
    1:   rv = NS_NewChannel(getter_AddRefs(channel), url, nsnull,
    1:     nsnull, /* do not add this internal plugin's channel
    1:             on the load group otherwise this channel could be canceled
28078:             form |nsDocShell::OnLinkClickSync| bug 166613 */
    1:     callbacks);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
21231:   if (doc) {
    1:     // Set the owner of channel to the document principal...
    1:     channel->SetOwner(doc->NodePrincipal());
    1: 
    1:     // And if it's a script allow it to execute against the
    1:     // document's script context.
    1:     nsCOMPtr<nsIScriptChannel> scriptChannel(do_QueryInterface(channel));
    1:     if (scriptChannel) {
    1:       scriptChannel->SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
 2364:       // Plug-ins seem to depend on javascript: URIs running synchronously
 2364:       scriptChannel->SetExecuteAsync(PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   // deal with headers and post data
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:   if (httpChannel) {
36766:     if (aPostStream) {
    1:       // XXX it's a bit of a hack to rewind the postdata stream
    1:       // here but it has to be done in case the post data is
    1:       // being reused multiple times.
    1:       nsCOMPtr<nsISeekableStream>
36766:       postDataSeekable(do_QueryInterface(aPostStream));
    1:       if (postDataSeekable)
    1:         postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1: 
    1:       nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:       NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
    1: 
36766:       uploadChannel->SetUploadStream(aPostStream, EmptyCString(), -1);
    1:     }
    1: 
    1:     if (aHeadersData)
    1:       rv = AddHeadersToChannel(aHeadersData, aHeadersDataLen, httpChannel);
    1:   }
    1:   rv = channel->AsyncOpen(listenerPeer, nsnull);
    1:   return rv;
    1: }
    1: 
21231: // Called by GetURL and PostURL
    1: nsresult
29956: nsPluginHost::DoURLLoadSecurityCheck(nsIPluginInstance *aInstance,
    1:                                          const char* aURL)
    1: {
    1:   if (!aURL || *aURL == '\0')
    1:     return NS_OK;
    1: 
    1:   // get the URL of the document that loaded the plugin
    1:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   aInstance->GetOwner(getter_AddRefs(owner));
    1:   if (!owner)
    1:     return NS_ERROR_FAILURE;
    1: 
29834:   nsCOMPtr<nsIDocument> doc;
29834:   owner->GetDocument(getter_AddRefs(doc));
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Create an absolute URL for the target in case the target is relative
    1:   nsCOMPtr<nsIURI> targetURL;
29834:   NS_NewURI(getter_AddRefs(targetURL), aURL, doc->GetBaseURI());
    1:   if (!targetURL)
    1:     return NS_ERROR_FAILURE;
    1: 
29834:   nsresult rv;
    1:   nsCOMPtr<nsIScriptSecurityManager> secMan(
    1:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), targetURL,
    1:                                            nsIScriptSecurityManager::STANDARD);
    1: 
    1: }
    1: 
29574: nsresult
29956: nsPluginHost::AddHeadersToChannel(const char *aHeadersData,
    1:                                   PRUint32 aHeadersDataLen,
    1:                                   nsIChannel *aGenericChannel)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCOMPtr<nsIHttpChannel> aChannel = do_QueryInterface(aGenericChannel);
    1:   if (!aChannel) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   // used during the manipulation of the String from the aHeadersData
    1:   nsCAutoString headersString;
    1:   nsCAutoString oneHeader;
    1:   nsCAutoString headerName;
    1:   nsCAutoString headerValue;
    1:   PRInt32 crlf = 0;
    1:   PRInt32 colon = 0;
    1: 
    1:   // Turn the char * buffer into an nsString.
    1:   headersString = aHeadersData;
    1: 
    1:   // Iterate over the nsString: for each "\r\n" delimited chunk,
    1:   // add the value as a header to the nsIHTTPChannel
    1:   while (PR_TRUE) {
    1:     crlf = headersString.Find("\r\n", PR_TRUE);
    1:     if (-1 == crlf) {
    1:       rv = NS_OK;
    1:       return rv;
    1:     }
    1:     headersString.Mid(oneHeader, 0, crlf);
    1:     headersString.Cut(0, crlf + 2);
    1:     oneHeader.StripWhitespace();
    1:     colon = oneHeader.Find(":");
    1:     if (-1 == colon) {
    1:       rv = NS_ERROR_NULL_POINTER;
    1:       return rv;
    1:     }
    1:     oneHeader.Left(headerName, colon);
    1:     colon++;
    1:     oneHeader.Mid(headerValue, colon, oneHeader.Length() - colon);
    1: 
    1:     // FINALLY: we can set the header!
    1: 
    1:     rv = aChannel->SetRequestHeader(headerName, headerValue, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       rv = NS_ERROR_NULL_POINTER;
    1:       return rv;
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::StopPluginInstance(nsIPluginInstance* aInstance)
    1: {
12417:   if (PluginDestructionGuard::DelayDestroy(aInstance)) {
12417:     return NS_OK;
12417:   }
12417: 
    1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
29956:   ("nsPluginHost::StopPluginInstance called instance=%p\n",aInstance));
    1: 
37525:   aInstance->Stop();
37525: 
37841:   nsPluginInstanceTag * instanceTag = FindInstanceTag(aInstance);
37841:   if (instanceTag) {
    1:     // if the plugin does not want to be 'cached' just remove it
    1:     PRBool doCache = PR_TRUE;
32799:     aInstance->ShouldCache(&doCache);
37525:     if (doCache) {
    1:       // try to get the max cached plugins from a pref or use default
37525:       PRUint32 cachedPluginLimit;
    1:       nsresult rv = NS_ERROR_FAILURE;
21231:       if (mPrefService)
37525:         rv = mPrefService->GetIntPref(NS_PREF_MAX_NUM_CACHED_PLUGINS, (int*)&cachedPluginLimit);
21231:       if (NS_FAILED(rv))
37525:         cachedPluginLimit = DEFAULT_NUMBER_OF_STOPPED_PLUGINS;
37525:       
37841:       if (StoppedInstanceTagCount() >= cachedPluginLimit) {
37841:         nsPluginInstanceTag * oldestInstanceTag = FindOldestStoppedInstanceTag();
37841:         if (oldestInstanceTag) {
37841:           nsPluginTag* pluginTag = oldestInstanceTag->mPluginTag;
37841:           mInstanceTags.RemoveElement(oldestInstanceTag);
37525:           OnPluginInstanceDestroyed(pluginTag);
37525:         }
37525:       }
37525:     } else {
37841:       nsPluginTag* pluginTag = instanceTag->mPluginTag;
37841:       mInstanceTags.RemoveElement(instanceTag);
37525:       OnPluginInstanceDestroyed(pluginTag);
37525:     }
37841:   }
37525: 
    1:   return NS_OK;
    1: }
    1: 
37841: nsPluginInstanceTag*
37841: nsPluginHost::FindOldestStoppedInstanceTag()
37525: {
37841:   nsPluginInstanceTag *oldestInstanceTag = nsnull;
37525:   TimeStamp oldestTime = TimeStamp::Now();
37841:   for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:     nsPluginInstanceTag *instanceTag = mInstanceTags[i];
37841:     if (instanceTag->mInstance->IsRunning())
37525:       continue;
37525: 
37841:     TimeStamp time = instanceTag->mInstance->LastStopTime();
37525:     if (time < oldestTime) {
37525:       oldestTime = time;
37841:       oldestInstanceTag = instanceTag;
37841:     }
37841:   }
37841: 
37841:   return oldestInstanceTag;
37525: }
37525: 
37525: PRUint32
37841: nsPluginHost::StoppedInstanceTagCount()
37525: {
37525:   PRUint32 stoppedCount = 0;
37841:   for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:     nsPluginInstanceTag *instanceTag = mInstanceTags[i];
37841:     if (!instanceTag->mInstance->IsRunning())
37525:       stoppedCount++;
37525:   }
37525:   return stoppedCount;
37525: }
37525: 
29956: nsresult nsPluginHost::NewEmbeddedPluginStreamListener(nsIURI* aURL,
    1:                                                        nsIPluginInstanceOwner *aOwner,
    1:                                                        nsIPluginInstance* aInstance,
    1:                                                        nsIStreamListener** aListener)
    1: {
    1:   if (!aURL)
    1:     return NS_OK;
    1: 
    1:   nsRefPtr<nsPluginStreamListenerPeer> listener =
    1:       new nsPluginStreamListenerPeer();
    1:   if (listener == nsnull)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv;
    1: 
    1:   // if we have an instance, everything has been set up
    1:   // if we only have an owner, then we need to pass it in
    1:   // so the listener can set up the instance later after
    1:   // we've determined the mimetype of the stream
    1:   if (aInstance != nsnull)
    1:     rv = listener->InitializeEmbedded(aURL, aInstance);
    1:   else if (aOwner != nsnull)
37525:     rv = listener->InitializeEmbedded(aURL, nsnull, aOwner);
    1:   else
    1:     rv = NS_ERROR_ILLEGAL_VALUE;
    1:   if (NS_SUCCEEDED(rv))
    1:     NS_ADDREF(*aListener = listener);
    1: 
    1:   return rv;
    1: }
    1: 
21231: // Called by InstantiateEmbeddedPlugin()
29956: nsresult nsPluginHost::NewEmbeddedPluginStream(nsIURI* aURL,
    1:                                                nsIPluginInstanceOwner *aOwner,
    1:                                                nsIPluginInstance* aInstance)
    1: {
    1:   nsCOMPtr<nsIStreamListener> listener;
    1:   nsresult rv = NewEmbeddedPluginStreamListener(aURL, aOwner, aInstance,
    1:                                                 getter_AddRefs(listener));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDocument> doc;
    1:     nsCOMPtr<nsILoadGroup> loadGroup;
    1:     if (aOwner) {
    1:       rv = aOwner->GetDocument(getter_AddRefs(doc));
    1:       if (NS_SUCCEEDED(rv) && doc) {
    1:         loadGroup = doc->GetDocumentLoadGroup();
    1:       }
    1:     }
    1:     nsCOMPtr<nsIChannel> channel;
    1:     rv = NS_NewChannel(getter_AddRefs(channel), aURL, nsnull, loadGroup, nsnull);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       // if this is http channel, set referrer, some servers are configured
    1:       // to reject requests without referrer set, see bug 157796
    1:       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:       if (httpChannel && doc)
    1:         httpChannel->SetReferrer(doc->GetDocumentURI());
    1: 
    1:       rv = channel->AsyncOpen(listener, nsnull);
    1:       if (NS_SUCCEEDED(rv))
    1:         return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
21231: // Called by InstantiateFullPagePlugin()
29956: nsresult nsPluginHost::NewFullPagePluginStream(nsIStreamListener *&aStreamListener,
    1:                                                nsIPluginInstance *aInstance)
    1: {
    1:   nsPluginStreamListenerPeer  *listener = new nsPluginStreamListenerPeer();
21231:   if (!listener)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv;
    1: 
    1:   rv = listener->InitializeFullPage(aInstance);
    1: 
    1:   aStreamListener = listener;
    1:   NS_ADDREF(listener);
    1: 
    1:   // add peer to list of stream peers for this instance
37841:   nsPluginInstanceTag * p = FindInstanceTag(aInstance);
37841:   if (p) {
37841:     if (!p->mStreams && (NS_FAILED(rv = NS_NewISupportsArray(getter_AddRefs(p->mStreams)))))
37841:       return rv;
37841:     p->mStreams->AppendElement(aStreamListener);
37841:   }
    1: 
    1:   return rv;
    1: }
    1: 
29956: NS_IMETHODIMP nsPluginHost::Observe(nsISupports *aSubject,
    1:                                     const char *aTopic,
    1:                                     const PRUnichar *someData)
    1: {
21231:   if (!nsCRT::strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic)) {
 3363:     OnShutdown();
    1:     Destroy();
    1:     UnloadUnusedLibraries();
    1:     sInst->Release();
    1:   }
24475:   if (!nsCRT::strcmp(NS_PRIVATE_BROWSING_SWITCH_TOPIC, aTopic)) {
30005:     // inform all active plugins of changed private mode state
37841:     for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:       nsNPAPIPluginInstance* pi = static_cast<nsNPAPIPluginInstance*>(mInstanceTags[i]->mInstance);
37841:       pi->PrivateModeStateChanged();
24475:     }
24475:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::HandleBadPlugin(PRLibrary* aLibrary, nsIPluginInstance *aInstance)
    1: {
    1:   // the |aLibrary| parameter is not needed anymore, after we added |aInstance| which
    1:   // can also be used to look up the plugin name, but we cannot get rid of it because
    1:   // the |nsIPluginHost| interface is deprecated which in fact means 'frozen'
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   NS_ASSERTION(PR_FALSE, "Plugin performed illegal operation");
    1: 
    1:   if (mDontShowBadPluginMessage)
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   if (aInstance)
29834:     aInstance->GetOwner(getter_AddRefs(owner));
    1: 
    1:   nsCOMPtr<nsIPrompt> prompt;
    1:   GetPrompt(owner, getter_AddRefs(prompt));
    1:   if (prompt) {
 5691:     nsCOMPtr<nsIStringBundleService> strings(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIStringBundle> bundle;
    1:     rv = strings->CreateBundle(BRAND_PROPERTIES_URL, getter_AddRefs(bundle));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsXPIDLString brandName;
    1:     if (NS_FAILED(rv = bundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
    1:                                  getter_Copies(brandName))))
    1:       return rv;
    1: 
    1:     rv = strings->CreateBundle(PLUGIN_PROPERTIES_URL, getter_AddRefs(bundle));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsXPIDLString title, message, checkboxMessage;
    1:     if (NS_FAILED(rv = bundle->GetStringFromName(NS_LITERAL_STRING("BadPluginTitle").get(),
    1:                                  getter_Copies(title))))
    1:       return rv;
    1: 
    1:     const PRUnichar *formatStrings[] = { brandName.get() };
    1:     if (NS_FAILED(rv = bundle->FormatStringFromName(NS_LITERAL_STRING("BadPluginMessage").get(),
    1:                                  formatStrings, 1, getter_Copies(message))))
    1:       return rv;
    1: 
    1:     if (NS_FAILED(rv = bundle->GetStringFromName(NS_LITERAL_STRING("BadPluginCheckboxMessage").get(),
    1:                                  getter_Copies(checkboxMessage))))
    1:       return rv;
    1: 
    1:     // add plugin name to the message
12841:     nsCString pluginname;
37841:     nsPluginInstanceTag * p = FindInstanceTag(aInstance);
37841:     if (p) {
37841:       nsPluginTag * tag = p->mPluginTag;
37841:       if (tag) {
12841:         if (!tag->mName.IsEmpty())
    1:           pluginname = tag->mName;
    1:         else
    1:           pluginname = tag->mFileName;
37841:       }
37841:     }
    1: 
12841:     NS_ConvertUTF8toUTF16 msg(pluginname);
    1:     msg.AppendLiteral("\n\n");
    1:     msg.Append(message);
    1: 
    1:     PRInt32 buttonPressed;
    1:     PRBool checkboxState = PR_FALSE;
    1:     rv = prompt->ConfirmEx(title, msg.get(),
    1:                          nsIPrompt::BUTTON_TITLE_OK * nsIPrompt::BUTTON_POS_0,
    1:                          nsnull, nsnull, nsnull,
    1:                          checkboxMessage, &checkboxState, &buttonPressed);
    1: 
    1: 
    1:     if (NS_SUCCEEDED(rv) && checkboxState)
    1:       mDontShowBadPluginMessage = PR_TRUE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::ParsePostBufferToFixHeaders(const char *inPostData, PRUint32 inPostDataLen,
    1:                                           char **outPostData, PRUint32 *outPostDataLen)
    1: {
    1:   if (!inPostData || !outPostData || !outPostDataLen)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *outPostData = 0;
    1:   *outPostDataLen = 0;
    1: 
    1:   const char CR = '\r';
    1:   const char LF = '\n';
    1:   const char CRLFCRLF[] = {CR,LF,CR,LF,'\0'}; // C string"\r\n\r\n"
    1:   const char ContentLenHeader[] = "Content-length";
    1: 
26912:   nsAutoTArray<const char*, 8> singleLF;
    1:   const char *pSCntlh = 0;// pointer to start of ContentLenHeader in inPostData
    1:   const char *pSod = 0;   // pointer to start of data in inPostData
    1:   const char *pEoh = 0;   // pointer to end of headers in inPostData
    1:   const char *pEod = inPostData + inPostDataLen; // pointer to end of inPostData
    1:   if (*inPostData == LF) {
    1:     // If no custom headers are required, simply add a blank
    1:     // line ('\n') to the beginning of the file or buffer.
    1:     // so *inPostData == '\n' is valid
    1:     pSod = inPostData + 1;
    1:   } else {
    1:     const char *s = inPostData; //tmp pointer to sourse inPostData
    1:     while (s < pEod) {
    1:       if (!pSCntlh &&
    1:           (*s == 'C' || *s == 'c') &&
    1:           (s + sizeof(ContentLenHeader) - 1 < pEod) &&
    1:           (!PL_strncasecmp(s, ContentLenHeader, sizeof(ContentLenHeader) - 1)))
    1:       {
    1:         // lets assume this is ContentLenHeader for now
    1:         const char *p = pSCntlh = s;
    1:         p += sizeof(ContentLenHeader) - 1;
    1:         // search for first CR or LF == end of ContentLenHeader
    1:         for (; p < pEod; p++) {
    1:           if (*p == CR || *p == LF) {
    1:             // got delimiter,
    1:             // one more check; if previous char is a digit
    1:             // most likely pSCntlh points to the start of ContentLenHeader
    1:             if (*(p-1) >= '0' && *(p-1) <= '9') {
    1:               s = p;
    1:             }
    1:             break; //for loop
    1:           }
    1:         }
    1:         if (pSCntlh == s) { // curret ptr is the same
    1:           pSCntlh = 0; // that was not ContentLenHeader
    1:           break; // there is nothing to parse, break *WHILE LOOP* here
    1:         }
    1:       }
    1: 
    1:       if (*s == CR) {
    1:         if (pSCntlh && // only if ContentLenHeader is found we are looking for end of headers
    1:             ((s + sizeof(CRLFCRLF)-1) <= pEod) &&
    1:             !memcmp(s, CRLFCRLF, sizeof(CRLFCRLF)-1))
    1:         {
    1:           s += sizeof(CRLFCRLF)-1;
    1:           pEoh = pSod = s; // data stars here
    1:           break;
    1:         }
    1:       } else if (*s == LF) {
    1:         if (*(s-1) != CR) {
26912:           singleLF.AppendElement(s);
    1:         }
    1:         if (pSCntlh && (s+1 < pEod) && (*(s+1) == LF)) {
    1:           s++;
26912:           singleLF.AppendElement(s);
    1:           s++;
    1:           pEoh = pSod = s; // data stars here
    1:           break;
    1:         }
    1:       }
    1:       s++;
    1:     }
    1:   }
    1: 
    1:   // deal with output buffer
    1:   if (!pSod) { // lets assume whole buffer is a data
    1:     pSod = inPostData;
    1:   }
    1: 
    1:   PRUint32 newBufferLen = 0;
    1:   PRUint32 dataLen = pEod - pSod;
    1:   PRUint32 headersLen = pEoh ? pSod - inPostData : 0;
    1: 
    1:   char *p; // tmp ptr into new output buf
    1:   if (headersLen) { // we got a headers
    1:     // this function does not make any assumption on correctness
    1:     // of ContentLenHeader value in this case.
    1: 
    1:     newBufferLen = dataLen + headersLen;
    1:     // in case there were single LFs in headers
    1:     // reserve an extra space for CR will be added before each single LF
26912:     int cntSingleLF = singleLF.Length();
    1:     newBufferLen += cntSingleLF;
    1: 
    1:     if (!(*outPostData = p = (char*)nsMemory::Alloc(newBufferLen)))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // deal with single LF
    1:     const char *s = inPostData;
    1:     if (cntSingleLF) {
    1:       for (int i=0; i<cntSingleLF; i++) {
26912:         const char *plf = singleLF.ElementAt(i); // ptr to single LF in headers
    1:         int n = plf - s; // bytes to copy
    1:         if (n) { // for '\n\n' there is nothing to memcpy
    1:           memcpy(p, s, n);
    1:           p += n;
    1:         }
    1:         *p++ = CR;
    1:         s = plf;
    1:         *p++ = *s++;
    1:       }
    1:     }
    1:     // are we done with headers?
    1:     headersLen = pEoh - s;
    1:     if (headersLen) { // not yet
    1:       memcpy(p, s, headersLen); // copy the rest
    1:       p += headersLen;
    1:     }
    1:   } else  if (dataLen) { // no ContentLenHeader is found but there is a data
    1:     // make new output buffer big enough
    1:     // to keep ContentLenHeader+value followed by data
    1:     PRUint32 l = sizeof(ContentLenHeader) + sizeof(CRLFCRLF) + 32;
    1:     newBufferLen = dataLen + l;
    1:     if (!(*outPostData = p = (char*)nsMemory::Alloc(newBufferLen)))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     headersLen = PR_snprintf(p, l,"%s: %ld%s", ContentLenHeader, dataLen, CRLFCRLF);
    1:     if (headersLen == l) { // if PR_snprintf has ate all extra space consider this as an error
    1:       nsMemory::Free(p);
    1:       *outPostData = 0;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     p += headersLen;
    1:     newBufferLen = headersLen + dataLen;
    1:   }
    1:   // at this point we've done with headers.
    1:   // there is a possibility that input buffer has only headers info in it
    1:   // which already parsed and copied into output buffer.
    1:   // copy the data
    1:   if (dataLen) {
    1:     memcpy(p, pSod, dataLen);
    1:   }
    1: 
    1:   *outPostDataLen = newBufferLen;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
36766: nsPluginHost::CreateTempFileToPost(const char *aPostDataURL, nsIFile **aTmpFile)
    1: {
    1:   nsresult rv;
    1:   PRInt64 fileSize;
    1:   nsCAutoString filename;
    1: 
    1:   // stat file == get size & convert file:///c:/ to c: if needed
    1:   nsCOMPtr<nsIFile> inFile;
36766:   rv = NS_GetFileFromURLSpec(nsDependentCString(aPostDataURL),
    1:                              getter_AddRefs(inFile));
    1:   if (NS_FAILED(rv)) {
    1:     nsCOMPtr<nsILocalFile> localFile;
36766:     rv = NS_NewNativeLocalFile(nsDependentCString(aPostDataURL), PR_FALSE,
    1:                                getter_AddRefs(localFile));
    1:     if (NS_FAILED(rv)) return rv;
    1:     inFile = localFile;
    1:   }
    1:   rv = inFile->GetFileSize(&fileSize);
    1:   if (NS_FAILED(rv)) return rv;
    1:   rv = inFile->GetNativePath(filename);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   if (!LL_IS_ZERO(fileSize)) {
    1:     nsCOMPtr<nsIInputStream> inStream;
    1:     rv = NS_NewLocalFileInputStream(getter_AddRefs(inStream), inFile);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Create a temporary file to write the http Content-length:
    1:     // %ld\r\n\" header and "\r\n" == end of headers for post data to
    1: 
    1:     nsCOMPtr<nsIFile> tempFile;
    1:     rv = GetPluginTempDir(getter_AddRefs(tempFile));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCAutoString inFileName;
    1:     inFile->GetNativeLeafName(inFileName);
    1:     // XXX hack around bug 70083
    1:     inFileName.Insert(NS_LITERAL_CSTRING("post-"), 0);
    1:     rv = tempFile->AppendNative(inFileName);
    1: 
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     // make it unique, and mode == 0600, not world-readable
    1:     rv = tempFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIOutputStream> outStream;
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = NS_NewLocalFileOutputStream(getter_AddRefs(outStream),
    1:         tempFile,
    1:         (PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE),
    1:         0600); // 600 so others can't read our form data
    1:     }
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Post data file couldn't be created!");
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     char buf[1024];
    1:     PRUint32 br, bw;
    1:     PRBool firstRead = PR_TRUE;
    1:     while (1) {
    1:       // Read() mallocs if buffer is null
    1:       rv = inStream->Read(buf, 1024, &br);
    1:       if (NS_FAILED(rv) || (PRInt32)br <= 0)
    1:         break;
    1:       if (firstRead) {
    1:         //"For protocols in which the headers must be distinguished from the body,
    1:         // such as HTTP, the buffer or file should contain the headers, followed by
    1:         // a blank line, then the body. If no custom headers are required, simply
    1:         // add a blank line ('\n') to the beginning of the file or buffer.
    1: 
    1:         char *parsedBuf;
    1:         // assuming first 1K (or what we got) has all headers in,
29956:         // lets parse it through nsPluginHost::ParsePostBufferToFixHeaders()
    1:         ParsePostBufferToFixHeaders((const char *)buf, br, &parsedBuf, &bw);
    1:         rv = outStream->Write(parsedBuf, bw, &br);
    1:         nsMemory::Free(parsedBuf);
    1:         if (NS_FAILED(rv) || (bw != br))
    1:           break;
    1: 
    1:         firstRead = PR_FALSE;
    1:         continue;
    1:       }
    1:       bw = br;
    1:       rv = outStream->Write(buf, bw, &br);
    1:       if (NS_FAILED(rv) || (bw != br))
    1:         break;
    1:     }
    1: 
    1:     inStream->Close();
    1:     outStream->Close();
36766:     if (NS_SUCCEEDED(rv))
36766:       *aTmpFile = tempFile.forget().get();
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
    1: {
    1:   return PLUG_NewPluginNativeWindow(aPluginNativeWindow);
    1: }
    1: 
    1: NS_IMETHODIMP
29956: nsPluginHost::DeletePluginNativeWindow(nsPluginNativeWindow * aPluginNativeWindow)
    1: {
    1:   return PLUG_DeletePluginNativeWindow(aPluginNativeWindow);
    1: }
    1: 
 6774: NS_IMETHODIMP
29956: nsPluginHost::InstantiateDummyJavaPlugin(nsIPluginInstanceOwner *aOwner)
 6774: {
 6774:   // Pass PR_FALSE as the second arg, we want the answer to be the
 6774:   // same here whether the Java plugin is enabled or not.
 6774:   nsPluginTag *plugin = FindPluginForType("application/x-java-vm", PR_FALSE);
 6774: 
 6774:   if (!plugin || !plugin->mIsNPRuntimeEnabledJavaPlugin) {
 6774:     // No NPRuntime enabled Java plugin found, no point in
 6774:     // instantiating a dummy plugin then.
 6774: 
 6774:     return NS_OK;
 6774:   }
 6774: 
 6774:   nsresult rv = SetUpPluginInstance("application/x-java-vm", nsnull, aOwner);
 6774:   NS_ENSURE_SUCCESS(rv, rv);
 6774: 
 6774:   nsCOMPtr<nsIPluginInstance> instance;
 6774:   aOwner->GetInstance(*getter_AddRefs(instance));
29953:   if (!instance)
 6774:     return NS_OK;
29953: 
29953:   instance->DefineJavaProperties();
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
14390: NS_IMETHODIMP
29956: nsPluginHost::GetPluginName(nsIPluginInstance *aPluginInstance,
15698:                             const char** aPluginName)
15698: {
37841:   nsPluginInstanceTag *instanceTag = FindInstanceTag(aPluginInstance);
37841:   if (!instanceTag || !instanceTag->mPluginTag)
37525:     return NS_ERROR_FAILURE;
37525: 
37841:   *aPluginName = instanceTag->mPluginTag->mName.get();
37525: 
14390:   return NS_OK;
14390: }
14390: 
33384: NS_IMETHODIMP
33384: nsPluginHost::GetPluginTagForInstance(nsIPluginInstance *aPluginInstance,
33384:                                       nsIPluginTag **aPluginTag)
33384: {
33384:   NS_ENSURE_ARG_POINTER(aPluginInstance);
33384:   NS_ENSURE_ARG_POINTER(aPluginTag);
33384: 
37841:   nsPluginInstanceTag *instanceTag = FindInstanceTag(aPluginInstance);
37841: 
37841:   NS_ENSURE_TRUE(instanceTag && instanceTag->mPluginTag, NS_ERROR_FAILURE);
37841:   
37841:   *aPluginTag = instanceTag->mPluginTag;
33384:   NS_ADDREF(*aPluginTag);
33384:   return NS_OK;
33384: }
33384: 
29956: nsresult nsPluginHost::AddUnusedLibrary(PRLibrary * aLibrary)
    1: {
26912:   if (!mUnusedLibraries.Contains(aLibrary)) // don't add duplicates
    1:     mUnusedLibraries.AppendElement(aLibrary);
    1: 
    1:   return NS_OK;
    1: }
    1: 
36227: #ifdef MAC_CARBON_PLUGINS
36227: // Flash requires a minimum of 8 events per second to avoid audio skipping.
36227: // Since WebKit uses a hidden plugin event rate of 4 events per second Flash
36227: // uses a Carbon timer for WebKit which fires at 8 events per second.
36227: #define HIDDEN_PLUGIN_DELAY 125
36227: #define VISIBLE_PLUGIN_DELAY 20
36227: #endif
36227: 
36227: void nsPluginHost::AddIdleTimeTarget(nsIPluginInstanceOwner* objectFrame, PRBool isVisible)
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
36227:   nsTObserverArray<nsIPluginInstanceOwner*> *targetArray;
36227:   if (isVisible) {
36227:     targetArray = &mVisibleTimerTargets;
36227:   } else {
36227:     targetArray = &mHiddenTimerTargets;
36227:   }
36227: 
36227:   if (targetArray->Contains(objectFrame)) {
36227:     return;
36227:   }
36227: 
36227:   targetArray->AppendElement(objectFrame);
36227:   if (targetArray->Length() == 1) {
36227:     if (isVisible) {
36227:       mVisiblePluginTimer->InitWithCallback(this, VISIBLE_PLUGIN_DELAY, nsITimer::TYPE_REPEATING_SLACK);
36227:     } else {
36227:       mHiddenPluginTimer->InitWithCallback(this, HIDDEN_PLUGIN_DELAY, nsITimer::TYPE_REPEATING_SLACK);
36227:     }
36227:   }
36227: #endif
36227: }
36227: 
36227: void nsPluginHost::RemoveIdleTimeTarget(nsIPluginInstanceOwner* objectFrame)
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
36227:   PRBool visibleRemoved = mVisibleTimerTargets.RemoveElement(objectFrame);
36227:   if (visibleRemoved && mVisibleTimerTargets.IsEmpty()) {
36227:     mVisiblePluginTimer->Cancel();
36227:   }
36227: 
36227:   PRBool hiddenRemoved = mHiddenTimerTargets.RemoveElement(objectFrame);
36227:   if (hiddenRemoved && mHiddenTimerTargets.IsEmpty()) {
36227:     mHiddenPluginTimer->Cancel();
36227:   }
36227: 
36227:   NS_ASSERTION(!(hiddenRemoved && visibleRemoved), "Plugin instance received visible and hidden idle event notifications");
36227: #endif
36227: }
36227: 
36227: NS_IMETHODIMP nsPluginHost::Notify(nsITimer* timer)
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
36227:   if (timer == mVisiblePluginTimer) {
36227:     nsTObserverArray<nsIPluginInstanceOwner*>::ForwardIterator iter(mVisibleTimerTargets);
36227:     while (iter.HasMore()) {
36227:       iter.GetNext()->SendIdleEvent();
36227:     }
36227:     return NS_OK;
36227:   } else if (timer == mHiddenPluginTimer) {
36227:     nsTObserverArray<nsIPluginInstanceOwner*>::ForwardIterator iter(mHiddenTimerTargets);
36227:     while (iter.HasMore()) {
36227:       iter.GetNext()->SendIdleEvent();
36227:     }
36227:     return NS_OK;
36227:   }
36227: #endif
36227:   return NS_ERROR_FAILURE;
36227: }
36227: 
36304: #ifdef MOZ_IPC
36304: void
38026: nsPluginHost::PluginCrashed(nsNPAPIPlugin* aPlugin, const nsAString& dumpID)
36304: {
37841:   nsPluginTag* pluginTag = FindTagForPlugin(aPlugin);
37525:   if (!pluginTag) {
36304:     NS_WARNING("nsPluginTag not found in nsPluginHost::PluginCrashed");
36304:     return;
36304:   }
36304: 
38026:   // Notify the app's observer that a plugin crashed so it can submit a crashreport.
38026:   PRBool submittedCrashReport = PR_FALSE;
38026:   nsCOMPtr<nsIObserverService> obsService = do_GetService("@mozilla.org/observer-service;1");
38026:   nsCOMPtr<nsIWritablePropertyBag2> propbag = do_CreateInstance("@mozilla.org/hash-property-bag;1");
38026:   if (obsService && propbag) {
38026:     propbag->SetPropertyAsAString(NS_LITERAL_STRING("minidumpID"), dumpID);
38026:     obsService->NotifyObservers(propbag, "plugin-crashed", nsnull);
38026:     // see if an observer submitted a crash report.
38026:     propbag->GetPropertyAsBool(NS_LITERAL_STRING("submittedCrashReport"), &submittedCrashReport);
38026:   }
38026: 
36304:   // Invalidate each nsPluginInstanceTag for the crashed plugin
36304: 
37841:   for (PRUint32 i = mInstanceTags.Length(); i > 0; i--) {
37841:     nsPluginInstanceTag* instanceTag = mInstanceTags[i - 1];
37841:     if (instanceTag->mPluginTag == pluginTag) {
37151:       // notify the content node (nsIObjectLoadingContent) that the plugin has crashed
37151:       nsCOMPtr<nsIDOMElement> domElement;
37841:       instanceTag->mInstance->GetDOMElement(getter_AddRefs(domElement));
37151:       nsCOMPtr<nsIObjectLoadingContent> objectContent(do_QueryInterface(domElement));
37151:       if (objectContent) {
38026:         objectContent->PluginCrashed(NS_ConvertUTF8toUTF16(pluginTag->mName),
38026:                                      submittedCrashReport);
37151:       }
37151:       
37841:       instanceTag->mInstance->Stop();
37841: 
37841:       nsPluginTag* pluginTag = instanceTag->mPluginTag;
37841:       mInstanceTags.RemoveElement(instanceTag);
37525:       OnPluginInstanceDestroyed(pluginTag);
36304:     }
36304:   }
36304: 
36304:   // Only after all instances have been invalidated is it safe to null
36304:   // out nsPluginTag.mEntryPoint. The next time we try to create an
36304:   // instance of this plugin we reload it (launch a new plugin process).
36304: 
37525:   pluginTag->mEntryPoint = nsnull;
36304: }
36304: #endif
36304: 
37841: nsPluginInstanceTag*
37841: nsPluginHost::FindInstanceTag(nsIPluginInstance *instance)
37841: {
37841:   for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:     nsPluginInstanceTag *instanceTag = mInstanceTags[i];
37841:     if (instanceTag->mInstance == instance)
37841:       return instanceTag;
37841:   }
37841:   return nsnull;
37841: }
37841: 
37841: nsPluginInstanceTag*
37841: nsPluginHost::FindInstanceTag(const char *mimetype)
37525: {
37525:   PRBool defaultplugin = (PL_strcmp(mimetype, "*") == 0);
37525:   
37841:   for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:     nsPluginInstanceTag* instanceTag = mInstanceTags[i];
37525:     // give it some special treatment for the default plugin first
37525:     // because we cannot tell the default plugin by asking instance for a mime type
37841:     if (defaultplugin && instanceTag->mDefaultPlugin)
37841:       return instanceTag;
37841:     
37841:     if (!instanceTag->mInstance)
37841:       continue;
37525:     
37525:     const char* mt;
37841:     nsresult rv = instanceTag->mInstance->GetMIMEType(&mt);
37525:     if (NS_FAILED(rv))
37525:       continue;
37525:     
37525:     if (PL_strcasecmp(mt, mimetype) == 0)
37841:       return instanceTag;
37525:   }
37525:   return nsnull;
37525: }
37525: 
37841: nsPluginInstanceTag*
37841: nsPluginHost::FindStoppedInstanceTag(const char * url)
37525: {
37841:   for (PRUint32 i = 0; i < mInstanceTags.Length(); i++) {
37841:     nsPluginInstanceTag *instanceTag = mInstanceTags[i];
37841:     if (!PL_strcmp(url, instanceTag->mURL) && !instanceTag->mInstance->IsRunning())
37841:       return instanceTag;
37525:   }
37525:   return nsnull;
37525: }
37525: 
37525: void 
37525: nsPluginHost::StopRunningInstances(nsISupportsArray* aReloadDocs, nsPluginTag* aPluginTag)
37525: {
37841:   for (PRInt32 i = mInstanceTags.Length(); i > 0; i--) {
37841:     nsPluginInstanceTag *instanceTag = mInstanceTags[i - 1];
37841:     nsNPAPIPluginInstance* instance = instanceTag->mInstance;
37841:     if (instance->IsRunning() && (!aPluginTag || aPluginTag == instanceTag->mPluginTag)) {
37525:       instance->SetWindow(nsnull);
37525:       instance->Stop();
37525: 
37525:       // If we've been passed an array to return, lets collect all our documents,
37525:       // removing duplicates. These will be reframed (embedded) or reloaded (full-page) later
37525:       // to kickstart our instances.
37525:       if (aReloadDocs) {
37525:         nsCOMPtr<nsIPluginInstanceOwner> owner;
37525:         instance->GetOwner(getter_AddRefs(owner));
37525:         if (owner) {
37525:           nsCOMPtr<nsIDocument> doc;
37525:           owner->GetDocument(getter_AddRefs(doc));
37525:           if (doc && aReloadDocs->IndexOf(doc) == -1)  // don't allow for duplicates
37525:             aReloadDocs->AppendElement(doc);
37525:         }
37525:       }
37525: 
37841:       nsPluginTag* pluginTag = instanceTag->mPluginTag;
37841:       mInstanceTags.RemoveElement(instanceTag);
37525:       OnPluginInstanceDestroyed(pluginTag);
37525:     }
37525:   }
37525: }
37525: 
37841: nsTArray< nsAutoPtr<nsPluginInstanceTag> >*
37841: nsPluginHost::InstanceTagArray()
37525: {
37841:   return &mInstanceTags;
37525: }
37525: 
    1: nsresult nsPluginStreamListenerPeer::ServeStreamAsFile(nsIRequest *request,
    1:                                                        nsISupports* aContext)
    1: {
    1:   if (!mInstance)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // mInstance->Stop calls mPStreamListener->CleanUpStream(), so stream will be properly clean up
    1:   mInstance->Stop();
    1:   mInstance->Start();
    1:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   mInstance->GetOwner(getter_AddRefs(owner));
    1:   if (owner) {
32799:     NPWindow* window = nsnull;
    1:     owner->GetWindow(window);
38045: #if defined(MOZ_WIDGET_GTK2) || defined(MOZ_WIDGET_QT)
    1:     // Should call GetPluginPort() here.
    1:     // This part is copied from nsPluginInstanceOwner::GetPluginPort(). 
    1:     nsCOMPtr<nsIWidget> widget;
    1:     ((nsPluginNativeWindow*)window)->GetPluginWidget(getter_AddRefs(widget));
    1:     if (widget) {
32799:       window->window = widget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
    1:     }
    1: #endif
29834:     if (window->window) {
    1:       nsCOMPtr<nsIPluginInstance> inst = mInstance;
    1:       ((nsPluginNativeWindow*)window)->CallSetWindow(inst);
    1:     }
    1:   }
    1: 
38785:   mPluginStreamInfo->SetSeekable(0);
38785:   mPStreamListener->OnStartBinding(mPluginStreamInfo);
38785:   mPluginStreamInfo->SetStreamOffset(0);
    1: 
36843:   // force the plugin to use stream as file
32799:   mStreamType = NP_ASFILE;
    1: 
    1:   // then check it out if browser cache is not available
    1:   nsCOMPtr<nsICachingChannel> cacheChannel = do_QueryInterface(request);
    1:   if (!(cacheChannel && (NS_SUCCEEDED(cacheChannel->SetCacheAsFile(PR_TRUE))))) {
    1:       nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
    1:       if (channel) {
    1:         SetupPluginCacheFile(channel);
    1:       }
    1:   }
    1: 
    1:   // unset mPendingRequests
    1:   mPendingRequests = 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
13322: NS_IMPL_ISUPPORTS1(nsPluginByteRangeStreamListener, nsIStreamListener)
    1: nsPluginByteRangeStreamListener::nsPluginByteRangeStreamListener(nsIWeakReference* aWeakPtr)
    1: {
    1:   mWeakPtrPluginStreamListenerPeer = aWeakPtr;
    1:   mRemoveMagicNumber = PR_FALSE;
    1: }
    1: 
    1: nsPluginByteRangeStreamListener::~nsPluginByteRangeStreamListener()
    1: {
    1:   mStreamConverter = 0;
    1:   mWeakPtrPluginStreamListenerPeer = 0;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginByteRangeStreamListener::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIStreamListener> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
    1:   if (!finalStreamListener)
    1:      return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIStreamConverterService> serv = do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     rv = serv->AsyncConvertData(MULTIPART_BYTERANGES,
    1:                                 "*/*",
    1:                                 finalStreamListener,
    1:                                 nsnull,
    1:                                 getter_AddRefs(mStreamConverter));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = mStreamConverter->OnStartRequest(request, ctxt);
    1:       if (NS_SUCCEEDED(rv))
    1:         return rv;
    1:     }
    1:   }
    1:   mStreamConverter = 0;
    1: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(request));
    1:   if (!httpChannel) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PRUint32 responseCode = 0;
    1:   rv = httpChannel->GetResponseStatus(&responseCode);
16367:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
16367:   // get nsPluginStreamListenerPeer* ptr from finalStreamListener
16367:   nsPluginStreamListenerPeer *pslp =
16367:     reinterpret_cast<nsPluginStreamListenerPeer*>(finalStreamListener.get());
16367: 
16367:   if (responseCode != 200) {
16367:     PRBool bWantsAllNetworkStreams = PR_FALSE;
16367:     pslp->GetPluginInstance()->
32799:       GetValueFromPlugin(NPPVpluginWantsAllNetworkStreams,
16367:                          (void*)&bWantsAllNetworkStreams);
16367:     if (!bWantsAllNetworkStreams){
16367:       return NS_ERROR_FAILURE;
16367:     }
16367:   }
16367: 
    1:   // if server cannot continue with byte range (206 status) and sending us whole object (200 status)
    1:   // reset this seekable stream & try serve it to plugin instance as a file
    1:   mStreamConverter = finalStreamListener;
    1:   mRemoveMagicNumber = PR_TRUE;
    1: 
    1:   rv = pslp->ServeStreamAsFile(request, ctxt);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginByteRangeStreamListener::OnStopRequest(nsIRequest *request, nsISupports *ctxt,
    1:                               nsresult status)
    1: {
    1:   if (!mStreamConverter)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIStreamListener> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
    1:   if (!finalStreamListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (mRemoveMagicNumber) {
    1:     // remove magic number from container
    1:     nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(ctxt);
    1:     if (container) {
    1:       PRUint32 magicNumber = 0;
    1:       container->GetData(&magicNumber);
    1:       if (magicNumber == MAGIC_REQUEST_CONTEXT) {
    1:         // to allow properly finish nsPluginStreamListenerPeer->OnStopRequest()
    1:         // set it to something that is not the magic number.
    1:         container->SetData(0);
    1:       }
    1:     } else {
    1:       NS_WARNING("Bad state of nsPluginByteRangeStreamListener");
    1:     }
    1:   }
    1: 
    1:   return mStreamConverter->OnStopRequest(request, ctxt, status);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPluginByteRangeStreamListener::OnDataAvailable(nsIRequest *request, nsISupports *ctxt,
    1:                                 nsIInputStream *inStr, PRUint32 sourceOffset, PRUint32 count)
    1: {
    1:   if (!mStreamConverter)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIStreamListener> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
    1:   if (!finalStreamListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mStreamConverter->OnDataAvailable(request, ctxt, inStr, sourceOffset, count);
    1: }
    1: 
    1: PRBool
38785: nsPluginStreamInfo::UseExistingPluginCacheFile(nsPluginStreamInfo* psi)
    1: {
    1: 
    1:   NS_ENSURE_ARG_POINTER(psi);
    1: 
    1:  if ( psi->mLength == mLength &&
    1:       psi->mModified == mModified &&
    1:       mStreamComplete &&
38785:       !PL_strcmp(psi->mURL, mURL))
    1:   {
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
38785: void
38785: nsPluginStreamInfo::SetStreamComplete(const PRBool complete)
38785: {
38785:   mStreamComplete = complete;
38785: 
38785:   if (complete) {
38785:     // We're done, release the request.
38785:     SetRequest(nsnull);
38785:   }
38785: }
38785: 
12417: // Runnable that does an async destroy of a plugin.
12417: 
12417: class nsPluginDestroyRunnable : public nsRunnable,
12417:                                 public PRCList
12417: {
12417: public:
12417:   nsPluginDestroyRunnable(nsIPluginInstance *aInstance)
12417:     : mInstance(aInstance)
12417:   {
12417:     PR_INIT_CLIST(this);
12417:     PR_APPEND_LINK(this, &sRunnableListHead);
12417:   }
12417: 
12417:   virtual ~nsPluginDestroyRunnable()
12417:   {
12417:     PR_REMOVE_LINK(this);
12417:   }
12417: 
12417:   NS_IMETHOD Run()
12417:   {
12417:     nsCOMPtr<nsIPluginInstance> instance;
12417: 
12417:     // Null out mInstance to make sure this code in another runnable
12417:     // will do the right thing even if someone was holding on to this
12417:     // runnable longer than we expect.
12417:     instance.swap(mInstance);
12417: 
12417:     if (PluginDestructionGuard::DelayDestroy(instance)) {
12417:       // It's still not safe to destroy the plugin, it's now up to the
12417:       // outermost guard on the stack to take care of the destruction.
12417:       return NS_OK;
12417:     }
12417: 
12417:     nsPluginDestroyRunnable *r =
12417:       static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(&sRunnableListHead));
12417: 
12417:     while (r != &sRunnableListHead) {
12417:       if (r != this && r->mInstance == instance) {
12417:         // There's another runnable scheduled to tear down
12417:         // instance. Let it do the job.
12417:         return NS_OK;
12417:       }
12592:       r = static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(r));
12417:     }
12417: 
12417:     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
12417:                ("Doing delayed destroy of instance %p\n", instance.get()));
12417: 
29956:     nsRefPtr<nsPluginHost> host = nsPluginHost::GetInst();
21231:     if (host)
12417:       host->StopPluginInstance(instance);
12417: 
12417:     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
12417:                ("Done with delayed destroy of instance %p\n", instance.get()));
12417: 
12417:     return NS_OK;
12417:   }
12417: 
12417: protected:
12417:   nsCOMPtr<nsIPluginInstance> mInstance;
12417: 
12417:   static PRCList sRunnableListHead;
12417: };
12417: 
12417: PRCList nsPluginDestroyRunnable::sRunnableListHead =
12417:   PR_INIT_STATIC_CLIST(&nsPluginDestroyRunnable::sRunnableListHead);
12417: 
12417: PRCList PluginDestructionGuard::sListHead =
12417:   PR_INIT_STATIC_CLIST(&PluginDestructionGuard::sListHead);
12417: 
12417: PluginDestructionGuard::~PluginDestructionGuard()
12417: {
12417:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
12417: 
12417:   PR_REMOVE_LINK(this);
12417: 
12417:   if (mDelayedDestroy) {
12417:     // We've attempted to destroy the plugin instance we're holding on
12417:     // to while we were guarding it. Do the actual destroy now, off of
12417:     // a runnable.
12417:     nsRefPtr<nsPluginDestroyRunnable> evt =
12417:       new nsPluginDestroyRunnable(mInstance);
12417: 
12417:     NS_DispatchToMainThread(evt);
12417:   }
12417: }
12417: 
12417: // static
12417: PRBool
12417: PluginDestructionGuard::DelayDestroy(nsIPluginInstance *aInstance)
12417: {
12417:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
12417:   NS_ASSERTION(aInstance, "Uh, I need an instance!");
12417: 
12417:   // Find the first guard on the stack and make it do a delayed
12417:   // destroy upon destruction.
12417: 
12417:   PluginDestructionGuard *g =
12417:     static_cast<PluginDestructionGuard*>(PR_LIST_HEAD(&sListHead));
12417: 
12417:   while (g != &sListHead) {
12417:     if (g->mInstance == aInstance) {
12417:       g->mDelayedDestroy = PR_TRUE;
12417: 
12417:       return PR_TRUE;
12417:     }
12417:     g = static_cast<PluginDestructionGuard*>(PR_NEXT_LINK(g));    
12417:   }
12417: 
12417:   return PR_FALSE;
12417: }
