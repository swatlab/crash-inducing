43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43113: /* vim:set expandtab ts=4 sw=4 sts=4 cin: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@meer.net> (original author)
43113:  *   Christian Biesinger <cbiesinger@web.de>
43113:  *   Google Inc.
43113:  *   Jan Wrobel <wrobel@blues.ath.cx>
43113:  *   Jan Odvarko <odvarko@gmail.com>
43113:  *   Dave Camp <dcamp@mozilla.com>
43113:  *   Honza Bambas <honzab@firemni.cz>
46790:  *   Daniel Witte <dwitte@mozilla.com>
46909:  *   Jason Duell <jduell.mcbugs@gmail.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsHttpChannel.h"
43113: #include "nsHttpHandler.h"
43113: #include "nsIApplicationCacheService.h"
43113: #include "nsIApplicationCacheContainer.h"
43113: #include "nsIAuthInformation.h"
43113: #include "nsIStringBundle.h"
43113: #include "nsIIDNService.h"
43113: #include "nsIStreamListenerTee.h"
43113: #include "nsISeekableStream.h"
43113: #include "nsMimeTypes.h"
43113: #include "nsNetUtil.h"
43113: #include "prprf.h"
51363: #include "prnetdb.h"
43113: #include "nsEscape.h"
43113: #include "nsStreamUtils.h"
43113: #include "nsIOService.h"
43113: #include "nsICacheService.h"
43113: #include "nsDNSPrefetch.h"
43113: #include "nsChannelClassifier.h"
49375: #include "nsIRedirectResultListener.h"
70188: #include "mozilla/TimeStamp.h"
78427: #include "mozilla/Telemetry.h"
78633: #include "nsDOMError.h"
81029: #include "nsAlgorithm.h"
81029: 
81029: using namespace mozilla;
43113: 
79877: // Device IDs for various cache types
79877: const char kDiskDeviceID[] = "disk";
79877: const char kMemoryDeviceID[] = "memory";
79877: const char kOfflineDeviceID[] = "offline";
79877: 
43113: // True if the local cache should be bypassed when processing a request.
43113: #define BYPASS_LOCAL_CACHE(loadFlags) \
43113:         (loadFlags & (nsIRequest::LOAD_BYPASS_CACHE | \
43113:                       nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE))
43113: 
43113: static NS_DEFINE_CID(kStreamListenerTeeCID, NS_STREAMLISTENERTEE_CID);
43113: 
49375: class AutoRedirectVetoNotifier
49375: {
49375: public:
49375:     AutoRedirectVetoNotifier(nsHttpChannel* channel) : mChannel(channel) {}
49375:     ~AutoRedirectVetoNotifier() {ReportRedirectResult(false);}
49375:     void RedirectSucceeded() {ReportRedirectResult(true);}
49375: 
49375: private:
49375:     nsHttpChannel* mChannel;
49375:     void ReportRedirectResult(bool succeeded);
49375: };
49375: 
49375: void
49375: AutoRedirectVetoNotifier::ReportRedirectResult(bool succeeded)
49375: {
49375:     if (!mChannel)
49375:         return;
49375: 
51363:     mChannel->mRedirectChannel = nsnull;
51363: 
49375:     nsCOMPtr<nsIRedirectResultListener> vetoHook;
49375:     NS_QueryNotificationCallbacks(mChannel, 
49375:                                   NS_GET_IID(nsIRedirectResultListener), 
49375:                                   getter_AddRefs(vetoHook));
49375:     mChannel = nsnull;
49375:     if (vetoHook)
49375:         vetoHook->OnRedirectResult(succeeded);
49375: }
49375: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <public>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpChannel::nsHttpChannel()
71646:     : HttpAsyncAborter<nsHttpChannel>(this)
71646:     , mLogicalOffset(0)
43113:     , mCacheAccess(0)
43113:     , mPostID(0)
43113:     , mRequestTime(0)
53987:     , mOnCacheEntryAvailableCallback(nsnull)
80486:     , mAsyncCacheOpen(false)
80486:     , mCachedContentIsValid(false)
80486:     , mCachedContentIsPartial(false)
80486:     , mTransactionReplaced(false)
80486:     , mAuthRetryPending(false)
80486:     , mResuming(false)
80486:     , mInitedCacheEntry(false)
80486:     , mCacheForOfflineUse(false)
80486:     , mCachingOpportunistically(false)
80486:     , mFallbackChannel(false)
80486:     , mCustomConditionalRequest(false)
80486:     , mFallingBack(false)
80486:     , mWaitingForRedirectCallback(false)
80486:     , mRequestTimeInitialized(false)
78427:     , mDidReval(false)
43113: {
43113:     LOG(("Creating nsHttpChannel [this=%p]\n", this));
70188:     mChannelCreationTime = PR_Now();
70188:     mChannelCreationTimestamp = mozilla::TimeStamp::Now();
43113: }
43113: 
43113: nsHttpChannel::~nsHttpChannel()
43113: {
43113:     LOG(("Destroying nsHttpChannel [this=%p]\n", this));
43113: 
46930:     if (mAuthProvider)
46930:         mAuthProvider->Disconnect(NS_ERROR_ABORT);
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::Init(nsIURI *uri,
43113:                     PRUint8 caps,
43113:                     nsProxyInfo *proxyInfo)
43113: {
46909:     nsresult rv = HttpBaseChannel::Init(uri, caps, proxyInfo);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
46909:     LOG(("nsHttpChannel::Init [this=%p]\n", this));
43832: 
43832:     mAuthProvider =
43832:         do_CreateInstance("@mozilla.org/network/http-channel-auth-provider;1",
43832:                           &rv);
46909:     if (NS_FAILED(rv))
46909:         return rv;
43832:     rv = mAuthProvider->Init(this);
43113: 
43113:     return rv;
43113: }
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <private>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
79445: nsHttpChannel::Connect(bool firstTime)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::Connect [this=%p]\n", this));
43113: 
51363:     // Even if we're in private browsing mode, we still enforce existing STS
51363:     // data (it is read-only).
51363:     // if the connection is not using SSL and either the exact host matches or
51363:     // a superdomain wants to force HTTPS, do it.
79445:     bool usingSSL = false;
51363:     rv = mURI->SchemeIs("https", &usingSSL);
51363:     NS_ENSURE_SUCCESS(rv,rv);
51363: 
51363:     if (!usingSSL) {
51363:         // enforce Strict-Transport-Security
51363:         nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
51363:         NS_ENSURE_TRUE(stss, NS_ERROR_OUT_OF_MEMORY);
51363: 
79445:         bool isStsHost = false;
51363:         rv = stss->IsStsURI(mURI, &isStsHost);
52258: 
52258:         // if STS fails, there's no reason to cancel the load, but it's
52258:         // worrisome.
52258:         NS_ASSERTION(NS_SUCCEEDED(rv),
52258:                      "Something is wrong with STS: IsStsURI failed.");
52258: 
52258:         if (NS_SUCCEEDED(rv) && isStsHost) {
51363:             LOG(("nsHttpChannel::Connect() STS permissions found\n"));
51363:             return AsyncCall(&nsHttpChannel::HandleAsyncRedirectChannelToHttps);
51363:         }
51363:     }
51363: 
43113:     // ensure that we are using a valid hostname
43113:     if (!net_IsValidHostName(nsDependentCString(mConnectionInfo->Host())))
43113:         return NS_ERROR_UNKNOWN_HOST;
43113: 
43113:     // true when called from AsyncOpen
43113:     if (firstTime) {
43113:         // are we offline?
79445:         bool offline = gIOService->IsOffline();
43113:         if (offline)
43113:             mLoadFlags |= LOAD_ONLY_FROM_CACHE;
43113:         else if (PL_strcmp(mConnectionInfo->ProxyType(), "unknown") == 0)
43113:             return ResolveProxy();  // Lazily resolve proxy info
43113: 
43113:         // Don't allow resuming when cache must be used
43113:         if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
43113:             LOG(("Resuming from cache is not supported yet"));
43113:             return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:         }
43113: 
43113:         // open a cache entry for this channel...
53987:         rv = OpenCacheEntry();
43113: 
43113:         if (NS_FAILED(rv)) {
43113:             LOG(("OpenCacheEntry failed [rv=%x]\n", rv));
43113:             // if this channel is only allowed to pull from the cache, then
43113:             // we must fail if we were unable to open a cache entry.
43113:             if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
43113:                 // If we have a fallback URI (and we're not already
43113:                 // falling back), process the fallback asynchronously.
43113:                 if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
43113:                     return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
43113:                 }
43113:                 return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:             }
43113:             // otherwise, let's just proceed without using the cache.
43113:         }
43113: 
43113:         // if cacheForOfflineUse has been set, open up an offline cache
43113:         // entry to update
43113:         if (mCacheForOfflineUse) {
43113:             rv = OpenOfflineCacheEntryForWriting();
43113:             if (NS_FAILED(rv)) return rv;
43113:         }
43113: 
53987:         if (NS_SUCCEEDED(rv) && mAsyncCacheOpen)
43113:             return NS_OK;
43113:     }
43113: 
43113:     // we may or may not have a cache entry at this point
43113:     if (mCacheEntry) {
43113:         // inspect the cache entry to determine whether or not we need to go
43113:         // out to net to validate it.  this call sets mCachedContentIsValid
43113:         // and may set request headers as required for cache validation.
43113:         rv = CheckCache();
43113:         if (NS_FAILED(rv))
43113:             NS_WARNING("cache check failed");
43113: 
43113:         // read straight from the cache if possible...
43113:         if (mCachedContentIsValid) {
43113:             nsRunnableMethod<nsHttpChannel> *event = nsnull;
43113:             if (!mCachedContentIsPartial) {
43113:                 AsyncCall(&nsHttpChannel::AsyncOnExamineCachedResponse, &event);
43113:             }
43113:             rv = ReadFromCache();
43113:             if (NS_FAILED(rv) && event) {
43113:                 event->Revoke();
43113:             }
78427:             mozilla::Telemetry::Accumulate(
78427:                     mozilla::Telemetry::HTTP_CACHE_DISPOSITION, kCacheHit);
79877: 
79877:             char* cacheDeviceID = nsnull;
79877:             mCacheEntry->GetDeviceID(&cacheDeviceID);
79877:             if (cacheDeviceID) {
79877:                 if (!strcmp(cacheDeviceID, kDiskDeviceID))
79877:                     mozilla::Telemetry::Accumulate(
79877:                             mozilla::Telemetry::HTTP_DISK_CACHE_DISPOSITION,
79877:                             kCacheHit);
79877:                 else if (!strcmp(cacheDeviceID, kMemoryDeviceID))
79877:                     mozilla::Telemetry::Accumulate(
79877:                             mozilla::Telemetry::HTTP_MEMORY_CACHE_DISPOSITION,
79877:                             kCacheHit);
79877:                 else if (!strcmp(cacheDeviceID, kOfflineDeviceID))
79877:                     mozilla::Telemetry::Accumulate(
79877:                             mozilla::Telemetry::HTTP_OFFLINE_CACHE_DISPOSITION,
79877:                             kCacheHit);
79877:             }
43113:             return rv;
43113:         }
43113:         else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
43113:             // the cache contains the requested resource, but it must be 
43113:             // validated before we can reuse it.  since we are not allowed
43113:             // to hit the net, there's nothing more to do.  the document
43113:             // is effectively not in the cache.
43113:             return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:         }
43113:     }
53987:     else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
53987:         // If we have a fallback URI (and we're not already
53987:         // falling back), process the fallback asynchronously.
53987:         if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
53987:             return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
53987:         }
53987:         return NS_ERROR_DOCUMENT_NOT_CACHED;
53987:     }
43113: 
43113:     // check to see if authorization headers should be included
43832:     mAuthProvider->AddAuthorizationHeaders();
43113: 
43113:     if (mLoadFlags & LOAD_NO_NETWORK_IO) {
43113:         return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:     }
43113: 
43113:     // hit the net...
43113:     rv = SetupTransaction();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     rv = mTransactionPump->AsyncRead(this, nsnull);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     PRUint32 suspendCount = mSuspendCount;
53987:     while (suspendCount--)
53987:         mTransactionPump->Suspend();
53987: 
53987:     return NS_OK;
43113: }
43113: 
71646: void
71646: nsHttpChannel::DoNotifyListenerCleanup()
69869: {
63794:     // We don't need this info anymore
63794:     CleanRedirectCacheChainIfNecessary();
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncRedirect()
43113: {
71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
43113:     
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async redirect [this=%p]\n", this));
71646:         mCallOnResume = &nsHttpChannel::HandleAsyncRedirect;
43113:         return;
43113:     }
43113: 
43113:     nsresult rv = NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::HandleAsyncRedirect [this=%p]\n", this));
43113: 
43113:     // since this event is handled asynchronously, it is possible that this
43113:     // channel could have been canceled, in which case there would be no point
43113:     // in processing the redirect.
43113:     if (NS_SUCCEEDED(mStatus)) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncRedirect);
48304:         rv = AsyncProcessRedirection(mResponseHead->Status());
43113:         if (NS_FAILED(rv)) {
48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncRedirect);
48304:             ContinueHandleAsyncRedirect(rv);
48304:         }
48304:     }
48304:     else {
48304:         ContinueHandleAsyncRedirect(NS_OK);
48304:     }
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueHandleAsyncRedirect(nsresult rv)
48304: {
48304:     if (NS_FAILED(rv)) {
48304:         // If AsyncProcessRedirection fails, then we have to send out the
43113:         // OnStart/OnStop notifications.
48304:         LOG(("ContinueHandleAsyncRedirect got failure result [rv=%x]\n", rv));
43113:         mStatus = rv;
43113:         DoNotifyListener();
43113:     }
43113: 
43113:     // close the cache entry.  Blow it away if we couldn't process the redirect
43113:     // for some reason (the cache entry might be corrupt).
43113:     if (mCacheEntry) {
43113:         if (NS_FAILED(rv))
43113:             mCacheEntry->Doom();
80486:         CloseCacheEntry(false);
80486:     }
80486: 
80486:     mIsPending = false;
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
48304: 
48304:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncNotModified()
43113: {
71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
43113:     
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async not-modified [this=%p]\n",
43113:              this));
71646:         mCallOnResume = &nsHttpChannel::HandleAsyncNotModified;
43113:         return;
43113:     }
43113:     
43113:     LOG(("nsHttpChannel::HandleAsyncNotModified [this=%p]\n", this));
43113: 
43113:     DoNotifyListener();
43113: 
80486:     CloseCacheEntry(true);
80486: 
80486:     mIsPending = false;
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncFallback()
43113: {
71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
43113: 
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async fallback [this=%p]\n", this));
71646:         mCallOnResume = &nsHttpChannel::HandleAsyncFallback;
43113:         return;
43113:     }
43113: 
43113:     nsresult rv = NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::HandleAsyncFallback [this=%p]\n", this));
43113: 
43113:     // since this event is handled asynchronously, it is possible that this
43113:     // channel could have been canceled, in which case there would be no point
43113:     // in processing the fallback.
43113:     if (!mCanceled) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncFallback);
79445:         bool waitingForRedirectCallback;
48304:         rv = ProcessFallback(&waitingForRedirectCallback);
48304:         if (waitingForRedirectCallback)
48304:             return;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncFallback);
48304:     }
48304: 
48304:     ContinueHandleAsyncFallback(rv);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueHandleAsyncFallback(nsresult rv)
48304: {
48304:     if (!mCanceled && (NS_FAILED(rv) || !mFallingBack)) {
43113:         // If ProcessFallback fails, then we have to send out the
43113:         // OnStart/OnStop notifications.
48304:         LOG(("ProcessFallback failed [rv=%x, %d]\n", rv, mFallingBack));
43113:         mStatus = NS_FAILED(rv) ? rv : NS_ERROR_DOCUMENT_NOT_CACHED;
43113:         DoNotifyListener();
43113:     }
43113: 
80486:     mIsPending = false;
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
48304: 
48304:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::SetupTransaction()
43113: {
43113:     LOG(("nsHttpChannel::SetupTransaction [this=%p]\n", this));
43113: 
43113:     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_ALREADY_INITIALIZED);
43113: 
43113:     nsresult rv;
43113: 
43113:     if (mCaps & NS_HTTP_ALLOW_PIPELINING) {
43113:         //
43113:         // disable pipelining if:
43113:         //   (1) pipelining has been explicitly disabled
43113:         //   (2) request corresponds to a top-level document load (link click)
43113:         //   (3) request method is non-idempotent
43113:         //
43113:         // XXX does the toplevel document check really belong here?  or, should
43113:         //     we push it out entirely to necko consumers?
43113:         //
43113:         if (!mAllowPipelining || (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI) ||
43113:             !(mRequestHead.Method() == nsHttp::Get ||
43113:               mRequestHead.Method() == nsHttp::Head ||
43113:               mRequestHead.Method() == nsHttp::Propfind ||
43113:               mRequestHead.Method() == nsHttp::Proppatch)) {
43113:             LOG(("  pipelining disallowed\n"));
43113:             mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
43113:         }
43113:     }
43113: 
43113:     // use the URI path if not proxying (transparent proxying such as SSL proxy
43113:     // does not count here). also, figure out what version we should be speaking.
43113:     nsCAutoString buf, path;
43113:     nsCString* requestURI;
69816:     if (mConnectionInfo->UsingSSL() ||
69816:         mConnectionInfo->ShouldForceConnectMethod() ||
69816:         !mConnectionInfo->UsingHttpProxy()) {
43113:         rv = mURI->GetPath(path);
43113:         if (NS_FAILED(rv)) return rv;
43113:         // path may contain UTF-8 characters, so ensure that they're escaped.
43113:         if (NS_EscapeURL(path.get(), path.Length(), esc_OnlyNonASCII, buf))
43113:             requestURI = &buf;
43113:         else
43113:             requestURI = &path;
43113:         mRequestHead.SetVersion(gHttpHandler->HttpVersion());
43113:     }
43113:     else {
43113:         rv = mURI->GetUserPass(buf);
43113:         if (NS_FAILED(rv)) return rv;
43113:         if (!buf.IsEmpty() && ((strncmp(mSpec.get(), "http:", 5) == 0) ||
43113:                                 strncmp(mSpec.get(), "https:", 6) == 0)) {
43113:             nsCOMPtr<nsIURI> tempURI;
43113:             rv = mURI->Clone(getter_AddRefs(tempURI));
43113:             if (NS_FAILED(rv)) return rv;
43113:             rv = tempURI->SetUserPass(EmptyCString());
43113:             if (NS_FAILED(rv)) return rv;
43113:             rv = tempURI->GetAsciiSpec(path);
43113:             if (NS_FAILED(rv)) return rv;
43113:             requestURI = &path;
43113:         }
43113:         else
43113:             requestURI = &mSpec;
43113:         mRequestHead.SetVersion(gHttpHandler->ProxyHttpVersion());
43113:     }
43113: 
43113:     // trim off the #ref portion if any...
43113:     PRInt32 ref = requestURI->FindChar('#');
43113:     if (ref != kNotFound)
43113:         requestURI->SetLength(ref);
43113: 
43113:     mRequestHead.SetRequestURI(*requestURI);
43113: 
43113:     // set the request time for cache expiration calculations
43113:     mRequestTime = NowInSeconds();
80486:     mRequestTimeInitialized = true;
43113: 
43113:     // if doing a reload, force end-to-end
43113:     if (mLoadFlags & LOAD_BYPASS_CACHE) {
43113:         // We need to send 'Pragma:no-cache' to inhibit proxy caching even if
43113:         // no proxy is configured since we might be talking with a transparent
43113:         // proxy, i.e. one that operates at the network level.  See bug #14772.
80486:         mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), true);
43113:         // If we're configured to speak HTTP/1.1 then also send 'Cache-control:
43113:         // no-cache'
43113:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
80486:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("no-cache"), true);
43113:     }
43113:     else if ((mLoadFlags & VALIDATE_ALWAYS) && (mCacheAccess & nsICache::ACCESS_READ)) {
43113:         // We need to send 'Cache-Control: max-age=0' to force each cache along
43113:         // the path to the origin server to revalidate its own entry, if any,
43113:         // with the next cache or server.  See bug #84847.
43113:         //
43113:         // If we're configured to speak HTTP/1.0 then just send 'Pragma: no-cache'
43113:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
80486:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("max-age=0"), true);
43113:         else
80486:             mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), true);
43113:     }
43113: 
43113:     if (mResuming) {
43113:         char byteRange[32];
43113:         PR_snprintf(byteRange, sizeof(byteRange), "bytes=%llu-", mStartPos);
43113:         mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(byteRange));
43113: 
43113:         if (!mEntityID.IsEmpty()) {
43113:             // Also, we want an error if this resource changed in the meantime
43113:             // Format of the entity id is: escaped_etag/size/lastmod
43113:             nsCString::const_iterator start, end, slash;
43113:             mEntityID.BeginReading(start);
43113:             mEntityID.EndReading(end);
43113:             mEntityID.BeginReading(slash);
43113: 
43113:             if (FindCharInReadable('/', slash, end)) {
43113:                 nsCAutoString ifMatch;
43113:                 mRequestHead.SetHeader(nsHttp::If_Match,
43113:                         NS_UnescapeURL(Substring(start, slash), 0, ifMatch));
43113: 
43113:                 ++slash; // Incrementing, so that searching for '/' won't find
43113:                          // the same slash again
43113:             }
43113: 
43113:             if (FindCharInReadable('/', slash, end)) {
43113:                 mRequestHead.SetHeader(nsHttp::If_Unmodified_Since,
43113:                         Substring(++slash, end));
43113:             }
43113:         }
43113:     }
43113: 
43113:     // create wrapper for this channel's notification callbacks
43113:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
43113:     NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
43113:                                            getter_AddRefs(callbacks));
43113:     if (!callbacks)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     // create the transaction object
43113:     mTransaction = new nsHttpTransaction();
43113:     if (!mTransaction)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     // See bug #466080. Transfer LOAD_ANONYMOUS flag to socket-layer.
43113:     if (mLoadFlags & LOAD_ANONYMOUS)
43113:         mCaps |= NS_HTTP_LOAD_ANONYMOUS;
43113: 
70188:     if (mTimingEnabled)
70188:         mCaps |= NS_HTTP_TIMING_ENABLED;
70188: 
43113:     mConnectionInfo->SetAnonymous((mLoadFlags & LOAD_ANONYMOUS) != 0);
43113: 
70090:     if (mUpgradeProtocolCallback) {
80486:         mRequestHead.SetHeader(nsHttp::Upgrade, mUpgradeProtocol, false);
70090:         mRequestHead.SetHeader(nsHttp::Connection,
70090:                                nsDependentCString(nsHttp::Upgrade.get()),
80486:                                true);
70090:         mCaps |=  NS_HTTP_STICKY_CONNECTION;
70090:         mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
70090:         mCaps &= ~NS_HTTP_ALLOW_KEEPALIVE;
70090:     }
70090: 
43113:     nsCOMPtr<nsIAsyncInputStream> responseStream;
43113:     rv = mTransaction->Init(mCaps, mConnectionInfo, &mRequestHead,
43113:                             mUploadStream, mUploadStreamHasHeaders,
43113:                             NS_GetCurrentThread(), callbacks, this,
43113:                             getter_AddRefs(responseStream));
43113:     if (NS_FAILED(rv)) {
46790:         mTransaction = nsnull;
43113:         return rv;
43113:     }
43113: 
43113:     rv = nsInputStreamPump::Create(getter_AddRefs(mTransactionPump),
43113:                                    responseStream);
43113:     return rv;
43113: }
43113: 
43113: // NOTE: This function duplicates code from nsBaseChannel. This will go away
43113: // once HTTP uses nsBaseChannel (part of bug 312760)
43113: static void
43113: CallTypeSniffers(void *aClosure, const PRUint8 *aData, PRUint32 aCount)
43113: {
43113:   nsIChannel *chan = static_cast<nsIChannel*>(aClosure);
43113: 
43113:   const nsCOMArray<nsIContentSniffer>& sniffers =
43113:     gIOService->GetContentSniffers();
43113:   PRUint32 length = sniffers.Count();
43113:   for (PRUint32 i = 0; i < length; ++i) {
43113:     nsCAutoString newType;
43113:     nsresult rv =
43113:       sniffers[i]->GetMIMETypeFromContent(chan, aData, aCount, newType);
43113:     if (NS_SUCCEEDED(rv) && !newType.IsEmpty()) {
43113:       chan->SetContentType(newType);
43113:       break;
43113:     }
43113:   }
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::CallOnStartRequest()
43113: {
80486:     mTracingEnabled = false;
43113: 
43113:     if (mResponseHead && mResponseHead->ContentType().IsEmpty()) {
73543:         NS_ASSERTION(mConnectionInfo, "Should have connection info here");
43113:         if (!mContentTypeHint.IsEmpty())
43113:             mResponseHead->SetContentType(mContentTypeHint);
73543:         else if (mResponseHead->Version() == NS_HTTP_VERSION_0_9 &&
73543:                  mConnectionInfo->Port() != mConnectionInfo->DefaultPort())
73543:             mResponseHead->SetContentType(NS_LITERAL_CSTRING(TEXT_PLAIN));
43113:         else {
43113:             // Uh-oh.  We had better find out what type we are!
43113: 
43113:             // XXX This does not work with content-encodings...  but
43113:             // neither does applying the conversion from the URILoader
43113: 
43113:             nsCOMPtr<nsIStreamConverterService> serv;
43113:             nsresult rv = gHttpHandler->
43113:                 GetStreamConverterService(getter_AddRefs(serv));
43113:             // If we failed, we just fall through to the "normal" case
43113:             if (NS_SUCCEEDED(rv)) {
43113:                 nsCOMPtr<nsIStreamListener> converter;
43113:                 rv = serv->AsyncConvertData(UNKNOWN_CONTENT_TYPE,
43113:                                             "*/*",
43113:                                             mListener,
43113:                                             mListenerContext,
43113:                                             getter_AddRefs(converter));
43113:                 if (NS_SUCCEEDED(rv)) {
43113:                     mListener = converter;
43113:                 }
43113:             }
43113:         }
43113:     }
43113: 
43113:     if (mResponseHead && mResponseHead->ContentCharset().IsEmpty())
43113:         mResponseHead->SetContentCharset(mContentCharsetHint);
43113: 
52144:     if (mResponseHead) {
51740:         SetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH,
51740:                            mResponseHead->ContentLength());
52144:         // If we have a cache entry, set its predicted size to ContentLength to
52144:         // avoid caching an entry that will exceed the max size limit.
52144:         if (mCacheEntry) {
52144:             nsresult rv;
52144:             PRInt64 predictedDataSize = -1; // -1 in case GetAsInt64 fails.
52144:             GetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH, 
52144:                                &predictedDataSize);
52144:             rv = mCacheEntry->SetPredictedDataSize(predictedDataSize);
52144:             if (NS_FAILED(rv)) return rv;
52144:         }
52144:     }
43113:     // Allow consumers to override our content type
43113:     if ((mLoadFlags & LOAD_CALL_CONTENT_SNIFFERS) &&
43113:         gIOService->GetContentSniffers().Count() != 0) {
43113:         // NOTE: We can have both a txn pump and a cache pump when the cache
43113:         // content is partial. In that case, we need to read from the cache,
43113:         // because that's the one that has the initial contents. If that fails
43113:         // then give the transaction pump a shot.
43113: 
43113:         nsIChannel* thisChannel = static_cast<nsIChannel*>(this);
43113: 
79445:         bool typeSniffersCalled = false;
43113:         if (mCachePump) {
43113:           typeSniffersCalled =
43113:             NS_SUCCEEDED(mCachePump->PeekStream(CallTypeSniffers, thisChannel));
43113:         }
43113:         
43113:         if (!typeSniffersCalled && mTransactionPump) {
43113:           mTransactionPump->PeekStream(CallTypeSniffers, thisChannel);
43113:         }
43113:     }
43113: 
43113:     LOG(("  calling mListener->OnStartRequest\n"));
43113:     nsresult rv = mListener->OnStartRequest(this, mListenerContext);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // install stream converter if required
43113:     rv = ApplyContentConversions();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
52366:     // if this channel is for a download, close off access to the cache.
52366:     if (mCacheEntry && mChannelIsForDownload) {
52366:         mCacheEntry->Doom();
80486:         CloseCacheEntry(false);
52366:     }
52366: 
43113:     if (!mCanceled) {
43113:         // create offline cache entry if offline caching was requested
43113:         if (mCacheForOfflineUse) {
79445:             bool shouldCacheForOfflineUse;
43113:             rv = ShouldUpdateOfflineCacheEntry(&shouldCacheForOfflineUse);
43113:             if (NS_FAILED(rv)) return rv;
43113:             
43113:             if (shouldCacheForOfflineUse) {
43113:                 LOG(("writing to the offline cache"));
43113:                 rv = InitOfflineCacheEntry();
43113:                 if (NS_FAILED(rv)) return rv;
43113:                 
43113:                 if (mOfflineCacheEntry) {
43113:                   rv = InstallOfflineCacheListener();
43113:                   if (NS_FAILED(rv)) return rv;
43113:                 }
43113:             } else {
43113:                 LOG(("offline cache is up to date, not updating"));
43113:                 CloseOfflineCacheEntry();
43113:             }
43113:         }
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ProcessFailedSSLConnect(PRUint32 httpStatus)
43113: {
43113:     // Failure to set up SSL proxy tunnel means one of the following:
43113:     // 1) Proxy wants authorization, or forbids.
43113:     // 2) DNS at proxy couldn't resolve target URL.
43113:     // 3) Proxy connection to target failed or timed out.
43113:     // 4) Eve noticed our proxy CONNECT, and is replying with malicious HTML.
43113:     // 
43113:     // Our current architecture will parse response content with the
43113:     // permission of the target URL!  Given #4, we must avoid rendering the
43113:     // body of the reply, and instead give the user a (hopefully helpful) 
43113:     // boilerplate error page, based on just the HTTP status of the reply.
43113: 
43113:     NS_ABORT_IF_FALSE(mConnectionInfo->UsingSSL(),
43113:                       "SSL connect failed but not using SSL?");
43113:     nsresult rv;
43113:     switch (httpStatus) 
43113:     {
43113:     case 300: case 301: case 302: case 303: case 307:
43113:         // Bad redirect: not top-level, or it's a POST, bad/missing Location,
43113:         // or ProcessRedirect() failed for some other reason.  Legal
43113:         // redirects that fail because site not available, etc., are handled
43113:         // elsewhere, in the regular codepath.
43113:         rv = NS_ERROR_CONNECTION_REFUSED;
43113:         break;
43113:     case 403: // HTTP/1.1: "Forbidden"
43113:     case 407: // ProcessAuthentication() failed
43113:     case 501: // HTTP/1.1: "Not Implemented"
43113:         // user sees boilerplate Mozilla "Proxy Refused Connection" page.
43113:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
43113:         break;
43113:     // Squid sends 404 if DNS fails (regular 404 from target is tunneled)
43113:     case 404: // HTTP/1.1: "Not Found"
43113:     // RFC 2616: "some deployed proxies are known to return 400 or 500 when
43113:     // DNS lookups time out."  (Squid uses 500 if it runs out of sockets: so
43113:     // we have a conflict here).
43113:     case 400: // HTTP/1.1 "Bad Request"
43113:     case 500: // HTTP/1.1: "Internal Server Error"
43113:         /* User sees: "Address Not Found: Firefox can't find the server at
43113:          * www.foo.com."
43113:          */
43113:         rv = NS_ERROR_UNKNOWN_HOST; 
43113:         break;
43113:     case 502: // HTTP/1.1: "Bad Gateway" (invalid resp from target server)
43113:     // Squid returns 503 if target request fails for anything but DNS.
43113:     case 503: // HTTP/1.1: "Service Unavailable"
43113:         /* User sees: "Failed to Connect:
43113:          *  Firefox can't establish a connection to the server at
43113:          *  www.foo.com.  Though the site seems valid, the browser
43113:          *  was unable to establish a connection."
43113:          */
43113:         rv = NS_ERROR_CONNECTION_REFUSED;
43113:         break;
43113:     // RFC 2616 uses 504 for both DNS and target timeout, so not clear what to
43113:     // do here: picking target timeout, as DNS covered by 400/404/500
43113:     case 504: // HTTP/1.1: "Gateway Timeout" 
43113:         // user sees: "Network Timeout: The server at www.foo.com
43113:         //              is taking too long to respond."
43113:         rv = NS_ERROR_NET_TIMEOUT;
43113:         break;
43113:     // Confused proxy server or malicious response
43113:     default:
43113:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
43113:         break;
43113:     }
43113:     LOG(("Cancelling failed SSL proxy connection [this=%p httpStatus=%u]\n",
43113:          this, httpStatus)); 
43113:     Cancel(rv);
43113:     CallOnStartRequest();
43113:     return rv;
43113: }
43113: 
79445: bool
43113: nsHttpChannel::ShouldSSLProxyResponseContinue(PRUint32 httpStatus)
43113: {
43113:     // When SSL connect has failed, allow proxy reply to continue only if it's
81287:     // a 407 (proxy authentication required) response
81287:     return (httpStatus == 407);
43113: }
43113: 
51363: /**
51363:  * Decide whether or not to remember Strict-Transport-Security, and whether
51363:  * or not to enforce channel integrity.
51363:  *
51363:  * @return NS_ERROR_FAILURE if there's security information missing even though
51363:  *             it's an HTTPS connection.
51363:  */
51363: nsresult
51363: nsHttpChannel::ProcessSTSHeader()
51363: {
51363:     nsresult rv;
79445:     bool isHttps = false;
51363:     rv = mURI->SchemeIs("https", &isHttps);
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     // If this channel is not loading securely, STS doesn't do anything.
51363:     // The upgrade to HTTPS takes place earlier in the channel load process.
51363:     if (!isHttps)
51363:         return NS_OK;
51363: 
51363:     nsCAutoString asciiHost;
51363:     rv = mURI->GetAsciiHost(asciiHost);
52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
51363: 
51363:     // If the channel is not a hostname, but rather an IP, STS doesn't do
51363:     // anything.
51363:     PRNetAddr hostAddr;
51363:     if (PR_SUCCESS == PR_StringToNetAddr(asciiHost.get(), &hostAddr))
51363:         return NS_OK;
51363: 
51363:     nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
51363:     NS_ENSURE_TRUE(stss, NS_ERROR_OUT_OF_MEMORY);
51363: 
52258:     // mSecurityInfo may not always be present, and if it's not then it is okay
52258:     // to just disregard any STS headers since we know nothing about the
52258:     // security of the connection.
52258:     NS_ENSURE_TRUE(mSecurityInfo, NS_OK);
52258: 
51363:     // Check the trustworthiness of the channel (are there any cert errors?)
51363:     // If there are certificate errors, we still load the data, we just ignore
51363:     // any STS headers that are present.
79445:     bool tlsIsBroken = false;
51363:     rv = stss->ShouldIgnoreStsHeader(mSecurityInfo, &tlsIsBroken);
52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
51363: 
51363:     // If this was already an STS host, the connection should have been aborted
51363:     // by the bad cert handler in the case of cert errors.  If it didn't abort the connection,
51363:     // there's probably something funny going on.
51363:     // If this wasn't an STS host, errors are allowed, but no more STS processing
51363:     // will happen during the session.
79445:     bool wasAlreadySTSHost;
51363:     rv = stss->IsStsURI(mURI, &wasAlreadySTSHost);
52258:     // Failure here means STS is broken.  Don't prevent the load, but this
52258:     // shouldn't fail.
52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
51363:     NS_ASSERTION(!(wasAlreadySTSHost && tlsIsBroken),
51363:                  "connection should have been aborted by nss-bad-cert-handler");
51363: 
51363:     // Any STS header is ignored if the channel is not trusted due to
51363:     // certificate errors (STS Spec 7.1) -- there is nothing else to do, and
51363:     // the load may progress.
51363:     if (tlsIsBroken) {
51363:         LOG(("STS: Transport layer is not trustworthy, ignoring "
51363:              "STS headers and continuing load\n"));
51363:         return NS_OK;
51363:     }
51363: 
51363:     // If there's a STS header, process it (STS Spec 7.1).  At this point in
51363:     // processing, the channel is trusted, so the header should not be ignored.
51363:     const nsHttpAtom atom = nsHttp::ResolveAtom("Strict-Transport-Security");
51363:     nsCAutoString stsHeader;
51363:     rv = mResponseHead->GetHeader(atom, stsHeader);
51363:     if (rv == NS_ERROR_NOT_AVAILABLE) {
51363:         LOG(("STS: No STS header, continuing load.\n"));
51363:         return NS_OK;
51363:     }
52258:     // All other failures are fatal.
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     rv = stss->ProcessStsHeader(mURI, stsHeader.get());
51363:     if (NS_FAILED(rv)) {
51363:         LOG(("STS: Failed to parse STS header, continuing load.\n"));
51363:         return NS_OK;
51363:     }
51363: 
51363:     return NS_OK;
51363: }
51363: 
43113: nsresult
43113: nsHttpChannel::ProcessResponse()
43113: {
43113:     nsresult rv;
43113:     PRUint32 httpStatus = mResponseHead->Status();
43113: 
43113:     LOG(("nsHttpChannel::ProcessResponse [this=%p httpStatus=%u]\n",
43113:         this, httpStatus));
43113: 
52258:     if (mTransaction->SSLConnectFailed()) {
52258:         if (!ShouldSSLProxyResponseContinue(httpStatus))
43113:             return ProcessFailedSSLConnect(httpStatus);
52258:         // If SSL proxy response needs to complete, wait to process connection
52258:         // for Strict-Transport-Security.
52258:     } else {
52258:         // Given a successful connection, process any STS data that's relevant.
51363:         rv = ProcessSTSHeader();
52258:         NS_ASSERTION(NS_SUCCEEDED(rv), "ProcessSTSHeader failed, continuing load.");
52258:     }
51363: 
43113:     // notify "http-on-examine-response" observers
43113:     gHttpHandler->OnExamineResponse(this);
43113: 
43113:     SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
43113: 
43113:     // handle unused username and password in url (see bug 232567)
43113:     if (httpStatus != 401 && httpStatus != 407) {
43832:         if (!mAuthRetryPending)
43832:             mAuthProvider->CheckForSuperfluousAuth();
43113:         if (mCanceled)
43113:             return CallOnStartRequest();
43113: 
43832:         // reset the authentication's current continuation state because our
43832:         // last authentication attempt has been completed successfully
43832:         mAuthProvider->Disconnect(NS_ERROR_ABORT);
43832:         mAuthProvider = nsnull;
43113:         LOG(("  continuation state has been reset"));
43113:     }
43113: 
78427:     bool successfulReval = false;
78427: 
43113:     // handle different server response categories.  Note that we handle
43113:     // caching or not caching of error pages in
43113:     // nsHttpResponseHead::MustValidate; if you change this switch, update that
43113:     // one
43113:     switch (httpStatus) {
43113:     case 200:
43113:     case 203:
43113:         // Per RFC 2616, 14.35.2, "A server MAY ignore the Range header".
43113:         // So if a server does that and sends 200 instead of 206 that we
43113:         // expect, notify our caller.
43113:         // However, if we wanted to start from the beginning, let it go through
43113:         if (mResuming && mStartPos != 0) {
43113:             LOG(("Server ignored our Range header, cancelling [this=%p]\n", this));
43113:             Cancel(NS_ERROR_NOT_RESUMABLE);
43113:             rv = CallOnStartRequest();
43113:             break;
43113:         }
43113:         // these can normally be cached
43113:         rv = ProcessNormal();
43113:         MaybeInvalidateCacheEntryForSubsequentGet();
43113:         break;
43113:     case 206:
43113:         if (mCachedContentIsPartial) // an internal byte range request...
43113:             rv = ProcessPartialContent();
43113:         else
43113:             rv = ProcessNormal();
43113:         break;
43113:     case 300:
43113:     case 301:
43113:     case 302:
43113:     case 307:
43113:     case 303:
43113: #if 0
43113:     case 305: // disabled as a security measure (see bug 187996).
43113: #endif
43113:         // don't store the response body for redirects
43113:         MaybeInvalidateCacheEntryForSubsequentGet();
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessResponse);
48304:         rv = AsyncProcessRedirection(httpStatus);
48304:         if (NS_FAILED(rv)) {
48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessResponse);
48304:             LOG(("AsyncProcessRedirection failed [rv=%x]\n", rv));
48304:             rv = ContinueProcessResponse(rv);
43113:         }
43113:         break;
43113:     case 304:
43113:         rv = ProcessNotModified();
43113:         if (NS_FAILED(rv)) {
43113:             LOG(("ProcessNotModified failed [rv=%x]\n", rv));
43113:             rv = ProcessNormal();
43113:         }
78427:         else {
78427:             successfulReval = true;
78427:         }
43113:         break;
43113:     case 401:
43113:     case 407:
43832:         rv = mAuthProvider->ProcessAuthentication(
43832:             httpStatus, mConnectionInfo->UsingSSL() &&
43832:                         mTransaction->SSLConnectFailed());
43832:         if (rv == NS_ERROR_IN_PROGRESS)  {
43832:             // authentication prompt has been invoked and result
43832:             // is expected asynchronously
80486:             mAuthRetryPending = true;
43832:             // suspend the transaction pump to stop receiving the
43832:             // unauthenticated content data. We will throw that data
43832:             // away when user provides credentials or resume the pump
43832:             // when user refuses to authenticate.
43832:             LOG(("Suspending the transaction, asynchronously prompting for credentials"));
43832:             mTransactionPump->Suspend();
43832:             rv = NS_OK;
43832:         }
43832:         else if (NS_FAILED(rv)) {
43113:             LOG(("ProcessAuthentication failed [rv=%x]\n", rv));
43113:             if (mTransaction->SSLConnectFailed())
43113:                 return ProcessFailedSSLConnect(httpStatus);
43832:             if (!mAuthRetryPending)
43832:                 mAuthProvider->CheckForSuperfluousAuth();
43113:             rv = ProcessNormal();
43113:         }
43832:         else
80486:             mAuthRetryPending = true; // see DoAuthRetry
43113:         break;
43113:     default:
43113:         rv = ProcessNormal();
43113:         MaybeInvalidateCacheEntryForSubsequentGet();
43113:         break;
43113:     }
43113: 
79877:     int cacheDisposition;
78427:     if (!mDidReval)
79877:         cacheDisposition = kCacheMissed;
79877:     else if (successfulReval)
79877:         cacheDisposition = kCacheHitViaReval;
79877:     else
79877:         cacheDisposition = kCacheMissedViaReval;
79877: 
79877:     mozilla::Telemetry::Accumulate(mozilla::Telemetry::HTTP_CACHE_DISPOSITION,
79877:             cacheDisposition);
79877:     if (mCacheEntry) {
79877:         char* cacheDeviceID = nsnull;
79877:         mCacheEntry->GetDeviceID(&cacheDeviceID);
79877:         if (cacheDeviceID) {
79877:             if (!strcmp(cacheDeviceID, kDiskDeviceID))
78427:                 mozilla::Telemetry::Accumulate(
79877:                         mozilla::Telemetry::HTTP_DISK_CACHE_DISPOSITION,
79877:                         cacheDisposition);
79877:             else if (!strcmp(cacheDeviceID, kMemoryDeviceID))
78427:                 mozilla::Telemetry::Accumulate(
79877:                         mozilla::Telemetry::HTTP_MEMORY_CACHE_DISPOSITION,
79877:                         cacheDisposition);
79877:             else if (!strcmp(cacheDeviceID, kOfflineDeviceID))
78427:                 mozilla::Telemetry::Accumulate(
79877:                         mozilla::Telemetry::HTTP_OFFLINE_CACHE_DISPOSITION,
79877:                         cacheDisposition);
79877:         }
79877:     }
78427: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
48304: nsHttpChannel::ContinueProcessResponse(nsresult rv)
48304: {
78633:     if (rv == NS_ERROR_DOM_BAD_URI && mRedirectURI) {
78633: 
79445:         bool isHTTP = false;
78633:         if (NS_FAILED(mRedirectURI->SchemeIs("http", &isHTTP)))
80486:             isHTTP = false;
78633:         if (!isHTTP && NS_FAILED(mRedirectURI->SchemeIs("https", &isHTTP)))
80486:             isHTTP = false;
78633:         
78633:         if (!isHTTP) {
78633:             // This was a blocked attempt to redirect and subvert the system by
78633:             // redirecting to another protocol (perhaps javascript:)
78633:             // In that case we want to throw an error instead of displaying the
78633:             // non-redirected response body.
78633: 
78633:             LOG(("ContinueProcessResponse detected rejected Non-HTTP Redirection"));
78633:             return NS_ERROR_CORRUPTED_CONTENT;
78633:         }
78633:     }
78633: 
48304:     if (NS_SUCCEEDED(rv)) {
48304:         InitCacheEntry();
80486:         CloseCacheEntry(false);
48304: 
48304:         if (mCacheForOfflineUse) {
48304:             // Store response in the offline cache
48304:             InitOfflineCacheEntry();
48304:             CloseOfflineCacheEntry();
48304:         }
48304:         return NS_OK;
48304:     }
48304: 
48304:     LOG(("ContinueProcessResponse got failure result [rv=%x]\n", rv));
48304:     if (mTransaction->SSLConnectFailed()) {
48304:         return ProcessFailedSSLConnect(mRedirectType);
48304:     }
48304:     return ProcessNormal();
48304: }
48304: 
48304: nsresult
43113: nsHttpChannel::ProcessNormal()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::ProcessNormal [this=%p]\n", this));
43113: 
79445:     bool succeeded;
43113:     rv = GetRequestSucceeded(&succeeded);
43113:     if (NS_SUCCEEDED(rv) && !succeeded) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessNormal);
79445:         bool waitingForRedirectCallback;
63793:         (void)ProcessFallback(&waitingForRedirectCallback);
48304:         if (waitingForRedirectCallback) {
48304:             // The transaction has been suspended by ProcessFallback.
48304:             return NS_OK;
48304:         }
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessNormal);
48304:     }
48304: 
48304:     return ContinueProcessNormal(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessNormal(nsresult rv)
48304: {
43113:     if (NS_FAILED(rv)) {
48304:         // Fill the failure status here, we have failed to fall back, thus we
48304:         // have to report our status as failed.
48304:         mStatus = rv;
43113:         DoNotifyListener();
43113:         return rv;
43113:     }
43113: 
48304:     if (mFallingBack) {
43113:         // Do not continue with normal processing, fallback is in
43113:         // progress now.
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if we're here, then any byte-range requests failed to result in a partial
43113:     // response.  we must clear this flag to prevent BufferPartialContent from
43113:     // being called inside our OnDataAvailable (see bug 136678).
80486:     mCachedContentIsPartial = false;
43113: 
43113:     ClearBogusContentEncodingIfNeeded();
43113: 
43113:     // this must be called before firing OnStartRequest, since http clients,
43113:     // such as imagelib, expect our cache entry to already have the correct
43113:     // expiration time (bug 87710).
43113:     if (mCacheEntry) {
43113:         rv = InitCacheEntry();
43113:         if (NS_FAILED(rv))
80486:             CloseCacheEntry(true);
43113:     }
43113: 
43113:     // Check that the server sent us what we were asking for
43113:     if (mResuming) {
43113:         // Create an entity id from the response
43113:         nsCAutoString id;
43113:         rv = GetEntityID(id);
43113:         if (NS_FAILED(rv)) {
43113:             // If creating an entity id is not possible -> error
43113:             Cancel(NS_ERROR_NOT_RESUMABLE);
43113:         }
43113:         else if (mResponseHead->Status() != 206 &&
43113:                  mResponseHead->Status() != 200) {
43113:             // Probably 404 Not Found, 412 Precondition Failed or
43113:             // 416 Invalid Range -> error
43113:             LOG(("Unexpected response status while resuming, aborting [this=%p]\n",
43113:                  this));
43113:             Cancel(NS_ERROR_ENTITY_CHANGED);
43113:         }
43113:         // If we were passed an entity id, verify it's equal to the server's
43113:         else if (!mEntityID.IsEmpty()) {
43113:             if (!mEntityID.Equals(id)) {
43113:                 LOG(("Entity mismatch, expected '%s', got '%s', aborting [this=%p]",
43113:                      mEntityID.get(), id.get(), this));
43113:                 Cancel(NS_ERROR_ENTITY_CHANGED);
43113:             }
43113:         }
43113:     }
43113: 
43113:     rv = CallOnStartRequest();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // install cache listener if we still have a cache entry open
43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
43113:         rv = InstallCacheListener();
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::PromptTempRedirect()
43113: {
43113:     if (!gHttpHandler->PromptTempRedirect()) {
43113:         return NS_OK;
43113:     }
43113:     nsresult rv;
43113:     nsCOMPtr<nsIStringBundleService> bundleService =
43113:             do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsCOMPtr<nsIStringBundle> stringBundle;
43113:     rv = bundleService->CreateBundle(NECKO_MSGS_URL, getter_AddRefs(stringBundle));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsXPIDLString messageString;
43113:     rv = stringBundle->GetStringFromName(NS_LITERAL_STRING("RepostFormData").get(), getter_Copies(messageString));
43113:     // GetStringFromName can return NS_OK and NULL messageString.
43113:     if (NS_SUCCEEDED(rv) && messageString) {
79445:         bool repost = false;
43113: 
43113:         nsCOMPtr<nsIPrompt> prompt;
43113:         GetCallback(prompt);
43113:         if (!prompt)
43113:             return NS_ERROR_NO_INTERFACE;
43113: 
43113:         prompt->Confirm(nsnull, messageString, &repost);
43113:         if (!repost)
43113:             return NS_ERROR_FAILURE;
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ProxyFailover()
43113: {
43113:     LOG(("nsHttpChannel::ProxyFailover [this=%p]\n", this));
43113: 
43113:     nsresult rv;
43113: 
43113:     nsCOMPtr<nsIProtocolProxyService> pps =
43113:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     nsCOMPtr<nsIProxyInfo> pi;
43113:     rv = pps->GetFailoverForProxy(mConnectionInfo->ProxyInfo(), mURI, mStatus,
43113:                                   getter_AddRefs(pi));
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     // XXXbz so where does this codepath remove us from the loadgroup,
43113:     // exactly?
48304:     return AsyncDoReplaceWithProxy(pi);
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncReplaceWithProxy()
43113: {
71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
43113: 
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async proxy replacement [this=%p]\n",
43113:              this));
71646:         mCallOnResume = &nsHttpChannel::HandleAsyncReplaceWithProxy;
43113:         return;
43113:     }
43113: 
43113:     nsresult status = mStatus;
43113:     
43113:     nsCOMPtr<nsIProxyInfo> pi;
43113:     pi.swap(mTargetProxyInfo);
43113:     if (!mCanceled) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncReplaceWithProxy);
48304:         status = AsyncDoReplaceWithProxy(pi);
48304:         if (NS_SUCCEEDED(status))
48304:             return;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncReplaceWithProxy);
48304:     }
48304: 
48304:     if (NS_FAILED(status)) {
48304:         ContinueHandleAsyncReplaceWithProxy(status);
48304:     }
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueHandleAsyncReplaceWithProxy(nsresult status)
48304: {
43113:     if (mLoadGroup && NS_SUCCEEDED(status)) {
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
43113:     }
48304:     else if (NS_FAILED(status)) {
43113:         AsyncAbort(status);
43113:     }
48304: 
48304:     // Return NS_OK here, even it seems to be breaking the async function stack
48304:     // contract (i.e. passing the result code to a function bellow).
48304:     // ContinueHandleAsyncReplaceWithProxy will always be at the bottom of the
48304:     // stack. If we would return the failure code, the async function stack
48304:     // logic would cancel the channel synchronously, which is undesired after
48304:     // invoking AsyncAbort above.
48304:     return NS_OK;
43113: }
43113: 
51363: void
51363: nsHttpChannel::HandleAsyncRedirectChannelToHttps()
51363: {
71646:     NS_PRECONDITION(!mCallOnResume, "How did that happen?");
51363: 
51363:     if (mSuspendCount) {
51363:         LOG(("Waiting until resume to do async redirect to https [this=%p]\n", this));
71646:         mCallOnResume = &nsHttpChannel::HandleAsyncRedirectChannelToHttps;
51363:         return;
51363:     }
51363: 
51363:     nsresult rv = AsyncRedirectChannelToHttps();
51363:     if (NS_FAILED(rv))
51363:         ContinueAsyncRedirectChannelToHttps(rv);
51363: }
51363: 
51363: nsresult
51363: nsHttpChannel::AsyncRedirectChannelToHttps()
51363: {
51363:     nsresult rv = NS_OK;
51363:     LOG(("nsHttpChannel::HandleAsyncRedirectChannelToHttps() [STS]\n"));
51363: 
51363:     nsCOMPtr<nsIChannel> newChannel;
51363:     nsCOMPtr<nsIURI> upgradedURI;
51363: 
51363:     rv = mURI->Clone(getter_AddRefs(upgradedURI));
51363:     NS_ENSURE_SUCCESS(rv,rv);
51363: 
51363:     upgradedURI->SetScheme(NS_LITERAL_CSTRING("https"));
51363: 
51363:     PRInt32 oldPort = -1;
51363:     rv = mURI->GetPort(&oldPort);
51363:     if (NS_FAILED(rv)) return rv;
51363: 
51363:     // Keep any nonstandard ports so only the scheme is changed.
51363:     // For example:
51363:     //  http://foo.com:80 -> https://foo.com:443
51363:     //  http://foo.com:81 -> https://foo.com:81
51363: 
51363:     if (oldPort == 80 || oldPort == -1)
51363:         upgradedURI->SetPort(-1);
51363:     else
51363:         upgradedURI->SetPort(oldPort);
51363: 
51363:     nsCOMPtr<nsIIOService> ioService;
51363:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     rv = ioService->NewChannelFromURI(upgradedURI, getter_AddRefs(newChannel));
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
80486:     rv = SetupReplacementChannel(upgradedURI, newChannel, true);
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     // Inform consumers about this fake redirect
51363:     mRedirectChannel = newChannel;
51363:     PRUint32 flags = nsIChannelEventSink::REDIRECT_PERMANENT;
51363: 
51363:     PushRedirectAsyncFunc(
51363:         &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
51363:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
51363: 
51363:     if (NS_SUCCEEDED(rv))
51363:         rv = WaitForRedirectCallback();
51363: 
51363:     if (NS_FAILED(rv)) {
51363:         AutoRedirectVetoNotifier notifier(this);
51363:         PopRedirectAsyncFunc(
51363:             &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
51363:     }
51363: 
51363:     return rv;
51363: }
51363: 
51363: nsresult
51363: nsHttpChannel::ContinueAsyncRedirectChannelToHttps(nsresult rv)
51363: {
51363:     AutoRedirectVetoNotifier notifier(this);
51363: 
51363:     if (NS_FAILED(rv)) {
51363:         // Fill the failure status here, the update to https had been vetoed
51363:         // but from the security reasons we have to discard the whole channel
51363:         // load.
51363:         mStatus = rv;
51363:     }
51363: 
51363:     if (mLoadGroup)
51363:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
51363: 
51363:     if (NS_FAILED(rv)) {
51363:         // We have to manually notify the listener because there is not any pump
51363:         // that would call our OnStart/StopRequest after resume from waiting for
51363:         // the redirect callback.
51363:         DoNotifyListener();
51363:         return rv;
51363:     }
51363: 
51363:     // Make sure to do this _after_ calling OnChannelRedirect
51363:     mRedirectChannel->SetOriginalURI(mOriginalURI);
51363: 
51363:     // And now, notify observers the deprecated way
51363:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
51363:     GetCallback(httpEventSink);
51363:     if (httpEventSink) {
51363:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
51363:         // versions.
51363:         rv = httpEventSink->OnRedirect(this, mRedirectChannel);
51363:         if (NS_FAILED(rv)) {
51363:             mStatus = rv;
51363:             DoNotifyListener();
51363:             return rv;
51363:         }
51363:     }
51363: 
51363:     // open new channel
51363:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
51363:     if (NS_FAILED(rv)) {
51363:         mStatus = rv;
51363:         DoNotifyListener();
51363:         return rv;
51363:     }
51363: 
51363:     mStatus = NS_BINDING_REDIRECTED;
51363: 
51363:     notifier.RedirectSucceeded();
51363: 
51363:     // disconnect from the old listeners...
51363:     mListener = nsnull;
51363:     mListenerContext = nsnull;
51363: 
51363:     // ...and the old callbacks
51363:     mCallbacks = nsnull;
51363:     mProgressSink = nsnull;
51363: 
51363:     return rv;
51363: }
51363: 
43113: nsresult
48304: nsHttpChannel::AsyncDoReplaceWithProxy(nsIProxyInfo* pi)
43113: {
48304:     LOG(("nsHttpChannel::AsyncDoReplaceWithProxy [this=%p pi=%p]", this, pi));
43113:     nsresult rv;
43113: 
43113:     nsCOMPtr<nsIChannel> newChannel;
43113:     rv = gHttpHandler->NewProxiedChannel(mURI, pi, getter_AddRefs(newChannel));
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
80486:     rv = SetupReplacementChannel(mURI, newChannel, true);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     // Inform consumers about this fake redirect
48304:     mRedirectChannel = newChannel;
43113:     PRUint32 flags = nsIChannelEventSink::REDIRECT_INTERNAL;
48304: 
48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueDoReplaceWithProxy);
48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
48304: 
48304:     if (NS_SUCCEEDED(rv))
48304:         rv = WaitForRedirectCallback();
48304: 
48304:     if (NS_FAILED(rv)) {
49375:         AutoRedirectVetoNotifier notifier(this);
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueDoReplaceWithProxy);
48304:     }
48304: 
48304:     return rv;
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueDoReplaceWithProxy(nsresult rv)
48304: {
49375:     AutoRedirectVetoNotifier notifier(this);
49375: 
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
48304: 
43113:     // Make sure to do this _after_ calling OnChannelRedirect
48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
43113: 
43113:     // open new channel
48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     mStatus = NS_BINDING_REDIRECTED;
43113: 
49375:     notifier.RedirectSucceeded();
49375: 
43113:     // disconnect from the old listeners...
43113:     mListener = nsnull;
43113:     mListenerContext = nsnull;
43113: 
43113:     // ...and the old callbacks
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ResolveProxy()
43113: {
43113:     LOG(("nsHttpChannel::ResolveProxy [this=%p]\n", this));
43113: 
43113:     nsresult rv;
43113: 
43113:     nsCOMPtr<nsIProtocolProxyService> pps =
43113:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
69816:     PRUint32 resolveFlags = 0;
69816:     if (mConnectionInfo->ProxyInfo())
69816:         mConnectionInfo->ProxyInfo()->GetResolveFlags(&resolveFlags);
69816: 
69816:     return pps->AsyncResolve(mURI, resolveFlags, this, getter_AddRefs(mProxyRequest));
43113: }
43113: 
79445: bool
43113: nsHttpChannel::ResponseWouldVary()
43113: {
58260:     nsresult rv;
43113:     nsCAutoString buf, metaKey;
43113:     mCachedResponseHead->GetHeader(nsHttp::Vary, buf);
43113:     if (!buf.IsEmpty()) {
43113:         NS_NAMED_LITERAL_CSTRING(prefix, "request-");
43113: 
43113:         // enumerate the elements of the Vary header...
43113:         char *val = buf.BeginWriting(); // going to munge buf
43113:         char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:         while (token) {
58260:             LOG(("nsHttpChannel::ResponseWouldVary [this=%x] " \
58260:                  "processing %s\n",
58260:                  this, token));
43113:             //
43113:             // if "*", then assume response would vary.  technically speaking,
43113:             // "Vary: header, *" is not permitted, but we allow it anyways.
43113:             //
58260:             // We hash values of cookie-headers for the following reasons:
43113:             //
43113:             //   1- cookies can be very large in size
43113:             //
43113:             //   2- cookies may contain sensitive information.  (for parity with
43113:             //      out policy of not storing Set-cookie headers in the cache
43113:             //      meta data, we likewise do not want to store cookie headers
43113:             //      here.)
43113:             //
58260:             if (*token == '*')
80486:                 return true; // if we encounter this, just get out of here
58260: 
43113:             // build cache meta data key...
43113:             metaKey = prefix + nsDependentCString(token);
43113: 
43113:             // check the last value of the given request header to see if it has
43113:             // since changed.  if so, then indeed the cached response is invalid.
43113:             nsXPIDLCString lastVal;
43113:             mCacheEntry->GetMetaDataElement(metaKey.get(), getter_Copies(lastVal));
58260:             LOG(("nsHttpChannel::ResponseWouldVary [this=%x] " \
58260:                     "stored value = %c%s%c\n", this, '"', lastVal.get(), '"'));
58260: 
58260:             // Look for value of "Cookie" in the request headers
43113:             nsHttpAtom atom = nsHttp::ResolveAtom(token);
43113:             const char *newVal = mRequestHead.PeekHeader(atom);
58260:             if (!lastVal.IsEmpty()) {
58260:                 // value for this header in cache, but no value in request
58260:                 if (!newVal)
80486:                     return true; // yes - response would vary
58260: 
58260:                 // If this is a cookie-header, stored metadata is not
58260:                 // the value itself but the hash. So we also hash the
58260:                 // outgoing value here in order to compare the hashes
58260:                 nsCAutoString hash;
58260:                 if (atom == nsHttp::Cookie) {
58260:                     rv = Hash(newVal, hash);
58260:                     // If hash failed, be conservative (the cached hash
58260:                     // exists at this point) and claim response would vary
58260:                     if (NS_FAILED(rv))
80486:                         return true;
58260:                     newVal = hash.get();
58260: 
58260:                     LOG(("nsHttpChannel::ResponseWouldVary [this=%x] " \
58260:                             "set-cookie value hashed to %s\n",
58260:                          this, newVal));
58260:                 }
58260: 
58260:                 if (strcmp(newVal, lastVal))
80486:                     return true; // yes, response would vary
58260: 
58260:             } else if (newVal) { // old value is empty, but newVal is set
80486:                 return true;
43113:             }
43113: 
43113:             // next token...
43113:             token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:         }
43113:     }
80486:     return false;
58260: }
58260: 
71646: // We need to have an implementation of this function just so that we can keep
71646: // all references to mCallOnResume of type nsHttpChannel:  it's not OK in C++
71646: // to set a member function ptr to  a base class function.
71646: void
71646: nsHttpChannel::HandleAsyncAbort()
71646: {
71646:     HttpAsyncAborter<nsHttpChannel>::HandleAsyncAbort();
71646: }
71646: 
71646: 
58260: nsresult
58260: nsHttpChannel::Hash(const char *buf, nsACString &hash)
58260: {
58260:     nsresult rv;
58260:     if (!mHasher) {
58260:         mHasher = do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
58260:         if (NS_FAILED(rv)) {
58260:             LOG(("nsHttpChannel: Failed to instantiate crypto-hasher"));
58260:             return rv;
58260:         }
58260:     }
58260: 
58260:     rv = mHasher->Init(nsICryptoHash::SHA1);
58260:     NS_ENSURE_SUCCESS(rv, rv);
58260: 
58260:    rv = mHasher->Update(reinterpret_cast<unsigned const char*>(buf),
58260:                          strlen(buf));
58260:     NS_ENSURE_SUCCESS(rv, rv);
58260: 
80486:     rv = mHasher->Finish(true, hash);
58260:     NS_ENSURE_SUCCESS(rv, rv);
58260: 
58260:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <byte-range>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::SetupByteRangeRequest(PRUint32 partialLen)
43113: {
43113:     // cached content has been found to be partial, add necessary request
43113:     // headers to complete cache entry.
43113: 
43113:     // use strongest validator available...
43113:     const char *val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
43113:     if (!val)
43113:         val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
43113:     if (!val) {
43113:         // if we hit this code it means mCachedResponseHead->IsResumable() is
43113:         // either broken or not being called.
43113:         NS_NOTREACHED("no cache validator");
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: 
43113:     char buf[32];
43113:     PR_snprintf(buf, sizeof(buf), "bytes=%u-", partialLen);
43113: 
43113:     mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(buf));
43113:     mRequestHead.SetHeader(nsHttp::If_Range, nsDependentCString(val));
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ProcessPartialContent()
43113: {
43113:     // ok, we've just received a 206
43113:     //
43113:     // we need to stream whatever data is in the cache out first, and then
43113:     // pick up whatever data is on the wire, writing it into the cache.
43113: 
43113:     LOG(("nsHttpChannel::ProcessPartialContent [this=%p]\n", this)); 
43113: 
43113:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
43113: 
43113:     // Make sure to clear bogus content-encodings before looking at the header
43113:     ClearBogusContentEncodingIfNeeded();
43113:     
43113:     // Check if the content-encoding we now got is different from the one we
43113:     // got before
43113:     if (PL_strcasecmp(mResponseHead->PeekHeader(nsHttp::Content_Encoding),
43113:                       mCachedResponseHead->PeekHeader(nsHttp::Content_Encoding))
43113:                       != 0) {
43113:         Cancel(NS_ERROR_INVALID_CONTENT_ENCODING);
43113:         return CallOnStartRequest();
43113:     }
43113: 
43113: 
43113:     // suspend the current transaction
43113:     nsresult rv = mTransactionPump->Suspend();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // merge any new headers with the cached response headers
43113:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // update the cached response head
43113:     nsCAutoString head;
80486:     mCachedResponseHead->Flatten(head, true);
43113:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // make the cached response be the current response
43113:     mResponseHead = mCachedResponseHead;
43113: 
43113:     rv = UpdateExpirationTime();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // notify observers interested in looking at a response that has been
43113:     // merged with any cached headers (http-on-examine-merged-response).
43113:     gHttpHandler->OnExamineMergedResponse(this);
43113: 
43113:     // the cached content is valid, although incomplete.
80486:     mCachedContentIsValid = true;
43113:     return ReadFromCache();
43113: }
43113: 
43113: nsresult
79445: nsHttpChannel::OnDoneReadingPartialCacheEntry(bool *streamDone)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::OnDoneReadingPartialCacheEntry [this=%p]", this));
43113: 
43113:     // by default, assume we would have streamed all data or failed...
80486:     *streamDone = true;
43113: 
43113:     // setup cache listener to append to cache entry
43113:     PRUint32 size;
43113:     rv = mCacheEntry->GetDataSize(&size);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = InstallCacheListener(size);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // need to track the logical offset of the data being sent to our listener
43113:     mLogicalOffset = size;
43113: 
43113:     // we're now completing the cached content, so we can clear this flag.
43113:     // this puts us in the state of a regular download.
80486:     mCachedContentIsPartial = false;
43113: 
43113:     // resume the transaction if it exists, otherwise the pipe contained the
43113:     // remaining part of the document and we've now streamed all of the data.
43113:     if (mTransactionPump) {
43113:         rv = mTransactionPump->Resume();
43113:         if (NS_SUCCEEDED(rv))
80486:             *streamDone = false;
43113:     }
43113:     else
43113:         NS_NOTREACHED("no transaction");
43113:     return rv;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <cache>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::ProcessNotModified()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::ProcessNotModified [this=%p]\n", this)); 
43113: 
43113:     if (mCustomConditionalRequest) {
43113:         LOG(("Bypassing ProcessNotModified due to custom conditional headers")); 
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: 
43113:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
43113: 
43113:     // merge any new headers with the cached response headers
43113:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // update the cached response head
43113:     nsCAutoString head;
80486:     mCachedResponseHead->Flatten(head, true);
43113:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // make the cached response be the current response
43113:     mResponseHead = mCachedResponseHead;
43113: 
43113:     rv = UpdateExpirationTime();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
82085:     rv = AddCacheEntryHeaders(mCacheEntry);
82085:     if (NS_FAILED(rv)) return rv;
82085: 
43113:     // notify observers interested in looking at a reponse that has been
43113:     // merged with any cached headers
43113:     gHttpHandler->OnExamineMergedResponse(this);
43113: 
80486:     mCachedContentIsValid = true;
43113:     rv = ReadFromCache();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
80486:     mTransactionReplaced = true;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
79445: nsHttpChannel::ProcessFallback(bool *waitingForRedirectCallback)
43113: {
43113:     LOG(("nsHttpChannel::ProcessFallback [this=%p]\n", this));
43113:     nsresult rv;
43113: 
80486:     *waitingForRedirectCallback = false;
80486:     mFallingBack = false;
43113: 
43113:     // At this point a load has failed (either due to network problems
43113:     // or an error returned on the server).  Perform an application
43113:     // cache fallback if we have a URI to fall back to.
43113:     if (!mApplicationCache || mFallbackKey.IsEmpty() || mFallbackChannel) {
43113:         LOG(("  choosing not to fallback [%p,%s,%d]",
43113:              mApplicationCache.get(), mFallbackKey.get(), mFallbackChannel));
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Make sure the fallback entry hasn't been marked as a foreign
43113:     // entry.
43113:     PRUint32 fallbackEntryType;
43113:     rv = mApplicationCache->GetTypes(mFallbackKey, &fallbackEntryType);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     if (fallbackEntryType & nsIApplicationCache::ITEM_FOREIGN) {
43113:         // This cache points to a fallback that refers to a different
43113:         // manifest.  Refuse to fall back.
43113:         return NS_OK;
43113:     }
43113: 
43113:     NS_ASSERTION(fallbackEntryType & nsIApplicationCache::ITEM_FALLBACK,
43113:                  "Fallback entry not marked correctly!");
43113: 
43113:     // Kill any opportunistic cache entry, and disable opportunistic
43113:     // caching for the fallback.
43113:     if (mOfflineCacheEntry) {
43113:         mOfflineCacheEntry->Doom();
43113:         mOfflineCacheEntry = 0;
43113:         mOfflineCacheAccess = 0;
43113:     }
43113: 
80486:     mCacheForOfflineUse = false;
80486:     mCachingOpportunistically = false;
43113:     mOfflineCacheClientID.Truncate();
43113:     mOfflineCacheEntry = 0;
43113:     mOfflineCacheAccess = 0;
43113: 
43113:     // Close the current cache entry.
43113:     if (mCacheEntry)
80486:         CloseCacheEntry(true);
43113: 
43113:     // Create a new channel to load the fallback entry.
43113:     nsRefPtr<nsIChannel> newChannel;
43113:     rv = gHttpHandler->NewChannel(mURI, getter_AddRefs(newChannel));
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
80486:     rv = SetupReplacementChannel(mURI, newChannel, true);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // Make sure the new channel loads from the fallback key.
43113:     nsCOMPtr<nsIHttpChannelInternal> httpInternal =
43113:         do_QueryInterface(newChannel, &rv);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     rv = httpInternal->SetupFallbackChannel(mFallbackKey.get());
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // ... and fallbacks should only load from the cache.
43113:     PRUint32 newLoadFlags = mLoadFlags | LOAD_REPLACE | LOAD_ONLY_FROM_CACHE;
43113:     rv = newChannel->SetLoadFlags(newLoadFlags);
43113: 
43113:     // Inform consumers about this fake redirect
48304:     mRedirectChannel = newChannel;
43113:     PRUint32 redirectFlags = nsIChannelEventSink::REDIRECT_INTERNAL;
48304: 
48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
48304: 
48304:     if (NS_SUCCEEDED(rv))
48304:         rv = WaitForRedirectCallback();
48304: 
48304:     if (NS_FAILED(rv)) {
49375:         AutoRedirectVetoNotifier notifier(this);
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
48304:         return rv;
48304:     }
48304: 
48304:     // Indicate we are now waiting for the asynchronous redirect callback
48304:     // if all went OK.
80486:     *waitingForRedirectCallback = true;
48304:     return NS_OK;
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessFallback(nsresult rv)
48304: {
49375:     AutoRedirectVetoNotifier notifier(this);
49375: 
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
48304: 
43113:     // Make sure to do this _after_ calling OnChannelRedirect
48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
48304: 
48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
49375:     if (NS_FAILED(rv))
49375:         return rv;
43113: 
43113:     // close down this channel
43113:     Cancel(NS_BINDING_REDIRECTED);
43113: 
49375:     notifier.RedirectSucceeded();
49375: 
43113:     // disconnect from our listener
43113:     mListener = 0;
43113:     mListenerContext = 0;
49375: 
43113:     // and from our callbacks
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113: 
80486:     mFallingBack = true;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // Determines if a request is a byte range request for a subrange,
43113: // i.e. is a byte range request, but not a 0- byte range request.
79445: static bool
43113: IsSubRangeRequest(nsHttpRequestHead &aRequestHead)
43113: {
43113:     if (!aRequestHead.PeekHeader(nsHttp::Range))
80486:         return false;
43113:     nsCAutoString byteRange;
43113:     aRequestHead.GetHeader(nsHttp::Range, byteRange);
43113:     return !byteRange.EqualsLiteral("bytes=0-");
43113: }
43113: 
43113: nsresult
53987: nsHttpChannel::OpenCacheEntry()
43113: {
43113:     nsresult rv;
43113: 
80486:     mAsyncCacheOpen = false;
80486:     mLoadedFromApplicationCache = false;
43113: 
43113:     LOG(("nsHttpChannel::OpenCacheEntry [this=%p]", this));
43113: 
43113:     // make sure we're not abusing this function
43113:     NS_PRECONDITION(!mCacheEntry, "cache entry already open");
43113: 
43113:     nsCAutoString cacheKey;
43113: 
43113:     if (mRequestHead.Method() == nsHttp::Post) {
43113:         // If the post id is already set then this is an attempt to replay
43113:         // a post transaction via the cache.  Otherwise, we need a unique
43113:         // post id for this transaction.
43113:         if (mPostID == 0)
43113:             mPostID = gHttpHandler->GenerateUniqueID();
43113:     }
43113:     else if ((mRequestHead.Method() != nsHttp::Get) &&
54823:              (mRequestHead.Method() != nsHttp::Head)) {
43113:         // don't use the cache for other types of requests
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (mResuming) {
43113:         // We don't support caching for requests initiated
43113:         // via nsIResumableChannel.
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Don't cache byte range requests which are subranges, only cache 0-
43113:     // byte range requests.
43113:     if (IsSubRangeRequest(mRequestHead))
43113:         return NS_OK;
43113: 
43113:     GenerateCacheKey(mPostID, cacheKey);
43113: 
43113:     // Set the desired cache access mode accordingly...
43113:     nsCacheAccessMode accessRequested;
53987:     rv = DetermineCacheAccess(&accessRequested);
53987:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     if (!mApplicationCache && mInheritApplicationCache) {
43113:         // Pick up an application cache from the notification
43113:         // callbacks if available
43113:         nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
43113:         GetCallback(appCacheContainer);
43113: 
43113:         if (appCacheContainer) {
43113:             appCacheContainer->GetApplicationCache(getter_AddRefs(mApplicationCache));
43113:         }
43113:     }
43113: 
43113:     if (!mApplicationCache &&
43113:         (mChooseApplicationCache || (mLoadFlags & LOAD_CHECK_OFFLINE_CACHE))) {
43113:         // We're supposed to load from an application cache, but
43113:         // one was not supplied by the load group.  Ask the
43113:         // application cache service to choose one for us.
43113:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
43113:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
43113:         if (appCacheService) {
43113:             nsresult rv = appCacheService->ChooseApplicationCache
43113:                 (cacheKey, getter_AddRefs(mApplicationCache));
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113:         }
43113:     }
43113: 
43113:     nsCOMPtr<nsICacheSession> session;
43113: 
43113:     // If we have an application cache, we check it first.
43113:     if (mApplicationCache) {
43113:         nsCAutoString appCacheClientID;
43113:         mApplicationCache->GetClientID(appCacheClientID);
43113: 
43113:         nsCOMPtr<nsICacheService> serv =
43113:             do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         rv = serv->CreateSession(appCacheClientID.get(),
43113:                                  nsICache::STORE_OFFLINE,
43113:                                  nsICache::STREAM_BASED,
43113:                                  getter_AddRefs(session));
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
53987:         if (mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY) {
53987:             // must use synchronous open for LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
53987:             rv = session->OpenCacheEntry(cacheKey,
80486:                                          nsICache::ACCESS_READ, false,
53987:                                          getter_AddRefs(mCacheEntry));
53987:             if (NS_SUCCEEDED(rv)) {
53987:                 mCacheEntry->GetAccessGranted(&mCacheAccess);
53987:                 LOG(("nsHttpChannel::OpenCacheEntry [this=%p grantedAccess=%d]",
53987:                     this, mCacheAccess));
80486:                 mLoadedFromApplicationCache = true;
53987:                 return NS_OK;
53987:             } else if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
53987:                 LOG(("bypassing local cache since it is busy\n"));
53987:                 // Don't try to load normal cache entry
53987:                 return NS_ERROR_NOT_AVAILABLE;
53987:             }
53987:         } else {
53987:             mOnCacheEntryAvailableCallback =
53987:                 &nsHttpChannel::OnOfflineCacheEntryAvailable;
43113:             // We open with ACCESS_READ only, because we don't want to
43113:             // overwrite the offline cache entry non-atomically.
43113:             // ACCESS_READ will prevent us from writing to the offline
43113:             // cache as a normal cache entry.
53987:             rv = session->AsyncOpenCacheEntry(cacheKey,
53987:                                               nsICache::ACCESS_READ,
53987:                                               this);
53987: 
53987:             if (NS_SUCCEEDED(rv)) {
80486:                 mAsyncCacheOpen = true;
53987:                 return NS_OK;
53987:             }
53987:         }
53987: 
53987:         // sync or async opening failed
53987:         return OnOfflineCacheEntryAvailable(nsnull, nsICache::ACCESS_NONE,
80486:                                             rv, true);
80486:     }
80486: 
80486:     return OpenNormalCacheEntry(true);
53987: }
53987: 
53987: nsresult
53987: nsHttpChannel::OnOfflineCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
53987:                                             nsCacheAccessMode aAccess,
53987:                                             nsresult aEntryStatus,
79445:                                             bool aIsSync)
53987: {
53987:     nsresult rv;
53987: 
53987:     if (NS_SUCCEEDED(aEntryStatus)) {
53987:         // We successfully opened an offline cache session and the entry,
53987:         // so indicate we will load from the offline cache.
80486:         mLoadedFromApplicationCache = true;
53987:         mCacheEntry = aEntry;
53987:         mCacheAccess = aAccess;
53987:     }
53987: 
53987:     if (mCanceled && NS_FAILED(mStatus)) {
53987:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
53987:         return mStatus;
53987:     }
53987: 
53987:     if (NS_SUCCEEDED(aEntryStatus))
53987:         // Called from OnCacheEntryAvailable, advance to the next state
80486:         return Connect(false);
53987: 
53987:     if (!mCacheForOfflineUse && !mFallbackChannel) {
53987:         nsCAutoString cacheKey;
53987:         GenerateCacheKey(mPostID, cacheKey);
53987: 
43113:         // Check for namespace match.
43113:         nsCOMPtr<nsIApplicationCacheNamespace> namespaceEntry;
43113:         rv = mApplicationCache->GetMatchingNamespace
43113:             (cacheKey, getter_AddRefs(namespaceEntry));
53987:         if (NS_FAILED(rv) && !aIsSync)
80486:             return Connect(false);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         PRUint32 namespaceType = 0;
43113:         if (!namespaceEntry ||
43113:             NS_FAILED(namespaceEntry->GetItemType(&namespaceType)) ||
43113:             (namespaceType &
43113:              (nsIApplicationCacheNamespace::NAMESPACE_FALLBACK |
43113:               nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC |
43113:               nsIApplicationCacheNamespace::NAMESPACE_BYPASS)) == 0) {
43113:             // When loading from an application cache, only items
43113:             // on the whitelist or matching a
43113:             // fallback/opportunistic namespace should hit the
43113:             // network...
43113:             mLoadFlags |= LOAD_ONLY_FROM_CACHE;
43113: 
43113:             // ... and if there were an application cache entry,
43113:             // we would have found it earlier.
80486:             return aIsSync ? NS_ERROR_CACHE_KEY_NOT_FOUND : Connect(false);
43113:         }
43113: 
43113:         if (namespaceType &
43113:             nsIApplicationCacheNamespace::NAMESPACE_FALLBACK) {
43113:             rv = namespaceEntry->GetData(mFallbackKey);
53987:             if (NS_FAILED(rv) && !aIsSync)
80486:                 return Connect(false);
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113:         }
43113: 
43113:         if ((namespaceType &
43113:              nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC) &&
43113:             mLoadFlags & LOAD_DOCUMENT_URI) {
43113:             // Document loads for items in an opportunistic namespace
43113:             // should be placed in the offline cache.
43113:             nsCString clientID;
43113:             mApplicationCache->GetClientID(clientID);
43113: 
43113:             mCacheForOfflineUse = !clientID.IsEmpty();
43113:             SetOfflineCacheClientID(clientID);
80486:             mCachingOpportunistically = true;
43113:         }
43113:     }
53987: 
53987:     return OpenNormalCacheEntry(aIsSync);
53987: }
53987: 
53987: 
53987: nsresult
79445: nsHttpChannel::OpenNormalCacheEntry(bool aIsSync)
53987: {
53987:     NS_ASSERTION(!mCacheEntry, "We have already mCacheEntry");
53987: 
53987:     nsresult rv;
53987: 
53987:     nsCAutoString cacheKey;
53987:     GenerateCacheKey(mPostID, cacheKey);
53987: 
53987:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy();
53987: 
53987:     nsCOMPtr<nsICacheSession> session;
43113:     rv = gHttpHandler->GetCacheSession(storagePolicy,
43113:                                        getter_AddRefs(session));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     nsCacheAccessMode accessRequested;
53987:     rv = DetermineCacheAccess(&accessRequested);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     if (mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY) {
53987:         if (!aIsSync) {
53987:             // Unexpected state: we were called from OnCacheEntryAvailable(),
53987:             // so LOAD_BYPASS_LOCAL_CACHE_IF_BUSY shouldn't be set. Unless
53987:             // somebody altered mLoadFlags between OpenCacheEntry() and
53987:             // OnCacheEntryAvailable()...
53987:             NS_WARNING(
53987:                 "OpenNormalCacheEntry() called from OnCacheEntryAvailable() "
53987:                 "when LOAD_BYPASS_LOCAL_CACHE_IF_BUSY was specified");
53987:         }
53987: 
53987:         // must use synchronous open for LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
80486:         rv = session->OpenCacheEntry(cacheKey, accessRequested, false,
43113:                                      getter_AddRefs(mCacheEntry));
53987:         if (NS_SUCCEEDED(rv)) {
53987:             mCacheEntry->GetAccessGranted(&mCacheAccess);
53987:             LOG(("nsHttpChannel::OpenCacheEntry [this=%p grantedAccess=%d]",
53987:                 this, mCacheAccess));
53987:         }
53987:         else if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
51890:             LOG(("bypassing local cache since it is busy\n"));
53987:             rv = NS_ERROR_NOT_AVAILABLE;
53987:         }
53987:     }
53987:     else {
53987:         mOnCacheEntryAvailableCallback =
53987:             &nsHttpChannel::OnNormalCacheEntryAvailable;
51890:         rv = session->AsyncOpenCacheEntry(cacheKey, accessRequested, this);
53987:         if (NS_SUCCEEDED(rv)) {
80486:             mAsyncCacheOpen = true;
53987:             return NS_OK;
53987:         }
53987:     }
53987: 
53987:     if (!aIsSync)
53987:         // Called from OnCacheEntryAvailable, advance to the next state
80486:         rv = Connect(false);
53987: 
43113:     return rv;
43113: }
43113: 
53987: nsresult
53987: nsHttpChannel::OnNormalCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
53987:                                            nsCacheAccessMode aAccess,
53987:                                            nsresult aEntryStatus,
79445:                                            bool aIsSync)
53987: {
53987:     NS_ASSERTION(!aIsSync, "aIsSync should be false");
53987: 
53987:     if (NS_SUCCEEDED(aEntryStatus)) {
53987:         mCacheEntry = aEntry;
53987:         mCacheAccess = aAccess;
53987:     }
53987: 
53987:     if (mCanceled && NS_FAILED(mStatus)) {
53987:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
53987:         return mStatus;
53987:     }
53987: 
53987:     if ((mLoadFlags & LOAD_ONLY_FROM_CACHE) && NS_FAILED(aEntryStatus))
53987:         // if this channel is only allowed to pull from the cache, then
53987:         // we must fail if we were unable to open a cache entry.
53987:         return NS_ERROR_DOCUMENT_NOT_CACHED;
53987: 
53987:     // advance to the next state...
80486:     return Connect(false);
53987: }
53987: 
43113: 
43113: nsresult
43113: nsHttpChannel::OpenOfflineCacheEntryForWriting()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::OpenOfflineCacheEntryForWriting [this=%p]", this));
43113: 
43113:     // make sure we're not abusing this function
43113:     NS_PRECONDITION(!mOfflineCacheEntry, "cache entry already open");
43113: 
79445:     bool offline = gIOService->IsOffline();
43113:     if (offline) {
43113:         // only put things in the offline cache while online
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (mRequestHead.Method() != nsHttp::Get) {
43113:         // only cache complete documents offline
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Don't cache byte range requests which are subranges, only cache 0-
43113:     // byte range requests.
43113:     if (IsSubRangeRequest(mRequestHead))
43113:         return NS_OK;
43113: 
43113:     nsCAutoString cacheKey;
43113:     GenerateCacheKey(mPostID, cacheKey);
43113: 
43113:     NS_ENSURE_TRUE(!mOfflineCacheClientID.IsEmpty(),
43113:                    NS_ERROR_NOT_AVAILABLE);
43113: 
43113:     nsCOMPtr<nsICacheSession> session;
43113:     nsCOMPtr<nsICacheService> serv =
43113:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = serv->CreateSession(mOfflineCacheClientID.get(),
43113:                              nsICache::STORE_OFFLINE,
43113:                              nsICache::STREAM_BASED,
43113:                              getter_AddRefs(session));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = session->OpenCacheEntry(cacheKey, nsICache::ACCESS_READ_WRITE,
80486:                                  false, getter_AddRefs(mOfflineCacheEntry));
43113: 
43113:     if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
43113:         // access to the cache entry has been denied (because the cache entry
43113:         // is probably in use by another channel).  Either the cache is being
43113:         // read from (we're offline) or it's being updated elsewhere.
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (NS_SUCCEEDED(rv)) {
43113:         mOfflineCacheEntry->GetAccessGranted(&mOfflineCacheAccess);
43113:         LOG(("got offline cache entry [access=%x]\n", mOfflineCacheAccess));
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
71627: // Generates the proper cache-key for this instance of nsHttpChannel
43113: nsresult
43113: nsHttpChannel::GenerateCacheKey(PRUint32 postID, nsACString &cacheKey)
43113: {
71627:     AssembleCacheKey(mFallbackChannel ? mFallbackKey.get() : mSpec.get(),
71627:                      postID, cacheKey);
71627:     return NS_OK;
71627: }
71627: 
71627: // Assembles a cache-key from the given pieces of information and |mLoadFlags|
71627: void
71627: nsHttpChannel::AssembleCacheKey(const char *spec, PRUint32 postID,
71627:                                 nsACString &cacheKey)
71627: {
43113:     cacheKey.Truncate();
43113: 
43113:     if (mLoadFlags & LOAD_ANONYMOUS) {
43113:         cacheKey.AssignLiteral("anon&");
43113:     }
43113: 
43113:     if (postID) {
43113:         char buf[32];
43113:         PR_snprintf(buf, sizeof(buf), "id=%x&", postID);
43113:         cacheKey.Append(buf);
43113:     }
43113: 
43113:     if (!cacheKey.IsEmpty()) {
43113:         cacheKey.AppendLiteral("uri=");
43113:     }
43113: 
43113:     // Strip any trailing #ref from the URL before using it as the key
43113:     const char *p = strchr(spec, '#');
43113:     if (p)
43113:         cacheKey.Append(spec, p - spec);
43113:     else
43113:         cacheKey.Append(spec);
43113: }
43113: 
43113: // UpdateExpirationTime is called when a new response comes in from the server.
43113: // It updates the stored response-time and sets the expiration time on the
43113: // cache entry.  
43113: //
43113: // From section 13.2.4 of RFC2616, we compute expiration time as follows:
43113: //
43113: //    timeRemaining = freshnessLifetime - currentAge
43113: //    expirationTime = now + timeRemaining
43113: // 
43113: nsresult
43113: nsHttpChannel::UpdateExpirationTime()
43113: {
43113:     NS_ENSURE_TRUE(mResponseHead, NS_ERROR_FAILURE);
43113: 
43113:     nsresult rv;
43113: 
43113:     PRUint32 expirationTime = 0;
43113:     if (!mResponseHead->MustValidate()) {
43113:         PRUint32 freshnessLifetime = 0;
43113: 
43113:         rv = mResponseHead->ComputeFreshnessLifetime(&freshnessLifetime);
43113:         if (NS_FAILED(rv)) return rv;
43113: 
43113:         if (freshnessLifetime > 0) {
43113:             PRUint32 now = NowInSeconds(), currentAge = 0;
43113: 
43113:             rv = mResponseHead->ComputeCurrentAge(now, mRequestTime, &currentAge); 
43113:             if (NS_FAILED(rv)) return rv;
43113: 
43113:             LOG(("freshnessLifetime = %u, currentAge = %u\n",
43113:                 freshnessLifetime, currentAge));
43113: 
43113:             if (freshnessLifetime > currentAge) {
43113:                 PRUint32 timeRemaining = freshnessLifetime - currentAge;
43113:                 // be careful... now + timeRemaining may overflow
43113:                 if (now + timeRemaining < now)
43113:                     expirationTime = PRUint32(-1);
43113:                 else
43113:                     expirationTime = now + timeRemaining;
43113:             }
43113:             else
43113:                 expirationTime = now;
43113:         }
43113:     }
43113: 
43113:     rv = mCacheEntry->SetExpirationTime(expirationTime);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     if (mOfflineCacheEntry) {
43113:         rv = mOfflineCacheEntry->SetExpirationTime(expirationTime);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // CheckCache is called from Connect after a cache entry has been opened for
43113: // this URL but before going out to net.  It's purpose is to set or clear the 
43113: // mCachedContentIsValid flag, and to configure an If-Modified-Since request
43113: // if validation is required.
43113: nsresult
43113: nsHttpChannel::CheckCache()
43113: {
43113:     nsresult rv = NS_OK;
43113: 
43113:     LOG(("nsHTTPChannel::CheckCache enter [this=%p entry=%p access=%d]",
43113:         this, mCacheEntry.get(), mCacheAccess));
43113:     
43113:     // Be pessimistic: assume the cache entry has no useful data.
80486:     mCachedContentIsValid = false;
43113: 
43113:     // Don't proceed unless we have opened a cache entry for reading.
43113:     if (!mCacheEntry || !(mCacheAccess & nsICache::ACCESS_READ))
43113:         return NS_OK;
43113: 
43113:     nsXPIDLCString buf;
43113: 
43113:     // Get the method that was used to generate the cached response
43113:     rv = mCacheEntry->GetMetaDataElement("request-method", getter_Copies(buf));
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
78638:     nsHttpAtom method = nsHttp::ResolveAtom(buf);
43113:     if (method == nsHttp::Head) {
43113:         // The cached response does not contain an entity.  We can only reuse
43113:         // the response if the current request is also HEAD.
43113:         if (mRequestHead.Method() != nsHttp::Head)
43113:             return NS_OK;
43113:     }
43113:     buf.Adopt(0);
43113: 
43113:     // We'll need this value in later computations...
43113:     PRUint32 lastModifiedTime;
43113:     rv = mCacheEntry->GetLastModified(&lastModifiedTime);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // Determine if this is the first time that this cache entry
43113:     // has been accessed during this session.
79445:     bool fromPreviousSession =
43113:             (gHttpHandler->SessionStartTime() > lastModifiedTime);
43113: 
43113:     // Get the cached HTTP response headers
43113:     rv = mCacheEntry->GetMetaDataElement("response-head", getter_Copies(buf));
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // Parse the cached HTTP response headers
43113:     mCachedResponseHead = new nsHttpResponseHead();
43113:     if (!mCachedResponseHead)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     rv = mCachedResponseHead->Parse((char *) buf.get());
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113:     buf.Adopt(0);
43113: 
43113:     // Don't bother to validate items that are read-only,
43113:     // unless they are read-only because of INHIBIT_CACHING or because
43113:     // we're updating the offline cache.
43113:     // Don't bother to validate if this is a fallback entry.
43113:     if (!mCacheForOfflineUse &&
43113:         (mLoadedFromApplicationCache ||
43113:          (mCacheAccess == nsICache::ACCESS_READ &&
43113:           !(mLoadFlags & INHIBIT_CACHING)) ||
43113:          mFallbackChannel)) {
80486:         mCachedContentIsValid = true;
43113:         return NS_OK;
43113:     }
43113: 
43113:     PRUint16 isCachedRedirect = mCachedResponseHead->Status()/100 == 3;
43113: 
61973:     mCustomConditionalRequest =
61973:         mRequestHead.PeekHeader(nsHttp::If_Modified_Since) ||
61973:         mRequestHead.PeekHeader(nsHttp::If_None_Match) ||
61973:         mRequestHead.PeekHeader(nsHttp::If_Unmodified_Since) ||
61973:         mRequestHead.PeekHeader(nsHttp::If_Match) ||
61973:         mRequestHead.PeekHeader(nsHttp::If_Range);
61973: 
43113:     if (method != nsHttp::Head && !isCachedRedirect) {
43113:         // If the cached content-length is set and it does not match the data
43113:         // size of the cached content, then the cached response is partial...
43113:         // either we need to issue a byte range request or we need to refetch
43113:         // the entire document.
64617:         PRInt64 contentLength = mCachedResponseHead->ContentLength();
64617:         if (contentLength != PRInt64(-1)) {
43113:             PRUint32 size;
43113:             rv = mCacheEntry->GetDataSize(&size);
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113: 
64617:             if (PRInt64(size) != contentLength) {
43113:                 LOG(("Cached data size does not match the Content-Length header "
51740:                      "[content-length=%lld size=%u]\n", PRInt64(contentLength), size));
61973: 
79445:                 bool hasContentEncoding =
61973:                     mCachedResponseHead->PeekHeader(nsHttp::Content_Encoding)
61973:                     != nsnull;
64617:                 if ((PRInt64(size) < contentLength) &&
61973:                      size > 0 &&
61973:                      !hasContentEncoding &&
61973:                      mCachedResponseHead->IsResumable() &&
61973:                      !mCustomConditionalRequest &&
61973:                      !mCachedResponseHead->NoStore()) {
61973:                     // looks like a partial entry we can reuse
43113:                     rv = SetupByteRangeRequest(size);
43113:                     NS_ENSURE_SUCCESS(rv, rv);
80486:                     mCachedContentIsPartial = true;
43113:                 }
43113:                 return NS_OK;
43113:             }
43113:         }
43113:     }
43113: 
79445:     bool doValidation = false;
79445:     bool canAddImsHeader = true;
43113: 
70828:     // Cached entry is not the entity we request (see bug #633743)
70828:     if (ResponseWouldVary()) {
70828:         LOG(("Validating based on Vary headers returning TRUE\n"));
80486:         canAddImsHeader = false;
80486:         doValidation = true;
70828:     }
70828:     // If the LOAD_FROM_CACHE flag is set, any cached data can simply be used
70828:     else if (mLoadFlags & LOAD_FROM_CACHE) {
43113:         LOG(("NOT validating based on LOAD_FROM_CACHE load flag\n"));
80486:         doValidation = false;
43113:     }
43113:     // If the VALIDATE_ALWAYS flag is set, any cached data won't be used until
43113:     // it's revalidated with the server.
43113:     else if (mLoadFlags & VALIDATE_ALWAYS) {
43113:         LOG(("Validating based on VALIDATE_ALWAYS load flag\n"));
80486:         doValidation = true;
43113:     }
43113:     // Even if the VALIDATE_NEVER flag is set, there are still some cases in
43113:     // which we must validate the cached response with the server.
43113:     else if (mLoadFlags & VALIDATE_NEVER) {
43113:         LOG(("VALIDATE_NEVER set\n"));
43113:         // if no-store or if no-cache and ssl, validate cached response (see
43113:         // bug 112564 for an explanation of this logic)
43113:         if (mCachedResponseHead->NoStore() ||
43113:            (mCachedResponseHead->NoCache() && mConnectionInfo->UsingSSL())) {
43113:             LOG(("Validating based on (no-store || (no-cache && ssl)) logic\n"));
80486:             doValidation = true;
43113:         }
43113:         else {
43113:             LOG(("NOT validating based on VALIDATE_NEVER load flag\n"));
80486:             doValidation = false;
43113:         }
43113:     }
43113:     // check if validation is strictly required...
43113:     else if (mCachedResponseHead->MustValidate()) {
43113:         LOG(("Validating based on MustValidate() returning TRUE\n"));
80486:         doValidation = true;
43113:     }
43113: 
43113:     else if (MustValidateBasedOnQueryUrl()) {
43113:         LOG(("Validating based on RFC 2616 section 13.9 "
43113:              "(query-url w/o explicit expiration-time)\n"));
80486:         doValidation = true;
43113:     }
43113:     // Check if the cache entry has expired...
43113:     else {
43113:         PRUint32 time = 0; // a temporary variable for storing time values...
43113: 
43113:         rv = mCacheEntry->GetExpirationTime(&time);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         if (NowInSeconds() <= time)
80486:             doValidation = false;
43113:         else if (mCachedResponseHead->MustValidateIfExpired())
80486:             doValidation = true;
43113:         else if (mLoadFlags & VALIDATE_ONCE_PER_SESSION) {
43113:             // If the cached response does not include expiration infor-
43113:             // mation, then we must validate the response, despite whether
43113:             // or not this is the first access this session.  This behavior
43113:             // is consistent with existing browsers and is generally expected
43113:             // by web authors.
43113:             rv = mCachedResponseHead->ComputeFreshnessLifetime(&time);
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:             if (time == 0)
80486:                 doValidation = true;
43113:             else
43113:                 doValidation = fromPreviousSession;
43113:         }
43113:         else
80486:             doValidation = true;
43113: 
43113:         LOG(("%salidating based on expiration time\n", doValidation ? "V" : "Not v"));
43113:     }
43113: 
43113:     if (!doValidation && mRequestHead.PeekHeader(nsHttp::If_Match) &&
43113:         (method == nsHttp::Get || method == nsHttp::Head)) {
43113:         const char *requestedETag, *cachedETag;
43113:         cachedETag = mCachedResponseHead->PeekHeader(nsHttp::ETag);
43113:         requestedETag = mRequestHead.PeekHeader(nsHttp::If_Match);
43113:         if (cachedETag && (!strncmp(cachedETag, "W/", 2) ||
43113:             strcmp(requestedETag, cachedETag))) {
43113:             // User has defined If-Match header, if the cached entry is not 
43113:             // matching the provided header value or the cached ETag is weak,
43113:             // force validation.
80486:             doValidation = true;
43113:         }
43113:     }
43113: 
43113:     if (!doValidation) {
43113:         //
43113:         // Check the authorization headers used to generate the cache entry.
43113:         // We must validate the cache entry if:
43113:         //
43113:         // 1) the cache entry was generated prior to this session w/
43113:         //    credentials (see bug 103402).
43113:         // 2) the cache entry was generated w/o credentials, but would now
43113:         //    require credentials (see bug 96705).
43113:         //
43113:         // NOTE: this does not apply to proxy authentication.
43113:         //
43113:         mCacheEntry->GetMetaDataElement("auth", getter_Copies(buf));
43113:         doValidation =
43113:             (fromPreviousSession && !buf.IsEmpty()) ||
43113:             (buf.IsEmpty() && mRequestHead.PeekHeader(nsHttp::Authorization));
43113:     }
43113: 
63794:     // Bug #561276: We maintain a chain of cache-keys which returns cached
63794:     // 3xx-responses (redirects) in order to detect cycles. If a cycle is
63794:     // found, ignore the cached response and hit the net. Otherwise, use
63794:     // the cached response and add the cache-key to the chain. Note that
63794:     // a limited number of redirects (cached or not) is allowed and is
63794:     // enforced independently of this mechanism
63794:     if (!doValidation && isCachedRedirect) {
63794:         nsCAutoString cacheKey;
63794:         GenerateCacheKey(mPostID, cacheKey);
63794: 
63794:         if (!mRedirectedCachekeys)
63794:             mRedirectedCachekeys = new nsTArray<nsCString>();
63794:         else if (mRedirectedCachekeys->Contains(cacheKey))
80486:             doValidation = true;
63794: 
63794:         LOG(("Redirection-chain %s key %s\n",
63794:              doValidation ? "contains" : "does not contain", cacheKey.get()));
63794: 
63794:         // Append cacheKey if not in the chain already
63794:         if (!doValidation)
63794:             mRedirectedCachekeys->AppendElement(cacheKey);
43113:     }
43113: 
43113:     mCachedContentIsValid = !doValidation;
43113: 
43113:     if (doValidation) {
43113:         //
43113:         // now, we are definitely going to issue a HTTP request to the server.
43113:         // make it conditional if possible.
43113:         //
43113:         // do not attempt to validate no-store content, since servers will not
43113:         // expect it to be cached.  (we only keep it in our cache for the
43113:         // purposes of back/forward, etc.)
43113:         //
43113:         // the request method MUST be either GET or HEAD (see bug 175641).
43113:         //
43113:         // do not override conditional headers when consumer has defined its own
43113:         if (!mCachedResponseHead->NoStore() &&
43113:             (mRequestHead.Method() == nsHttp::Get ||
43113:              mRequestHead.Method() == nsHttp::Head) &&
43113:              !mCustomConditionalRequest) {
43113:             const char *val;
43113:             // Add If-Modified-Since header if a Last-Modified was given
43113:             // and we are allowed to do this (see bugs 510359 and 269303)
43113:             if (canAddImsHeader) {
43113:                 val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
43113:                 if (val)
43113:                     mRequestHead.SetHeader(nsHttp::If_Modified_Since,
43113:                                            nsDependentCString(val));
43113:             }
43113:             // Add If-None-Match header if an ETag was given in the response
43113:             val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
43113:             if (val)
43113:                 mRequestHead.SetHeader(nsHttp::If_None_Match,
43113:                                        nsDependentCString(val));
78427:             mDidReval = true;
43113:         }
43113:     }
43113: 
43113:     LOG(("nsHTTPChannel::CheckCache exit [this=%p doValidation=%d]\n", this, doValidation));
43113:     return NS_OK;
43113: }
43113: 
79445: bool
43113: nsHttpChannel::MustValidateBasedOnQueryUrl()
43113: {
43113:     // RFC 2616, section 13.9 states that GET-requests with a query-url
43113:     // MUST NOT be treated as fresh unless the server explicitly provides
43113:     // an expiration-time in the response. See bug #468594
43113:     // Section 13.2.1 (6th paragraph) defines "explicit expiration time"
43113:     if (mRequestHead.Method() == nsHttp::Get)
43113:     {
43113:         nsCAutoString query;
43113:         nsCOMPtr<nsIURL> url = do_QueryInterface(mURI);
43113:         nsresult rv = url->GetQuery(query);
43113:         if (NS_SUCCEEDED(rv) && !query.IsEmpty()) {
43113:             PRUint32 tmp; // we don't need the value, just whether it's set
43113:             rv = mCachedResponseHead->GetExpiresValue(&tmp);
43113:             if (NS_FAILED(rv)) {
43113:                 rv = mCachedResponseHead->GetMaxAgeValue(&tmp);
43113:                 if (NS_FAILED(rv)) {
80486:                     return true;
80486:                 }
80486:             }
80486:         }
80486:     }
80486:     return false;
43113: }
43113: 
43113: 
43113: nsresult
79445: nsHttpChannel::ShouldUpdateOfflineCacheEntry(bool *shouldCacheForOfflineUse)
43113: {
80486:     *shouldCacheForOfflineUse = false;
43113: 
43113:     if (!mOfflineCacheEntry) {
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if we're updating the cache entry, update the offline cache entry too
43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
80486:         *shouldCacheForOfflineUse = true;
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if there's nothing in the offline cache, add it
43113:     if (mOfflineCacheEntry && (mOfflineCacheAccess == nsICache::ACCESS_WRITE)) {
80486:         *shouldCacheForOfflineUse = true;
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if the document is newer than the offline entry, update it
43113:     PRUint32 docLastModifiedTime;
43113:     nsresult rv = mResponseHead->GetLastModifiedValue(&docLastModifiedTime);
43113:     if (NS_FAILED(rv)) {
80486:         *shouldCacheForOfflineUse = true;
43113:         return NS_OK;
43113:     }
43113: 
43113:     PRUint32 offlineLastModifiedTime;
43113:     rv = mOfflineCacheEntry->GetLastModified(&offlineLastModifiedTime);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     if (docLastModifiedTime > offlineLastModifiedTime) {
80486:         *shouldCacheForOfflineUse = true;
43113:         return NS_OK;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // If the data in the cache hasn't expired, then there's no need to
43113: // talk with the server, not even to do an if-modified-since.  This
43113: // method creates a stream from the cache, synthesizing all the various
43113: // channel-related events.
43113: nsresult
43113: nsHttpChannel::ReadFromCache()
43113: {
43113:     nsresult rv;
43113: 
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_FAILURE);
43113:     NS_ENSURE_TRUE(mCachedContentIsValid, NS_ERROR_FAILURE);
43113: 
43113:     LOG(("nsHttpChannel::ReadFromCache [this=%p] "
43113:          "Using cached copy of: %s\n", this, mSpec.get()));
43113: 
46790:     if (mCachedResponseHead)
43113:         mResponseHead = mCachedResponseHead;
43113: 
43113:     // if we don't already have security info, try to get it from the cache 
43113:     // entry. there are two cases to consider here: 1) we are just reading
43113:     // from the cache, or 2) this may be due to a 304 not modified response,
43113:     // in which case we could have security info from a socket transport.
43113:     if (!mSecurityInfo)
43113:         mCacheEntry->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
43113: 
43113:     if ((mCacheAccess & nsICache::ACCESS_WRITE) && !mCachedContentIsPartial) {
43113:         // We have write access to the cache, but we don't need to go to the
43113:         // server to validate at this time, so just mark the cache entry as
43113:         // valid in order to allow others access to this cache entry.
43113:         mCacheEntry->MarkValid();
43113:     }
43113: 
43113:     // if this is a cached redirect, we must process the redirect asynchronously
43113:     // since AsyncOpen may not have returned yet.  Make sure there is a Location
43113:     // header, otherwise we'll have to treat this like a normal 200 response.
43113:     if (mResponseHead && (mResponseHead->Status() / 100 == 3) 
43113:                       && (mResponseHead->PeekHeader(nsHttp::Location)))
43113:         return AsyncCall(&nsHttpChannel::HandleAsyncRedirect);
43113: 
43113:     // have we been configured to skip reading from the cache?
43113:     if ((mLoadFlags & LOAD_ONLY_IF_MODIFIED) && !mCachedContentIsPartial) {
43113:         // if offline caching has been requested and the offline cache needs
43113:         // updating, complete the call even if the main cache entry is
43113:         // up-to-date
79445:         bool shouldUpdateOffline;
43113:         if (!mCacheForOfflineUse ||
43113:             NS_FAILED(ShouldUpdateOfflineCacheEntry(&shouldUpdateOffline)) ||
43113:             !shouldUpdateOffline) {
43113: 
43113:             LOG(("skipping read from cache based on LOAD_ONLY_IF_MODIFIED "
43113:                  "load flag\n"));
43113:             return AsyncCall(&nsHttpChannel::HandleAsyncNotModified);
43113:         }
43113:     }
43113: 
43113:     // open input stream for reading...
43113:     nsCOMPtr<nsIInputStream> stream;
43113:     rv = mCacheEntry->OpenInputStream(0, getter_AddRefs(stream));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = nsInputStreamPump::Create(getter_AddRefs(mCachePump),
64617:                                    stream, PRInt64(-1), PRInt64(-1), 0, 0,
80486:                                    true);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     rv = mCachePump->AsyncRead(this, mListenerContext);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
70188:     if (mTimingEnabled)
70188:         mCacheReadStart = mozilla::TimeStamp::Now();
70188: 
53987:     PRUint32 suspendCount = mSuspendCount;
53987:     while (suspendCount--)
53987:         mCachePump->Suspend();
53987: 
53987:     return NS_OK;
43113: }
43113: 
43113: void
79445: nsHttpChannel::CloseCacheEntry(bool doomOnFailure)
43113: {
61191:     if (!mCacheEntry)
43113:         return;
43113: 
43113:     LOG(("nsHttpChannel::CloseCacheEntry [this=%p] mStatus=%x mCacheAccess=%x",
43113:          this, mStatus, mCacheAccess));
43113: 
43113:     // If we have begun to create or replace a cache entry, and that cache
43113:     // entry is not complete and not resumable, then it needs to be doomed.
43113:     // Otherwise, CheckCache will make the mistake of thinking that the
43113:     // partial cache entry is complete.
43113: 
79445:     bool doom = false;
43113:     if (mInitedCacheEntry) {
43113:         NS_ASSERTION(mResponseHead, "oops");
61191:         if (NS_FAILED(mStatus) && doomOnFailure &&
43113:             (mCacheAccess & nsICache::ACCESS_WRITE) &&
43113:             !mResponseHead->IsResumable())
80486:             doom = true;
43113:     }
43113:     else if (mCacheAccess == nsICache::ACCESS_WRITE)
80486:         doom = true;
43113: 
43113:     if (doom) {
43113:         LOG(("  dooming cache entry!!"));
43113:         mCacheEntry->Doom();
43113:     }
43113: 
46790:     mCachedResponseHead = nsnull;
43113: 
43113:     mCachePump = 0;
43113:     mCacheEntry = 0;
43113:     mCacheAccess = 0;
80486:     mInitedCacheEntry = false;
43113: }
43113: 
43113: 
43113: void
43113: nsHttpChannel::CloseOfflineCacheEntry()
43113: {
43113:     if (!mOfflineCacheEntry)
43113:         return;
43113: 
43113:     LOG(("nsHttpChannel::CloseOfflineCacheEntry [this=%p]", this));
43113: 
43113:     if (NS_FAILED(mStatus)) {
43113:         mOfflineCacheEntry->Doom();
43113:     }
43113:     else {
79445:         bool succeeded;
43113:         if (NS_SUCCEEDED(GetRequestSucceeded(&succeeded)) && !succeeded)
43113:             mOfflineCacheEntry->Doom();
43113:     }
43113: 
43113:     mOfflineCacheEntry = 0;
43113:     mOfflineCacheAccess = 0;
43113: 
43113:     if (mCachingOpportunistically) {
43113:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
43113:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
43113:         if (appCacheService) {
43113:             nsCAutoString cacheKey;
43113:             GenerateCacheKey(mPostID, cacheKey);
43113:             appCacheService->CacheOpportunistically(mApplicationCache,
43113:                                                     cacheKey);
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: // Initialize the cache entry for writing.
43113: //  - finalize storage policy
43113: //  - store security info
43113: //  - update expiration time
43113: //  - store headers and other meta data
43113: nsresult
43113: nsHttpChannel::InitCacheEntry()
43113: {
43113:     nsresult rv;
43113: 
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_UNEXPECTED);
43113:     // if only reading, nothing to be done here.
43113:     if (mCacheAccess == nsICache::ACCESS_READ)
43113:         return NS_OK;
43113: 
43113:     // Don't cache the response again if already cached...
43113:     if (mCachedContentIsValid)
43113:         return NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::InitCacheEntry [this=%p entry=%p]\n",
43113:         this, mCacheEntry.get()));
43113: 
43113:     // The no-store directive within the 'Cache-Control:' header indicates
43113:     // that we must not store the response in a persistent cache.
43113:     if (mResponseHead->NoStore())
43113:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
43113: 
43113:     // Only cache SSL content on disk if the pref is set
43113:     if (!gHttpHandler->IsPersistentHttpsCachingEnabled() &&
43113:         mConnectionInfo->UsingSSL())
43113:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
43113: 
43113:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING) {
43113:         rv = mCacheEntry->SetStoragePolicy(nsICache::STORE_IN_MEMORY);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     // Set the expiration time for this cache entry
43113:     rv = UpdateExpirationTime();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = AddCacheEntryHeaders(mCacheEntry);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
80486:     mInitedCacheEntry = true;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsHttpChannel::InitOfflineCacheEntry()
43113: {
43113:     // This function can be called even when we fail to connect (bug 551990)
43113: 
43113:     if (!mOfflineCacheEntry) {
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (mResponseHead && mResponseHead->NoStore()) {
43113:         CloseOfflineCacheEntry();
43113: 
43113:         return NS_OK;
43113:     }
43113: 
43113:     // This entry's expiration time should match the main entry's expiration
43113:     // time.  UpdateExpirationTime() will keep it in sync once the offline
43113:     // cache entry has been created.
43113:     if (mCacheEntry) {
43113:         PRUint32 expirationTime;
43113:         nsresult rv = mCacheEntry->GetExpirationTime(&expirationTime);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         mOfflineCacheEntry->SetExpirationTime(expirationTime);
43113:     }
43113: 
43113:     return AddCacheEntryHeaders(mOfflineCacheEntry);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsHttpChannel::AddCacheEntryHeaders(nsICacheEntryDescriptor *entry)
43113: {
43113:     nsresult rv;
43113: 
58260:     LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] begin", this));
43113:     // Store secure data in memory only
43113:     if (mSecurityInfo)
43113:         entry->SetSecurityInfo(mSecurityInfo);
43113: 
43113:     // Store the HTTP request method with the cache entry so we can distinguish
43113:     // for example GET and HEAD responses.
43113:     rv = entry->SetMetaDataElement("request-method",
78638:                                    mRequestHead.Method().get());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // Store the HTTP authorization scheme used if any...
43113:     rv = StoreAuthorizationMetaData(entry);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // Iterate over the headers listed in the Vary response header, and
43113:     // store the value of the corresponding request header so we can verify
43113:     // that it has not varied when we try to re-use the cached response at
58260:     // a later time.  Take care to store "Cookie" headers only as hashes
58260:     // due to security considerations and the fact that they can be pretty
58260:     // large (bug 468426). We take care of "Vary: cookie" in ResponseWouldVary.
43113:     //
43113:     // NOTE: if "Vary: accept, cookie", then we will store the "accept" header
43113:     // in the cache.  we could try to avoid needlessly storing the "accept"
43113:     // header in this case, but it doesn't seem worth the extra code to perform
43113:     // the check.
43113:     {
43113:         nsCAutoString buf, metaKey;
43113:         mResponseHead->GetHeader(nsHttp::Vary, buf);
43113:         if (!buf.IsEmpty()) {
43113:             NS_NAMED_LITERAL_CSTRING(prefix, "request-");
43113:            
43113:             char *val = buf.BeginWriting(); // going to munge buf
43113:             char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:             while (token) {
58260:                 LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] " \
58260:                         "processing %s", this, token));
58260:                 if (*token != '*') {
43113:                     nsHttpAtom atom = nsHttp::ResolveAtom(token);
58260:                     const char *val = mRequestHead.PeekHeader(atom);
58260:                     nsCAutoString hash;
58260:                     if (val) {
58260:                         // If cookie-header, store a hash of the value
58260:                         if (atom == nsHttp::Cookie) {
58260:                             LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] " \
58260:                                     "cookie-value %s", this, val));
58260:                             rv = Hash(val, hash);
58260:                             // If hash failed, store a string not very likely
58260:                             // to be the result of subsequent hashes
58260:                             if (NS_FAILED(rv))
58260:                                 val = "<hash failed>";
58260:                             else
58260:                                 val = hash.get();
58260: 
58260:                             LOG(("   hashed to %s\n", val));
58260:                         }
58260: 
43113:                         // build cache meta data key and set meta data element...
43113:                         metaKey = prefix + nsDependentCString(token);
58260:                         entry->SetMetaDataElement(metaKey.get(), val);
58260:                     } else {
58260:                         LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%x] " \
58260:                                 "clearing metadata for %s", this, token));
58260:                         metaKey = prefix + nsDependentCString(token);
58260:                         entry->SetMetaDataElement(metaKey.get(), nsnull);
43113:                     }
43113:                 }
43113:                 token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:             }
43113:         }
43113:     }
43113: 
43113: 
43113:     // Store the received HTTP head with the cache entry as an element of
43113:     // the meta data.
43113:     nsCAutoString head;
80486:     mResponseHead->Flatten(head, true);
43113:     rv = entry->SetMetaDataElement("response-head", head.get());
43113: 
43113:     return rv;
43113: }
43113: 
43113: inline void
43113: GetAuthType(const char *challenge, nsCString &authType)
43113: {
43113:     const char *p;
43113: 
43113:     // get the challenge type
43113:     if ((p = strchr(challenge, ' ')) != nsnull)
43113:         authType.Assign(challenge, p - challenge);
43113:     else
43113:         authType.Assign(challenge);
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry)
43113: {
43113:     // Not applicable to proxy authorization...
43113:     const char *val = mRequestHead.PeekHeader(nsHttp::Authorization);
43113:     if (!val)
43113:         return NS_OK;
43113: 
43113:     // eg. [Basic realm="wally world"]
43113:     nsCAutoString buf;
43113:     GetAuthType(val, buf);
43113:     return entry->SetMetaDataElement("auth", buf.get());
43113: }
43113: 
43113: // Finalize the cache entry
43113: //  - may need to rewrite response headers if any headers changed
43113: //  - may need to recalculate the expiration time if any headers changed
43113: //  - called only for freshly written cache entries
43113: nsresult
43113: nsHttpChannel::FinalizeCacheEntry()
43113: {
43113:     LOG(("nsHttpChannel::FinalizeCacheEntry [this=%p]\n", this));
43113: 
43113:     if (mResponseHead && mResponseHeadersModified) {
43113:         // Set the expiration time for this cache entry
43113:         nsresult rv = UpdateExpirationTime();
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: // Open an output stream to the cache entry and insert a listener tee into
43113: // the chain of response listeners.
43113: nsresult
43113: nsHttpChannel::InstallCacheListener(PRUint32 offset)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("Preparing to write data into the cache [uri=%s]\n", mSpec.get()));
43113: 
43113:     NS_ASSERTION(mCacheEntry, "no cache entry");
43113:     NS_ASSERTION(mListener, "no listener");
43113: 
43113:     nsCOMPtr<nsIOutputStream> out;
43113:     rv = mCacheEntry->OpenOutputStream(offset, getter_AddRefs(out));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // XXX disk cache does not support overlapped i/o yet
43113: #if 0
43113:     // Mark entry valid inorder to allow simultaneous reading...
43113:     rv = mCacheEntry->MarkValid();
43113:     if (NS_FAILED(rv)) return rv;
43113: #endif
43113: 
43113:     nsCOMPtr<nsIStreamListenerTee> tee =
43113:         do_CreateInstance(kStreamListenerTeeCID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
51302:     nsCOMPtr<nsICacheService> serv =
51302:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
51302:     NS_ENSURE_SUCCESS(rv, rv);
51302: 
51302:     nsCOMPtr<nsIEventTarget> cacheIOTarget;
51302:     serv->GetCacheIOTarget(getter_AddRefs(cacheIOTarget));
51302: 
74243:     nsCacheStoragePolicy policy;
74243:     rv = mCacheEntry->GetStoragePolicy(&policy);
74243: 
74243:     if (NS_FAILED(rv) || policy == nsICache::STORE_ON_DISK_AS_FILE ||
51302:         !cacheIOTarget) {
51302:         LOG(("nsHttpChannel::InstallCacheListener sync tee %p rv=%x policy=%d "
51302:              "cacheIOTarget=%p", tee.get(), rv, policy, cacheIOTarget.get()));
43113:         rv = tee->Init(mListener, out, nsnull);
43113:     } else {
51302:         LOG(("nsHttpChannel::InstallCacheListener async tee %p", tee.get()));
51302:         rv = tee->InitAsync(mListener, cacheIOTarget, out, nsnull);
43113:     }
43113: 
43113:     if (NS_FAILED(rv)) return rv;
43113:     mListener = tee;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::InstallOfflineCacheListener()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("Preparing to write data into the offline cache [uri=%s]\n",
43113:          mSpec.get()));
43113: 
43113:     NS_ASSERTION(mOfflineCacheEntry, "no offline cache entry");
43113:     NS_ASSERTION(mListener, "no listener");
43113: 
43113:     nsCOMPtr<nsIOutputStream> out;
43113:     rv = mOfflineCacheEntry->OpenOutputStream(0, getter_AddRefs(out));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsCOMPtr<nsIStreamListenerTee> tee =
43113:         do_CreateInstance(kStreamListenerTeeCID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = tee->Init(mListener, out, nsnull);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mListener = tee;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpChannel::ClearBogusContentEncodingIfNeeded()
43113: {
43113:     // For .gz files, apache sends both a Content-Type: application/x-gzip
43113:     // as well as Content-Encoding: gzip, which is completely wrong.  In
43113:     // this case, we choose to ignore the rogue Content-Encoding header. We
43113:     // must do this early on so as to prevent it from being seen up stream.
43113:     // The same problem exists for Content-Encoding: compress in default
43113:     // Apache installs.
43113:     if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "gzip") && (
43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP) ||
43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP2) ||
43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP3))) {
43113:         // clear the Content-Encoding header
43113:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
43113:     }
43113:     else if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "compress") && (
43113:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS) ||
43113:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS2))) {
43113:         // clear the Content-Encoding header
43113:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
43113:     }
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <redirect>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::SetupReplacementChannel(nsIURI       *newURI, 
43113:                                        nsIChannel   *newChannel,
79445:                                        bool          preserveMethod)
43113: {
43113:     LOG(("nsHttpChannel::SetupReplacementChannel "
43113:          "[this=%p newChannel=%p preserveMethod=%d]",
43113:          this, newChannel, preserveMethod));
49375: 
49375:     nsresult rv = HttpBaseChannel::SetupReplacementChannel(newURI, newChannel, preserveMethod);
49375:     if (NS_FAILED(rv))
49375:         return rv;
43113: 
43113:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
43113:     if (!httpChannel)
43113:         return NS_OK; // no other options to set
43113: 
43113:     // convey the mApplyConversion flag (bug 91862)
43113:     nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(httpChannel);
43113:     if (encodedChannel)
43113:         encodedChannel->SetApplyConversion(mApplyConversion);
43113: 
43113:     // transfer the resume information
43113:     if (mResuming) {
43113:         nsCOMPtr<nsIResumableChannel> resumableChannel(do_QueryInterface(newChannel));
43113:         if (!resumableChannel) {
43113:             NS_WARNING("Got asked to resume, but redirected to non-resumable channel!");
43113:             return NS_ERROR_NOT_RESUMABLE;
43113:         }
43113:         resumableChannel->ResumeAt(mStartPos, mEntityID);
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
48304: nsHttpChannel::AsyncProcessRedirection(PRUint32 redirectType)
43113: {
48304:     LOG(("nsHttpChannel::AsyncProcessRedirection [this=%p type=%u]\n",
43113:         this, redirectType));
43113: 
43113:     const char *location = mResponseHead->PeekHeader(nsHttp::Location);
43113: 
43113:     // if a location header was not given, then we can't perform the redirect,
43113:     // so just carry on as though this were a normal response.
43113:     if (!location)
43113:         return NS_ERROR_FAILURE;
43113: 
43113:     // make sure non-ASCII characters in the location header are escaped.
43113:     nsCAutoString locationBuf;
43113:     if (NS_EscapeURL(location, -1, esc_OnlyNonASCII, locationBuf))
43113:         location = locationBuf.get();
43113: 
43113:     if (mRedirectionLimit == 0) {
43113:         LOG(("redirection limit reached!\n"));
43113:         // this error code is fatal, and should be conveyed to our listener.
43113:         Cancel(NS_ERROR_REDIRECT_LOOP);
43113:         return NS_ERROR_REDIRECT_LOOP;
43113:     }
43113: 
48304:     mRedirectType = redirectType;
48304: 
43113:     LOG(("redirecting to: %s [redirection-limit=%u]\n",
43113:         location, PRUint32(mRedirectionLimit)));
43113: 
71627:     nsresult rv = CreateNewURI(location, getter_AddRefs(mRedirectURI));
71627: 
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     if (mApplicationCache) {
43113:         // if we are redirected to a different origin check if there is a fallback
43113:         // cache entry to fall back to. we don't care about file strict 
43113:         // checking, at least mURI is not a file URI.
80486:         if (!NS_SecurityCompareURIs(mURI, mRedirectURI, false)) {
48304:             PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
79445:             bool waitingForRedirectCallback;
63793:             (void)ProcessFallback(&waitingForRedirectCallback);
48304:             if (waitingForRedirectCallback)
48304:                 return NS_OK;
48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
48304:         }
48304:     }
48304: 
48304:     return ContinueProcessRedirectionAfterFallback(NS_OK);
48304: }
48304: 
71627: // Creates an URI to the given location using current URI for base and charset
71627: nsresult
71627: nsHttpChannel::CreateNewURI(const char *loc, nsIURI **newURI)
71627: {
71627:     nsCOMPtr<nsIIOService> ioService;
71627:     nsresult rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
71627:     if (NS_FAILED(rv)) return rv;
71627: 
71627:     // the new uri should inherit the origin charset of the current uri
71627:     nsCAutoString originCharset;
71627:     rv = mURI->GetOriginCharset(originCharset);
71627:     if (NS_FAILED(rv))
71627:         originCharset.Truncate();
71627: 
71627:     return ioService->NewURI(nsDependentCString(loc),
71627:                              originCharset.get(),
71627:                              mURI,
71627:                              newURI);
71627: }
71627: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessRedirectionAfterFallback(nsresult rv)
48304: {
48304:     if (NS_SUCCEEDED(rv) && mFallingBack) {
43113:         // do not continue with redirect processing, fallback is in
43113:         // progress now.
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Kill the current cache entry if we are redirecting
43113:     // back to ourself.
79445:     bool redirectingBackToSameURI = false;
43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
48304:         NS_SUCCEEDED(mURI->Equals(mRedirectURI, &redirectingBackToSameURI)) &&
43113:         redirectingBackToSameURI)
43113:             mCacheEntry->Doom();
43113: 
43113:     // move the reference of the old location to the new one if the new
43113:     // one has none.
43113:     nsCAutoString ref;
70215:     rv = mRedirectURI->GetRef(ref);
43113:     if (NS_SUCCEEDED(rv) && ref.IsEmpty()) {
70215:         mURI->GetRef(ref);
70215:         if (!ref.IsEmpty()) {
70215:             // NOTE: SetRef will fail if mRedirectURI is immutable
70215:             // (e.g. an about: URI)... Oh well.
70215:             mRedirectURI->SetRef(ref);
43113:         }
43113:     }
43113: 
80420:     bool rewriteToGET = HttpBaseChannel::ShouldRewriteRedirectToGET(
80420:         mRedirectType, mRequestHead.Method());
80420:       
80420:     // prompt if the method is not safe (such as POST, PUT, DELETE, ...)
80420:     if (!rewriteToGET &&
80420:         !HttpBaseChannel::IsSafeMethod(mRequestHead.Method())) {
43113:         rv = PromptTempRedirect();
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
48304:     nsCOMPtr<nsIIOService> ioService;
48304:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
48304:     nsCOMPtr<nsIChannel> newChannel;
48304:     rv = ioService->NewChannelFromURI(mRedirectURI, getter_AddRefs(newChannel));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
80420:     rv = SetupReplacementChannel(mRedirectURI, newChannel, !rewriteToGET);
48304:     if (NS_FAILED(rv)) return rv;
48304: 
43113:     PRUint32 redirectFlags;
48304:     if (mRedirectType == 301) // Moved Permanently
43113:         redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
43113:     else
43113:         redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
43113: 
43113:     // verify that this is a legal redirect
48304:     mRedirectChannel = newChannel;
48304: 
48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirection);
48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
48304: 
48304:     if (NS_SUCCEEDED(rv))
48304:         rv = WaitForRedirectCallback();
48304: 
48304:     if (NS_FAILED(rv)) {
49375:         AutoRedirectVetoNotifier notifier(this);
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirection);
48304:     }
48304: 
48304:     return rv;
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessRedirection(nsresult rv)
48304: {
49375:     AutoRedirectVetoNotifier notifier(this);
49375: 
48889:     LOG(("ContinueProcessRedirection [rv=%x]\n", rv));
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
48304: 
43113:     // Make sure to do this _after_ calling OnChannelRedirect
48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
43113: 
43113:     // And now, the deprecated way
43113:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
43113:     GetCallback(httpEventSink);
43113:     if (httpEventSink) {
43113:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
43113:         // versions.
48304:         rv = httpEventSink->OnRedirect(this, mRedirectChannel);
48304:         if (NS_FAILED(rv))
48304:             return rv;
43113:     }
43113:     // XXX we used to talk directly with the script security manager, but that
43113:     // should really be handled by the event sink implementation.
43113: 
43113:     // begin loading the new channel
48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
48304: 
48304:     if (NS_FAILED(rv))
48304:         return rv;
43113: 
43113:     // close down this channel
43113:     Cancel(NS_BINDING_REDIRECTED);
43113:     
49375:     notifier.RedirectSucceeded();
49375: 
43113:     // disconnect from our listener
43113:     mListener = 0;
43113:     mListenerContext = 0;
49375: 
43113:     // and from our callbacks
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <auth>
43113: //-----------------------------------------------------------------------------
43113: 
43832: NS_IMETHODIMP nsHttpChannel::OnAuthAvailable()
43113: {
43113:     LOG(("nsHttpChannel::OnAuthAvailable [this=%p]", this));
43113: 
43113:     // setting mAuthRetryPending flag and resuming the transaction
43113:     // triggers process of throwing away the unauthenticated data already
43113:     // coming from the network
80486:     mAuthRetryPending = true;
43113:     LOG(("Resuming the transaction, we got credentials from user"));
43113:     mTransactionPump->Resume();
43113:   
43113:     return NS_OK;
43113: }
43113: 
79445: NS_IMETHODIMP nsHttpChannel::OnAuthCancelled(bool userCancel)
43113: {
43832:     LOG(("nsHttpChannel::OnAuthCancelled [this=%p]", this));
43832: 
56438:     if (mTransactionPump) {
43832:         // ensure call of OnStartRequest of the current listener here,
43832:         // it would not be called otherwise at all
43832:         nsresult rv = CallOnStartRequest();
43832: 
43832:         // drop mAuthRetryPending flag and resume the transaction
43832:         // this resumes load of the unauthenticated content data
80486:         mAuthRetryPending = false;
43832:         LOG(("Resuming the transaction, user cancelled the auth dialog"));
43832:         mTransactionPump->Resume();
43832: 
43113:         if (NS_FAILED(rv))
43832:             mTransactionPump->Cancel(rv);
43832:     }
43832:     
43832:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsISupports
43113: //-----------------------------------------------------------------------------
43113: 
46790: NS_IMPL_ADDREF_INHERITED(nsHttpChannel, HttpBaseChannel)
46790: NS_IMPL_RELEASE_INHERITED(nsHttpChannel, HttpBaseChannel)
43113: 
43113: NS_INTERFACE_MAP_BEGIN(nsHttpChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIRequest)
43113:     NS_INTERFACE_MAP_ENTRY(nsIChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
43113:     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
43113:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannel)
46915:     NS_INTERFACE_MAP_ENTRY(nsICacheInfoChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsICachingChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel2)
43113:     NS_INTERFACE_MAP_ENTRY(nsICacheListener)
43113:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannelInternal)
43113:     NS_INTERFACE_MAP_ENTRY(nsIResumableChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsITransportEventSink)
43113:     NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
43113:     NS_INTERFACE_MAP_ENTRY(nsIProtocolProxyCallback)
43113:     NS_INTERFACE_MAP_ENTRY(nsIProxiedChannel)
43832:     NS_INTERFACE_MAP_ENTRY(nsIHttpAuthenticableChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheContainer)
43113:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheChannel)
48304:     NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
70188:     NS_INTERFACE_MAP_ENTRY(nsITimedChannel)
46790: NS_INTERFACE_MAP_END_INHERITING(HttpBaseChannel)
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIRequest
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::Cancel(nsresult status)
43113: {
43113:     LOG(("nsHttpChannel::Cancel [this=%p status=%x]\n", this, status));
43113:     if (mCanceled) {
43113:         LOG(("  ignoring; already canceled\n"));
43113:         return NS_OK;
43113:     }
48304:     if (mWaitingForRedirectCallback) {
48304:         LOG(("channel canceled during wait for redirect callback"));
48304:     }
80486:     mCanceled = true;
43113:     mStatus = status;
43113:     if (mProxyRequest)
43113:         mProxyRequest->Cancel(status);
43113:     if (mTransaction)
43113:         gHttpHandler->CancelTransaction(mTransaction, status);
43113:     if (mTransactionPump)
43113:         mTransactionPump->Cancel(status);
43113:     if (mCachePump)
43113:         mCachePump->Cancel(status);
43832:     if (mAuthProvider)
43832:         mAuthProvider->Cancel(status);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::Suspend()
43113: {
43113:     NS_ENSURE_TRUE(mIsPending, NS_ERROR_NOT_AVAILABLE);
43113:     
43113:     LOG(("nsHttpChannel::Suspend [this=%p]\n", this));
43113: 
43113:     ++mSuspendCount;
43113: 
43113:     if (mTransactionPump)
43113:         return mTransactionPump->Suspend();
43113:     if (mCachePump)
43113:         return mCachePump->Suspend();
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::Resume()
43113: {
43113:     NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
43113:     
43113:     LOG(("nsHttpChannel::Resume [this=%p]\n", this));
43113:         
71646:     if (--mSuspendCount == 0 && mCallOnResume) {
71646:         nsresult rv = AsyncCall(mCallOnResume);
71646:         mCallOnResume = nsnull;
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113:     }
43113: 
43113:     if (mTransactionPump)
43113:         return mTransactionPump->Resume();
43113:     if (mCachePump)
43113:         return mCachePump->Resume();
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetSecurityInfo(nsISupports **securityInfo)
43113: {
43113:     NS_ENSURE_ARG_POINTER(securityInfo);
43113:     *securityInfo = mSecurityInfo;
43113:     NS_IF_ADDREF(*securityInfo);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *context)
43113: {
43113:     LOG(("nsHttpChannel::AsyncOpen [this=%p]\n", this));
43113: 
43113:     NS_ENSURE_ARG_POINTER(listener);
43113:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     nsresult rv;
43113: 
49366:     if (mCanceled)
49366:         return mStatus;
49366: 
43113:     rv = NS_CheckPortSafety(mURI);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     if (!(mConnectionInfo && mConnectionInfo->UsingHttpProxy())) {
43113:         // Start a DNS lookup very early in case the real open is queued the DNS can 
43113:         // happen in parallel. Do not do so in the presence of an HTTP proxy as 
43113:         // all lookups other than for the proxy itself are done by the proxy.
70364:         //
70364:         // We keep the DNS prefetch object around so that we can retrieve
70364:         // timing information from it. There is no guarantee that we actually
70364:         // use the DNS prefetch data for the real connection, but as we keep
70364:         // this data around for 3 minutes by default, this should almost always
70364:         // be correct, and even when it isn't, the timing still represents _a_
70364:         // valid DNS lookup timing for the site, even if it is not _the_
70364:         // timing we used.
70364:         mDNSPrefetch = new nsDNSPrefetch(mURI, mTimingEnabled);
70364:         mDNSPrefetch->PrefetchHigh();
43113:     }
43113:     
43113:     // Remember the cookie header that was set, if any
43113:     const char *cookieHeader = mRequestHead.PeekHeader(nsHttp::Cookie);
46906:     if (cookieHeader) {
43113:         mUserSetCookieHeader = cookieHeader;
46906:     }
46906: 
43113:     AddCookiesToRequest();
43113: 
43113:     // notify "http-on-modify-request" observers
43113:     gHttpHandler->OnModifyRequest(this);
43113: 
43113:     // Adjust mCaps according to our request headers:
43113:     //  - If "Connection: close" is set as a request header, then do not bother
43113:     //    trying to establish a keep-alive connection.
43113:     if (mRequestHead.HasHeaderValue(nsHttp::Connection, "close"))
43113:         mCaps &= ~(NS_HTTP_ALLOW_KEEPALIVE | NS_HTTP_ALLOW_PIPELINING);
43113:     
43113:     if ((mLoadFlags & VALIDATE_ALWAYS) || 
43113:         (BYPASS_LOCAL_CACHE(mLoadFlags)))
43113:         mCaps |= NS_HTTP_REFRESH_DNS;
43113: 
74259:     // Force-Reload should reset the persistent connection pool for this host
74259:     if (mLoadFlags & LOAD_FRESH_CONNECTION)
74259:         mCaps |= NS_HTTP_CLEAR_KEEPALIVES;
74259:     
80486:     mIsPending = true;
80486:     mWasOpened = true;
43113: 
43113:     mListener = listener;
43113:     mListenerContext = context;
43113: 
43113:     // add ourselves to the load group.  from this point forward, we'll report
43113:     // all failures asynchronously.
43113:     if (mLoadGroup)
43113:         mLoadGroup->AddRequest(this, nsnull);
43113: 
70333:     // Collect mAsyncOpenTime after we have called all obsrevers like
70333:     // "http-on-modify-request" and load group observers that may set
70333:     // mTimingEnabled flag.
70333:     if (mTimingEnabled)
70333:         mAsyncOpenTime = mozilla::TimeStamp::Now();
70333: 
43113:     // We may have been cancelled already, either by on-modify-request
43113:     // listeners or by load group observers; in that case, we should
43113:     // not send the request to the server
43113:     if (mCanceled)
43113:         rv = mStatus;
43113:     else
43113:         rv = Connect();
43113:     if (NS_FAILED(rv)) {
43113:         LOG(("Calling AsyncAbort [rv=%x mCanceled=%i]\n", rv, mCanceled));
80486:         CloseCacheEntry(true);
43113:         AsyncAbort(rv);
47861:     } else if (mLoadFlags & LOAD_CLASSIFY_URI) {
43113:         nsRefPtr<nsChannelClassifier> classifier = new nsChannelClassifier();
43113:         if (!classifier) {
43113:             Cancel(NS_ERROR_OUT_OF_MEMORY);
43113:             return NS_OK;
43113:         }
43113: 
43113:         rv = classifier->Start(this);
43113:         if (NS_FAILED(rv)) {
43113:             Cancel(rv);
43113:         }
43113:     }
43113: 
43113:     return NS_OK;
43113: }
46790: 
43113: //-----------------------------------------------------------------------------
46790: // nsHttpChannel::nsIHttpChannelInternal
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
46790: nsHttpChannel::SetupFallbackChannel(const char *aFallbackKey)
43113: {
46790:     LOG(("nsHttpChannel::SetupFallbackChannel [this=%x, key=%s]",
46790:          this, aFallbackKey));
80486:     mFallbackChannel = true;
46790:     mFallbackKey = aFallbackKey;
46790: 
43113:     return NS_OK;
43113: }
52140: 
52140: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsISupportsPriority
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetPriority(PRInt32 value)
43113: {
81029:     PRInt16 newValue = clamped(value, PR_INT16_MIN, PR_INT16_MAX);
43113:     if (mPriority == newValue)
43113:         return NS_OK;
43113:     mPriority = newValue;
43113:     if (mTransaction)
43113:         gHttpHandler->RescheduleTransaction(mTransaction, mPriority);
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIProtocolProxyCallback
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIURI *uri,
43113:                                 nsIProxyInfo *pi, nsresult status)
43113: {
43113:     mProxyRequest = nsnull;
43113: 
43113:     // If status is a failure code, then it means that we failed to resolve
43113:     // proxy info.  That is a non-fatal error assuming it wasn't because the
43113:     // request was canceled.  We just failover to DIRECT when proxy resolution
43113:     // fails (failure can mean that the PAC URL could not be loaded).
43113:     
43113:     // Need to replace this channel with a new one.  It would be complex to try
43113:     // to change the value of mConnectionInfo since so much of our state may
43113:     // depend on its state.
43113:     mTargetProxyInfo = pi;
43113:     HandleAsyncReplaceWithProxy();
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIProxiedChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetProxyInfo(nsIProxyInfo **result)
43113: {
43113:     if (!mConnectionInfo)
43113:         *result = nsnull;
43113:     else {
43113:         *result = mConnectionInfo->ProxyInfo();
43113:         NS_IF_ADDREF(*result);
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
70188: // nsHttpChannel::nsITimedChannel
70188: //-----------------------------------------------------------------------------
70188: 
70188: NS_IMETHODIMP
79445: nsHttpChannel::SetTimingEnabled(bool enabled) {
70188:     mTimingEnabled = enabled;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
79445: nsHttpChannel::GetTimingEnabled(bool* _retval) {
70188:     *_retval = mTimingEnabled;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetChannelCreation(mozilla::TimeStamp* _retval) {
70188:     *_retval = mChannelCreationTimestamp;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetAsyncOpen(mozilla::TimeStamp* _retval) {
70188:     *_retval = mAsyncOpenTime;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetDomainLookupStart(mozilla::TimeStamp* _retval) {
70364:     if (mDNSPrefetch && mDNSPrefetch->TimingsValid())
70364:         *_retval = mDNSPrefetch->StartTimestamp();
70364:     else if (mTransaction)
70188:         *_retval = mTransaction->Timings().domainLookupStart;
70188:     else
70188:         *_retval = mTransactionTimings.domainLookupStart;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetDomainLookupEnd(mozilla::TimeStamp* _retval) {
70364:     if (mDNSPrefetch && mDNSPrefetch->TimingsValid())
70364:         *_retval = mDNSPrefetch->EndTimestamp();
70364:     else if (mTransaction)
70188:         *_retval = mTransaction->Timings().domainLookupEnd;
70188:     else
70188:         *_retval = mTransactionTimings.domainLookupEnd;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetConnectStart(mozilla::TimeStamp* _retval) {
70188:     if (mTransaction)
70188:         *_retval = mTransaction->Timings().connectStart;
70188:     else
70188:         *_retval = mTransactionTimings.connectStart;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetConnectEnd(mozilla::TimeStamp* _retval) {
70188:     if (mTransaction)
70188:         *_retval = mTransaction->Timings().connectEnd;
70188:     else
70188:         *_retval = mTransactionTimings.connectEnd;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetRequestStart(mozilla::TimeStamp* _retval) {
70188:     if (mTransaction)
70188:         *_retval = mTransaction->Timings().requestStart;
70188:     else
70188:         *_retval = mTransactionTimings.requestStart;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetResponseStart(mozilla::TimeStamp* _retval) {
70188:     if (mTransaction)
70188:         *_retval = mTransaction->Timings().responseStart;
70188:     else
70188:         *_retval = mTransactionTimings.responseStart;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetResponseEnd(mozilla::TimeStamp* _retval) {
70188:     if (mTransaction)
70188:         *_retval = mTransaction->Timings().responseEnd;
70188:     else
70188:         *_retval = mTransactionTimings.responseEnd;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetCacheReadStart(mozilla::TimeStamp* _retval) {
70188:     *_retval = mCacheReadStart;
70188:     return NS_OK;
70188: }
70188: 
70188: NS_IMETHODIMP
70188: nsHttpChannel::GetCacheReadEnd(mozilla::TimeStamp* _retval) {
70188:     *_retval = mCacheReadEnd;
70188:     return NS_OK;
70188: }
70188: 
70188: #define IMPL_TIMING_ATTR(name)                                 \
70188: NS_IMETHODIMP                                                  \
70188: nsHttpChannel::Get##name##Time(PRTime* _retval) {              \
70188:     mozilla::TimeStamp stamp;                                  \
70188:     Get##name(&stamp);                                         \
70188:     if (stamp.IsNull()) {                                      \
70188:         *_retval = 0;                                          \
70188:         return NS_OK;                                          \
70188:     }                                                          \
70188:     *_retval = mChannelCreationTime +                          \
70188:         (stamp - mChannelCreationTimestamp).ToSeconds() * 1e6; \
70188:     return NS_OK;                                              \
70188: }
70188: 
70188: IMPL_TIMING_ATTR(ChannelCreation)
70188: IMPL_TIMING_ATTR(AsyncOpen)
70188: IMPL_TIMING_ATTR(DomainLookupStart)
70188: IMPL_TIMING_ATTR(DomainLookupEnd)
70188: IMPL_TIMING_ATTR(ConnectStart)
70188: IMPL_TIMING_ATTR(ConnectEnd)
70188: IMPL_TIMING_ATTR(RequestStart)
70188: IMPL_TIMING_ATTR(ResponseStart)
70188: IMPL_TIMING_ATTR(ResponseEnd)
70188: IMPL_TIMING_ATTR(CacheReadStart)
70188: IMPL_TIMING_ATTR(CacheReadEnd)
70188: 
70188: #undef IMPL_TIMING_ATTR
70188: 
70188: //-----------------------------------------------------------------------------
43832: // nsHttpChannel::nsIHttpAuthenticableChannel
43832: //-----------------------------------------------------------------------------
43832: 
43832: NS_IMETHODIMP
79445: nsHttpChannel::GetIsSSL(bool *aIsSSL)
43832: {
43832:     *aIsSSL = mConnectionInfo->UsingSSL();
43832:     return NS_OK;
43832: }
43832: 
43832: NS_IMETHODIMP
79445: nsHttpChannel::GetProxyMethodIsConnect(bool *aProxyMethodIsConnect)
43832: {
43832:     *aProxyMethodIsConnect =
69816:         (mConnectionInfo->UsingHttpProxy() && mConnectionInfo->UsingSSL()) ||
69816:         mConnectionInfo->ShouldForceConnectMethod();
43832:     return NS_OK;
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetServerResponseHeader(nsACString &value)
43832: {
43832:     if (!mResponseHead)
43832:         return NS_ERROR_NOT_AVAILABLE;
43832:     return mResponseHead->GetHeader(nsHttp::Server, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetProxyChallenges(nsACString &value)
43832: {
43832:     if (!mResponseHead)
43832:         return NS_ERROR_UNEXPECTED;
43832:     return mResponseHead->GetHeader(nsHttp::Proxy_Authenticate, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetWWWChallenges(nsACString &value)
43832: {
43832:     if (!mResponseHead)
43832:         return NS_ERROR_UNEXPECTED;
43832:     return mResponseHead->GetHeader(nsHttp::WWW_Authenticate, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::SetProxyCredentials(const nsACString &value)
43832: {
43832:     return mRequestHead.SetHeader(nsHttp::Proxy_Authorization, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::SetWWWCredentials(const nsACString &value)
43832: {
43832:     return mRequestHead.SetHeader(nsHttp::Authorization, value);
43832: }
43832: 
43832: //-----------------------------------------------------------------------------
46909: // Methods that nsIHttpAuthenticableChannel dupes from other IDLs, which we
46909: // get from HttpBaseChannel, must be explicitly forwarded, because C++ sucks.
46909: //
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
46909: {
46909:     return HttpBaseChannel::GetLoadFlags(aLoadFlags);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetURI(nsIURI **aURI)
46909: {
46909:     return HttpBaseChannel::GetURI(aURI);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks)
46909: {
46909:     return HttpBaseChannel::GetNotificationCallbacks(aCallbacks);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetLoadGroup(nsILoadGroup **aLoadGroup)
46909: {
46909:     return HttpBaseChannel::GetLoadGroup(aLoadGroup);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetRequestMethod(nsACString& aMethod)
46909: {
46909:     return HttpBaseChannel::GetRequestMethod(aMethod);
46909: }
46909: 
46909: 
46909: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIRequestObserver
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
43113: {
43113:     if (!(mCanceled || NS_FAILED(mStatus))) {
43113:         // capture the request's status, so our consumers will know ASAP of any
43113:         // connection failures, etc - bug 93581
43113:         request->GetStatus(&mStatus);
43113:     }
43113: 
43113:     LOG(("nsHttpChannel::OnStartRequest [this=%p request=%p status=%x]\n",
43113:         this, request, mStatus));
43113: 
43113:     // Make sure things are what we expect them to be...
43113:     NS_ASSERTION(request == mCachePump || request == mTransactionPump,
43113:                  "Unexpected request");
43113:     NS_ASSERTION(!(mTransactionPump && mCachePump) || mCachedContentIsPartial,
43113:                  "If we have both pumps, the cache content must be partial");
43113: 
43113:     if (!mSecurityInfo && !mCachePump && mTransaction) {
43113:         // grab the security info from the connection object; the transaction
43113:         // is guaranteed to own a reference to the connection.
43113:         mSecurityInfo = mTransaction->SecurityInfo();
43113:     }
43113: 
43113:     // don't enter this block if we're reading from the cache...
43113:     if (NS_SUCCEEDED(mStatus) && !mCachePump && mTransaction) {
72347:         // mTransactionPump doesn't hit OnInputStreamReady and call this until
43113:         // all of the response headers have been acquired, so we can take ownership
43113:         // of them from the transaction.
43113:         mResponseHead = mTransaction->TakeResponseHead();
43113:         // the response head may be null if the transaction was cancelled.  in
43113:         // which case we just need to call OnStartRequest/OnStopRequest.
43113:         if (mResponseHead)
43113:             return ProcessResponse();
43113: 
43113:         NS_WARNING("No response head in OnStartRequest");
43113:     }
43113: 
43113:     // avoid crashing if mListener happens to be null...
43113:     if (!mListener) {
43113:         NS_NOTREACHED("mListener is null");
43113:         return NS_OK;
43113:     }
43113: 
43113:     // on proxy errors, try to failover
43113:     if (mConnectionInfo->ProxyInfo() &&
43113:        (mStatus == NS_ERROR_PROXY_CONNECTION_REFUSED ||
43113:         mStatus == NS_ERROR_UNKNOWN_PROXY_HOST ||
43113:         mStatus == NS_ERROR_NET_TIMEOUT)) {
48304: 
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest1);
43113:         if (NS_SUCCEEDED(ProxyFailover()))
43113:             return NS_OK;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest1);
48304:     }
48304: 
48304:     return ContinueOnStartRequest2(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueOnStartRequest1(nsresult result)
48304: {
48304:     // Success indicates we passed ProxyFailover, in that case we must not continue
48304:     // with this code chain.
48304:     if (NS_SUCCEEDED(result))
48304:         return NS_OK;
48304: 
48304:     return ContinueOnStartRequest2(result);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueOnStartRequest2(nsresult result)
48304: {
43113:     // on other request errors, try to fall back
48304:     if (NS_FAILED(mStatus)) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest3);
79445:         bool waitingForRedirectCallback;
54892:         ProcessFallback(&waitingForRedirectCallback);
48304:         if (waitingForRedirectCallback)
43113:             return NS_OK;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest3);
48304:     }
48304: 
48304:     return ContinueOnStartRequest3(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueOnStartRequest3(nsresult result)
48304: {
48304:     if (mFallingBack)
48304:         return NS_OK;
43113: 
43113:     return CallOnStartRequest();
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
43113: {
43113:     LOG(("nsHttpChannel::OnStopRequest [this=%p request=%p status=%x]\n",
43113:         this, request, status));
43113: 
70188:     if (mTimingEnabled && request == mCachePump) {
70188:         mCacheReadEnd = mozilla::TimeStamp::Now();
70188:     }
70188: 
63903:      // allow content to be cached if it was loaded successfully (bug #482935)
79445:      bool contentComplete = NS_SUCCEEDED(status);
63903: 
43113:     // honor the cancelation status even if the underlying transaction completed.
43113:     if (mCanceled || NS_FAILED(mStatus))
43113:         status = mStatus;
43113: 
43113:     if (mCachedContentIsPartial) {
43113:         if (NS_SUCCEEDED(status)) {
43113:             // mTransactionPump should be suspended
43113:             NS_ASSERTION(request != mTransactionPump,
43113:                 "byte-range transaction finished prematurely");
43113: 
43113:             if (request == mCachePump) {
79445:                 bool streamDone;
43113:                 status = OnDoneReadingPartialCacheEntry(&streamDone);
43113:                 if (NS_SUCCEEDED(status) && !streamDone)
43113:                     return status;
43113:                 // otherwise, fall through and fire OnStopRequest...
43113:             }
43113:             else
43113:                 NS_NOTREACHED("unexpected request");
43113:         }
43113:         // Do not to leave the transaction in a suspended state in error cases.
43113:         if (NS_FAILED(status) && mTransaction)
43113:             gHttpHandler->CancelTransaction(mTransaction, status); 
43113:     }
43113: 
43113:     if (mTransaction) {
43113:         // determine if we should call DoAuthRetry
79445:         bool authRetry = mAuthRetryPending && NS_SUCCEEDED(status);
43113: 
43113:         //
70090:         // grab references to connection in case we need to retry an
70090:         // authentication request over it or use it for an upgrade
70090:         // to another protocol.
43113:         //
43113:         // this code relies on the code in nsHttpTransaction::Close, which
43113:         // tests for NS_HTTP_STICKY_CONNECTION to determine whether or not to
43113:         // keep the connection around after the transaction is finished.
43113:         //
69895:         nsRefPtr<nsAHttpConnection> conn;
43113:         if (authRetry && (mCaps & NS_HTTP_STICKY_CONNECTION)) {
69895:             conn = mTransaction->Connection();
43113:             // This is so far a workaround to fix leak when reusing unpersistent
43113:             // connection for authentication retry. See bug 459620 comment 4
43113:             // for details.
43113:             if (conn && !conn->IsPersistent())
43113:                 conn = nsnull;
43113:         }
43113: 
70090:         nsRefPtr<nsAHttpConnection> stickyConn;
70090:         if (mCaps & NS_HTTP_STICKY_CONNECTION)
70090:             stickyConn = mTransaction->Connection();
70090:         
43113:         // at this point, we're done with the transaction
70188:         mTransactionTimings = mTransaction->Timings();
46790:         mTransaction = nsnull;
43113:         mTransactionPump = 0;
43113: 
70364:         // We no longer need the dns prefetch object
70364:         if (mDNSPrefetch && mDNSPrefetch->TimingsValid()) {
70364:             mTransactionTimings.domainLookupStart =
70364:                 mDNSPrefetch->StartTimestamp();
70364:             mTransactionTimings.domainLookupEnd =
70364:                 mDNSPrefetch->EndTimestamp();
70364:         }
70364:         mDNSPrefetch = nsnull;
70364: 
43113:         // handle auth retry...
43113:         if (authRetry) {
80486:             mAuthRetryPending = false;
43113:             status = DoAuthRetry(conn);
43113:             if (NS_SUCCEEDED(status))
43113:                 return NS_OK;
43113:         }
43113: 
43113:         // If DoAuthRetry failed, or if we have been cancelled since showing
43113:         // the auth. dialog, then we need to send OnStartRequest now
43113:         if (authRetry || (mAuthRetryPending && NS_FAILED(status))) {
43113:             NS_ASSERTION(NS_FAILED(status), "should have a failure code here");
43113:             // NOTE: since we have a failure status, we can ignore the return
43113:             // value from onStartRequest.
43113:             mListener->OnStartRequest(this, mListenerContext);
43113:         }
43113: 
43113:         // if this transaction has been replaced, then bail.
43113:         if (mTransactionReplaced)
43113:             return NS_OK;
70090:         
70090:         if (mUpgradeProtocolCallback && stickyConn &&
70090:             mResponseHead && mResponseHead->Status() == 101) {
70090:             nsCOMPtr<nsISocketTransport>    socketTransport;
70090:             nsCOMPtr<nsIAsyncInputStream>   socketIn;
70090:             nsCOMPtr<nsIAsyncOutputStream>  socketOut;
70090: 
70090:             nsresult rv;
70090:             rv = stickyConn->TakeTransport(getter_AddRefs(socketTransport),
70090:                                            getter_AddRefs(socketIn),
70090:                                            getter_AddRefs(socketOut));
70090:             if (NS_SUCCEEDED(rv))
70090:                 mUpgradeProtocolCallback->OnTransportAvailable(socketTransport,
70090:                                                                socketIn,
70090:                                                                socketOut);
70090:         }
43113:     }
43113: 
80486:     mIsPending = false;
43113:     mStatus = status;
43113: 
61191:     // perform any final cache operations before we close the cache entry.
61191:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
61191:         mRequestTimeInitialized){
61191:         FinalizeCacheEntry();
61191:     }
61191:     
43113:     if (mListener) {
43113:         LOG(("  calling OnStopRequest\n"));
43113:         mListener->OnStopRequest(this, mListenerContext, status);
43113:         mListener = 0;
43113:         mListenerContext = 0;
43113:     }
43113: 
80890:     if (mCacheEntry) {
80890:         bool asFile = false;
80890:         if (mInitedCacheEntry && !mCachedContentIsPartial &&
80890:             (NS_SUCCEEDED(mStatus) || contentComplete) &&
80890:             (mCacheAccess & nsICache::ACCESS_WRITE) &&
80890:             NS_SUCCEEDED(GetCacheAsFile(&asFile)) && asFile) {
80890:             // We can allow others access to the cache entry
80890:             // because we don't write to the cache anymore.
80890:             // CloseCacheEntry may not actually close the cache
80890:             // entry immediately because someone (such as XHR2
80890:             // blob response) may hold the token to the cache
80890:             // entry. So we mark the cache valid here.
80890:             // We also need to check the entry is stored as file
80890:             // because we write to the cache asynchronously when
80890:             // it isn't stored in the file and it isn't completely
80890:             // written to the disk yet.
80890:             mCacheEntry->MarkValid();
80890:         }
63903:         CloseCacheEntry(!contentComplete);
80890:     }
43113: 
43113:     if (mOfflineCacheEntry)
43113:         CloseOfflineCacheEntry();
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, status);
43113: 
63794:     // We don't need this info anymore
63794:     CleanRedirectCacheChainIfNecessary();
63794: 
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIStreamListener
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnDataAvailable(nsIRequest *request, nsISupports *ctxt,
43113:                                nsIInputStream *input,
43113:                                PRUint32 offset, PRUint32 count)
43113: {
43113:     LOG(("nsHttpChannel::OnDataAvailable [this=%p request=%p offset=%u count=%u]\n",
43113:         this, request, offset, count));
43113: 
43113:     // don't send out OnDataAvailable notifications if we've been canceled.
43113:     if (mCanceled)
43113:         return mStatus;
43113: 
43113:     NS_ASSERTION(mResponseHead, "No response head in ODA!!");
43113: 
43113:     NS_ASSERTION(!(mCachedContentIsPartial && (request == mTransactionPump)),
43113:             "transaction pump not suspended");
43113: 
43113:     if (mAuthRetryPending || (request == mTransactionPump && mTransactionReplaced)) {
43113:         PRUint32 n;
43113:         return input->ReadSegments(NS_DiscardSegment, nsnull, count, &n);
43113:     }
43113: 
43113:     if (mListener) {
43113:         //
43113:         // synthesize transport progress event.  we do this here since we want
43113:         // to delay OnProgress events until we start streaming data.  this is
43113:         // crucially important since it impacts the lock icon (see bug 240053).
43113:         //
43113:         nsresult transportStatus;
43113:         if (request == mCachePump)
43113:             transportStatus = nsITransport::STATUS_READING;
43113:         else
43113:             transportStatus = nsISocketTransport::STATUS_RECEIVING_FROM;
43113: 
43113:         // mResponseHead may reference new or cached headers, but either way it
43113:         // holds our best estimate of the total content length.  Even in the case
43113:         // of a byte range request, the content length stored in the cached
43113:         // response headers is what we want to use here.
43113: 
51740:         PRUint64 progressMax(PRUint64(mResponseHead->ContentLength()));
43113:         PRUint64 progress = mLogicalOffset + PRUint64(count);
43113:         NS_ASSERTION(progress <= progressMax, "unexpected progress values");
43113: 
43113:         OnTransportStatus(nsnull, transportStatus, progress, progressMax);
43113: 
43113:         //
43113:         // we have to manually keep the logical offset of the stream up-to-date.
43113:         // we cannot depend solely on the offset provided, since we may have 
43113:         // already streamed some data from another source (see, for example,
43113:         // OnDoneReadingPartialCacheEntry).
43113:         //
43113:         nsresult rv =  mListener->OnDataAvailable(this,
43113:                                                   mListenerContext,
43113:                                                   input,
43113:                                                   mLogicalOffset,
43113:                                                   count);
43113:         if (NS_SUCCEEDED(rv))
43113:             mLogicalOffset = progress;
43113:         return rv;
43113:     }
43113: 
43113:     return NS_ERROR_ABORT;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsITransportEventSink
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnTransportStatus(nsITransport *trans, nsresult status,
43113:                                  PRUint64 progress, PRUint64 progressMax)
43113: {
43113:     // cache the progress sink so we don't have to query for it each time.
43113:     if (!mProgressSink)
43113:         GetCallback(mProgressSink);
43113: 
67756:     if (status == nsISocketTransport::STATUS_CONNECTED_TO ||
67756:         status == nsISocketTransport::STATUS_WAITING_FOR) {
67756:         nsCOMPtr<nsISocketTransport> socketTransport =
67756:             do_QueryInterface(trans);
67756:         if (socketTransport) {
67756:             socketTransport->GetSelfAddr(&mSelfAddr);
67756:             socketTransport->GetPeerAddr(&mPeerAddr);
67756:         }
67756:     }
67756: 
43113:     // block socket status event after Cancel or OnStopRequest has been called.
43113:     if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending && !(mLoadFlags & LOAD_BACKGROUND)) {
43113:         LOG(("sending status notification [this=%p status=%x progress=%llu/%llu]\n",
43113:             this, status, progress, progressMax));
43113: 
43113:         nsCAutoString host;
43113:         mURI->GetHost(host);
43113:         mProgressSink->OnStatus(this, nsnull, status,
43113:                                 NS_ConvertUTF8toUTF16(host).get());
43113: 
43113:         if (progress > 0) {
43113:             NS_ASSERTION(progress <= progressMax, "unexpected progress values");
43113:             mProgressSink->OnProgress(this, nsnull, progress, progressMax);
43113:         }
43113:     }
43113: #ifdef DEBUG
43113:     else
43113:         LOG(("skipping status notification [this=%p sink=%p pending=%u background=%x]\n",
43113:             this, mProgressSink.get(), mIsPending, (mLoadFlags & LOAD_BACKGROUND)));
43113: #endif
43113: 
43113:     return NS_OK;
43113: } 
43113: 
43113: //-----------------------------------------------------------------------------
46915: // nsHttpChannel::nsICacheInfoChannel
46915: //-----------------------------------------------------------------------------
46915: 
46915: NS_IMETHODIMP
79445: nsHttpChannel::IsFromCache(bool *value)
46915: {
46915:     if (!mIsPending)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     // return false if reading a partial cache entry; the data isn't entirely
46915:     // from the cache!
46915: 
46915:     *value = (mCachePump || (mLoadFlags & LOAD_ONLY_IF_MODIFIED)) &&
46915:               mCachedContentIsValid && !mCachedContentIsPartial;
46915: 
46915:     return NS_OK;
46915: }
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::GetCacheTokenExpirationTime(PRUint32 *_retval)
46915: {
46915:     NS_ENSURE_ARG_POINTER(_retval);
46915:     if (!mCacheEntry)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     return mCacheEntry->GetExpirationTime(_retval);
46915: }
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::GetCacheTokenCachedCharset(nsACString &_retval)
46915: {
46915:     nsresult rv;
46915: 
46915:     if (!mCacheEntry)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     nsXPIDLCString cachedCharset;
46915:     rv = mCacheEntry->GetMetaDataElement("charset",
46915:                                          getter_Copies(cachedCharset));
46915:     if (NS_SUCCEEDED(rv))
46915:         _retval = cachedCharset;
46915: 
46915:     return rv;
46915: }
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::SetCacheTokenCachedCharset(const nsACString &aCharset)
46915: {
46915:     if (!mCacheEntry)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     return mCacheEntry->SetMetaDataElement("charset",
46915:                                            PromiseFlatCString(aCharset).get());
46915: }
46915: 
46915: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsICachingChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheToken(nsISupports **token)
43113: {
43113:     NS_ENSURE_ARG_POINTER(token);
43113:     if (!mCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     return CallQueryInterface(mCacheEntry, token);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetCacheToken(nsISupports *token)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetOfflineCacheToken(nsISupports **token)
43113: {
43113:     NS_ENSURE_ARG_POINTER(token);
43113:     if (!mOfflineCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     return CallQueryInterface(mOfflineCacheEntry, token);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetOfflineCacheToken(nsISupports *token)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: class nsHttpChannelCacheKey : public nsISupportsPRUint32,
43113:                               public nsISupportsCString
43113: {
43113:     NS_DECL_ISUPPORTS
43113: 
43113:     NS_DECL_NSISUPPORTSPRIMITIVE
43113:     NS_FORWARD_NSISUPPORTSPRUINT32(mSupportsPRUint32->)
43113:     
43113:     // Both interfaces declares toString method with the same signature.
43113:     // Thus we have to delegate only to nsISupportsPRUint32 implementation.
43113:     NS_SCRIPTABLE NS_IMETHOD GetData(nsACString & aData) 
43113:     { 
43113:         return mSupportsCString->GetData(aData);
43113:     }
43113:     NS_SCRIPTABLE NS_IMETHOD SetData(const nsACString & aData)
43113:     { 
43113:         return mSupportsCString->SetData(aData);
43113:     }
43113:     
43113: public:
43113:     nsresult SetData(PRUint32 aPostID, const nsACString& aKey);
43113: 
43113: protected:
43113:     nsCOMPtr<nsISupportsPRUint32> mSupportsPRUint32;
43113:     nsCOMPtr<nsISupportsCString> mSupportsCString;
43113: };
43113: 
43113: NS_IMPL_ADDREF(nsHttpChannelCacheKey)
43113: NS_IMPL_RELEASE(nsHttpChannelCacheKey)
43113: NS_INTERFACE_TABLE_HEAD(nsHttpChannelCacheKey)
43113: NS_INTERFACE_TABLE_BEGIN
43113: NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsHttpChannelCacheKey,
43113:                                    nsISupports, nsISupportsPRUint32)
43113: NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsHttpChannelCacheKey,
43113:                                    nsISupportsPrimitive, nsISupportsPRUint32)
43113: NS_INTERFACE_TABLE_ENTRY(nsHttpChannelCacheKey,
43113:                          nsISupportsPRUint32)
43113: NS_INTERFACE_TABLE_ENTRY(nsHttpChannelCacheKey,
43113:                          nsISupportsCString)
43113: NS_INTERFACE_TABLE_END
43113: NS_INTERFACE_TABLE_TAIL
43113: 
43113: NS_IMETHODIMP nsHttpChannelCacheKey::GetType(PRUint16 *aType)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aType);
43113: 
43113:     *aType = TYPE_PRUINT32;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult nsHttpChannelCacheKey::SetData(PRUint32 aPostID,
43113:                                         const nsACString& aKey)
43113: {
43113:     nsresult rv;
43113: 
43113:     mSupportsCString = 
43113:         do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mSupportsCString->SetData(aKey);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mSupportsPRUint32 = 
43113:         do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mSupportsPRUint32->SetData(aPostID);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheKey(nsISupports **key)
43113: {
43113:     nsresult rv;
43113:     NS_ENSURE_ARG_POINTER(key);
43113: 
43113:     LOG(("nsHttpChannel::GetCacheKey [this=%p]\n", this));
43113: 
43113:     *key = nsnull;
43113: 
43113:     nsRefPtr<nsHttpChannelCacheKey> container =
43113:         new nsHttpChannelCacheKey();
43113: 
43113:     if (!container)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     nsCAutoString cacheKey;
43113:     rv = GenerateCacheKey(mPostID, cacheKey);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = container->SetData(mPostID, cacheKey);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return CallQueryInterface(container.get(), key);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetCacheKey(nsISupports *key)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::SetCacheKey [this=%p key=%p]\n", this, key));
43113: 
43113:     // can only set the cache key if a load is not in progress
43113:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
43113: 
43113:     if (!key)
43113:         mPostID = 0;
43113:     else {
43113:         // extract the post id
43113:         nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(key, &rv);
43113:         if (NS_FAILED(rv)) return rv;
43113: 
43113:         rv = container->GetData(&mPostID);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::GetCacheAsFile(bool *value)
43113: {
43113:     NS_ENSURE_ARG_POINTER(value);
43113:     if (!mCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     nsCacheStoragePolicy storagePolicy;
43113:     mCacheEntry->GetStoragePolicy(&storagePolicy);
43113:     *value = (storagePolicy == nsICache::STORE_ON_DISK_AS_FILE);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::SetCacheAsFile(bool value)
43113: {
43113:     if (!mCacheEntry || mLoadFlags & INHIBIT_PERSISTENT_CACHING)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     nsCacheStoragePolicy policy;
43113:     if (value)
43113:         policy = nsICache::STORE_ON_DISK_AS_FILE;
43113:     else
43113:         policy = nsICache::STORE_ANYWHERE;
43113:     return mCacheEntry->SetStoragePolicy(policy);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::GetCacheForOfflineUse(bool *value)
43113: {
43113:     *value = mCacheForOfflineUse;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::SetCacheForOfflineUse(bool value)
43113: {
43113:     mCacheForOfflineUse = value;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetOfflineCacheClientID(nsACString &value)
43113: {
43113:     value = mOfflineCacheClientID;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetOfflineCacheClientID(const nsACString &value)
43113: {
43113:     mOfflineCacheClientID = value;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheFile(nsIFile **cacheFile)
43113: {
43113:     if (!mCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     return mCacheEntry->GetFile(cacheFile);
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIResumableChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::ResumeAt(PRUint64 aStartPos,
43113:                         const nsACString& aEntityID)
43113: {
43113:     LOG(("nsHttpChannel::ResumeAt [this=%p startPos=%llu id='%s']\n",
43113:          this, aStartPos, PromiseFlatCString(aEntityID).get()));
43113:     mEntityID = aEntityID;
43113:     mStartPos = aStartPos;
80486:     mResuming = true;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsICacheListener
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
43113:                                      nsCacheAccessMode access,
43113:                                      nsresult status)
43113: {
53987:     nsresult rv;
53987: 
43113:     LOG(("nsHttpChannel::OnCacheEntryAvailable [this=%p entry=%p "
43113:          "access=%x status=%x]\n", this, entry, access, status));
43113: 
43113:     // if the channel's already fired onStopRequest, then we should ignore
43113:     // this event.
43113:     if (!mIsPending)
43113:         return NS_OK;
43113: 
53987:     nsOnCacheEntryAvailableCallback callback = mOnCacheEntryAvailableCallback;
53987:     mOnCacheEntryAvailableCallback = nsnull;
53987: 
53987:     NS_ASSERTION(callback,
53987:         "nsHttpChannel::OnCacheEntryAvailable called without callback");
80486:     rv = ((*this).*callback)(entry, access, status, false);
53987: 
43113:     if (NS_FAILED(rv)) {
53987:         LOG(("AsyncOpenCacheEntry failed [rv=%x]\n", rv));
53987:         if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
53987:             // If we have a fallback URI (and we're not already
53987:             // falling back), process the fallback asynchronously.
53987:             if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
53987:                 rv = AsyncCall(&nsHttpChannel::HandleAsyncFallback);
53987:                 if (NS_SUCCEEDED(rv))
53987:                     return rv;
53987:             }
53987:         }
80486:         CloseCacheEntry(true);
43113:         AsyncAbort(rv);
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
43113: {
43113:     LOG(("nsHttpChannel::DoAuthRetry [this=%p]\n", this));
43113: 
43113:     NS_ASSERTION(!mTransaction, "should not have a transaction");
43113:     nsresult rv;
43113: 
43113:     // toggle mIsPending to allow nsIObserver implementations to modify
43113:     // the request headers (bug 95044).
80486:     mIsPending = false;
43113: 
43113:     // fetch cookies, and add them to the request header.
43113:     // the server response could have included cookies that must be sent with
43113:     // this authentication attempt (bug 84794).
46906:     // TODO: save cookies from auth response and send them here (bug 572151).
43113:     AddCookiesToRequest();
43113:     
43113:     // notify "http-on-modify-request" observers
43113:     gHttpHandler->OnModifyRequest(this);
43113: 
80486:     mIsPending = true;
43113: 
43113:     // get rid of the old response headers
43113:     mResponseHead = nsnull;
43113: 
43113:     // set sticky connection flag and disable pipelining.
43113:     mCaps |=  NS_HTTP_STICKY_CONNECTION;
43113:     mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
43113:    
43113:     // and create a new one...
43113:     rv = SetupTransaction();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // transfer ownership of connection to transaction
43113:     if (conn)
43113:         mTransaction->SetConnection(conn);
43113: 
43113:     // rewind the upload stream
43113:     if (mUploadStream) {
43113:         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
43113:         if (seekable)
43113:             seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
43113:     }
43113: 
43113:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     rv = mTransactionPump->AsyncRead(this, nsnull);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     PRUint32 suspendCount = mSuspendCount;
53987:     while (suspendCount--)
53987:         mTransactionPump->Suspend();
53987: 
53987:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIApplicationCacheChannel
43113: //-----------------------------------------------------------------------------
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetApplicationCache(nsIApplicationCache **out)
43113: {
43113:     NS_IF_ADDREF(*out = mApplicationCache);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetApplicationCache(nsIApplicationCache *appCache)
43113: {
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     mApplicationCache = appCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::GetLoadedFromApplicationCache(bool *aLoadedFromApplicationCache)
43113: {
43113:     *aLoadedFromApplicationCache = mLoadedFromApplicationCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::GetInheritApplicationCache(bool *aInherit)
43113: {
43113:     *aInherit = mInheritApplicationCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::SetInheritApplicationCache(bool aInherit)
43113: {
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     mInheritApplicationCache = aInherit;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::GetChooseApplicationCache(bool *aChoose)
43113: {
43113:     *aChoose = mChooseApplicationCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
79445: nsHttpChannel::SetChooseApplicationCache(bool aChoose)
43113: {
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     mChooseApplicationCache = aChoose;
43113:     return NS_OK;
43113: }
43113: 
56242: NS_IMETHODIMP
56242: nsHttpChannel::MarkOfflineCacheEntryAsForeign()
56242: {
56242:     if (!mApplicationCache)
56242:         return NS_ERROR_NOT_AVAILABLE;
56242: 
56242:     nsresult rv;
56242: 
56242:     nsCAutoString cacheKey;
56242:     rv = GenerateCacheKey(mPostID, cacheKey);
56242:     NS_ENSURE_SUCCESS(rv, rv);
56242: 
56242:     rv = mApplicationCache->MarkEntry(cacheKey,
56242:                                       nsIApplicationCache::ITEM_FOREIGN);
56242:     NS_ENSURE_SUCCESS(rv, rv);
56242: 
56242:     return NS_OK;
56242: }
56242: 
43113: //-----------------------------------------------------------------------------
48304: // nsHttpChannel::nsIAsyncVerifyRedirectCallback
48304: //-----------------------------------------------------------------------------
48304: 
48304: nsresult
48304: nsHttpChannel::WaitForRedirectCallback()
48304: {
48304:     nsresult rv;
50824:     LOG(("nsHttpChannel::WaitForRedirectCallback [this=%p]\n", this));
50824: 
48304:     if (mTransactionPump) {
48304:         rv = mTransactionPump->Suspend();
48304:         NS_ENSURE_SUCCESS(rv, rv);
48304:     }
48304:     if (mCachePump) {
48304:         rv = mCachePump->Suspend();
48304:         if (NS_FAILED(rv) && mTransactionPump) {
54892: #ifdef DEBUG
54892:             nsresult resume = 
54892: #endif
54892:             mTransactionPump->Resume();
48304:             NS_ASSERTION(NS_SUCCEEDED(resume),
48304:                 "Failed to resume transaction pump");
48304:         }
48304:         NS_ENSURE_SUCCESS(rv, rv);
48304:     }
48304: 
80486:     mWaitingForRedirectCallback = true;
48304:     return NS_OK;
48304: }
48304: 
48304: NS_IMETHODIMP
48304: nsHttpChannel::OnRedirectVerifyCallback(nsresult result)
48304: {
48889:     LOG(("nsHttpChannel::OnRedirectVerifyCallback [this=%p] "
48889:          "result=%x stack=%d mWaitingForRedirectCallback=%u\n",
48889:          this, result, mRedirectFuncStack.Length(), mWaitingForRedirectCallback));
48304:     NS_ASSERTION(mWaitingForRedirectCallback,
48304:                  "Someone forgot to call WaitForRedirectCallback() ?!");
80486:     mWaitingForRedirectCallback = false;
48304: 
48304:     if (mCanceled && NS_SUCCEEDED(result))
48304:         result = NS_BINDING_ABORTED;
48304: 
48304:     for (PRUint32 i = mRedirectFuncStack.Length(); i > 0;) {
48304:         --i;
48304:         // Pop the last function pushed to the stack
48304:         nsContinueRedirectionFunc func = mRedirectFuncStack[i];
48304:         mRedirectFuncStack.RemoveElementAt(mRedirectFuncStack.Length() - 1);
48304: 
48304:         // Call it with the result we got from the callback or the deeper
48304:         // function call.
48304:         result = (this->*func)(result);
48304: 
48304:         // If a new function has been pushed to the stack and placed us in the
48304:         // waiting state, we need to break the chain and wait for the callback
48304:         // again.
48304:         if (mWaitingForRedirectCallback)
48304:             break;
48304:     }
48304: 
48304:     if (NS_FAILED(result) && !mCanceled) {
48304:         // First, cancel this channel if we are in failure state to set mStatus
48304:         // and let it be propagated to pumps.
48304:         Cancel(result);
48304:     }
48304: 
48304:     if (!mWaitingForRedirectCallback) {
48304:         // We are not waiting for the callback. At this moment we must release
48304:         // reference to the redirect target channel, otherwise we may leak.
48304:         mRedirectChannel = nsnull;
48304:     }
48304: 
48304:     // We always resume the pumps here. If all functions on stack have been
48304:     // called we need OnStopRequest to be triggered, and if we broke out of the
48304:     // loop above (and are thus waiting for a new callback) the suspension
48304:     // count must be balanced in the pumps.
48304:     if (mTransactionPump)
48304:         mTransactionPump->Resume();
48304:     if (mCachePump)
48304:         mCachePump->Resume();
48304: 
48304:     return result;
48304: }
48304: 
48304: void
48304: nsHttpChannel::PushRedirectAsyncFunc(nsContinueRedirectionFunc func)
48304: {
48304:     mRedirectFuncStack.AppendElement(func);
48304: }
48304: 
48304: void
48304: nsHttpChannel::PopRedirectAsyncFunc(nsContinueRedirectionFunc func)
48304: {
48304:     NS_ASSERTION(func == mRedirectFuncStack[mRedirectFuncStack.Length() - 1],
48304:         "Trying to pop wrong method from redirect async stack!");
48304: 
48304:     mRedirectFuncStack.TruncateLength(mRedirectFuncStack.Length() - 1);
48304: }
48304: 
70436: 
48304: //-----------------------------------------------------------------------------
70436: // nsHttpChannel internal functions
43113: //-----------------------------------------------------------------------------
43113: 
43113: void
43113: nsHttpChannel::MaybeInvalidateCacheEntryForSubsequentGet()
43113: {
43113:     // See RFC 2616 section 5.1.1. These are considered valid
43113:     // methods which DO NOT invalidate cache-entries for the
43113:     // referred resource. POST, PUT and DELETE as well as any
43113:     // other method not listed here will potentially invalidate
43113:     // any cached copy of the resource
43113:     if (mRequestHead.Method() == nsHttp::Options ||
43113:        mRequestHead.Method() == nsHttp::Get ||
43113:        mRequestHead.Method() == nsHttp::Head ||
43113:        mRequestHead.Method() == nsHttp::Trace ||
43113:        mRequestHead.Method() == nsHttp::Connect)
43113:         return;
43113: 
71627: 
71627:     // Invalidate the request-uri.
71627:     // Pass 0 in first param to get the cache-key for a GET-request.
71627:     nsCAutoString tmpCacheKey;
71627:     GenerateCacheKey(0, tmpCacheKey);
71627:     LOG(("MaybeInvalidateCacheEntryForSubsequentGet [this=%p uri=%s]\n", 
71627:         this, tmpCacheKey.get()));
71627:     DoInvalidateCacheEntry(tmpCacheKey);
71627: 
71627:     // Invalidate Location-header if set
71627:     const char *location = mResponseHead->PeekHeader(nsHttp::Location);
71627:     if (location) {
71627:         LOG(("  Location-header=%s\n", location));
71627:         InvalidateCacheEntryForLocation(location);
71627:     }
71627: 
71627:     // Invalidate Content-Location-header if set
71627:     location = mResponseHead->PeekHeader(nsHttp::Content_Location);
71627:     if (location) {
71627:         LOG(("  Content-Location-header=%s\n", location));
71627:         InvalidateCacheEntryForLocation(location);
71627:     }
71627: }
71627: 
71627: void
71627: nsHttpChannel::InvalidateCacheEntryForLocation(const char *location)
71627: {
71627:     nsCAutoString tmpCacheKey, tmpSpec;
71627:     nsCOMPtr<nsIURI> resultingURI;
71627:     nsresult rv = CreateNewURI(location, getter_AddRefs(resultingURI));
71627:     if (NS_SUCCEEDED(rv) && HostPartIsTheSame(resultingURI)) {
71627:         if (NS_SUCCEEDED(resultingURI->GetAsciiSpec(tmpSpec))) {
71627:             location = tmpSpec.get();  //reusing |location|
71627: 
71627:             // key for a GET-request to |location| with current load-flags
71627:             AssembleCacheKey(location, 0, tmpCacheKey);
71627:             DoInvalidateCacheEntry(tmpCacheKey);
71627:         } else
71627:             NS_WARNING(("  failed getting ascii-spec\n"));
71627:     } else {
71627:         LOG(("  hosts not matching\n"));
71627:     }
71627: }
71627: 
71627: void
71627: nsHttpChannel::DoInvalidateCacheEntry(nsACString &key)
71627: {
43113:     // NOTE:
43113:     // Following comments 24,32 and 33 in bug #327765, we only care about
71627:     // the cache in the protocol-handler, not the application cache.
43113:     // The logic below deviates from the original logic in OpenCacheEntry on
43113:     // one point by using only READ_ONLY access-policy. I think this is safe.
71627: 
71627:     // First, find session holding the cache-entry - use current storage-policy
43113:     nsCOMPtr<nsICacheSession> session;
43113:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy();
43113: 
71627:     nsresult rv = gHttpHandler->GetCacheSession(storagePolicy,
43113:                                                 getter_AddRefs(session));
43113: 
71627:     if (NS_FAILED(rv))
71627:         return;
71627: 
71627:     // Now, find the actual cache-entry
43113:     nsCOMPtr<nsICacheEntryDescriptor> tmpCacheEntry;
71627:     rv = session->OpenCacheEntry(key, nsICache::ACCESS_READ,
80486:                                  false,
43113:                                  getter_AddRefs(tmpCacheEntry));
43113: 
43113:     // If entry was found, set its expiration-time = 0
43113:     if(NS_SUCCEEDED(rv)) {
43113:         tmpCacheEntry->SetExpirationTime(0);
71627:         LOG(("  cache-entry invalidated [key=%s]\n", key.Data()));
71627:     } else {
71627:         LOG(("  cache-entry not found [key=%s]\n", key.Data()));
43113:     }
43113: }
43113: 
43113: nsCacheStoragePolicy
43113: nsHttpChannel::DetermineStoragePolicy()
43113: {
43113:     nsCacheStoragePolicy policy = nsICache::STORE_ANYWHERE;
43113:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING)
43113:         policy = nsICache::STORE_IN_MEMORY;
43113: 
43113:     return policy;
43113: }
43113: 
53987: nsresult
53987: nsHttpChannel::DetermineCacheAccess(nsCacheAccessMode *_retval)
53987: {
79445:     bool offline = gIOService->IsOffline();
53987: 
53987:     if (offline || (mLoadFlags & INHIBIT_CACHING)) {
53987:         // If we have been asked to bypass the cache and not write to the
53987:         // cache, then don't use the cache at all.  Unless we're actually
53987:         // offline, which takes precedence over BYPASS_LOCAL_CACHE.
53987:         if (BYPASS_LOCAL_CACHE(mLoadFlags) && !offline)
53987:             return NS_ERROR_NOT_AVAILABLE;
53987:         *_retval = nsICache::ACCESS_READ;
53987:     }
53987:     else if (BYPASS_LOCAL_CACHE(mLoadFlags))
53987:         *_retval = nsICache::ACCESS_WRITE; // replace cache entry
53987:     else
53987:         *_retval = nsICache::ACCESS_READ_WRITE; // normal browsing
53987: 
53987:     return NS_OK;
53987: }
53987: 
43113: void
43113: nsHttpChannel::AsyncOnExamineCachedResponse()
43113: {
43113:     gHttpHandler->OnExamineCachedResponse(this);
43113: }
