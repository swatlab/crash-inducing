 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is Mozilla Communicator client code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Pierre Phaneuf <pp@ludusdesign.com>
 1:  *   Henri Sivonen <hsivonen@iki.fi>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: #include "nsCOMPtr.h"
 1: #include "nsXMLContentSink.h"
 1: #include "nsIParser.h"
 1: #include "nsIUnicharInputStream.h"
 1: #include "nsIDocument.h"
 1: #include "nsIDOMDocument.h"
 1: #include "nsIDOMDocumentType.h"
 1: #include "nsIDOMDOMImplementation.h"
 1: #include "nsIDOMNSDocument.h"
 1: #include "nsIContent.h"
 1: #include "nsIURI.h"
 1: #include "nsNetUtil.h"
 1: #include "nsIDocShell.h"
 1: #include "nsIDocShellTreeItem.h"
 1: #include "nsIContent.h"
 1: #include "nsIStyleSheetLinkingElement.h"
 1: #include "nsPresContext.h"
 1: #include "nsIPresShell.h"
 1: #include "nsIDOMComment.h"
 1: #include "nsIDOMCDATASection.h"
 1: #include "nsDOMDocumentType.h"
 1: #include "nsHTMLParts.h"
 1: #include "nsVoidArray.h"
 1: #include "nsCRT.h"
 1: #include "nsICSSLoader.h"
 1: #include "nsICSSStyleSheet.h"
 1: #include "nsGkAtoms.h"
 1: #include "nsContentUtils.h"
 1: #include "nsIScriptContext.h"
 1: #include "nsINameSpaceManager.h"
 1: #include "nsIServiceManager.h"
 1: #include "nsIScriptSecurityManager.h"
 1: #include "nsIContentViewer.h"
 1: #include "prtime.h"
 1: #include "prlog.h"
 1: #include "prmem.h"
 1: #include "nsParserUtils.h"
 1: #include "nsRect.h"
 1: #include "nsGenericElement.h"
 1: #include "nsIWebNavigation.h"
 1: #include "nsIScriptElement.h"
 1: #include "nsScriptLoader.h"
 1: #include "nsStyleLinkElement.h"
 1: #include "nsIImageLoadingContent.h"
 1: #include "nsReadableUtils.h"
 1: #include "nsUnicharUtils.h"
 1: #include "nsICookieService.h"
 1: #include "nsIPrompt.h"
 1: #include "nsIDOMWindowInternal.h"
 1: #include "nsIChannel.h"
 1: #include "nsIPrincipal.h"
 1: #include "nsXMLPrettyPrinter.h"
 1: #include "nsNodeInfoManager.h"
 1: #include "nsContentCreatorFunctions.h"
 1: #include "nsIContentPolicy.h"
 1: #include "nsContentPolicyUtils.h"
 1: #include "nsContentErrors.h"
 1: #include "nsIDOMProcessingInstruction.h"
 1: #include "nsNodeUtils.h"
 1: #include "nsIScriptGlobalObject.h"
 1: 
 1: #ifdef MOZ_SVG
 1: #include "nsGUIEvent.h"
 1: #endif
 1: 
 1: #define kXSLType "text/xsl"
 1: 
 1: // XXX Open Issues:
 1: // 1) what's not allowed - We need to figure out which HTML tags
 1: //    (prefixed with a HTML namespace qualifier) are explicitly not
 1: //    allowed (if any).
 1: // 2) factoring code with nsHTMLContentSink - There's some amount of
 1: //    common code between this and the HTML content sink. This will
 1: //    increase as we support more and more HTML elements. How can code
 1: //    from the code be factored?
 1: 
 1: nsresult
 1: NS_NewXMLContentSink(nsIXMLContentSink** aResult,
 1:                      nsIDocument* aDoc,
 1:                      nsIURI* aURI,
 1:                      nsISupports* aContainer,
 1:                      nsIChannel* aChannel)
 1: {
 1:   NS_PRECONDITION(nsnull != aResult, "null ptr");
 1:   if (nsnull == aResult) {
 1:     return NS_ERROR_NULL_POINTER;
 1:   }
 1:   nsXMLContentSink* it;
 1:   NS_NEWXPCOM(it, nsXMLContentSink);
 1:   if (nsnull == it) {
 1:     return NS_ERROR_OUT_OF_MEMORY;
 1:   }
 1:   
 1:   nsCOMPtr<nsIXMLContentSink> kungFuDeathGrip = it;
 1:   nsresult rv = it->Init(aDoc, aURI, aContainer, aChannel);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   
 1:   return CallQueryInterface(it, aResult);
 1: }
 1: 
 1: nsXMLContentSink::nsXMLContentSink()
 1:   : mConstrainSize(PR_TRUE),
 1:     mPrettyPrintXML(PR_TRUE),
 1:     mAllowAutoXLinks(PR_TRUE)
 1: {
 1: }
 1: 
 1: nsXMLContentSink::~nsXMLContentSink()
 1: {
 1:   if (mDocument) {
 1:     // Remove ourselves just to be safe, though we really should have
 1:     // been removed in DidBuildModel if everything worked right.
 1:     mDocument->RemoveObserver(this);
 1:   }
 1: 
 1:   NS_IF_RELEASE(mDocElement);
 1:   if (mText) {
 1:     PR_Free(mText);  //  Doesn't null out, unlike PR_FREEIF
 1:   }
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::Init(nsIDocument* aDoc,
 1:                        nsIURI* aURI,
 1:                        nsISupports* aContainer,
 1:                        nsIChannel* aChannel)
 1: {
 1:   MOZ_TIMER_DEBUGLOG(("Reset and start: nsXMLContentSink::Init(), this=%p\n",
 1:                       this));
 1:   MOZ_TIMER_RESET(mWatch);
 1:   MOZ_TIMER_START(mWatch);
 1: 	
 1:   nsresult rv = nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   aDoc->AddObserver(this);
 1: 
 1:   if (!mDocShell) {
 1:     mPrettyPrintXML = PR_FALSE;
 1:   }
 1:   
 1:   mState = eXMLContentSinkState_InProlog;
 1:   mDocElement = nsnull;
 1: 
 1:   MOZ_TIMER_DEBUGLOG(("Stop: nsXMLContentSink::Init()\n"));
 1:   MOZ_TIMER_STOP(mWatch);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMPL_ISUPPORTS_INHERITED7(nsXMLContentSink,
 1:                              nsContentSink,
 1:                              nsIContentSink,
 1:                              nsIXMLContentSink,
 1:                              nsIExpatSink,
 1:                              nsITimerCallback,
 1:                              nsIDocumentObserver,
 1:                              nsIMutationObserver,
 1:                              nsITransformObserver)
 1: 
 1: // nsIContentSink
 1: NS_IMETHODIMP
 1: nsXMLContentSink::WillTokenize(void)
 1: {
 1:   return WillProcessTokensImpl();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::WillBuildModel(void)
 1: {
 1:   WillBuildModelImpl();
 1: 
 1:   // Notify document that the load is beginning
 1:   mDocument->BeginLoad();
 1: 
 1:   // Check for correct load-command for maybe prettyprinting
 1:   if (mPrettyPrintXML) {
 1:     nsCAutoString command;
 1:     mParser->GetCommand(command);
 1:     if (!command.EqualsLiteral("view")) {
 1:       mPrettyPrintXML = PR_FALSE;
 1:     }
 1:   }
 1:   
 1:   return NS_OK;
 1: }
 1: 
 1: PRBool
 1: nsXMLContentSink::CanStillPrettyPrint()
 1: {
 1:   return mPrettyPrintXML &&
 1:          (!mPrettyPrintHasFactoredElements || mPrettyPrintHasSpecialRoot);
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::MaybePrettyPrint()
 1: {
 1:   if (!CanStillPrettyPrint()) {
 1:     mPrettyPrintXML = PR_FALSE;
 1: 
 1:     return NS_OK;
 1:   }
 1: 
 1:   // stop observing in order to avoid crashing when replacing content
 1:   mDocument->RemoveObserver(this);
 1: 
 1:   // Reenable the CSSLoader so that the prettyprinting stylesheets can load
 1:   if (mCSSLoader) {
 1:     mCSSLoader->SetEnabled(PR_TRUE);
 1:   }
 1:   
 1:   nsCOMPtr<nsXMLPrettyPrinter> printer;
 1:   nsresult rv = NS_NewXMLPrettyPrinter(getter_AddRefs(printer));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   return printer->PrettyPrint(mDocument);
 1: }
 1: 
 1: static void
 1: CheckXSLTParamPI(nsIDOMProcessingInstruction* aPi,
 1:                  nsIDocumentTransformer* aProcessor,
 1:                  nsIDocument* aDocument)
 1: {
 1:   nsAutoString target, data;
 1:   aPi->GetTarget(target);
 1: 
 1:   // Check for namespace declarations
 1:   if (target.EqualsLiteral("xslt-param-namespace")) {
 1:     aPi->GetData(data);
 1:     nsAutoString prefix, namespaceAttr;
 1:     nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::prefix,
 1:                                            prefix);
 1:     if (!prefix.IsEmpty() &&
 1:         nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::_namespace,
 1:                                                namespaceAttr)) {
 1:       aProcessor->AddXSLTParamNamespace(prefix, namespaceAttr);
 1:     }
 1:   }
 1: 
 1:   // Check for actual parameters
 1:   else if (target.EqualsLiteral("xslt-param")) {
 1:     aPi->GetData(data);
 1:     nsAutoString name, namespaceAttr, select, value;
 1:     nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::name,
 1:                                            name);
 1:     nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::_namespace,
 1:                                            namespaceAttr);
 1:     if (!nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::select, select)) {
 1:       select.SetIsVoid(PR_TRUE);
 1:     }
 1:     if (!nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::value, value)) {
 1:       value.SetIsVoid(PR_TRUE);
 1:     }
 1:     if (!name.IsEmpty()) {
 1:       nsCOMPtr<nsIDOMNode> doc = do_QueryInterface(aDocument);
 1:       aProcessor->AddXSLTParam(name, namespaceAttr, select, value, doc);
 1:     }
 1:   }
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::DidBuildModel()
 1: {
 1:   DidBuildModelImpl();
 1: 
 1:   if (mXSLTProcessor) {
 1:     // stop observing in order to avoid crashing when replacing content
 1:     mDocument->RemoveObserver(this);
 1: 
 1:     // Check for xslt-param and xslt-param-namespace PIs
 1:     PRUint32 i;
 1:     nsIContent* child;
 1:     for (i = 0; (child = mDocument->GetChildAt(i)); ++i) {
 1:       if (child->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
 1:         nsCOMPtr<nsIDOMProcessingInstruction> pi = do_QueryInterface(child);
 1:         CheckXSLTParamPI(pi, mXSLTProcessor, mDocument);
 1:       }
 1:       else if (child->IsNodeOfType(nsINode::eELEMENT)) {
 1:         // Only honor PIs in the prolog
 1:         break;
 1:       }
 1:     }
 1: 
 1:     nsCOMPtr<nsIDOMDocument> currentDOMDoc(do_QueryInterface(mDocument));
 1:     mXSLTProcessor->SetSourceContentModel(currentDOMDoc);
 1:     // Since the processor now holds a reference to us we drop our reference
 1:     // to it to avoid owning cycles
 1:     mXSLTProcessor = nsnull;
 1:   }
 1:   else {
 1:     // Kick off layout for non-XSLT transformed documents.
 1:     nsScriptLoader *loader = mDocument->GetScriptLoader();
 1:     if (loader) {
 1:       loader->RemoveObserver(this);
 1:     }
 1: 
 1:     if (mDocElement) {
 1:       // Notify document observers that all the content has been stuck
 1:       // into the document.
 1:       // XXX do we need to notify for things like PIs?  Or just the
 1:       // documentElement?
 1:       NS_ASSERTION(mDocument->IndexOf(mDocElement) != -1,
 1:                    "mDocElement not in doc?");
 1:     }
 1: 
 1:     // Check if we want to prettyprint
 1:     MaybePrettyPrint();
 1: 
 1:     StartLayout();
 1: 
 1:     ScrollToRef();
 1: 
 1:     mDocument->RemoveObserver(this);
 1: 
 1:     mDocument->EndLoad();
 1:   }
 1: 
 1:   DropParserAndPerfHint();
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::OnDocumentCreated(nsIDocument* aResultDocument)
 1: {
 1:   NS_ENSURE_ARG(aResultDocument);
 1: 
 1:   nsCOMPtr<nsIContentViewer> contentViewer;
 1:   mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
 1:   if (contentViewer) {
 1:     nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aResultDocument);
 1:     return contentViewer->SetDOMDocument(doc);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::OnTransformDone(nsresult aResult,
 1:                                   nsIDocument* aResultDocument)
 1: {
 1:   NS_ASSERTION(NS_FAILED(aResult) || aResultDocument,
 1:                "Don't notify about transform success without a document.");
 1: 
 1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aResultDocument);
 1: 
 1:   nsCOMPtr<nsIContentViewer> contentViewer;
 1:   mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
 1: 
 1:   if (NS_FAILED(aResult) && contentViewer) {
 1:     // Transform failed.
 1:     if (domDoc) {
 1:       // We have an error document.
 1:       contentViewer->SetDOMDocument(domDoc);
 1:     }
 1:     else {
 1:       // We don't have an error document, display the
 1:       // untransformed source document.
 1:       nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(mDocument);
 1:       contentViewer->SetDOMDocument(document);
 1:     }
 1:   }
 1: 
 1:   nsCOMPtr<nsIDocument> originalDocument = mDocument;
 1:   if (NS_SUCCEEDED(aResult) || aResultDocument) {
 1:     // Transform succeeded or it failed and we have an error
 1:     // document to display.
 1:     mDocument = aResultDocument;
 1:   }
 1: 
 1:   nsScriptLoader *loader = originalDocument->GetScriptLoader();
 1:   if (loader) {
 1:     loader->RemoveObserver(this);
 1:   }
 1: 
 1:   // Notify document observers that all the content has been stuck
 1:   // into the document.  
 1:   // XXX do we need to notify for things like PIs?  Or just the
 1:   // documentElement?
 1:   nsIContent *rootContent = mDocument->GetRootContent();
 1:   if (rootContent) {
 1:     NS_ASSERTION(mDocument->IndexOf(rootContent) != -1,
 1:                  "rootContent not in doc?");
 1:     mDocument->BeginUpdate(UPDATE_CONTENT_MODEL);
 1:     nsNodeUtils::ContentInserted(mDocument, rootContent,
 1:                                  mDocument->IndexOf(rootContent));
 1:     mDocument->EndUpdate(UPDATE_CONTENT_MODEL);
 1:   }
 1:   
 1:   // Start the layout process
 1:   StartLayout();
 1: 
 1:   ScrollToRef();
 1: 
 1:   originalDocument->EndLoad();
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::WillInterrupt(void)
 1: {
 1:   return WillInterruptImpl();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::WillResume(void)
 1: {
 1:   return WillResumeImpl();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::SetParser(nsIParser* aParser)
 1: {
 1:   mParser = aParser;
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::CreateElement(const PRUnichar** aAtts, PRUint32 aAttsCount,
 1:                                 nsINodeInfo* aNodeInfo, PRUint32 aLineNumber,
 1:                                 nsIContent** aResult, PRBool* aAppendContent)
 1: {
 1:   NS_ASSERTION(aNodeInfo, "can't create element without nodeinfo");
 1: 
 1:   *aResult = nsnull;
 1:   *aAppendContent = PR_TRUE;
 1:   nsresult rv = NS_OK;
 1: 
 1:   nsCOMPtr<nsIContent> content;
 1:   rv = NS_NewElement(getter_AddRefs(content), aNodeInfo->NamespaceID(),
 1:                      aNodeInfo);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (aNodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_XHTML)
 1: #ifdef MOZ_SVG
 1:       || aNodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_SVG)
 1: #endif
 1:     ) {
 1:     nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(content);
 1:     sele->SetScriptLineNumber(aLineNumber);
 1:     sele->WillCallDoneAddingChildren();
 1:     mConstrainSize = PR_FALSE;
 1:   }
 1: 
 1:   // XHTML needs some special attention
 1:   if (aNodeInfo->NamespaceEquals(kNameSpaceID_XHTML)) {
 1:     mPrettyPrintHasFactoredElements = PR_TRUE;
 1:   }
 1:   else {
 1:     // If we care, find out if we just used a special factory.
 1:     if (!mPrettyPrintHasFactoredElements && !mPrettyPrintHasSpecialRoot &&
 1:         mPrettyPrintXML) {
 1:       mPrettyPrintHasFactoredElements =
 1:         nsContentUtils::NameSpaceManager()->
 1:           HasElementCreator(aNodeInfo->NamespaceID());
 1:     }
 1: 
 1:     if (!aNodeInfo->NamespaceEquals(kNameSpaceID_SVG)) {
 1:       content.swap(*aResult);
 1: 
 1:       return NS_OK;
 1:     }
 1:   }
 1: 
 1:   if (aNodeInfo->Equals(nsGkAtoms::title, kNameSpaceID_XHTML)) {
 1:     if (mDocument && mDocument->GetDocumentTitle().IsVoid()) {
 1:       mInTitle = PR_TRUE; // The first title wins
 1:     }
 1:   }
 1: #ifdef MOZ_SVG
 1:   else if (aNodeInfo->Equals(nsGkAtoms::title, kNameSpaceID_SVG)) {
 1:     nsIContent* parent = GetCurrentContent();
 1:     if (mDocument && mDocument->GetDocumentTitle().IsVoid() &&
 1:         parent && parent == mDocElement &&
 1:         parent->NodeInfo()->Equals(nsGkAtoms::svg, kNameSpaceID_SVG)) {
 1:       mInTitle = PR_TRUE; // The first title wins
 1:     }
 1:   }
 1: #endif // MOZ_SVG
 1:   else if (aNodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML) ||
 1:            aNodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_XHTML) ||
 1:            aNodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_SVG)) {
 1:     nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(content));
 1:     if (ssle) {
 1:       ssle->InitStyleLinkElement(mParser, PR_FALSE);
 1:       ssle->SetEnableUpdates(PR_FALSE);
 1:       if (!aNodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML)) {
 1:         ssle->SetLineNumber(aLineNumber);
 1:       }
 1:     }
 1:   } 
 1: 
 1:   content.swap(*aResult);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: nsresult
 1: nsXMLContentSink::CloseElement(nsIContent* aContent)
 1: {
 1:   NS_ASSERTION(aContent, "missing element to close");
 1: 
 1:   nsINodeInfo *nodeInfo = aContent->NodeInfo();
 1: 
 1:   // Some HTML nodes need DoneAddingChildren() called to initialize
 1:   // properly (eg form state restoration).
 1:   if ((nodeInfo->NamespaceID() == kNameSpaceID_XHTML &&
 1:        (nodeInfo->NameAtom() == nsGkAtoms::select ||
 1:         nodeInfo->NameAtom() == nsGkAtoms::textarea ||
 1:         nodeInfo->NameAtom() == nsGkAtoms::object ||
 1:         nodeInfo->NameAtom() == nsGkAtoms::applet))
 1: #ifdef MOZ_XTF
 1:       || nodeInfo->NamespaceID() > kNameSpaceID_LastBuiltin
 1: #endif
 1:       ) {
 1:     aContent->DoneAddingChildren(PR_FALSE);
 1:   }
 1:   
 1:   if (IsMonolithicContainer(nodeInfo)) {
 1:     mInMonolithicContainer--;
 1:   }
 1: 
 1:   if (!nodeInfo->NamespaceEquals(kNameSpaceID_XHTML) &&
 1:       !nodeInfo->NamespaceEquals(kNameSpaceID_SVG)) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   nsresult rv = NS_OK;
 1: 
 1:   if (nodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_XHTML)
 1: #ifdef MOZ_SVG
 1:       || nodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_SVG)
 1: #endif
 1:     ) {
 1:     mConstrainSize = PR_TRUE; 
 1: 
 1:     // Now tell the script that it's ready to go. This may execute the script
 1:     // or return NS_ERROR_HTMLPARSER_BLOCK. Or neither if the script doesn't
 1:     // need executing.
 1:     rv = aContent->DoneAddingChildren(PR_TRUE);
 1: 
 1:     // If the act of insertion evaluated the script, we're fine.
 1:     // Else, block the parser till the script has loaded.
 1:     if (rv == NS_ERROR_HTMLPARSER_BLOCK) {
 1:       nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(aContent);
 1:       mScriptElements.AppendObject(sele);
 1:     }
 1: 
 1:     // If the parser got blocked, make sure to return the appropriate rv.
 1:     // I'm not sure if this is actually needed or not.
 1:     if (mParser && !mParser->IsParserEnabled()) {
 1:       // XXX The HTML sink doesn't call BlockParser here, why do we?
 1:       mParser->BlockParser();
 1:       rv = NS_ERROR_HTMLPARSER_BLOCK;
 1:     }
 1: 
 1:     return rv;
 1:   }
 1:   
 1:   if ((nodeInfo->Equals(nsGkAtoms::title, kNameSpaceID_XHTML)
 1: #ifdef MOZ_SVG
 1:        || nodeInfo->Equals(nsGkAtoms::title, kNameSpaceID_SVG)
 1: #endif // MOZ_SVG
 1:       ) && mInTitle) {
 1:     NS_ASSERTION(mDocument, "How did mInTitle get to be true if mDocument is null?");
 1:     // The first title wins
 1:     nsCOMPtr<nsIDOMNSDocument> dom_doc(do_QueryInterface(mDocument));
 1:     mTitleText.CompressWhitespace();
 1:     dom_doc->SetTitle(mTitleText);
 1:     mInTitle = PR_FALSE;
 1:   }
 1:   else if (nodeInfo->Equals(nsGkAtoms::base, kNameSpaceID_XHTML) &&
 1:            !mHasProcessedBase) {
 1:     // The first base wins
 1:     rv = ProcessBASETag(aContent);
 1:     mHasProcessedBase = PR_TRUE;
 1:   }
 1:   else if (nodeInfo->Equals(nsGkAtoms::meta, kNameSpaceID_XHTML) &&
 1:            // Need to check here to make sure this meta tag does not set
 1:            // mPrettyPrintXML to false when we have a special root!
 1:            (!mPrettyPrintXML || !mPrettyPrintHasSpecialRoot)) {
 1:     rv = ProcessMETATag(aContent);
 1:   }
 1:   else if (nodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML) ||
 1:            nodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_XHTML) ||
 1:            nodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_SVG)) {
 1:     nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(aContent));
 1:     if (ssle) {
 1:       ssle->SetEnableUpdates(PR_TRUE);
 1:       rv = ssle->UpdateStyleSheet(nsnull, nsnull);
 1:       if (rv == NS_ERROR_HTMLPARSER_BLOCK && mParser) {
 1:         mParser->BlockParser();
 1:       }
 1:     }
 1:   }
 1: 
 1:   return rv;
 1: }  
 1: 
 1: nsresult
 1: nsXMLContentSink::AddContentAsLeaf(nsIContent *aContent)
 1: {
 1:   nsresult result = NS_OK;
 1: 
 1:   if ((eXMLContentSinkState_InProlog == mState) ||
 1:       (eXMLContentSinkState_InEpilog == mState)) {
 1:     NS_ASSERTION(mDocument, "Fragments have no prolog or epilog");
 1:     mDocument->AppendChildTo(aContent, PR_FALSE);
 1:   }
 1:   else {
 1:     nsCOMPtr<nsIContent> parent = GetCurrentContent();
 1: 
 1:     if (parent) {
 1:       result = parent->AppendChildTo(aContent, PR_FALSE);
 1:     }
 1:   }
 1:   return result;
 1: }
 1: 
 1: // Create an XML parser and an XSL content sink and start parsing
 1: // the XSL stylesheet located at the given URI.
 1: nsresult
 1: nsXMLContentSink::LoadXSLStyleSheet(nsIURI* aUrl)
 1: {
 1:   mXSLTProcessor =
 1:     do_CreateInstance("@mozilla.org/document-transformer;1?type=xslt");
 1:   if (!mXSLTProcessor) {
 1:     // No XSLT processor available, continue normal document loading
 1:     return NS_OK;
 1:   }
 1: 
 1:   mXSLTProcessor->SetTransformObserver(this);
 1: 
 1:   nsCOMPtr<nsILoadGroup> loadGroup = mDocument->GetDocumentLoadGroup();
 1:   if (!loadGroup) {
 1:     mXSLTProcessor = nsnull;
 1:     return NS_ERROR_FAILURE;
 1:   }
 1: 
 1:   return mXSLTProcessor->LoadStyleSheet(aUrl, loadGroup,
 1:                                         mDocument->NodePrincipal());
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::ProcessStyleLink(nsIContent* aElement,
 1:                                    const nsSubstring& aHref,
 1:                                    PRBool aAlternate,
 1:                                    const nsSubstring& aTitle,
 1:                                    const nsSubstring& aType,
 1:                                    const nsSubstring& aMedia)
 1: {
 1:   nsresult rv = NS_OK;
 1:   mPrettyPrintXML = PR_FALSE;
 1: 
 1:   nsCAutoString cmd;
 1:   if (mParser)
 1:     mParser->GetCommand(cmd);
 1:   if (cmd.EqualsASCII(kLoadAsData))
 1:     return NS_OK; // Do not load stylesheets when loading as data
 1: 
 1:   NS_ConvertUTF16toUTF8 type(aType);
 1:   if (type.EqualsIgnoreCase(kXSLType) ||
 1:       type.EqualsIgnoreCase(kXMLTextContentType) ||
 1:       type.EqualsIgnoreCase(kXMLApplicationContentType)) {
 1:     if (aAlternate) {
 1:       // don't load alternate XSLT
 1:       return NS_OK;
 1:     }
 1:     // LoadXSLStyleSheet needs a mDocShell.
 1:     if (!mDocShell)
 1:       return NS_OK;
 1: 
 1:     nsCOMPtr<nsIURI> url;
 1:     rv = NS_NewURI(getter_AddRefs(url), aHref, nsnull, mDocumentBaseURI);
 1:     NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:     // Do security check
 1:     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
 1:     rv = secMan->
 1:       CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url,
 1:                                 nsIScriptSecurityManager::ALLOW_CHROME);
 1:     NS_ENSURE_SUCCESS(rv, NS_OK);
 1: 
 1:     rv = secMan->CheckSameOriginURI(mDocumentURI, url);
 1:     NS_ENSURE_SUCCESS(rv, NS_OK);
 1: 
 1:     // Do content policy check
 1:     PRInt16 decision = nsIContentPolicy::ACCEPT;
 1:     rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_STYLESHEET,
 1:                                    url,
 1:                                    mDocument->GetDocumentURI(),
 1:                                    aElement,
 1:                                    type,
 1:                                    nsnull,
 1:                                    &decision,
 1:                                    nsContentUtils::GetContentPolicy());
 1: 
 1:     NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:     if (NS_CP_REJECTED(decision)) {
 1:       return NS_OK;
 1:     }
 1: 
 1:     return LoadXSLStyleSheet(url);
 1:   }
 1: 
 1:   // Let nsContentSink deal with css.
 1:   rv = nsContentSink::ProcessStyleLink(aElement, aHref, aAlternate,
 1:                                        aTitle, aType, aMedia);
 1: 
 1:   if (rv == NS_ERROR_HTMLPARSER_BLOCK) {
 1:     if (mParser) {
 1:       mParser->BlockParser();
 1:     }
 1:     return NS_OK;
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::ProcessBASETag(nsIContent* aContent)
 1: {
 1:   NS_ASSERTION(aContent, "missing base-element");
 1: 
 1:   nsresult rv = NS_OK;
 1: 
 1:   if (mDocument) {
 1:     nsAutoString value;
 1:   
 1:     if (aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::target, value)) {
 1:       mDocument->SetBaseTarget(value);
 1:     }
 1: 
 1:     if (aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::href, value)) {
 1:       nsCOMPtr<nsIURI> baseURI;
 1:       rv = NS_NewURI(getter_AddRefs(baseURI), value);
 1:       if (NS_SUCCEEDED(rv)) {
 1:         rv = mDocument->SetBaseURI(baseURI); // The document checks if it is legal to set this base
 1:         if (NS_SUCCEEDED(rv)) {
 1:           mDocumentBaseURI = mDocument->GetBaseURI();
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP 
 1: nsXMLContentSink::SetDocumentCharset(nsACString& aCharset)
 1: {
 1:   if (mDocument) {
 1:     mDocument->SetDocumentCharacterSet(aCharset);
 1:   }
 1:   
 1:   return NS_OK;
 1: }
 1: 
 1: nsISupports *
 1: nsXMLContentSink::GetTarget()
 1: {
 1:   return mDocument;
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::FlushText(PRBool aCreateTextNode, PRBool* aDidFlush)
 1: {
 1:   nsresult rv = NS_OK;
 1:   PRBool didFlush = PR_FALSE;
 1:   if (0 != mTextLength) {
 1:     if (aCreateTextNode) {
 1:       nsCOMPtr<nsIContent> textContent;
 1:       rv = NS_NewTextNode(getter_AddRefs(textContent), mNodeInfoManager);
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:       // Set the text in the text node
 1:       textContent->SetText(mText, mTextLength, PR_FALSE);
 1: 
 1:       // Add text to its parent
 1:       AddContentAsLeaf(textContent);
 1:     }
 1:     mTextLength = 0;
 1:     didFlush = PR_TRUE;
 1:   }
 1: 
 1:   if (nsnull != aDidFlush) {
 1:     *aDidFlush = didFlush;
 1:   }
 1:   return rv;
 1: }
 1: 
 1: nsIContent*
 1: nsXMLContentSink::GetCurrentContent()
 1: {
 1:   if (mContentStack.Length() == 0) {
 1:     return nsnull;
 1:   }
 1:   return GetCurrentStackNode().mContent;
 1: }
 1: 
 1: StackNode &
 1: nsXMLContentSink::GetCurrentStackNode()
 1: {
 1:   PRInt32 count = mContentStack.Length();
 1:   NS_ASSERTION(count > 0, "Bogus Length()");
 1:   return mContentStack[count-1];
 1: }
 1: 
 1: 
 1: nsresult
 1: nsXMLContentSink::PushContent(nsIContent *aContent)
 1: {
 1:   NS_PRECONDITION(aContent, "Null content being pushed!");
 1:   StackNode *sn = mContentStack.AppendElement();
 1:   NS_ENSURE_TRUE(sn, NS_ERROR_OUT_OF_MEMORY);
 1: 
 1:   sn->mContent = aContent;
 1:   sn->mNumFlushed = 0;
 1:   return NS_OK;
 1: }
 1: 
 1: void
 1: nsXMLContentSink::PopContent()
 1: {
 1:   PRInt32 count = mContentStack.Length();
 1: 
 1:   if (count == 0) {
 1:     NS_WARNING("Popping empty stack");
 1:     return;
 1:   }
 1: 
 1:   mContentStack.RemoveElementAt(count - 1);
 1: }
 1: 
 1: void
 1: nsXMLContentSink::MaybeStartLayout()
 1: {
 1:   if (mLayoutStarted || mXSLTProcessor || CanStillPrettyPrint()) {
 1:     return;
 1:   }
 1:   StartLayout();
 1: }
 1: 
 1: void
 1: nsXMLContentSink::StartLayout()
 1: {
 1:   if (mLayoutStarted) {
 1:     return;
 1:   }
 1:   PRBool topLevelFrameset = PR_FALSE;
 1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
 1:   if (docShellAsItem) {
 1:     nsCOMPtr<nsIDocShellTreeItem> root;
 1:     docShellAsItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
 1:     if(docShellAsItem == root) {
 1:       topLevelFrameset = PR_TRUE;
 1:     }
 1:   }
 1:   
 1:   nsContentSink::StartLayout(topLevelFrameset);
 1: 
 1: }
 1: 
 1: #ifdef MOZ_MATHML
 1: ////////////////////////////////////////////////////////////////////////
 1: // MathML Element Factory - temporary location for bug 132844
 1: // Will be factored out post 1.0
 1: 
 1: nsresult
 1: NS_NewMathMLElement(nsIContent** aResult, nsINodeInfo* aNodeInfo)
 1: {
 1:   static const char kMathMLStyleSheetURI[] = "resource://gre/res/mathml.css";
 1: 
 1:   aNodeInfo->SetIDAttributeAtom(nsGkAtoms::id);
 1:   
 1:   // this bit of code is to load mathml.css on demand
 1:   nsIDocument *doc = aNodeInfo->GetDocument();
 1:   if (doc)
 1:     doc->EnsureCatalogStyleSheet(kMathMLStyleSheetURI);
 1: 
 1:   return NS_NewXMLElement(aResult, aNodeInfo);
 1: }
 1: #endif // MOZ_MATHML
 1: 
 1: 
 1: ////////////////////////////////////////////////////////////////////////
 1: 
 1: PRBool
 1: nsXMLContentSink::SetDocElement(PRInt32 aNameSpaceID,
 1:                                 nsIAtom* aTagName,
 1:                                 nsIContent *aContent)
 1: {
 1:   if (mDocElement)
 1:     return PR_FALSE;
 1: 
 1:   // check for root elements that needs special handling for
 1:   // prettyprinting
 1:   if ((aNameSpaceID == kNameSpaceID_XBL &&
 1:        aTagName == nsGkAtoms::bindings) ||
 1:       (aNameSpaceID == kNameSpaceID_XSLT &&
 1:        (aTagName == nsGkAtoms::stylesheet ||
 1:         aTagName == nsGkAtoms::transform))) {
 1:     mPrettyPrintHasSpecialRoot = PR_TRUE;
 1:     if (mPrettyPrintXML) {
 1:       // In this case, disable script execution, stylesheet
 1:       // loading, and auto XLinks since we plan to prettyprint.
 1:       mAllowAutoXLinks = PR_FALSE;
 1:       nsScriptLoader* scriptLoader = mDocument->GetScriptLoader();
 1:       if (scriptLoader) {
 1:         scriptLoader->SetEnabled(PR_FALSE);
 1:       }
 1:       if (mCSSLoader) {
 1:         mCSSLoader->SetEnabled(PR_FALSE);
 1:       }
 1:     }        
 1:   }
 1: 
 1:   mDocElement = aContent;
 1:   NS_ADDREF(mDocElement);
 1:   nsresult rv = mDocument->AppendChildTo(mDocElement, PR_TRUE);
 1:   if (NS_FAILED(rv)) {
 1:     // If we return PR_FALSE here, the caller will bail out because it won't
 1:     // find a parent content node to append to, which is fine.
 1:     return PR_FALSE;
 1:   }
 1:   return PR_TRUE;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsXMLContentSink::HandleStartElement(const PRUnichar *aName, 
 1:                                      const PRUnichar **aAtts, 
 1:                                      PRUint32 aAttsCount, 
 1:                                      PRInt32 aIndex, 
 1:                                      PRUint32 aLineNumber)
 1: {
 1:   NS_PRECONDITION(aIndex >= -1, "Bogus aIndex");
 1:   NS_PRECONDITION(aAttsCount % 2 == 0, "incorrect aAttsCount");
 1:   // Adjust aAttsCount so it's the actual number of attributes
 1:   aAttsCount /= 2;
 1: 
 1:   nsresult result = NS_OK;
 1:   PRBool appendContent = PR_TRUE;
 1:   nsCOMPtr<nsIContent> content;
 1: 
 1:   // XXX Hopefully the parser will flag this before we get
 1:   // here. If we're in the epilog, there should be no
 1:   // new elements
 1:   PR_ASSERT(eXMLContentSinkState_InEpilog != mState);
 1: 
 1:   FlushText();
 1:   DidAddContent();
 1: 
 1:   mState = eXMLContentSinkState_InDocumentElement;
 1: 
 1:   PRInt32 nameSpaceID;
 1:   nsCOMPtr<nsIAtom> prefix, localName;
 1:   nsContentUtils::SplitExpatName(aName, getter_AddRefs(prefix),
 1:                                  getter_AddRefs(localName), &nameSpaceID);
 1: 
 1:   if (!OnOpenContainer(aAtts, aAttsCount, nameSpaceID, localName, aLineNumber)) {
 1:     return NS_OK;
 1:   }
 1:   
 1:   nsCOMPtr<nsINodeInfo> nodeInfo;
 1:   result = mNodeInfoManager->GetNodeInfo(localName, prefix, nameSpaceID,
 1:                                          getter_AddRefs(nodeInfo));
 1:   NS_ENSURE_SUCCESS(result, result);
 1: 
 1:   result = CreateElement(aAtts, aAttsCount, nodeInfo, aLineNumber,
 1:                          getter_AddRefs(content), &appendContent);
 1:   NS_ENSURE_SUCCESS(result, result);
 1: 
 1:   // Set the ID attribute atom on the node info object for this node
 1:   // This must occur before the attributes are added so the name
 1:   // of the id attribute is known.
 1:   if (aIndex != -1 && NS_SUCCEEDED(result)) {
 1:     nsCOMPtr<nsIAtom> IDAttr = do_GetAtom(aAtts[aIndex]);
 1: 
 1:     if (IDAttr) {
 1:       nodeInfo->SetIDAttributeAtom(IDAttr);
 1:     }
 1:   }
 1:   
 1: #ifdef MOZ_XTF
 1:   if (nameSpaceID > kNameSpaceID_LastBuiltin)
 1:     content->BeginAddingChildren();
 1: #endif
 1: 
 1:   // Set the attributes on the new content element
 1:   result = AddAttributes(aAtts, content);
 1: 
 1:   if (NS_OK == result) {
 1:     // Store the element 
 1:     if (!SetDocElement(nameSpaceID, localName, content) && appendContent) {
 1:       nsCOMPtr<nsIContent> parent = GetCurrentContent();
 1:       NS_ENSURE_TRUE(parent, NS_ERROR_UNEXPECTED);
 1: 
 1:       parent->AppendChildTo(content, PR_FALSE);
 1:     }
 1: 
 1:     result = PushContent(content);
 1:     NS_ENSURE_SUCCESS(result, result);
 1:   }
 1: 
 1:   // Some HTML nodes need DoneCreatingElement() called to initialize
 1:   // properly (eg form state restoration).
 1:   if (nodeInfo->NamespaceID() == kNameSpaceID_XHTML &&
 1:       (nodeInfo->NameAtom() == nsGkAtoms::input ||
 1:        nodeInfo->NameAtom() == nsGkAtoms::button)) {
 1:     content->DoneCreatingElement();
 1:   }
 1: 
 1:   if (IsMonolithicContainer(nodeInfo)) {
 1:     mInMonolithicContainer++;
 1:   }
 1: 
 1:   MaybeStartLayout();
 1: 
 1:   return NS_SUCCEEDED(result) ? DidProcessATokenImpl() : result;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsXMLContentSink::HandleEndElement(const PRUnichar *aName)
 1: {
 1:   nsresult result = NS_OK;
 1: 
 1:   // XXX Hopefully the parser will flag this before we get
 1:   // here. If we're in the prolog or epilog, there should be
 1:   // no close tags for elements.
 1:   PR_ASSERT(eXMLContentSinkState_InDocumentElement == mState);
 1: 
 1:   FlushText();
 1: 
 1:   StackNode & sn = GetCurrentStackNode();
 1: 
 1:   nsCOMPtr<nsIContent> content;
 1:   sn.mContent.swap(content);
 1:   PRUint32 numFlushed = sn.mNumFlushed;
 1: 
 1:   PopContent();
 1:   NS_ASSERTION(content, "failed to pop content");
 1: #ifdef DEBUG
 1:   // Check that we're closing the right thing
 1:   nsCOMPtr<nsIAtom> debugNameSpacePrefix, debugTagAtom;
 1:   PRInt32 debugNameSpaceID;
 1:   nsContentUtils::SplitExpatName(aName, getter_AddRefs(debugNameSpacePrefix),
 1:                                  getter_AddRefs(debugTagAtom),
 1:                                  &debugNameSpaceID);
 1:   NS_ASSERTION(content->NodeInfo()->Equals(debugTagAtom, debugNameSpaceID),
 1:                "Wrong element being closed");
 1: #endif  
 1: 
 1:   result = CloseElement(content);
 1: 
 1:   if (mDocElement == content) {
 1:     // XXXbz for roots that don't want to be appended on open, we
 1:     // probably need to deal here.... (and stop appending them on open).
 1:     mState = eXMLContentSinkState_InEpilog;
 1:   }
 1: 
 1:   PRInt32 stackLen = mContentStack.Length();
 1:   if (mNotifyLevel >= stackLen) {
 1:     if (numFlushed < content->GetChildCount()) {
 1:     	  NotifyAppend(content, numFlushed);
 1:     }
 1:     mNotifyLevel = stackLen - 1;
 1:   }
 1:   DidAddContent();
 1: 
 1: #ifdef MOZ_SVG
 1:   if (content->GetNameSpaceID() == kNameSpaceID_SVG &&
 1:       content->HasAttr(kNameSpaceID_None, nsGkAtoms::onload)) {
 1:     nsEventStatus status = nsEventStatus_eIgnore;
 1:     nsEvent event(PR_TRUE, NS_SVG_LOAD);
 1:     event.eventStructType = NS_SVG_EVENT;
95:     nsCOMPtr<nsIPresShell> presShell = mDocument->GetShellAt(0);
 1:     if (presShell) {
 1:       FlushTags();
 1:       presShell->HandleDOMEventWithTarget(content, &event, &status);
 1:     }
 1:   }
 1: #endif
 1: 
 1:   return NS_SUCCEEDED(result) ? DidProcessATokenImpl() : result;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsXMLContentSink::HandleComment(const PRUnichar *aName)
 1: {
 1:   FlushText();
 1: 
 1:   nsCOMPtr<nsIContent> comment;
 1:   nsresult rv = NS_NewCommentNode(getter_AddRefs(comment), mNodeInfoManager);
 1:   if (comment) {
 1:     comment->SetText(nsDependentString(aName), PR_FALSE);
 1:     rv = AddContentAsLeaf(comment);
 1:     DidAddContent();
 1:   }
 1: 
 1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsXMLContentSink::HandleCDataSection(const PRUnichar *aData, 
 1:                                      PRUint32 aLength)
 1: {
 1:   // XSLT doesn't differentiate between text and cdata and wants adjacent
 1:   // textnodes merged, so add as text.
 1:   if (mXSLTProcessor) {
 1:     return AddText(aData, aLength);
 1:   }
 1: 
 1:   FlushText();
 1:   
 1:   if (mInTitle) {
 1:     mTitleText.Append(aData, aLength);
 1:   }
 1:   
 1:   nsCOMPtr<nsIContent> cdata;
 1:   nsresult rv = NS_NewXMLCDATASection(getter_AddRefs(cdata), mNodeInfoManager);
 1:   if (cdata) {
 1:     cdata->SetText(aData, aLength, PR_FALSE);
 1:     rv = AddContentAsLeaf(cdata);
 1:     DidAddContent();
 1:   }
 1: 
 1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::HandleDoctypeDecl(const nsAString & aSubset, 
 1:                                     const nsAString & aName, 
 1:                                     const nsAString & aSystemId, 
 1:                                     const nsAString & aPublicId,
 1:                                     nsISupports* aCatalogData)
 1: {
 1:   FlushText();
 1: 
 1:   nsresult rv = NS_OK;
 1: 
 1:   NS_ASSERTION(mDocument, "Shouldn't get here from a document fragment");
 1: 
 1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aName);
 1:   NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
 1: 
 1:   // Create a new doctype node
 1:   nsCOMPtr<nsIDOMDocumentType> docType;
 1:   rv = NS_NewDOMDocumentType(getter_AddRefs(docType), mNodeInfoManager, nsnull,
 1:                              name, nsnull, nsnull, aPublicId, aSystemId,
 1:                              aSubset);
 1:   if (NS_FAILED(rv) || !docType) {
 1:     return rv;
 1:   }
 1: 
 1:   if (aCatalogData && mCSSLoader && mDocument) {
 1:     // bug 124570 - we only expect additional agent sheets for now -- ignore
 1:     // exit codes, error are not fatal here, just that the stylesheet won't apply
 1:     nsCOMPtr<nsIURI> uri(do_QueryInterface(aCatalogData));
 1:     if (uri) {
 1:       nsCOMPtr<nsICSSStyleSheet> sheet;
 1:       mCSSLoader->LoadSheetSync(uri, PR_TRUE, getter_AddRefs(sheet));
 1:       
 1: #ifdef NS_DEBUG
 1:       nsCAutoString uriStr;
 1:       uri->GetSpec(uriStr);
 1:       printf("Loading catalog stylesheet: %s ... %s\n", uriStr.get(), sheet.get() ? "Done" : "Failed");
 1: #endif
 1:       if (sheet) {
 1:         mDocument->BeginUpdate(UPDATE_STYLE);
 1:         mDocument->AddCatalogStyleSheet(sheet);
 1:         mDocument->EndUpdate(UPDATE_STYLE);
 1:       }
 1:     }
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> content = do_QueryInterface(docType);
 1:   NS_ASSERTION(content, "doctype isn't content?");
 1: 
 1:   rv = mDocument->AppendChildTo(content, PR_FALSE);
 1:   DidAddContent();
 1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsXMLContentSink::HandleCharacterData(const PRUnichar *aData, 
 1:                                       PRUint32 aLength)
 1: {
 1:   nsresult rv = NS_OK;
 1:   if (aData && mState != eXMLContentSinkState_InProlog &&
 1:       mState != eXMLContentSinkState_InEpilog) {
 1:     rv = AddText(aData, aLength);
 1:   }
 1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::HandleProcessingInstruction(const PRUnichar *aTarget, 
 1:                                               const PRUnichar *aData)
 1: {
 1:   FlushText();
 1: 
 1:   const nsDependentString target(aTarget);
 1:   const nsDependentString data(aData);
 1: 
 1:   nsCOMPtr<nsIContent> node;
 1: 
 1:   nsresult rv = NS_NewXMLProcessingInstruction(getter_AddRefs(node),
 1:                                                mNodeInfoManager, target, data);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(node));
 1:   if (ssle) {
 1:     ssle->InitStyleLinkElement(mParser, PR_FALSE);
 1:     ssle->SetEnableUpdates(PR_FALSE);
 1:     mPrettyPrintXML = PR_FALSE;
 1:   }
 1: 
 1:   rv = AddContentAsLeaf(node);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   DidAddContent();
 1: 
 1:   if (ssle) {
 1:     ssle->SetEnableUpdates(PR_TRUE);
 1:     rv = ssle->UpdateStyleSheet(nsnull, nsnull);
 1: 
 1:     if (NS_FAILED(rv)) {
 1:       if (rv == NS_ERROR_HTMLPARSER_BLOCK && mParser) {
 1:         mParser->BlockParser();
 1:       }
 1:       return rv;
 1:     }
 1:   }
 1: 
 1:   // If it's not a CSS stylesheet PI...
 1:   nsAutoString type;
 1:   nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::type, type);
 1: 
 1:   if (mState != eXMLContentSinkState_InProlog ||
 1:       !target.EqualsLiteral("xml-stylesheet") ||
 1:       type.LowerCaseEqualsLiteral("text/css")) {
 1:     return DidProcessATokenImpl();
 1:   }
 1: 
 1:   nsAutoString href, title, media;
 1:   PRBool isAlternate = PR_FALSE;
 1:   ParsePIData(data, href, title, media, isAlternate);
 1: 
 1:   // If there was no href, we can't do anything with this PI
 1:   if (href.IsEmpty()) {
 1:       return DidProcessATokenImpl();
 1:   }
 1: 
 1:   rv = ProcessStyleLink(node, href, isAlternate, title, type, media);
 1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
 1: }
 1: 
 1: /* static */
 1: void
 1: nsXMLContentSink::ParsePIData(const nsString &aData, nsString &aHref,
 1:                               nsString &aTitle, nsString &aMedia,
 1:                               PRBool &aIsAlternate)
 1: {
 1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::href, aHref);
 1: 
 1:   // If there was no href, we can't do anything with this PI
 1:   if (aHref.IsEmpty()) {
 1:     return;
 1:   }
 1: 
 1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::title, aTitle);
 1: 
 1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::media, aMedia);
 1: 
 1:   nsAutoString alternate;
 1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::alternate, alternate);
 1: 
 1:   aIsAlternate = alternate.EqualsLiteral("yes");
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::HandleXMLDeclaration(const PRUnichar *aVersion,
 1:                                        const PRUnichar *aEncoding,
 1:                                        PRInt32 aStandalone)
 1: {
 1:   mDocument->SetXMLDeclaration(aVersion, aEncoding, aStandalone);
 1: 
 1:   return DidProcessATokenImpl();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsXMLContentSink::ReportError(const PRUnichar* aErrorText, 
 1:                               const PRUnichar* aSourceText,
 1:                               nsIScriptError *aError,
 1:                               PRBool *_retval)
 1: {
 1:   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 1:   nsresult rv = NS_OK;
 1: 
 1:   // The expat driver should report the error.  We're just cleaning up the mess.
 1:   *_retval = PR_TRUE;
 1:   
 1:   mPrettyPrintXML = PR_FALSE;
 1: 
 1:   mState = eXMLContentSinkState_InProlog;
 1: 
 1:   // XXX need to stop scripts here -- hsivonen
 1: 
 1:   // stop observing in order to avoid crashing when removing content
 1:   mDocument->RemoveObserver(this);
 1: 
 1:   // Clear the current content and
 1:   // prepare to set <parsererror> as the document root
 1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mDocument));
 1:   if (node) {
 1:     for (;;) {
 1:       nsCOMPtr<nsIDOMNode> child, dummy;
 1:       node->GetLastChild(getter_AddRefs(child));
 1:       if (!child)
 1:         break;
 1:       node->RemoveChild(child, getter_AddRefs(dummy));
 1:     }
 1:   }
 1:   NS_IF_RELEASE(mDocElement); 
 1: 
 1:   // Clear any buffered-up text we have.  It's enough to set the length to 0.
 1:   // The buffer itself is allocated when we're created and deleted in our
 1:   // destructor, so don't mess with it.
 1:   mTextLength = 0;
 1: 
 1:   if (mXSLTProcessor) {
 1:     // Get rid of the XSLT processor.
 1:     mXSLTProcessor->CancelLoads();
 1:     mXSLTProcessor = nsnull;
 1:   }
 1: 
 1:   // release the nodes on stack
 1:   mContentStack.Clear();
 1:   mNotifyLevel = 0;
 1: 
 1:   const PRUnichar* noAtts[] = { 0, 0 };
 1: 
 1:   NS_NAMED_LITERAL_STRING(errorNs,
 1:                           "http://www.mozilla.org/newlayout/xml/parsererror.xml");
 1: 
 1:   nsAutoString parsererror(errorNs);
 1:   parsererror.Append((PRUnichar)0xFFFF);
 1:   parsererror.AppendLiteral("parsererror");
 1:   
 1:   rv = HandleStartElement(parsererror.get(), noAtts, 0, -1, (PRUint32)-1);
 1:   NS_ENSURE_SUCCESS(rv,rv);
 1: 
 1:   rv = HandleCharacterData(aErrorText, nsCRT::strlen(aErrorText));
 1:   NS_ENSURE_SUCCESS(rv,rv);  
 1:   
 1:   nsAutoString sourcetext(errorNs);
 1:   sourcetext.Append((PRUnichar)0xFFFF);
 1:   sourcetext.AppendLiteral("sourcetext");
 1: 
 1:   rv = HandleStartElement(sourcetext.get(), noAtts, 0, -1, (PRUint32)-1);
 1:   NS_ENSURE_SUCCESS(rv,rv);
 1:   
 1:   rv = HandleCharacterData(aSourceText, nsCRT::strlen(aSourceText));
 1:   NS_ENSURE_SUCCESS(rv,rv);
 1:   
 1:   rv = HandleEndElement(sourcetext.get());
 1:   NS_ENSURE_SUCCESS(rv,rv); 
 1:   
 1:   rv = HandleEndElement(parsererror.get());
 1:   NS_ENSURE_SUCCESS(rv,rv);
 1: 
 1:   FlushTags();
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsXMLContentSink::AddAttributes(const PRUnichar** aAtts,
 1:                                 nsIContent* aContent)
 1: {
 1:   // Add tag attributes to the content attributes
 1:   nsCOMPtr<nsIAtom> prefix, localName;
 1:   while (*aAtts) {
 1:     PRInt32 nameSpaceID;
 1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
 1:                                    getter_AddRefs(localName), &nameSpaceID);
 1: 
 1:     // Add attribute to content
 1:     aContent->SetAttr(nameSpaceID, localName, prefix,
 1:                       nsDependentString(aAtts[1]), PR_FALSE);
 1:     aAtts += 2;
 1:   }
 1: 
 1:   // Give autoloading links a chance to fire
 1:   if (mDocShell && mAllowAutoXLinks) {
 1:     nsresult rv = aContent->MaybeTriggerAutoLink(mDocShell);
 1:     if (rv == NS_XML_AUTOLINK_REPLACE ||
 1:         rv == NS_XML_AUTOLINK_UNDEFINED) {
 1:       // If we do not terminate the parse, we just keep generating link trigger
 1:       // events. We want to parse only up to the first replace link, and stop.
 1:       mParser->Terminate();
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: #define NS_ACCUMULATION_BUFFER_SIZE 4096
 1: 
 1: nsresult
 1: nsXMLContentSink::AddText(const PRUnichar* aText, 
 1:                           PRInt32 aLength)
 1: {
 1: 
 1:   if (mInTitle) {
 1:     mTitleText.Append(aText,aLength);
 1:   }
 1: 
 1:   // Create buffer when we first need it
 1:   if (0 == mTextSize) {
 1:     mText = (PRUnichar *) PR_MALLOC(sizeof(PRUnichar) * NS_ACCUMULATION_BUFFER_SIZE);
 1:     if (nsnull == mText) {
 1:       return NS_ERROR_OUT_OF_MEMORY;
 1:     }
 1:     mTextSize = NS_ACCUMULATION_BUFFER_SIZE;
 1:   }
 1: 
 1:   const nsAString& str = Substring(aText, aText+aLength);
 1: 
 1:   // Copy data from string into our buffer; flush buffer when it fills up
 1:   PRInt32 offset = 0;
 1:   PRBool  isLastCharCR = PR_FALSE;
 1:   while (0 != aLength) {
 1:     PRInt32 amount = mTextSize - mTextLength;
 1:     if (amount > aLength) {
 1:       amount = aLength;
 1:     }
 1:     if (0 == amount) {
 1:       // XSLT wants adjacent textnodes merged.
 1:       if (mConstrainSize && !mXSLTProcessor) {
 1:         nsresult rv = FlushText();
 1:         if (NS_OK != rv) {
 1:           return rv;
 1:         }
 1:       }
 1:       else {
 1:         mTextSize += aLength;
 1:         mText = (PRUnichar *) PR_REALLOC(mText, sizeof(PRUnichar) * mTextSize);
 1:         if (nsnull == mText) {
 1:           return NS_ERROR_OUT_OF_MEMORY;
 1:         }
 1:       }
 1:     }
 1:     // Line breaks should not be normalized twice. See bug 343870.
 1:     mTextLength +=
 1:       nsContentUtils::CopyNewlineNormalizedUnicodeTo(str, 
 1:                                                      offset, 
 1:                                                      &mText[mTextLength], 
 1:                                                      amount,
 1:                                                      isLastCharCR);
 1:     offset  += amount;
 1:     aLength -= amount;
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: void
 1: nsXMLContentSink::FlushPendingNotifications(mozFlushType aType)
 1: {
 1:   // Only flush tags if we're not doing the notification ourselves
 1:   // (since we aren't reentrant)
 1:   if (!mInNotification) {
 1:     if (aType & Flush_SinkNotifications) {
 1:       FlushTags();
 1:     }
 1:     else {
 1:       FlushText();
 1:     }
 1:     if (aType & Flush_OnlyReflow) {
 1:       // Make sure that layout has started so that the reflow flush
 1:       // will actually happen.
 1:       MaybeStartLayout();
 1:     }
 1:   }
 1: }
 1: 
 1: /**
 1:  * NOTE!! Forked from SinkContext. Please keep in sync.
 1:  *
 1:  * Flush all elements that have been seen so far such that
 1:  * they are visible in the tree. Specifically, make sure
 1:  * that they are all added to their respective parents.
 1:  * Also, do notification at the top for all content that
 1:  * has been newly added so that the frame tree is complete.
 1:  */
 1: nsresult
 1: nsXMLContentSink::FlushTags()
 1: {
 1:   PRBool oldBeganUpdate = mBeganUpdate;
 1: 
 1:   ++mInNotification;
 1:   mozAutoDocUpdate updateBatch(mDocument, UPDATE_CONTENT_MODEL, PR_TRUE);
 1:   mBeganUpdate = PR_TRUE;
 1: 
 1:   // Don't release last text node in case we need to add to it again
 1:   FlushText();
 1: 
 1:   // Start from the base of the stack (growing downward) and do
 1:   // a notification from the node that is closest to the root of
 1:   // tree for any content that has been added.
 1: 
 1:   PRInt32 stackPos;
 1:   PRInt32 stackLen = mContentStack.Length();
 1:   PRBool flushed = PR_FALSE;
 1:   PRUint32 childCount;
 1:   nsIContent* content;
 1: 
 1:   for (stackPos = 0; stackPos < stackLen; ++stackPos) {
 1:     content = mContentStack[stackPos].mContent;
 1:     childCount = content->GetChildCount();
 1: 
 1:     if (!flushed && (mContentStack[stackPos].mNumFlushed < childCount)) {
 1:       NotifyAppend(content, mContentStack[stackPos].mNumFlushed);
 1:       flushed = PR_TRUE;
 1:     }
 1: 
 1:     mContentStack[stackPos].mNumFlushed = childCount;
 1:   }
 1:   mNotifyLevel = stackLen - 1;
 1: 
 1:   --mInNotification;
 1: 
 1:   mBeganUpdate = oldBeganUpdate;
 1:   
 1:   return NS_OK;
 1: }
 1: 
 1: /**
 1:  * NOTE!! Forked from SinkContext. Please keep in sync.
 1:  */
 1: void
 1: nsXMLContentSink::UpdateChildCounts()
 1: {
 1:   // Start from the top of the stack (growing upwards) and see if any
 1:   // new content has been appended. If so, we recognize that reflows
 1:   // have been generated for it and we should make sure that no
 1:   // further reflows occur.  Note that we have to include stackPos == 0
 1:   // to properly notify on kids of <html>.
 1:   PRInt32 stackLen = mContentStack.Length();
 1:   PRInt32 stackPos = stackLen - 1;
 1:   while (stackPos >= 0) {
 1:     StackNode & node = mContentStack[stackPos];
 1:     node.mNumFlushed = node.mContent->GetChildCount();
 1: 
 1:     stackPos--;
 1:   }
 1:   mNotifyLevel = stackLen - 1;
 1: }
 1: 
 1: PRBool
 1: nsXMLContentSink::IsMonolithicContainer(nsINodeInfo* aNodeInfo)
 1: {
 1:   return ((aNodeInfo->NamespaceID() == kNameSpaceID_XHTML &&
 1:           (aNodeInfo->NameAtom() == nsGkAtoms::tr ||
 1:            aNodeInfo->NameAtom() == nsGkAtoms::select ||
 1:            aNodeInfo->NameAtom() == nsGkAtoms::object ||
 1:            aNodeInfo->NameAtom() == nsGkAtoms::applet))
 1: #ifdef MOZ_MATHML
 1:        || (aNodeInfo->NamespaceID() == kNameSpaceID_MathML &&
 1:           (aNodeInfo->NameAtom() == nsGkAtoms::math))
 1: #endif
 1:           );
 1: }
