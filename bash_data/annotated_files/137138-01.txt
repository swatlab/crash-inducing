     1: /* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
     1: /* cairo - a vector graphics library with display and print output
     1:  *
     1:  * Copyright © 2002 University of Southern California
     1:  * Copyright © 2005 Red Hat, Inc.
     1:  *
     1:  * This library is free software; you can redistribute it and/or
     1:  * modify it either under the terms of the GNU Lesser General Public
     1:  * License version 2.1 as published by the Free Software Foundation
     1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
     1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
     1:  * notice, a recipient may use your version of this file under either
     1:  * the MPL or the LGPL.
     1:  *
     1:  * You should have received a copy of the LGPL along with this library
     1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 70960:  * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
     1:  * You should have received a copy of the MPL along with this library
     1:  * in the file COPYING-MPL-1.1
     1:  *
     1:  * The contents of this file are subject to the Mozilla Public License
     1:  * Version 1.1 (the "License"); you may not use this file except in
     1:  * compliance with the License. You may obtain a copy of the License at
     1:  * http://www.mozilla.org/MPL/
     1:  *
     1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
     1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
     1:  * the specific language governing rights and limitations.
     1:  *
     1:  * The Original Code is the cairo graphics library.
     1:  *
     1:  * The Initial Developer of the Original Code is University of Southern
     1:  * California.
     1:  *
     1:  * Contributor(s):
     1:  *	Carl D. Worth <cworth@cworth.org>
     1:  */
     1: 
     1: #include "cairoint.h"
     1: #include "cairo-private.h"
     1: 
     1: #include "cairo-arc-private.h"
 70960: #include "cairo-error-private.h"
     1: #include "cairo-path-private.h"
     1: 
 70960: /**
 70960:  * SECTION:cairo
 70960:  * @Title: cairo_t
 70960:  * @Short_Description: The cairo drawing context
 70960:  * @See_Also: #cairo_surface_t
 70960:  *
 70960:  * #cairo_t is the main object used when drawing with cairo. To
 70960:  * draw with cairo, you create a #cairo_t, set the target surface,
 70960:  * and drawing options for the #cairo_t, create shapes with
 70960:  * functions like cairo_move_to() and cairo_line_to(), and then
 70960:  * draw shapes with cairo_stroke() or cairo_fill().
 70960:  *
 70960:  * #cairo_t<!-- -->'s can be pushed to a stack via cairo_save().
 70960:  * They may then safely be changed, without loosing the current state.
 70960:  * Use cairo_restore() to restore to the saved state.
 70960:  */
 70960: 
 70960: /**
 70960:  * SECTION:cairo-text
 70960:  * @Title: text
 70960:  * @Short_Description: Rendering text and glyphs
 70960:  * @See_Also: #cairo_font_face_t, #cairo_scaled_font_t, cairo_text_path(),
 70960:  *            cairo_glyph_path()
 70960:  *
 70960:  * The functions with <emphasis>text</emphasis> in their name form cairo's
 70960:  * <firstterm>toy</firstterm> text API.  The toy API takes UTF-8 encoded
 70960:  * text and is limited in its functionality to rendering simple
 70960:  * left-to-right text with no advanced features.  That means for example
 70960:  * that most complex scripts like Hebrew, Arabic, and Indic scripts are
 70960:  * out of question.  No kerning or correct positioning of diacritical marks
 70960:  * either.  The font selection is pretty limited too and doesn't handle the
 70960:  * case that the selected font does not cover the characters in the text.
 70960:  * This set of functions are really that, a toy text API, for testing and
 70960:  * demonstration purposes.  Any serious application should avoid them.
 70960:  *
 70960:  * The functions with <emphasis>glyphs</emphasis> in their name form cairo's
 70960:  * <firstterm>low-level</firstterm> text API.  The low-level API relies on
 70960:  * the user to convert text to a set of glyph indexes and positions.  This
 70960:  * is a very hard problem and is best handled by external libraries, like
 70960:  * the pangocairo that is part of the Pango text layout and rendering library.
 70960:  * Pango is available from <ulink
 70960:  * url="http://www.pango.org/">http://www.pango.org/</ulink>.
 70960:  */
 70960: 
 70960: /**
 70960:  * SECTION:cairo-transforms
 70960:  * @Title: Transformations
 70960:  * @Short_Description: Manipulating the current transformation matrix
 70960:  * @See_Also: #cairo_matrix_t
 70960:  *
 70960:  * The current transformation matrix, <firstterm>ctm</firstterm>, is a
 70960:  * two-dimensional affine transformation that maps all coordinates and other
 70960:  * drawing instruments from the <firstterm>user space</firstterm> into the
 70960:  * surface's canonical coordinate system, also known as the <firstterm>device
 70960:  * space</firstterm>.
 70960:  */
 70960: 
 21379: #define CAIRO_TOLERANCE_MINIMUM	_cairo_fixed_to_double(1)
     1: 
 41340: #if !defined(INFINITY)
 41340: #define INFINITY HUGE_VAL
 41340: #endif
 41340: 
  4133: static const cairo_t _cairo_nil = {
  8452:   CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
     1:   CAIRO_STATUS_NO_MEMORY,	/* status */
   314:   { 0, 0, 0, NULL },		/* user_data */
   314:   NULL,				/* gstate */
 26419:   {{ 0 }, { 0 }},		/* gstate_tail */
 16122:   NULL,				/* gstate_freelist */
   314:   {{				/* path */
     1:     { 0, 0 },			/* last_move_point */
     1:     { 0, 0 },			/* current point */
     1:     FALSE,			/* has_current_point */
 70960:     FALSE,			/* has_last_move_point */
   314:     FALSE,			/* has_curve_to */
 32473:     FALSE,			/* is_box */
 41340:     FALSE,			/* maybe_fill_region */
 41340:     TRUE,			/* is_empty_fill */
 70960:     { {0, 0}, {0, 0}},		/* extents */
 32473:     {{{NULL,NULL}}}		/* link */
   314:   }}
     1: };
     1: 
 70960: static const cairo_t _cairo_nil__null_pointer = {
 70960:   CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */
 70960:   CAIRO_STATUS_NULL_POINTER,	/* status */
 70960:   { 0, 0, 0, NULL },		/* user_data */
 70960:   NULL,				/* gstate */
 70960:   {{ 0 }, { 0 }},		/* gstate_tail */
 70960:   NULL,				/* gstate_freelist */
 70960:   {{				/* path */
 70960:     { 0, 0 },			/* last_move_point */
 70960:     { 0, 0 },			/* current point */
 70960:     FALSE,			/* has_current_point */
 70960:     FALSE,			/* has_last_move_point */
 70960:     FALSE,			/* has_curve_to */
 70960:     FALSE,			/* is_box */
 70960:     FALSE,			/* maybe_fill_region */
 70960:     TRUE,			/* is_empty_fill */
 70960:     { {0, 0}, {0, 0}},		/* extents */
 70960:     {{{NULL,NULL}}}		/* link */
 70960:   }}
 70960: };
     1: #include <assert.h>
     1: 
     1: /**
     1:  * _cairo_error:
     1:  * @status: a status value indicating an error, (eg. not
 16122:  * %CAIRO_STATUS_SUCCESS)
     1:  *
     1:  * Checks that status is an error status, but does nothing else.
     1:  *
     1:  * All assignments of an error status to any user-visible object
     1:  * within the cairo application should result in a call to
     1:  * _cairo_error().
     1:  *
     1:  * The purpose of this function is to allow the user to set a
     1:  * breakpoint in _cairo_error() to generate a stack trace for when the
     1:  * user causes cairo to detect an error.
  8452:  *
  8452:  * Return value: the error status.
     1:  **/
  8452: cairo_status_t
     1: _cairo_error (cairo_status_t status)
     1: {
 26419:     CAIRO_ENSURE_UNIQUE;
 21379:     assert (_cairo_status_is_error (status));
  8452: 
  8452:     return status;
     1: }
     1: 
     1: /**
     1:  * _cairo_set_error:
     1:  * @cr: a cairo context
 16122:  * @status: a status value indicating an error
     1:  *
  8452:  * Atomically sets cr->status to @status and calls _cairo_error;
 16122:  * Does nothing if status is %CAIRO_STATUS_SUCCESS.
     1:  *
     1:  * All assignments of an error status to cr->status should happen
  8452:  * through _cairo_set_error(). Note that due to the nature of the atomic
  8452:  * operation, it is not safe to call this function on the nil objects.
     1:  *
     1:  * The purpose of this function is to allow the user to set a
     1:  * breakpoint in _cairo_error() to generate a stack trace for when the
     1:  * user causes cairo to detect an error.
     1:  **/
     1: static void
     1: _cairo_set_error (cairo_t *cr, cairo_status_t status)
     1: {
     1:     /* Don't overwrite an existing error. This preserves the first
  8452:      * error, which is the most significant. */
 32473:     _cairo_status_set_error (&cr->status, _cairo_error (status));
     1: }
     1: 
 32473: /* We keep a small stash of contexts to reduce malloc pressure */
 32473: #define CAIRO_STASH_SIZE 4
 70960: #if CAIRO_NO_MUTEX
 32473: static struct {
 32473:     cairo_t pool[CAIRO_STASH_SIZE];
 32473:     int occupied;
 32473: } _context_stash;
 32473: 
 32473: static cairo_t *
 32473: _context_get (void)
 32473: {
 70960:     int avail;
 70960: 
 70960:     avail = ffs (~_context_stash.occupied) - 1;
 32473:     if (avail >= CAIRO_STASH_SIZE)
 32473: 	return malloc (sizeof (cairo_t));
 32473: 
 70960:     _context_stash.occupied |= 1 << avail;
 32473:     return &_context_stash.pool[avail];
 32473: }
 32473: 
 32473: static void
 32473: _context_put (cairo_t *cr)
 32473: {
 32473:     if (cr < &_context_stash.pool[0] ||
 32473: 	cr >= &_context_stash.pool[CAIRO_STASH_SIZE])
 32473:     {
 32473: 	free (cr);
 32473: 	return;
 32473:     }
 32473: 
 70960:     _context_stash.occupied &= ~(1 << (cr - &_context_stash.pool[0]));
 41340: }
 41340: #elif HAS_ATOMIC_OPS
 41340: static struct {
 41340:     cairo_t pool[CAIRO_STASH_SIZE];
 41340:     cairo_atomic_int_t occupied;
 41340: } _context_stash;
 41340: 
 41340: static cairo_t *
 41340: _context_get (void)
 41340: {
 41340:     cairo_atomic_int_t avail, old, new;
 41340: 
 40590:     do {
 41340: 	old = _cairo_atomic_int_get (&_context_stash.occupied);
 41340: 	avail = ffs (~old) - 1;
 41340: 	if (avail >= CAIRO_STASH_SIZE)
 41340: 	    return malloc (sizeof (cairo_t));
 41340: 
 41340: 	new = old | (1 << avail);
 70960:     } while (! _cairo_atomic_int_cmpxchg (&_context_stash.occupied, old, new));
 41340: 
 41340:     return &_context_stash.pool[avail];
 41340: }
 41340: 
 41340: static void
 41340: _context_put (cairo_t *cr)
 41340: {
 41340:     cairo_atomic_int_t old, new, avail;
 41340: 
 41340:     if (cr < &_context_stash.pool[0] ||
 41340: 	cr >= &_context_stash.pool[CAIRO_STASH_SIZE])
 41340:     {
 41340: 	free (cr);
 41340: 	return;
 41340:     }
 41340: 
 41340:     avail = ~(1 << (cr - &_context_stash.pool[0]));
 41340:     do {
 41340: 	old = _cairo_atomic_int_get (&_context_stash.occupied);
 40574: 	new = old & avail;
 70960:     } while (! _cairo_atomic_int_cmpxchg (&_context_stash.occupied, old, new));
 32473: }
 32473: #else
 32473: #define _context_get() malloc (sizeof (cairo_t))
 32473: #define _context_put(cr) free (cr)
 32473: #endif
 32473: 
 70960: /* XXX This should disappear in favour of a common pool of error objects. */
 70960: static cairo_t *_cairo_nil__objects[CAIRO_STATUS_LAST_STATUS + 1];
 70960: 
 70960: static cairo_t *
 70960: _cairo_create_in_error (cairo_status_t status)
 70960: {
 70960:     cairo_t *cr;
 70960: 
 70960:     assert (status != CAIRO_STATUS_SUCCESS);
 70960: 
137138:     /* Sanity check */
137138:     if (status < 0 || status > CAIRO_STATUS_LAST_STATUS) {
137138:       abort();
137138:     }
137138: 
 70960:     /* special case OOM in order to avoid another allocation */
 70960:     switch ((int) status) {
 70960:     case CAIRO_STATUS_NO_MEMORY:
 70960: 	return (cairo_t *) &_cairo_nil;
 70960:     case CAIRO_STATUS_NULL_POINTER:
 70960: 	return (cairo_t *) &_cairo_nil__null_pointer;
 70960:     }
 70960: 
 70960:     CAIRO_MUTEX_LOCK (_cairo_error_mutex);
 70960:     cr = _cairo_nil__objects[status];
 70960:     if (cr == NULL) {
 70960: 	cr = malloc (sizeof (cairo_t));
 70960: 	if (unlikely (cr == NULL)) {
 70960: 	    CAIRO_MUTEX_UNLOCK (_cairo_error_mutex);
 70960: 	    _cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
 70960: 	    return (cairo_t *) &_cairo_nil;
 70960: 	}
 70960: 
 70960: 	*cr = _cairo_nil;
 70960: 	cr->status = status;
 70960: 	_cairo_nil__objects[status] = cr;
 70960:     }
 70960:     CAIRO_MUTEX_UNLOCK (_cairo_error_mutex);
 70960: 
 70960:     return cr;
 70960: }
 70960: 
 70960: void
 70960: _cairo_reset_static_data (void)
 70960: {
 70960:     int status;
 70960: 
 70960:     CAIRO_MUTEX_LOCK (_cairo_error_mutex);
 70960:     for (status = CAIRO_STATUS_SUCCESS;
 70960: 	 status <= CAIRO_STATUS_LAST_STATUS;
 70960: 	 status++)
 70960:     {
 70960: 	if (_cairo_nil__objects[status] != NULL) {
 70960: 	    free (_cairo_nil__objects[status]);
 70960: 	    _cairo_nil__objects[status] = NULL;
 70960: 	}
 70960:     }
 70960:     CAIRO_MUTEX_UNLOCK (_cairo_error_mutex);
 70960: }
 70960: 
     1: /**
     1:  * cairo_create:
     1:  * @target: target surface for the context
     1:  *
     1:  * Creates a new #cairo_t with all graphics state parameters set to
     1:  * default values and with @target as a target surface. The target
     1:  * surface should be constructed with a backend-specific function such
     1:  * as cairo_image_surface_create() (or any other
 16122:  * cairo_<emphasis>backend</emphasis>_surface_create() variant).
     1:  *
     1:  * This function references @target, so you can immediately
     1:  * call cairo_surface_destroy() on it if you don't need to
     1:  * maintain a separate reference to it.
     1:  *
     1:  * Return value: a newly allocated #cairo_t with a reference
     1:  *  count of 1. The initial reference count should be released
     1:  *  with cairo_destroy() when you are done using the #cairo_t.
     1:  *  This function never returns %NULL. If memory cannot be
     1:  *  allocated, a special #cairo_t object will be returned on
     1:  *  which cairo_status() returns %CAIRO_STATUS_NO_MEMORY.
     1:  *  You can use this object normally, but no drawing will
     1:  *  be done.
     1:  **/
     1: cairo_t *
     1: cairo_create (cairo_surface_t *target)
     1: {
     1:     cairo_t *cr;
  4133:     cairo_status_t status;
  4133: 
 70960:     if (unlikely (target == NULL))
 70960: 	return _cairo_create_in_error (_cairo_error (CAIRO_STATUS_NULL_POINTER));
 70960:     if (unlikely (target->status))
 70960: 	return _cairo_create_in_error (target->status);
     1: 
 32473:     cr = _context_get ();
 70960:     if (unlikely (cr == NULL))
 70960: 	return _cairo_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
  8452: 
  8452:     CAIRO_REFERENCE_COUNT_INIT (&cr->ref_count, 1);
     1: 
     1:     cr->status = CAIRO_STATUS_SUCCESS;
     1: 
   314:     _cairo_user_data_array_init (&cr->user_data);
  4133:     _cairo_path_fixed_init (cr->path);
  3847: 
 26419:     cr->gstate = &cr->gstate_tail[0];
 26419:     cr->gstate_freelist = &cr->gstate_tail[1];
 26419:     cr->gstate_tail[1].next = NULL;
 26419: 
  4133:     status = _cairo_gstate_init (cr->gstate, target);
 70960:     if (unlikely (status)) {
 70960: 	_context_put (cr);
 70960: 	cr = _cairo_create_in_error (status);
 70960:     }
     1: 
     1:     return cr;
     1: }
     1: slim_hidden_def (cairo_create);
     1: 
     1: /**
     1:  * cairo_reference:
     1:  * @cr: a #cairo_t
     1:  *
     1:  * Increases the reference count on @cr by one. This prevents
     1:  * @cr from being destroyed until a matching call to cairo_destroy()
     1:  * is made.
     1:  *
   314:  * The number of references to a #cairo_t can be get using
   314:  * cairo_get_reference_count().
   314:  *
     1:  * Return value: the referenced #cairo_t.
     1:  **/
     1: cairo_t *
     1: cairo_reference (cairo_t *cr)
     1: {
  8452:     if (cr == NULL || CAIRO_REFERENCE_COUNT_IS_INVALID (&cr->ref_count))
     1: 	return cr;
     1: 
  8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&cr->ref_count));
  8452: 
  8452:     _cairo_reference_count_inc (&cr->ref_count);
     1: 
     1:     return cr;
     1: }
     1: 
     1: /**
     1:  * cairo_destroy:
     1:  * @cr: a #cairo_t
     1:  *
     1:  * Decreases the reference count on @cr by one. If the result
     1:  * is zero, then @cr and all associated resources are freed.
     1:  * See cairo_reference().
     1:  **/
     1: void
     1: cairo_destroy (cairo_t *cr)
     1: {
 26419:     cairo_surface_t *surface;
 26419: 
  8452:     if (cr == NULL || CAIRO_REFERENCE_COUNT_IS_INVALID (&cr->ref_count))
     1: 	return;
     1: 
  8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&cr->ref_count));
  8452: 
  8452:     if (! _cairo_reference_count_dec_and_test (&cr->ref_count))
     1: 	return;
     1: 
 26419:     while (cr->gstate != &cr->gstate_tail[0]) {
 16122: 	if (_cairo_gstate_restore (&cr->gstate, &cr->gstate_freelist))
  4133: 	    break;
     1:     }
     1: 
 26419:     /* The context is expected (>99% of all use cases) to be held for the
 26419:      * duration of a single expose event/sequence of graphic operations.
 26419:      * Therefore, on destroy we explicitly flush the Cairo pipeline of any
 26419:      * pending operations.
 26419:      */
 26419:     surface = _cairo_gstate_get_original_target (cr->gstate);
 26419:     if (surface != NULL)
 26419: 	cairo_surface_flush (surface);
 26419: 
   314:     _cairo_gstate_fini (cr->gstate);
 26419:     cr->gstate_freelist = cr->gstate_freelist->next; /* skip over tail[1] */
 16122:     while (cr->gstate_freelist != NULL) {
 16122: 	cairo_gstate_t *gstate = cr->gstate_freelist;
 16122: 	cr->gstate_freelist = gstate->next;
 16122: 	free (gstate);
 16122:     }
   314: 
   314:     _cairo_path_fixed_fini (cr->path);
   314: 
   314:     _cairo_user_data_array_fini (&cr->user_data);
     1: 
 70960:     /* mark the context as invalid to protect against misuse */
 70960:     cr->status = CAIRO_STATUS_NULL_POINTER;
 70960: 
 32473:     _context_put (cr);
     1: }
     1: slim_hidden_def (cairo_destroy);
     1: 
     1: /**
   314:  * cairo_get_user_data:
   314:  * @cr: a #cairo_t
   314:  * @key: the address of the #cairo_user_data_key_t the user data was
   314:  * attached to
   314:  *
   314:  * Return user data previously attached to @cr using the specified
   314:  * key.  If no user data has been attached with the given key this
   314:  * function returns %NULL.
   314:  *
   314:  * Return value: the user data previously attached or %NULL.
   314:  *
   314:  * Since: 1.4
   314:  **/
   314: void *
   314: cairo_get_user_data (cairo_t			 *cr,
   314: 		     const cairo_user_data_key_t *key)
   314: {
   314:     return _cairo_user_data_array_get_data (&cr->user_data,
   314: 					    key);
   314: }
   314: 
   314: /**
   314:  * cairo_set_user_data:
   314:  * @cr: a #cairo_t
   314:  * @key: the address of a #cairo_user_data_key_t to attach the user data to
   314:  * @user_data: the user data to attach to the #cairo_t
   314:  * @destroy: a #cairo_destroy_func_t which will be called when the
   314:  * #cairo_t is destroyed or when new user data is attached using the
   314:  * same key.
   314:  *
   314:  * Attach user data to @cr.  To remove user data from a surface,
   314:  * call this function with the key that was used to set it and %NULL
   314:  * for @data.
   314:  *
   314:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
   314:  * slot could not be allocated for the user data.
   314:  *
   314:  * Since: 1.4
   314:  **/
   314: cairo_status_t
   314: cairo_set_user_data (cairo_t			 *cr,
   314: 		     const cairo_user_data_key_t *key,
   314: 		     void			 *user_data,
   314: 		     cairo_destroy_func_t	 destroy)
   314: {
  8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&cr->ref_count))
 21379: 	return cr->status;
   314: 
   314:     return _cairo_user_data_array_set_data (&cr->user_data,
   314: 					    key, user_data, destroy);
   314: }
   314: 
   314: /**
   314:  * cairo_get_reference_count:
   314:  * @cr: a #cairo_t
   314:  *
   314:  * Returns the current reference count of @cr.
   314:  *
   314:  * Return value: the current reference count of @cr.  If the
   314:  * object is a nil object, 0 will be returned.
   314:  *
   314:  * Since: 1.4
   314:  **/
   314: unsigned int
   314: cairo_get_reference_count (cairo_t *cr)
   314: {
  8452:     if (cr == NULL || CAIRO_REFERENCE_COUNT_IS_INVALID (&cr->ref_count))
   314: 	return 0;
   314: 
  8452:     return CAIRO_REFERENCE_COUNT_GET_VALUE (&cr->ref_count);
   314: }
   314: 
   314: /**
     1:  * cairo_save:
     1:  * @cr: a #cairo_t
     1:  *
     1:  * Makes a copy of the current state of @cr and saves it
     1:  * on an internal stack of saved states for @cr. When
     1:  * cairo_restore() is called, @cr will be restored to
     1:  * the saved state. Multiple calls to cairo_save() and
     1:  * cairo_restore() can be nested; each call to cairo_restore()
     1:  * restores the state from the matching paired cairo_save().
     1:  *
     1:  * It isn't necessary to clear all saved states before
     1:  * a #cairo_t is freed. If the reference count of a #cairo_t
     1:  * drops to zero in response to a call to cairo_destroy(),
     1:  * any saved states will be freed along with the #cairo_t.
     1:  **/
     1: void
     1: cairo_save (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 16122:     status = _cairo_gstate_save (&cr->gstate, &cr->gstate_freelist);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_save);
     1: 
     1: /**
     1:  * cairo_restore:
     1:  * @cr: a #cairo_t
     1:  *
     1:  * Restores @cr to the state saved by a preceding call to
     1:  * cairo_save() and removes that state from the stack of
     1:  * saved states.
     1:  **/
     1: void
     1: cairo_restore (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 16122:     status = _cairo_gstate_restore (&cr->gstate, &cr->gstate_freelist);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
   314: }
     1: slim_hidden_def(cairo_restore);
     1: 
     1: /**
     1:  * cairo_push_group:
     1:  * @cr: a cairo context
     1:  *
     1:  * Temporarily redirects drawing to an intermediate surface known as a
     1:  * group. The redirection lasts until the group is completed by a call
     1:  * to cairo_pop_group() or cairo_pop_group_to_source(). These calls
     1:  * provide the result of any drawing to the group as a pattern,
     1:  * (either as an explicit object, or set as the source pattern).
     1:  *
     1:  * This group functionality can be convenient for performing
     1:  * intermediate compositing. One common use of a group is to render
     1:  * objects as opaque within the group, (so that they occlude each
     1:  * other), and then blend the result with translucence onto the
     1:  * destination.
     1:  *
     1:  * Groups can be nested arbitrarily deep by making balanced calls to
     1:  * cairo_push_group()/cairo_pop_group(). Each call pushes/pops the new
     1:  * target group onto/from a stack.
     1:  *
     1:  * The cairo_push_group() function calls cairo_save() so that any
     1:  * changes to the graphics state will not be visible outside the
     1:  * group, (the pop_group functions call cairo_restore()).
     1:  *
     1:  * By default the intermediate group will have a content type of
 16122:  * %CAIRO_CONTENT_COLOR_ALPHA. Other content types can be chosen for
     1:  * the group by using cairo_push_group_with_content() instead.
     1:  *
     1:  * As an example, here is how one might fill and stroke a path with
     1:  * translucence, but without any portion of the fill being visible
     1:  * under the stroke:
     1:  *
     1:  * <informalexample><programlisting>
     1:  * cairo_push_group (cr);
     1:  * cairo_set_source (cr, fill_pattern);
     1:  * cairo_fill_preserve (cr);
     1:  * cairo_set_source (cr, stroke_pattern);
     1:  * cairo_stroke (cr);
     1:  * cairo_pop_group_to_source (cr);
     1:  * cairo_paint_with_alpha (cr, alpha);
     1:  * </programlisting></informalexample>
     1:  *
     1:  * Since: 1.2
     1:  */
     1: void
     1: cairo_push_group (cairo_t *cr)
     1: {
     1:     cairo_push_group_with_content (cr, CAIRO_CONTENT_COLOR_ALPHA);
     1: }
     1: 
     1: /**
     1:  * cairo_push_group_with_content:
     1:  * @cr: a cairo context
 32473:  * @content: a #cairo_content_t indicating the type of group that
     1:  *           will be created
     1:  *
     1:  * Temporarily redirects drawing to an intermediate surface known as a
     1:  * group. The redirection lasts until the group is completed by a call
     1:  * to cairo_pop_group() or cairo_pop_group_to_source(). These calls
     1:  * provide the result of any drawing to the group as a pattern,
     1:  * (either as an explicit object, or set as the source pattern).
     1:  *
     1:  * The group will have a content type of @content. The ability to
     1:  * control this content type is the only distinction between this
     1:  * function and cairo_push_group() which you should see for a more
     1:  * detailed description of group rendering.
     1:  *
     1:  * Since: 1.2
     1:  */
     1: void
     1: cairo_push_group_with_content (cairo_t *cr, cairo_content_t content)
     1: {
 70960:     cairo_surface_t *group_surface;
 70960:     cairo_clip_t *clip;
     1:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
  4133: 	return;
  4133: 
 70960:     clip = _cairo_gstate_get_clip (cr->gstate);
 70960:     if (clip->all_clipped) {
 70960: 	group_surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 0, 0);
 70960: 	status = group_surface->status;
 70960: 	if (unlikely (status))
 70960: 	    goto bail;
 70960:     } else {
 70960: 	cairo_surface_t *parent_surface;
 70960: 	const cairo_rectangle_int_t *clip_extents;
 70960: 	cairo_rectangle_int_t extents;
 70960:         cairo_matrix_t matrix;
 70960: 	cairo_bool_t is_empty;
 70960: 
 70918: 	parent_surface = _cairo_gstate_get_target (cr->gstate);
 70918: 
 70918: 	/* Get the extents that we'll use in creating our new group surface */
 70960: 	is_empty = _cairo_surface_get_extents (parent_surface, &extents);
 41340: 	clip_extents = _cairo_clip_get_extents (_cairo_gstate_get_clip (cr->gstate));
 41340: 	if (clip_extents != NULL)
 70960: 	    is_empty = _cairo_rectangle_intersect (&extents, clip_extents);
 41340: 
 41340: 	group_surface = _cairo_surface_create_similar_solid (parent_surface,
     1: 							     content,
  6154: 							     extents.width,
 41340: 							     extents.height,
 41340: 							     CAIRO_COLOR_TRANSPARENT,
 41340: 							     TRUE);
 41340: 	status = group_surface->status;
 26419: 	if (unlikely (status))
     1: 	    goto bail;
     1: 
     1: 	/* Set device offsets on the new surface so that logically it appears at
     1: 	 * the same location on the parent surface -- when we pop_group this,
     1: 	 * the source pattern will get fixed up for the appropriate target surface
     1: 	 * device offsets, so we want to set our own surface offsets from /that/,
     1: 	 * and not from the device origin. */
     1: 	cairo_surface_set_device_offset (group_surface,
  4133: 					 parent_surface->device_transform.x0 - extents.x,
  4133: 					 parent_surface->device_transform.y0 - extents.y);
     1: 
 32473: 	/* If we have a current path, we need to adjust it to compensate for
 32473: 	 * the device offset just applied. */
 70960:         cairo_matrix_init_translate (&matrix, -extents.x, -extents.y);
 70960: 	_cairo_path_fixed_transform (cr->path, &matrix);
 70960:     }
 32473: 
     1:     /* create a new gstate for the redirect */
     1:     cairo_save (cr);
 32473:     if (unlikely (cr->status))
     1: 	goto bail;
     1: 
  4133:     status = _cairo_gstate_redirect_target (cr->gstate, group_surface);
     1: 
     1: bail:
     1:     cairo_surface_destroy (group_surface);
 26419:     if (unlikely (status))
     1: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_push_group_with_content);
     1: 
     1: /**
     1:  * cairo_pop_group:
     1:  * @cr: a cairo context
     1:  *
     1:  * Terminates the redirection begun by a call to cairo_push_group() or
     1:  * cairo_push_group_with_content() and returns a new pattern
     1:  * containing the results of all drawing operations performed to the
     1:  * group.
     1:  *
     1:  * The cairo_pop_group() function calls cairo_restore(), (balancing a
     1:  * call to cairo_save() by the push_group function), so that any
     1:  * changes to the graphics state will not be visible outside the
     1:  * group.
     1:  *
     1:  * Return value: a newly created (surface) pattern containing the
     1:  * results of all drawing operations performed to the group. The
     1:  * caller owns the returned object and should call
     1:  * cairo_pattern_destroy() when finished with it.
     1:  *
     1:  * Since: 1.2
     1:  **/
     1: cairo_pattern_t *
     1: cairo_pop_group (cairo_t *cr)
     1: {
     1:     cairo_surface_t *group_surface, *parent_target;
 32473:     cairo_pattern_t *group_pattern;
 70960:     cairo_matrix_t group_matrix, device_transform_matrix;
 32473:     cairo_status_t status;
 32473: 
 32473:     if (unlikely (cr->status))
 32473: 	return _cairo_pattern_create_in_error (cr->status);
  4133: 
     1:     /* Grab the active surfaces */
     1:     group_surface = _cairo_gstate_get_target (cr->gstate);
     1:     parent_target = _cairo_gstate_get_parent_target (cr->gstate);
     1: 
     1:     /* Verify that we are at the right nesting level */
     1:     if (parent_target == NULL) {
     1: 	_cairo_set_error (cr, CAIRO_STATUS_INVALID_POP_GROUP);
 32473: 	return _cairo_pattern_create_in_error (CAIRO_STATUS_INVALID_POP_GROUP);
     1:     }
     1: 
     1:     /* We need to save group_surface before we restore; we don't need
     1:      * to reference parent_target and original_target, since the
     1:      * gstate will still hold refs to them once we restore. */
  4133:     group_surface = cairo_surface_reference (group_surface);
     1: 
     1:     cairo_restore (cr);
     1: 
 32473:     if (unlikely (cr->status)) {
 32473: 	group_pattern = _cairo_pattern_create_in_error (cr->status);
     1: 	goto done;
 32473:     }
     1: 
     1:     group_pattern = cairo_pattern_create_for_surface (group_surface);
 32473:     status = group_pattern->status;
 32473:     if (unlikely (status)) {
 32473: 	_cairo_set_error (cr, status);
     1:         goto done;
     1:     }
     1: 
     1:     _cairo_gstate_get_matrix (cr->gstate, &group_matrix);
 18904:     /* Transform by group_matrix centered around device_transform so that when
 18904:      * we call _cairo_gstate_copy_transformed_pattern the result is a pattern
 18904:      * with a matrix equivalent to the device_transform of group_surface. */
 18904:     if (_cairo_surface_has_device_transform (group_surface)) {
 18904: 	cairo_pattern_set_matrix (group_pattern, &group_surface->device_transform);
 18904: 	_cairo_pattern_transform (group_pattern, &group_matrix);
 18904: 	_cairo_pattern_transform (group_pattern, &group_surface->device_transform_inverse);
 18904:     } else {
     1: 	cairo_pattern_set_matrix (group_pattern, &group_matrix);
 18904:     }
 18904: 
 32473:     /* If we have a current path, we need to adjust it to compensate for
 32473:      * the device offset just removed. */
 70960:     cairo_matrix_multiply (&device_transform_matrix, 
 70960:                            &_cairo_gstate_get_target (cr->gstate)->device_transform,
 32473: 			   &group_surface->device_transform_inverse);
 70960:     _cairo_path_fixed_transform (cr->path, &device_transform_matrix);
 32473: 
     1: done:
     1:     cairo_surface_destroy (group_surface);
     1: 
     1:     return group_pattern;
     1: }
     1: slim_hidden_def(cairo_pop_group);
     1: 
     1: /**
     1:  * cairo_pop_group_to_source:
     1:  * @cr: a cairo context
     1:  *
     1:  * Terminates the redirection begun by a call to cairo_push_group() or
     1:  * cairo_push_group_with_content() and installs the resulting pattern
     1:  * as the source pattern in the given cairo context.
     1:  *
     1:  * The behavior of this function is equivalent to the sequence of
     1:  * operations:
     1:  *
     1:  * <informalexample><programlisting>
 11708:  * #cairo_pattern_t *group = cairo_pop_group (cr);
     1:  * cairo_set_source (cr, group);
     1:  * cairo_pattern_destroy (group);
     1:  * </programlisting></informalexample>
     1:  *
     1:  * but is more convenient as their is no need for a variable to store
     1:  * the short-lived pointer to the pattern.
     1:  *
     1:  * The cairo_pop_group() function calls cairo_restore(), (balancing a
     1:  * call to cairo_save() by the push_group function), so that any
     1:  * changes to the graphics state will not be visible outside the
     1:  * group.
     1:  *
     1:  * Since: 1.2
     1:  **/
     1: void
     1: cairo_pop_group_to_source (cairo_t *cr)
     1: {
     1:     cairo_pattern_t *group_pattern;
     1: 
     1:     group_pattern = cairo_pop_group (cr);
     1:     cairo_set_source (cr, group_pattern);
     1:     cairo_pattern_destroy (group_pattern);
     1: }
     1: 
     1: /**
     1:  * cairo_set_operator:
     1:  * @cr: a #cairo_t
     1:  * @op: a compositing operator, specified as a #cairo_operator_t
     1:  *
     1:  * Sets the compositing operator to be used for all drawing
     1:  * operations. See #cairo_operator_t for details on the semantics of
     1:  * each available compositing operator.
     1:  *
 13980:  * The default operator is %CAIRO_OPERATOR_OVER.
     1:  **/
     1: void
     1: cairo_set_operator (cairo_t *cr, cairo_operator_t op)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_operator (cr->gstate, op);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def (cairo_set_operator);
     1: 
 26419: 
 26419: static cairo_bool_t
 26419: _current_source_matches_solid (cairo_t *cr,
 26419: 			       double red,
 26419: 			       double green,
 26419: 			       double blue,
 26419: 			       double alpha)
 26419: {
 26419:     const cairo_pattern_t *current;
 26419:     cairo_color_t color;
 26419: 
 26419:     current = cr->gstate->source;
 26419:     if (current->type != CAIRO_PATTERN_TYPE_SOLID)
 26419: 	return FALSE;
 26419: 
 26419:     red   = _cairo_restrict_value (red,   0.0, 1.0);
 26419:     green = _cairo_restrict_value (green, 0.0, 1.0);
 26419:     blue  = _cairo_restrict_value (blue,  0.0, 1.0);
 26419:     alpha = _cairo_restrict_value (alpha, 0.0, 1.0);
 26419: 
 26419:     _cairo_color_init_rgba (&color, red, green, blue, alpha);
 26419:     return _cairo_color_equal (&color,
 26419: 			       &((cairo_solid_pattern_t *) current)->color);
 26419: }
     1: /**
     1:  * cairo_set_source_rgb
     1:  * @cr: a cairo context
     1:  * @red: red component of color
     1:  * @green: green component of color
     1:  * @blue: blue component of color
     1:  *
     1:  * Sets the source pattern within @cr to an opaque color. This opaque
     1:  * color will then be used for any subsequent drawing operation until
     1:  * a new source pattern is set.
     1:  *
     1:  * The color components are floating point numbers in the range 0 to
     1:  * 1. If the values passed in are outside that range, they will be
     1:  * clamped.
 13980:  *
 13980:  * The default source pattern is opaque black, (that is, it is
 13980:  * equivalent to cairo_set_source_rgb(cr, 0.0, 0.0, 0.0)).
     1:  **/
     1: void
     1: cairo_set_source_rgb (cairo_t *cr, double red, double green, double blue)
     1: {
     1:     cairo_pattern_t *pattern;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 26419:     if (_current_source_matches_solid (cr, red, green, blue, 1.))
 26419: 	return;
 26419: 
  4133:     /* push the current pattern to the freed lists */
 26419:     cairo_set_source (cr, (cairo_pattern_t *) &_cairo_pattern_black);
  4133: 
     1:     pattern = cairo_pattern_create_rgb (red, green, blue);
     1:     cairo_set_source (cr, pattern);
     1:     cairo_pattern_destroy (pattern);
     1: }
 32473: slim_hidden_def (cairo_set_source_rgb);
     1: 
     1: /**
     1:  * cairo_set_source_rgba:
     1:  * @cr: a cairo context
     1:  * @red: red component of color
     1:  * @green: green component of color
     1:  * @blue: blue component of color
     1:  * @alpha: alpha component of color
     1:  *
     1:  * Sets the source pattern within @cr to a translucent color. This
     1:  * color will then be used for any subsequent drawing operation until
     1:  * a new source pattern is set.
     1:  *
     1:  * The color and alpha components are floating point numbers in the
     1:  * range 0 to 1. If the values passed in are outside that range, they
     1:  * will be clamped.
 13980:  *
 13980:  * The default source pattern is opaque black, (that is, it is
 13980:  * equivalent to cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 1.0)).
     1:  **/
     1: void
     1: cairo_set_source_rgba (cairo_t *cr,
     1: 		       double red, double green, double blue,
     1: 		       double alpha)
     1: {
     1:     cairo_pattern_t *pattern;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 26419:     if (_current_source_matches_solid (cr, red, green, blue, alpha))
 26419: 	return;
 26419: 
  4133:     /* push the current pattern to the freed lists */
 26419:     cairo_set_source (cr, (cairo_pattern_t *) &_cairo_pattern_black);
  4133: 
     1:     pattern = cairo_pattern_create_rgba (red, green, blue, alpha);
     1:     cairo_set_source (cr, pattern);
     1:     cairo_pattern_destroy (pattern);
     1: }
     1: 
     1: /**
     1:  * cairo_set_source_surface:
     1:  * @cr: a cairo context
     1:  * @surface: a surface to be used to set the source pattern
     1:  * @x: User-space X coordinate for surface origin
     1:  * @y: User-space Y coordinate for surface origin
     1:  *
     1:  * This is a convenience function for creating a pattern from @surface
     1:  * and setting it as the source in @cr with cairo_set_source().
     1:  *
     1:  * The @x and @y parameters give the user-space coordinate at which
     1:  * the surface origin should appear. (The surface origin is its
     1:  * upper-left corner before any transformation has been applied.) The
 70960:  * @x and @y parameters are negated and then set as translation values
     1:  * in the pattern matrix.
     1:  *
     1:  * Other than the initial translation pattern matrix, as described
     1:  * above, all other pattern attributes, (such as its extend mode), are
     1:  * set to the default values as in cairo_pattern_create_for_surface().
     1:  * The resulting pattern can be queried with cairo_get_source() so
     1:  * that these attributes can be modified if desired, (eg. to create a
     1:  * repeating pattern with cairo_pattern_set_extend()).
     1:  **/
     1: void
     1: cairo_set_source_surface (cairo_t	  *cr,
     1: 			  cairo_surface_t *surface,
     1: 			  double	   x,
     1: 			  double	   y)
     1: {
     1:     cairo_pattern_t *pattern;
     1:     cairo_matrix_t matrix;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     /* push the current pattern to the freed lists */
 26419:     cairo_set_source (cr, (cairo_pattern_t *) &_cairo_pattern_black);
  4133: 
     1:     pattern = cairo_pattern_create_for_surface (surface);
     1: 
     1:     cairo_matrix_init_translate (&matrix, -x, -y);
     1:     cairo_pattern_set_matrix (pattern, &matrix);
     1: 
     1:     cairo_set_source (cr, pattern);
     1:     cairo_pattern_destroy (pattern);
     1: }
     1: slim_hidden_def (cairo_set_source_surface);
     1: 
     1: /**
     1:  * cairo_set_source
     1:  * @cr: a cairo context
     1:  * @source: a #cairo_pattern_t to be used as the source for
     1:  * subsequent drawing operations.
     1:  *
     1:  * Sets the source pattern within @cr to @source. This pattern
     1:  * will then be used for any subsequent drawing operation until a new
     1:  * source pattern is set.
     1:  *
     1:  * Note: The pattern's transformation matrix will be locked to the
     1:  * user space in effect at the time of cairo_set_source(). This means
     1:  * that further modifications of the current transformation matrix
     1:  * will not affect the source pattern. See cairo_pattern_set_matrix().
     1:  *
 13980:  * The default source pattern is a solid pattern that is opaque black,
 13980:  * (that is, it is equivalent to cairo_set_source_rgb(cr, 0.0, 0.0,
 13980:  * 0.0)).
     1:  **/
     1: void
     1: cairo_set_source (cairo_t *cr, cairo_pattern_t *source)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     if (source == NULL) {
     1: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
     1: 	return;
     1:     }
     1: 
     1:     if (source->status) {
     1: 	_cairo_set_error (cr, source->status);
     1: 	return;
     1:     }
     1: 
  4133:     status = _cairo_gstate_set_source (cr->gstate, source);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def (cairo_set_source);
     1: 
     1: /**
     1:  * cairo_get_source:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current source pattern for @cr.
     1:  *
     1:  * Return value: the current source pattern. This object is owned by
     1:  * cairo. To keep a reference to it, you must call
     1:  * cairo_pattern_reference().
     1:  **/
     1: cairo_pattern_t *
     1: cairo_get_source (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 32473: 	return _cairo_pattern_create_in_error (cr->status);
     1: 
     1:     return _cairo_gstate_get_source (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_set_tolerance:
     1:  * @cr: a #cairo_t
     1:  * @tolerance: the tolerance, in device units (typically pixels)
     1:  *
     1:  * Sets the tolerance used when converting paths into trapezoids.
     1:  * Curved segments of the path will be subdivided until the maximum
     1:  * deviation between the original path and the polygonal approximation
     1:  * is less than @tolerance. The default value is 0.1. A larger
     1:  * value will give better performance, a smaller value, better
     1:  * appearance. (Reducing the value from the default value of 0.1
 26419:  * is unlikely to improve appearance significantly.)  The accuracy of paths
 26419:  * within Cairo is limited by the precision of its internal arithmetic, and
 26419:  * the prescribed @tolerance is restricted to the smallest
 26419:  * representable internal value.
     1:  **/
     1: void
     1: cairo_set_tolerance (cairo_t *cr, double tolerance)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 26419:     if (tolerance < CAIRO_TOLERANCE_MINIMUM)
 26419: 	tolerance = CAIRO_TOLERANCE_MINIMUM;
     1: 
  4133:     status = _cairo_gstate_set_tolerance (cr->gstate, tolerance);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 26419: slim_hidden_def (cairo_set_tolerance);
     1: 
     1: /**
     1:  * cairo_set_antialias:
     1:  * @cr: a #cairo_t
     1:  * @antialias: the new antialiasing mode
     1:  *
     1:  * Set the antialiasing mode of the rasterizer used for drawing shapes.
     1:  * This value is a hint, and a particular backend may or may not support
     1:  * a particular value.  At the current time, no backend supports
     1:  * %CAIRO_ANTIALIAS_SUBPIXEL when drawing shapes.
     1:  *
     1:  * Note that this option does not affect text rendering, instead see
     1:  * cairo_font_options_set_antialias().
     1:  **/
     1: void
     1: cairo_set_antialias (cairo_t *cr, cairo_antialias_t antialias)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_antialias (cr->gstate, antialias);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_set_fill_rule:
     1:  * @cr: a #cairo_t
     1:  * @fill_rule: a fill rule, specified as a #cairo_fill_rule_t
     1:  *
     1:  * Set the current fill rule within the cairo context. The fill rule
     1:  * is used to determine which regions are inside or outside a complex
     1:  * (potentially self-intersecting) path. The current fill rule affects
  4133:  * both cairo_fill() and cairo_clip(). See #cairo_fill_rule_t for details
     1:  * on the semantics of each available fill rule.
 13980:  *
 13980:  * The default fill rule is %CAIRO_FILL_RULE_WINDING.
     1:  **/
     1: void
     1: cairo_set_fill_rule (cairo_t *cr, cairo_fill_rule_t fill_rule)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_fill_rule (cr->gstate, fill_rule);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_set_line_width:
     1:  * @cr: a #cairo_t
     1:  * @width: a line width
     1:  *
     1:  * Sets the current line width within the cairo context. The line
     1:  * width value specifies the diameter of a pen that is circular in
     1:  * user space, (though device-space pen may be an ellipse in general
     1:  * due to scaling/shear/rotation of the CTM).
     1:  *
     1:  * Note: When the description above refers to user space and CTM it
     1:  * refers to the user space and CTM in effect at the time of the
     1:  * stroking operation, not the user space and CTM in effect at the
     1:  * time of the call to cairo_set_line_width(). The simplest usage
     1:  * makes both of these spaces identical. That is, if there is no
 32473:  * change to the CTM between a call to cairo_set_line_width() and the
     1:  * stroking operation, then one can just pass user-space values to
     1:  * cairo_set_line_width() and ignore this note.
     1:  *
     1:  * As with the other stroke parameters, the current line width is
     1:  * examined by cairo_stroke(), cairo_stroke_extents(), and
     1:  * cairo_stroke_to_path(), but does not have any effect during path
     1:  * construction.
     1:  *
     1:  * The default line width value is 2.0.
     1:  **/
     1: void
     1: cairo_set_line_width (cairo_t *cr, double width)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 26419:     if (width < 0.)
 26419: 	width = 0.;
     1: 
  4133:     status = _cairo_gstate_set_line_width (cr->gstate, width);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 21379: slim_hidden_def (cairo_set_line_width);
     1: 
     1: /**
     1:  * cairo_set_line_cap:
   314:  * @cr: a cairo context
   314:  * @line_cap: a line cap style
     1:  *
     1:  * Sets the current line cap style within the cairo context. See
     1:  * #cairo_line_cap_t for details about how the available line cap
     1:  * styles are drawn.
     1:  *
     1:  * As with the other stroke parameters, the current line cap style is
     1:  * examined by cairo_stroke(), cairo_stroke_extents(), and
     1:  * cairo_stroke_to_path(), but does not have any effect during path
     1:  * construction.
 13980:  *
 13980:  * The default line cap style is %CAIRO_LINE_CAP_BUTT.
     1:  **/
     1: void
     1: cairo_set_line_cap (cairo_t *cr, cairo_line_cap_t line_cap)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_line_cap (cr->gstate, line_cap);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 21379: slim_hidden_def (cairo_set_line_cap);
     1: 
     1: /**
     1:  * cairo_set_line_join:
   314:  * @cr: a cairo context
 13980:  * @line_join: a line join style
     1:  *
     1:  * Sets the current line join style within the cairo context. See
     1:  * #cairo_line_join_t for details about how the available line join
     1:  * styles are drawn.
     1:  *
     1:  * As with the other stroke parameters, the current line join style is
     1:  * examined by cairo_stroke(), cairo_stroke_extents(), and
     1:  * cairo_stroke_to_path(), but does not have any effect during path
     1:  * construction.
 13980:  *
 13980:  * The default line join style is %CAIRO_LINE_JOIN_MITER.
     1:  **/
     1: void
     1: cairo_set_line_join (cairo_t *cr, cairo_line_join_t line_join)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_line_join (cr->gstate, line_join);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 21379: slim_hidden_def (cairo_set_line_join);
     1: 
     1: /**
     1:  * cairo_set_dash:
     1:  * @cr: a cairo context
     1:  * @dashes: an array specifying alternate lengths of on and off stroke portions
     1:  * @num_dashes: the length of the dashes array
     1:  * @offset: an offset into the dash pattern at which the stroke should start
     1:  *
     1:  * Sets the dash pattern to be used by cairo_stroke(). A dash pattern
     1:  * is specified by @dashes, an array of positive values. Each value
     1:  * provides the length of alternate "on" and "off" portions of the
     1:  * stroke. The @offset specifies an offset into the pattern at which
     1:  * the stroke begins.
     1:  *
     1:  * Each "on" segment will have caps applied as if the segment were a
     1:  * separate sub-path. In particular, it is valid to use an "on" length
 11708:  * of 0.0 with %CAIRO_LINE_CAP_ROUND or %CAIRO_LINE_CAP_SQUARE in order
     1:  * to distributed dots or squares along a path.
     1:  *
     1:  * Note: The length values are in user-space units as evaluated at the
     1:  * time of stroking. This is not necessarily the same as the user
     1:  * space at the time of cairo_set_dash().
     1:  *
     1:  * If @num_dashes is 0 dashing is disabled.
     1:  *
     1:  * If @num_dashes is 1 a symmetric pattern is assumed with alternating
     1:  * on and off portions of the size specified by the single value in
     1:  * @dashes.
     1:  *
     1:  * If any value in @dashes is negative, or if all values are 0, then
 11708:  * @cr will be put into an error state with a status of
 32473:  * %CAIRO_STATUS_INVALID_DASH.
     1:  **/
     1: void
     1: cairo_set_dash (cairo_t	     *cr,
     1: 		const double *dashes,
     1: 		int	      num_dashes,
     1: 		double	      offset)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_dash (cr->gstate,
     1: 				     dashes, num_dashes, offset);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_get_dash_count:
     1:  * @cr: a #cairo_t
     1:  *
   314:  * This function returns the length of the dash array in @cr (0 if dashing
   314:  * is not currently in effect).
     1:  *
     1:  * See also cairo_set_dash() and cairo_get_dash().
     1:  *
   314:  * Return value: the length of the dash array, or 0 if no dash array set.
   314:  *
     1:  * Since: 1.4
     1:  */
     1: int
     1: cairo_get_dash_count (cairo_t *cr)
     1: {
  4133:     int num_dashes;
  4133: 
 32473:     if (unlikely (cr->status))
  8452: 	return 0;
  8452: 
  4133:     _cairo_gstate_get_dash (cr->gstate, NULL, &num_dashes, NULL);
  4133: 
  4133:     return num_dashes;
     1: }
     1: 
     1: /**
     1:  * cairo_get_dash:
     1:  * @cr: a #cairo_t
     1:  * @dashes: return value for the dash array, or %NULL
     1:  * @offset: return value for the current dash offset, or %NULL
     1:  *
     1:  * Gets the current dash array.  If not %NULL, @dashes should be big
     1:  * enough to hold at least the number of values returned by
     1:  * cairo_get_dash_count().
     1:  *
     1:  * Since: 1.4
     1:  **/
     1: void
     1: cairo_get_dash (cairo_t *cr,
     1: 		double  *dashes,
     1: 		double  *offset)
     1: {
 32473:     if (unlikely (cr->status))
  8452: 	return;
  8452: 
  4133:     _cairo_gstate_get_dash (cr->gstate, dashes, NULL, offset);
     1: }
     1: 
   314: /**
   314:  * cairo_set_miter_limit:
   314:  * @cr: a cairo context
   314:  * @limit: miter limit to set
   314:  *
   314:  * Sets the current miter limit within the cairo context.
   314:  *
   314:  * If the current line join style is set to %CAIRO_LINE_JOIN_MITER
   314:  * (see cairo_set_line_join()), the miter limit is used to determine
   314:  * whether the lines should be joined with a bevel instead of a miter.
   314:  * Cairo divides the length of the miter by the line width.
   314:  * If the result is greater than the miter limit, the style is
   314:  * converted to a bevel.
   314:  *
   314:  * As with the other stroke parameters, the current line miter limit is
   314:  * examined by cairo_stroke(), cairo_stroke_extents(), and
   314:  * cairo_stroke_to_path(), but does not have any effect during path
   314:  * construction.
 13980:  *
 13980:  * The default miter limit value is 10.0, which will convert joins
 13980:  * with interior angles less than 11 degrees to bevels instead of
 13980:  * miters. For reference, a miter limit of 2.0 makes the miter cutoff
 13980:  * at 60 degrees, and a miter limit of 1.414 makes the cutoff at 90
 13980:  * degrees.
 13980:  *
 13980:  * A miter limit for a desired angle can be computed as: miter limit =
 13980:  * 1/sin(angle/2)
   314:  **/
     1: void
     1: cairo_set_miter_limit (cairo_t *cr, double limit)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_miter_limit (cr->gstate, limit);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_translate:
     1:  * @cr: a cairo context
     1:  * @tx: amount to translate in the X direction
     1:  * @ty: amount to translate in the Y direction
     1:  *
     1:  * Modifies the current transformation matrix (CTM) by translating the
     1:  * user-space origin by (@tx, @ty). This offset is interpreted as a
     1:  * user-space coordinate according to the CTM in place before the new
 11708:  * call to cairo_translate(). In other words, the translation of the
     1:  * user-space origin takes place after any existing transformation.
     1:  **/
     1: void
     1: cairo_translate (cairo_t *cr, double tx, double ty)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_translate (cr->gstate, tx, ty);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 26419: slim_hidden_def (cairo_translate);
     1: 
     1: /**
     1:  * cairo_scale:
     1:  * @cr: a cairo context
     1:  * @sx: scale factor for the X dimension
     1:  * @sy: scale factor for the Y dimension
     1:  *
     1:  * Modifies the current transformation matrix (CTM) by scaling the X
     1:  * and Y user-space axes by @sx and @sy respectively. The scaling of
     1:  * the axes takes place after any existing transformation of user
     1:  * space.
     1:  **/
     1: void
     1: cairo_scale (cairo_t *cr, double sx, double sy)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_scale (cr->gstate, sx, sy);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
   314: slim_hidden_def (cairo_scale);
     1: 
     1: /**
     1:  * cairo_rotate:
     1:  * @cr: a cairo context
     1:  * @angle: angle (in radians) by which the user-space axes will be
     1:  * rotated
     1:  *
     1:  * Modifies the current transformation matrix (CTM) by rotating the
     1:  * user-space axes by @angle radians. The rotation of the axes takes
     1:  * places after any existing transformation of user space. The
     1:  * rotation direction for positive angles is from the positive X axis
     1:  * toward the positive Y axis.
     1:  **/
     1: void
     1: cairo_rotate (cairo_t *cr, double angle)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_rotate (cr->gstate, angle);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_transform:
     1:  * @cr: a cairo context
     1:  * @matrix: a transformation to be applied to the user-space axes
     1:  *
     1:  * Modifies the current transformation matrix (CTM) by applying
     1:  * @matrix as an additional transformation. The new transformation of
     1:  * user space takes place after any existing transformation.
     1:  **/
     1: void
     1: cairo_transform (cairo_t	      *cr,
     1: 		 const cairo_matrix_t *matrix)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_transform (cr->gstate, matrix);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 26419: slim_hidden_def (cairo_transform);
     1: 
     1: /**
     1:  * cairo_set_matrix:
     1:  * @cr: a cairo context
     1:  * @matrix: a transformation matrix from user space to device space
     1:  *
     1:  * Modifies the current transformation matrix (CTM) by setting it
     1:  * equal to @matrix.
     1:  **/
     1: void
     1: cairo_set_matrix (cairo_t	       *cr,
     1: 		  const cairo_matrix_t *matrix)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_matrix (cr->gstate, matrix);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 16122: slim_hidden_def (cairo_set_matrix);
     1: 
     1: /**
     1:  * cairo_identity_matrix:
     1:  * @cr: a cairo context
     1:  *
     1:  * Resets the current transformation matrix (CTM) by setting it equal
     1:  * to the identity matrix. That is, the user-space and device-space
     1:  * axes will be aligned and one user-space unit will transform to one
     1:  * device-space unit.
     1:  **/
     1: void
     1: cairo_identity_matrix (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     _cairo_gstate_identity_matrix (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_user_to_device:
     1:  * @cr: a cairo context
     1:  * @x: X value of coordinate (in/out parameter)
     1:  * @y: Y value of coordinate (in/out parameter)
     1:  *
     1:  * Transform a coordinate from user space to device space by
     1:  * multiplying the given point by the current transformation matrix
     1:  * (CTM).
     1:  **/
     1: void
     1: cairo_user_to_device (cairo_t *cr, double *x, double *y)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     _cairo_gstate_user_to_device (cr->gstate, x, y);
     1: }
 26419: slim_hidden_def (cairo_user_to_device);
     1: 
     1: /**
     1:  * cairo_user_to_device_distance:
     1:  * @cr: a cairo context
     1:  * @dx: X component of a distance vector (in/out parameter)
     1:  * @dy: Y component of a distance vector (in/out parameter)
     1:  *
     1:  * Transform a distance vector from user space to device space. This
     1:  * function is similar to cairo_user_to_device() except that the
     1:  * translation components of the CTM will be ignored when transforming
     1:  * (@dx,@dy).
     1:  **/
     1: void
     1: cairo_user_to_device_distance (cairo_t *cr, double *dx, double *dy)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     _cairo_gstate_user_to_device_distance (cr->gstate, dx, dy);
     1: }
 26419: slim_hidden_def (cairo_user_to_device_distance);
     1: 
     1: /**
     1:  * cairo_device_to_user:
     1:  * @cr: a cairo
     1:  * @x: X value of coordinate (in/out parameter)
     1:  * @y: Y value of coordinate (in/out parameter)
     1:  *
     1:  * Transform a coordinate from device space to user space by
     1:  * multiplying the given point by the inverse of the current
     1:  * transformation matrix (CTM).
     1:  **/
     1: void
     1: cairo_device_to_user (cairo_t *cr, double *x, double *y)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     _cairo_gstate_device_to_user (cr->gstate, x, y);
     1: }
     1: 
     1: /**
     1:  * cairo_device_to_user_distance:
     1:  * @cr: a cairo context
     1:  * @dx: X component of a distance vector (in/out parameter)
     1:  * @dy: Y component of a distance vector (in/out parameter)
     1:  *
     1:  * Transform a distance vector from device space to user space. This
     1:  * function is similar to cairo_device_to_user() except that the
     1:  * translation components of the inverse CTM will be ignored when
     1:  * transforming (@dx,@dy).
     1:  **/
     1: void
     1: cairo_device_to_user_distance (cairo_t *cr, double *dx, double *dy)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     _cairo_gstate_device_to_user_distance (cr->gstate, dx, dy);
     1: }
     1: 
     1: /**
     1:  * cairo_new_path:
     1:  * @cr: a cairo context
     1:  *
     1:  * Clears the current path. After this call there will be no path and
     1:  * no current point.
     1:  **/
     1: void
     1: cairo_new_path (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
   314:     _cairo_path_fixed_fini (cr->path);
 32473:     _cairo_path_fixed_init (cr->path);
     1: }
     1: slim_hidden_def(cairo_new_path);
     1: 
     1: /**
     1:  * cairo_move_to:
     1:  * @cr: a cairo context
     1:  * @x: the X coordinate of the new position
     1:  * @y: the Y coordinate of the new position
     1:  *
     1:  * Begin a new sub-path. After this call the current point will be (@x,
     1:  * @y).
     1:  **/
     1: void
     1: cairo_move_to (cairo_t *cr, double x, double y)
     1: {
  4133:     cairo_status_t status;
     1:     cairo_fixed_t x_fixed, y_fixed;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     _cairo_gstate_user_to_backend (cr->gstate, &x, &y);
     1:     x_fixed = _cairo_fixed_from_double (x);
     1:     y_fixed = _cairo_fixed_from_double (y);
     1: 
  4133:     status = _cairo_path_fixed_move_to (cr->path, x_fixed, y_fixed);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_move_to);
     1: 
     1: /**
     1:  * cairo_new_sub_path:
     1:  * @cr: a cairo context
     1:  *
     1:  * Begin a new sub-path. Note that the existing path is not
     1:  * affected. After this call there will be no current point.
     1:  *
     1:  * In many cases, this call is not needed since new sub-paths are
     1:  * frequently started with cairo_move_to().
     1:  *
     1:  * A call to cairo_new_sub_path() is particularly useful when
     1:  * beginning a new sub-path with one of the cairo_arc() calls. This
     1:  * makes things easier as it is no longer necessary to manually
     1:  * compute the arc's initial coordinates for a call to
     1:  * cairo_move_to().
     1:  *
     1:  * Since: 1.2
     1:  **/
     1: void
     1: cairo_new_sub_path (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
   314:     _cairo_path_fixed_new_sub_path (cr->path);
     1: }
     1: 
     1: /**
     1:  * cairo_line_to:
     1:  * @cr: a cairo context
     1:  * @x: the X coordinate of the end of the new line
     1:  * @y: the Y coordinate of the end of the new line
     1:  *
     1:  * Adds a line to the path from the current point to position (@x, @y)
     1:  * in user-space coordinates. After this call the current point
     1:  * will be (@x, @y).
     1:  *
     1:  * If there is no current point before the call to cairo_line_to()
     1:  * this function will behave as cairo_move_to(@cr, @x, @y).
     1:  **/
     1: void
     1: cairo_line_to (cairo_t *cr, double x, double y)
     1: {
  4133:     cairo_status_t status;
     1:     cairo_fixed_t x_fixed, y_fixed;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     _cairo_gstate_user_to_backend (cr->gstate, &x, &y);
     1:     x_fixed = _cairo_fixed_from_double (x);
     1:     y_fixed = _cairo_fixed_from_double (y);
     1: 
  4133:     status = _cairo_path_fixed_line_to (cr->path, x_fixed, y_fixed);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def (cairo_line_to);
     1: 
     1: /**
     1:  * cairo_curve_to:
     1:  * @cr: a cairo context
     1:  * @x1: the X coordinate of the first control point
     1:  * @y1: the Y coordinate of the first control point
     1:  * @x2: the X coordinate of the second control point
     1:  * @y2: the Y coordinate of the second control point
     1:  * @x3: the X coordinate of the end of the curve
     1:  * @y3: the Y coordinate of the end of the curve
     1:  *
     1:  * Adds a cubic Bézier spline to the path from the current point to
     1:  * position (@x3, @y3) in user-space coordinates, using (@x1, @y1) and
     1:  * (@x2, @y2) as the control points. After this call the current point
     1:  * will be (@x3, @y3).
     1:  *
     1:  * If there is no current point before the call to cairo_curve_to()
     1:  * this function will behave as if preceded by a call to
     1:  * cairo_move_to(@cr, @x1, @y1).
     1:  **/
     1: void
     1: cairo_curve_to (cairo_t *cr,
     1: 		double x1, double y1,
     1: 		double x2, double y2,
     1: 		double x3, double y3)
     1: {
  4133:     cairo_status_t status;
     1:     cairo_fixed_t x1_fixed, y1_fixed;
     1:     cairo_fixed_t x2_fixed, y2_fixed;
     1:     cairo_fixed_t x3_fixed, y3_fixed;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     _cairo_gstate_user_to_backend (cr->gstate, &x1, &y1);
     1:     _cairo_gstate_user_to_backend (cr->gstate, &x2, &y2);
     1:     _cairo_gstate_user_to_backend (cr->gstate, &x3, &y3);
     1: 
     1:     x1_fixed = _cairo_fixed_from_double (x1);
     1:     y1_fixed = _cairo_fixed_from_double (y1);
     1: 
     1:     x2_fixed = _cairo_fixed_from_double (x2);
     1:     y2_fixed = _cairo_fixed_from_double (y2);
     1: 
     1:     x3_fixed = _cairo_fixed_from_double (x3);
     1:     y3_fixed = _cairo_fixed_from_double (y3);
     1: 
  4133:     status = _cairo_path_fixed_curve_to (cr->path,
     1: 					 x1_fixed, y1_fixed,
     1: 					 x2_fixed, y2_fixed,
     1: 					 x3_fixed, y3_fixed);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def (cairo_curve_to);
     1: 
     1: /**
     1:  * cairo_arc:
     1:  * @cr: a cairo context
     1:  * @xc: X position of the center of the arc
     1:  * @yc: Y position of the center of the arc
     1:  * @radius: the radius of the arc
     1:  * @angle1: the start angle, in radians
     1:  * @angle2: the end angle, in radians
     1:  *
     1:  * Adds a circular arc of the given @radius to the current path.  The
     1:  * arc is centered at (@xc, @yc), begins at @angle1 and proceeds in
     1:  * the direction of increasing angles to end at @angle2. If @angle2 is
     1:  * less than @angle1 it will be progressively increased by 2*M_PI
     1:  * until it is greater than @angle1.
     1:  *
     1:  * If there is a current point, an initial line segment will be added
     1:  * to the path to connect the current point to the beginning of the
  8452:  * arc. If this initial line is undesired, it can be avoided by
  8452:  * calling cairo_new_sub_path() before calling cairo_arc().
     1:  *
     1:  * Angles are measured in radians. An angle of 0.0 is in the direction
     1:  * of the positive X axis (in user space). An angle of %M_PI/2.0 radians
     1:  * (90 degrees) is in the direction of the positive Y axis (in
     1:  * user space). Angles increase in the direction from the positive X
     1:  * axis toward the positive Y axis. So with the default transformation
     1:  * matrix, angles increase in a clockwise direction.
     1:  *
     1:  * (To convert from degrees to radians, use <literal>degrees * (M_PI /
     1:  * 180.)</literal>.)
     1:  *
     1:  * This function gives the arc in the direction of increasing angles;
     1:  * see cairo_arc_negative() to get the arc in the direction of
     1:  * decreasing angles.
     1:  *
     1:  * The arc is circular in user space. To achieve an elliptical arc,
     1:  * you can scale the current transformation matrix by different
     1:  * amounts in the X and Y directions. For example, to draw an ellipse
     1:  * in the box given by @x, @y, @width, @height:
     1:  *
     1:  * <informalexample><programlisting>
     1:  * cairo_save (cr);
     1:  * cairo_translate (cr, x + width / 2., y + height / 2.);
  4133:  * cairo_scale (cr, width / 2., height / 2.);
     1:  * cairo_arc (cr, 0., 0., 1., 0., 2 * M_PI);
     1:  * cairo_restore (cr);
     1:  * </programlisting></informalexample>
     1:  **/
     1: void
     1: cairo_arc (cairo_t *cr,
     1: 	   double xc, double yc,
     1: 	   double radius,
     1: 	   double angle1, double angle2)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     /* Do nothing, successfully, if radius is <= 0 */
 41340:     if (radius <= 0.0) {
 41340: 	cairo_line_to (cr, xc, yc);
     1: 	return;
 41340:     }
     1: 
     1:     while (angle2 < angle1)
     1: 	angle2 += 2 * M_PI;
     1: 
     1:     cairo_line_to (cr,
     1: 		   xc + radius * cos (angle1),
     1: 		   yc + radius * sin (angle1));
     1: 
     1:     _cairo_arc_path (cr, xc, yc, radius,
     1: 		     angle1, angle2);
     1: }
     1: 
     1: /**
     1:  * cairo_arc_negative:
     1:  * @cr: a cairo context
     1:  * @xc: X position of the center of the arc
     1:  * @yc: Y position of the center of the arc
     1:  * @radius: the radius of the arc
     1:  * @angle1: the start angle, in radians
     1:  * @angle2: the end angle, in radians
     1:  *
     1:  * Adds a circular arc of the given @radius to the current path.  The
     1:  * arc is centered at (@xc, @yc), begins at @angle1 and proceeds in
     1:  * the direction of decreasing angles to end at @angle2. If @angle2 is
     1:  * greater than @angle1 it will be progressively decreased by 2*M_PI
  4133:  * until it is less than @angle1.
     1:  *
     1:  * See cairo_arc() for more details. This function differs only in the
     1:  * direction of the arc between the two angles.
     1:  **/
     1: void
     1: cairo_arc_negative (cairo_t *cr,
     1: 		    double xc, double yc,
     1: 		    double radius,
     1: 		    double angle1, double angle2)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     /* Do nothing, successfully, if radius is <= 0 */
     1:     if (radius <= 0.0)
     1: 	return;
     1: 
     1:     while (angle2 > angle1)
     1: 	angle2 -= 2 * M_PI;
     1: 
     1:     cairo_line_to (cr,
     1: 		   xc + radius * cos (angle1),
     1: 		   yc + radius * sin (angle1));
     1: 
     1:      _cairo_arc_path_negative (cr, xc, yc, radius,
     1: 			       angle1, angle2);
     1: }
     1: 
     1: /* XXX: NYI
     1: void
     1: cairo_arc_to (cairo_t *cr,
     1: 	      double x1, double y1,
     1: 	      double x2, double y2,
     1: 	      double radius)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_arc_to (cr->gstate,
     1: 				   x1, y1,
     1: 				   x2, y2,
     1: 				   radius);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: */
     1: 
     1: /**
     1:  * cairo_rel_move_to:
     1:  * @cr: a cairo context
     1:  * @dx: the X offset
     1:  * @dy: the Y offset
     1:  *
     1:  * Begin a new sub-path. After this call the current point will offset
     1:  * by (@x, @y).
     1:  *
     1:  * Given a current point of (x, y), cairo_rel_move_to(@cr, @dx, @dy)
     1:  * is logically equivalent to cairo_move_to(@cr, x + @dx, y + @dy).
     1:  *
     1:  * It is an error to call this function with no current point. Doing
     1:  * so will cause @cr to shutdown with a status of
 16122:  * %CAIRO_STATUS_NO_CURRENT_POINT.
     1:  **/
     1: void
     1: cairo_rel_move_to (cairo_t *cr, double dx, double dy)
     1: {
     1:     cairo_fixed_t dx_fixed, dy_fixed;
  4133:     cairo_status_t status;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
  4133: 
     1:     dx_fixed = _cairo_fixed_from_double (dx);
     1:     dy_fixed = _cairo_fixed_from_double (dy);
     1: 
  4133:     status = _cairo_path_fixed_rel_move_to (cr->path, dx_fixed, dy_fixed);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_rel_line_to:
     1:  * @cr: a cairo context
     1:  * @dx: the X offset to the end of the new line
     1:  * @dy: the Y offset to the end of the new line
     1:  *
     1:  * Relative-coordinate version of cairo_line_to(). Adds a line to the
     1:  * path from the current point to a point that is offset from the
     1:  * current point by (@dx, @dy) in user space. After this call the
     1:  * current point will be offset by (@dx, @dy).
     1:  *
     1:  * Given a current point of (x, y), cairo_rel_line_to(@cr, @dx, @dy)
     1:  * is logically equivalent to cairo_line_to(@cr, x + @dx, y + @dy).
     1:  *
     1:  * It is an error to call this function with no current point. Doing
     1:  * so will cause @cr to shutdown with a status of
 16122:  * %CAIRO_STATUS_NO_CURRENT_POINT.
     1:  **/
     1: void
     1: cairo_rel_line_to (cairo_t *cr, double dx, double dy)
     1: {
     1:     cairo_fixed_t dx_fixed, dy_fixed;
  4133:     cairo_status_t status;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     _cairo_gstate_user_to_device_distance (cr->gstate, &dx, &dy);
  4133: 
     1:     dx_fixed = _cairo_fixed_from_double (dx);
     1:     dy_fixed = _cairo_fixed_from_double (dy);
     1: 
  4133:     status = _cairo_path_fixed_rel_line_to (cr->path, dx_fixed, dy_fixed);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_rel_line_to);
     1: 
     1: /**
     1:  * cairo_rel_curve_to:
     1:  * @cr: a cairo context
     1:  * @dx1: the X offset to the first control point
     1:  * @dy1: the Y offset to the first control point
     1:  * @dx2: the X offset to the second control point
     1:  * @dy2: the Y offset to the second control point
     1:  * @dx3: the X offset to the end of the curve
     1:  * @dy3: the Y offset to the end of the curve
     1:  *
     1:  * Relative-coordinate version of cairo_curve_to(). All offsets are
     1:  * relative to the current point. Adds a cubic Bézier spline to the
     1:  * path from the current point to a point offset from the current
     1:  * point by (@dx3, @dy3), using points offset by (@dx1, @dy1) and
     1:  * (@dx2, @dy2) as the control points. After this call the current
     1:  * point will be offset by (@dx3, @dy3).
     1:  *
     1:  * Given a current point of (x, y), cairo_rel_curve_to(@cr, @dx1,
     1:  * @dy1, @dx2, @dy2, @dx3, @dy3) is logically equivalent to
 16122:  * cairo_curve_to(@cr, x+@dx1, y+@dy1, x+@dx2, y+@dy2, x+@dx3, y+@dy3).
     1:  *
     1:  * It is an error to call this function with no current point. Doing
     1:  * so will cause @cr to shutdown with a status of
 16122:  * %CAIRO_STATUS_NO_CURRENT_POINT.
     1:  **/
     1: void
     1: cairo_rel_curve_to (cairo_t *cr,
     1: 		    double dx1, double dy1,
     1: 		    double dx2, double dy2,
     1: 		    double dx3, double dy3)
     1: {
     1:     cairo_fixed_t dx1_fixed, dy1_fixed;
     1:     cairo_fixed_t dx2_fixed, dy2_fixed;
     1:     cairo_fixed_t dx3_fixed, dy3_fixed;
  4133:     cairo_status_t status;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     _cairo_gstate_user_to_device_distance (cr->gstate, &dx1, &dy1);
     1:     _cairo_gstate_user_to_device_distance (cr->gstate, &dx2, &dy2);
     1:     _cairo_gstate_user_to_device_distance (cr->gstate, &dx3, &dy3);
     1: 
     1:     dx1_fixed = _cairo_fixed_from_double (dx1);
     1:     dy1_fixed = _cairo_fixed_from_double (dy1);
     1: 
     1:     dx2_fixed = _cairo_fixed_from_double (dx2);
     1:     dy2_fixed = _cairo_fixed_from_double (dy2);
     1: 
     1:     dx3_fixed = _cairo_fixed_from_double (dx3);
     1:     dy3_fixed = _cairo_fixed_from_double (dy3);
     1: 
  4133:     status = _cairo_path_fixed_rel_curve_to (cr->path,
     1: 					     dx1_fixed, dy1_fixed,
     1: 					     dx2_fixed, dy2_fixed,
     1: 					     dx3_fixed, dy3_fixed);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_rectangle:
     1:  * @cr: a cairo context
     1:  * @x: the X coordinate of the top left corner of the rectangle
     1:  * @y: the Y coordinate to the top left corner of the rectangle
     1:  * @width: the width of the rectangle
     1:  * @height: the height of the rectangle
     1:  *
     1:  * Adds a closed sub-path rectangle of the given size to the current
     1:  * path at position (@x, @y) in user-space coordinates.
     1:  *
     1:  * This function is logically equivalent to:
     1:  * <informalexample><programlisting>
     1:  * cairo_move_to (cr, x, y);
     1:  * cairo_rel_line_to (cr, width, 0);
     1:  * cairo_rel_line_to (cr, 0, height);
     1:  * cairo_rel_line_to (cr, -width, 0);
     1:  * cairo_close_path (cr);
     1:  * </programlisting></informalexample>
     1:  **/
     1: void
     1: cairo_rectangle (cairo_t *cr,
     1: 		 double x, double y,
     1: 		 double width, double height)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     cairo_move_to (cr, x, y);
     1:     cairo_rel_line_to (cr, width, 0);
     1:     cairo_rel_line_to (cr, 0, height);
     1:     cairo_rel_line_to (cr, -width, 0);
     1:     cairo_close_path (cr);
     1: }
     1: 
 16122: #if 0
 16122: /* XXX: NYI */
     1: void
     1: cairo_stroke_to_path (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 41340:     /* The code in _cairo_recording_surface_get_path has a poorman's stroke_to_path */
 16122: 
  4133:     status = _cairo_gstate_stroke_path (cr->gstate);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 16122: #endif
     1: 
     1: /**
     1:  * cairo_close_path:
     1:  * @cr: a cairo context
     1:  *
     1:  * Adds a line segment to the path from the current point to the
     1:  * beginning of the current sub-path, (the most recent point passed to
     1:  * cairo_move_to()), and closes this sub-path. After this call the
     1:  * current point will be at the joined endpoint of the sub-path.
     1:  *
     1:  * The behavior of cairo_close_path() is distinct from simply calling
     1:  * cairo_line_to() with the equivalent coordinate in the case of
     1:  * stroking. When a closed sub-path is stroked, there are no caps on
     1:  * the ends of the sub-path. Instead, there is a line join connecting
     1:  * the final and initial segments of the sub-path.
     1:  *
 11708:  * If there is no current point before the call to cairo_close_path(),
     1:  * this function will have no effect.
     1:  *
 11708:  * Note: As of cairo version 1.2.4 any call to cairo_close_path() will
     1:  * place an explicit MOVE_TO element into the path immediately after
     1:  * the CLOSE_PATH element, (which can be seen in cairo_copy_path() for
     1:  * example). This can simplify path processing in some cases as it may
     1:  * not be necessary to save the "last move_to point" during processing
     1:  * as the MOVE_TO immediately after the CLOSE_PATH will provide that
     1:  * point.
     1:  **/
     1: void
     1: cairo_close_path (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_path_fixed_close_path (cr->path);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_close_path);
     1: 
     1: /**
 10694:  * cairo_path_extents:
 10694:  * @cr: a cairo context
 10694:  * @x1: left of the resulting extents
 10694:  * @y1: top of the resulting extents
 10694:  * @x2: right of the resulting extents
 10694:  * @y2: bottom of the resulting extents
 10694:  *
 10694:  * Computes a bounding box in user-space coordinates covering the
 10694:  * points on the current path. If the current path is empty, returns
 10694:  * an empty rectangle ((0,0), (0,0)). Stroke parameters, fill rule,
 10694:  * surface dimensions and clipping are not taken into account.
 10694:  *
 10694:  * Contrast with cairo_fill_extents() and cairo_stroke_extents() which
 10694:  * return the extents of only the area that would be "inked" by
 10694:  * the corresponding drawing operations.
 10694:  *
 10694:  * The result of cairo_path_extents() is defined as equivalent to the
 11708:  * limit of cairo_stroke_extents() with %CAIRO_LINE_CAP_ROUND as the
 10694:  * line width approaches 0.0, (but never reaching the empty-rectangle
 10694:  * returned by cairo_stroke_extents() for a line width of 0.0).
 10694:  *
 10694:  * Specifically, this means that zero-area sub-paths such as
 10694:  * cairo_move_to();cairo_line_to() segments, (even degenerate cases
 10694:  * where the coordinates to both calls are identical), will be
 10694:  * considered as contributing to the extents. However, a lone
 10694:  * cairo_move_to() will not contribute to the results of
 10694:  * cairo_path_extents().
 10694:  *
 10694:  * Since: 1.6
 10694:  **/
 10694: void
 10694: cairo_path_extents (cairo_t *cr,
 10694: 		    double *x1, double *y1, double *x2, double *y2)
 10694: {
 32473:     if (unlikely (cr->status)) {
 11708: 	if (x1)
 11708: 	    *x1 = 0.0;
 11708: 	if (y1)
 11708: 	    *y1 = 0.0;
 11708: 	if (x2)
 11708: 	    *x2 = 0.0;
 11708: 	if (y2)
 11708: 	    *y2 = 0.0;
 11708: 
 10694: 	return;
 11708:     }
 10694: 
 26419:     _cairo_gstate_path_extents (cr->gstate,
 10694: 				cr->path,
 10694: 				x1, y1, x2, y2);
 10694: }
 10694: 
 10694: /**
     1:  * cairo_paint:
     1:  * @cr: a cairo context
     1:  *
     1:  * A drawing operator that paints the current source everywhere within
     1:  * the current clip region.
     1:  **/
     1: void
     1: cairo_paint (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_paint (cr->gstate);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def (cairo_paint);
     1: 
     1: /**
     1:  * cairo_paint_with_alpha:
     1:  * @cr: a cairo context
     1:  * @alpha: alpha value, between 0 (transparent) and 1 (opaque)
     1:  *
     1:  * A drawing operator that paints the current source everywhere within
     1:  * the current clip region using a mask of constant alpha value
     1:  * @alpha. The effect is similar to cairo_paint(), but the drawing
     1:  * is faded out using the alpha value.
     1:  **/
     1: void
     1: cairo_paint_with_alpha (cairo_t *cr,
     1: 			double   alpha)
     1: {
  4133:     cairo_status_t status;
     1:     cairo_color_t color;
 16122:     cairo_solid_pattern_t pattern;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     if (CAIRO_ALPHA_IS_OPAQUE (alpha)) {
     1: 	cairo_paint (cr);
     1: 	return;
     1:     }
     1: 
 70960:     if (CAIRO_ALPHA_IS_ZERO (alpha) &&
 70960:         _cairo_operator_bounded_by_mask (cr->gstate->op)) {
     1: 	return;
     1:     }
     1: 
 70960:     _cairo_color_init_rgba (&color, 0., 0., 0., alpha);
 70960:     _cairo_pattern_init_solid (&pattern, &color);
  4133: 
  4133:     status = _cairo_gstate_mask (cr->gstate, &pattern.base);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: 
     1:     _cairo_pattern_fini (&pattern.base);
     1: }
     1: 
     1: /**
     1:  * cairo_mask:
     1:  * @cr: a cairo context
     1:  * @pattern: a #cairo_pattern_t
     1:  *
     1:  * A drawing operator that paints the current source
     1:  * using the alpha channel of @pattern as a mask. (Opaque
     1:  * areas of @pattern are painted with the source, transparent
     1:  * areas are not painted.)
     1:  */
     1: void
     1: cairo_mask (cairo_t         *cr,
     1: 	    cairo_pattern_t *pattern)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     if (pattern == NULL) {
     1: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
     1: 	return;
     1:     }
     1: 
     1:     if (pattern->status) {
     1: 	_cairo_set_error (cr, pattern->status);
     1: 	return;
     1:     }
     1: 
  4133:     status = _cairo_gstate_mask (cr->gstate, pattern);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def (cairo_mask);
     1: 
     1: /**
     1:  * cairo_mask_surface:
     1:  * @cr: a cairo context
     1:  * @surface: a #cairo_surface_t
     1:  * @surface_x: X coordinate at which to place the origin of @surface
     1:  * @surface_y: Y coordinate at which to place the origin of @surface
     1:  *
     1:  * A drawing operator that paints the current source
     1:  * using the alpha channel of @surface as a mask. (Opaque
     1:  * areas of @surface are painted with the source, transparent
     1:  * areas are not painted.)
     1:  */
     1: void
     1: cairo_mask_surface (cairo_t         *cr,
     1: 		    cairo_surface_t *surface,
     1: 		    double           surface_x,
     1: 		    double           surface_y)
     1: {
     1:     cairo_pattern_t *pattern;
     1:     cairo_matrix_t matrix;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     pattern = cairo_pattern_create_for_surface (surface);
     1: 
     1:     cairo_matrix_init_translate (&matrix, - surface_x, - surface_y);
     1:     cairo_pattern_set_matrix (pattern, &matrix);
     1: 
     1:     cairo_mask (cr, pattern);
     1: 
     1:     cairo_pattern_destroy (pattern);
     1: }
     1: 
     1: /**
     1:  * cairo_stroke:
     1:  * @cr: a cairo context
     1:  *
     1:  * A drawing operator that strokes the current path according to the
     1:  * current line width, line join, line cap, and dash settings. After
 16122:  * cairo_stroke(), the current path will be cleared from the cairo
     1:  * context. See cairo_set_line_width(), cairo_set_line_join(),
     1:  * cairo_set_line_cap(), cairo_set_dash(), and
     1:  * cairo_stroke_preserve().
     1:  *
     1:  * Note: Degenerate segments and sub-paths are treated specially and
     1:  * provide a useful result. These can result in two different
     1:  * situations:
     1:  *
     1:  * 1. Zero-length "on" segments set in cairo_set_dash(). If the cap
 11708:  * style is %CAIRO_LINE_CAP_ROUND or %CAIRO_LINE_CAP_SQUARE then these
     1:  * segments will be drawn as circular dots or squares respectively. In
 11708:  * the case of %CAIRO_LINE_CAP_SQUARE, the orientation of the squares
     1:  * is determined by the direction of the underlying path.
     1:  *
     1:  * 2. A sub-path created by cairo_move_to() followed by either a
     1:  * cairo_close_path() or one or more calls to cairo_line_to() to the
     1:  * same coordinate as the cairo_move_to(). If the cap style is
 16122:  * %CAIRO_LINE_CAP_ROUND then these sub-paths will be drawn as circular
 11708:  * dots. Note that in the case of %CAIRO_LINE_CAP_SQUARE a degenerate
     1:  * sub-path will not be drawn at all, (since the correct orientation
     1:  * is indeterminate).
     1:  *
 11708:  * In no case will a cap style of %CAIRO_LINE_CAP_BUTT cause anything
     1:  * to be drawn in the case of either degenerate segments or sub-paths.
     1:  **/
     1: void
     1: cairo_stroke (cairo_t *cr)
     1: {
     1:     cairo_stroke_preserve (cr);
     1: 
     1:     cairo_new_path (cr);
     1: }
 21379: slim_hidden_def(cairo_stroke);
     1: 
     1: /**
     1:  * cairo_stroke_preserve:
     1:  * @cr: a cairo context
     1:  *
     1:  * A drawing operator that strokes the current path according to the
     1:  * current line width, line join, line cap, and dash settings. Unlike
 11708:  * cairo_stroke(), cairo_stroke_preserve() preserves the path within the
     1:  * cairo context.
     1:  *
     1:  * See cairo_set_line_width(), cairo_set_line_join(),
     1:  * cairo_set_line_cap(), cairo_set_dash(), and
     1:  * cairo_stroke_preserve().
     1:  **/
     1: void
     1: cairo_stroke_preserve (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_stroke (cr->gstate, cr->path);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_stroke_preserve);
     1: 
     1: /**
     1:  * cairo_fill:
     1:  * @cr: a cairo context
     1:  *
     1:  * A drawing operator that fills the current path according to the
     1:  * current fill rule, (each sub-path is implicitly closed before being
 11708:  * filled). After cairo_fill(), the current path will be cleared from
     1:  * the cairo context. See cairo_set_fill_rule() and
     1:  * cairo_fill_preserve().
     1:  **/
     1: void
     1: cairo_fill (cairo_t *cr)
     1: {
     1:     cairo_fill_preserve (cr);
     1: 
     1:     cairo_new_path (cr);
     1: }
     1: 
     1: /**
     1:  * cairo_fill_preserve:
     1:  * @cr: a cairo context
     1:  *
     1:  * A drawing operator that fills the current path according to the
     1:  * current fill rule, (each sub-path is implicitly closed before being
 11708:  * filled). Unlike cairo_fill(), cairo_fill_preserve() preserves the
     1:  * path within the cairo context.
     1:  *
     1:  * See cairo_set_fill_rule() and cairo_fill().
     1:  **/
     1: void
     1: cairo_fill_preserve (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_fill (cr->gstate, cr->path);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_fill_preserve);
     1: 
     1: /**
     1:  * cairo_copy_page:
     1:  * @cr: a cairo context
     1:  *
     1:  * Emits the current page for backends that support multiple pages, but
     1:  * doesn't clear it, so, the contents of the current page will be retained
     1:  * for the next page too.  Use cairo_show_page() if you want to get an
     1:  * empty page after the emission.
  6154:  *
  6154:  * This is a convenience function that simply calls
  6154:  * cairo_surface_copy_page() on @cr's target.
     1:  **/
     1: void
     1: cairo_copy_page (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_copy_page (cr->gstate);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_show_page:
     1:  * @cr: a cairo context
     1:  *
     1:  * Emits and clears the current page for backends that support multiple
     1:  * pages.  Use cairo_copy_page() if you don't want to clear the page.
  6154:  *
  6154:  * This is a convenience function that simply calls
  6154:  * cairo_surface_show_page() on @cr's target.
     1:  **/
     1: void
     1: cairo_show_page (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_show_page (cr->gstate);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_in_stroke:
     1:  * @cr: a cairo context
     1:  * @x: X coordinate of the point to test
     1:  * @y: Y coordinate of the point to test
     1:  *
     1:  * Tests whether the given point is inside the area that would be
     1:  * affected by a cairo_stroke() operation given the current path and
  4133:  * stroking parameters. Surface dimensions and clipping are not taken
  4133:  * into account.
     1:  *
     1:  * See cairo_stroke(), cairo_set_line_width(), cairo_set_line_join(),
     1:  * cairo_set_line_cap(), cairo_set_dash(), and
     1:  * cairo_stroke_preserve().
     1:  *
     1:  * Return value: A non-zero value if the point is inside, or zero if
     1:  * outside.
     1:  **/
     1: cairo_bool_t
     1: cairo_in_stroke (cairo_t *cr, double x, double y)
     1: {
  4133:     cairo_status_t status;
  4133:     cairo_bool_t inside = FALSE;
     1: 
 32473:     if (unlikely (cr->status))
 41340: 	return FALSE;
     1: 
  4133:     status = _cairo_gstate_in_stroke (cr->gstate,
   314: 				      cr->path,
     1: 				      x, y, &inside);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: 
     1:     return inside;
     1: }
     1: 
     1: /**
     1:  * cairo_in_fill:
     1:  * @cr: a cairo context
     1:  * @x: X coordinate of the point to test
     1:  * @y: Y coordinate of the point to test
     1:  *
     1:  * Tests whether the given point is inside the area that would be
     1:  * affected by a cairo_fill() operation given the current path and
  4133:  * filling parameters. Surface dimensions and clipping are not taken
  4133:  * into account.
     1:  *
     1:  * See cairo_fill(), cairo_set_fill_rule() and cairo_fill_preserve().
     1:  *
     1:  * Return value: A non-zero value if the point is inside, or zero if
     1:  * outside.
     1:  **/
     1: cairo_bool_t
     1: cairo_in_fill (cairo_t *cr, double x, double y)
     1: {
 32473:     if (unlikely (cr->status))
 41340: 	return FALSE;
 41340: 
 41340:     return _cairo_gstate_in_fill (cr->gstate, cr->path, x, y);
     1: }
     1: 
     1: /**
     1:  * cairo_stroke_extents:
     1:  * @cr: a cairo context
     1:  * @x1: left of the resulting extents
     1:  * @y1: top of the resulting extents
     1:  * @x2: right of the resulting extents
     1:  * @y2: bottom of the resulting extents
     1:  *
     1:  * Computes a bounding box in user coordinates covering the area that
 10694:  * would be affected, (the "inked" area), by a cairo_stroke()
 32473:  * operation given the current path and stroke parameters.
 32473:  * If the current path is empty, returns an empty rectangle ((0,0), (0,0)).
 32473:  * Surface dimensions and clipping are not taken into account.
 10694:  *
 10694:  * Note that if the line width is set to exactly zero, then
 13979:  * cairo_stroke_extents() will return an empty rectangle. Contrast with
 10694:  * cairo_path_extents() which can be used to compute the non-empty
 10694:  * bounds as the line width approaches zero.
     1:  *
 13979:  * Note that cairo_stroke_extents() must necessarily do more work to
 13979:  * compute the precise inked areas in light of the stroke parameters,
 13979:  * so cairo_path_extents() may be more desirable for sake of
 13979:  * performance if non-inked path extents are desired.
 13979:  *
     1:  * See cairo_stroke(), cairo_set_line_width(), cairo_set_line_join(),
     1:  * cairo_set_line_cap(), cairo_set_dash(), and
     1:  * cairo_stroke_preserve().
     1:  **/
     1: void
     1: cairo_stroke_extents (cairo_t *cr,
     1:                       double *x1, double *y1, double *x2, double *y2)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status)) {
 11708: 	if (x1)
 11708: 	    *x1 = 0.0;
 11708: 	if (y1)
 11708: 	    *y1 = 0.0;
 11708: 	if (x2)
 11708: 	    *x2 = 0.0;
 11708: 	if (y2)
 11708: 	    *y2 = 0.0;
 11708: 
     1: 	return;
 11708:     }
     1: 
  4133:     status = _cairo_gstate_stroke_extents (cr->gstate,
   314: 					   cr->path,
     1: 					   x1, y1, x2, y2);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_fill_extents:
     1:  * @cr: a cairo context
     1:  * @x1: left of the resulting extents
     1:  * @y1: top of the resulting extents
     1:  * @x2: right of the resulting extents
     1:  * @y2: bottom of the resulting extents
     1:  *
     1:  * Computes a bounding box in user coordinates covering the area that
 10694:  * would be affected, (the "inked" area), by a cairo_fill() operation
 10694:  * given the current path and fill parameters. If the current path is
 10694:  * empty, returns an empty rectangle ((0,0), (0,0)). Surface
 10694:  * dimensions and clipping are not taken into account.
 10694:  *
 10694:  * Contrast with cairo_path_extents(), which is similar, but returns
 13979:  * non-zero extents for some paths with no inked area, (such as a
 13979:  * simple line segment).
 13979:  *
 13979:  * Note that cairo_fill_extents() must necessarily do more work to
 13979:  * compute the precise inked areas in light of the fill rule, so
 13979:  * cairo_path_extents() may be more desirable for sake of performance
 13979:  * if the non-inked path extents are desired.
     1:  *
     1:  * See cairo_fill(), cairo_set_fill_rule() and cairo_fill_preserve().
     1:  **/
     1: void
     1: cairo_fill_extents (cairo_t *cr,
     1:                     double *x1, double *y1, double *x2, double *y2)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status)) {
 11708: 	if (x1)
 11708: 	    *x1 = 0.0;
 11708: 	if (y1)
 11708: 	    *y1 = 0.0;
 11708: 	if (x2)
 11708: 	    *x2 = 0.0;
 11708: 	if (y2)
 11708: 	    *y2 = 0.0;
 11708: 
     1: 	return;
 11708:     }
     1: 
  4133:     status = _cairo_gstate_fill_extents (cr->gstate,
   314: 					 cr->path,
     1: 					 x1, y1, x2, y2);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_clip:
     1:  * @cr: a cairo context
     1:  *
     1:  * Establishes a new clip region by intersecting the current clip
     1:  * region with the current path as it would be filled by cairo_fill()
     1:  * and according to the current fill rule (see cairo_set_fill_rule()).
     1:  *
 11708:  * After cairo_clip(), the current path will be cleared from the cairo
     1:  * context.
     1:  *
     1:  * The current clip region affects all drawing operations by
     1:  * effectively masking out any changes to the surface that are outside
     1:  * the current clip region.
     1:  *
     1:  * Calling cairo_clip() can only make the clip region smaller, never
     1:  * larger. But the current clip is part of the graphics state, so a
     1:  * temporary restriction of the clip region can be achieved by
     1:  * calling cairo_clip() within a cairo_save()/cairo_restore()
     1:  * pair. The only other means of increasing the size of the clip
     1:  * region is cairo_reset_clip().
     1:  **/
     1: void
     1: cairo_clip (cairo_t *cr)
     1: {
     1:     cairo_clip_preserve (cr);
     1: 
     1:     cairo_new_path (cr);
     1: }
     1: 
     1: /**
     1:  * cairo_clip_preserve:
     1:  * @cr: a cairo context
     1:  *
     1:  * Establishes a new clip region by intersecting the current clip
     1:  * region with the current path as it would be filled by cairo_fill()
     1:  * and according to the current fill rule (see cairo_set_fill_rule()).
     1:  *
 11708:  * Unlike cairo_clip(), cairo_clip_preserve() preserves the path within
     1:  * the cairo context.
     1:  *
     1:  * The current clip region affects all drawing operations by
     1:  * effectively masking out any changes to the surface that are outside
     1:  * the current clip region.
     1:  *
 32473:  * Calling cairo_clip_preserve() can only make the clip region smaller, never
     1:  * larger. But the current clip is part of the graphics state, so a
     1:  * temporary restriction of the clip region can be achieved by
 32473:  * calling cairo_clip_preserve() within a cairo_save()/cairo_restore()
     1:  * pair. The only other means of increasing the size of the clip
     1:  * region is cairo_reset_clip().
     1:  **/
     1: void
     1: cairo_clip_preserve (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_clip (cr->gstate, cr->path);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: slim_hidden_def(cairo_clip_preserve);
     1: 
     1: /**
     1:  * cairo_reset_clip:
     1:  * @cr: a cairo context
     1:  *
     1:  * Reset the current clip region to its original, unrestricted
     1:  * state. That is, set the clip region to an infinitely large shape
     1:  * containing the target surface. Equivalently, if infinity is too
     1:  * hard to grasp, one can imagine the clip region being reset to the
     1:  * exact bounds of the target surface.
     1:  *
     1:  * Note that code meant to be reusable should not call
     1:  * cairo_reset_clip() as it will cause results unexpected by
     1:  * higher-level code which calls cairo_clip(). Consider using
     1:  * cairo_save() and cairo_restore() around cairo_clip() as a more
     1:  * robust means of temporarily restricting the clip region.
     1:  **/
     1: void
     1: cairo_reset_clip (cairo_t *cr)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_reset_clip (cr->gstate);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_clip_extents:
     1:  * @cr: a cairo context
     1:  * @x1: left of the resulting extents
     1:  * @y1: top of the resulting extents
     1:  * @x2: right of the resulting extents
     1:  * @y2: bottom of the resulting extents
     1:  *
     1:  * Computes a bounding box in user coordinates covering the area inside the
     1:  * current clip.
     1:  *
     1:  * Since: 1.4
     1:  **/
     1: void
     1: cairo_clip_extents (cairo_t *cr,
     1: 		    double *x1, double *y1,
     1: 		    double *x2, double *y2)
     1: {
 32473:     if (unlikely (cr->status)) {
 11708: 	if (x1)
 11708: 	    *x1 = 0.0;
 11708: 	if (y1)
 11708: 	    *y1 = 0.0;
 11708: 	if (x2)
 11708: 	    *x2 = 0.0;
 11708: 	if (y2)
 11708: 	    *y2 = 0.0;
 11708: 
     1: 	return;
 11708:     }
     1: 
 41340:     if (! _cairo_gstate_clip_extents (cr->gstate, x1, y1, x2, y2)) {
 41340: 	*x1 = -INFINITY;
 41340: 	*y1 = -INFINITY;
 41340: 	*x2 = +INFINITY;
 41340: 	*y2 = +INFINITY;
 41340:     }
 41340: }
 41340: 
 41340: /**
 41340:  * cairo_in_clip:
 41340:  * @cr: a cairo context
 41340:  * @x: X coordinate of the point to test
 41340:  * @y: Y coordinate of the point to test
 41340:  *
 41340:  * Tests whether the given point is inside the area that would be
 41340:  * visible through the current clip, i.e. the area that would be filled by
 41340:  * a cairo_paint() operation.
 41340:  *
 41340:  * See cairo_clip(), and cairo_clip_preserve().
 41340:  *
 41340:  * Return value: A non-zero value if the point is inside, or zero if
 41340:  * outside.
 41340:  *
 41340:  * Since: 1.10
 41340:  **/
 41340: cairo_bool_t
 41340: cairo_in_clip (cairo_t *cr, double x, double y)
 41340: {
 41340:     if (unlikely (cr->status))
 41340: 	return FALSE;
 41340: 
 41340:     return _cairo_gstate_in_clip (cr->gstate, x, y);
     1: }
     1: 
     1: static cairo_rectangle_list_t *
     1: _cairo_rectangle_list_create_in_error (cairo_status_t status)
     1: {
     1:     cairo_rectangle_list_t *list;
     1: 
  4133:     if (status == CAIRO_STATUS_NO_MEMORY)
  4133:         return (cairo_rectangle_list_t*) &_cairo_rectangles_nil;
  4133: 
     1:     list = malloc (sizeof (cairo_rectangle_list_t));
 26419:     if (unlikely (list == NULL)) {
  8452: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1:         return (cairo_rectangle_list_t*) &_cairo_rectangles_nil;
  8452:     }
  8452: 
     1:     list->status = status;
     1:     list->rectangles = NULL;
     1:     list->num_rectangles = 0;
     1:     return list;
     1: }
     1: 
     1: /**
     1:  * cairo_copy_clip_rectangle_list:
   314:  * @cr: a cairo context
   314:  *
   314:  * Gets the current clip region as a list of rectangles in user coordinates.
     1:  * Never returns %NULL.
     1:  *
 11708:  * The status in the list may be %CAIRO_STATUS_CLIP_NOT_REPRESENTABLE to
     1:  * indicate that the clip region cannot be represented as a list of
     1:  * user-space rectangles. The status may have other values to indicate
     1:  * other errors.
     1:  *
 11708:  * Returns: the current clip region as a list of rectangles in user coordinates,
 11708:  * which should be destroyed using cairo_rectangle_list_destroy().
   314:  *
     1:  * Since: 1.4
     1:  **/
     1: cairo_rectangle_list_t *
     1: cairo_copy_clip_rectangle_list (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
     1:         return _cairo_rectangle_list_create_in_error (cr->status);
     1: 
     1:     return _cairo_gstate_copy_clip_rectangle_list (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_select_font_face:
     1:  * @cr: a #cairo_t
     1:  * @family: a font family name, encoded in UTF-8
     1:  * @slant: the slant for the font
     1:  * @weight: the weight for the font
     1:  *
 13980:  * Note: The cairo_select_font_face() function call is part of what
 13980:  * the cairo designers call the "toy" text API. It is convenient for
 13980:  * short demos and simple programs, but it is not expected to be
 13980:  * adequate for serious text-using applications.
 13980:  *
     1:  * Selects a family and style of font from a simplified description as
 13980:  * a family name, slant and weight. Cairo provides no operation to
 13980:  * list available family names on the system (this is a "toy",
 18904:  * remember), but the standard CSS2 generic family names, ("serif",
 13980:  * "sans-serif", "cursive", "fantasy", "monospace"), are likely to
 13980:  * work as expected.
 13980:  *
 26419:  * If @family starts with the string "@cairo:", or if no native font
 26419:  * backends are compiled in, cairo will use an internal font family.
 26419:  * The internal font family recognizes many modifiers in the @family
 26419:  * string, most notably, it recognizes the string "monospace".  That is,
 26419:  * the family name "@cairo:monospace" will use the monospace version of
 26419:  * the internal font family.
 26419:  *
 13980:  * For "real" font selection, see the font-backend-specific
 13980:  * font_face_create functions for the font backend you are using. (For
 13980:  * example, if you are using the freetype-based cairo-ft font backend,
 13980:  * see cairo_ft_font_face_create_for_ft_face() or
 13980:  * cairo_ft_font_face_create_for_pattern().) The resulting font face
 13980:  * could then be used with cairo_scaled_font_create() and
 13980:  * cairo_set_scaled_font().
 13980:  *
 13980:  * Similarly, when using the "real" font support, you can call
 13980:  * directly into the underlying font system, (such as fontconfig or
 13980:  * freetype), for operations such as listing available fonts, etc.
 13980:  *
 13980:  * It is expected that most applications will need to use a more
 13980:  * comprehensive font handling and text layout library, (for example,
 13980:  * pango), in conjunction with cairo.
 13980:  *
 13980:  * If text is drawn without a call to cairo_select_font_face(), (nor
 13980:  * cairo_set_font_face() nor cairo_set_scaled_font()), the default
 18904:  * family is platform-specific, but is essentially "sans-serif".
 18904:  * Default slant is %CAIRO_FONT_SLANT_NORMAL, and default weight is
 13980:  * %CAIRO_FONT_WEIGHT_NORMAL.
 18904:  *
 18904:  * This function is equivalent to a call to cairo_toy_font_face_create()
 18904:  * followed by cairo_set_font_face().
     1:  **/
     1: void
     1: cairo_select_font_face (cairo_t              *cr,
     1: 			const char           *family,
     1: 			cairo_font_slant_t    slant,
     1: 			cairo_font_weight_t   weight)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_select_font_face (cr->gstate, family, slant, weight);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_font_extents:
     1:  * @cr: a #cairo_t
     1:  * @extents: a #cairo_font_extents_t object into which the results
     1:  * will be stored.
     1:  *
     1:  * Gets the font extents for the currently selected font.
     1:  **/
     1: void
     1: cairo_font_extents (cairo_t              *cr,
     1: 		    cairo_font_extents_t *extents)
     1: {
  4133:     cairo_status_t status;
  4133: 
 11708:     extents->ascent = 0.0;
 11708:     extents->descent = 0.0;
 11708:     extents->height = 0.0;
 11708:     extents->max_x_advance = 0.0;
 11708:     extents->max_y_advance = 0.0;
 11708: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_get_font_extents (cr->gstate, extents);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_set_font_face:
     1:  * @cr: a #cairo_t
     1:  * @font_face: a #cairo_font_face_t, or %NULL to restore to the default font
     1:  *
     1:  * Replaces the current #cairo_font_face_t object in the #cairo_t with
     1:  * @font_face. The replaced font face in the #cairo_t will be
     1:  * destroyed if there are no other references to it.
     1:  **/
     1: void
     1: cairo_set_font_face (cairo_t           *cr,
     1: 		     cairo_font_face_t *font_face)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_font_face (cr->gstate, font_face);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
   314:  * cairo_get_font_face:
   314:  * @cr: a #cairo_t
   314:  *
   314:  * Gets the current font face for a #cairo_t.
   314:  *
   314:  * Return value: the current font face.  This object is owned by
   314:  * cairo. To keep a reference to it, you must call
 16122:  * cairo_font_face_reference().
   314:  *
   314:  * This function never returns %NULL. If memory cannot be allocated, a
   314:  * special "nil" #cairo_font_face_t object will be returned on which
   314:  * cairo_font_face_status() returns %CAIRO_STATUS_NO_MEMORY. Using
   314:  * this nil object will cause its error state to propagate to other
   314:  * objects it is passed to, (for example, calling
   314:  * cairo_set_font_face() with a nil font will trigger an error that
 11708:  * will shutdown the #cairo_t object).
   314:  **/
   314: cairo_font_face_t *
   314: cairo_get_font_face (cairo_t *cr)
   314: {
  4133:     cairo_status_t status;
   314:     cairo_font_face_t *font_face;
   314: 
 32473:     if (unlikely (cr->status))
   314: 	return (cairo_font_face_t*) &_cairo_font_face_nil;
   314: 
  4133:     status = _cairo_gstate_get_font_face (cr->gstate, &font_face);
 26419:     if (unlikely (status)) {
  4133: 	_cairo_set_error (cr, status);
   314: 	return (cairo_font_face_t*) &_cairo_font_face_nil;
   314:     }
   314: 
   314:     return font_face;
   314: }
   314: 
   314: /**
     1:  * cairo_set_font_size:
     1:  * @cr: a #cairo_t
     1:  * @size: the new font size, in user space units
     1:  *
     1:  * Sets the current font matrix to a scale by a factor of @size, replacing
     1:  * any font matrix previously set with cairo_set_font_size() or
     1:  * cairo_set_font_matrix(). This results in a font size of @size user space
     1:  * units. (More precisely, this matrix will result in the font's
     1:  * em-square being a @size by @size square in user space.)
 13980:  *
 13980:  * If text is drawn without a call to cairo_set_font_size(), (nor
 13980:  * cairo_set_font_matrix() nor cairo_set_scaled_font()), the default
 13980:  * font size is 10.0.
     1:  **/
     1: void
     1: cairo_set_font_size (cairo_t *cr, double size)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_font_size (cr->gstate, size);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
 16122: slim_hidden_def (cairo_set_font_size);
     1: 
     1: /**
     1:  * cairo_set_font_matrix
     1:  * @cr: a #cairo_t
     1:  * @matrix: a #cairo_matrix_t describing a transform to be applied to
     1:  * the current font.
     1:  *
     1:  * Sets the current font matrix to @matrix. The font matrix gives a
     1:  * transformation from the design space of the font (in this space,
     1:  * the em-square is 1 unit by 1 unit) to user space. Normally, a
     1:  * simple scale is used (see cairo_set_font_size()), but a more
     1:  * complex font matrix can be used to shear the font
     1:  * or stretch it unequally along the two axes
     1:  **/
     1: void
     1: cairo_set_font_matrix (cairo_t		    *cr,
     1: 		       const cairo_matrix_t *matrix)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_set_font_matrix (cr->gstate, matrix);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_get_font_matrix
     1:  * @cr: a #cairo_t
     1:  * @matrix: return value for the matrix
     1:  *
     1:  * Stores the current font matrix into @matrix. See
     1:  * cairo_set_font_matrix().
     1:  **/
     1: void
     1: cairo_get_font_matrix (cairo_t *cr, cairo_matrix_t *matrix)
     1: {
 32473:     if (unlikely (cr->status)) {
  8452: 	cairo_matrix_init_identity (matrix);
  8452: 	return;
  8452:     }
  8452: 
     1:     _cairo_gstate_get_font_matrix (cr->gstate, matrix);
     1: }
     1: 
     1: /**
     1:  * cairo_set_font_options:
     1:  * @cr: a #cairo_t
     1:  * @options: font options to use
     1:  *
     1:  * Sets a set of custom font rendering options for the #cairo_t.
     1:  * Rendering options are derived by merging these options with the
     1:  * options derived from underlying surface; if the value in @options
     1:  * has a default value (like %CAIRO_ANTIALIAS_DEFAULT), then the value
     1:  * from the surface is used.
     1:  **/
     1: void
     1: cairo_set_font_options (cairo_t                    *cr,
     1: 			const cairo_font_options_t *options)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
  4133:     status = cairo_font_options_status ((cairo_font_options_t *) options);
 26419:     if (unlikely (status)) {
  4133: 	_cairo_set_error (cr, status);
  4133: 	return;
  4133:     }
  4133: 
  4133:     _cairo_gstate_set_font_options (cr->gstate, options);
     1: }
 16122: slim_hidden_def (cairo_set_font_options);
     1: 
     1: /**
     1:  * cairo_get_font_options:
     1:  * @cr: a #cairo_t
     1:  * @options: a #cairo_font_options_t object into which to store
     1:  *   the retrieved options. All existing values are overwritten
     1:  *
     1:  * Retrieves font rendering options set via #cairo_set_font_options.
     1:  * Note that the returned options do not include any options derived
     1:  * from the underlying surface; they are literally the options
     1:  * passed to cairo_set_font_options().
     1:  **/
     1: void
     1: cairo_get_font_options (cairo_t              *cr,
     1: 			cairo_font_options_t *options)
     1: {
  4133:     /* check that we aren't trying to overwrite the nil object */
  4133:     if (cairo_font_options_status (options))
  4133: 	return;
  4133: 
 32473:     if (unlikely (cr->status)) {
  8452: 	_cairo_font_options_init_default (options);
  8452: 	return;
  8452:     }
  8452: 
     1:     _cairo_gstate_get_font_options (cr->gstate, options);
     1: }
     1: 
     1: /**
     1:  * cairo_set_scaled_font:
     1:  * @cr: a #cairo_t
     1:  * @scaled_font: a #cairo_scaled_font_t
     1:  *
     1:  * Replaces the current font face, font matrix, and font options in
     1:  * the #cairo_t with those of the #cairo_scaled_font_t.  Except for
     1:  * some translation, the current CTM of the #cairo_t should be the
     1:  * same as that of the #cairo_scaled_font_t, which can be accessed
     1:  * using cairo_scaled_font_get_ctm().
     1:  *
     1:  * Since: 1.2
     1:  **/
     1: void
     1: cairo_set_scaled_font (cairo_t                   *cr,
     1: 		       const cairo_scaled_font_t *scaled_font)
     1: {
  4133:     cairo_status_t status;
 32473:     cairo_bool_t was_previous;
 32473: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 18904:     if (scaled_font == NULL) {
 26419: 	status = _cairo_error (CAIRO_STATUS_NULL_POINTER);
 18904: 	goto BAIL;
 18904:     }
 18904: 
  4133:     status = scaled_font->status;
 26419:     if (unlikely (status))
     1:         goto BAIL;
     1: 
 26419:     if (scaled_font == cr->gstate->scaled_font)
 26419: 	return;
 26419: 
 32473:     was_previous = scaled_font == cr->gstate->previous_scaled_font;
 32473: 
  4133:     status = _cairo_gstate_set_font_face (cr->gstate, scaled_font->font_face);
 26419:     if (unlikely (status))
     1:         goto BAIL;
     1: 
  4133:     status = _cairo_gstate_set_font_matrix (cr->gstate, &scaled_font->font_matrix);
 26419:     if (unlikely (status))
     1:         goto BAIL;
     1: 
  4133:     _cairo_gstate_set_font_options (cr->gstate, &scaled_font->options);
     1: 
 48712:     /* XXX: Mozilla code assumes that the ctm of a scaled font doesn't need to
 48712:      * match the context ctm. This assumption breaks the previous_scaled_font
 48712:      * cache. So we avoid using the cache for now.
 32473:     if (was_previous)
 32473: 	cr->gstate->scaled_font = cairo_scaled_font_reference ((cairo_scaled_font_t *) scaled_font);
 48712:     */
 32473: 
     1:     return;
     1: 
     1: BAIL:
  4133:     _cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
   314:  * cairo_get_scaled_font:
   314:  * @cr: a #cairo_t
   314:  *
   314:  * Gets the current scaled font for a #cairo_t.
   314:  *
   314:  * Return value: the current scaled font. This object is owned by
   314:  * cairo. To keep a reference to it, you must call
   314:  * cairo_scaled_font_reference().
   314:  *
   314:  * This function never returns %NULL. If memory cannot be allocated, a
   314:  * special "nil" #cairo_scaled_font_t object will be returned on which
   314:  * cairo_scaled_font_status() returns %CAIRO_STATUS_NO_MEMORY. Using
   314:  * this nil object will cause its error state to propagate to other
   314:  * objects it is passed to, (for example, calling
   314:  * cairo_set_scaled_font() with a nil font will trigger an error that
 11708:  * will shutdown the #cairo_t object).
   314:  *
   314:  * Since: 1.4
   314:  **/
   314: cairo_scaled_font_t *
   314: cairo_get_scaled_font (cairo_t *cr)
   314: {
  4133:     cairo_status_t status;
   314:     cairo_scaled_font_t *scaled_font;
   314: 
 32473:     if (unlikely (cr->status))
 11886: 	return _cairo_scaled_font_create_in_error (cr->status);
   314: 
  4133:     status = _cairo_gstate_get_scaled_font (cr->gstate, &scaled_font);
 26419:     if (unlikely (status)) {
  4133: 	_cairo_set_error (cr, status);
 11886: 	return _cairo_scaled_font_create_in_error (status);
   314:     }
   314: 
   314:     return scaled_font;
   314: }
   314: 
   314: /**
     1:  * cairo_text_extents:
     1:  * @cr: a #cairo_t
 18904:  * @utf8: a NUL-terminated string of text encoded in UTF-8, or %NULL
     1:  * @extents: a #cairo_text_extents_t object into which the results
     1:  * will be stored
     1:  *
     1:  * Gets the extents for a string of text. The extents describe a
     1:  * user-space rectangle that encloses the "inked" portion of the text,
     1:  * (as it would be drawn by cairo_show_text()). Additionally, the
     1:  * x_advance and y_advance values indicate the amount by which the
     1:  * current point would be advanced by cairo_show_text().
     1:  *
     1:  * Note that whitespace characters do not directly contribute to the
     1:  * size of the rectangle (extents.width and extents.height). They do
     1:  * contribute indirectly by changing the position of non-whitespace
     1:  * characters. In particular, trailing whitespace characters are
     1:  * likely to not affect the size of the rectangle, though they will
     1:  * affect the x_advance and y_advance values.
     1:  **/
     1: void
     1: cairo_text_extents (cairo_t              *cr,
     1: 		    const char		 *utf8,
     1: 		    cairo_text_extents_t *extents)
     1: {
  4133:     cairo_status_t status;
     1:     cairo_glyph_t *glyphs = NULL;
     1:     int num_glyphs;
     1:     double x, y;
     1: 
     1:     extents->x_bearing = 0.0;
     1:     extents->y_bearing = 0.0;
     1:     extents->width  = 0.0;
     1:     extents->height = 0.0;
     1:     extents->x_advance = 0.0;
     1:     extents->y_advance = 0.0;
 10694: 
 32473:     if (unlikely (cr->status))
     1: 	return;
 10694: 
 10694:     if (utf8 == NULL)
 10694: 	return;
     1: 
     1:     cairo_get_current_point (cr, &x, &y);
     1: 
 18904:     status = _cairo_gstate_text_to_glyphs (cr->gstate,
     1: 					   x, y,
 18904: 					   utf8, strlen (utf8),
 18904: 					   &glyphs, &num_glyphs,
 18904: 					   NULL, NULL,
 18904: 					   NULL);
     1: 
 10694:     if (status == CAIRO_STATUS_SUCCESS)
 10694: 	status = _cairo_gstate_glyph_extents (cr->gstate,
 10694: 		                              glyphs, num_glyphs,
 10694: 					      extents);
 18904:     cairo_glyph_free (glyphs);
     1: 
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_glyph_extents:
     1:  * @cr: a #cairo_t
     1:  * @glyphs: an array of #cairo_glyph_t objects
     1:  * @num_glyphs: the number of elements in @glyphs
     1:  * @extents: a #cairo_text_extents_t object into which the results
     1:  * will be stored
     1:  *
     1:  * Gets the extents for an array of glyphs. The extents describe a
     1:  * user-space rectangle that encloses the "inked" portion of the
     1:  * glyphs, (as they would be drawn by cairo_show_glyphs()).
     1:  * Additionally, the x_advance and y_advance values indicate the
     1:  * amount by which the current point would be advanced by
 16122:  * cairo_show_glyphs().
     1:  *
     1:  * Note that whitespace glyphs do not contribute to the size of the
     1:  * rectangle (extents.width and extents.height).
     1:  **/
     1: void
     1: cairo_glyph_extents (cairo_t                *cr,
     1: 		     const cairo_glyph_t    *glyphs,
     1: 		     int                    num_glyphs,
     1: 		     cairo_text_extents_t   *extents)
     1: {
  4133:     cairo_status_t status;
  4133: 
 10694:     extents->x_bearing = 0.0;
 10694:     extents->y_bearing = 0.0;
 10694:     extents->width  = 0.0;
 10694:     extents->height = 0.0;
 10694:     extents->x_advance = 0.0;
 10694:     extents->y_advance = 0.0;
 10694: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 16122:     if (num_glyphs == 0)
 16122: 	return;
 16122: 
 16122:     if (num_glyphs < 0) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NEGATIVE_COUNT);
 16122: 	return;
 16122:     }
 16122: 
 16122:     if (glyphs == NULL) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
 16122: 	return;
 16122:     }
 16122: 
  4133:     status = _cairo_gstate_glyph_extents (cr->gstate, glyphs, num_glyphs,
     1: 					  extents);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_show_text:
     1:  * @cr: a cairo context
 18904:  * @utf8: a NUL-terminated string of text encoded in UTF-8, or %NULL
     1:  *
     1:  * A drawing operator that generates the shape from a string of UTF-8
     1:  * characters, rendered according to the current font_face, font_size
     1:  * (font_matrix), and font_options.
     1:  *
     1:  * This function first computes a set of glyphs for the string of
     1:  * text. The first glyph is placed so that its origin is at the
     1:  * current point. The origin of each subsequent glyph is offset from
     1:  * that of the previous glyph by the advance values of the previous
     1:  * glyph.
     1:  *
     1:  * After this call the current point is moved to the origin of where
     1:  * the next glyph would be placed in this same progression. That is,
     1:  * the current point will be at the origin of the final glyph offset
     1:  * by its advance values. This allows for easy display of a single
     1:  * logical string with multiple calls to cairo_show_text().
     1:  *
 11708:  * Note: The cairo_show_text() function call is part of what the cairo
     1:  * designers call the "toy" text API. It is convenient for short demos
   314:  * and simple programs, but it is not expected to be adequate for
   314:  * serious text-using applications. See cairo_show_glyphs() for the
   314:  * "real" text display API in cairo.
     1:  **/
     1: void
     1: cairo_show_text (cairo_t *cr, const char *utf8)
     1: {
     1:     cairo_text_extents_t extents;
  4133:     cairo_status_t status;
 26419:     cairo_glyph_t *glyphs, *last_glyph;
 26419:     cairo_text_cluster_t *clusters;
 18904:     int utf8_len, num_glyphs, num_clusters;
 21379:     cairo_text_cluster_flags_t cluster_flags;
     1:     double x, y;
 21379:     cairo_bool_t has_show_text_glyphs;
 26419:     cairo_glyph_t stack_glyphs[CAIRO_STACK_ARRAY_LENGTH (cairo_glyph_t)];
 26419:     cairo_text_cluster_t stack_clusters[CAIRO_STACK_ARRAY_LENGTH (cairo_text_cluster_t)];
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     if (utf8 == NULL)
     1: 	return;
     1: 
     1:     cairo_get_current_point (cr, &x, &y);
     1: 
 18904:     utf8_len = strlen (utf8);
 18904: 
 21379:     has_show_text_glyphs =
 21379: 	cairo_surface_has_show_text_glyphs (cairo_get_target (cr));
 21379: 
 26419:     glyphs = stack_glyphs;
 26419:     num_glyphs = ARRAY_LENGTH (stack_glyphs);
 26419: 
 26419:     if (has_show_text_glyphs) {
 26419: 	clusters = stack_clusters;
 26419: 	num_clusters = ARRAY_LENGTH (stack_clusters);
 26419:     } else {
 26419: 	clusters = NULL;
 26419: 	num_clusters = 0;
 26419:     }
 26419: 
 18904:     status = _cairo_gstate_text_to_glyphs (cr->gstate,
     1: 					   x, y,
 18904: 					   utf8, utf8_len,
 18904: 					   &glyphs, &num_glyphs,
 21379: 					   has_show_text_glyphs ? &clusters : NULL, &num_clusters,
 21379: 					   &cluster_flags);
 26419:     if (unlikely (status))
     1: 	goto BAIL;
     1: 
     1:     if (num_glyphs == 0)
     1: 	return;
     1: 
 16122:     status = _cairo_gstate_show_text_glyphs (cr->gstate,
 18904: 					     utf8, utf8_len,
 16122: 					     glyphs, num_glyphs,
 18904: 					     clusters, num_clusters,
 21379: 					     cluster_flags);
 26419:     if (unlikely (status))
     1: 	goto BAIL;
     1: 
     1:     last_glyph = &glyphs[num_glyphs - 1];
  4133:     status = _cairo_gstate_glyph_extents (cr->gstate,
     1: 					  last_glyph, 1,
     1: 					  &extents);
 26419:     if (unlikely (status))
     1: 	goto BAIL;
     1: 
     1:     x = last_glyph->x + extents.x_advance;
     1:     y = last_glyph->y + extents.y_advance;
     1:     cairo_move_to (cr, x, y);
     1: 
     1:  BAIL:
 26419:     if (glyphs != stack_glyphs)
 18904: 	cairo_glyph_free (glyphs);
 26419:     if (clusters != stack_clusters)
 18904: 	cairo_text_cluster_free (clusters);
     1: 
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
   314: /**
   314:  * cairo_show_glyphs:
   314:  * @cr: a cairo context
   314:  * @glyphs: array of glyphs to show
   314:  * @num_glyphs: number of glyphs to show
   314:  *
   314:  * A drawing operator that generates the shape from an array of glyphs,
 18904:  * rendered according to the current font face, font size
 18904:  * (font matrix), and font options.
   314:  **/
     1: void
     1: cairo_show_glyphs (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     if (num_glyphs == 0)
     1: 	return;
     1: 
 16122:     if (num_glyphs < 0) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NEGATIVE_COUNT);
 16122: 	return;
 16122:     }
 16122: 
 16122:     if (glyphs == NULL) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
 16122: 	return;
 16122:     }
 16122: 
 16122:     status = _cairo_gstate_show_text_glyphs (cr->gstate,
 16122: 					     NULL, 0,
 16122: 					     glyphs, num_glyphs,
 16122: 					     NULL, 0,
 16122: 					     FALSE);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
 18904: /**
 18904:  * cairo_show_text_glyphs:
 18904:  * @cr: a cairo context
 18904:  * @utf8: a string of text encoded in UTF-8
 18904:  * @utf8_len: length of @utf8 in bytes, or -1 if it is NUL-terminated
 18904:  * @glyphs: array of glyphs to show
 18904:  * @num_glyphs: number of glyphs to show
 18904:  * @clusters: array of cluster mapping information
 18904:  * @num_clusters: number of clusters in the mapping
 21379:  * @cluster_flags: cluster mapping flags
 18904:  *
 18904:  * This operation has rendering effects similar to cairo_show_glyphs()
 18904:  * but, if the target surface supports it, uses the provided text and
 18904:  * cluster mapping to embed the text for the glyphs shown in the output.
 21379:  * If the target does not support the extended attributes, this function
 21379:  * acts like the basic cairo_show_glyphs() as if it had been passed
 21379:  * @glyphs and @num_glyphs.
 18904:  *
 18904:  * The mapping between @utf8 and @glyphs is provided by an array of
 18904:  * <firstterm>clusters</firstterm>.  Each cluster covers a number of
 18904:  * text bytes and glyphs, and neighboring clusters cover neighboring
 18904:  * areas of @utf8 and @glyphs.  The clusters should collectively cover @utf8
 18904:  * and @glyphs in entirety.
 18904:  *
 18904:  * The first cluster always covers bytes from the beginning of @utf8.
 21379:  * If @cluster_flags do not have the %CAIRO_TEXT_CLUSTER_FLAG_BACKWARD
 21379:  * set, the first cluster also covers the beginning
 18904:  * of @glyphs, otherwise it covers the end of the @glyphs array and
 18904:  * following clusters move backward.
 18904:  *
 18904:  * See #cairo_text_cluster_t for constraints on valid clusters.
 18904:  *
 18904:  * Since: 1.8
 18904:  **/
 16122: void
 16122: cairo_show_text_glyphs (cairo_t			   *cr,
 16122: 			const char		   *utf8,
 16122: 			int			    utf8_len,
 16122: 			const cairo_glyph_t	   *glyphs,
 16122: 			int			    num_glyphs,
 16122: 			const cairo_text_cluster_t *clusters,
 16122: 			int			    num_clusters,
 21379: 			cairo_text_cluster_flags_t  cluster_flags)
 16122: {
 16122:     cairo_status_t status;
 16122: 
 32473:     if (unlikely (cr->status))
 16122: 	return;
 16122: 
 16122:     /* A slew of sanity checks */
 16122: 
 18904:     /* Special case for NULL and -1 */
 18904:     if (utf8 == NULL && utf8_len == -1)
 18904: 	utf8_len = 0;
 18904: 
 18904:     /* No NULLs for non-zeros */
 16122:     if ((num_glyphs   && glyphs   == NULL) ||
 16122: 	(utf8_len     && utf8     == NULL) ||
 16122: 	(num_clusters && clusters == NULL)) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
 16122: 	return;
 16122:     }
 16122: 
 18904:     /* A -1 for utf8_len means NUL-terminated */
 18904:     if (utf8_len == -1)
 18904: 	utf8_len = strlen (utf8);
 18904: 
 18904:     /* Apart from that, no negatives */
 18904:     if (num_glyphs < 0 || utf8_len < 0 || num_clusters < 0) {
 18904: 	_cairo_set_error (cr, CAIRO_STATUS_NEGATIVE_COUNT);
 18904: 	return;
 18904:     }
 18904: 
 18831:     /* Make sure clusters cover the entire glyphs and utf8 arrays,
 18831:      * and that cluster boundaries are UTF-8 boundaries. */
 18904:     status = _cairo_validate_text_clusters (utf8, utf8_len,
 18904: 					    glyphs, num_glyphs,
 21379: 					    clusters, num_clusters, cluster_flags);
 18904:     if (status == CAIRO_STATUS_INVALID_CLUSTERS) {
 18904: 	/* Either got invalid UTF-8 text, or cluster mapping is bad.
 18904: 	 * Differentiate those. */
 18904: 
 18904: 	cairo_status_t status2;
 18904: 
 18904: 	status2 = _cairo_utf8_to_ucs4 (utf8, utf8_len, NULL, NULL);
 18904: 	if (status2)
 18904: 	    status = status2;
 18904: 
 18831: 	_cairo_set_error (cr, status);
 18829: 	return;
 18829:     }
 18829: 
 16122:     if (num_glyphs == 0 && utf8_len == 0)
 16122: 	return;
 16122: 
 16122:     status = _cairo_gstate_show_text_glyphs (cr->gstate,
 16122: 					     utf8, utf8_len,
 16122: 					     glyphs, num_glyphs,
 21379: 					     clusters, num_clusters, cluster_flags);
 26419:     if (unlikely (status))
 16122: 	_cairo_set_error (cr, status);
 16122: }
 16122: 
   314: /**
   314:  * cairo_text_path:
   314:  * @cr: a cairo context
 18904:  * @utf8: a NUL-terminated string of text encoded in UTF-8, or %NULL
   314:  *
   314:  * Adds closed paths for text to the current path.  The generated
   314:  * path if filled, achieves an effect similar to that of
   314:  * cairo_show_text().
   314:  *
   314:  * Text conversion and positioning is done similar to cairo_show_text().
   314:  *
   314:  * Like cairo_show_text(), After this call the current point is
   314:  * moved to the origin of where the next glyph would be placed in
   314:  * this same progression.  That is, the current point will be at
   314:  * the origin of the final glyph offset by its advance values.
   314:  * This allows for chaining multiple calls to to cairo_text_path()
   314:  * without having to set current point in between.
   314:  *
 11708:  * Note: The cairo_text_path() function call is part of what the cairo
   314:  * designers call the "toy" text API. It is convenient for short demos
   314:  * and simple programs, but it is not expected to be adequate for
   314:  * serious text-using applications. See cairo_glyph_path() for the
   314:  * "real" text path API in cairo.
   314:  **/
     1: void
     1: cairo_text_path  (cairo_t *cr, const char *utf8)
     1: {
  4133:     cairo_status_t status;
   314:     cairo_text_extents_t extents;
 26419:     cairo_glyph_t stack_glyphs[CAIRO_STACK_ARRAY_LENGTH (cairo_glyph_t)];
 26419:     cairo_glyph_t *glyphs, *last_glyph;
     1:     int num_glyphs;
     1:     double x, y;
     1: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 10414:     if (utf8 == NULL)
 10414: 	return;
 10414: 
     1:     cairo_get_current_point (cr, &x, &y);
     1: 
 26419:     glyphs = stack_glyphs;
 26419:     num_glyphs = ARRAY_LENGTH (stack_glyphs);
 26419: 
 18904:     status = _cairo_gstate_text_to_glyphs (cr->gstate,
     1: 					   x, y,
 18904: 					   utf8, strlen (utf8),
 18904: 					   &glyphs, &num_glyphs,
 18904: 					   NULL, NULL,
 18904: 					   NULL);
     1: 
 26419:     if (unlikely (status))
   314: 	goto BAIL;
   314: 
   314:     if (num_glyphs == 0)
     1: 	return;
     1: 
  4133:     status = _cairo_gstate_glyph_path (cr->gstate,
     1: 				       glyphs, num_glyphs,
   314: 				       cr->path);
   314: 
 26419:     if (unlikely (status))
   314: 	goto BAIL;
   314: 
   314:     last_glyph = &glyphs[num_glyphs - 1];
  4133:     status = _cairo_gstate_glyph_extents (cr->gstate,
   314: 					  last_glyph, 1,
   314: 					  &extents);
   314: 
 26419:     if (unlikely (status))
   314: 	goto BAIL;
   314: 
   314:     x = last_glyph->x + extents.x_advance;
   314:     y = last_glyph->y + extents.y_advance;
   314:     cairo_move_to (cr, x, y);
   314: 
   314:  BAIL:
 26419:     if (glyphs != stack_glyphs)
 18904: 	cairo_glyph_free (glyphs);
     1: 
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
   314: /**
   314:  * cairo_glyph_path:
   314:  * @cr: a cairo context
   314:  * @glyphs: array of glyphs to show
   314:  * @num_glyphs: number of glyphs to show
   314:  *
   314:  * Adds closed paths for the glyphs to the current path.  The generated
   314:  * path if filled, achieves an effect similar to that of
   314:  * cairo_show_glyphs().
   314:  **/
     1: void
     1: cairo_glyph_path (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
 10414:     if (num_glyphs == 0)
 10414: 	return;
 10414: 
 16122:     if (num_glyphs < 0) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NEGATIVE_COUNT);
 16122: 	return;
 16122:     }
 16122: 
 16122:     if (glyphs == NULL) {
 16122: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
 16122: 	return;
 16122:     }
 16122: 
  4133:     status = _cairo_gstate_glyph_path (cr->gstate,
     1: 				       glyphs, num_glyphs,
   314: 				       cr->path);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_get_operator:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current compositing operator for a cairo context.
     1:  *
     1:  * Return value: the current compositing operator.
     1:  **/
     1: cairo_operator_t
     1: cairo_get_operator (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_OPERATOR_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_operator (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_get_tolerance:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current tolerance value, as set by cairo_set_tolerance().
     1:  *
     1:  * Return value: the current tolerance value.
     1:  **/
     1: double
     1: cairo_get_tolerance (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_TOLERANCE_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_tolerance (cr->gstate);
     1: }
     1: slim_hidden_def (cairo_get_tolerance);
     1: 
     1: /**
     1:  * cairo_get_antialias:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current shape antialiasing mode, as set by cairo_set_shape_antialias().
     1:  *
     1:  * Return value: the current shape antialiasing mode.
     1:  **/
     1: cairo_antialias_t
     1: cairo_get_antialias (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_ANTIALIAS_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_antialias (cr->gstate);
     1: }
     1: 
     1: /**
 11708:  * cairo_has_current_point:
 11708:  * @cr: a cairo context
 11708:  *
 11708:  * Returns whether a current point is defined on the current path.
 11708:  * See cairo_get_current_point() for details on the current point.
 11708:  *
 11708:  * Return value: whether a current point is defined.
 11708:  *
 11708:  * Since: 1.6
 11708:  **/
 11708: cairo_bool_t
 11708: cairo_has_current_point (cairo_t *cr)
 11708: {
 32473:     if (unlikely (cr->status))
 11708:     return FALSE;
 11708: 
 11708:     return cr->path->has_current_point;
 11708: }
 11708: 
 11708: /**
     1:  * cairo_get_current_point:
     1:  * @cr: a cairo context
     1:  * @x: return value for X coordinate of the current point
     1:  * @y: return value for Y coordinate of the current point
     1:  *
     1:  * Gets the current point of the current path, which is
     1:  * conceptually the final point reached by the path so far.
     1:  *
     1:  * The current point is returned in the user-space coordinate
 11708:  * system. If there is no defined current point or if @cr is in an
 11708:  * error status, @x and @y will both be set to 0.0. It is possible to
 11708:  * check this in advance with cairo_has_current_point().
     1:  *
     1:  * Most path construction functions alter the current point. See the
     1:  * following for details on how they affect the current point:
  4133:  * cairo_new_path(), cairo_new_sub_path(),
  4133:  * cairo_append_path(), cairo_close_path(),
  4133:  * cairo_move_to(), cairo_line_to(), cairo_curve_to(),
  4133:  * cairo_rel_move_to(), cairo_rel_line_to(), cairo_rel_curve_to(),
  4133:  * cairo_arc(), cairo_arc_negative(), cairo_rectangle(),
 18904:  * cairo_text_path(), cairo_glyph_path(), cairo_stroke_to_path().
 18904:  *
 18904:  * Some functions use and alter the current point but do not
 18904:  * otherwise change current path:
 18904:  * cairo_show_text().
  4133:  *
  4133:  * Some functions unset the current path and as a result, current point:
  4133:  * cairo_fill(), cairo_stroke().
     1:  **/
     1: void
     1: cairo_get_current_point (cairo_t *cr, double *x_ret, double *y_ret)
     1: {
     1:     cairo_fixed_t x_fixed, y_fixed;
     1:     double x, y;
     1: 
  8452:     if (cr->status == CAIRO_STATUS_SUCCESS &&
  8452: 	_cairo_path_fixed_get_current_point (cr->path, &x_fixed, &y_fixed))
  8452:     {
     1: 	x = _cairo_fixed_to_double (x_fixed);
     1: 	y = _cairo_fixed_to_double (y_fixed);
     1: 	_cairo_gstate_backend_to_user (cr->gstate, &x, &y);
     1:     }
  8452:     else
  8452:     {
  8452: 	x = 0.0;
  8452: 	y = 0.0;
  8452:     }
     1: 
     1:     if (x_ret)
     1: 	*x_ret = x;
     1:     if (y_ret)
     1: 	*y_ret = y;
     1: }
     1: slim_hidden_def(cairo_get_current_point);
     1: 
     1: /**
     1:  * cairo_get_fill_rule:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current fill rule, as set by cairo_set_fill_rule().
     1:  *
     1:  * Return value: the current fill rule.
     1:  **/
     1: cairo_fill_rule_t
     1: cairo_get_fill_rule (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_FILL_RULE_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_fill_rule (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_get_line_width:
     1:  * @cr: a cairo context
     1:  *
   314:  * This function returns the current line width value exactly as set by
     1:  * cairo_set_line_width(). Note that the value is unchanged even if
     1:  * the CTM has changed between the calls to cairo_set_line_width() and
     1:  * cairo_get_line_width().
   314:  *
   314:  * Return value: the current line width.
     1:  **/
     1: double
     1: cairo_get_line_width (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_LINE_WIDTH_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_line_width (cr->gstate);
     1: }
 21379: slim_hidden_def (cairo_get_line_width);
     1: 
     1: /**
     1:  * cairo_get_line_cap:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current line cap style, as set by cairo_set_line_cap().
     1:  *
     1:  * Return value: the current line cap style.
     1:  **/
     1: cairo_line_cap_t
     1: cairo_get_line_cap (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_LINE_CAP_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_line_cap (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_get_line_join:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current line join style, as set by cairo_set_line_join().
     1:  *
     1:  * Return value: the current line join style.
     1:  **/
     1: cairo_line_join_t
     1: cairo_get_line_join (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_LINE_JOIN_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_line_join (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_get_miter_limit:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the current miter limit, as set by cairo_set_miter_limit().
     1:  *
     1:  * Return value: the current miter limit.
     1:  **/
     1: double
     1: cairo_get_miter_limit (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 16122:         return CAIRO_GSTATE_MITER_LIMIT_DEFAULT;
  8452: 
     1:     return _cairo_gstate_get_miter_limit (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_get_matrix:
     1:  * @cr: a cairo context
     1:  * @matrix: return value for the matrix
     1:  *
     1:  * Stores the current transformation matrix (CTM) into @matrix.
     1:  **/
     1: void
     1: cairo_get_matrix (cairo_t *cr, cairo_matrix_t *matrix)
     1: {
 32473:     if (unlikely (cr->status)) {
  8452: 	cairo_matrix_init_identity (matrix);
  8452: 	return;
  8452:     }
  8452: 
     1:     _cairo_gstate_get_matrix (cr->gstate, matrix);
     1: }
     1: slim_hidden_def (cairo_get_matrix);
     1: 
     1: /**
     1:  * cairo_get_target:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets the target surface for the cairo context as passed to
     1:  * cairo_create().
     1:  *
     1:  * This function will always return a valid pointer, but the result
     1:  * can be a "nil" surface if @cr is already in an error state,
     1:  * (ie. cairo_status() <literal>!=</literal> %CAIRO_STATUS_SUCCESS).
     1:  * A nil surface is indicated by cairo_surface_status()
     1:  * <literal>!=</literal> %CAIRO_STATUS_SUCCESS.
     1:  *
     1:  * Return value: the target surface. This object is owned by cairo. To
     1:  * keep a reference to it, you must call cairo_surface_reference().
     1:  **/
     1: cairo_surface_t *
     1: cairo_get_target (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 10694: 	return _cairo_surface_create_in_error (cr->status);
     1: 
     1:     return _cairo_gstate_get_original_target (cr->gstate);
     1: }
 18904: slim_hidden_def (cairo_get_target);
     1: 
     1: /**
     1:  * cairo_get_group_target:
     1:  * @cr: a cairo context
     1:  *
 10414:  * Gets the current destination surface for the context. This is either
 10414:  * the original target surface as passed to cairo_create() or the target
 10414:  * surface for the current group as started by the most recent call to
 10414:  * cairo_push_group() or cairo_push_group_with_content().
 10414:  *
 10414:  * This function will always return a valid pointer, but the result
 10414:  * can be a "nil" surface if @cr is already in an error state,
 10414:  * (ie. cairo_status() <literal>!=</literal> %CAIRO_STATUS_SUCCESS).
 10414:  * A nil surface is indicated by cairo_surface_status()
 10414:  * <literal>!=</literal> %CAIRO_STATUS_SUCCESS.
 10414:  *
 10414:  * Return value: the target surface. This object is owned by cairo. To
 10414:  * keep a reference to it, you must call cairo_surface_reference().
     1:  *
     1:  * Since: 1.2
     1:  **/
     1: cairo_surface_t *
     1: cairo_get_group_target (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
 10694: 	return _cairo_surface_create_in_error (cr->status);
     1: 
     1:     return _cairo_gstate_get_target (cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_copy_path:
     1:  * @cr: a cairo context
     1:  *
     1:  * Creates a copy of the current path and returns it to the user as a
     1:  * #cairo_path_t. See #cairo_path_data_t for hints on how to iterate
     1:  * over the returned data structure.
     1:  *
     1:  * This function will always return a valid pointer, but the result
 11708:  * will have no data (<literal>data==%NULL</literal> and
     1:  * <literal>num_data==0</literal>), if either of the following
     1:  * conditions hold:
     1:  *
     1:  * <orderedlist>
     1:  * <listitem>If there is insufficient memory to copy the path. In this
     1:  *     case <literal>path->status</literal> will be set to
     1:  *     %CAIRO_STATUS_NO_MEMORY.</listitem>
     1:  * <listitem>If @cr is already in an error state. In this case
     1:  *    <literal>path->status</literal> will contain the same status that
     1:  *    would be returned by cairo_status().</listitem>
     1:  * </orderedlist>
     1:  *
     1:  * Return value: the copy of the current path. The caller owns the
     1:  * returned object and should call cairo_path_destroy() when finished
     1:  * with it.
     1:  **/
     1: cairo_path_t *
     1: cairo_copy_path (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return _cairo_path_create_in_error (cr->status);
     1: 
   314:     return _cairo_path_create (cr->path, cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_copy_path_flat:
     1:  * @cr: a cairo context
     1:  *
     1:  * Gets a flattened copy of the current path and returns it to the
     1:  * user as a #cairo_path_t. See #cairo_path_data_t for hints on
     1:  * how to iterate over the returned data structure.
     1:  *
     1:  * This function is like cairo_copy_path() except that any curves
     1:  * in the path will be approximated with piecewise-linear
     1:  * approximations, (accurate to within the current tolerance
     1:  * value). That is, the result is guaranteed to not have any elements
     1:  * of type %CAIRO_PATH_CURVE_TO which will instead be replaced by a
     1:  * series of %CAIRO_PATH_LINE_TO elements.
     1:  *
     1:  * This function will always return a valid pointer, but the result
 11708:  * will have no data (<literal>data==%NULL</literal> and
     1:  * <literal>num_data==0</literal>), if either of the following
     1:  * conditions hold:
     1:  *
     1:  * <orderedlist>
     1:  * <listitem>If there is insufficient memory to copy the path. In this
     1:  *     case <literal>path->status</literal> will be set to
     1:  *     %CAIRO_STATUS_NO_MEMORY.</listitem>
     1:  * <listitem>If @cr is already in an error state. In this case
     1:  *    <literal>path->status</literal> will contain the same status that
     1:  *    would be returned by cairo_status().</listitem>
     1:  * </orderedlist>
     1:  *
     1:  * Return value: the copy of the current path. The caller owns the
     1:  * returned object and should call cairo_path_destroy() when finished
     1:  * with it.
     1:  **/
     1: cairo_path_t *
     1: cairo_copy_path_flat (cairo_t *cr)
     1: {
 32473:     if (unlikely (cr->status))
     1: 	return _cairo_path_create_in_error (cr->status);
     1: 
   314:     return _cairo_path_create_flat (cr->path, cr->gstate);
     1: }
     1: 
     1: /**
     1:  * cairo_append_path:
     1:  * @cr: a cairo context
     1:  * @path: path to be appended
     1:  *
     1:  * Append the @path onto the current path. The @path may be either the
     1:  * return value from one of cairo_copy_path() or
     1:  * cairo_copy_path_flat() or it may be constructed manually.  See
     1:  * #cairo_path_t for details on how the path data structure should be
     1:  * initialized, and note that <literal>path->status</literal> must be
     1:  * initialized to %CAIRO_STATUS_SUCCESS.
     1:  **/
     1: void
     1: cairo_append_path (cairo_t		*cr,
     1: 		   const cairo_path_t	*path)
     1: {
  4133:     cairo_status_t status;
  4133: 
 32473:     if (unlikely (cr->status))
     1: 	return;
     1: 
     1:     if (path == NULL) {
     1: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
     1: 	return;
     1:     }
     1: 
     1:     if (path->status) {
     1: 	if (path->status > CAIRO_STATUS_SUCCESS &&
     1: 	    path->status <= CAIRO_STATUS_LAST_STATUS)
     1: 	    _cairo_set_error (cr, path->status);
     1: 	else
     1: 	    _cairo_set_error (cr, CAIRO_STATUS_INVALID_STATUS);
     1: 	return;
     1:     }
     1: 
  8452:     if (path->num_data == 0)
  8452: 	return;
  8452: 
     1:     if (path->data == NULL) {
     1: 	_cairo_set_error (cr, CAIRO_STATUS_NULL_POINTER);
     1: 	return;
     1:     }
     1: 
  4133:     status = _cairo_path_append_to_context (path, cr);
 26419:     if (unlikely (status))
  4133: 	_cairo_set_error (cr, status);
     1: }
     1: 
     1: /**
     1:  * cairo_status:
     1:  * @cr: a cairo context
     1:  *
     1:  * Checks whether an error has previously occurred for this context.
     1:  *
 11708:  * Returns: the current status of this context, see #cairo_status_t
     1:  **/
     1: cairo_status_t
     1: cairo_status (cairo_t *cr)
     1: {
     1:     return cr->status;
     1: }
     1: slim_hidden_def (cairo_status);
