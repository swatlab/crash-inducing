47525: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
47525:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
47525:  *
47525:  * ***** BEGIN LICENSE BLOCK *****
47525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47525:  *
47525:  * The contents of this file are subject to the Mozilla Public License Version
47525:  * 1.1 (the "License"); you may not use this file except in compliance with
47525:  * the License. You may obtain a copy of the License at
47525:  * http://www.mozilla.org/MPL/
47525:  *
47525:  * Software distributed under the License is distributed on an "AS IS" basis,
47525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47525:  * for the specific language governing rights and limitations under the
47525:  * License.
47525:  *
47525:  * The Original Code is mozilla.org code, released
47525:  * June 24, 2010.
47525:  *
47525:  * The Initial Developer of the Original Code is
47525:  *    The Mozilla Foundation
47525:  *
47525:  * Contributor(s):
47525:  *    Andreas Gal <gal@mozilla.com>
47525:  *
47525:  * Alternatively, the contents of this file may be used under the terms of
47525:  * either of the GNU General Public License Version 2 or later (the "GPL"),
47525:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47525:  * in which case the provisions of the GPL or the LGPL are applicable instead
47525:  * of those above. If you wish to allow use of your version of this file only
47525:  * under the terms of either the GPL or the LGPL, and not to allow others to
47525:  * use your version of this file under the terms of the MPL, indicate your
47525:  * decision by deleting the provisions above and replace them with the notice
47525:  * and other provisions required by the GPL or the LGPL. If you do not delete
47525:  * the provisions above, a recipient may use your version of this file under
47525:  * the terms of any one of the MPL, the GPL or the LGPL.
47525:  *
47525:  * ***** END LICENSE BLOCK ***** */
47525: 
47574: #include "jsobj.h"
55599: #include "jsvalue.h"
47574: 
47525: #include "WrapperFactory.h"
47574: #include "CrossOriginWrapper.h"
47574: #include "FilteringWrapper.h"
47574: #include "XrayWrapper.h"
47525: #include "AccessCheck.h"
55628: #include "XPCWrapper.h"
47525: 
47574: #include "xpcprivate.h"
47574: 
47525: namespace xpc {
47525: 
47574: // When chrome pulls a naked property across the membrane using
47574: // .wrappedJSObject, we want it to cross the membrane into the
47574: // chrome compartment without automatically being wrapped into an
47574: // X-ray wrapper. We achieve this by wrapping it into a special
47574: // transparent wrapper in the origin (non-chrome) compartment. When
47574: // an object with that special wrapper applied crosses into chrome,
47574: // we know to not apply an X-ray wrapper.
47574: JSWrapper WaiveXrayWrapperWrapper(WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG);
47574: 
47574: // When objects for which we waived the X-ray wrapper cross into
47574: // chrome, we wrap them into a special cross-compartment wrapper
47574: // that transitively extends the waiver to all properties we get
47574: // off it.
55691: CrossOriginWrapper CrossOriginWrapper::singleton(0);
55691: 
55691: static JSObject *
55691: DoubleWrap(JSContext *cx, JSObject *obj, uintN flags)
55691: {
55691:     if (flags & WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG) {
55691:         js::SwitchToCompartment sc(cx, obj->compartment());
55691:         return JSWrapper::New(cx, obj, NULL, obj->getParent(),
55691:                               &WaiveXrayWrapperWrapper);
55691:     }
55691:     return obj;
55691: }
47574: 
47574: JSObject *
55628: WrapperFactory::PrepareForWrapping(JSContext *cx, JSObject *scope, JSObject *obj, uintN flags)
55628: {
55691:     // Don't unwrap an outer window, just double wrap it if needed.
55691:     if (obj->getClass()->ext.innerObject)
55691:         return DoubleWrap(cx, obj, flags);
55691: 
55628:     // Here are the rules for wrapping:
55628:     // We should never get a proxy here (the JS engine unwraps those for us).
55691:     JS_ASSERT(!obj->isWrapper());
55628: 
55628:     // As soon as an object is wrapped in a security wrapper, it morphs to be
55628:     // a fat wrapper. (see also: bug XXX).
55628:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
55628:         return nsnull;
55628: 
55628:     // We only hand out outer objects to script.
55628:     OBJ_TO_OUTER_OBJECT(cx, obj);
55705:     if (!obj)
55705:         return nsnull;
55628: 
55628:     // Now, our object is ready to be wrapped, but several objects (notably
55628:     // nsJSIIDs) have a wrapper per scope. If we are about to wrap one of
55628:     // those objects in a security wrapper, then we need to hand back the
55689:     // wrapper for the new scope instead. Also, global objects don't move
55689:     // between scopes so for those we also want to return the wrapper. So...
55689:     if (!IS_WN_WRAPPER(obj) || !obj->getParent())
55691:         return DoubleWrap(cx, obj, flags);
55628: 
55628:     XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
55628: 
55628:     // We know that DOM objects only allow one object, we can return early.
55728:     if (wn->HasProto() && wn->GetProto()->ClassIsDOMObject())
55691:         return DoubleWrap(cx, obj, flags);
55628: 
55628:     XPCCallContext ccx(JS_CALLER, cx, obj);
55628:     if (NATIVE_HAS_FLAG(&ccx, WantPreCreate)) {
55628:         // We have a precreate hook. This object might enforce that we only
55628:         // ever create JS object for it.
55628:         JSObject *originalScope = scope;
55628:         nsresult rv = wn->GetScriptableInfo()->GetCallback()->
55628:             PreCreate(wn->Native(), cx, scope, &scope);
55691:         NS_ENSURE_SUCCESS(rv, DoubleWrap(cx, obj, flags));
55628: 
55628:         // If the handed back scope differs from the passed-in scope and is in
55628:         // a separate compartment, then this object is explicitly requesting
55628:         // that we don't create a second JS object for it: create a security
55628:         // wrapper.
55628:         if (originalScope->getCompartment() != scope->getCompartment())
55691:             return DoubleWrap(cx, obj, flags);
55628: 
55628:         // Note: this penalizes objects that only have one wrapper, but are
55628:         // being accessed across compartments. We would really prefer to
55628:         // replace the above code with a test that says "do you only have one
55628:         // wrapper?"
55628:     }
55628: 
55628:     // The object we're looking at might allow us to create a new wrapped
55628:     // native in the new scope. Try it and continue wrapping on the
55628:     // possibly-new object.
55628:     JSAutoEnterCompartment ac;
55628:     if (!ac.enter(cx, scope))
55691:         return nsnull;
55691: 
55628:     jsval v;
55628:     nsresult rv =
55628:         nsXPConnect::FastGetXPConnect()->WrapNativeToJSVal(cx, scope, wn->Native(), nsnull,
55628:                                                            &NS_GET_IID(nsISupports), PR_FALSE,
55628:                                                            &v, nsnull);
55691:     if (NS_SUCCEEDED(rv))
55691:         obj = JSVAL_TO_OBJECT(v);
55691: 
55691:     return DoubleWrap(cx, obj, flags);
55628: }
55628: 
55628: JSObject *
55580: WrapperFactory::Rewrap(JSContext *cx, JSObject *obj, JSObject *wrappedProto, JSObject *parent,
55580:                        uintN flags)
47525: {
55691:     NS_ASSERTION(!obj->isWrapper() ||
55691:                  (obj->isWrapper() &&
55691:                   obj->getProxyHandler() == &WaiveXrayWrapperWrapper) ||
55691:                  obj->getClass()->ext.innerObject,
54404:                  "wrapped object passed to rewrap");
55602:     NS_ASSERTION(JS_GET_CLASS(cx, obj) != &XrayUtils::HolderClass, "trying to wrap a holder");
47574: 
55606:     JSCompartment *origin = obj->getCompartment();
47574:     JSCompartment *target = cx->compartment;
55599:     JSObject *xrayHolder = nsnull;
47574: 
47574:     JSWrapper *wrapper;
55733:     CompartmentPrivate *targetdata = static_cast<CompartmentPrivate *>(target->data);
47574:     if (AccessCheck::isChrome(target)) {
55591:         if (AccessCheck::isChrome(origin)) {
55675:             // Same origin we use a transparent wrapper, unless the compartment asks
55675:             // for an Xray.
55733:             if (targetdata && targetdata->preferXrays && IS_WN_WRAPPER(obj)) {
55675:                 typedef XrayWrapper<JSCrossCompartmentWrapper, CrossCompartmentXray> Xray;
55675:                 wrapper = &Xray::singleton;
55675:                 xrayHolder = Xray::createHolder(cx, obj, parent);
55675:                 if (!xrayHolder)
55675:                     return nsnull;
55675:             } else {
55591:                 wrapper = &JSCrossCompartmentWrapper::singleton;
55675:             }
55591:         } else if (flags & WAIVE_XRAY_WRAPPER_FLAG) {
47574:             // If we waived the X-ray wrapper for this object, wrap it into a
47574:             // special wrapper to transitively maintain the X-ray waiver.
55691:             wrapper = &CrossOriginWrapper::singleton;
47574:         } else {
47574:             // Native objects must be wrapped into an X-ray wrapper.
55582:             if (!obj->getGlobal()->isSystem() &&
55582:                 (IS_WN_WRAPPER(obj) || obj->getClass()->ext.innerObject)) {
55599:                 typedef XrayWrapper<JSCrossCompartmentWrapper, CrossCompartmentXray> Xray;
55582:                 wrapper = &Xray::singleton;
55599:                 xrayHolder = Xray::createHolder(cx, obj, parent);
55599:                 if (!xrayHolder)
55599:                     return nsnull;
55582:             } else {
55582:                 wrapper = &JSCrossCompartmentWrapper::singleton;
55582:             }
47525:         }
47574:     } else if (AccessCheck::isChrome(origin)) {
55700:         wrapper = &FilteringWrapper<JSCrossCompartmentWrapper,
55700:                                     ExposedPropertiesOnly>::singleton;
55700:     } else if (AccessCheck::isSameOrigin(origin, target)) {
55700:         // Same origin we use a transparent wrapper, unless the compartment asks
55700:         // for an Xray or the wrapper needs a SOW.
47574:         if (AccessCheck::needsSystemOnlyWrapper(obj)) {
47574:             wrapper = &FilteringWrapper<JSCrossCompartmentWrapper,
47574:                                         OnlyIfSubjectIsSystem>::singleton;
55733:         } else if (targetdata && targetdata->preferXrays && IS_WN_WRAPPER(obj)) {
55675:             typedef XrayWrapper<JSCrossCompartmentWrapper, CrossCompartmentXray> Xray;
55675:             wrapper = &Xray::singleton;
55675:             xrayHolder = Xray::createHolder(cx, obj, parent);
55675:             if (!xrayHolder)
55675:                 return nsnull;
55675:         } else {
47574:             wrapper = &JSCrossCompartmentWrapper::singleton;
55675:         }
47574:     } else {
55700:         NS_ASSERTION(!AccessCheck::needsSystemOnlyWrapper(obj),
55700:                      "bad object exposed across origins");
55700: 
47574:         // Cross origin we want to disallow scripting and limit access to
47574:         // a predefined set of properties. XrayWrapper adds a property
47574:         // (.wrappedJSObject) which allows bypassing the XrayWrapper, but
47574:         // we filter out access to that property.
55653:         if (!IS_WN_WRAPPER(obj) && !obj->getClass()->ext.innerObject) {
55582:             wrapper = &FilteringWrapper<JSCrossCompartmentWrapper,
55582:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
55582:         } else {
55599:             typedef XrayWrapper<JSCrossCompartmentWrapper, CrossCompartmentXray> Xray;
55617: 
55617:             // Location objects can become same origin after navigation, so we might
55617:             // have to grant transparent access later on.
55617:             if (IsLocationObject(obj)) {
55617:                 wrapper = &FilteringWrapper<Xray,
55617:                     SameOriginOrCrossOriginAccessiblePropertiesOnly>::singleton;
55617:             } else {
55598:                 wrapper= &FilteringWrapper<Xray,
47574:                     CrossOriginAccessiblePropertiesOnly>::singleton;
55617:             }
55617: 
55599:             xrayHolder = Xray::createHolder(cx, obj, parent);
55599:             if (!xrayHolder)
55599:                 return nsnull;
55582:         }
47574:     }
55599: 
55604:     JSObject *wrapperObj = JSWrapper::New(cx, obj, wrappedProto, parent, wrapper);
55599:     if (!wrapperObj || !xrayHolder)
55599:         return wrapperObj;
55622: 
55622:     // NB: The fact that the only wrappers to use ProxyExtra are XrayWrappers
55622:     // is relied on by XPCNativeWrapper.unwrap.
55599:     wrapperObj->setProxyExtra(js::ObjectValue(*xrayHolder));
55599:     return wrapperObj;
47525: }
47525: 
55617: typedef FilteringWrapper<XrayWrapper<JSWrapper, SameCompartmentXray>,
55617:                          SameOriginOrCrossOriginAccessiblePropertiesOnly> LW;
55617: 
55617: bool
55617: WrapperFactory::IsLocationObject(JSObject *obj)
55617: {
55617:     const char *name = obj->getClass()->name;
55617:     return name[0] == 'L' && !strcmp(name, "Location");
47525: }
55617: 
55617: JSObject *
55617: WrapperFactory::WrapLocationObject(JSContext *cx, JSObject *obj)
55617: {
55617:     JSObject *xrayHolder = LW::createHolder(cx, obj, obj->getParent());
55617:     if (!xrayHolder)
55617:         return NULL;
55617:     JSObject *wrapperObj = JSWrapper::New(cx, obj, obj->getProto(), NULL, &LW::singleton);
55617:     if (!wrapperObj)
55617:         return NULL;
55617:     wrapperObj->setProxyExtra(js::ObjectValue(*xrayHolder));
55617:     return wrapperObj;
55617: }
55617: 
55696: bool
55696: WrapperFactory::WaiveXrayAndWrap(JSContext *cx, jsval *vp)
55696: {
55815:     if (JSVAL_IS_PRIMITIVE(*vp))
55815:         return JS_WrapValue(cx, vp);
55696: 
55696:     JSObject *obj = JSVAL_TO_OBJECT(*vp)->unwrap();
55696: 
55696:     // We have to make sure that if we're wrapping an outer window, that
55696:     // the .wrappedJSObject also wraps the outer window.
55696:     OBJ_TO_OUTER_OBJECT(cx, obj);
55696:     if (!obj)
55696:         return false;
55696: 
55696:     {
55696:         js::SwitchToCompartment sc(cx, obj->compartment());
55696:         obj = JSWrapper::New(cx, obj, NULL, obj->getParent(), &WaiveXrayWrapperWrapper);
55696:         if (!obj)
55696:             return false;
55617:     }
55696: 
55696:     *vp = OBJECT_TO_JSVAL(obj);
55696:     return JS_WrapValue(cx, vp);
55696: }
55696: 
55700: JSObject *
55700: WrapperFactory::WrapSOWObject(JSContext *cx, JSObject *obj)
55700: {
55700:     JSObject *wrapperObj =
55700:         JSWrapper::New(cx, obj, obj->getProto(), NULL,
55700:                        &FilteringWrapper<JSWrapper,
55700:                                          OnlyIfSubjectIsSystem>::singleton);
55700:     return wrapperObj;
55696: }
55700: 
55700: }
