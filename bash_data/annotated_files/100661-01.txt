     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "pratom.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMHTMLElement.h"
 48083: #include "nsIDOMNSEvent.h"
 41886: #include "nsIMEStateManager.h"
 41886: #include "nsFocusManager.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsReadableUtils.h"
 78229: #include "nsIObserverService.h"
 78229: #include "mozilla/Services.h"
 78229: #include "mozISpellCheckingEngine.h"
 78229: #include "nsIEditorSpellCheck.h"
 78229: #include "mozInlineSpellChecker.h"
     1: 
     1: #include "nsIDOMText.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMAttr.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMDocumentFragment.h"
     1: #include "nsIDOMNamedNodeMap.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIDOMRange.h"
     1: #include "nsIDOMHTMLBRElement.h"
     1: #include "nsIDocument.h"
     1: #include "nsITransactionManager.h"
     1: #include "nsIAbsorbingTransaction.h"
     1: #include "nsIPresShell.h"
     1: #include "nsISelection.h"
     1: #include "nsISelectionPrivate.h"
     1: #include "nsISelectionController.h"
     1: #include "nsIEnumerator.h"
 41743: #include "nsEditProperty.h"
     1: #include "nsIAtom.h"
 15969: #include "nsCaret.h"
     1: #include "nsIWidget.h"
     1: #include "nsIPlaintextEditor.h"
 43438: #include "nsIPrivateDOMEvent.h"
 43438: #include "nsGUIEvent.h"
     1: 
     1: #include "nsIFrame.h"  // Needed by IME code
     1: 
 42163: #include "nsCSSStyleSheet.h"
     1: 
     1: #include "nsIContent.h"
 81058: #include "nsDOMString.h"
     1: #include "nsServiceManagerUtils.h"
     1: 
     1: // transactions the editor knows how to build
     1: #include "EditAggregateTxn.h"
     1: #include "PlaceholderTxn.h"
     1: #include "ChangeAttributeTxn.h"
     1: #include "CreateElementTxn.h"
     1: #include "InsertElementTxn.h"
     1: #include "DeleteElementTxn.h"
     1: #include "InsertTextTxn.h"
     1: #include "DeleteTextTxn.h"
     1: #include "DeleteRangeTxn.h"
     1: #include "SplitElementTxn.h"
     1: #include "JoinElementTxn.h"
     1: #include "nsStyleSheetTxns.h"
     1: #include "IMETextTxn.h"
 20592: #include "nsString.h"
     1: 
     1: #include "nsEditor.h"
     1: #include "nsEditorUtils.h"
 39014: #include "nsEditorEventListener.h"
     1: #include "nsISelectionDisplay.h"
 84013: #include "nsIInlineSpellChecker.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsIHTMLDocument.h"
     1: #include "nsIParserService.h"
     1: 
 36983: #include "nsITransferable.h"
 42574: #include "nsComputedDOMStyle.h"
 53730: #include "nsTextEditUtils.h"
 80566: #include "nsComputedDOMStyle.h"
 36983: 
 42480: #include "mozilla/FunctionTimer.h"
 71931: #include "mozilla/Preferences.h"
 74131: #include "mozilla/dom/Element.h"
 82861: #include "nsContentUtils.h"
 86391: #include "nsCCUncollectableMarker.h"
 42480: 
     1: #define NS_ERROR_EDITOR_NO_SELECTION NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_EDITOR,1)
     1: #define NS_ERROR_EDITOR_NO_TEXTNODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_EDITOR,2)
     1: 
     1: #ifdef NS_DEBUG_EDITOR
 79445: static bool gNoisy = false;
     1: #endif
     1: 
 43713: #ifdef DEBUG
 43713: #include "nsIDOMHTMLDocument.h"
 43713: #endif
 43713: 
 71931: using namespace mozilla;
 82843: using namespace mozilla::widget;
     1: 
     1: // Defined in nsEditorRegistration.cpp
     1: extern nsIParserService *sParserService;
     1: 
     1: //---------------------------------------------------------------------------
     1: //
     1: // nsEditor: base editor class implementation
     1: //
     1: //---------------------------------------------------------------------------
     1: 
     1: nsEditor::nsEditor()
 96784: :  mPlaceHolderName(nsnull)
 96784: ,  mSelState(nsnull)
 96784: ,  mPhonetic(nsnull)
 96784: ,  mModCount(0)
 51224: ,  mFlags(0)
     1: ,  mUpdateCount(0)
     1: ,  mPlaceHolderBatch(0)
 97808: ,  mAction(kOpNone)
 96784: ,  mHandlingActionCount(0)
     1: ,  mIMETextOffset(0)
     1: ,  mIMEBufferLength(0)
 96784: ,  mDirection(eNone)
 96784: ,  mDocDirtyState(-1)
 96784: ,  mSpellcheckCheckboxState(eTriUnset)
 80486: ,  mInIMEMode(false)
 80486: ,  mIsIMEComposing(false)
 80486: ,  mShouldTxnSetSelection(true)
 80486: ,  mDidPreDestroy(false)
 80486: ,  mDidPostCreate(false)
 94119: ,  mHandlingTrustedAction(false)
 94119: ,  mDispatchInputEvent(true)
     1: {
     1: }
     1: 
     1: nsEditor::~nsEditor()
     1: {
 40720:   NS_ASSERTION(!mDocWeak || mDidPreDestroy, "Why PreDestroy hasn't been called?");
 40720: 
 13021:   mTxnMgr = nsnull;
     1: 
     1:   delete mPhonetic;
     1: }
     1: 
 28153: NS_IMPL_CYCLE_COLLECTION_CLASS(nsEditor)
 28153: 
 28153: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEditor)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRootElement)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInlineSpellChecker)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTxnMgr)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mIMETextRangeList)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mIMETextNode)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mActionListeners)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mEditorObservers)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mDocStateListeners)
 28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEventTarget)
 39014:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEventListener)
 28153: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 28153: 
 28153: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEditor)
 86391:  nsIDocument* currentDoc =
 86391:    tmp->mRootElement ? tmp->mRootElement->GetCurrentDoc() : nsnull;
 86391:  if (currentDoc &&
 86391:      nsCCUncollectableMarker::InGeneration(cb, currentDoc->GetMarkedCCGeneration())) {
 86391:    return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 86391:  }
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRootElement)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInlineSpellChecker)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTxnMgr)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mIMETextRangeList)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mIMETextNode)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mActionListeners)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mEditorObservers)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mDocStateListeners)
 28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEventTarget)
 39014:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEventListener)
 28153: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 28153: 
 28153: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEditor)
 28153:  NS_INTERFACE_MAP_ENTRY(nsIPhonetic)
 28153:  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 28153:  NS_INTERFACE_MAP_ENTRY(nsIEditorIMESupport)
 28153:  NS_INTERFACE_MAP_ENTRY(nsIEditor)
 78229:  NS_INTERFACE_MAP_ENTRY(nsIObserver)
 28153:  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIEditor)
 28153: NS_INTERFACE_MAP_END
 28153: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsEditor)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsEditor)
     1: 
     1: 
     1: NS_IMETHODIMP
 63592: nsEditor::Init(nsIDOMDocument *aDoc, nsIContent *aRoot, nsISelectionController *aSelCon, PRUint32 aFlags)
 63592: {
 63592:   NS_PRECONDITION(aDoc, "bad arg");
 63592:   if (!aDoc)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
 41886:   // First only set flags, but other stuff shouldn't be initialized now.
 63591:   // Don't move this call after initializing mDocWeak.
 41886:   // SetFlags() can check whether it's called during initialization or not by
 41886:   // them.  Note that SetFlags() will be called by PostCreate().
 56879: #ifdef DEBUG
 56879:   nsresult rv =
 56879: #endif
 56879:   SetFlags(aFlags);
 41886:   NS_ASSERTION(NS_SUCCEEDED(rv), "SetFlags() failed");
 41886: 
     1:   mDocWeak = do_GetWeakReference(aDoc);  // weak reference to doc
 63589:   // HTML editors currently don't have their own selection controller,
 63589:   // so they'll pass null as aSelCon, and we'll get the selection controller
 63589:   // off of the presshell.
 63589:   nsCOMPtr<nsISelectionController> selCon;
 63589:   if (aSelCon) {
     1:     mSelConWeak = do_GetWeakReference(aSelCon);   // weak reference to selectioncontroller
 63589:     selCon = aSelCon;
 63589:   } else {
 70236:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 63592:     selCon = do_QueryInterface(presShell);
 63589:   }
 63589:   NS_ASSERTION(selCon, "Selection controller should be available at this point");
 40703: 
     1:   //set up root element if we are passed one.  
     1:   if (aRoot)
     1:     mRootElement = do_QueryInterface(aRoot);
     1: 
     1:   mUpdateCount=0;
     1: 
     1:   /* initialize IME stuff */
     1:   mIMETextNode = nsnull;
     1:   mIMETextOffset = 0;
     1:   mIMEBufferLength = 0;
     1:   
     1:   /* Show the caret */
 80486:   selCon->SetCaretReadOnly(false);
 63589:   selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
 63589: 
 63589:   selCon->SetSelectionFlags(nsISelectionDisplay::DISPLAY_ALL);//we want to see all the selection reflected to user
     1: 
 63591:   NS_POSTCONDITION(mDocWeak, "bad state");
     1: 
 43129:   // Make sure that the editor will be destroyed properly
 80486:   mDidPreDestroy = false;
 63593:   // Make sure that the ediotr will be created properly
 80486:   mDidPostCreate = false;
 43129: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::PostCreate()
     1: {
 50883:   // Synchronize some stuff for the flags.  SetFlags() will initialize
 50883:   // something by the flag difference.  This is first time of that, so, all
 50883:   // initializations must be run.  For such reason, we need to invert mFlags
 50883:   // value first.
 50883:   mFlags = ~mFlags;
 50883:   nsresult rv = SetFlags(~mFlags);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 63593:   // These operations only need to happen on the first PostCreate call
 63593:   if (!mDidPostCreate) {
 80486:     mDidPostCreate = true;
 63593: 
     1:     // Set up listeners
 73869:     CreateEventListeners();
     1:     rv = InstallEventListeners();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // nuke the modification count, so the doc appears unmodified
     1:     // do this before we notify listeners
     1:     ResetModificationCount();
     1: 
     1:     // update the UI with our state
     1:     NotifyDocumentListeners(eDocumentCreated);
     1:     NotifyDocumentListeners(eDocumentStateChanged);
 78229: 
 78229:     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
 78229:     if (obs) {
 78229:       obs->AddObserver(this,
 78229:                        SPELLCHECK_DICTIONARY_UPDATE_NOTIFICATION,
 80486:                        false);
 78229:     }
 63593:   }
     1: 
 55284:   // update nsTextStateManager and caret if we have focus
 56870:   nsCOMPtr<nsIContent> focusedContent = GetFocusedContent();
 54605:   if (focusedContent) {
 70236:     nsCOMPtr<nsIPresShell> ps = GetPresShell();
 54605:     NS_ASSERTION(ps, "no pres shell even though we have focus");
 63587:     NS_ENSURE_TRUE(ps, NS_ERROR_UNEXPECTED);
 54605:     nsPresContext* pc = ps->GetPresContext(); 
 54605: 
 54605:     nsIMEStateManager::OnTextStateBlur(pc, nsnull);
 54605:     nsIMEStateManager::OnTextStateFocus(pc, focusedContent);
 55284: 
 55284:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(focusedContent);
 55284:     if (target) {
 55284:       InitializeSelection(target);
 55284:     }
 93491: 
 93491:     // If the text control gets reframed during focus, Focus() would not be
 93491:     // called, so take a chance here to see if we need to spell check the text
 93491:     // control.
 93491:     nsEditorEventListener* listener =
 93491:       reinterpret_cast<nsEditorEventListener*> (mEventListener.get());
 93491:     listener->SpellCheckIfNeeded();
 54605:   }
     1:   return NS_OK;
     1: }
     1: 
 73869: /* virtual */
 73869: void
 39014: nsEditor::CreateEventListeners()
 39014: {
 43129:   // Don't create the handler twice
 72596:   if (!mEventListener) {
 72596:     mEventListener = new nsEditorEventListener();
 72596:   }
 39014: }
 39014: 
 39014: nsresult
     1: nsEditor::InstallEventListeners()
     1: {
 63587:   NS_ENSURE_TRUE(mDocWeak && mEventListener,
     1:                  NS_ERROR_NOT_INITIALIZED);
 43714: 
 43714:   // Initialize the event target.
 43714:   nsCOMPtr<nsIContent> rootContent = do_QueryInterface(GetRoot());
 43714:   NS_ENSURE_TRUE(rootContent, NS_ERROR_NOT_AVAILABLE);
 43714:   mEventTarget = do_QueryInterface(rootContent->GetParent());
 43714:   NS_ENSURE_TRUE(mEventTarget, NS_ERROR_NOT_AVAILABLE);
 43714: 
 40987:   nsEditorEventListener* listener =
 40987:     reinterpret_cast<nsEditorEventListener*>(mEventListener.get());
 40987:   return listener->Connect(this);
     1: }
     1: 
     1: void
     1: nsEditor::RemoveEventListeners()
     1: {
 40987:   if (!mDocWeak || !mEventListener) {
     1:     return;
     1:   }
 40987:   reinterpret_cast<nsEditorEventListener*>(mEventListener.get())->Disconnect();
 43714:   mEventTarget = nsnull;
     1: }
     1: 
 79445: bool
     1: nsEditor::GetDesiredSpellCheckState()
     1: {
     1:   // Check user override on this element
     1:   if (mSpellcheckCheckboxState != eTriUnset) {
     1:     return (mSpellcheckCheckboxState == eTriTrue);
     1:   }
     1: 
     1:   // Check user preferences
 71931:   PRInt32 spellcheckLevel = Preferences::GetInt("layout.spellcheckDefault", 1);
     1: 
     1:   if (spellcheckLevel == 0) {
 80486:     return false;                    // Spellchecking forced off globally
     1:   }
     1: 
 50883:   if (!CanEnableSpellCheck()) {
 80486:     return false;
     1:   }
     1: 
 70236:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 70236:   if (presShell) {
     1:     nsPresContext* context = presShell->GetPresContext();
     1:     if (context && !context->IsDynamic()) {
 80486:       return false;
     1:     }
     1:   }
     1: 
     1:   // Check DOM state
 89182:   nsCOMPtr<nsIContent> content = GetRoot();
     1:   if (!content) {
 80486:     return false;
     1:   }
     1: 
 16126:   if (content->IsRootOfNativeAnonymousSubtree()) {
     1:     content = content->GetParent();
     1:   }
     1: 
 81041:   nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(content);
     1:   if (!element) {
 80486:     return false;
     1:   }
     1: 
 79445:   bool enable;
     1:   element->GetSpellcheck(&enable);
     1: 
     1:   return enable;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::PreDestroy(bool aDestroyingFrames)
     1: {
     1:   if (mDidPreDestroy)
     1:     return NS_OK;
     1: 
 78229:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
 78229:   if (obs) {
 78229:     obs->RemoveObserver(this,
 78229:                         SPELLCHECK_DICTIONARY_UPDATE_NOTIFICATION);
 78229:   }
 78229: 
     1:   // Let spellchecker clean up its observers etc. It is important not to
     1:   // actually free the spellchecker here, since the spellchecker could have
     1:   // caused flush notifications, which could have gotten here if a textbox
     1:   // is being removed. Setting the spellchecker to NULL could free the
     1:   // object that is still in use! It will be freed when the editor is
     1:   // destroyed.
     1:   if (mInlineSpellChecker)
 22729:     mInlineSpellChecker->Cleanup(aDestroyingFrames);
     1: 
     1:   // tell our listeners that the doc is going away
     1:   NotifyDocumentListeners(eDocumentToBeDestroyed);
     1: 
     1:   // Unregister event listeners
     1:   RemoveEventListeners();
     1:   mActionListeners.Clear();
     1:   mEditorObservers.Clear();
     1:   mDocStateListeners.Clear();
     1:   mInlineSpellChecker = nsnull;
 63223:   mSpellcheckCheckboxState = eTriUnset;
 63178:   mRootElement = nsnull;
     1: 
 80486:   mDidPreDestroy = true;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::GetFlags(PRUint32 *aFlags)
     1: {
     1:   *aFlags = mFlags;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::SetFlags(PRUint32 aFlags)
     1: {
 50883:   if (mFlags == aFlags) {
 50883:     return NS_OK;
 50883:   }
 50883: 
 79445:   bool spellcheckerWasEnabled = CanEnableSpellCheck();
     1:   mFlags = aFlags;
     1: 
 63587:   if (!mDocWeak) {
 41886:     // If we're initializing, we shouldn't do anything now.
 41886:     // SetFlags() will be called by PostCreate(),
 41886:     // we should synchronize some stuff for the flags at that time.
 41886:     return NS_OK;
 41886:   }
 41886: 
 50883:   // The flag change may cause the spellchecker state change
 50883:   if (CanEnableSpellCheck() != spellcheckerWasEnabled) {
 41886:     nsresult rv = SyncRealTimeSpell();
 41886:     NS_ENSURE_SUCCESS(rv, rv);
 50883:   }
 41886: 
 41886:   // Might be changing editable state, so, we need to reset current IME state
 42852:   // if we're focused and the flag change causes IME state change.
 56870:   nsCOMPtr<nsIContent> focusedContent = GetFocusedContent();
 56870:   if (focusedContent) {
 82843:     IMEState newState;
 50883:     nsresult rv = GetPreferredIMEState(&newState);
 41886:     if (NS_SUCCEEDED(rv)) {
 42852:       // NOTE: When the enabled state isn't going to be modified, this method
 42852:       // is going to do nothing.
 58017:       nsIMEStateManager::UpdateIMEState(newState, focusedContent);
 41886:     }
 41886:   }
 41886: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::GetIsSelectionEditable(bool *aIsSelectionEditable)
 76739: {
 76739:   NS_ENSURE_ARG_POINTER(aIsSelectionEditable);
 76739: 
 76739:   // get current selection
 76739:   nsCOMPtr<nsISelection> selection;
 76739:   nsresult res = GetSelection(getter_AddRefs(selection));
 76739:   NS_ENSURE_SUCCESS(res, res);
 76739:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
 76739: 
 76739:   // XXX we just check that the anchor node is editable at the moment
 76739:   //     we should check that all nodes in the selection are editable
 76739:   nsCOMPtr<nsIDOMNode> anchorNode;
 76739:   selection->GetAnchorNode(getter_AddRefs(anchorNode));
 76739:   *aIsSelectionEditable = anchorNode && IsEditable(anchorNode);
 76739: 
 76739:   return NS_OK;
 76739: }
 76739: 
 76739: NS_IMETHODIMP
 79445: nsEditor::GetIsDocumentEditable(bool *aIsDocumentEditable)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aIsDocumentEditable);
 93880:   nsCOMPtr<nsIDOMDocument> doc = GetDOMDocument();
 93880:   *aIsDocumentEditable = !!doc;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 93880: already_AddRefed<nsIDocument>
 93880: nsEditor::GetDocument()
 93880: {
 93880:   NS_PRECONDITION(mDocWeak, "bad state, mDocWeak weak pointer not initialized");
 93880:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 93880:   return doc.forget();
 93880: }
 93880: 
 93880: already_AddRefed<nsIDOMDocument>
 93880: nsEditor::GetDOMDocument()
 93880: {
 93880:   NS_PRECONDITION(mDocWeak, "bad state, mDocWeak weak pointer not initialized");
 93880:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
 93880:   return doc.forget();
 93880: }
 93880: 
     1: NS_IMETHODIMP 
     1: nsEditor::GetDocument(nsIDOMDocument **aDoc)
     1: {
 93880:   nsCOMPtr<nsIDOMDocument> doc = GetDOMDocument();
 93880:   doc.forget(aDoc);
 93880:   return *aDoc ? NS_OK : NS_ERROR_NOT_INITIALIZED;
     1: }
     1: 
 70236: already_AddRefed<nsIPresShell>
 70236: nsEditor::GetPresShell()
 70236: {
 63591:   NS_PRECONDITION(mDocWeak, "bad state, null mDocWeak");
 63591:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 70236:   NS_ENSURE_TRUE(doc, NULL);
 70362:   nsCOMPtr<nsIPresShell> ps = doc->GetShell();
 70236:   return ps.forget();
     1: }
     1: 
     1: 
     1: /* attribute string contentsMIMEType; */
     1: NS_IMETHODIMP
     1: nsEditor::GetContentsMIMEType(char * *aContentsMIMEType)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aContentsMIMEType);
     1:   *aContentsMIMEType = ToNewCString(mContentMIMEType);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::SetContentsMIMEType(const char * aContentsMIMEType)
     1: {
     1:   mContentMIMEType.Assign(aContentsMIMEType ? aContentsMIMEType : "");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::GetSelectionController(nsISelectionController **aSel)
     1: {
 43807:   NS_ENSURE_TRUE(aSel, NS_ERROR_NULL_POINTER);
     1:   *aSel = nsnull; // init out param
 63589:   nsCOMPtr<nsISelectionController> selCon;
 63589:   if (mSelConWeak) {
 63589:     selCon = do_QueryReferent(mSelConWeak);
 63589:   } else {
 70236:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 63589:     selCon = do_QueryInterface(presShell);
 63589:   }
 43806:   NS_ENSURE_TRUE(selCon, NS_ERROR_NOT_INITIALIZED);
     1:   NS_ADDREF(*aSel = selCon);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
 98852: nsEditor::DeleteSelection(EDirection aAction, EStripWrappers aStripWrappers)
 98852: {
 98852:   MOZ_ASSERT(aStripWrappers == eStrip || aStripWrappers == eNoStrip);
 98852:   return DeleteSelectionImpl(aAction, aStripWrappers);
     1: }
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::GetSelection(nsISelection **aSelection)
     1: {
 43807:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
     1:   *aSelection = nsnull;
 63588:   nsCOMPtr<nsISelectionController> selcon;
 63588:   GetSelectionController(getter_AddRefs(selcon));
 43806:   NS_ENSURE_TRUE(selcon, NS_ERROR_NOT_INITIALIZED);
     1:   return selcon->GetSelection(nsISelectionController::SELECTION_NORMAL, aSelection);  // does an addref
     1: }
     1: 
 98852: nsTypedSelection*
 98852: nsEditor::GetTypedSelection()
 98852: {
 98852:   nsCOMPtr<nsISelection> sel;
 98852:   nsresult res = GetSelection(getter_AddRefs(sel));
 98852:   NS_ENSURE_SUCCESS(res, nsnull);
 98852: 
 98852:   nsCOMPtr<nsISelectionPrivate> selPrivate = do_QueryInterface(sel);
 98852:   NS_ENSURE_TRUE(selPrivate, nsnull);
 98852: 
 98852:   nsRefPtr<nsFrameSelection> frameSel;
 98852:   res = selPrivate->GetFrameSelection(getter_AddRefs(frameSel));
 98852:   NS_ENSURE_SUCCESS(res, nsnull);
 98852: 
 98852:   return frameSel->GetSelection(nsISelectionController::SELECTION_NORMAL);
 98852: }
 98852: 
     1: NS_IMETHODIMP 
     1: nsEditor::DoTransaction(nsITransaction *aTxn)
     1: {
     1: #ifdef NS_DEBUG_EDITOR
     1:   if (gNoisy) { printf("Editor::DoTransaction ----------\n"); }
     1: #endif
     1: 
     1:   nsresult result = NS_OK;
     1:   
     1:   if (mPlaceHolderBatch && !mPlaceHolderTxn)
     1:   {
     1:     // it's pretty darn amazing how many different types of pointers
     1:     // this transaction goes through here.  I bet this is a record.
     1:     
     1:     // We start off with an EditTxn since that's what the factory returns.
 27825:     nsRefPtr<EditTxn> editTxn = new PlaceholderTxn();
 27825:     if (!editTxn) { return NS_ERROR_OUT_OF_MEMORY; }
     1: 
     1:     // Then we QI to an nsIAbsorbingTransaction to get at placeholder functionality
     1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn;
     1:     editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
     1:     // have to use line above instead of "plcTxn = do_QueryInterface(editTxn);"
     1:     // due to our broken interface model for transactions.
     1: 
     1:     // save off weak reference to placeholder txn
     1:     mPlaceHolderTxn = do_GetWeakReference(plcTxn);
     1:     plcTxn->Init(mPlaceHolderName, mSelState, this);
     1:     mSelState = nsnull;  // placeholder txn took ownership of this pointer
     1: 
     1:     // finally we QI to an nsITransaction since that's what DoTransaction() expects
     1:     nsCOMPtr<nsITransaction> theTxn = do_QueryInterface(plcTxn);
     1:     DoTransaction(theTxn);  // we will recurse, but will not hit this case in the nested call
     1: 
     1:     if (mTxnMgr)
     1:     {
     1:       nsCOMPtr<nsITransaction> topTxn;
     1:       result = mTxnMgr->PeekUndoStack(getter_AddRefs(topTxn));
 43805:       NS_ENSURE_SUCCESS(result, result);
     1:       if (topTxn)
     1:       {
     1:         plcTxn = do_QueryInterface(topTxn);
     1:         if (plcTxn)
     1:         {
     1:           // there is a palceholder transaction on top of the undo stack.  It is 
     1:           // either the one we just created, or an earlier one that we are now merging
     1:           // into.  From here on out remember this placeholder instead of the one
     1:           // we just created.
     1:           mPlaceHolderTxn = do_GetWeakReference(plcTxn);
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (aTxn)
     1:   {  
     1:     // XXX: Why are we doing selection specific batching stuff here?
     1:     // XXX: Most entry points into the editor have auto variables that
     1:     // XXX: should trigger Begin/EndUpdateViewBatch() calls that will make
     1:     // XXX: these selection batch calls no-ops.
     1:     // XXX:
     1:     // XXX: I suspect that this was placed here to avoid multiple
     1:     // XXX: selection changed notifications from happening until after
     1:     // XXX: the transaction was done. I suppose that can still happen
     1:     // XXX: if an embedding application called DoTransaction() directly
     1:     // XXX: to pump its own transactions through the system, but in that
     1:     // XXX: case, wouldn't we want to use Begin/EndUpdateViewBatch() or
     1:     // XXX: its auto equivalent nsAutoUpdateViewBatch to ensure that
     1:     // XXX: selection listeners have access to accurate frame data?
     1:     // XXX:
     1:     // XXX: Note that if we did add Begin/EndUpdateViewBatch() calls
     1:     // XXX: we will need to make sure that they are disabled during
     1:     // XXX: the init of the editor for text widgets to avoid layout
     1:     // XXX: re-entry during initial reflow. - kin
     1: 
     1:     // get the selection and start a batch change
     1:     nsCOMPtr<nsISelection>selection;
     1:     result = GetSelection(getter_AddRefs(selection));
 43895:     NS_ENSURE_SUCCESS(result, result);
 43895:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
     1: 
     1:     selPrivate->StartBatchChanges();
     1: 
     1:     if (mTxnMgr) {
     1:       result = mTxnMgr->DoTransaction(aTxn);
     1:     }
     1:     else {
     1:       result = aTxn->DoTransaction();
     1:     }
     1:     if (NS_SUCCEEDED(result)) {
     1:       result = DoAfterDoTransaction(aTxn);
     1:     }
     1: 
     1:     selPrivate->EndBatchChanges(); // no need to check result here, don't lose result of operation
     1:   }
     1:  
 62874:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   return result;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::EnableUndo(bool aEnable)
     1: {
     1:   nsresult result=NS_OK;
     1: 
 80486:   if (true==aEnable)
     1:   {
     1:     if (!mTxnMgr)
     1:     {
     1:       mTxnMgr = do_CreateInstance(NS_TRANSACTIONMANAGER_CONTRACTID, &result);
     1:       if (NS_FAILED(result) || !mTxnMgr) {
     1:         return NS_ERROR_NOT_AVAILABLE;
     1:       }
     1:     }
     1:     mTxnMgr->SetMaxTransactionCount(-1);
     1:   }
     1:   else
     1:   { // disable the transaction manager if it is enabled
     1:     if (mTxnMgr)
     1:     {
     1:       mTxnMgr->Clear();
     1:       mTxnMgr->SetMaxTransactionCount(0);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 90784: NS_IMETHODIMP
 90784: nsEditor::GetNumberOfUndoItems(PRInt32* aNumItems)
 90784: {
 90784:   *aNumItems = 0;
 90784:   return mTxnMgr ? mTxnMgr->GetNumberOfUndoItems(aNumItems) : NS_OK;
 90784: }
 90784: 
 90784: NS_IMETHODIMP
 90784: nsEditor::GetNumberOfRedoItems(PRInt32* aNumItems)
 90784: {
 90784:   *aNumItems = 0;
 90784:   return mTxnMgr ? mTxnMgr->GetNumberOfRedoItems(aNumItems) : NS_OK;
 90784: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::GetTransactionManager(nsITransactionManager* *aTxnManager)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aTxnManager);
     1:   
     1:   *aTxnManager = NULL;
 43807:   NS_ENSURE_TRUE(mTxnMgr, NS_ERROR_FAILURE);
     1: 
     1:   NS_ADDREF(*aTxnManager = mTxnMgr);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::SetTransactionManager(nsITransactionManager *aTxnManager)
     1: {
     1:   NS_ENSURE_TRUE(aTxnManager, NS_ERROR_FAILURE);
     1: 
     1:   mTxnMgr = aTxnManager;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::Undo(PRUint32 aCount)
     1: {
     1: #ifdef NS_DEBUG_EDITOR
     1:   if (gNoisy) { printf("Editor::Undo ----------\n"); }
     1: #endif
     1: 
     1:   ForceCompositionEnd();
     1: 
 79445:   bool hasTxnMgr, hasTransaction = false;
     1:   CanUndo(&hasTxnMgr, &hasTransaction);
 89182:   NS_ENSURE_TRUE(hasTransaction, NS_OK);
     1: 
     1:   nsAutoRules beginRulesSniffing(this, kOpUndo, nsIEditor::eNone);
     1: 
 89182:   if (!mTxnMgr) {
 89182:     return NS_OK;
 89182:   }
 89182: 
 89182:   for (PRUint32 i = 0; i < aCount; ++i) {
 89182:     nsresult rv = mTxnMgr->UndoTransaction();
 89182:     NS_ENSURE_SUCCESS(rv, rv);
 89182: 
 89182:     rv = DoAfterUndoTransaction();
 89182:     NS_ENSURE_SUCCESS(rv, rv);
 89182:   }
 89182: 
 89182:   return NS_OK;
     1: }
     1: 
     1: 
 79445: NS_IMETHODIMP nsEditor::CanUndo(bool *aIsEnabled, bool *aCanUndo)
     1: {
 43807:   NS_ENSURE_TRUE(aIsEnabled && aCanUndo, NS_ERROR_NULL_POINTER);
 89182:   *aIsEnabled = !!mTxnMgr;
 89182:   if (*aIsEnabled) {
     1:     PRInt32 numTxns = 0;
     1:     mTxnMgr->GetNumberOfUndoItems(&numTxns);
 89182:     *aCanUndo = !!numTxns;
 89182:   } else {
 80486:     *aCanUndo = false;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::Redo(PRUint32 aCount)
     1: {
     1: #ifdef NS_DEBUG_EDITOR
     1:   if (gNoisy) { printf("Editor::Redo ----------\n"); }
     1: #endif
     1: 
 79445:   bool hasTxnMgr, hasTransaction = false;
     1:   CanRedo(&hasTxnMgr, &hasTransaction);
 89182:   NS_ENSURE_TRUE(hasTransaction, NS_OK);
     1: 
     1:   nsAutoRules beginRulesSniffing(this, kOpRedo, nsIEditor::eNone);
     1: 
 89182:   if (!mTxnMgr) {
 89182:     return NS_OK;
 89182:   }
 89182: 
 89182:   for (PRUint32 i = 0; i < aCount; ++i) {
 89182:     nsresult rv = mTxnMgr->RedoTransaction();
 89182:     NS_ENSURE_SUCCESS(rv, rv);
 89182: 
 89182:     rv = DoAfterRedoTransaction();
 89182:     NS_ENSURE_SUCCESS(rv, rv);
 89182:   }
 89182: 
 89182:   return NS_OK;
     1: }
     1: 
     1: 
 79445: NS_IMETHODIMP nsEditor::CanRedo(bool *aIsEnabled, bool *aCanRedo)
     1: {
 43807:   NS_ENSURE_TRUE(aIsEnabled && aCanRedo, NS_ERROR_NULL_POINTER);
     1: 
 89182:   *aIsEnabled = !!mTxnMgr;
 89182:   if (*aIsEnabled) {
     1:     PRInt32 numTxns = 0;
     1:     mTxnMgr->GetNumberOfRedoItems(&numTxns);
 89182:     *aCanRedo = !!numTxns;
 89182:   } else {
 80486:     *aCanRedo = false;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::BeginTransaction()
     1: {
     1:   BeginUpdateViewBatch();
     1: 
 89182:   if (mTxnMgr) {
     1:     mTxnMgr->BeginBatch();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::EndTransaction()
     1: {
 89182:   if (mTxnMgr) {
     1:     mTxnMgr->EndBatch();
     1:   }
     1: 
     1:   EndUpdateViewBatch();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // These two routines are similar to the above, but do not use
     1: // the transaction managers batching feature.  Instead we use
     1: // a placeholder transaction to wrap up any further transaction
     1: // while the batch is open.  The advantage of this is that
     1: // placeholder transactions can later merge, if needed.  Merging
     1: // is unavailable between transaction manager batches.
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::BeginPlaceHolderTransaction(nsIAtom *aName)
     1: {
     1:   NS_PRECONDITION(mPlaceHolderBatch >= 0, "negative placeholder batch count!");
     1:   if (!mPlaceHolderBatch)
     1:   {
     1:     // time to turn on the batch
     1:     BeginUpdateViewBatch();
     1:     mPlaceHolderTxn = nsnull;
     1:     mPlaceHolderName = aName;
     1:     nsCOMPtr<nsISelection> selection;
     1:     nsresult res = GetSelection(getter_AddRefs(selection));
 48845:     if (NS_SUCCEEDED(res)) {
     1:       mSelState = new nsSelectionState();
     1:       mSelState->SaveSelection(selection);
     1:     }
 48845:   }
     1:   mPlaceHolderBatch++;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::EndPlaceHolderTransaction()
     1: {
     1:   NS_PRECONDITION(mPlaceHolderBatch > 0, "zero or negative placeholder batch count when ending batch!");
     1:   if (mPlaceHolderBatch == 1)
     1:   {
     1:     nsCOMPtr<nsISelection>selection;
 23383:     GetSelection(getter_AddRefs(selection));
     1: 
     1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
     1: 
     1:     // By making the assumption that no reflow happens during the calls
     1:     // to EndUpdateViewBatch and ScrollSelectionIntoView, we are able to
     1:     // allow the selection to cache a frame offset which is used by the
     1:     // caret drawing code. We only enable this cache here; at other times,
     1:     // we have no way to know whether reflow invalidates it
     1:     // See bugs 35296 and 199412.
     1:     if (selPrivate) {
 80486:       selPrivate->SetCanCacheFrameOffset(true);
     1:     }
     1: 
 53732:     {
 53732:       // Hide the caret here to avoid hiding it twice, once in EndUpdateViewBatch
 53732:       // and once in ScrollSelectionIntoView.
 53732:       nsRefPtr<nsCaret> caret;
 70236:       nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 53732: 
 53732:       if (presShell)
 53732:         caret = presShell->GetCaret();
 53732: 
 53732:       StCaretHider caretHider(caret);
 53732: 
     1:       // time to turn off the batch
     1:       EndUpdateViewBatch();
     1:       // make sure selection is in view
 12392: 
 12392:       // After ScrollSelectionIntoView(), the pending notifications might be
 12392:       // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
 80486:       ScrollSelectionIntoView(false);
 53732:     }
     1: 
     1:     // cached for frame offset are Not available now
     1:     if (selPrivate) {
 80486:       selPrivate->SetCanCacheFrameOffset(false);
     1:     }
     1: 
     1:     if (mSelState)
     1:     {
     1:       // we saved the selection state, but never got to hand it to placeholder 
     1:       // (else we ould have nulled out this pointer), so destroy it to prevent leaks.
     1:       delete mSelState;
     1:       mSelState = nsnull;
     1:     }
     1:     if (mPlaceHolderTxn)  // we might have never made a placeholder if no action took place
     1:     {
     1:       nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryReferent(mPlaceHolderTxn);
     1:       if (plcTxn) 
     1:       {
     1:         plcTxn->EndPlaceHolderBatch();
     1:       }
     1:       else  
     1:       {
     1:         // in the future we will check to make sure undo is off here,
     1:         // since that is the only known case where the placeholdertxn would disappear on us.
     1:         // For now just removing the assert.
     1:       }
 86433:       // notify editor observers of action but if composing, it's done by
 86433:       // text event handler.
     1:       if (!mInIMEMode) NotifyEditorObservers();
     1:     }
     1:   }
     1:   mPlaceHolderBatch--;
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::ShouldTxnSetSelection(bool *aResult)
     1: {
 43806:   NS_ENSURE_TRUE(aResult, NS_ERROR_NULL_POINTER);
     1:   *aResult = mShouldTxnSetSelection;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP  
 79445: nsEditor::SetShouldTxnSetSelection(bool aShould)
     1: {
     1:   mShouldTxnSetSelection = aShould;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::GetDocumentIsEmpty(bool *aDocumentIsEmpty)
     1: {
 80486:   *aDocumentIsEmpty = true;
     1: 
 89182:   dom::Element* root = GetRoot();
 89182:   NS_ENSURE_TRUE(root, NS_ERROR_NULL_POINTER); 
 89182: 
 89182:   *aDocumentIsEmpty = !root->HasChildren();
 89182:   return NS_OK;
     1: }
     1: 
     1: 
     1: // XXX: the rule system should tell us which node to select all on (ie, the root, or the body)
     1: NS_IMETHODIMP nsEditor::SelectAll()
     1: {
 63587:   if (!mDocWeak) { return NS_ERROR_NOT_INITIALIZED; }
     1:   ForceCompositionEnd();
     1: 
 63588:   nsCOMPtr<nsISelectionController> selCon;
 63588:   GetSelectionController(getter_AddRefs(selCon));
 43806:   NS_ENSURE_TRUE(selCon, NS_ERROR_NOT_INITIALIZED);
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
     1:   if (NS_SUCCEEDED(result) && selection)
     1:   {
     1:     result = SelectEntireDocument(selection);
     1:   }
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP nsEditor::BeginningOfDocument()
     1: {
 63587:   if (!mDocWeak) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
     1:   // get the selection
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult result = GetSelection(getter_AddRefs(selection));
 43808:   NS_ENSURE_SUCCESS(result, result);
 43807:   NS_ENSURE_TRUE(selection, NS_ERROR_NOT_INITIALIZED);
     1:     
     1:   // get the root element 
 89184:   dom::Element* rootElement = GetRoot();
 43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_NULL_POINTER); 
     1:   
     1:   // find first editable thingy
 89184:   nsCOMPtr<nsINode> firstNode = GetFirstEditableNode(rootElement);
 89184:   if (!firstNode) {
     1:     // just the root node, set selection to inside the root
 89184:     return selection->CollapseNative(rootElement, 0);
 89184:   }
 89184: 
 89184:   if (firstNode->NodeType() == nsIDOMNode::TEXT_NODE) {
 89184:     // If firstNode is text, set selection to beginning of the text node.
 89184:     return selection->CollapseNative(firstNode, 0);
 89184:   }
 89184: 
 89184:   // Otherwise, it's a leaf node and we set the selection just in front of it.
 89184:   nsCOMPtr<nsIContent> parent = firstNode->GetParent();
 89184:   if (!parent) {
 89184:     return NS_ERROR_NULL_POINTER;
 89184:   }
 89184: 
 89184:   PRInt32 offsetInParent = parent->IndexOf(firstNode);
 89184:   return selection->CollapseNative(parent, offsetInParent);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::EndOfDocument()
     1: { 
 97762:   NS_ENSURE_TRUE(mDocWeak, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   // get selection 
     1:   nsCOMPtr<nsISelection> selection; 
 97762:   nsresult rv = GetSelection(getter_AddRefs(selection)); 
 97762:   NS_ENSURE_SUCCESS(rv, rv); 
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER); 
     1:   
     1:   // get the root element 
 97762:   nsINode* node = GetRoot();
 83343:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER); 
 97762:   nsINode* child = node->GetLastChild();
 97762: 
 97762:   while (child && IsContainer(child->AsDOMNode())) {
 57480:     node = child;
 97762:     child = node->GetLastChild();
 97762:   }
 97762: 
 97762:   PRUint32 length = node->Length();
 97762:   return selection->CollapseNative(node, PRInt32(length));
     1: } 
     1:   
     1: NS_IMETHODIMP
 79445: nsEditor::GetDocumentModified(bool *outDocModified)
     1: {
 43807:   NS_ENSURE_TRUE(outDocModified, NS_ERROR_NULL_POINTER);
     1: 
     1:   PRInt32  modCount = 0;
     1:   GetModificationCount(&modCount);
     1: 
     1:   *outDocModified = (modCount != 0);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::GetDocumentCharacterSet(nsACString &characterSet)
     1: {
 63590:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 63590:   NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
 63590: 
     1:   characterSet = doc->GetDocumentCharacterSet();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::SetDocumentCharacterSet(const nsACString& characterSet)
     1: {
 63590:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 63590:   NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
 63590: 
     1:   doc->SetDocumentCharacterSet(characterSet);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::Cut()
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED; 
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::CanCut(bool *aCanCut)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED; 
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::Copy()
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED; 
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::CanCopy(bool *aCanCut)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED; 
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::Paste(PRInt32 aSelectionType)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED; 
     1: }
     1: 
     1: NS_IMETHODIMP
 36983: nsEditor::PasteTransferable(nsITransferable *aTransferable)
 36983: {
 36983:   return NS_ERROR_NOT_IMPLEMENTED; 
 36983: }
 36983: 
 36983: NS_IMETHODIMP
 79445: nsEditor::CanPaste(PRInt32 aSelectionType, bool *aCanPaste)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED; 
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::CanPasteTransferable(nsITransferable *aTransferable, bool *aCanPaste)
 36983: {
 36983:   return NS_ERROR_NOT_IMPLEMENTED; 
 36983: }
 36983: 
 36983: NS_IMETHODIMP 
     1: nsEditor::SetAttribute(nsIDOMElement *aElement, const nsAString & aAttribute, const nsAString & aValue)
     1: {
  3030:   nsRefPtr<ChangeAttributeTxn> txn;
  3030:   nsresult result = CreateTxnForSetAttribute(aElement, aAttribute, aValue,
  3030:                                              getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result))  {
     1:     result = DoTransaction(txn);  
     1:   }
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::GetAttributeValue(nsIDOMElement *aElement, 
     1:                             const nsAString & aAttribute, 
     1:                             nsAString & aResultValue, 
 79445:                             bool *aResultIsSet)
     1: {
 43807:   NS_ENSURE_TRUE(aResultIsSet, NS_ERROR_NULL_POINTER);
 80486:   *aResultIsSet = false;
 81058:   if (!aElement) {
 81058:     return NS_OK;
 81058:   }
 81058:   nsAutoString value;
 81058:   nsresult rv = aElement->GetAttribute(aAttribute, value);
 81058:   NS_ENSURE_SUCCESS(rv, rv);
 81058:   if (!DOMStringIsNull(value)) {
 81058:     *aResultIsSet = true;
 81058:     aResultValue = value;
 81058:   }
 81058:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::RemoveAttribute(nsIDOMElement *aElement, const nsAString& aAttribute)
     1: {
  3030:   nsRefPtr<ChangeAttributeTxn> txn;
  3030:   nsresult result = CreateTxnForRemoveAttribute(aElement, aAttribute,
  3030:                                                 getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result))  {
     1:     result = DoTransaction(txn);  
     1:   }
     1:   return result;
     1: }
     1: 
     1: 
 96773: bool
 96773: nsEditor::OutputsMozDirty()
 96773: {
 96773:   // Return true for Composer (!eEditorAllowInteraction) or mail
 96773:   // (eEditorMailMask), but false for webpages.
 96773:   return !(mFlags & nsIPlaintextEditor::eEditorAllowInteraction) ||
 96773:           (mFlags & nsIPlaintextEditor::eEditorMailMask);
 96773: }
 96773: 
 96773: 
     1: NS_IMETHODIMP
     1: nsEditor::MarkNodeDirty(nsIDOMNode* aNode)
     1: {  
 96773:   // Mark the node dirty, but not for webpages (bug 599983)
 96773:   if (!OutputsMozDirty()) {
 96773:     return NS_OK;
 96773:   }
 96772:   nsCOMPtr<dom::Element> element = do_QueryInterface(aNode);
 96772:   if (element) {
 41743:     element->SetAttr(kNameSpaceID_None, nsEditProperty::mozdirty,
 80486:                      EmptyString(), false);
 96772:   }
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsEditor::GetInlineSpellChecker(bool autoCreate,
     1:                                               nsIInlineSpellChecker ** aInlineSpellChecker)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aInlineSpellChecker);
     1: 
     1:   if (mDidPreDestroy) {
     1:     // Don't allow people to get or create the spell checker once the editor
     1:     // is going away.
     1:     *aInlineSpellChecker = nsnull;
     1:     return autoCreate ? NS_ERROR_NOT_AVAILABLE : NS_OK;
     1:   }
     1: 
 78229:   // We don't want to show the spell checking UI if there are no spell check dictionaries available.
 79445:   bool canSpell = mozInlineSpellChecker::CanEnableInlineSpellChecking();
 78229:   if (!canSpell) {
 78229:     *aInlineSpellChecker = nsnull;
 78229:     return NS_ERROR_FAILURE;
 78229:   }
 78229: 
 15173:   nsresult rv;
     1:   if (!mInlineSpellChecker && autoCreate) {
     1:     mInlineSpellChecker = do_CreateInstance(MOZ_INLINESPELLCHECKER_CONTRACTID, &rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
 15173:   }
 15173: 
 15173:   if (mInlineSpellChecker) {
     1:     rv = mInlineSpellChecker->Init(this);
     1:     if (NS_FAILED(rv))
     1:       mInlineSpellChecker = nsnull;
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aInlineSpellChecker = mInlineSpellChecker);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 78229: NS_IMETHODIMP nsEditor::Observe(nsISupports* aSubj, const char *aTopic,
 78229:                                 const PRUnichar *aData)
 78229: {
 78229:   NS_ASSERTION(!strcmp(aTopic,
 78229:                        SPELLCHECK_DICTIONARY_UPDATE_NOTIFICATION),
 78229:                "Unexpected observer topic");
 78229: 
 78229:   // When mozInlineSpellChecker::CanEnableInlineSpellChecking changes
 78229:   SyncRealTimeSpell();
 78229: 
 78229:   // When nsIEditorSpellCheck::GetCurrentDictionary changes
 78229:   if (mInlineSpellChecker) {
 78229:     // if the current dictionary is no longer available, find another one
 78229:     nsCOMPtr<nsIEditorSpellCheck> editorSpellCheck;
 78229:     mInlineSpellChecker->GetSpellChecker(getter_AddRefs(editorSpellCheck));
 78229:     if (editorSpellCheck) {
 78229:       // Note: This might change the current dictionary, which may call
 78229:       // this observer recursively.
 78229:       editorSpellCheck->CheckCurrentDictionary();
 78229:     }
 78229: 
 78229:     // update the inline spell checker to reflect the new current dictionary
 78229:     mInlineSpellChecker->SpellCheckRange(nsnull); // causes recheck
 78229:   }
 78229: 
 78229:   return NS_OK;
 78229: }
 78229: 
     1: NS_IMETHODIMP nsEditor::SyncRealTimeSpell()
     1: {
 42480:   NS_TIME_FUNCTION;
 42480: 
 79445:   bool enable = GetDesiredSpellCheckState();
     1: 
 78229:   // Initializes mInlineSpellChecker
     1:   nsCOMPtr<nsIInlineSpellChecker> spellChecker;
     1:   GetInlineSpellChecker(enable, getter_AddRefs(spellChecker));
     1: 
 78229:   if (mInlineSpellChecker) {
 78229:     // We might have a mInlineSpellChecker even if there are no dictionaries
 78229:     // available since we don't destroy the mInlineSpellChecker when the last
 78229:     // dictionariy is removed, but in that case spellChecker is null
 78229:     mInlineSpellChecker->SetEnableRealTimeSpell(enable && spellChecker);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsEditor::SetSpellcheckUserOverride(bool enable)
     1: {
     1:   mSpellcheckCheckboxState = enable ? eTriTrue : eTriFalse;
     1: 
     1:   return SyncRealTimeSpell();
     1: }
     1: 
     1: NS_IMETHODIMP nsEditor::CreateNode(const nsAString& aTag,
     1:                                    nsIDOMNode *    aParent,
     1:                                    PRInt32         aPosition,
     1:                                    nsIDOMNode **   aNewNode)
     1: {
     1:   PRInt32 i;
     1: 
     1:   nsAutoRules beginRulesSniffing(this, kOpCreateNode, nsIEditor::eNext);
     1:   
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->WillCreateNode(aTag, aParent, aPosition);
     1: 
  3030:   nsRefPtr<CreateElementTxn> txn;
  3030:   nsresult result = CreateTxnForCreateElement(aTag, aParent, aPosition,
  3030:                                               getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result)) 
     1:   {
     1:     result = DoTransaction(txn);  
     1:     if (NS_SUCCEEDED(result)) 
     1:     {
     1:       result = txn->GetNewNode(aNewNode);
     1:       NS_ASSERTION((NS_SUCCEEDED(result)), "GetNewNode can't fail if txn::DoTransaction succeeded.");
     1:     }
     1:   }
     1:   
     1:   mRangeUpdater.SelAdjCreateNode(aParent, aPosition);
     1:   
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->DidCreateNode(aTag, *aNewNode, aParent, aPosition, result);
     1: 
     1:   return result;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::InsertNode(nsIDOMNode * aNode,
     1:                                    nsIDOMNode * aParent,
     1:                                    PRInt32      aPosition)
     1: {
     1:   PRInt32 i;
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->WillInsertNode(aNode, aParent, aPosition);
     1: 
  3030:   nsRefPtr<InsertElementTxn> txn;
  3030:   nsresult result = CreateTxnForInsertElement(aNode, aParent, aPosition,
  3030:                                               getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result))  {
     1:     result = DoTransaction(txn);  
     1:   }
     1: 
     1:   mRangeUpdater.SelAdjInsertNode(aParent, aPosition);
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->DidInsertNode(aNode, aParent, aPosition, result);
     1: 
     1:   return result;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::SplitNode(nsIDOMNode * aNode,
     1:                     PRInt32      aOffset,
     1:                     nsIDOMNode **aNewLeftNode)
     1: {
     1:   PRInt32 i;
     1:   nsAutoRules beginRulesSniffing(this, kOpSplitNode, nsIEditor::eNext);
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->WillSplitNode(aNode, aOffset);
     1: 
  3030:   nsRefPtr<SplitElementTxn> txn;
  3030:   nsresult result = CreateTxnForSplitNode(aNode, aOffset, getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result))  
     1:   {
     1:     result = DoTransaction(txn);
     1:     if (NS_SUCCEEDED(result))
     1:     {
     1:       result = txn->GetNewNode(aNewLeftNode);
     1:       NS_ASSERTION((NS_SUCCEEDED(result)), "result must succeeded for GetNewNode");
     1:     }
     1:   }
     1: 
     1:   mRangeUpdater.SelAdjSplitNode(aNode, aOffset, *aNewLeftNode);
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:   {
     1:     nsIDOMNode *ptr = *aNewLeftNode;
     1:     mActionListeners[i]->DidSplitNode(aNode, aOffset, ptr, result);
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: 
100182: nsresult
100182: nsEditor::JoinNodes(nsINode* aNodeToKeep, nsIContent* aNodeToMove)
100182: {
100182:   // We don't really need aNodeToMove's parent to be non-null -- we could just
100182:   // skip adjusting any ranges in aNodeToMove's parent if there is none.  But
100182:   // the current implementation requires it.
100182:   MOZ_ASSERT(aNodeToKeep && aNodeToMove && aNodeToMove->GetNodeParent());
100182:   nsresult res = JoinNodes(aNodeToKeep->AsDOMNode(), aNodeToMove->AsDOMNode(),
100182:                            aNodeToMove->GetNodeParent()->AsDOMNode());
100182:   NS_ASSERTION(NS_SUCCEEDED(res), "JoinNodes failed");
100182:   NS_ENSURE_SUCCESS(res, res);
100182:   return NS_OK;
100182: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::JoinNodes(nsIDOMNode * aLeftNode,
     1:                     nsIDOMNode * aRightNode,
     1:                     nsIDOMNode * aParent)
     1: {
     1:   PRInt32 i, offset;
     1:   nsAutoRules beginRulesSniffing(this, kOpJoinNode, nsIEditor::ePrevious);
     1: 
     1:   // remember some values; later used for saved selection updating.
     1:   // find the offset between the nodes to be joined.
     1:   nsresult result = GetChildOffset(aRightNode, aParent, offset);
 43805:   NS_ENSURE_SUCCESS(result, result);
     1:   // find the number of children of the lefthand node
     1:   PRUint32 oldLeftNodeLen;
     1:   result = GetLengthOfDOMNode(aLeftNode, oldLeftNodeLen);
 43805:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->WillJoinNodes(aLeftNode, aRightNode, aParent);
     1: 
  3030:   nsRefPtr<JoinElementTxn> txn;
  3030:   result = CreateTxnForJoinNode(aLeftNode, aRightNode, getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result))  {
     1:     result = DoTransaction(txn);  
     1:   }
     1: 
     1:   mRangeUpdater.SelAdjJoinNodes(aLeftNode, aRightNode, aParent, offset, (PRInt32)oldLeftNodeLen);
     1:   
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->DidJoinNodes(aLeftNode, aRightNode, aParent, result);
     1: 
     1:   return result;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::DeleteNode(nsIDOMNode * aElement)
     1: {
     1:   PRInt32 i, offset;
     1:   nsCOMPtr<nsIDOMNode> parent;
     1:   nsAutoRules beginRulesSniffing(this, kOpCreateNode, nsIEditor::ePrevious);
     1: 
     1:   // save node location for selection updating code.
     1:   nsresult result = GetNodeLocation(aElement, address_of(parent), &offset);
 43805:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->WillDeleteNode(aElement);
     1: 
  3030:   nsRefPtr<DeleteElementTxn> txn;
  3030:   result = CreateTxnForDeleteElement(aElement, getter_AddRefs(txn));
     1:   if (NS_SUCCEEDED(result))  {
     1:     result = DoTransaction(txn);  
     1:   }
     1: 
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->DidDeleteNode(aElement, result);
     1: 
     1:   return result;
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // ReplaceContainer: replace inNode with a new node (outNode) which is contructed 
     1: //                   to be of type aNodeType.  Put inNodes children into outNode.
     1: //                   Callers responsibility to make sure inNode's children can 
     1: //                   go in outNode.
     1: nsresult
     1: nsEditor::ReplaceContainer(nsIDOMNode *inNode, 
     1:                            nsCOMPtr<nsIDOMNode> *outNode, 
     1:                            const nsAString &aNodeType,
     1:                            const nsAString *aAttribute,
     1:                            const nsAString *aValue,
 79445:                            bool aCloneAttributes)
     1: {
 43807:   NS_ENSURE_TRUE(inNode && outNode, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsIDOMNode> parent;
     1:   PRInt32 offset;
     1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // create new container
     1:   nsCOMPtr<nsIContent> newContent;
     1: 
     1:   //new call to use instead to get proper HTML element, bug# 39919
     1:   res = CreateHTMLContent(aNodeType, getter_AddRefs(newContent));
     1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(newContent);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:     *outNode = do_QueryInterface(elem);
     1:   
     1:   // set attribute if needed
     1:   if (aAttribute && aValue && !aAttribute->IsEmpty())
     1:   {
     1:     res = elem->SetAttribute(*aAttribute, *aValue);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   if (aCloneAttributes)
     1:   {
     1:     nsCOMPtr<nsIDOMNode>newNode = do_QueryInterface(elem);
     1:     res = CloneAttributes(newNode, inNode);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   
     1:   // notify our internal selection state listener
     1:   // (Note: A nsAutoSelectionReset object must be created
     1:   //  before calling this to initialize mRangeUpdater)
     1:   nsAutoReplaceContainerSelNotify selStateNotify(mRangeUpdater, inNode, *outNode);
     1:   {
     1:     nsAutoTxnsConserveSelection conserveSelection(this);
     1:     nsCOMPtr<nsIDOMNode> child;
 79445:     bool bHasMoreChildren;
     1:     inNode->HasChildNodes(&bHasMoreChildren);
     1:     while (bHasMoreChildren)
     1:     {
     1:       inNode->GetFirstChild(getter_AddRefs(child));
     1:       res = DeleteNode(child);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       res = InsertNode(child, *outNode, -1);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       inNode->HasChildNodes(&bHasMoreChildren);
     1:     }
     1:   }
     1:   // insert new container into tree
     1:   res = InsertNode( *outNode, parent, offset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // delete old container
     1:   return DeleteNode(inNode);
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // RemoveContainer: remove inNode, reparenting its children into their
     1: //                  the parent of inNode
     1: //
     1: nsresult
 89176: nsEditor::RemoveContainer(nsINode* aNode)
 89176: {
 89176:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode);
 89176:   return RemoveContainer(node);
 89176: }
 89176: 
 89176: nsresult
     1: nsEditor::RemoveContainer(nsIDOMNode *inNode)
     1: {
 43807:   NS_ENSURE_TRUE(inNode, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsIDOMNode> parent;
     1:   PRInt32 offset;
     1:   
     1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // loop through the child nodes of inNode and promote them
     1:   // into inNode's parent.
 79445:   bool bHasMoreChildren;
     1:   inNode->HasChildNodes(&bHasMoreChildren);
     1:   nsCOMPtr<nsIDOMNodeList> nodeList;
     1:   res = inNode->GetChildNodes(getter_AddRefs(nodeList));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(nodeList, NS_ERROR_NULL_POINTER);
     1:   PRUint32 nodeOrigLen;
     1:   nodeList->GetLength(&nodeOrigLen);
     1: 
     1:   // notify our internal selection state listener
     1:   nsAutoRemoveContainerSelNotify selNotify(mRangeUpdater, inNode, parent, offset, nodeOrigLen);
     1:                                    
     1:   nsCOMPtr<nsIDOMNode> child;
     1:   while (bHasMoreChildren)
     1:   {
     1:     inNode->GetLastChild(getter_AddRefs(child));
     1:     res = DeleteNode(child);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     res = InsertNode(child, parent, offset);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     inNode->HasChildNodes(&bHasMoreChildren);
     1:   }
     1:   return DeleteNode(inNode);
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // InsertContainerAbove:  insert a new parent for inNode, returned in outNode,
     1: //                   which is contructed to be of type aNodeType.  outNode becomes
     1: //                   a child of inNode's earlier parent.
     1: //                   Callers responsibility to make sure inNode's can be child
     1: //                   of outNode, and outNode can be child of old parent.
     1: nsresult
     1: nsEditor::InsertContainerAbove( nsIDOMNode *inNode, 
     1:                                 nsCOMPtr<nsIDOMNode> *outNode, 
     1:                                 const nsAString &aNodeType,
     1:                                 const nsAString *aAttribute,
     1:                                 const nsAString *aValue)
     1: {
 43807:   NS_ENSURE_TRUE(inNode && outNode, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsIDOMNode> parent;
     1:   PRInt32 offset;
     1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // create new container
     1:   nsCOMPtr<nsIContent> newContent;
     1: 
     1:   //new call to use instead to get proper HTML element, bug# 39919
     1:   res = CreateHTMLContent(aNodeType, getter_AddRefs(newContent));
     1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(newContent);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   *outNode = do_QueryInterface(elem);
     1:   
     1:   // set attribute if needed
     1:   if (aAttribute && aValue && !aAttribute->IsEmpty())
     1:   {
     1:     res = elem->SetAttribute(*aAttribute, *aValue);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   
     1:   // notify our internal selection state listener
     1:   nsAutoInsertContainerSelNotify selNotify(mRangeUpdater);
     1:   
     1:   // put inNode in new parent, outNode
     1:   res = DeleteNode(inNode);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   {
     1:     nsAutoTxnsConserveSelection conserveSelection(this);
     1:     res = InsertNode(inNode, *outNode, 0);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   // put new parent in doc
     1:   return InsertNode(*outNode, parent, offset);
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // MoveNode:  move aNode to {aParent,aOffset}
     1: nsresult
100182: nsEditor::MoveNode(nsIContent* aNode, nsINode* aParent, PRInt32 aOffset)
100182: {
100182:   MOZ_ASSERT(aNode && aParent);
100182:   MOZ_ASSERT(aOffset == -1 || (0 <= aOffset &&
100182:                                aOffset <= (PRInt32)aParent->Length()));
100182:   nsresult res = MoveNode(aNode->AsDOMNode(), aParent->AsDOMNode(), aOffset);
100182:   NS_ASSERTION(NS_SUCCEEDED(res), "MoveNode failed");
100182:   NS_ENSURE_SUCCESS(res, res);
100182:   return NS_OK;
100182: }
100182: 
100182: nsresult
     1: nsEditor::MoveNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset)
     1: {
 43807:   NS_ENSURE_TRUE(aNode && aParent, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMNode> oldParent;
     1:   PRInt32 oldOffset;
     1:   nsresult res = GetNodeLocation(aNode, address_of(oldParent), &oldOffset);
     1:   
     1:   if (aOffset == -1)
     1:   {
     1:     PRUint32 unsignedOffset;
     1:     // magic value meaning "move to end of aParent"
     1:     res = GetLengthOfDOMNode(aParent, unsignedOffset);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     aOffset = (PRInt32)unsignedOffset;
     1:   }
     1:   
     1:   // don't do anything if it's already in right place
     1:   if ((aParent == oldParent.get()) && (oldOffset == aOffset)) return NS_OK;
     1:   
     1:   // notify our internal selection state listener
     1:   nsAutoMoveNodeSelNotify selNotify(mRangeUpdater, oldParent, oldOffset, aParent, aOffset);
     1:   
     1:   // need to adjust aOffset if we are moving aNode further along in its current parent
     1:   if ((aParent == oldParent.get()) && (oldOffset < aOffset)) 
     1:   {
     1:     aOffset--;  // this is because when we delete aNode, it will make the offsets after it off by one
     1:   }
     1: 
100661:   // Hold a reference so aNode doesn't go away when we remove it (bug 772282)
100661:   nsCOMPtr<nsIDOMNode> node = aNode;
100661:   res = DeleteNode(node);
 43805:   NS_ENSURE_SUCCESS(res, res);
100661:   return InsertNode(node, aParent, aOffset);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::AddEditorObserver(nsIEditorObserver *aObserver)
     1: {
     1:   // we don't keep ownership of the observers.  They must
     1:   // remove themselves as observers before they are destroyed.
     1:   
 43807:   NS_ENSURE_TRUE(aObserver, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Make sure the listener isn't already on the list
     1:   if (mEditorObservers.IndexOf(aObserver) == -1) 
     1:   {
     1:     if (!mEditorObservers.AppendObject(aObserver))
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::RemoveEditorObserver(nsIEditorObserver *aObserver)
     1: {
 43807:   NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
     1: 
     1:   if (!mEditorObservers.RemoveObject(aObserver))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 94119: class EditorInputEventDispatcher : public nsRunnable
 94119: {
 94119: public:
 94119:   EditorInputEventDispatcher(nsEditor* aEditor,
 94119:                              bool aIsTrusted,
 94119:                              nsIContent* aTarget) :
 94119:     mEditor(aEditor), mTarget(aTarget), mIsTrusted(aIsTrusted)
 94119:   {
 94119:   }
 94119: 
 94119:   NS_IMETHOD Run()
 94119:   {
 94119:     // Note that we don't need to check mDispatchInputEvent here.  We need
 94119:     // to check it only when the editor requests to dispatch the input event.
 94119: 
 94119:     if (!mTarget->IsInDoc()) {
 94119:       return NS_OK;
 94119:     }
 94119: 
 94119:     nsCOMPtr<nsIPresShell> ps = mEditor->GetPresShell();
 94119:     if (!ps) {
 94119:       return NS_OK;
 94119:     }
 94119: 
 94119:     nsEvent inputEvent(mIsTrusted, NS_FORM_INPUT);
 94119:     inputEvent.flags |= NS_EVENT_FLAG_CANT_CANCEL;
 94119:     inputEvent.time = static_cast<PRUint64>(PR_Now() / 1000);
 94119:     nsEventStatus status = nsEventStatus_eIgnore;
 94119:     nsresult rv =
 94119:       ps->HandleEventWithTarget(&inputEvent, nsnull, mTarget, &status);
 94119:     NS_ENSURE_SUCCESS(rv, NS_OK); // print the warning if error
 94119:     return NS_OK;
 94119:   }
 94119: 
 94119: private:
 94119:   nsRefPtr<nsEditor> mEditor;
 94119:   nsCOMPtr<nsIContent> mTarget;
 94119:   bool mIsTrusted;
 94119: };
 94119: 
     1: void nsEditor::NotifyEditorObservers(void)
     1: {
 94119:   for (PRInt32 i = 0; i < mEditorObservers.Count(); i++) {
     1:     mEditorObservers[i]->EditAction();
     1:   }
     1: 
 94119:   if (!mDispatchInputEvent) {
 94119:     return;
 94119:   }
 94119: 
 94119:   // We don't need to dispatch multiple input events if there is a pending
 94119:   // input event.  However, it may have different event target.  If we resolved
 94119:   // this issue, we need to manage the pending events in an array.  But it's
 94119:   // overwork.  We don't need to do it for the very rare case.
 94119: 
 94119:   nsCOMPtr<nsIContent> target = GetInputEventTargetContent();
 94119:   NS_ENSURE_TRUE(target, );
 94119: 
 94119:   nsContentUtils::AddScriptRunner(
 94119:      new EditorInputEventDispatcher(this, mHandlingTrustedAction, target));
 94119: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::AddEditActionListener(nsIEditActionListener *aListener)
     1: {
 43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Make sure the listener isn't already on the list
     1:   if (mActionListeners.IndexOf(aListener) == -1) 
     1:   {
     1:     if (!mActionListeners.AppendObject(aListener))
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::RemoveEditActionListener(nsIEditActionListener *aListener)
     1: {
 43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_FAILURE);
     1: 
     1:   if (!mActionListeners.RemoveObject(aListener))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::AddDocumentStateListener(nsIDocumentStateListener *aListener)
     1: {
 43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
     1: 
     1:   if (mDocStateListeners.IndexOf(aListener) == -1)
     1:   {
     1:     if (!mDocStateListeners.AppendObject(aListener))
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::RemoveDocumentStateListener(nsIDocumentStateListener *aListener)
     1: {
 43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
     1: 
     1:   if (!mDocStateListeners.RemoveObject(aListener))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::OutputToString(const nsAString& aFormatType,
     1:                                        PRUint32 aFlags,
     1:                                        nsAString& aOutputString)
     1: {
     1:   // these should be implemented by derived classes.
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::OutputToStream(nsIOutputStream* aOutputStream,
     1:                          const nsAString& aFormatType,
     1:                          const nsACString& aCharsetOverride,
     1:                          PRUint32 aFlags)
     1: {
     1:   // these should be implemented by derived classes.
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::DumpContentTree()
     1: {
     1: #ifdef DEBUG
     1:   nsCOMPtr<nsIContent> root = do_QueryInterface(mRootElement);
     1:   if (root)  root->List(stdout);
     1: #endif
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::DebugDumpContent()
     1: {
     1: #ifdef DEBUG
     1:   nsCOMPtr<nsIDOMHTMLDocument> doc = do_QueryReferent(mDocWeak);
 43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIDOMHTMLElement>bodyElem;
     1:   doc->GetBody(getter_AddRefs(bodyElem));
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(bodyElem);
     1:   if (content)
     1:     content->List();
     1: #endif
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::DebugUnitTests(PRInt32 *outNumTests, PRInt32 *outNumTestsFailed)
     1: {
     1: #ifdef DEBUG
     1:   NS_NOTREACHED("This should never get called. Overridden by subclasses");
     1: #endif
     1:   return NS_OK;
     1: }
     1: 
     1: 
 79445: bool     
     1: nsEditor::ArePreservingSelection()
     1: {
     1:   return !(mSavedSel.IsEmpty());
     1: }
     1: 
     1: nsresult 
     1: nsEditor::PreserveSelectionAcrossActions(nsISelection *aSel)
     1: {
     1:   mSavedSel.SaveSelection(aSel);
     1:   mRangeUpdater.RegisterSelectionState(mSavedSel);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult 
     1: nsEditor::RestorePreservedSelection(nsISelection *aSel)
     1: {
     1:   if (mSavedSel.IsEmpty()) return NS_ERROR_FAILURE;
     1:   mSavedSel.RestoreSelection(aSel);
     1:   StopPreservingSelection();
     1:   return NS_OK;
     1: }
     1: 
     1: void     
     1: nsEditor::StopPreservingSelection()
     1: {
     1:   mRangeUpdater.DropSelectionState(mSavedSel);
     1:   mSavedSel.MakeEmpty();
     1: }
     1: 
     1: 
 46425: nsresult
 46425: nsEditor::BeginIMEComposition()
 46425: {
 80486:   mInIMEMode = true;
 46425:   if (mPhonetic) {
     1:     mPhonetic->Truncate(0);
 46425:   }
 40645:   return NS_OK;
     1: }
     1: 
 46425: nsresult
 46425: nsEditor::EndIMEComposition()
     1: {
 43806:   NS_ENSURE_TRUE(mInIMEMode, NS_OK); // nothing to do
     1: 
 46425:   nsresult rv = NS_OK;
     1: 
     1:   // commit the IME transaction..we can get at it via the transaction mgr.
     1:   // Note that this means IME won't work without an undo stack!
 46425:   if (mTxnMgr) {
     1:     nsCOMPtr<nsITransaction> txn;
 46425:     rv = mTxnMgr->PeekUndoStack(getter_AddRefs(txn));
 46425:     NS_ASSERTION(NS_SUCCEEDED(rv), "PeekUndoStack() failed");
     1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryInterface(txn);
 46425:     if (plcTxn) {
 46425:       rv = plcTxn->Commit();
 46425:       NS_ASSERTION(NS_SUCCEEDED(rv),
 46425:                    "nsIAbsorbingTransaction::Commit() failed");
     1:     }
     1:   }
     1: 
     1:   /* reset the data we need to construct a transaction */
 46425:   mIMETextNode = nsnull;
     1:   mIMETextOffset = 0;
     1:   mIMEBufferLength = 0;
 80486:   mInIMEMode = false;
 80486:   mIsIMEComposing = false;
     1: 
     1:   // notify editor observers of action
     1:   NotifyEditorObservers();
     1: 
 46425:   return rv;
 46425: }
 46425: 
 46425: 
     1: NS_IMETHODIMP
     1: nsEditor::GetPhonetic(nsAString& aPhonetic)
     1: {
     1:   if (mPhonetic)
     1:     aPhonetic = *mPhonetic;
     1:   else
     1:     aPhonetic.Truncate(0);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: static nsresult
 83343: GetEditorContentWindow(dom::Element *aRoot, nsIWidget **aResult)
 36657: {
 43807:   NS_ENSURE_TRUE(aRoot && aResult, NS_ERROR_NULL_POINTER);
     1: 
     1:   *aResult = 0;
     1: 
     1:   // Not ref counted
 83343:   nsIFrame *frame = aRoot->GetPrimaryFrame();
     1: 
 43807:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
     1: 
 47148:   *aResult = frame->GetNearestWidget();
 43807:   NS_ENSURE_TRUE(*aResult, NS_ERROR_FAILURE);
     1: 
     1:   NS_ADDREF(*aResult);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 15919: nsEditor::GetWidget(nsIWidget **aWidget)
 15919: {
 43807:   NS_ENSURE_TRUE(aWidget, NS_ERROR_NULL_POINTER);
 15919:   *aWidget = nsnull;
     1: 
     1:   nsCOMPtr<nsIWidget> widget;
 36657:   nsresult res = GetEditorContentWindow(GetRoot(), getter_AddRefs(widget));
 43808:   NS_ENSURE_SUCCESS(res, res);
 43807:   NS_ENSURE_TRUE(widget, NS_ERROR_NOT_AVAILABLE);
 15919: 
 15919:   NS_ADDREF(*aWidget = widget);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::ForceCompositionEnd()
     1: {
     1: 
     1: // We can test mInIMEMode and do some optimization for Mac and Window
     1: // Howerver, since UNIX support over-the-spot, we cannot rely on that 
     1: // flag for Unix.
 78126: // We should use LookAndFeel to resolve this
     1: 
 69620: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(XP_OS2)
 40986:   // XXXmnakano see bug 558976, ResetInputState() has two meaning which are
 40986:   // "commit the composition" and "cursor is moved".  This method name is
 40986:   // "ForceCompositionEnd", so, ResetInputState() should be used only for the
 40986:   // former here.  However, ResetInputState() is also used for the latter here
 40986:   // because even if we don't have composition, we call ResetInputState() on
 40986:   // Linux.  Currently, nsGtkIMModule can know the timing of the cursor move,
 40986:   // so, the latter meaning should be gone and we should remove this #if.
     1:   if(! mInIMEMode)
     1:     return NS_OK;
     1: #endif
     1: 
 15919:   nsCOMPtr<nsIWidget> widget;
 15919:   nsresult res = GetWidget(getter_AddRefs(widget));
 43808:   NS_ENSURE_SUCCESS(res, res);
     1: 
 15919:   if (widget) {
 15919:     res = widget->ResetInputState();
 43808:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 82843: nsEditor::GetPreferredIMEState(IMEState *aState)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aState);
 82843:   aState->mEnabled = IMEState::ENABLED;
 82843:   aState->mOpen = IMEState::DONT_CHANGE_OPEN_STATE;
     1: 
 40703:   if (IsReadonly() || IsDisabled()) {
 82843:     aState->mEnabled = IMEState::DISABLED;
  1520:     return NS_OK;
  1520:   }
  1520: 
  1520:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetRoot());
  1520:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
  1520: 
 36657:   nsIFrame* frame = content->GetPrimaryFrame();
  1520:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
  1520: 
  1520:   switch (frame->GetStyleUIReset()->mIMEMode) {
  1520:     case NS_STYLE_IME_MODE_AUTO:
 40703:       if (IsPasswordEditor())
 82843:         aState->mEnabled = IMEState::PASSWORD;
  1520:       break;
  1520:     case NS_STYLE_IME_MODE_DISABLED:
  1520:       // we should use password state for |ime-mode: disabled;|.
 82843:       aState->mEnabled = IMEState::PASSWORD;
  1520:       break;
  1520:     case NS_STYLE_IME_MODE_ACTIVE:
 82843:       aState->mOpen = IMEState::OPEN;
  1520:       break;
  1520:     case NS_STYLE_IME_MODE_INACTIVE:
 82843:       aState->mOpen = IMEState::CLOSED;
  1520:       break;
  1520:   }
  1520: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsEditor::GetComposing(bool* aResult)
 11912: {
 11912:   NS_ENSURE_ARG_POINTER(aResult);
 11912:   *aResult = IsIMEComposing();
 11912:   return NS_OK;
 11912: }
 11912: 
 69620: 
     1: /* Non-interface, public methods */
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::GetRootElement(nsIDOMElement **aRootElement)
     1: {
 43713:   NS_ENSURE_ARG_POINTER(aRootElement);
 43713:   NS_ENSURE_TRUE(mRootElement, NS_ERROR_NOT_AVAILABLE);
 83343:   nsCOMPtr<nsIDOMElement> rootElement = do_QueryInterface(mRootElement);
 83343:   rootElement.forget(aRootElement);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: /** All editor operations which alter the doc should be prefaced
     1:  *  with a call to StartOperation, naming the action and direction */
     1: NS_IMETHODIMP
 97808: nsEditor::StartOperation(OperationID opID, nsIEditor::EDirection aDirection)
     1: {
     1:   mAction = opID;
     1:   mDirection = aDirection;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: /** All editor operations which alter the doc should be followed
     1:  *  with a call to EndOperation */
     1: NS_IMETHODIMP
     1: nsEditor::EndOperation()
     1: {
 97808:   mAction = kOpNone;
     1:   mDirection = eNone;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::CloneAttribute(const nsAString & aAttribute,
     1:                          nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)
     1: {
 43807:   NS_ENSURE_TRUE(aDestNode && aSourceNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMElement> destElement = do_QueryInterface(aDestNode);
     1:   nsCOMPtr<nsIDOMElement> sourceElement = do_QueryInterface(aSourceNode);
 43807:   NS_ENSURE_TRUE(destElement && sourceElement, NS_ERROR_NO_INTERFACE);
     1: 
     1:   nsAutoString attrValue;
 79445:   bool isAttrSet;
     1:   nsresult rv = GetAttributeValue(sourceElement,
     1:                                   aAttribute,
     1:                                   attrValue,
     1:                                   &isAttrSet);
 43808:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (isAttrSet)
     1:     rv = SetAttribute(destElement, aAttribute, attrValue);
     1:   else
     1:     rv = RemoveAttribute(destElement, aAttribute);
     1: 
     1:   return rv;
     1: }
     1: 
     1: // Objects must be DOM elements
     1: NS_IMETHODIMP
     1: nsEditor::CloneAttributes(nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)
     1: {
 43807:   NS_ENSURE_TRUE(aDestNode && aSourceNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMElement> destElement = do_QueryInterface(aDestNode);
     1:   nsCOMPtr<nsIDOMElement> sourceElement = do_QueryInterface(aSourceNode);
 43807:   NS_ENSURE_TRUE(destElement && sourceElement, NS_ERROR_NO_INTERFACE);
     1: 
     1:   nsCOMPtr<nsIDOMNamedNodeMap> sourceAttributes;
     1:   sourceElement->GetAttributes(getter_AddRefs(sourceAttributes));
     1:   nsCOMPtr<nsIDOMNamedNodeMap> destAttributes;
     1:   destElement->GetAttributes(getter_AddRefs(destAttributes));
 43807:   NS_ENSURE_TRUE(sourceAttributes && destAttributes, NS_ERROR_FAILURE);
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1: 
     1:   // Use transaction system for undo only if destination
     1:   //   is already in the document
 83343:   nsCOMPtr<nsIDOMNode> p = aDestNode;
 83343:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(GetRoot());
 83343:   NS_ENSURE_TRUE(rootNode, NS_ERROR_NULL_POINTER);
 79445:   bool destInBody = true;
     1:   while (p && p != rootNode)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> tmp;
     1:     if (NS_FAILED(p->GetParentNode(getter_AddRefs(tmp))) || !tmp)
     1:     {
 80486:       destInBody = false;
     1:       break;
     1:     }
     1:     p = tmp;
     1:   }
     1: 
     1:   PRUint32 sourceCount;
     1:   sourceAttributes->GetLength(&sourceCount);
     1:   PRUint32 i, destCount;
     1:   destAttributes->GetLength(&destCount);
     1:   nsCOMPtr<nsIDOMNode> attrNode;
     1: 
     1:   // Clear existing attributes
     1:   for (i = 0; i < destCount; i++)
     1:   {
     1:     // always remove item number 0 (first item in list)
     1:     if( NS_SUCCEEDED(destAttributes->Item(0, getter_AddRefs(attrNode))) && attrNode)
     1:     {
     1:       nsCOMPtr<nsIDOMAttr> destAttribute = do_QueryInterface(attrNode);
     1:       if (destAttribute)
     1:       {
     1:         nsAutoString str;
     1:         if (NS_SUCCEEDED(destAttribute->GetName(str)))
     1:         {
     1:           if (destInBody)
     1:             RemoveAttribute(destElement, str);
     1:           else
     1:             destElement->RemoveAttribute(str);
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   nsresult result = NS_OK;
     1: 
     1:   // Set just the attributes that the source element has
     1:   for (i = 0; i < sourceCount; i++)
     1:   {
     1:     if( NS_SUCCEEDED(sourceAttributes->Item(i, getter_AddRefs(attrNode))) && attrNode)
     1:     {
     1:       nsCOMPtr<nsIDOMAttr> sourceAttribute = do_QueryInterface(attrNode);
     1:       if (sourceAttribute)
     1:       {
     1:         nsAutoString sourceAttrName;
     1:         if (NS_SUCCEEDED(sourceAttribute->GetName(sourceAttrName)))
     1:         {
     1:           nsAutoString sourceAttrValue;
     1:           /*
     1:           Presence of an attribute in the named node map indicates that it was set on the 
     1:           element even if it has no value.
     1:           */
     1:           if (NS_SUCCEEDED(sourceAttribute->GetValue(sourceAttrValue)))
     1:           {
     1:             if (destInBody) {
 80486:               result = SetAttributeOrEquivalent(destElement, sourceAttrName, sourceAttrValue, false);
     1:             }
     1:             else {
     1:               // the element is not inserted in the document yet, we don't want to put a
     1:               // transaction on the UndoStack
 80486:               result = SetAttributeOrEquivalent(destElement, sourceAttrName, sourceAttrValue, true);
     1:             }
     1:           } else {
     1:             // Do we ever get here?
     1: #if DEBUG_cmanske
     1:             printf("Attribute in sourceAttribute has empty value in nsEditor::CloneAttributes()\n");
     1: #endif
     1:           }
     1:         }        
     1:       }
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: 
 79445: NS_IMETHODIMP nsEditor::ScrollSelectionIntoView(bool aScrollToAnchor)
     1: {
     1:   nsCOMPtr<nsISelectionController> selCon;
     1:   if (NS_SUCCEEDED(GetSelectionController(getter_AddRefs(selCon))) && selCon)
     1:   {
     1:     PRInt16 region = nsISelectionController::SELECTION_FOCUS_REGION;
     1: 
     1:     if (aScrollToAnchor)
     1:       region = nsISelectionController::SELECTION_ANCHOR_REGION;
     1: 
     1:     selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
 56442:                                     region, 0);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsEditor::InsertTextImpl(const nsAString& aStringToInsert, 
     1:                                           nsCOMPtr<nsIDOMNode> *aInOutNode, 
     1:                                           PRInt32 *aInOutOffset,
     1:                                           nsIDOMDocument *aDoc)
     1: {
     1:   // NOTE: caller *must* have already used nsAutoTxnsConserveSelection stack-based
     1:   // class to turn off txn selection updating.  Caller also turned on rules sniffing
     1:   // if desired.
     1:   
 53730:   nsresult res;
 43806:   NS_ENSURE_TRUE(aInOutNode && *aInOutNode && aInOutOffset && aDoc, NS_ERROR_NULL_POINTER);
     1:   if (!mInIMEMode && aStringToInsert.IsEmpty()) return NS_OK;
     1:   nsCOMPtr<nsIDOMText> nodeAsText = do_QueryInterface(*aInOutNode);
 53730:   if (!nodeAsText && IsPlaintextEditor()) {
 83343:     nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(GetRoot());
 53730:     // In some cases, aInOutNode is the anonymous DIV, and aInOutOffset is 0.
 53730:     // To avoid injecting unneeded text nodes, we first look to see if we have
 53730:     // one available.  In that case, we'll just adjust aInOutNode and aInOutOffset
 53730:     // accordingly.
 83343:     if (*aInOutNode == rootNode && *aInOutOffset == 0) {
 53730:       nsCOMPtr<nsIDOMNode> possibleTextNode;
 53730:       res = (*aInOutNode)->GetFirstChild(getter_AddRefs(possibleTextNode));
 53730:       if (NS_SUCCEEDED(res)) {
 53730:         nodeAsText = do_QueryInterface(possibleTextNode);
 53730:         if (nodeAsText) {
 53730:           *aInOutNode = possibleTextNode;
 53730:         }
 53730:       }
 53730:     }
 53730:     // In some other cases, aInOutNode is the anonymous DIV, and aInOutOffset points
 53730:     // to the terminating mozBR.  In that case, we'll adjust aInOutNode and aInOutOffset
 53730:     // to the preceding text node, if any.
 83343:     if (!nodeAsText && *aInOutNode == rootNode && *aInOutOffset > 0) {
 53730:       nsCOMPtr<nsIDOMNodeList> children;
 53730:       res = (*aInOutNode)->GetChildNodes(getter_AddRefs(children));
 53730:       if (NS_SUCCEEDED(res)) {
 53730:         nsCOMPtr<nsIDOMNode> possibleMozBRNode;
 55302:         children->Item(*aInOutOffset, getter_AddRefs(possibleMozBRNode));
 55302:         if (possibleMozBRNode && nsTextEditUtils::IsMozBR(possibleMozBRNode)) {
 53730:           nsCOMPtr<nsIDOMNode> possibleTextNode;
 53730:           res = children->Item(*aInOutOffset - 1, getter_AddRefs(possibleTextNode));
 53730:           if (NS_SUCCEEDED(res)) {
 53730:             nodeAsText = do_QueryInterface(possibleTextNode);
 53730:             if (nodeAsText) {
 53730:               PRUint32 length;
 53730:               res = nodeAsText->GetLength(&length);
 53730:               if (NS_SUCCEEDED(res)) {
 53730:                 *aInOutOffset = PRInt32(length);
 53730:                 *aInOutNode = possibleTextNode;
 53730:               }
 53730:             }
 53730:           }
 56048:         } else {
 56048:           // The selection might be at the end of the last textnode child,
 56048:           // in which case we can just append to the textnode in question.
 56048:           nsCOMPtr<nsIDOMNode> possibleTextNode;
 56048:           res = children->Item(*aInOutOffset - 1, getter_AddRefs(possibleTextNode));
 56048:           nodeAsText = do_QueryInterface(possibleTextNode);
 56048:           if (nodeAsText) {
 56048:             PRUint32 length;
 56048:             res = nodeAsText->GetLength(&length);
 56048:             if (NS_SUCCEEDED(res)) {
 56048:               *aInOutOffset = PRInt32(length);
 56048:               *aInOutNode = possibleTextNode;
 56048:             }
 56048:           }
 53730:         }
 53730:       }
 53730:     }
 53734:     // Sometimes, aInOutNode is the mozBR element itself.  In that case, we'll
 53734:     // adjust the insertion point to the previous text node, if one exists, or
 53734:     // to the parent anonymous DIV.
 53734:     if (nsTextEditUtils::IsMozBR(*aInOutNode) && *aInOutOffset == 0) {
 53734:       nsCOMPtr<nsIDOMNode> previous;
 53734:       (*aInOutNode)->GetPreviousSibling(getter_AddRefs(previous));
 53734:       nodeAsText = do_QueryInterface(previous);
 53734:       if (nodeAsText) {
 53734:         PRUint32 length;
 53734:         res = nodeAsText->GetLength(&length);
 53734:         if (NS_SUCCEEDED(res)) {
 53734:           *aInOutOffset = PRInt32(length);
 53734:           *aInOutNode = previous;
 53734:         }
 53734:       } else {
 53734:         nsCOMPtr<nsIDOMNode> parent;
 53734:         (*aInOutNode)->GetParentNode(getter_AddRefs(parent));
 83343:         if (parent == rootNode) {
 53734:           *aInOutNode = parent;
 53734:         }
 53734:       }
 53734:     }
 53730:   }
     1:   PRInt32 offset = *aInOutOffset;
     1:   if (mInIMEMode)
     1:   {
     1:     if (!nodeAsText)
     1:     {
     1:       // create a text node
     1:       res = aDoc->CreateTextNode(EmptyString(), getter_AddRefs(nodeAsText));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(nodeAsText, NS_ERROR_NULL_POINTER);
     1:       nsCOMPtr<nsIDOMNode> newNode = do_QueryInterface(nodeAsText);
     1:       // then we insert it into the dom tree
     1:       res = InsertNode(newNode, *aInOutNode, offset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       offset = 0;
     1:     }
     1:     res = InsertTextIntoTextNodeImpl(aStringToInsert, nodeAsText, offset);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   else
     1:   {
     1:     if (nodeAsText)
     1:     {
     1:       // we are inserting text into an existing text node.
     1:       res = InsertTextIntoTextNodeImpl(aStringToInsert, nodeAsText, offset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       *aInOutOffset += aStringToInsert.Length();
     1:     }
     1:     else
     1:     {
     1:       // we are inserting text into a non-text node
     1:       // first we have to create a textnode (this also populates it with the text)
     1:       res = aDoc->CreateTextNode(aStringToInsert, getter_AddRefs(nodeAsText));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(nodeAsText, NS_ERROR_NULL_POINTER);
     1:       nsCOMPtr<nsIDOMNode> newNode = do_QueryInterface(nodeAsText);
     1:       // then we insert it into the dom tree
     1:       res = InsertNode(newNode, *aInOutNode, offset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       *aInOutNode = newNode;
     1:       *aInOutOffset = aStringToInsert.Length();
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: 
 37130: nsresult nsEditor::InsertTextIntoTextNodeImpl(const nsAString& aStringToInsert, 
     1:                                               nsIDOMCharacterData *aTextNode, 
 37130:                                               PRInt32 aOffset,
 79445:                                               bool aSuppressIME)
     1: {
  3030:   nsRefPtr<EditTxn> txn;
 20235:   nsresult result = NS_OK;
 79445:   bool isIMETransaction = false;
 37130:   // aSuppressIME is used when editor must insert text, yet this text is not
     1:   // part of current ime operation.  example: adjusting whitespace around an ime insertion.
 37130:   if (mIMETextRangeList && mInIMEMode && !aSuppressIME)
     1:   {
     1:     if (!mIMETextNode)
     1:     {
     1:       mIMETextNode = aTextNode;
     1:       mIMETextOffset = aOffset;
     1:     }
     1:     PRUint16 len ;
 20235:     len = mIMETextRangeList->GetLength();
 20235:     if (len > 0)
     1:     {
     1:       nsCOMPtr<nsIPrivateTextRange> range;
     1:       for (PRUint16 i = 0; i < len; i++) 
     1:       {
 20235:         range = mIMETextRangeList->Item(i);
 20235:         if (range)
     1:         {
     1:           PRUint16 type;
     1:           result = range->GetRangeType(&type);
     1:           if (NS_SUCCEEDED(result)) 
     1:           {
     1:             if (type == nsIPrivateTextRange::TEXTRANGE_RAWINPUT) 
     1:             {
     1:               PRUint16 start, end;
     1:               result = range->GetRangeStart(&start);
     1:               if (NS_SUCCEEDED(result)) 
     1:               {
     1:                 result = range->GetRangeEnd(&end);
     1:                 if (NS_SUCCEEDED(result)) 
     1:                 {
     1:                   if (!mPhonetic)
     1:                     mPhonetic = new nsString();
     1:                   if (mPhonetic)
     1:                   {
     1:                     nsAutoString tmp(aStringToInsert);                  
     1:                     tmp.Mid(*mPhonetic, start, end-start);
     1:                   }
     1:                 }
     1:               }
     1:             } // if
     1:           }
     1:         } // if
     1:       } // for
     1:     } // if
     1: 
  3030:     nsRefPtr<IMETextTxn> imeTxn;
  3030:     result = CreateTxnForIMEText(aStringToInsert, getter_AddRefs(imeTxn));
  3030:     txn = imeTxn;
 80486:     isIMETransaction = true;
     1:   }
     1:   else
     1:   {
  3030:     nsRefPtr<InsertTextTxn> insertTxn;
  3030:     result = CreateTxnForInsertText(aStringToInsert, aTextNode, aOffset,
  3030:                                     getter_AddRefs(insertTxn));
  3030:     txn = insertTxn;
  3030:   }
 43805:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // let listeners know what's up
     1:   PRInt32 i;
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->WillInsertText(aTextNode, aOffset, aStringToInsert);
     1:   
     1:   // XXX we may not need these view batches anymore.  This is handled at a higher level now I believe
     1:   BeginUpdateViewBatch();
     1:   result = DoTransaction(txn);
     1:   EndUpdateViewBatch();
     1: 
     1:   mRangeUpdater.SelAdjInsertText(aTextNode, aOffset, aStringToInsert);
     1:   
     1:   // let listeners know what happened
     1:   for (i = 0; i < mActionListeners.Count(); i++)
     1:     mActionListeners[i]->DidInsertText(aTextNode, aOffset, aStringToInsert, result);
     1: 
     1:   // Added some cruft here for bug 43366.  Layout was crashing because we left an 
     1:   // empty text node lying around in the document.  So I delete empty text nodes
     1:   // caused by IME.  I have to mark the IME transaction as "fixed", which means
     1:   // that furure ime txns won't merge with it.  This is because we don't want
     1:   // future ime txns trying to put their text into a node that is no longer in
     1:   // the document.  This does not break undo/redo, because all these txns are 
     1:   // wrapped in a parent PlaceHolder txn, and placeholder txns are already 
     1:   // savvy to having multiple ime txns inside them.
     1:   
     1:   // delete empty ime text node if there is one
 60293:   if (isIMETransaction && mIMETextNode)
     1:   {
     1:     PRUint32 len;
     1:     mIMETextNode->GetLength(&len);
     1:     if (!len)
     1:     {
     1:       DeleteNode(mIMETextNode);
     1:       mIMETextNode = nsnull;
  3233:       static_cast<IMETextTxn*>(txn.get())->MarkFixed();  // mark the ime txn "fixed"
  3030:     }
  3030:   }
  3030:   
     1:   return result;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::SelectEntireDocument(nsISelection *aSelection)
     1: {
     1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
     1: 
 83343:   nsCOMPtr<nsIDOMElement> rootElement = do_QueryInterface(GetRoot());
     1:   if (!rootElement) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
     1:   return aSelection->SelectAllChildren(rootElement);
     1: }
     1: 
     1: 
 89184: nsINode*
 89184: nsEditor::GetFirstEditableNode(nsINode* aRoot)
 89184: {
 89184:   MOZ_ASSERT(aRoot);
 89184: 
 89184:   nsIContent* node = GetLeftmostChild(aRoot);
 89184:   if (node && !IsEditable(node)) {
 89184:     node = GetNextNode(node, /* aEditableNode = */ true);
 89184:   }
 89184: 
 89184:   return (node != aRoot) ? node : nsnull;
 89184: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::NotifyDocumentListeners(TDocumentListenerNotification aNotificationType)
     1: {
     1:   PRInt32 numListeners = mDocStateListeners.Count();
 43895:   if (!numListeners)    // maybe there just aren't any.
 43895:     return NS_OK;
     1:  
 30079:   nsCOMArray<nsIDocumentStateListener> listeners(mDocStateListeners);
     1:   nsresult rv = NS_OK;
     1:   PRInt32 i;
 30079: 
     1:   switch (aNotificationType)
     1:   {
     1:     case eDocumentCreated:
     1:       for (i = 0; i < numListeners;i++)
     1:       {
 30079:         rv = listeners[i]->NotifyDocumentCreated();
     1:         if (NS_FAILED(rv))
     1:           break;
     1:       }
     1:       break;
     1:       
     1:     case eDocumentToBeDestroyed:
     1:       for (i = 0; i < numListeners;i++)
     1:       {
 30079:         rv = listeners[i]->NotifyDocumentWillBeDestroyed();
     1:         if (NS_FAILED(rv))
     1:           break;
     1:       }
     1:       break;
     1:   
     1:     case eDocumentStateChanged:
     1:       {
 79445:         bool docIsDirty;
     1:         rv = GetDocumentModified(&docIsDirty);
 43805:         NS_ENSURE_SUCCESS(rv, rv);
     1:         
     1:         if (docIsDirty == mDocDirtyState)
     1:           return NS_OK;
     1:         
     1:         mDocDirtyState = (PRInt8)docIsDirty;
     1:         
     1:         for (i = 0; i < numListeners;i++)
     1:         {
 30079:           rv = listeners[i]->NotifyDocumentStateChanged(mDocDirtyState);
     1:           if (NS_FAILED(rv))
     1:             break;
     1:         }
     1:       }
     1:       break;
     1:     
     1:     default:
     1:       NS_NOTREACHED("Unknown notification");
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForInsertText(const nsAString & aStringToInsert,
     1:                                                nsIDOMCharacterData *aTextNode,
     1:                                                PRInt32 aOffset,
     1:                                                InsertTextTxn ** aTxn)
     1: {
 43806:   NS_ENSURE_TRUE(aTextNode && aTxn, NS_ERROR_NULL_POINTER);
 62873:   nsresult rv;
 62873: 
 62873:   nsRefPtr<InsertTextTxn> txn = new InsertTextTxn();
 62873:   rv = txn->Init(aTextNode, aOffset, aStringToInsert, this);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::DeleteText(nsIDOMCharacterData *aElement,
     1:                               PRUint32             aOffset,
     1:                               PRUint32             aLength)
     1: {
  3030:   nsRefPtr<DeleteTextTxn> txn;
  3030:   nsresult result = CreateTxnForDeleteText(aElement, aOffset, aLength,
  3030:                                            getter_AddRefs(txn));
     1:   nsAutoRules beginRulesSniffing(this, kOpDeleteText, nsIEditor::ePrevious);
     1:   if (NS_SUCCEEDED(result))  
     1:   {
     1:     // let listeners know what's up
     1:     PRInt32 i;
     1:     for (i = 0; i < mActionListeners.Count(); i++)
     1:       mActionListeners[i]->WillDeleteText(aElement, aOffset, aLength);
     1:     
     1:     result = DoTransaction(txn); 
     1:     
     1:     // let listeners know what happened
     1:     for (i = 0; i < mActionListeners.Count(); i++)
     1:       mActionListeners[i]->DidDeleteText(aElement, aOffset, aLength, result);
     1:   }
     1:   return result;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForDeleteText(nsIDOMCharacterData *aElement,
     1:                                                PRUint32             aOffset,
     1:                                                PRUint32             aLength,
     1:                                                DeleteTextTxn      **aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
     1: 
 62873:   nsRefPtr<DeleteTextTxn> txn = new DeleteTextTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aElement, aOffset, aLength, &mRangeUpdater);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForSplitNode(nsIDOMNode *aNode,
     1:                                          PRUint32    aOffset,
     1:                                          SplitElementTxn **aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
     1: 
 62873:   nsRefPtr<SplitElementTxn> txn = new SplitElementTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aNode, aOffset);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForJoinNode(nsIDOMNode  *aLeftNode,
     1:                                              nsIDOMNode  *aRightNode,
     1:                                              JoinElementTxn **aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aLeftNode && aRightNode, NS_ERROR_NULL_POINTER);
     1: 
 62873:   nsRefPtr<JoinElementTxn> txn = new JoinElementTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aLeftNode, aRightNode);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: // END nsEditor core implementation
     1: 
     1: 
     1: // BEGIN nsEditor public helper methods
     1: 
     1: nsresult
     1: nsEditor::SplitNodeImpl(nsIDOMNode * aExistingRightNode,
     1:                         PRInt32      aOffset,
     1:                         nsIDOMNode*  aNewLeftNode,
     1:                         nsIDOMNode*  aParent)
     1: {
     1: #ifdef NS_DEBUG_EDITOR
     1:   if (gNoisy) { printf("SplitNodeImpl: left=%p, right=%p, offset=%d\n", (void*)aNewLeftNode, (void*)aExistingRightNode, aOffset); }
     1: #endif
     1: 
     1:   NS_ASSERTION(((nsnull!=aExistingRightNode) &&
     1:                 (nsnull!=aNewLeftNode) &&
     1:                 (nsnull!=aParent)),
     1:                 "null arg");
     1:   nsresult result;
     1:   if ((nsnull!=aExistingRightNode) &&
     1:       (nsnull!=aNewLeftNode) &&
     1:       (nsnull!=aParent))
     1:   {
     1:     // get selection
     1:     nsCOMPtr<nsISelection> selection;
     1:     result = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(result, result);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
     1:     // remember some selection points
     1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
     1:     PRInt32 selStartOffset, selEndOffset;
 43518:     result = GetStartNodeAndOffset(selection, getter_AddRefs(selStartNode), &selStartOffset);
     1:     if (NS_FAILED(result)) selStartNode = nsnull;  // if selection is cleared, remember that
 43518:     result = GetEndNodeAndOffset(selection, getter_AddRefs(selEndNode), &selEndOffset);
     1:     if (NS_FAILED(result)) selStartNode = nsnull;  // if selection is cleared, remember that
     1: 
     1:     nsCOMPtr<nsIDOMNode> resultNode;
     1:     result = aParent->InsertBefore(aNewLeftNode, aExistingRightNode, getter_AddRefs(resultNode));
     1:     //printf("  after insert\n"); content->List();  // DEBUG
     1:     if (NS_SUCCEEDED(result))
     1:     {
     1:       // split the children between the 2 nodes
     1:       // at this point, aExistingRightNode has all the children
     1:       // move all the children whose index is < aOffset to aNewLeftNode
     1:       if (0<=aOffset) // don't bother unless we're going to move at least one child
     1:       {
     1:         // if it's a text node, just shuffle around some text
     1:         nsCOMPtr<nsIDOMCharacterData> rightNodeAsText( do_QueryInterface(aExistingRightNode) );
     1:         nsCOMPtr<nsIDOMCharacterData> leftNodeAsText( do_QueryInterface(aNewLeftNode) );
     1:         if (leftNodeAsText && rightNodeAsText)
     1:         {
     1:           // fix right node
     1:           nsAutoString leftText;
     1:           rightNodeAsText->SubstringData(0, aOffset, leftText);
     1:           rightNodeAsText->DeleteData(0, aOffset);
     1:           // fix left node
     1:           leftNodeAsText->SetData(leftText);
     1:           // moose          
     1:         }
     1:         else
     1:         {  // otherwise it's an interior node, so shuffle around the children
     1:            // go through list backwards so deletes don't interfere with the iteration
     1:           nsCOMPtr<nsIDOMNodeList> childNodes;
     1:           result = aExistingRightNode->GetChildNodes(getter_AddRefs(childNodes));
     1:           if ((NS_SUCCEEDED(result)) && (childNodes))
     1:           {
     1:             PRInt32 i=aOffset-1;
     1:             for ( ; ((NS_SUCCEEDED(result)) && (0<=i)); i--)
     1:             {
     1:               nsCOMPtr<nsIDOMNode> childNode;
     1:               result = childNodes->Item(i, getter_AddRefs(childNode));
     1:               if ((NS_SUCCEEDED(result)) && (childNode))
     1:               {
     1:                 result = aExistingRightNode->RemoveChild(childNode, getter_AddRefs(resultNode));
     1:                 //printf("  after remove\n"); content->List();  // DEBUG
     1:                 if (NS_SUCCEEDED(result))
     1:                 {
     1:                   nsCOMPtr<nsIDOMNode> firstChild;
     1:                   aNewLeftNode->GetFirstChild(getter_AddRefs(firstChild));
     1:                   result = aNewLeftNode->InsertBefore(childNode, firstChild, getter_AddRefs(resultNode));
     1:                   //printf("  after append\n"); content->List();  // DEBUG
     1:                 }
     1:               }
     1:             }
     1:           }        
     1:         }
     1:         // handle selection
 70236:         nsCOMPtr<nsIPresShell> ps = GetPresShell();
 42409:         if (ps)
 42409:           ps->FlushPendingNotifications(Flush_Frames);
 42409: 
     1:         if (GetShouldTxnSetSelection())
     1:         {
     1:           // editor wants us to set selection at split point
     1:           selection->Collapse(aNewLeftNode, aOffset);
     1:         }
     1:         else if (selStartNode)   
     1:         {
     1:           // else adjust the selection if needed.  if selStartNode is null, then there was no selection.
     1:           // HACK: this is overly simplified - multi-range selections need more work than this
     1:           if (selStartNode.get() == aExistingRightNode)
     1:           {
     1:             if (selStartOffset < aOffset)
     1:             {
     1:               selStartNode = aNewLeftNode;
     1:             }
     1:             else
     1:             {
     1:               selStartOffset -= aOffset;
     1:             }
     1:           }
     1:           if (selEndNode.get() == aExistingRightNode)
     1:           {
     1:             if (selEndOffset < aOffset)
     1:             {
     1:               selEndNode = aNewLeftNode;
     1:             }
     1:             else
     1:             {
     1:               selEndOffset -= aOffset;
     1:             }
     1:           }
     1:           selection->Collapse(selStartNode,selStartOffset);
     1:           selection->Extend(selEndNode,selEndOffset);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   else
     1:     result = NS_ERROR_INVALID_ARG;
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
     1: nsEditor::JoinNodesImpl(nsIDOMNode * aNodeToKeep,
     1:                         nsIDOMNode * aNodeToJoin,
     1:                         nsIDOMNode * aParent,
 79445:                         bool         aNodeToKeepIsFirst)
     1: {
     1:   NS_ASSERTION(aNodeToKeep && aNodeToJoin && aParent, "null arg");
 56879:   nsresult result = NS_OK;
     1:   if (aNodeToKeep && aNodeToJoin && aParent)
     1:   {
     1:     // get selection
     1:     nsCOMPtr<nsISelection> selection;
     1:     GetSelection(getter_AddRefs(selection));
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
     1:     // remember some selection points
     1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
     1:     PRInt32 selStartOffset, selEndOffset, joinOffset, keepOffset;
 43518:     result = GetStartNodeAndOffset(selection, getter_AddRefs(selStartNode), &selStartOffset);
     1:     if (NS_FAILED(result)) selStartNode = nsnull;
 43518:     result = GetEndNodeAndOffset(selection, getter_AddRefs(selEndNode), &selEndOffset);
     1:     // Joe or Kin should comment here on why the following line is not a copy/paste error
     1:     if (NS_FAILED(result)) selStartNode = nsnull;
     1: 
     1:     nsCOMPtr<nsIDOMNode> leftNode;
     1:     if (aNodeToKeepIsFirst)
     1:       leftNode = aNodeToKeep;
     1:     else
     1:       leftNode = aNodeToJoin;
     1: 
     1:     PRUint32 firstNodeLength;
     1:     result = GetLengthOfDOMNode(leftNode, firstNodeLength);
 43805:     NS_ENSURE_SUCCESS(result, result);
     1:     nsCOMPtr<nsIDOMNode> parent;
     1:     result = GetNodeLocation(aNodeToJoin, address_of(parent), &joinOffset);
 43805:     NS_ENSURE_SUCCESS(result, result);
     1:     result = GetNodeLocation(aNodeToKeep, address_of(parent), &keepOffset);
 43805:     NS_ENSURE_SUCCESS(result, result);
     1:     
     1:     // if selection endpoint is between the nodes, remember it as being
     1:     // in the one that is going away instead.  This simplifies later selection
     1:     // adjustment logic at end of this method.
     1:     if (selStartNode)
     1:     {
     1:       if (selStartNode == parent)
     1:       {
     1:         if (aNodeToKeepIsFirst)
     1:         {
     1:           if ((selStartOffset > keepOffset) && (selStartOffset <= joinOffset))
     1:           {
     1:             selStartNode = aNodeToJoin; 
     1:             selStartOffset = 0;
     1:           }
     1:         }
     1:         else
     1:         {
     1:           if ((selStartOffset > joinOffset) && (selStartOffset <= keepOffset))
     1:           {
     1:             selStartNode = aNodeToJoin; 
     1:             selStartOffset = firstNodeLength;
     1:           }
     1:         }
     1:       }
     1:       if (selEndNode == parent)
     1:       {
     1:         if (aNodeToKeepIsFirst)
     1:         {
     1:           if ((selEndOffset > keepOffset) && (selEndOffset <= joinOffset))
     1:           {
     1:             selEndNode = aNodeToJoin; 
     1:             selEndOffset = 0;
     1:           }
     1:         }
     1:         else
     1:         {
     1:           if ((selEndOffset > joinOffset) && (selEndOffset <= keepOffset))
     1:           {
     1:             selEndNode = aNodeToJoin; 
     1:             selEndOffset = firstNodeLength;
     1:           }
     1:         }
     1:       }
     1:     }
     1:     // ok, ready to do join now.
     1:     // if it's a text node, just shuffle around some text
     1:     nsCOMPtr<nsIDOMCharacterData> keepNodeAsText( do_QueryInterface(aNodeToKeep) );
     1:     nsCOMPtr<nsIDOMCharacterData> joinNodeAsText( do_QueryInterface(aNodeToJoin) );
     1:     if (keepNodeAsText && joinNodeAsText)
     1:     {
     1:       nsAutoString rightText;
     1:       nsAutoString leftText;
     1:       if (aNodeToKeepIsFirst)
     1:       {
     1:         keepNodeAsText->GetData(leftText);
     1:         joinNodeAsText->GetData(rightText);
     1:       }
     1:       else
     1:       {
     1:         keepNodeAsText->GetData(rightText);
     1:         joinNodeAsText->GetData(leftText);
     1:       }
     1:       leftText += rightText;
     1:       keepNodeAsText->SetData(leftText);          
     1:     }
     1:     else
     1:     {  // otherwise it's an interior node, so shuffle around the children
     1:       nsCOMPtr<nsIDOMNodeList> childNodes;
     1:       result = aNodeToJoin->GetChildNodes(getter_AddRefs(childNodes));
     1:       if ((NS_SUCCEEDED(result)) && (childNodes))
     1:       {
     1:         PRInt32 i;  // must be signed int!
     1:         PRUint32 childCount=0;
     1:         nsCOMPtr<nsIDOMNode> firstNode; //only used if aNodeToKeepIsFirst is false
     1:         childNodes->GetLength(&childCount);
     1:         if (!aNodeToKeepIsFirst)
     1:         { // remember the first child in aNodeToKeep, we'll insert all the children of aNodeToJoin in front of it
     1:           result = aNodeToKeep->GetFirstChild(getter_AddRefs(firstNode));  
     1:           // GetFirstChild returns nsnull firstNode if aNodeToKeep has no children, that's ok.
     1:         }
     1:         nsCOMPtr<nsIDOMNode> resultNode;
     1:         // have to go through the list backwards to keep deletes from interfering with iteration
     1:         nsCOMPtr<nsIDOMNode> previousChild;
     1:         for (i=childCount-1; ((NS_SUCCEEDED(result)) && (0<=i)); i--)
     1:         {
     1:           nsCOMPtr<nsIDOMNode> childNode;
     1:           result = childNodes->Item(i, getter_AddRefs(childNode));
     1:           if ((NS_SUCCEEDED(result)) && (childNode))
     1:           {
     1:             if (aNodeToKeepIsFirst)
     1:             { // append children of aNodeToJoin
     1:               //was result = aNodeToKeep->AppendChild(childNode, getter_AddRefs(resultNode));
     1:               result = aNodeToKeep->InsertBefore(childNode, previousChild, getter_AddRefs(resultNode));
     1:               previousChild = do_QueryInterface(childNode);
     1:             }
     1:             else
     1:             { // prepend children of aNodeToJoin
     1:               result = aNodeToKeep->InsertBefore(childNode, firstNode, getter_AddRefs(resultNode));
     1:               firstNode = do_QueryInterface(childNode);
     1:             }
     1:           }
     1:         }
     1:       }
     1:       else if (!childNodes) {
     1:         result = NS_ERROR_NULL_POINTER;
     1:       }
     1:     }
     1:     if (NS_SUCCEEDED(result))
     1:     { // delete the extra node
     1:       nsCOMPtr<nsIDOMNode> resultNode;
     1:       result = aParent->RemoveChild(aNodeToJoin, getter_AddRefs(resultNode));
     1:       
     1:       if (GetShouldTxnSetSelection())
     1:       {
     1:         // editor wants us to set selection at join point
     1:         selection->Collapse(aNodeToKeep, firstNodeLength);
     1:       }
     1:       else if (selStartNode)
     1:       {
     1:         // and adjust the selection if needed
     1:         // HACK: this is overly simplified - multi-range selections need more work than this
 79445:         bool bNeedToAdjust = false;
     1:         
     1:         // check to see if we joined nodes where selection starts
     1:         if (selStartNode.get() == aNodeToJoin)
     1:         {
 80486:           bNeedToAdjust = true;
     1:           selStartNode = aNodeToKeep;
     1:           if (aNodeToKeepIsFirst)
     1:           {
     1:             selStartOffset += firstNodeLength;
     1:           }
     1:         }
     1:         else if ((selStartNode.get() == aNodeToKeep) && !aNodeToKeepIsFirst)
     1:         {
 80486:           bNeedToAdjust = true;
     1:           selStartOffset += firstNodeLength;
     1:         }
     1:                 
     1:         // check to see if we joined nodes where selection ends
     1:         if (selEndNode.get() == aNodeToJoin)
     1:         {
 80486:           bNeedToAdjust = true;
     1:           selEndNode = aNodeToKeep;
     1:           if (aNodeToKeepIsFirst)
     1:           {
     1:             selEndOffset += firstNodeLength;
     1:           }
     1:         }
     1:         else if ((selEndNode.get() == aNodeToKeep) && !aNodeToKeepIsFirst)
     1:         {
 80486:           bNeedToAdjust = true;
     1:           selEndOffset += firstNodeLength;
     1:         }
     1:         
     1:         // adjust selection if needed
     1:         if (bNeedToAdjust)
     1:         {
     1:           selection->Collapse(selStartNode,selStartOffset);
     1:           selection->Extend(selEndNode,selEndOffset);          
     1:         }
     1:       }
     1:     }
     1:   }
     1:   else
     1:     result = NS_ERROR_INVALID_ARG;
     1: 
     1:   return result;
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsEditor::GetChildOffset(nsIDOMNode *aChild, nsIDOMNode *aParent, PRInt32 &aOffset)
     1: {
     1:   NS_ASSERTION((aChild && aParent), "bad args");
     1: 
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aParent);
     1:   nsCOMPtr<nsIContent> cChild = do_QueryInterface(aChild);
 43807:   NS_ENSURE_TRUE(cChild && content, NS_ERROR_NULL_POINTER);
     1: 
     1:   aOffset = content->IndexOf(cChild);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult 
     1: nsEditor::GetNodeLocation(nsIDOMNode *inChild, nsCOMPtr<nsIDOMNode> *outParent, PRInt32 *outOffset)
     1: {
     1:   NS_ASSERTION((inChild && outParent && outOffset), "bad args");
     1:   nsresult result = NS_ERROR_NULL_POINTER;
     1:   if (inChild && outParent && outOffset)
     1:   {
     1:     result = inChild->GetParentNode(getter_AddRefs(*outParent));
     1:     if ((NS_SUCCEEDED(result)) && (*outParent))
     1:     {
     1:       result = GetChildOffset(inChild, *outParent, *outOffset);
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: // returns the number of things inside aNode.  
     1: // If aNode is text, returns number of characters. If not, returns number of children nodes.
     1: nsresult
     1: nsEditor::GetLengthOfDOMNode(nsIDOMNode *aNode, PRUint32 &aCount) 
     1: {
     1:   aCount = 0;
 94357:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 94357:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
 94357:   aCount = node->Length();
 94357:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsEditor::GetPriorNode(nsIDOMNode  *aParentNode, 
     1:                        PRInt32      aOffset, 
 79445:                        bool         aEditableNode, 
     1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                        bool         bNoBlockCrossing)
     1: {
 97755:   NS_ENSURE_TRUE(aResultNode, NS_ERROR_NULL_POINTER);
     1:   *aResultNode = nsnull;
     1: 
 97755:   nsCOMPtr<nsINode> parentNode = do_QueryInterface(aParentNode);
 97755:   NS_ENSURE_TRUE(parentNode, NS_ERROR_NULL_POINTER);
 97755: 
 97755:   *aResultNode = do_QueryInterface(GetPriorNode(parentNode, aOffset,
 97988:                                                 aEditableNode,
 97988:                                                 bNoBlockCrossing));
     1:   return NS_OK;
     1: }
 97755: 
 97755: nsIContent*
 97755: nsEditor::GetPriorNode(nsINode* aParentNode,
 97755:                        PRInt32 aOffset,
 97755:                        bool aEditableNode,
 97988:                        bool aNoBlockCrossing)
 97755: {
 97755:   MOZ_ASSERT(aParentNode);
 97755: 
 97755:   // If we are at the beginning of the node, or it is a text node, then just
 97755:   // look before it.
 97755:   if (!aOffset || aParentNode->NodeType() == nsIDOMNode::TEXT_NODE) {
 97755:     if (aNoBlockCrossing && IsBlockNode(aParentNode)) {
 97755:       // If we aren't allowed to cross blocks, don't look before this block.
 97755:       return nsnull;
 97755:     }
 97988:     return GetPriorNode(aParentNode, aEditableNode, aNoBlockCrossing);
     1:   }
     1: 
     1:   // else look before the child at 'aOffset'
 97755:   if (nsIContent* child = aParentNode->GetChildAt(aOffset)) {
 97988:     return GetPriorNode(child, aEditableNode, aNoBlockCrossing);
 97755:   }
     1: 
     1:   // unless there isn't one, in which case we are at the end of the node
     1:   // and want the deep-right child.
 97755:   nsIContent* resultNode = GetRightmostChild(aParentNode, aNoBlockCrossing);
 97755:   if (!resultNode || !aEditableNode || IsEditable(resultNode)) {
 97755:     return resultNode;
 97755:   }
     1: 
     1:   // restart the search from the non-editable node we just found
 97988:   return GetPriorNode(resultNode, aEditableNode, aNoBlockCrossing);
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsEditor::GetNextNode(nsIDOMNode   *aParentNode, 
     1:                       PRInt32      aOffset, 
 79445:                       bool         aEditableNode, 
     1:                       nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                       bool         bNoBlockCrossing)
     1: {
 97755:   NS_ENSURE_TRUE(aResultNode, NS_ERROR_NULL_POINTER);
     1:   *aResultNode = nsnull;
     1: 
 97755:   nsCOMPtr<nsINode> parentNode = do_QueryInterface(aParentNode);
 97755:   NS_ENSURE_TRUE(parentNode, NS_ERROR_NULL_POINTER);
 97755: 
 97755:   *aResultNode = do_QueryInterface(GetNextNode(parentNode, aOffset,
 97988:                                                aEditableNode,
 97988:                                                bNoBlockCrossing));
 97755:   return NS_OK;
 97755: }
 97755: 
 97755: nsIContent*
 97755: nsEditor::GetNextNode(nsINode* aParentNode,
 97755:                       PRInt32 aOffset,
 97755:                       bool aEditableNode,
 97988:                       bool aNoBlockCrossing)
 97755: {
 97755:   MOZ_ASSERT(aParentNode);
 97755: 
 90153:   // if aParentNode is a text node, use its location instead
 97755:   if (aParentNode->NodeType() == nsIDOMNode::TEXT_NODE) {
 97755:     nsINode* parent = aParentNode->GetNodeParent();
 97755:     NS_ENSURE_TRUE(parent, nsnull);
 97755:     aOffset = parent->IndexOf(aParentNode) + 1; // _after_ the text node
     1:     aParentNode = parent;
 97755:   }
 97755: 
     1:   // look at the child at 'aOffset'
 97755:   nsIContent* child = aParentNode->GetChildAt(aOffset);
 97755:   if (child) {
 97755:     if (aNoBlockCrossing && IsBlockNode(child)) {
 97755:       return child;
 97755:     }
 97755: 
 97755:     nsIContent* resultNode = GetLeftmostChild(child, aNoBlockCrossing);
 97755:     if (!resultNode) {
 97755:       return child;
 97755:     }
 97755: 
 97988:     if (!IsDescendantOfEditorRoot(resultNode)) {
 97755:       return nsnull;
 97755:     }
 97755: 
 97755:     if (!aEditableNode || IsEditable(resultNode)) {
 97755:       return resultNode;
 97755:     }
     1: 
     1:     // restart the search from the non-editable node we just found
 97988:     return GetNextNode(resultNode, aEditableNode, aNoBlockCrossing);
     1:   }
     1:     
     1:   // unless there isn't one, in which case we are at the end of the node
     1:   // and want the next one.
 97755:   if (aNoBlockCrossing && IsBlockNode(aParentNode)) {
     1:     // don't cross out of parent block
     1:     return NS_OK;
     1:   }
 97755: 
 97988:   return GetNextNode(aParentNode, aEditableNode, aNoBlockCrossing);
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsEditor::GetPriorNode(nsIDOMNode  *aCurrentNode, 
 79445:                        bool         aEditableNode, 
     1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                        bool         bNoBlockCrossing)
     1: {
 97755:   NS_ENSURE_TRUE(aResultNode, NS_ERROR_NULL_POINTER);
     1: 
 82862:   nsCOMPtr<nsINode> currentNode = do_QueryInterface(aCurrentNode);
 97755:   NS_ENSURE_TRUE(currentNode, NS_ERROR_NULL_POINTER);
 97755: 
 97755:   *aResultNode = do_QueryInterface(GetPriorNode(currentNode, aEditableNode,
 97988:                                                 bNoBlockCrossing));
 97755:   return NS_OK;
 97755: }
 97755: 
 97755: nsIContent*
 97755: nsEditor::GetPriorNode(nsINode* aCurrentNode, bool aEditableNode,
 97988:                        bool aNoBlockCrossing /* = false */)
 97755: {
 97755:   MOZ_ASSERT(aCurrentNode);
 97755: 
 97988:   if (!IsDescendantOfEditorRoot(aCurrentNode)) {
 97755:     return nsnull;
 97755:   }
 97755: 
 97988:   return FindNode(aCurrentNode, false, aEditableNode, aNoBlockCrossing);
 82862: }
 82862: 
 82862: nsIContent*
 82862: nsEditor::FindNextLeafNode(nsINode  *aCurrentNode, 
 82862:                            bool      aGoForward,
 97988:                            bool      bNoBlockCrossing)
     1: {
     1:   // called only by GetPriorNode so we don't need to check params.
 97988:   NS_PRECONDITION(IsDescendantOfEditorRoot(aCurrentNode) &&
 97988:                   !IsEditorRoot(aCurrentNode),
 82862:                   "Bogus arguments");
 82862: 
 82862:   nsINode* cur = aCurrentNode;
 82862:   for (;;) {
 82862:     // if aCurrentNode has a sibling in the right direction, return
 82862:     // that sibling's closest child (or itself if it has no children)
 82862:     nsIContent* sibling =
 82862:       aGoForward ? cur->GetNextSibling() : cur->GetPreviousSibling();
 82862:     if (sibling) {
 82862:       if (bNoBlockCrossing && IsBlockNode(sibling)) {
     1:         // don't look inside prevsib, since it is a block
 82862:         return sibling;
 82862:       }
 82862:       nsIContent *leaf =
 82862:         aGoForward ? GetLeftmostChild(sibling, bNoBlockCrossing) :
 82862:                      GetRightmostChild(sibling, bNoBlockCrossing);
 82862:       if (!leaf) { 
 82862:         return sibling;
 82862:       }
 82862: 
 82862:       return leaf;
 82862:     }
 82862: 
 82862:     nsINode *parent = cur->GetNodeParent();
 82862:     if (!parent) {
 82862:       return nsnull;
 82862:     }
 82862: 
 97988:     NS_ASSERTION(IsDescendantOfEditorRoot(parent),
 82862:                  "We started with a proper descendant of root, and should stop "
 82862:                  "if we ever hit the root, so we better have a descendant of "
 82862:                  "root now!");
 97988:     if (IsEditorRoot(parent) ||
 97988:         (bNoBlockCrossing && IsBlockNode(parent))) {
 82862:       return nsnull;
 82862:     }
 82862: 
 82862:     cur = parent;
 82862:   }
 82862: 
 82862:   NS_NOTREACHED("What part of for(;;) do you not understand?");
 82862:   return nsnull;
     1: }
     1: 
     1: nsresult
     1: nsEditor::GetNextNode(nsIDOMNode* aCurrentNode,
 79445:                       bool aEditableNode,
     1:                       nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                       bool bNoBlockCrossing)
     1: {
 82863:   nsCOMPtr<nsINode> currentNode = do_QueryInterface(aCurrentNode);
 89183:   if (!currentNode || !aResultNode) {
 89183:     return NS_ERROR_NULL_POINTER;
 89183:   }
 89183: 
 89183:   *aResultNode = do_QueryInterface(GetNextNode(currentNode, aEditableNode,
 97988:                                                bNoBlockCrossing));
 89183:   return NS_OK;
 89183: }
 89183: 
 89183: nsIContent*
 89183: nsEditor::GetNextNode(nsINode* aCurrentNode,
 89183:                       bool aEditableNode,
 97988:                       bool bNoBlockCrossing)
 89183: {
 89183:   MOZ_ASSERT(aCurrentNode);
 89183: 
 97988:   if (!IsDescendantOfEditorRoot(aCurrentNode)) {
 89183:     return nsnull;
 89183:   }
 89183: 
 97988:   return FindNode(aCurrentNode, true, aEditableNode, bNoBlockCrossing);
 82863: }
 82863: 
 82863: nsIContent*
 82863: nsEditor::FindNode(nsINode *aCurrentNode,
 82863:                    bool     aGoForward,
 82863:                    bool     aEditableNode,
 97988:                    bool     bNoBlockCrossing)
 97988: {
 97988:   if (IsEditorRoot(aCurrentNode)) {
     1:     // Don't allow traversal above the root node! This helps
     1:     // prevent us from accidentally editing browser content
     1:     // when the editor is in a text widget.
     1: 
 82863:     return nsnull;
 82863:   }
 82863: 
 82863:   nsIContent* candidate =
 97988:     FindNextLeafNode(aCurrentNode, aGoForward, bNoBlockCrossing);
 82863:   
 82863:   if (!candidate) {
 82863:     return nsnull;
 82863:   }
 82863: 
 82863:   if (!aEditableNode || IsEditable(candidate)) {
 82863:     return candidate;
 82863:   }
 82863: 
 97988:   return FindNode(candidate, aGoForward, aEditableNode, bNoBlockCrossing);
     1: }
     1: 
 75266: already_AddRefed<nsIDOMNode>
     1: nsEditor::GetRightmostChild(nsIDOMNode *aCurrentNode, 
 79445:                             bool bNoBlockCrossing)
     1: {
 43806:   NS_ENSURE_TRUE(aCurrentNode, nsnull);
     1:   nsCOMPtr<nsIDOMNode> resultNode, temp = aCurrentNode;
 79445:   bool hasChildren;
     1:   aCurrentNode->HasChildNodes(&hasChildren);
 75266:   while (hasChildren) {
     1:     temp->GetLastChild(getter_AddRefs(resultNode));
 75266:     if (resultNode) {
 75266:       if (bNoBlockCrossing && IsBlockNode(resultNode)) {
 75266:         return resultNode.forget();
 75266:       }
     1:       resultNode->HasChildNodes(&hasChildren);
     1:       temp = resultNode;
 75266:     } else {
 80486:       hasChildren = false;
     1:     }
 75266:   }
 75266: 
 75266:   return resultNode.forget();
 75266: }
 75266: 
 82861: nsIContent*
 82861: nsEditor::GetRightmostChild(nsINode *aCurrentNode,
 82861:                             bool     bNoBlockCrossing)
 82861: {
 82861:   NS_ENSURE_TRUE(aCurrentNode, nsnull);
 82861:   nsIContent *cur = aCurrentNode->GetLastChild();
 82861:   if (!cur) {
 82861:     return nsnull;
 82861:   }
 82861:   for (;;) {
 82861:     if (bNoBlockCrossing && IsBlockNode(cur)) {
 82861:       return cur;
 82861:     }
 82861:     nsIContent* next = cur->GetLastChild();
 82861:     if (!next) {
 82861:       return cur;
 82861:     }
 82861:     cur = next;
 82861:   }
 82861: 
 82861:   NS_NOTREACHED("What part of for(;;) do you not understand?");
 82861:   return nsnull;
 82861: }
 82861: 
 82861: nsIContent*
 82861: nsEditor::GetLeftmostChild(nsINode *aCurrentNode,
 82861:                            bool     bNoBlockCrossing)
 82861: {
 82861:   NS_ENSURE_TRUE(aCurrentNode, nsnull);
 82861:   nsIContent *cur = aCurrentNode->GetFirstChild();
 82861:   if (!cur) {
 82861:     return nsnull;
 82861:   }
 82861:   for (;;) {
 82861:     if (bNoBlockCrossing && IsBlockNode(cur)) {
 82861:       return cur;
 82861:     }
 82861:     nsIContent *next = cur->GetFirstChild();
 82861:     if (!next) {
 82861:       return cur;
 82861:     }
 82861:     cur = next;
 82861:   }
 82861: 
 82861:   NS_NOTREACHED("What part of for(;;) do you not understand?");
 82861:   return nsnull;
 82861: }
 82861: 
 75266: already_AddRefed<nsIDOMNode>
     1: nsEditor::GetLeftmostChild(nsIDOMNode *aCurrentNode,
 79445:                            bool bNoBlockCrossing)
     1: {
 43806:   NS_ENSURE_TRUE(aCurrentNode, nsnull);
     1:   nsCOMPtr<nsIDOMNode> resultNode, temp = aCurrentNode;
 79445:   bool hasChildren;
     1:   aCurrentNode->HasChildNodes(&hasChildren);
 75266:   while (hasChildren) {
     1:     temp->GetFirstChild(getter_AddRefs(resultNode));
 75266:     if (resultNode) {
 75266:       if (bNoBlockCrossing && IsBlockNode(resultNode)) {
 75266:         return resultNode.forget();
 75266:       }
     1:       resultNode->HasChildNodes(&hasChildren);
     1:       temp = resultNode;
 75266:     } else {
 80486:       hasChildren = false;
     1:     }
 75266:   }
 75266: 
 75266:   return resultNode.forget();
     1: }
     1: 
 79445: bool 
     1: nsEditor::IsBlockNode(nsIDOMNode *aNode)
     1: {
     1:   // stub to be overridden in nsHTMLEditor.
 41545:   // screwing around with the class hierarchy here in order
     1:   // to not duplicate the code in GetNextNode/GetPrevNode
     1:   // across both nsEditor/nsHTMLEditor.  
 80486:   return false;
     1: }
     1: 
 79445: bool 
 82861: nsEditor::IsBlockNode(nsINode *aNode)
 82861: {
 82861:   // stub to be overridden in nsHTMLEditor.
 82861:   // screwing around with the class hierarchy here in order
 82861:   // to not duplicate the code in GetNextNode/GetPrevNode
 82861:   // across both nsEditor/nsHTMLEditor.
 82861:   return false;
 82861: }
 82861: 
 82861: bool
 97375: nsEditor::CanContain(nsIDOMNode* aParent, nsIDOMNode* aChild)
 97375: {
 98806:   nsCOMPtr<nsIContent> parent = do_QueryInterface(aParent);
 98806:   NS_ENSURE_TRUE(parent, false);
 98806: 
 98806:   switch (parent->NodeType()) {
 98806:   case nsIDOMNode::ELEMENT_NODE:
 98806:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
 98806:     return TagCanContain(parent->Tag(), aChild);
 98806:   }
 98806:   return false;
 97375: }
 97375: 
 97375: bool
 97376: nsEditor::CanContainTag(nsIDOMNode* aParent, nsIAtom* aChildTag)
 97376: {
 98806:   nsCOMPtr<nsIContent> parent = do_QueryInterface(aParent);
 98806:   NS_ENSURE_TRUE(parent, false);
 98806: 
 98806:   switch (parent->NodeType()) {
 98806:   case nsIDOMNode::ELEMENT_NODE:
 98806:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
 98806:     return TagCanContainTag(parent->Tag(), aChildTag);
 98806:   }
 98806:   return false;
     1: }
     1: 
 79445: bool 
 97376: nsEditor::TagCanContain(nsIAtom* aParentTag, nsIDOMNode* aChild)
 97376: {
 98806:   nsCOMPtr<nsIContent> child = do_QueryInterface(aChild);
 98806:   NS_ENSURE_TRUE(child, false);
 98806: 
 98806:   switch (child->NodeType()) {
 98806:   case nsIDOMNode::TEXT_NODE:
 98806:   case nsIDOMNode::ELEMENT_NODE:
 98806:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
 98806:     return TagCanContainTag(aParentTag, child->Tag());
 98806:   }
 98806:   return false;
     1: }
     1: 
 79445: bool 
 97376: nsEditor::TagCanContainTag(nsIAtom* aParentTag, nsIAtom* aChildTag)
     1: {
 80486:   return true;
     1: }
     1: 
 79445: bool
 97986: nsEditor::IsRoot(nsIDOMNode* inNode)
     1: {
 80486:   NS_ENSURE_TRUE(inNode, false);
     1: 
 83343:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(GetRoot());
 83343: 
 83343:   return inNode == rootNode;
 82861: }
 82861: 
 82861: bool 
 97986: nsEditor::IsRoot(nsINode* inNode)
 82861: {
 82861:   NS_ENSURE_TRUE(inNode, false);
 82861: 
 83343:   nsCOMPtr<nsINode> rootNode = GetRoot();
 83343: 
 83343:   return inNode == rootNode;
     1: }
     1: 
 79445: bool
 97988: nsEditor::IsEditorRoot(nsINode* aNode)
 97988: {
 97988:   NS_ENSURE_TRUE(aNode, false);
 97988:   nsCOMPtr<nsINode> rootNode = GetEditorRoot();
 97988:   return aNode == rootNode;
 97988: }
 97988: 
 97988: bool 
 97986: nsEditor::IsDescendantOfRoot(nsIDOMNode* inNode)
     1: {
 82861:   nsCOMPtr<nsINode> node = do_QueryInterface(inNode);
 97986:   return IsDescendantOfRoot(node);
 82861: }
 82861: 
 82861: bool
 97986: nsEditor::IsDescendantOfRoot(nsINode* inNode)
 82861: {
 80486:   NS_ENSURE_TRUE(inNode, false);
 83343:   nsCOMPtr<nsIContent> root = GetRoot();
 82861:   NS_ENSURE_TRUE(root, false);
 82861: 
 82861:   return nsContentUtils::ContentIsDescendantOf(inNode, root);
     1: }
     1: 
 79445: bool
 97989: nsEditor::IsDescendantOfEditorRoot(nsIDOMNode* aNode)
 97989: {
 97989:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 97989:   return IsDescendantOfEditorRoot(node);
 97989: }
 97989: 
 97989: bool
 97988: nsEditor::IsDescendantOfEditorRoot(nsINode* aNode)
 97988: {
 97988:   NS_ENSURE_TRUE(aNode, false);
 97988:   nsCOMPtr<nsIContent> root = GetEditorRoot();
 97988:   NS_ENSURE_TRUE(root, false);
 97988: 
 97988:   return nsContentUtils::ContentIsDescendantOf(aNode, root);
 97988: }
 97988: 
 97988: bool 
     1: nsEditor::IsContainer(nsIDOMNode *aNode)
     1: {
 80486:   return aNode ? true : false;
     1: }
     1: 
 79445: bool
 82861: nsEditor::IsTextInDirtyFrameVisible(nsIContent *aNode)
     1: {
 97761:   MOZ_ASSERT(aNode);
 97761:   MOZ_ASSERT(aNode->NodeType() == nsIDOMNode::TEXT_NODE);
 97761: 
     1:   // virtual method
     1:   //
     1:   // If this is a simple non-html editor,
     1:   // the best we can do is to assume it's visible.
     1: 
 80486:   return true;
     1: }
     1: 
 82860: static inline bool
 82860: IsElementVisible(dom::Element* aElement)
 82860: {
 82860:   if (aElement->GetPrimaryFrame()) {
 82860:     // It's visible, for our purposes
 82860:     return true;
 82860:   }
 82860: 
 82860:   nsIContent *cur = aElement;
 82860:   for (; ;) {
 87637:     // Walk up the tree looking for the nearest ancestor with a frame.
 87637:     // The state of the child right below it will determine whether
 87637:     // we might possibly have a frame or not.
 87637:     bool haveLazyBitOnChild = cur->HasFlag(NODE_NEEDS_FRAME);
 82860:     cur = cur->GetFlattenedTreeParent();
 82860:     if (!cur) {
 87637:       if (!haveLazyBitOnChild) {
 87637:         // None of our ancestors have lazy bits set, so we shouldn't
 87637:         // have a frame
 82860:         return false;
 82860:       }
 82860: 
 87637:       // The root has a lazy frame construction bit.  We need to check
 87637:       // our style.
 87637:       break;
 87637:     }
 87637: 
 82860:     if (cur->GetPrimaryFrame()) {
 87637:       if (!haveLazyBitOnChild) {
 87637:         // Our ancestor directly under |cur| doesn't have lazy bits;
 87637:         // that means we won't get a frame
 82860:         return false;
 82860:       }
 82860: 
 87637:       if (cur->GetPrimaryFrame()->IsLeaf()) {
 87637:         // Nothing under here will ever get frames
 82860:         return false;
 82860:       }
 87637: 
 87637:       // Otherwise, we might end up with a frame when that lazy bit is
 87637:       // processed.  Figure out our actual style.
 82860:       break;
 82860:     }
 82860:   }
 82860: 
 82860:   // Now it might be that we have no frame because we're in a
 82860:   // display:none subtree, or it might be that we're just dealing with
 82860:   // lazy frame construction and it hasn't happened yet.  Check which
 82860:   // one it is.
 80566:   nsRefPtr<nsStyleContext> styleContext =
 82860:     nsComputedDOMStyle::GetStyleContextForElementNoFlush(aElement,
 80566:                                                          nsnull, nsnull);
 80566:   if (styleContext) {
 80566:     return styleContext->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_NONE;
 80566:   }
 80566:   return false;
 80566: }
 80566: 
 79445: bool 
     1: nsEditor::IsEditable(nsIDOMNode *aNode)
     1: {
 82861:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 82861:   return IsEditable(content);
 82861: }
 82861: 
 82861: bool
 82861: nsEditor::IsEditable(nsIContent *aNode)
 82861: {
 80486:   NS_ENSURE_TRUE(aNode, false);
 80486: 
 80486:   if (IsMozEditorBogusNode(aNode) || !IsModifiableNode(aNode)) return false;
     1: 
     1:   // see if it has a frame.  If so, we'll edit it.
     1:   // special case for textnodes: frame must have width.
 82861:   if (aNode->IsElement() && !IsElementVisible(aNode->AsElement())) {
 82860:     // If the element has no frame, it's not editable.  Note that we
 82860:     // need to check IsElement() here, because some of our tests
 82860:     // rely on frameless textnodes being visible.
 80486:     return false;
 82860:   }
 89740:   switch (aNode->NodeType()) {
 89740:     case nsIDOMNode::ELEMENT_NODE:
 89740:       return true; // not a text node; not invisible
 89740:     case nsIDOMNode::TEXT_NODE:
 89740:       return IsTextInDirtyFrameVisible(aNode);
 89740:     default:
 89668:       return false;
 89740:   }
     1: }
     1: 
 79445: bool
 82861: nsEditor::IsMozEditorBogusNode(nsIContent *element)
 82861: {
 41743:   return element &&
 41743:          element->AttrValueIs(kNameSpaceID_None, kMOZEditorBogusNodeAttrAtom,
 41743:                               kMOZEditorBogusNodeValue, eCaseMatters);
     1: }
     1: 
     1: nsresult
     1: nsEditor::CountEditableChildren(nsIDOMNode *aNode, PRUint32 &outCount) 
     1: {
     1:   outCount = 0;
     1:   if (!aNode) { return NS_ERROR_NULL_POINTER; }
     1:   nsresult res=NS_OK;
 79445:   bool hasChildNodes;
     1:   aNode->HasChildNodes(&hasChildNodes);
     1:   if (hasChildNodes)
     1:   {
     1:     nsCOMPtr<nsIDOMNodeList>nodeList;
     1:     res = aNode->GetChildNodes(getter_AddRefs(nodeList));
     1:     if (NS_SUCCEEDED(res) && nodeList) 
     1:     {
     1:       PRUint32 i;
     1:       PRUint32 len;
     1:       nodeList->GetLength(&len);
     1:       for (i=0 ; i<len; i++)
     1:       {
     1:         nsCOMPtr<nsIDOMNode> child;
     1:         res = nodeList->Item((PRInt32)i, getter_AddRefs(child));
     1:         if ((NS_SUCCEEDED(res)) && (child))
     1:         {
     1:           if (IsEditable(child))
     1:           {
     1:             outCount++;
     1:           }
     1:         }
     1:       }
     1:     }
     1:     else if (!nodeList)
     1:       res = NS_ERROR_NULL_POINTER;
     1:   }
     1:   return res;
     1: }
     1: 
     1: //END nsEditor static utility methods
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::IncrementModificationCount(PRInt32 inNumMods)
     1: {
     1:   PRUint32 oldModCount = mModCount;
     1: 
     1:   mModCount += inNumMods;
     1: 
     1:   if ((oldModCount == 0 && mModCount != 0)
     1:    || (oldModCount != 0 && mModCount == 0))
     1:     NotifyDocumentListeners(eDocumentStateChanged);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::GetModificationCount(PRInt32 *outModCount)
     1: {
     1:   NS_ENSURE_ARG_POINTER(outModCount);
     1:   *outModCount = mModCount;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::ResetModificationCount()
     1: {
 79445:   bool doNotify = (mModCount != 0);
     1: 
     1:   mModCount = 0;
     1: 
     1:   if (doNotify)
     1:     NotifyDocumentListeners(eDocumentStateChanged);
     1:   return NS_OK;
     1: }
     1: 
     1: //END nsEditor Private methods
     1: 
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetTag: digs out the atom for the tag of this node
     1: //
     1: nsIAtom *
     1: nsEditor::GetTag(nsIDOMNode *aNode)
     1: {
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
     1: 
     1:   if (!content) 
     1:   {
     1:     NS_ASSERTION(aNode, "null node passed to nsEditor::Tag()");
     1: 
     1:     return nsnull;
     1:   }
     1:   
     1:   return content->Tag();
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetTagString: digs out string for the tag of this node
     1: //                    
     1: nsresult 
     1: nsEditor::GetTagString(nsIDOMNode *aNode, nsAString& outString)
     1: {
     1:   if (!aNode) 
     1:   {
     1:     NS_NOTREACHED("null node passed to nsEditor::GetTag()");
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1:   
     1:   nsIAtom *atom = GetTag(aNode);
     1:   if (!atom)
     1:   {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   atom->ToString(outString);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // NodesSameType: do these nodes have the same tag?
     1: //                    
 79445: bool 
     1: nsEditor::NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2)
     1: {
 98809:   if (!aNode1 || !aNode2) {
     1:     NS_NOTREACHED("null node passed to nsEditor::NodesSameType()");
 80486:     return false;
     1:   }
     1: 
 98809:   nsCOMPtr<nsIContent> content1 = do_QueryInterface(aNode1);
 98809:   NS_ENSURE_TRUE(content1, false);
 98809: 
 98809:   nsCOMPtr<nsIContent> content2 = do_QueryInterface(aNode2);
 98809:   NS_ENSURE_TRUE(content2, false);
 98809: 
 98809:   return AreNodesSameType(content1, content2);
 98809: }
 98809: 
 98809: /* virtual */
 98809: bool
 98809: nsEditor::AreNodesSameType(nsIContent* aNode1, nsIContent* aNode2)
 98809: {
 98809:   MOZ_ASSERT(aNode1);
 98809:   MOZ_ASSERT(aNode2);
 98809:   return aNode1->Tag() == aNode2->Tag();
     1: }
     1: 
     1: 
     1: // IsTextOrElementNode: true if node of dom type element or text
     1: //               
 79445: bool
     1: nsEditor::IsTextOrElementNode(nsIDOMNode *aNode)
     1: {
     1:   if (!aNode)
     1:   {
     1:     NS_NOTREACHED("null node passed to IsTextOrElementNode()");
 80486:     return false;
     1:   }
     1:   
     1:   PRUint16 nodeType;
     1:   aNode->GetNodeType(&nodeType);
     1:   return ((nodeType == nsIDOMNode::ELEMENT_NODE) || (nodeType == nsIDOMNode::TEXT_NODE));
     1: }
     1: 
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsTextNode: true if node of dom type text
     1: //               
 79445: bool
     1: nsEditor::IsTextNode(nsIDOMNode *aNode)
     1: {
     1:   if (!aNode)
     1:   {
     1:     NS_NOTREACHED("null node passed to IsTextNode()");
 80486:     return false;
     1:   }
     1:   
     1:   PRUint16 nodeType;
     1:   aNode->GetNodeType(&nodeType);
     1:   return (nodeType == nsIDOMNode::TEXT_NODE);
     1: }
     1: 
 82861: bool
 82861: nsEditor::IsTextNode(nsINode *aNode)
 82861: {
 82861:   return aNode->NodeType() == nsIDOMNode::TEXT_NODE;
 82861: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetChildAt: returns the node at this position index in the parent
     1: //
     1: nsCOMPtr<nsIDOMNode> 
     1: nsEditor::GetChildAt(nsIDOMNode *aParent, PRInt32 aOffset)
     1: {
     1:   nsCOMPtr<nsIDOMNode> resultNode;
     1:   
     1:   nsCOMPtr<nsIContent> parent = do_QueryInterface(aParent);
     1: 
 43807:   NS_ENSURE_TRUE(parent, resultNode);
     1: 
     1:   resultNode = do_QueryInterface(parent->GetChildAt(aOffset));
     1: 
     1:   return resultNode;
     1: }
     1: 
 73913: ///////////////////////////////////////////////////////////////////////////
 73913: // GetNodeAtRangeOffsetPoint: returns the node at this position in a range,
 73913: // assuming that aParentOrNode is the node itself if it's a text node, or
 73913: // the node's parent otherwise.
 73913: //
 73913: nsCOMPtr<nsIDOMNode>
 73913: nsEditor::GetNodeAtRangeOffsetPoint(nsIDOMNode* aParentOrNode, PRInt32 aOffset)
 73913: {
 73913:   if (IsTextNode(aParentOrNode)) {
 73913:     return aParentOrNode;
 73913:   }
 73913:   return GetChildAt(aParentOrNode, aOffset);
 73913: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetStartNodeAndOffset: returns whatever the start parent & offset is of 
     1: //                        the first range in the selection.
     1: nsresult 
     1: nsEditor::GetStartNodeAndOffset(nsISelection *aSelection,
 43518:                                        nsIDOMNode **outStartNode,
     1:                                        PRInt32 *outStartOffset)
     1: {
 43807:   NS_ENSURE_TRUE(outStartNode && outStartOffset && aSelection, NS_ERROR_NULL_POINTER);
     1: 
 43518:   *outStartNode = nsnull;
 62307:   *outStartOffset = 0;
     1: 
     1:   nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
     1:   nsCOMPtr<nsIEnumerator> enumerator;
     1:   nsresult result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
 43893:   NS_ENSURE_SUCCESS(result, result);
 43893:   NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
     1: 
     1:   enumerator->First(); 
     1:   nsCOMPtr<nsISupports> currentItem;
 43893:   result = enumerator->CurrentItem(getter_AddRefs(currentItem));
 43893:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
 43807:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     1: 
 43893:   result = range->GetStartContainer(outStartNode);
 43893:   NS_ENSURE_SUCCESS(result, result);
 43893: 
 43893:   result = range->GetStartOffset(outStartOffset);
 43893:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetEndNodeAndOffset: returns whatever the end parent & offset is of 
     1: //                        the first range in the selection.
     1: nsresult 
     1: nsEditor::GetEndNodeAndOffset(nsISelection *aSelection,
 43518:                                        nsIDOMNode **outEndNode,
     1:                                        PRInt32 *outEndOffset)
     1: {
 43807:   NS_ENSURE_TRUE(outEndNode && outEndOffset, NS_ERROR_NULL_POINTER);
     1: 
 43518:   *outEndNode = nsnull;
 43518:     
     1:   nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
     1:   nsCOMPtr<nsIEnumerator> enumerator;
     1:   nsresult result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
     1:   if (NS_FAILED(result) || !enumerator)
     1:     return NS_ERROR_FAILURE;
     1:     
     1:   enumerator->First(); 
     1:   nsCOMPtr<nsISupports> currentItem;
     1:   if (NS_FAILED(enumerator->CurrentItem(getter_AddRefs(currentItem))))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
 43807:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     1:     
 43518:   if (NS_FAILED(range->GetEndContainer(outEndNode)))
     1:     return NS_ERROR_FAILURE;
     1:     
     1:   if (NS_FAILED(range->GetEndOffset(outEndOffset)))
     1:     return NS_ERROR_FAILURE;
     1:     
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsPreformatted: checks the style info for the node for the preformatted
     1: //                 text style.
     1: nsresult 
 79445: nsEditor::IsPreformatted(nsIDOMNode *aNode, bool *aResult)
     1: {
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
     1:   
 43806:   NS_ENSURE_TRUE(aResult && content, NS_ERROR_NULL_POINTER);
     1:   
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
     1: 
 52224:   // Look at the node (and its parent if it's not an element), and grab its style context
 42574:   nsRefPtr<nsStyleContext> elementStyle;
 52224:   if (!content->IsElement()) {
 52224:     content = content->GetParent();
 52224:   }
 52224:   if (content && content->IsElement()) {
 42574:     elementStyle = nsComputedDOMStyle::GetStyleContextForElement(content->AsElement(),
 42574:                                                                  nsnull,
 42574:                                                                  ps);
 42574:   }
 42574: 
 42574:   if (!elementStyle)
     1:   {
     1:     // Consider nodes without a style context to be NOT preformatted:
     1:     // For instance, this is true of JS tags inside the body (which show
     1:     // up as #text nodes but have no style context).
 80486:     *aResult = false;
     1:     return NS_OK;
     1:   }
     1: 
 42574:   const nsStyleText* styleText = elementStyle->GetStyleText();
     1: 
 11894:   *aResult = styleText->WhiteSpaceIsSignificant();
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // SplitNodeDeep: this splits a node "deeply", splitting children as 
     1: //                appropriate.  The place to split is represented by
     1: //                a dom point at {splitPointParent, splitPointOffset}.
     1: //                That dom point must be inside aNode, which is the node to 
     1: //                split.  outOffset is set to the offset in the parent of aNode where
     1: //                the split terminates - where you would want to insert 
     1: //                a new element, for instance, if that's why you were splitting 
     1: //                the node.
     1: //
     1: nsresult
     1: nsEditor::SplitNodeDeep(nsIDOMNode *aNode, 
     1:                         nsIDOMNode *aSplitPointParent, 
     1:                         PRInt32 aSplitPointOffset,
     1:                         PRInt32 *outOffset,
 79445:                         bool    aNoEmptyContainers,
     1:                         nsCOMPtr<nsIDOMNode> *outLeftNode,
     1:                         nsCOMPtr<nsIDOMNode> *outRightNode)
     1: {
 98821:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 98821:   NS_ENSURE_TRUE(node && aSplitPointParent && outOffset, NS_ERROR_NULL_POINTER);
     1:   PRInt32 offset = aSplitPointOffset;
     1: 
     1:   if (outLeftNode)  *outLeftNode  = nsnull;
     1:   if (outRightNode) *outRightNode = nsnull;
     1: 
 98821:   nsCOMPtr<nsINode> nodeToSplit = do_QueryInterface(aSplitPointParent);
 98821:   while (nodeToSplit) {
     1:     // need to insert rules code call here to do things like
     1:     // not split a list if you are after the last <li> or before the first, etc.
     1:     // for now we just have some smarts about unneccessarily splitting
     1:     // textnodes, which should be universal enough to put straight in
     1:     // this nsEditor routine.
     1:     
     1:     nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(nodeToSplit);
 98821:     PRUint32 len = nodeToSplit->Length();
 79445:     bool bDoSplit = false;
     1:     
     1:     if (!(aNoEmptyContainers || nodeAsText) || (offset && (offset != (PRInt32)len)))
     1:     {
 80486:       bDoSplit = true;
 98821:       nsCOMPtr<nsIDOMNode> tempNode;
 98821:       nsresult rv = SplitNode(nodeToSplit->AsDOMNode(), offset,
 98821:                               getter_AddRefs(tempNode));
 98821:       NS_ENSURE_SUCCESS(rv, rv);
 98821: 
 98821:       if (outRightNode) {
 98821:         *outRightNode = nodeToSplit->AsDOMNode();
 98821:       }
 98821:       if (outLeftNode) {
 98821:         *outLeftNode = tempNode;
 98821:       }
 98821:     }
 98821: 
 98821:     nsINode* parentNode = nodeToSplit->GetNodeParent();
 43806:     NS_ENSURE_TRUE(parentNode, NS_ERROR_FAILURE);
     1: 
 98821:     if (!bDoSplit && offset) {
 98821:       // must be "end of text node" case, we didn't split it, just move past it
 98821:       offset = parentNode->IndexOf(nodeToSplit) + 1;
 98821:       if (outLeftNode) {
 98821:         *outLeftNode = nodeToSplit->AsDOMNode();
 98821:       }
 98821:     } else {
 98821:       offset = parentNode->IndexOf(nodeToSplit);
 98821:       if (outRightNode) {
 98821:         *outRightNode = nodeToSplit->AsDOMNode();
 98821:       }
 98821:     }
 98821: 
 98821:     if (nodeToSplit == node) {
 98821:       // we split all the way up to (and including) aNode; we're done
     1:       break;
 98821:     }
     1: 
     1:     nodeToSplit = parentNode;
     1:   }
     1: 
 98821:   if (!nodeToSplit) {
     1:     NS_NOTREACHED("null node obtained in nsEditor::SplitNodeDeep()");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   *outOffset = offset;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // JoinNodeDeep:  this joins two like nodes "deeply", joining children as 
     1: //                appropriate.  
     1: nsresult
     1: nsEditor::JoinNodeDeep(nsIDOMNode *aLeftNode, 
     1:                        nsIDOMNode *aRightNode,
     1:                        nsCOMPtr<nsIDOMNode> *aOutJoinNode, 
     1:                        PRInt32 *outOffset)
     1: {
 43806:   NS_ENSURE_TRUE(aLeftNode && aRightNode && aOutJoinNode && outOffset, NS_ERROR_NULL_POINTER);
     1: 
     1:   // while the rightmost children and their descendants of the left node 
     1:   // match the leftmost children and their descendants of the right node
     1:   // join them up.  Can you say that three times fast?
     1:   
     1:   nsCOMPtr<nsIDOMNode> leftNodeToJoin = do_QueryInterface(aLeftNode);
     1:   nsCOMPtr<nsIDOMNode> rightNodeToJoin = do_QueryInterface(aRightNode);
     1:   nsCOMPtr<nsIDOMNode> parentNode,tmp;
     1:   nsresult res = NS_OK;
     1:   
     1:   rightNodeToJoin->GetParentNode(getter_AddRefs(parentNode));
     1:   
     1:   while (leftNodeToJoin && rightNodeToJoin && parentNode &&
     1:           NodesSameType(leftNodeToJoin, rightNodeToJoin))
     1:   {
     1:     // adjust out params
     1:     PRUint32 length;
     1:     res = GetLengthOfDOMNode(leftNodeToJoin, length);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     
     1:     *aOutJoinNode = rightNodeToJoin;
     1:     *outOffset = length;
     1:     
     1:     // do the join
     1:     res = JoinNodes(leftNodeToJoin, rightNodeToJoin, parentNode);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     
     1:     if (IsTextNode(parentNode)) // we've joined all the way down to text nodes, we're done!
     1:       return NS_OK;
     1: 
     1:     else
     1:     {
     1:       // get new left and right nodes, and begin anew
     1:       parentNode = rightNodeToJoin;
     1:       leftNodeToJoin = GetChildAt(parentNode, length-1);
     1:       rightNodeToJoin = GetChildAt(parentNode, length);
     1: 
     1:       // skip over non-editable nodes
     1:       while (leftNodeToJoin && !IsEditable(leftNodeToJoin))
     1:       {
     1:         leftNodeToJoin->GetPreviousSibling(getter_AddRefs(tmp));
     1:         leftNodeToJoin = tmp;
     1:       }
     1:       if (!leftNodeToJoin) break;
     1:     
     1:       while (rightNodeToJoin && !IsEditable(rightNodeToJoin))
     1:       {
     1:         rightNodeToJoin->GetNextSibling(getter_AddRefs(tmp));
     1:         rightNodeToJoin = tmp;
     1:       }
     1:       if (!rightNodeToJoin) break;
     1:     }
     1:   }
     1:   
     1:   return res;
     1: }
     1: 
     1: nsresult nsEditor::BeginUpdateViewBatch()
     1: {
     1:   NS_PRECONDITION(mUpdateCount >= 0, "bad state");
     1: 
     1: 
     1:   if (0 == mUpdateCount)
     1:   {
     1:     // Turn off selection updates and notifications.
     1: 
     1:     nsCOMPtr<nsISelection> selection;
     1:     GetSelection(getter_AddRefs(selection));
     1: 
     1:     if (selection) 
     1:     {
     1:       nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
     1:       selPrivate->StartBatchChanges();
     1:     }
     1:   }
     1: 
     1:   mUpdateCount++;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult nsEditor::EndUpdateViewBatch()
     1: {
     1:   NS_PRECONDITION(mUpdateCount > 0, "bad state");
     1:   
     1:   if (mUpdateCount <= 0)
     1:   {
     1:     mUpdateCount = 0;
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   mUpdateCount--;
     1: 
     1:   if (0 == mUpdateCount)
     1:   {
     1:     // Hide the caret with an StCaretHider. By the time it goes out
     1:     // of scope and tries to show the caret, reflow and selection changed
     1:     // notifications should've happened so the caret should have enough info
     1:     // to draw at the correct position.
     1: 
 15969:     nsRefPtr<nsCaret> caret;
 70236:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
     1: 
     1:     if (presShell)
 40045:       caret = presShell->GetCaret();
     1: 
     1:     StCaretHider caretHider(caret);
     1: 
     1:     // Turn selection updating and notifications back on.
     1: 
     1:     nsCOMPtr<nsISelection>selection;
     1:     GetSelection(getter_AddRefs(selection));
     1: 
     1:     if (selection) {
     1:       nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
     1:       selPrivate->EndBatchChanges();
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool 
     1: nsEditor::GetShouldTxnSetSelection()
     1: {
     1:   return mShouldTxnSetSelection;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
 98852: nsEditor::DeleteSelectionImpl(EDirection aAction,
 98852:                               EStripWrappers aStripWrappers)
 98852: {
 98852:   MOZ_ASSERT(aStripWrappers == eStrip || aStripWrappers == eNoStrip);
 98852: 
     1:   nsCOMPtr<nsISelection>selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
  3030:   nsRefPtr<EditAggregateTxn> txn;
     1:   nsCOMPtr<nsIDOMNode> deleteNode;
     1:   PRInt32 deleteCharOffset = 0, deleteCharLength = 0;
  3030:   res = CreateTxnForDeleteSelection(aAction, getter_AddRefs(txn),
  3030:                                     getter_AddRefs(deleteNode),
  3030:                                     &deleteCharOffset, &deleteCharLength);
     1:   nsCOMPtr<nsIDOMCharacterData> deleteCharData(do_QueryInterface(deleteNode));
     1: 
     1:   if (NS_SUCCEEDED(res))  
     1:   {
     1:     nsAutoRules beginRulesSniffing(this, kOpDeleteSelection, aAction);
     1:     PRInt32 i;
     1:     // Notify nsIEditActionListener::WillDelete[Selection|Text|Node]
     1:     if (!deleteNode)
     1:       for (i = 0; i < mActionListeners.Count(); i++)
     1:         mActionListeners[i]->WillDeleteSelection(selection);
     1:     else if (deleteCharData)
     1:       for (i = 0; i < mActionListeners.Count(); i++)
     1:         mActionListeners[i]->WillDeleteText(deleteCharData, deleteCharOffset, 1);
     1:     else
     1:       for (i = 0; i < mActionListeners.Count(); i++)
     1:         mActionListeners[i]->WillDeleteNode(deleteNode);
     1: 
     1:     // Delete the specified amount
     1:     res = DoTransaction(txn);  
     1: 
     1:     // Notify nsIEditActionListener::DidDelete[Selection|Text|Node]
     1:     if (!deleteNode)
     1:       for (i = 0; i < mActionListeners.Count(); i++)
     1:         mActionListeners[i]->DidDeleteSelection(selection);
     1:     else if (deleteCharData)
     1:       for (i = 0; i < mActionListeners.Count(); i++)
     1:         mActionListeners[i]->DidDeleteText(deleteCharData, deleteCharOffset, 1, res);
     1:     else
     1:       for (i = 0; i < mActionListeners.Count(); i++)
     1:         mActionListeners[i]->DidDeleteNode(deleteNode, res);
     1:   }
     1: 
     1:   return res;
     1: }
     1: 
     1: // XXX: error handling in this routine needs to be cleaned up!
     1: NS_IMETHODIMP
     1: nsEditor::DeleteSelectionAndCreateNode(const nsAString& aTag,
     1:                                            nsIDOMNode ** aNewNode)
     1: {
     1:   nsCOMPtr<nsIDOMNode> parentSelectedNode;
     1:   PRInt32 offsetOfNewNode;
     1:   nsresult result = DeleteSelectionAndPrepareToCreateNode(parentSelectedNode,
     1:                                                           offsetOfNewNode);
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   nsCOMPtr<nsIDOMNode> newNode;
     1:   result = CreateNode(aTag, parentSelectedNode, offsetOfNewNode,
     1:                       getter_AddRefs(newNode));
     1:   // XXX: ERROR_HANDLING  check result, and make sure aNewNode is set correctly in success/failure cases
     1:   *aNewNode = newNode;
     1:   NS_IF_ADDREF(*aNewNode);
     1: 
     1:   // we want the selection to be just after the new node
     1:   nsCOMPtr<nsISelection> selection;
     1:   result = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(result, result);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:   return selection->Collapse(parentSelectedNode, offsetOfNewNode+1);
     1: }
     1: 
     1: 
     1: /* Non-interface, protected methods */
     1: 
     1: nsresult
     1: nsEditor::GetIMEBufferLength(PRInt32* length)
     1: {
     1:   *length = mIMEBufferLength;
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsEditor::SetIsIMEComposing(){  
     1:   // We set mIsIMEComposing according to mIMETextRangeList.
     1:   nsCOMPtr<nsIPrivateTextRange> rangePtr;
     1:   PRUint16 listlen, type;
     1: 
 80486:   mIsIMEComposing = false;
 20235:   listlen = mIMETextRangeList->GetLength();
     1: 
     1:   for (PRUint16 i = 0; i < listlen; i++)
     1:   {
 20235:       rangePtr = mIMETextRangeList->Item(i);
 20235:       if (!rangePtr) continue;
 20235:       nsresult result = rangePtr->GetRangeType(&type);
     1:       if (NS_FAILED(result)) continue;
     1:       if ( type == nsIPrivateTextRange::TEXTRANGE_RAWINPUT ||
     1:            type == nsIPrivateTextRange::TEXTRANGE_CONVERTEDTEXT ||
     1:            type == nsIPrivateTextRange::TEXTRANGE_SELECTEDRAWTEXT ||
     1:            type == nsIPrivateTextRange::TEXTRANGE_SELECTEDCONVERTEDTEXT )
     1:       {
 80486:         mIsIMEComposing = true;
     1: #ifdef DEBUG_IME
 80486:         printf("nsEditor::mIsIMEComposing = true\n");
     1: #endif
     1:         break;
     1:       }
     1:   }
     1:   return;
     1: }
     1: 
 79445: bool
     1: nsEditor::IsIMEComposing() {
     1:   return mIsIMEComposing;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::DeleteSelectionAndPrepareToCreateNode(nsCOMPtr<nsIDOMNode> &parentSelectedNode, PRInt32& offsetOfNewNode)
     1: {
     1:   nsresult result=NS_ERROR_NOT_INITIALIZED;
     1:   nsCOMPtr<nsISelection> selection;
     1:   result = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(result, result);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
 98815:   if (!selection->Collapsed()) {
 98852:     result = DeleteSelection(nsIEditor::eNone, nsIEditor::eStrip);
     1:     if (NS_FAILED(result)) {
     1:       return result;
     1:     }
     1:     // get the new selection
     1:     result = GetSelection(getter_AddRefs(selection));
     1:     if (NS_FAILED(result)) {
     1:       return result;
     1:     }
 47373: 
 47373:     nsCOMPtr<nsIDOMNode> selectedNode;
 47373:     selection->GetAnchorNode(getter_AddRefs(selectedNode));
     1:     // no selection is ok.
     1:     // if there is a selection, it must be collapsed
 98815:     if (selectedNode && !selection->Collapsed()) {
 47373:       result = selection->CollapseToEnd();
 47373:       NS_ENSURE_SUCCESS(result, result);
 47373:     }
 47373:   }
     1:   // split the selected node
     1:   PRInt32 offsetOfSelectedNode;
     1:   result = selection->GetAnchorNode(getter_AddRefs(parentSelectedNode));
     1:   if (NS_SUCCEEDED(result) && NS_SUCCEEDED(selection->GetAnchorOffset(&offsetOfSelectedNode)) && parentSelectedNode)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> selectedNode;
     1:     PRUint32 selectedNodeContentCount=0;
     1:     nsCOMPtr<nsIDOMCharacterData>selectedParentNodeAsText;
     1:     selectedParentNodeAsText = do_QueryInterface(parentSelectedNode);
     1: 
     1:     offsetOfNewNode = offsetOfSelectedNode;
     1:     
     1:     /* if the selection is a text node, split the text node if necessary
     1:        and compute where to put the new node
     1:     */
     1:     if (selectedParentNodeAsText) 
     1:     { 
     1:       PRInt32 indexOfTextNodeInParent;
     1:       selectedNode = do_QueryInterface(parentSelectedNode);
     1:       selectedNode->GetParentNode(getter_AddRefs(parentSelectedNode));
     1:       selectedParentNodeAsText->GetLength(&selectedNodeContentCount);
     1:       GetChildOffset(selectedNode, parentSelectedNode, indexOfTextNodeInParent);
     1: 
     1:       if ((offsetOfSelectedNode!=0) && (((PRUint32)offsetOfSelectedNode)!=selectedNodeContentCount))
     1:       {
     1:         nsCOMPtr<nsIDOMNode> newSiblingNode;
     1:         result = SplitNode(selectedNode, offsetOfSelectedNode, getter_AddRefs(newSiblingNode));
 90153:         // now get the node's offset in its parent, and insert the new tag there
     1:         if (NS_SUCCEEDED(result)) {
     1:           result = GetChildOffset(selectedNode, parentSelectedNode, offsetOfNewNode);
     1:         }
     1:       }
     1:       else 
     1:       { // determine where to insert the new node
     1:         if (0==offsetOfSelectedNode) {
     1:           offsetOfNewNode = indexOfTextNodeInParent; // insert new node as previous sibling to selection parent
     1:         }
     1:         else {                 // insert new node as last child
     1:           GetChildOffset(selectedNode, parentSelectedNode, offsetOfNewNode);
     1:           offsetOfNewNode++;    // offsets are 0-based, and we need the index of the new node
     1:         }
     1:       }
     1:     }
     1:     // Here's where the new node was inserted
     1:   }
     1: #ifdef DEBUG
     1:   else {
     1:     printf("InsertLineBreak into an empty document is not yet supported\n");
     1:   }
     1: #endif
     1:   return result;
     1: }
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::DoAfterDoTransaction(nsITransaction *aTxn)
     1: {
     1:   nsresult rv = NS_OK;
     1:   
 79445:   bool    isTransientTransaction;
     1:   rv = aTxn->GetIsTransient(&isTransientTransaction);
 43808:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
     1:   if (!isTransientTransaction)
     1:   {
     1:     // we need to deal here with the case where the user saved after some
     1:     // edits, then undid one or more times. Then, the undo count is -ve,
     1:     // but we can't let a do take it back to zero. So we flip it up to
     1:     // a +ve number.
     1:     PRInt32 modCount;
     1:     GetModificationCount(&modCount);
     1:     if (modCount < 0)
     1:       modCount = -modCount;
     1:         
     1:     rv = IncrementModificationCount(1);    // don't count transient transactions
     1:   }
     1:   
     1:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::DoAfterUndoTransaction()
     1: {
     1:   nsresult rv = NS_OK;
     1: 
     1:   rv = IncrementModificationCount(-1);    // all undoable transactions are non-transient
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::DoAfterRedoTransaction()
     1: {
     1:   return IncrementModificationCount(1);    // all redoable transactions are non-transient
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::CreateTxnForSetAttribute(nsIDOMElement *aElement, 
     1:                                    const nsAString& aAttribute, 
     1:                                    const nsAString& aValue,
     1:                                    ChangeAttributeTxn ** aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
 27825: 
 62873:   nsRefPtr<ChangeAttributeTxn> txn = new ChangeAttributeTxn();
 62873: 
 80486:   nsresult rv = txn->Init(this, aElement, aAttribute, aValue, false);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::CreateTxnForRemoveAttribute(nsIDOMElement *aElement, 
     1:                                       const nsAString& aAttribute,
     1:                                       ChangeAttributeTxn ** aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
 27825: 
 62873:   nsRefPtr<ChangeAttributeTxn> txn = new ChangeAttributeTxn();
 62873: 
 80486:   nsresult rv = txn->Init(this, aElement, aAttribute, EmptyString(), true);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForCreateElement(const nsAString& aTag,
     1:                                                   nsIDOMNode     *aParent,
     1:                                                   PRInt32         aPosition,
     1:                                                   CreateElementTxn ** aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aParent, NS_ERROR_NULL_POINTER);
 27825: 
 62873:   nsRefPtr<CreateElementTxn> txn = new CreateElementTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aTag, aParent, aPosition);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForInsertElement(nsIDOMNode * aNode,
     1:                                                   nsIDOMNode * aParent,
     1:                                                   PRInt32      aPosition,
     1:                                                   InsertElementTxn ** aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aNode && aParent, NS_ERROR_NULL_POINTER);
 27825: 
 62873:   nsRefPtr<InsertElementTxn> txn = new InsertElementTxn();
 62873: 
 62873:   nsresult rv = txn->Init(aNode, aParent, aPosition, this);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP nsEditor::CreateTxnForDeleteElement(nsIDOMNode * aElement,
     1:                                              DeleteElementTxn ** aTxn)
     1: {
 43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
 27825: 
 62873:   nsRefPtr<DeleteElementTxn> txn = new DeleteElementTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aElement, &mRangeUpdater);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsEditor::CreateTxnForIMEText(const nsAString& aStringToInsert,
     1:                               IMETextTxn ** aTxn)
     1: {
     1:   NS_ASSERTION(aTxn, "illegal value- null ptr- aTxn");
 27825:      
 62873:   nsRefPtr<IMETextTxn> txn = new IMETextTxn();
 62873: 
 62873:   nsresult rv = txn->Init(mIMETextNode, mIMETextOffset, mIMEBufferLength,
 63588:                           mIMETextRangeList, aStringToInsert, this);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
 42163: nsEditor::CreateTxnForAddStyleSheet(nsCSSStyleSheet* aSheet, AddStyleSheetTxn* *aTxn)
     1: {
 62873:   nsRefPtr<AddStyleSheetTxn> txn = new AddStyleSheetTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aSheet);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP 
 42163: nsEditor::CreateTxnForRemoveStyleSheet(nsCSSStyleSheet* aSheet, RemoveStyleSheetTxn* *aTxn)
     1: {
 62873:   nsRefPtr<RemoveStyleSheetTxn> txn = new RemoveStyleSheetTxn();
 62873: 
 62873:   nsresult rv = txn->Init(this, aSheet);
 62873:   if (NS_SUCCEEDED(rv))
 62873:   {
 63026:     txn.forget(aTxn);
 62873:   }
 62873: 
 62873:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsEditor::CreateTxnForDeleteSelection(nsIEditor::EDirection aAction,
     1:                                       EditAggregateTxn ** aTxn,
     1:                                       nsIDOMNode ** aNode,
     1:                                       PRInt32 *aOffset,
     1:                                       PRInt32 *aLength)
     1: {
 43807:   NS_ENSURE_TRUE(aTxn, NS_ERROR_NULL_POINTER);
     1:   *aTxn = nsnull;
     1: 
 62873:   nsRefPtr<EditAggregateTxn> aggTxn;
 63588:   nsCOMPtr<nsISelectionController> selCon;
 63588:   GetSelectionController(getter_AddRefs(selCon));
 43806:   NS_ENSURE_TRUE(selCon, NS_ERROR_NOT_INITIALIZED);
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
     1:                                          getter_AddRefs(selection));
     1:   if ((NS_SUCCEEDED(result)) && selection)
     1:   {
     1:     // Check whether the selection is collapsed and we should do nothing:
 98815:     if (selection->Collapsed() && aAction == eNone)
     1:       return NS_OK;
     1: 
     1:     // allocate the out-param transaction
 62873:     aggTxn = new EditAggregateTxn();
     1: 
     1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
     1:     nsCOMPtr<nsIEnumerator> enumerator;
     1:     result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
     1:     if (NS_SUCCEEDED(result) && enumerator)
     1:     {
     1:       for (enumerator->First(); NS_OK!=enumerator->IsDone(); enumerator->Next())
     1:       {
     1:         nsCOMPtr<nsISupports> currentItem;
     1:         result = enumerator->CurrentItem(getter_AddRefs(currentItem));
     1:         if ((NS_SUCCEEDED(result)) && (currentItem))
     1:         {
     1:           nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
 98815:           bool isCollapsed;
     1:           range->GetCollapsed(&isCollapsed);
     1:           if (!isCollapsed)
     1:           {
 27825:             nsRefPtr<DeleteRangeTxn> txn = new DeleteRangeTxn();
 27825:             if (txn)
     1:             {
     1:               txn->Init(this, range, &mRangeUpdater);
 62873:               aggTxn->AppendChild(txn);
     1:             }
     1:             else
     1:               result = NS_ERROR_OUT_OF_MEMORY;
     1:           }
  5270:           // Same with range as with selection; if it is collapsed and action
  5270:           // is eNone, do nothing.
  5270:           else if (aAction != eNone)
     1:           { // we have an insertion point.  delete the thing in front of it or behind it, depending on aAction
 62873:             result = CreateTxnForDeleteInsertionPoint(range, aAction, aggTxn, aNode, aOffset, aLength);
 62873:           }
 62873:         }
 62873:       }
 62873:     }
 62873:   }
 62873: 
 62873:   // Only set the outparam if building the txn was a success, otherwise
 62873:   // we let the aggregation txn be destroyed when the refptr goes out of scope
 62873:   if (NS_SUCCEEDED(result))
 62873:   {
 63026:     aggTxn.forget(aTxn);
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: nsresult
     1: nsEditor::CreateTxnForDeleteCharacter(nsIDOMCharacterData  *aData,
     1:                                       PRUint32              aOffset,
     1:                                       nsIEditor::EDirection aDirection,
     1:                                       DeleteTextTxn       **aTxn)
     1: {
     1:   NS_ASSERTION(aDirection == eNext || aDirection == ePrevious,
     1:                "invalid direction");
     1:   nsAutoString data;
     1:   aData->GetData(data);
 67584:   PRUint32 segOffset = aOffset, segLength = 1;
     1:   if (aDirection == eNext) {
 43804:     if (segOffset + 1 < data.Length() &&
 43804:         NS_IS_HIGH_SURROGATE(data[segOffset]) &&
     1:         NS_IS_LOW_SURROGATE(data[segOffset+1])) {
     1:       // delete both halves of the surrogate pair
     1:       ++segLength;
     1:     }
 67584:   } else if (aOffset > 0) {
 67584:     --segOffset;
 63594:     if (segOffset > 0 &&
 43804:       NS_IS_LOW_SURROGATE(data[segOffset]) &&
     1:       NS_IS_HIGH_SURROGATE(data[segOffset-1])) {
     1:       ++segLength;
     1:       --segOffset;
     1:     }
 67584:   } else {
 67584:     return NS_ERROR_FAILURE;
     1:   }
     1:   return CreateTxnForDeleteText(aData, segOffset, segLength, aTxn);
     1: }
     1: 
     1: //XXX: currently, this doesn't handle edge conditions because GetNext/GetPrior are not implemented
     1: NS_IMETHODIMP
     1: nsEditor::CreateTxnForDeleteInsertionPoint(nsIDOMRange          *aRange, 
     1:                                            nsIEditor::EDirection aAction,
     1:                                            EditAggregateTxn     *aTxn,
     1:                                            nsIDOMNode          **aNode,
     1:                                            PRInt32              *aOffset,
     1:                                            PRInt32              *aLength)
     1: {
 67584:   NS_ASSERTION(aAction != eNone, "invalid action");
     1: 
     1:   // get the node and offset of the insertion point
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   nsresult result = aRange->GetStartContainer(getter_AddRefs(node));
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   PRInt32 offset;
     1:   result = aRange->GetStartOffset(&offset);
 43808:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // determine if the insertion point is at the beginning, middle, or end of the node
     1:   nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(node);
 98827:   nsCOMPtr<nsINode> inode = do_QueryInterface(node);
 98827:   MOZ_ASSERT(inode);
 98827: 
 98827:   PRUint32 count = inode->Length();
     1: 
 79445:   bool isFirst = (0 == offset);
 79445:   bool isLast  = (count == (PRUint32)offset);
     1: 
     1:   // XXX: if isFirst && isLast, then we'll need to delete the node 
     1:   //      as well as the 1 child
     1: 
     1:   // build a transaction for deleting the appropriate data
     1:   // XXX: this has to come from rule section
 80486:   if ((ePrevious==aAction) && (true==isFirst))
     1:   { // we're backspacing from the beginning of the node.  Delete the first thing to our left
     1:     nsCOMPtr<nsIDOMNode> priorNode;
 80486:     result = GetPriorNode(node, true, address_of(priorNode));
     1:     if ((NS_SUCCEEDED(result)) && priorNode)
 90153:     { // there is a priorNode, so delete its last child (if text content, delete the last char.)
     1:       // if it has no children, delete it
     1:       nsCOMPtr<nsIDOMCharacterData> priorNodeAsText = do_QueryInterface(priorNode);
     1:       if (priorNodeAsText)
     1:       {
     1:         PRUint32 length=0;
     1:         priorNodeAsText->GetLength(&length);
     1:         if (0<length)
     1:         {
 63027:           nsRefPtr<DeleteTextTxn> txn;
     1:           result = CreateTxnForDeleteCharacter(priorNodeAsText, length,
 63027:                                                ePrevious, getter_AddRefs(txn));
     1:           if (NS_SUCCEEDED(result)) {
     1:             aTxn->AppendChild(txn);
     1:             NS_ADDREF(*aNode = priorNode);
     1:             *aOffset = txn->GetOffset();
     1:             *aLength = txn->GetNumCharsToDelete();
     1:           }
     1:         }
     1:         else
     1:         { // XXX: can you have an empty text node?  If so, what do you do?
     1:           printf("ERROR: found a text node with 0 characters\n");
     1:           result = NS_ERROR_UNEXPECTED;
     1:         }
     1:       }
     1:       else
     1:       { // priorNode is not text, so tell it's parent to delete it
 63027:         nsRefPtr<DeleteElementTxn> txn;
 63027:         result = CreateTxnForDeleteElement(priorNode, getter_AddRefs(txn));
     1:         if (NS_SUCCEEDED(result)) {
     1:           aTxn->AppendChild(txn);
     1:           NS_ADDREF(*aNode = priorNode);
     1:         }
     1:       }
     1:     }
     1:   }
 80486:   else if ((nsIEditor::eNext==aAction) && (true==isLast))
     1:   { // we're deleting from the end of the node.  Delete the first thing to our right
     1:     nsCOMPtr<nsIDOMNode> nextNode;
 80486:     result = GetNextNode(node, true, address_of(nextNode));
     1:     if ((NS_SUCCEEDED(result)) && nextNode)
     1:     { // there is a nextNode, so delete it's first child (if text content, delete the first char.)
     1:       // if it has no children, delete it
     1:       nsCOMPtr<nsIDOMCharacterData> nextNodeAsText = do_QueryInterface(nextNode);
     1:       if (nextNodeAsText)
     1:       {
     1:         PRUint32 length=0;
     1:         nextNodeAsText->GetLength(&length);
     1:         if (0<length)
     1:         {
 63027:           nsRefPtr<DeleteTextTxn> txn;
 63027:           result = CreateTxnForDeleteCharacter(nextNodeAsText, 0, eNext,
 63027:                                                getter_AddRefs(txn));
     1:           if (NS_SUCCEEDED(result)) {
     1:             aTxn->AppendChild(txn);
     1:             NS_ADDREF(*aNode = nextNode);
     1:             *aOffset = txn->GetOffset();
     1:             *aLength = txn->GetNumCharsToDelete();
     1:           }
     1:         }
     1:         else
     1:         { // XXX: can you have an empty text node?  If so, what do you do?
     1:           printf("ERROR: found a text node with 0 characters\n");
     1:           result = NS_ERROR_UNEXPECTED;
     1:         }
     1:       }
     1:       else
 90153:       { // nextNode is not text, so tell its parent to delete it
 63027:         nsRefPtr<DeleteElementTxn> txn;
 63027:         result = CreateTxnForDeleteElement(nextNode, getter_AddRefs(txn));
     1:         if (NS_SUCCEEDED(result)) {
     1:           aTxn->AppendChild(txn);
     1:           NS_ADDREF(*aNode = nextNode);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   else
     1:   {
     1:     if (nodeAsText)
     1:     { // we have text, so delete a char at the proper offset
  5270:       nsRefPtr<DeleteTextTxn> txn;
  5270:       result = CreateTxnForDeleteCharacter(nodeAsText, offset, aAction,
  5270:                                            getter_AddRefs(txn));
     1:       if (NS_SUCCEEDED(result)) {
     1:         aTxn->AppendChild(txn);
     1:         NS_ADDREF(*aNode = node);
     1:         *aOffset = txn->GetOffset();
     1:         *aLength = txn->GetNumCharsToDelete();
     1:       }
     1:     }
     1:     else
     1:     { // we're either deleting a node or some text, need to dig into the next/prev node to find out
     1:       nsCOMPtr<nsIDOMNode> selectedNode;
     1:       if (ePrevious==aAction)
     1:       {
 80486:         result = GetPriorNode(node, offset, true, address_of(selectedNode));
     1:       }
     1:       else if (eNext==aAction)
     1:       {
 80486:         result = GetNextNode(node, offset, true, address_of(selectedNode));
     1:       }
     1:       if (NS_FAILED(result)) { return result; }
     1:       if (selectedNode) 
     1:       {
     1:         nsCOMPtr<nsIDOMCharacterData> selectedNodeAsText =
     1:                                              do_QueryInterface(selectedNode);
     1:         if (selectedNodeAsText)
     1:         { // we are deleting from a text node, so do a text deletion
     1:           PRUint32 position = 0;    // default for forward delete
     1:           if (ePrevious==aAction)
     1:           {
     1:             selectedNodeAsText->GetLength(&position);
     1:           }
  5270:           nsRefPtr<DeleteTextTxn> delTextTxn;
     1:           result = CreateTxnForDeleteCharacter(selectedNodeAsText, position,
  5270:                                                aAction,
  5270:                                                getter_AddRefs(delTextTxn));
     1:           if (NS_FAILED(result))  { return result; }
     1:           if (!delTextTxn) { return NS_ERROR_NULL_POINTER; }
     1:           aTxn->AppendChild(delTextTxn);
     1:           NS_ADDREF(*aNode = selectedNode);
     1:           *aOffset = delTextTxn->GetOffset();
     1:           *aLength = delTextTxn->GetNumCharsToDelete();
     1:         }
     1:         else
     1:         {
  5270:           nsRefPtr<DeleteElementTxn> delElementTxn;
  5270:           result = CreateTxnForDeleteElement(selectedNode,
  5270:                                              getter_AddRefs(delElementTxn));
     1:           if (NS_FAILED(result))  { return result; }
     1:           if (!delElementTxn) { return NS_ERROR_NULL_POINTER; }
     1:           aTxn->AppendChild(delElementTxn);
     1:           NS_ADDREF(*aNode = selectedNode);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: nsresult 
     1: nsEditor::CreateRange(nsIDOMNode *aStartParent, PRInt32 aStartOffset,
     1:                       nsIDOMNode *aEndParent, PRInt32 aEndOffset,
     1:                       nsIDOMRange **aRange)
     1: {
 87303:   return nsRange::CreateRange(aStartParent, aStartOffset, aEndParent,
 87303:                               aEndOffset, aRange);
     1: }
     1: 
     1: nsresult 
     1: nsEditor::AppendNodeToSelectionAsRange(nsIDOMNode *aNode)
     1: {
 43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if(!selection) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMNode> parentNode;
     1:   res = aNode->GetParentNode(getter_AddRefs(parentNode));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(parentNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   PRInt32 offset;
     1:   res = GetChildOffset(aNode, parentNode, offset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = CreateRange(parentNode, offset, parentNode, offset+1, getter_AddRefs(range));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(range, NS_ERROR_NULL_POINTER);
     1: 
     1:   return selection->AddRange(range);
     1: }
     1: 
     1: nsresult nsEditor::ClearSelection()
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = nsEditor::GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1:   return selection->RemoveAllRanges();  
     1: }
     1: 
     1: nsresult
     1: nsEditor::CreateHTMLContent(const nsAString& aTag, nsIContent** aContent)
     1: {
 93880:   nsCOMPtr<nsIDocument> doc = GetDocument();
 43807:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
     1: 
     1:   // XXX Wallpaper over editor bug (editor tries to create elements with an
     1:   //     empty nodename).
     1:   if (aTag.IsEmpty()) {
     1:     NS_ERROR("Don't pass an empty tag to nsEditor::CreateHTMLContent, "
     1:              "check caller.");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 81061:   return doc->CreateElem(aTag, nsnull, kNameSpaceID_XHTML, aContent);
     1: }
     1: 
     1: nsresult
     1: nsEditor::SetAttributeOrEquivalent(nsIDOMElement * aElement,
     1:                                    const nsAString & aAttribute,
     1:                                    const nsAString & aValue,
 79445:                                    bool aSuppressTransaction)
     1: {
     1:   return SetAttribute(aElement, aAttribute, aValue);
     1: }
     1: 
     1: nsresult
     1: nsEditor::RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
     1:                                       const nsAString & aAttribute,
 79445:                                       bool aSuppressTransaction)
     1: {
     1:   return RemoveAttribute(aElement, aAttribute);
     1: }
     1: 
     1: nsresult
 43438: nsEditor::HandleKeyPressEvent(nsIDOMKeyEvent* aKeyEvent)
 43438: {
 43438:   // NOTE: When you change this method, you should also change:
 43438:   //   * editor/libeditor/text/tests/test_texteditor_keyevent_handling.html
 43438:   //   * editor/libeditor/html/tests/test_htmleditor_keyevent_handling.html
 43438:   //
 43438:   // And also when you add new key handling, you need to change the subclass's
 43438:   // HandleKeyPressEvent()'s switch statement.
 43438: 
 43438:   nsKeyEvent* nativeKeyEvent = GetNativeKeyEvent(aKeyEvent);
 43438:   NS_ENSURE_TRUE(nativeKeyEvent, NS_ERROR_UNEXPECTED);
 43438:   NS_ASSERTION(nativeKeyEvent->message == NS_KEY_PRESS,
 43438:                "HandleKeyPressEvent gets non-keypress event");
 43438: 
 43438:   // if we are readonly or disabled, then do nothing.
 43438:   if (IsReadonly() || IsDisabled()) {
 43438:     // consume backspace for disabled and readonly textfields, to prevent
 43438:     // back in history, which could be confusing to users
 43438:     if (nativeKeyEvent->keyCode == nsIDOMKeyEvent::DOM_VK_BACK_SPACE) {
 43438:       aKeyEvent->PreventDefault();
 43438:     }
 43438:     return NS_OK;
 43438:   }
 43438: 
 43438:   switch (nativeKeyEvent->keyCode) {
 43438:     case nsIDOMKeyEvent::DOM_VK_META:
 43438:     case nsIDOMKeyEvent::DOM_VK_SHIFT:
 43438:     case nsIDOMKeyEvent::DOM_VK_CONTROL:
 43438:     case nsIDOMKeyEvent::DOM_VK_ALT:
 43438:       aKeyEvent->PreventDefault(); // consumed
 43438:       return NS_OK;
 43438:     case nsIDOMKeyEvent::DOM_VK_BACK_SPACE:
 96893:       if (nativeKeyEvent->IsControl() || nativeKeyEvent->IsAlt() ||
 96893:           nativeKeyEvent->IsMeta()) {
 43438:         return NS_OK;
 43438:       }
 98852:       DeleteSelection(nsIEditor::ePrevious, nsIEditor::eStrip);
 43438:       aKeyEvent->PreventDefault(); // consumed
 43438:       return NS_OK;
 43438:     case nsIDOMKeyEvent::DOM_VK_DELETE:
 43438:       // on certain platforms (such as windows) the shift key
 43438:       // modifies what delete does (cmd_cut in this case).
 43438:       // bailing here to allow the keybindings to do the cut.
 96893:       if (nativeKeyEvent->IsShift() || nativeKeyEvent->IsControl() ||
 96893:           nativeKeyEvent->IsAlt() || nativeKeyEvent->IsMeta()) {
 43438:         return NS_OK;
 43438:       }
 98852:       DeleteSelection(nsIEditor::eNext, nsIEditor::eStrip);
 43438:       aKeyEvent->PreventDefault(); // consumed
 43438:       return NS_OK; 
 43438:   }
 43438:   return NS_OK;
 43438: }
 43438: 
 43438: nsresult
 97808: nsEditor::HandleInlineSpellCheck(OperationID action,
     1:                                    nsISelection *aSelection,
     1:                                    nsIDOMNode *previousSelectedNode,
     1:                                    PRInt32 previousSelectedOffset,
     1:                                    nsIDOMNode *aStartNode,
     1:                                    PRInt32 aStartOffset,
     1:                                    nsIDOMNode *aEndNode,
     1:                                    PRInt32 aEndOffset)
     1: {
     1:   return mInlineSpellChecker ? mInlineSpellChecker->SpellCheckAfterEditorChange(action,
     1:                                                        aSelection,
     1:                                                        previousSelectedNode,
     1:                                                        previousSelectedOffset,
     1:                                                        aStartNode,
     1:                                                        aStartOffset,
     1:                                                        aEndNode,
     1:                                                        aEndOffset) : NS_OK;
     1: }
     1: 
 43715: already_AddRefed<nsIContent>
 43715: nsEditor::FindSelectionRoot(nsINode *aNode)
 43715: {
 83343:   nsCOMPtr<nsIContent> rootContent = GetRoot();
 43715:   return rootContent.forget();
 43715: }
 43715: 
 43715: nsresult
 43715: nsEditor::InitializeSelection(nsIDOMEventTarget* aFocusEventTarget)
 43715: {
 43715:   nsCOMPtr<nsINode> targetNode = do_QueryInterface(aFocusEventTarget);
 43715:   NS_ENSURE_TRUE(targetNode, NS_ERROR_INVALID_ARG);
 43715:   nsCOMPtr<nsIContent> selectionRootContent = FindSelectionRoot(targetNode);
 43715:   if (!selectionRootContent) {
 43715:     return NS_OK;
 43715:   }
 43715: 
 79445:   bool isTargetDoc =
 89182:     targetNode->NodeType() == nsIDOMNode::DOCUMENT_NODE &&
 43715:     targetNode->HasFlag(NODE_IS_EDITABLE);
 43715: 
 43715:   nsCOMPtr<nsISelection> selection;
 43715:   nsresult rv = GetSelection(getter_AddRefs(selection));
 43715:   NS_ENSURE_SUCCESS(rv, rv);
 43715: 
 70236:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 70236:   NS_ENSURE_TRUE(presShell, NS_ERROR_NOT_INITIALIZED);
 43715: 
 43715:   nsCOMPtr<nsISelectionController> selCon;
 43715:   rv = GetSelectionController(getter_AddRefs(selCon));
 43715:   NS_ENSURE_SUCCESS(rv, rv);
 43715: 
 43715:   nsCOMPtr<nsISelectionPrivate> selectionPrivate =
 43715:     do_QueryInterface(selection);
 43715:   NS_ENSURE_TRUE(selectionPrivate, NS_ERROR_UNEXPECTED);
 43715: 
 43715:   // Init the caret
 43715:   nsRefPtr<nsCaret> caret = presShell->GetCaret();
 43715:   NS_ENSURE_TRUE(caret, NS_ERROR_UNEXPECTED);
 80486:   caret->SetIgnoreUserModify(false);
 43715:   caret->SetCaretDOMSelection(selection);
 43715:   selCon->SetCaretReadOnly(IsReadonly());
 80486:   selCon->SetCaretEnabled(true);
 43715: 
 43715:   // Init selection
 43715:   selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
 82467:   selCon->SetSelectionFlags(nsISelectionDisplay::DISPLAY_ALL);
 43715:   selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
 43715:   // If the computed selection root isn't root content, we should set it
 43715:   // as selection ancestor limit.  However, if that is root element, it means
 43715:   // there is not limitation of the selection, then, we must set NULL.
 43715:   // NOTE: If we set a root element to the ancestor limit, some selection
 43715:   // methods don't work fine.
 43715:   if (selectionRootContent->GetParent()) {
 43715:     selectionPrivate->SetAncestorLimiter(selectionRootContent);
 43715:   } else {
 43715:     selectionPrivate->SetAncestorLimiter(nsnull);
 43715:   }
 43715: 
 43715:   // XXX What case needs this?
 43715:   if (isTargetDoc) {
 43715:     PRInt32 rangeCount;
 43715:     selection->GetRangeCount(&rangeCount);
 43715:     if (rangeCount == 0) {
 43715:       BeginningOfDocument();
 43715:     }
 43715:   }
 43715: 
 43715:   return NS_OK;
 43715: }
 43715: 
 83343: dom::Element *
     1: nsEditor::GetRoot()
     1: {
     1:   if (!mRootElement)
     1:   {
     1:     nsCOMPtr<nsIDOMElement> root;
     1: 
     1:     // Let GetRootElement() do the work
     1:     GetRootElement(getter_AddRefs(root));
     1:   }
     1: 
     1:   return mRootElement;
     1: }
     1: 
 97988: dom::Element*
 97988: nsEditor::GetEditorRoot()
 97988: {
 97988:   return GetRoot();
 97988: }
 97988: 
 78325: nsresult
 78325: nsEditor::DetermineCurrentDirection()
     1: {
     1:   // Get the current root direction from its frame
 83343:   dom::Element *rootElement = GetRoot();
 61556: 
 61556:   // If we don't have an explicit direction, determine our direction
 61556:   // from the content's direction
 61556:   if (!(mFlags & (nsIPlaintextEditor::eEditorLeftToRight |
 61556:                   nsIPlaintextEditor::eEditorRightToLeft))) {
 83343: 
 83343:     nsIFrame* frame = rootElement->GetPrimaryFrame();
 43807:     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
     1: 
 61556:     // Set the flag here, to enable us to use the same code path below.
 61556:     // It will be flipped before returning from the function.
 61556:     if (frame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
 61556:       mFlags |= nsIPlaintextEditor::eEditorRightToLeft;
 61556:     } else {
 61556:       mFlags |= nsIPlaintextEditor::eEditorLeftToRight;
 61556:     }
 61556:   }
 61556: 
 78325:   return NS_OK;
 78325: }
 78325: 
 78325: NS_IMETHODIMP
 78325: nsEditor::SwitchTextDirection()
 78325: {
 78325:   // Get the current root direction from its frame
 83343:   dom::Element *rootElement = GetRoot();
 78325:   nsresult rv = DetermineCurrentDirection();
 78325:   NS_ENSURE_SUCCESS(rv, rv);
 78325: 
     1:   // Apply the opposite direction
 61556:   if (mFlags & nsIPlaintextEditor::eEditorRightToLeft) {
 61556:     NS_ASSERTION(!(mFlags & nsIPlaintextEditor::eEditorLeftToRight),
 61556:                  "Unexpected mutually exclusive flag");
 61556:     mFlags &= ~nsIPlaintextEditor::eEditorRightToLeft;
 61556:     mFlags |= nsIPlaintextEditor::eEditorLeftToRight;
 83343:     rv = rootElement->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, NS_LITERAL_STRING("ltr"), true);
 61556:   } else if (mFlags & nsIPlaintextEditor::eEditorLeftToRight) {
 61556:     NS_ASSERTION(!(mFlags & nsIPlaintextEditor::eEditorRightToLeft),
 61556:                  "Unexpected mutually exclusive flag");
 61556:     mFlags |= nsIPlaintextEditor::eEditorRightToLeft;
 61556:     mFlags &= ~nsIPlaintextEditor::eEditorLeftToRight;
 83343:     rv = rootElement->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, NS_LITERAL_STRING("rtl"), true);
 61556:   }
     1: 
     1:   return rv;
     1: }
     1: 
 78325: void
 78325: nsEditor::SwitchTextDirectionTo(PRUint32 aDirection)
 78325: {
 78325:   // Get the current root direction from its frame
 83343:   dom::Element *rootElement = GetRoot();
 78325:   nsresult rv = DetermineCurrentDirection();
 78325:   NS_ENSURE_SUCCESS(rv, );
 78325: 
 78325:   // Apply the requested direction
 78325:   if (aDirection == nsIPlaintextEditor::eEditorLeftToRight &&
 78325:       (mFlags & nsIPlaintextEditor::eEditorRightToLeft)) {
 78325:     NS_ASSERTION(!(mFlags & nsIPlaintextEditor::eEditorLeftToRight),
 78325:                  "Unexpected mutually exclusive flag");
 78325:     mFlags &= ~nsIPlaintextEditor::eEditorRightToLeft;
 78325:     mFlags |= nsIPlaintextEditor::eEditorLeftToRight;
 83343:     rootElement->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, NS_LITERAL_STRING("ltr"), true);
 78325:   } else if (aDirection == nsIPlaintextEditor::eEditorRightToLeft &&
 78325:              (mFlags & nsIPlaintextEditor::eEditorLeftToRight)) {
 78325:     NS_ASSERTION(!(mFlags & nsIPlaintextEditor::eEditorRightToLeft),
 78325:                  "Unexpected mutually exclusive flag");
 78325:     mFlags |= nsIPlaintextEditor::eEditorRightToLeft;
 78325:     mFlags &= ~nsIPlaintextEditor::eEditorLeftToRight;
 83343:     rootElement->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, NS_LITERAL_STRING("rtl"), true);
 78325:   }
 78325: }
 78325: 
     1: #if DEBUG_JOE
     1: void
     1: nsEditor::DumpNode(nsIDOMNode *aNode, PRInt32 indent)
     1: {
     1:   PRInt32 i;
     1:   for (i=0; i<indent; i++)
     1:     printf("  ");
     1:   
     1:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
     1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag = do_QueryInterface(aNode);
     1:   
     1:   if (element || docfrag)
     1:   { 
     1:     if (element)
     1:     {
     1:       nsAutoString tag;
     1:       element->GetTagName(tag);
     1:       printf("<%s>\n", NS_LossyConvertUTF16toASCII(tag).get());
     1:     }
     1:     else
     1:     {
     1:       printf("<document fragment>\n");
     1:     }
     1:     nsCOMPtr<nsIDOMNodeList> childList;
     1:     aNode->GetChildNodes(getter_AddRefs(childList));
 43806:     NS_ENSURE_TRUE(childList, NS_ERROR_NULL_POINTER);
     1:     PRUint32 numChildren;
     1:     childList->GetLength(&numChildren);
     1:     nsCOMPtr<nsIDOMNode> child, tmp;
     1:     aNode->GetFirstChild(getter_AddRefs(child));
     1:     for (i=0; i<numChildren; i++)
     1:     {
     1:       DumpNode(child, indent+1);
     1:       child->GetNextSibling(getter_AddRefs(tmp));
     1:       child = tmp;
     1:     }
     1:   }
     1:   else if (IsTextNode(aNode))
     1:   {
     1:     nsCOMPtr<nsIDOMCharacterData> textNode = do_QueryInterface(aNode);
     1:     nsAutoString str;
     1:     textNode->GetData(str);
     1:     nsCAutoString cstr;
     1:     LossyCopyUTF16toASCII(str, cstr);
     1:     cstr.ReplaceChar('\n', ' ');
     1:     printf("<textnode> %s\n", cstr.get());
     1:   }
     1: }
     1: #endif
  2896: 
 79445: bool
  2896: nsEditor::IsModifiableNode(nsIDOMNode *aNode)
  2896: {
 80486:   return true;
  2896: }
 41886: 
 82861: bool
 82861: nsEditor::IsModifiableNode(nsINode *aNode)
 82861: {
 82861:   return true;
 82861: }
 82861: 
 43438: nsKeyEvent*
 43438: nsEditor::GetNativeKeyEvent(nsIDOMKeyEvent* aDOMKeyEvent)
 43438: {
 43438:   nsCOMPtr<nsIPrivateDOMEvent> privDOMEvent = do_QueryInterface(aDOMKeyEvent);
 43438:   NS_ENSURE_TRUE(privDOMEvent, nsnull);
 43438:   nsEvent* nativeEvent = privDOMEvent->GetInternalNSEvent();
 43438:   NS_ENSURE_TRUE(nativeEvent, nsnull);
 43438:   NS_ENSURE_TRUE(nativeEvent->eventStructType == NS_KEY_EVENT, nsnull);
 43438:   return static_cast<nsKeyEvent*>(nativeEvent);
 43438: }
 43438: 
 56870: already_AddRefed<nsIContent>
 56870: nsEditor::GetFocusedContent()
 41886: {
 72327:   nsCOMPtr<nsIDOMEventTarget> piTarget = GetDOMEventTarget();
 41886:   if (!piTarget) {
 56870:     return nsnull;
 41886:   }
 41886: 
 41886:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 56870:   NS_ENSURE_TRUE(fm, nsnull);
 41886: 
 41886:   nsCOMPtr<nsIContent> content = fm->GetFocusedContent();
 56870:   return SameCOMIdentity(content, piTarget) ? content.forget() : nsnull;
 41886: }
 48083: 
 79445: bool
 48083: nsEditor::IsActiveInDOMWindow()
 48083: {
 72327:   nsCOMPtr<nsIDOMEventTarget> piTarget = GetDOMEventTarget();
 48083:   if (!piTarget) {
 80486:     return false;
 48083:   }
 48083: 
 48083:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 80486:   NS_ENSURE_TRUE(fm, false);
 48083: 
 48083:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 48083:   nsPIDOMWindow* ourWindow = doc->GetWindow();
 48083:   nsCOMPtr<nsPIDOMWindow> win;
 48083:   nsIContent* content =
 80486:     nsFocusManager::GetFocusedDescendant(ourWindow, false,
 48083:                                          getter_AddRefs(win));
 48083:   return SameCOMIdentity(content, piTarget);
 48083: }
 48083: 
 79445: bool
 48083: nsEditor::IsAcceptableInputEvent(nsIDOMEvent* aEvent)
 48083: {
 48083:   // If the event is trusted, the event should always cause input.
 48083:   nsCOMPtr<nsIDOMNSEvent> NSEvent = do_QueryInterface(aEvent);
 80486:   NS_ENSURE_TRUE(NSEvent, false);
 48083: 
 82789:   // If this is mouse event but this editor doesn't have focus, we shouldn't
 82789:   // handle it.
 82789:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
 82789:   if (mouseEvent) {
 82789:     nsCOMPtr<nsIContent> focusedContent = GetFocusedContent();
 82789:     if (!focusedContent) {
 82789:       return false;
 82789:     }
 82789:   }
 82789: 
 79445:   bool isTrusted;
 48083:   nsresult rv = NSEvent->GetIsTrusted(&isTrusted);
 80486:   NS_ENSURE_SUCCESS(rv, false);
 48083:   if (isTrusted) {
 80486:     return true;
 48083:   }
 82789: 
 82789:   // Ignore untrusted mouse event.
 82789:   // XXX Why are we handling other untrusted input events?
 82789:   if (mouseEvent) {
 82789:     return false;
 82789:   }
 82789: 
 48083:   // Otherwise, we shouldn't handle any input events when we're not an active
 48083:   // element of the DOM window.
 48083:   return IsActiveInDOMWindow();
 48083: }
 59460: 
 75374: void
 75374: nsEditor::OnFocus(nsIDOMEventTarget* aFocusEventTarget)
 75374: {
 75374:   InitializeSelection(aFocusEventTarget);
 75374:   if (mInlineSpellChecker) {
 75374:     mInlineSpellChecker->UpdateCurrentDictionary();
 75374:   }
 75374: }
 94119: 
 94119: NS_IMETHODIMP
 94119: nsEditor::GetSuppressDispatchingInputEvent(bool *aSuppressed)
 94119: {
 94119:   NS_ENSURE_ARG_POINTER(aSuppressed);
 94119:   *aSuppressed = !mDispatchInputEvent;
 94119:   return NS_OK;
 94119: }
 94119: 
 94119: NS_IMETHODIMP
 94119: nsEditor::SetSuppressDispatchingInputEvent(bool aSuppress)
 94119: {
 94119:   mDispatchInputEvent = !aSuppress;
 94119:   return NS_OK;
 94119: }
 94119: 
 94119: nsEditor::HandlingTrustedAction::HandlingTrustedAction(nsEditor* aSelf,
 94119:                                                        nsIDOMNSEvent* aEvent)
 94119: {
 94119:   MOZ_ASSERT(aEvent);
 94119: 
 94119:   bool isTrusted = false;
 94119:   aEvent->GetIsTrusted(&isTrusted);
 94119:   Init(aSelf, isTrusted);
 94119: }
