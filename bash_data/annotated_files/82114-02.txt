29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
80507:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
80507:  * Portions created by the Initial Developer are Copyright (C) 1998-2011
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
80507:  * either the GNU General Public License Version 2 or later (the "GPL"), or
80507:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80507: #ifndef ParseNode_h__
80507: #define ParseNode_h__
80506: 
79734: #include "jsscript.h"
    1: 
80507: #include "frontend/ParseMaps.h"
80506: #include "frontend/TokenStream.h"
    1: 
80631: namespace js {
80631: 
    1: /*
    1:  * Parsing builds a tree of nodes that directs code generation.  This tree is
    1:  * not a concrete syntax tree in all respects (for example, || and && are left
    1:  * associative, but (A && B && C) translates into the right-associated tree
    1:  * <A && <B && C>> so that code generation can emit a left-associative branch
82024:  * around <B && C> when A is false).  Nodes are labeled by kind, with a
82024:  * secondary JSOp label when needed.
    1:  *
82024:  * The long comment after this enum block describes the kinds in detail.
82024:  */
82024: enum ParseNodeKind {
82024:     PNK_SEMI,
82024:     PNK_COMMA,
82024:     PNK_HOOK,
82024:     PNK_COLON,
82024:     PNK_OR,
82024:     PNK_AND,
82024:     PNK_BITOR,
82024:     PNK_BITXOR,
82024:     PNK_BITAND,
82024:     PNK_PLUS,
82024:     PNK_MINUS,
82024:     PNK_STAR,
82024:     PNK_DIV,
82024:     PNK_MOD,
82024:     PNK_INC,
82024:     PNK_DEC,
82024:     PNK_DOT,
82024:     PNK_LB,
82024:     PNK_RB,
82024:     PNK_LC,
82024:     PNK_RC,
82024:     PNK_LP,
82024:     PNK_RP,
82024:     PNK_NAME,
82024:     PNK_NUMBER,
82024:     PNK_STRING,
82024:     PNK_REGEXP,
82024:     PNK_TRUE,
82024:     PNK_FALSE,
82024:     PNK_NULL,
82024:     PNK_THIS,
82024:     PNK_FUNCTION,
82024:     PNK_IF,
82024:     PNK_ELSE,
82024:     PNK_SWITCH,
82024:     PNK_CASE,
82024:     PNK_DEFAULT,
82024:     PNK_WHILE,
82024:     PNK_DO,
82024:     PNK_FOR,
82024:     PNK_BREAK,
82024:     PNK_CONTINUE,
82024:     PNK_IN,
82024:     PNK_VAR,
82024:     PNK_WITH,
82024:     PNK_RETURN,
82024:     PNK_NEW,
82024:     PNK_DELETE,
82024:     PNK_DEFSHARP,
82024:     PNK_USESHARP,
82024:     PNK_TRY,
82024:     PNK_CATCH,
82024:     PNK_CATCHLIST,
82024:     PNK_FINALLY,
82024:     PNK_THROW,
82024:     PNK_INSTANCEOF,
82024:     PNK_DEBUGGER,
82024:     PNK_XMLSTAGO,
82024:     PNK_XMLETAGO,
82024:     PNK_XMLPTAGC,
82024:     PNK_XMLTAGC,
82024:     PNK_XMLNAME,
82024:     PNK_XMLATTR,
82024:     PNK_XMLSPACE,
82024:     PNK_XMLTEXT,
82024:     PNK_XMLCOMMENT,
82024:     PNK_XMLCDATA,
82024:     PNK_XMLPI,
82114:     PNK_XMLUNARY,
82024:     PNK_AT,
82024:     PNK_DBLCOLON,
82024:     PNK_ANYNAME,
82024:     PNK_DBLDOT,
82024:     PNK_FILTER,
82024:     PNK_XMLELEM,
82024:     PNK_XMLLIST,
82024:     PNK_YIELD,
82024:     PNK_ARRAYCOMP,
82024:     PNK_ARRAYPUSH,
82024:     PNK_LEXICALSCOPE,
82024:     PNK_LET,
82024:     PNK_SEQ,
82024:     PNK_FORHEAD,
82024:     PNK_ARGSBODY,
82024:     PNK_UPVARS,
82024: 
82024:     /*
82024:      * The following parse node kinds occupy contiguous ranges to enable easy
82024:      * range-testing.
82024:      */
82024: 
82024:     /* Equality operators. */
82024:     PNK_STRICTEQ,
82024:     PNK_EQ,
82024:     PNK_STRICTNE,
82024:     PNK_NE,
82024: 
82024:     /* Unary operators. */
82024:     PNK_TYPEOF,
82024:     PNK_VOID,
82024:     PNK_NOT,
82024:     PNK_BITNOT,
82024: 
82024:     /* Relational operators (< <= > >=). */
82024:     PNK_LT,
82024:     PNK_LE,
82024:     PNK_GT,
82024:     PNK_GE,
82024: 
82024:     /* Shift operators (<< >> >>>). */
82024:     PNK_LSH,
82024:     PNK_RSH,
82024:     PNK_URSH,
82024: 
82024:     /* Assignment operators (= += -= etc.). */
82024:     PNK_ASSIGN,
82024:     PNK_ASSIGNMENT_START = PNK_ASSIGN,
82024:     PNK_ADDASSIGN,
82024:     PNK_SUBASSIGN,
82024:     PNK_BITORASSIGN,
82024:     PNK_BITXORASSIGN,
82024:     PNK_BITANDASSIGN,
82024:     PNK_LSHASSIGN,
82024:     PNK_RSHASSIGN,
82024:     PNK_URSHASSIGN,
82024:     PNK_MULASSIGN,
82024:     PNK_DIVASSIGN,
82024:     PNK_MODASSIGN,
82024:     PNK_ASSIGNMENT_LAST = PNK_MODASSIGN,
82024: 
82024:     PNK_LIMIT /* domain size */
82024: };
82024: 
82024: /*
    1:  * Label        Variant     Members
    1:  * -----        -------     -------
    1:  * <Definitions>
82024:  * PNK_FUNCTION name        pn_funbox: ptr to js::FunctionBox holding function
 3235:  *                            object containing arg and var properties.  We
 3235:  *                            create the function object at parse (not emit)
 3235:  *                            time to specialize arg and var bytecodes early.
82024:  *                          pn_body: PNK_UPVARS if the function's source body
82024:  *                                   depends on outer names, else PNK_ARGSBODY
82024:  *                                   if formal parameters, else PNK_LC node for
82024:  *                                   function body statements, else PNK_RETURN
82024:  *                                   for expression closure, else PNK_SEQ for
51110:  *                                   expression closure with destructured
51110:  *                                   formal parameters
27012:  *                          pn_cookie: static level and var index for function
27012:  *                          pn_dflags: PND_* definition/use flags (see below)
27012:  *                          pn_blockid: block id number
82024:  * PNK_ARGSBODY list        list of formal parameters followed by PNK_LC node
27012:  *                            for function body statements as final element
27012:  *                          pn_count: 1 + number of formal parameters
82024:  * PNK_UPVARS   nameset     pn_names: lexical dependencies (js::Definitions)
27012:  *                            defined in enclosing scopes, or ultimately not
27012:  *                            defined (free variables, either global property
27012:  *                            references or reference errors).
82024:  *                          pn_tree: PNK_ARGSBODY or PNK_LC node
    1:  *
    1:  * <Statements>
82024:  * PNK_LC       list        pn_head: list of pn_count statements
82024:  * PNK_IF       ternary     pn_kid1: cond, pn_kid2: then, pn_kid3: else or null.
51110:  *                            In body of a comprehension or desugared generator
82024:  *                            expression, pn_kid2 is PNK_YIELD, PNK_ARRAYPUSH,
82024:  *                            or (if the push was optimized away) empty PNK_LC.
82024:  * PNK_SWITCH   binary      pn_left: discriminant
82024:  *                          pn_right: list of PNK_CASE nodes, with at most one
82024:  *                            PNK_DEFAULT node, or if there are let bindings
    1:  *                            in the top level of the switch body's cases, a
82024:  *                            PNK_LEXICALSCOPE node that contains the list of
82024:  *                            PNK_CASE nodes.
82024:  * PNK_CASE,    binary      pn_left: case expr
82024:  *                          pn_right: PNK_LC node for this case's statements
82024:  * PNK_DEFAULT  binary      pn_left: null
82024:  *                          pn_right: PNK_LC node for this default's statements
    1:  *                          pn_val: constant value if lookup or table switch
82024:  * PNK_WHILE    binary      pn_left: cond, pn_right: body
82024:  * PNK_DO       binary      pn_left: body, pn_right: cond
82024:  * PNK_FOR      binary      pn_left: either
82024:  *                            for/in loop: a ternary PNK_IN node with
82024:  *                              pn_kid1:  PNK_VAR to left of 'in', or NULL
74052:  *                                its pn_xflags may have PNX_POPVAR
    1:  *                                and PNX_FORINVAR bits set
82024:  *                              pn_kid2: PNK_NAME or destructuring expr
74052:  *                                to left of 'in'; if pn_kid1, then this
74052:  *                                is a clone of pn_kid1->pn_head
74052:  *                              pn_kid3: object expr to right of 'in'
82024:  *                            for(;;) loop: a ternary PNK_FORHEAD node with
    1:  *                              pn_kid1:  init expr before first ';'
    1:  *                              pn_kid2:  cond expr before second ';'
    1:  *                              pn_kid3:  update expr after second ';'
    1:  *                              any kid may be null
    1:  *                          pn_right: body
82024:  * PNK_THROW    unary       pn_op: JSOP_THROW, pn_kid: exception
82024:  * PNK_TRY      ternary     pn_kid1: try block
82024:  *                          pn_kid2: null or PNK_CATCHLIST list of
82024:  *                          PNK_LEXICALSCOPE nodes, each with pn_expr pointing
82024:  *                          to a PNK_CATCH node
    1:  *                          pn_kid3: null or finally block
82024:  * PNK_CATCH    ternary     pn_kid1: PNK_NAME, PNK_RB, or PNK_RC catch var node
82024:  *                                   (PNK_RB or PNK_RC if destructuring)
    1:  *                          pn_kid2: null or the catch guard expression
    1:  *                          pn_kid3: catch block statements
82024:  * PNK_BREAK    name        pn_atom: label or null
82024:  * PNK_CONTINUE name        pn_atom: label or null
82024:  * PNK_WITH     binary      pn_left: head expr, pn_right: body
82024:  * PNK_VAR      list        pn_head: list of PNK_NAME or PNK_ASSIGN nodes
72558:  *                                   each name node has either
27012:  *                                     pn_used: false
    1:  *                                     pn_atom: variable name
    1:  *                                     pn_expr: initializer or null
72558:  *                                   or
72558:  *                                     pn_used: true
72558:  *                                     pn_atom: variable name
72558:  *                                     pn_lexdef: def node
27012:  *                                   each assignment node has
82024:  *                                     pn_left: PNK_NAME with pn_used true and
27012:  *                                              pn_lexdef (NOT pn_expr) set
27012:  *                                     pn_right: initializer
82024:  * PNK_RETURN   unary       pn_kid: return expr or null
82024:  * PNK_SEMI     unary       pn_kid: expr or null statement
60792:  *                          pn_prologue: true if Directive Prologue member
60792:  *                              in original source, not introduced via
60792:  *                              constant folding or other tree rewriting
82024:  * PNK_COLON    name        pn_atom: label, pn_expr: labeled statement
    1:  *
    1:  * <Expressions>
    1:  * All left-associated binary trees of the same type are optimized into lists
    1:  * to avoid recursion when processing expression chains.
82024:  * PNK_COMMA    list        pn_head: list of pn_count comma-separated exprs
82024:  * PNK_ASSIGN   binary      pn_left: lvalue, pn_right: rvalue
82024:  * PNK_ADDASSIGN,   binary  pn_left: lvalue, pn_right: rvalue
82024:  * PNK_SUBASSIGN,           pn_op: JSOP_ADD for +=, etc.
82024:  * PNK_BITORASSIGN,
82024:  * PNK_BITXORASSIGN,
82024:  * PNK_BITANDASSIGN,
82024:  * PNK_LSHASSIGN,
82024:  * PNK_RSHASSIGN,
82024:  * PNK_URSHASSIGN,
82024:  * PNK_MULASSIGN,
82024:  * PNK_DIVASSIGN,
82024:  * PNK_MODASSIGN
82024:  * PNK_HOOK     ternary     pn_kid1: cond, pn_kid2: then, pn_kid3: else
82024:  * PNK_OR       binary      pn_left: first in || chain, pn_right: rest of chain
82024:  * PNK_AND      binary      pn_left: first in && chain, pn_right: rest of chain
82024:  * PNK_BITOR    binary      pn_left: left-assoc | expr, pn_right: ^ expr
82024:  * PNK_BITXOR   binary      pn_left: left-assoc ^ expr, pn_right: & expr
82024:  * PNK_BITAND   binary      pn_left: left-assoc & expr, pn_right: EQ expr
82015:  *
82024:  * PNK_EQ,      binary      pn_left: left-assoc EQ expr, pn_right: REL expr
82024:  * PNK_NE,
82024:  * PNK_STRICTEQ,
82024:  * PNK_STRICTNE
82024:  * PNK_LT,      binary      pn_left: left-assoc REL expr, pn_right: SH expr
82024:  * PNK_LE,
82024:  * PNK_GT,
82024:  * PNK_GE
82024:  * PNK_LSH,     binary      pn_left: left-assoc SH expr, pn_right: ADD expr
82024:  * PNK_RSH,
82024:  * PNK_URSH
82024:  * PNK_PLUS,    binary      pn_left: left-assoc ADD expr, pn_right: MUL expr
82024:  *                          pn_xflags: if a left-associated binary PNK_PLUS
    1:  *                            tree has been flattened into a list (see above
27012:  *                            under <Expressions>), pn_xflags will contain
    1:  *                            PNX_STRCAT if at least one list element is a
82024:  *                            string literal (PNK_STRING); if such a list has
27012:  *                            any non-string, non-number term, pn_xflags will
    1:  *                            contain PNX_CANTFOLD.
    1:  *                          pn_
82024:  * PNK_MINUS                pn_op: JSOP_ADD, JSOP_SUB
82024:  * PNK_STAR,    binary      pn_left: left-assoc MUL expr, pn_right: UNARY expr
82024:  * PNK_DIV,                 pn_op: JSOP_MUL, JSOP_DIV, JSOP_MOD
82024:  * PNK_MOD
82024:  * PNK_TYPEOF,  unary       pn_kid: UNARY expr
82024:  * PNK_VOID,
82024:  * PNK_NOT,
82024:  * PNK_BITNOT
82024:  * PNK_INC,     unary       pn_kid: MEMBER expr
82024:  * PNK_DEC
82024:  * PNK_NEW      list        pn_head: list of ctor, arg1, arg2, ... argN
    1:  *                          pn_count: 1 + N (where N is number of args)
    1:  *                          ctor is a MEMBER expr
82024:  * PNK_DELETE   unary       pn_kid: MEMBER expr
82024:  * PNK_DOT,     name        pn_expr: MEMBER expr to left of .
82024:  * PNK_DBLDOT               pn_atom: name to right of .
82024:  * PNK_LB       binary      pn_left: MEMBER expr to left of [
    1:  *                          pn_right: expr between [ and ]
82024:  * PNK_LP       list        pn_head: list of call, arg1, arg2, ... argN
    1:  *                          pn_count: 1 + N (where N is number of args)
    1:  *                          call is a MEMBER expr naming a callable object
82024:  * PNK_RB       list        pn_head: list of pn_count array element exprs
82024:  *                          [,,] holes are represented by PNK_COMMA nodes
27012:  *                          pn_xflags: PN_ENDCOMMA if extra comma at end
82024:  * PNK_RC       list        pn_head: list of pn_count binary PNK_COLON nodes
82024:  * PNK_COLON    binary      key-value pair in object initializer or
28354:  *                          destructuring lhs
28354:  *                          pn_left: property id, pn_right: value
11039:  *                          var {x} = object destructuring shorthand shares
82024:  *                          PN_NAME node for x on left and right of PNK_COLON
82024:  *                          node in PNK_RC's list, has PNX_DESTRUCT flag
82024:  * PNK_DEFSHARP unary       pn_num: jsint value of n in #n=
26959:  *                          pn_kid: primary function, paren, name, object or
26959:  *                                  array literal expressions
82024:  * PNK_USESHARP nullary     pn_num: jsint value of n in #n#
82024:  * PNK_NAME,    name        pn_atom: name, string, or object atom
82024:  * PNK_STRING,              pn_op: JSOP_NAME, JSOP_STRING, or JSOP_OBJECT, or
    1:  *                                 JSOP_REGEXP
82024:  * PNK_REGEXP               If JSOP_NAME, pn_op may be JSOP_*ARG or JSOP_*VAR
27012:  *                          with pn_cookie telling (staticLevel, slot) (see
27012:  *                          jsscript.h's UPVAR macros) and pn_dflags telling
27012:  *                          const-ness and static analysis results
82024:  * PNK_NAME     name        If pn_used, PNK_NAME uses the lexdef member instead
27012:  *                          of the expr member it overlays
82024:  * PNK_NUMBER   dval        pn_dval: double value of numeric literal
82024:  * PNK_TRUE,    nullary     pn_op: JSOp bytecode
82024:  * PNK_FALSE,
82024:  * PNK_NULL,
82024:  * PNK_THIS
    1:  *
    1:  * <E4X node descriptions>
82114:  * PNK_XMLUNARY unary       pn_kid: PNK_AT, PNK_ANYNAME, or PNK_DBLCOLON node
82114:  *                          pn_op: JSOP_XMLNAME, JSOP_BINDXMLNAME, or
82114:  *                                 JSOP_SETXMLNAME
82024:  * PNK_DEFAULT  name        pn_atom: default XML namespace string literal
82024:  * PNK_FILTER   binary      pn_left: container expr, pn_right: filter expr
82024:  * PNK_DBLDOT   binary      pn_left: container expr, pn_right: selector expr
82024:  * PNK_ANYNAME  nullary     pn_op: JSOP_ANYNAME
    1:  *                          pn_atom: cx->runtime->atomState.starAtom
82024:  * PNK_AT       unary       pn_op: JSOP_TOATTRNAME; pn_kid attribute id/expr
82024:  * PNK_DBLCOLON binary      pn_op: JSOP_QNAME
82024:  *                          pn_left: PNK_ANYNAME or PNK_NAME node
82024:  *                          pn_right: PNK_STRING "*" node, or expr within []
    1:  *              name        pn_op: JSOP_QNAMECONST
82024:  *                          pn_expr: PNK_ANYNAME or PNK_NAME left operand
    1:  *                          pn_atom: name on right of ::
82024:  * PNK_XMLELEM  list        XML element node
    1:  *                          pn_head: start tag, content1, ... contentN, end tag
    1:  *                          pn_count: 2 + N where N is number of content nodes
    1:  *                                    N may be > x.length() if {expr} embedded
51110:  *                            After constant folding, these contents may be
51110:  *                            concatenated into string nodes.
82024:  * PNK_XMLLIST  list        XML list node
    1:  *                          pn_head: content1, ... contentN
82024:  * PNK_XMLSTAGO, list       XML start, end, and point tag contents
82024:  * PNK_XMLETAGO,            pn_head: tag name or {expr}, ... XML attrs ...
82024:  * PNK_XMLPTAGC
82024:  * PNK_XMLNAME  nullary     pn_atom: XML name, with no {expr} embedded
82024:  * PNK_XMLNAME  list        pn_head: tag name or {expr}, ... name or {expr}
82024:  * PNK_XMLATTR, nullary     pn_atom: attribute value string; pn_op: JSOP_STRING
82024:  * PNK_XMLCDATA,
82024:  * PNK_XMLCOMMENT
82024:  * PNK_XMLPI    nullary     pn_pitarget: XML processing instruction target
80443:  *                          pn_pidata: XML PI data, or null if no data
82024:  * PNK_XMLTEXT  nullary     pn_atom: marked-up text, or null if empty string
82024:  * PNK_LC       unary       {expr} in XML tag or content; pn_kid is expr
    1:  *
    1:  * So an XML tag with no {expr} and three attributes is a list with the form:
    1:  *
    1:  *    (tagname attrname1 attrvalue1 attrname2 attrvalue2 attrname2 attrvalue3)
    1:  *
    1:  * An XML tag with embedded expressions like so:
    1:  *
    1:  *    <name1{expr1} name2{expr2}name3={expr3}>
    1:  *
    1:  * would have the form:
    1:  *
    1:  *    ((name1 {expr1}) (name2 {expr2} name3) {expr3})
    1:  *
    1:  * where () bracket a list with elements separated by spaces, and {expr} is a
82024:  * PNK_LC unary node with expr as its kid.
    1:  *
    1:  * Thus, the attribute name/value pairs occupy successive odd and even list
82024:  * locations, where pn_head is the PNK_XMLNAME node at list location 0.  The
    1:  * parser builds the same sort of structures for elements:
    1:  *
    1:  *    <a x={x}>Hi there!<b y={y}>How are you?</b><answer>{x + y}</answer></a>
    1:  *
    1:  * translates to:
    1:  *
    1:  *    ((a x {x}) 'Hi there!' ((b y {y}) 'How are you?') ((answer) {x + y}))
    1:  *
    1:  * <Non-E4X node descriptions, continued>
    1:  *
    1:  * Label              Variant   Members
    1:  * -----              -------   -------
82024:  * PNK_LEXICALSCOPE   name      pn_op: JSOP_LEAVEBLOCK or JSOP_LEAVEBLOCKEXPR
80631:  *                              pn_objbox: block object in ObjectBox holder
    1:  *                              pn_expr: block body
82024:  * PNK_ARRAYCOMP      list      pn_count: 1
51110:  *                              pn_head: list of 1 element, which is block
51110:  *                                enclosing for loop(s) and optionally
82024:  *                                if-guarded PNK_ARRAYPUSH
82024:  * PNK_ARRAYPUSH      unary     pn_op: JSOP_ARRAYCOMP
    1:  *                              pn_kid: array comprehension expression
    1:  */
80631: enum ParseNodeArity {
27012:     PN_NULLARY,                         /* 0 kids, only pn_atom/pn_dval/etc. */
27012:     PN_UNARY,                           /* one kid, plus a couple of scalars */
27012:     PN_BINARY,                          /* two kids, plus a couple of scalars */
27012:     PN_TERNARY,                         /* three kids */
27012:     PN_FUNC,                            /* function definition node */
27012:     PN_LIST,                            /* generic singly linked list */
27012:     PN_NAME,                            /* name use or definition node */
80631:     PN_NAMESET                          /* AtomDefnMapPtr + ParseNode ptr */
80631: };
    1: 
80631: struct Definition;
27012: 
80631: struct ParseNode {
78294:   private:
82024:     uint32              pn_type   : 16, /* PNK_* type */
27012:                         pn_op     : 8,  /* see JSOp enum and jsopcode.tbl */
80631:                         pn_arity  : 5,  /* see ParseNodeArity enum */
31479:                         pn_parens : 1,  /* this expr was enclosed in parens */
27012:                         pn_used   : 1,  /* name node is on a use-chain */
80631:                         pn_defn   : 1;  /* this node is a Definition */
27012: 
78294:   public:
82024:     ParseNode(ParseNodeKind kind, JSOp op, ParseNodeArity arity)
82024:       : pn_type(kind), pn_op(op), pn_arity(arity), pn_parens(0), pn_used(0), pn_defn(0),
80639:         pn_offset(0), pn_next(NULL), pn_link(NULL)
80639:     {
82024:         JS_ASSERT(kind < PNK_LIMIT);
80639:         pn_pos.begin.index = 0;
80639:         pn_pos.begin.lineno = 0;
80639:         pn_pos.end.index = 0;
80639:         pn_pos.end.lineno = 0;
80639:         memset(&pn_u, 0, sizeof pn_u);
80639:     }
80639: 
82024:     ParseNode(ParseNodeKind kind, JSOp op, ParseNodeArity arity, const TokenPos &pos)
82024:       : pn_type(kind), pn_op(op), pn_arity(arity), pn_parens(0), pn_used(0), pn_defn(0),
80639:         pn_pos(pos), pn_offset(0), pn_next(NULL), pn_link(NULL)
80639:     {
82024:         JS_ASSERT(kind < PNK_LIMIT);
80639:         memset(&pn_u, 0, sizeof pn_u);
80639:     }
80639: 
78294:     JSOp getOp() const                     { return JSOp(pn_op); }
78294:     void setOp(JSOp op)                    { pn_op = op; }
78294:     bool isOp(JSOp op) const               { return getOp() == op; }
82024: 
82024:     ParseNodeKind getKind() const {
82024:         JS_ASSERT(pn_type < PNK_LIMIT);
82024:         return ParseNodeKind(pn_type);
82024:     }
82024:     void setKind(ParseNodeKind kind) {
82024:         JS_ASSERT(kind < PNK_LIMIT);
82024:         pn_type = kind;
82024:     }
82024:     bool isKind(ParseNodeKind kind) const  { return getKind() == kind; }
82024: 
80631:     ParseNodeArity getArity() const        { return ParseNodeArity(pn_arity); }
80631:     bool isArity(ParseNodeArity a) const   { return getArity() == a; }
80631:     void setArity(ParseNodeArity a)        { pn_arity = a; }
80639: 
82024:     bool isXMLNameOp() const {
82024:         ParseNodeKind kind = getKind();
82024:         return kind == PNK_ANYNAME || kind == PNK_AT || kind == PNK_DBLCOLON;
82024:     }
82024:     bool isAssignment() const {
82024:         ParseNodeKind kind = getKind();
82024:         return PNK_ASSIGNMENT_START <= kind && kind <= PNK_ASSIGNMENT_LAST;
82024:     }
82024: 
82024:     bool isXMLPropertyIdentifier() const {
82024:         ParseNodeKind kind = getKind();
82024:         return kind == PNK_ANYNAME || kind == PNK_AT || kind == PNK_DBLCOLON;
82024:     }
82024: 
82024:     bool isXMLItem() const {
82024:         ParseNodeKind kind = getKind();
82024:         return kind == PNK_XMLCOMMENT || kind == PNK_XMLCDATA || kind == PNK_XMLPI ||
82024:                kind == PNK_XMLELEM || kind == PNK_XMLLIST;
82024:     }
82015: 
78294:     /* Boolean attributes. */
78294:     bool isInParens() const                { return pn_parens; }
78294:     void setInParens(bool enabled)         { pn_parens = enabled; }
80640:     bool isUsed() const                    { return pn_used; }
80640:     void setUsed(bool enabled)             { pn_used = enabled; }
78294:     bool isDefn() const                    { return pn_defn; }
78294:     void setDefn(bool enabled)             { pn_defn = enabled; }
27012: 
80631:     TokenPos            pn_pos;         /* two 16-bit pairs here, for 64 bits */
27012:     int32               pn_offset;      /* first generated bytecode offset */
80631:     ParseNode           *pn_next;       /* intrinsic link in parent PN_LIST */
80631:     ParseNode           *pn_link;       /* def/use link (alignment freebie);
80631:                                            also links FunctionBox::methods
37685:                                            lists of would-be |this| methods */
80639: 
    1:     union {
    1:         struct {                        /* list of next-linked nodes */
80631:             ParseNode   *head;          /* first node in list */
80631:             ParseNode   **tail;         /* ptr to ptr to last node in list */
    1:             uint32      count;          /* number of nodes in list */
27012:             uint32      xflags:12,      /* extra flags, see below */
27012:                         blockid:20;     /* see name variant below */
    1:         } list;
    1:         struct {                        /* ternary: if, for(;;), ?: */
80631:             ParseNode   *kid1;          /* condition, discriminant, etc. */
80631:             ParseNode   *kid2;          /* then-part, case list, etc. */
80631:             ParseNode   *kid3;          /* else-part, default case, etc. */
    1:         } ternary;
    1:         struct {                        /* two kids if binary */
80631:             ParseNode   *left;
80631:             ParseNode   *right;
80631:             Value       *pval;          /* switch case value */
82024:             uintN       iflags;         /* JSITER_* flags for PNK_FOR node */
    1:         } binary;
    1:         struct {                        /* one kid if unary */
80631:             ParseNode   *kid;
    1:             jsint       num;            /* -1 or sharp variable number */
60792:             JSBool      hidden;         /* hidden genexp-induced JSOP_YIELD
60792:                                            or directive prologue member (as
60792:                                            pn_prologue) */
    1:         } unary;
    1:         struct {                        /* name, labeled statement, etc. */
27012:             union {
27012:                 JSAtom        *atom;    /* lexical name or label atom */
80631:                 FunctionBox   *funbox;  /* function object */
80631:                 ObjectBox     *objbox;  /* block or regexp object */
27012:             };
27012:             union {
80631:                 ParseNode    *expr;     /* function body, var initializer, or
82024:                                            base object of PNK_DOT */
80631:                 Definition   *lexdef;   /* lexical definition for this use */
27012:             };
80631:             UpvarCookie cookie;         /* upvar cookie with absolute frame
27012:                                            level (not relative skip), possibly
27012:                                            in current frame */
27012:             uint32      dflags:12,      /* definition/use flags, see below */
27012:                         blockid:20;     /* block number, for subset dominance
27012:                                            computation */
    1:         } name;
27012:         struct {                        /* lexical dependencies + sub-tree */
80631:             AtomDefnMapPtr   defnMap;
80631:             ParseNode        *tree;     /* sub-tree containing name uses */
27012:         } nameset;
80443:         struct {                        /* PN_NULLARY variant for E4X XML PI */
80631:             PropertyName     *target;   /* target in <?target data?> */
80443:             JSAtom           *data;     /* data (or null) in <?target data?> */
80443:         } xmlpi;
    1:         jsdouble        dval;           /* aligned numeric literal value */
    1:     } pn_u;
    1: 
27012: #define pn_funbox       pn_u.name.funbox
27012: #define pn_body         pn_u.name.expr
27012: #define pn_cookie       pn_u.name.cookie
27012: #define pn_dflags       pn_u.name.dflags
27012: #define pn_blockid      pn_u.name.blockid
27012: #define pn_index        pn_u.name.blockid /* reuse as object table index */
    1: #define pn_head         pn_u.list.head
    1: #define pn_tail         pn_u.list.tail
    1: #define pn_count        pn_u.list.count
27012: #define pn_xflags       pn_u.list.xflags
    1: #define pn_kid1         pn_u.ternary.kid1
    1: #define pn_kid2         pn_u.ternary.kid2
    1: #define pn_kid3         pn_u.ternary.kid3
    1: #define pn_left         pn_u.binary.left
    1: #define pn_right        pn_u.binary.right
48470: #define pn_pval         pn_u.binary.pval
15613: #define pn_iflags       pn_u.binary.iflags
    1: #define pn_kid          pn_u.unary.kid
    1: #define pn_num          pn_u.unary.num
 1577: #define pn_hidden       pn_u.unary.hidden
60792: #define pn_prologue     pn_u.unary.hidden
    1: #define pn_atom         pn_u.name.atom
27012: #define pn_objbox       pn_u.name.objbox
    1: #define pn_expr         pn_u.name.expr
27012: #define pn_lexdef       pn_u.name.lexdef
72579: #define pn_names        pn_u.nameset.defnMap
27012: #define pn_tree         pn_u.nameset.tree
    1: #define pn_dval         pn_u.dval
80443: #define pn_pitarget     pn_u.xmlpi.target
80443: #define pn_pidata       pn_u.xmlpi.data
    1: 
40232:   protected:
80631:     void init(TokenKind type, JSOp op, ParseNodeArity arity) {
40232:         pn_type = type;
40232:         pn_op = op;
40232:         pn_arity = arity;
40232:         pn_parens = false;
40232:         JS_ASSERT(!pn_used);
40232:         JS_ASSERT(!pn_defn);
72579:         pn_names.init();
40232:         pn_next = pn_link = NULL;
40232:     }
40232: 
82024:     static ParseNode *create(ParseNodeKind kind, ParseNodeArity arity, TreeContext *tc);
40232: 
40232:   public:
82016:     /*
82016:      * Append right to left, forming a list node.  |left| must have the given
82016:      * kind and op, and op must be left-associative.
82016:      */
82016:     static ParseNode *
82024:     append(ParseNodeKind tt, JSOp op, ParseNode *left, ParseNode *right);
82016: 
82016:     /*
82016:      * Either append right to left, if left meets the conditions necessary to
82016:      * append (see append), or form a binary node whose children are right and
82016:      * left.
82016:      */
82016:     static ParseNode *
82024:     newBinaryOrAppend(ParseNodeKind kind, JSOp op, ParseNode *left, ParseNode *right,
82024:                       TreeContext *tc);
40232: 
27012:     /*
27012:      * The pn_expr and lexdef members are arms of an unsafe union. Unless you
27012:      * know exactly what you're doing, use only the following methods to access
27012:      * them. For less overhead and assertions for protection, use pn->expr()
27012:      * and pn->lexdef(). Otherwise, use pn->maybeExpr() and pn->maybeLexDef().
27012:      */
80631:     ParseNode *expr() const {
27012:         JS_ASSERT(!pn_used);
27012:         JS_ASSERT(pn_arity == PN_NAME || pn_arity == PN_FUNC);
27012:         return pn_expr;
27012:     }
27012: 
80631:     Definition *lexdef() const {
38549:         JS_ASSERT(pn_used || isDeoptimized());
27012:         JS_ASSERT(pn_arity == PN_NAME);
27012:         return pn_lexdef;
27012:     }
27012: 
80631:     ParseNode  *maybeExpr()   { return pn_used ? NULL : expr(); }
80631:     Definition *maybeLexDef() { return pn_used ? lexdef() : NULL; }
27012: 
27012: /* PN_FUNC and PN_NAME pn_dflags bits. */
27012: #define PND_LET         0x01            /* let (block-scoped) binding */
27012: #define PND_CONST       0x02            /* const binding (orthogonal to let) */
27012: #define PND_INITIALIZED 0x04            /* initialized declaration */
27012: #define PND_ASSIGNED    0x08            /* set if ever LHS of assignment */
59228: #define PND_TOPLEVEL    0x10            /* see isTopLevel() below */
27012: #define PND_BLOCKCHILD  0x20            /* use or def is direct block child */
28557: #define PND_GVAR        0x40            /* gvar binding, can't close over
28557:                                            because it could be deleted */
27012: #define PND_PLACEHOLDER 0x80            /* placeholder definition for lexdep */
27012: #define PND_FUNARG     0x100            /* downward or upward funarg usage */
27012: #define PND_BOUND      0x200            /* bound to a stack or global slot */
38549: #define PND_DEOPTIMIZED 0x400           /* former pn_used name node, pn_lexdef
38549:                                            still valid, but this use no longer
38549:                                            optimizable via an upvar opcode */
52878: #define PND_CLOSED      0x800           /* variable is closed over */
27012: 
30457: /* Flags to propagate from uses to definition. */
52878: #define PND_USE2DEF_FLAGS (PND_ASSIGNED | PND_FUNARG | PND_CLOSED)
30457: 
27012: /* PN_LIST pn_xflags bits. */
82024: #define PNX_STRCAT      0x01            /* PNK_PLUS list has string term */
82024: #define PNX_CANTFOLD    0x02            /* PNK_PLUS list has unfoldable term */
82024: #define PNX_POPVAR      0x04            /* PNK_VAR last result needs popping */
82024: #define PNX_FORINVAR    0x08            /* PNK_VAR is left kid of PNK_IN node,
82024:                                            which is left kid of PNK_FOR */
    1: #define PNX_ENDCOMMA    0x10            /* array literal has comma at end */
    1: #define PNX_XMLROOT     0x20            /* top-most node in XML literal tree */
    1: #define PNX_GROUPINIT   0x40            /* var [a, b] = [c, d]; unit list */
    1: #define PNX_NEEDBRACES  0x80            /* braces necessary due to closure */
57742: #define PNX_FUNCDEFS   0x100            /* contains top-level function statements */
57742: #define PNX_SETCALL    0x100            /* call expression in lvalue context */
27012: #define PNX_DESTRUCT   0x200            /* destructuring special cases:
27012:                                            1. shorthand syntax used, at present
27012:                                               object destructuring ({x,y}) only;
51097:                                            2. code evaluating destructuring
51097:                                               arguments occurs before function
51097:                                               body */
28123: #define PNX_HOLEY      0x400            /* array initialiser has holes */
59962: #define PNX_NONCONST   0x800            /* initialiser has non-constants */
27012: 
27012:     uintN frameLevel() const {
27012:         JS_ASSERT(pn_arity == PN_FUNC || pn_arity == PN_NAME);
47573:         return pn_cookie.level();
27012:     }
27012: 
27012:     uintN frameSlot() const {
27012:         JS_ASSERT(pn_arity == PN_FUNC || pn_arity == PN_NAME);
47573:         return pn_cookie.slot();
27012:     }
27012: 
38606:     inline bool test(uintN flag) const;
27012: 
27012:     bool isLet() const          { return test(PND_LET); }
27012:     bool isConst() const        { return test(PND_CONST); }
27012:     bool isInitialized() const  { return test(PND_INITIALIZED); }
27012:     bool isBlockChild() const   { return test(PND_BLOCKCHILD); }
27012:     bool isPlaceholder() const  { return test(PND_PLACEHOLDER); }
38549:     bool isDeoptimized() const  { return test(PND_DEOPTIMIZED); }
38606:     bool isAssigned() const     { return test(PND_ASSIGNED); }
38606:     bool isFunArg() const       { return test(PND_FUNARG); }
54840:     bool isClosed() const       { return test(PND_CLOSED); }
27012: 
59228:     /*
59228:      * True iff this definition creates a top-level binding in the overall
59228:      * script being compiled -- that is, it affects the whole program's
59228:      * bindings, not bindings for a specific function (unless this definition
59228:      * is in the outermost scope in eval code, executed within a function) or
59228:      * the properties of a specific object (through the with statement).
59228:      *
59228:      * NB: Function sub-statements found in overall program code and not nested
59228:      *     within other functions are not currently top level, even though (if
59228:      *     executed) they do create top-level bindings; there is no particular
59228:      *     rationale for this behavior.
59228:      */
59228:     bool isTopLevel() const     { return test(PND_TOPLEVEL); }
59228: 
80631:     /* Defined below, see after struct Definition. */
27111:     void setFunArg();
27012: 
80631:     void become(ParseNode *pn2);
27012:     void clear();
27012: 
27012:     /* True if pn is a parsenode representing a literal constant. */
27012:     bool isLiteral() const {
82024:         return isKind(PNK_NUMBER) ||
82024:                isKind(PNK_STRING) ||
82024:                isKind(PNK_TRUE) ||
82024:                isKind(PNK_FALSE) ||
82024:                isKind(PNK_NULL);
27012:     }
26968: 
26970:     /*
60792:      * True if this statement node could be a member of a Directive Prologue: an
60792:      * expression statement consisting of a single string literal.
60792:      *
60792:      * This considers only the node and its children, not its context. After
60792:      * parsing, check the node's pn_prologue flag to see if it is indeed part of
60792:      * a directive prologue.
60792:      *
60792:      * Note that a Directive Prologue can contain statements that cannot
60792:      * themselves be directives (string literals that include escape sequences
60792:      * or escaped newlines, say). This member function returns true for such
60792:      * nodes; we use it to determine the extent of the prologue.
60792:      * isEscapeFreeStringLiteral, below, checks whether the node itself could be
60792:      * a directive.
35113:      */
60792:     bool isStringExprStatement() const {
82024:         if (getKind() == PNK_SEMI) {
37740:             JS_ASSERT(pn_arity == PN_UNARY);
80631:             ParseNode *kid = pn_kid;
82024:             return kid && kid->getKind() == PNK_STRING && !kid->pn_parens;
35113:         }
35113:         return false;
35113:     }
35113: 
35113:     /*
82024:      * Return true if this node, known to be an unparenthesized string literal,
82024:      * could be the string of a directive in a Directive Prologue. Directive
82024:      * strings never contain escape sequences or line continuations.
35113:      */
60792:     bool isEscapeFreeStringLiteral() const {
82024:         JS_ASSERT(isKind(PNK_STRING) && !pn_parens);
40232: 
35113:         /*
35113:          * If the string's length in the source code is its length as a value,
60792:          * accounting for the quotes, then it must not contain any escape
60792:          * sequences or line continuations.
35113:          */
82024:         JSString *str = pn_atom;
35113:         return (pn_pos.begin.lineno == pn_pos.end.lineno &&
35113:                 pn_pos.begin.index + str->length() + 2 == pn_pos.end.index);
35113:     }
35113: 
60792:     /* Return true if this node appears in a Directive Prologue. */
60792:     bool isDirectivePrologueMember() const { return pn_prologue; }
60792: 
51110: #ifdef JS_HAS_GENERATOR_EXPRS
51110:     /*
51110:      * True if this node is a desugared generator expression.
51110:      */
51110:     bool isGeneratorExpr() const {
82024:         if (getKind() == PNK_LP) {
80631:             ParseNode *callee = this->pn_head;
82024:             if (callee->getKind() == PNK_FUNCTION) {
82024:                 ParseNode *body = (callee->pn_body->getKind() == PNK_UPVARS)
51110:                                   ? callee->pn_body->pn_tree
51110:                                   : callee->pn_body;
82024:                 if (body->getKind() == PNK_LEXICALSCOPE)
51110:                     return true;
51110:             }
51110:         }
51110:         return false;
51110:     }
51110: 
80631:     ParseNode *generatorExpr() const {
51110:         JS_ASSERT(isGeneratorExpr());
80631:         ParseNode *callee = this->pn_head;
82024:         ParseNode *body = callee->pn_body->getKind() == PNK_UPVARS
51110:                           ? callee->pn_body->pn_tree
51110:                           : callee->pn_body;
82024:         JS_ASSERT(body->getKind() == PNK_LEXICALSCOPE);
51110:         return body->pn_expr;
51110:     }
51110: #endif
51110: 
35113:     /*
27012:      * Compute a pointer to the last element in a singly-linked list. NB: list
27012:      * must be non-empty for correct PN_LAST usage -- this is asserted!
26970:      */
80631:     ParseNode *last() const {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         JS_ASSERT(pn_count != 0);
80631:         return (ParseNode *)(uintptr_t(pn_tail) - offsetof(ParseNode, pn_next));
27012:     }
26968: 
27012:     void makeEmpty() {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         pn_head = NULL;
27012:         pn_tail = &pn_head;
27012:         pn_count = 0;
27012:         pn_xflags = 0;
27012:         pn_blockid = 0;
27012:     }
26968: 
80631:     void initList(ParseNode *pn) {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         pn_head = pn;
27012:         pn_tail = &pn->pn_next;
27012:         pn_count = 1;
27012:         pn_xflags = 0;
27012:         pn_blockid = 0;
27012:     }
26970: 
80631:     void append(ParseNode *pn) {
27012:         JS_ASSERT(pn_arity == PN_LIST);
27012:         *pn_tail = pn;
27012:         pn_tail = &pn->pn_next;
27012:         pn_count++;
27012:     }
59962: 
80631:     bool getConstantValue(JSContext *cx, bool strictChecks, Value *vp);
59962:     inline bool isConstant();
27012: };
11039: 
80631: struct NullaryNode : public ParseNode {
82024:     static inline NullaryNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (NullaryNode *)ParseNode::create(kind, PN_NULLARY, tc);
40232:     }
40232: };
40232: 
80631: struct UnaryNode : public ParseNode {
82024:     UnaryNode(ParseNodeKind kind, JSOp op, const TokenPos &pos, ParseNode *kid)
82024:       : ParseNode(kind, op, PN_UNARY, pos)
80640:     {
80640:         pn_kid = kid;
80640:     }
80640: 
82024:     static inline UnaryNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (UnaryNode *)ParseNode::create(kind, PN_UNARY, tc);
40232:     }
40232: };
40232: 
80631: struct BinaryNode : public ParseNode {
82024:     BinaryNode(ParseNodeKind kind, JSOp op, const TokenPos &pos, ParseNode *left, ParseNode *right)
82024:       : ParseNode(kind, op, PN_BINARY, pos)
80640:     {
80640:         pn_left = left;
80640:         pn_right = right;
74052:     }
80640: 
82024:     BinaryNode(ParseNodeKind kind, JSOp op, ParseNode *left, ParseNode *right)
82024:       : ParseNode(kind, op, PN_BINARY, TokenPos::box(left->pn_pos, right->pn_pos))
80640:     {
80640:         pn_left = left;
80640:         pn_right = right;
74052:     }
74052: 
82024:     static inline BinaryNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (BinaryNode *)ParseNode::create(kind, PN_BINARY, tc);
40232:     }
40232: };
40232: 
80631: struct TernaryNode : public ParseNode {
82024:     TernaryNode(ParseNodeKind kind, JSOp op, ParseNode *kid1, ParseNode *kid2, ParseNode *kid3)
82024:       : ParseNode(kind, op, PN_TERNARY,
80983:                   TokenPos::make((kid1 ? kid1 : kid2 ? kid2 : kid3)->pn_pos.begin,
80640:                                  (kid3 ? kid3 : kid2 ? kid2 : kid1)->pn_pos.end))
80640:     {
80640:         pn_kid1 = kid1;
80640:         pn_kid2 = kid2;
80640:         pn_kid3 = kid3;
74052:     }
74052: 
82024:     static inline TernaryNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (TernaryNode *)ParseNode::create(kind, PN_TERNARY, tc);
40232:     }
40232: };
40232: 
80631: struct ListNode : public ParseNode {
82024:     static inline ListNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (ListNode *)ParseNode::create(kind, PN_LIST, tc);
40232:     }
40232: };
40232: 
80631: struct FunctionNode : public ParseNode {
82024:     static inline FunctionNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (FunctionNode *)ParseNode::create(kind, PN_FUNC, tc);
40232:     }
40232: };
40232: 
80631: struct NameNode : public ParseNode {
82024:     static NameNode *create(ParseNodeKind kind, JSAtom *atom, TreeContext *tc);
40232: 
80641:     inline void initCommon(TreeContext *tc);
40232: };
40232: 
80631: struct NameSetNode : public ParseNode {
82024:     static inline NameSetNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (NameSetNode *)ParseNode::create(kind, PN_NAMESET, tc);
40232:     }
40232: };
40232: 
80631: struct LexicalScopeNode : public ParseNode {
82024:     static inline LexicalScopeNode *create(ParseNodeKind kind, TreeContext *tc) {
82024:         return (LexicalScopeNode *)ParseNode::create(kind, PN_NAME, tc);
40232:     }
40232: };
40232: 
80631: ParseNode *
80631: CloneLeftHandSide(ParseNode *opn, TreeContext *tc);
40232: 
    1: /*
80631:  * js::Definition is a degenerate subtype of the PN_FUNC and PN_NAME variants
80631:  * of js::ParseNode, allocated only for function, var, const, and let
80631:  * declarations that define truly lexical bindings. This means that a child of
82024:  * a PNK_VAR list may be a Definition instead of a ParseNode. The pn_defn
80631:  * bit is set for all Definitions, clear otherwise.
27012:  *
72579:  * In an upvars list, defn->resolve() is the outermost definition the
72579:  * name may reference. If a with block or a function that calls eval encloses
72579:  * the use, the name may end up referring to something else at runtime.
72579:  *
27012:  * Note that not all var declarations are definitions: JS allows multiple var
27012:  * declarations in a function or script, but only the first creates the hoisted
27012:  * binding. JS programmers do redeclare variables for good refactoring reasons,
27012:  * for example:
27012:  *
27012:  *   function foo() {
27012:  *       ...
27012:  *       for (var i ...) ...;
27012:  *       ...
27012:  *       for (var i ...) ...;
27012:  *       ...
27012:  *   }
27012:  *
27012:  * Not all definitions bind lexical variables, alas. In global and eval code
27012:  * var may re-declare a pre-existing property having any attributes, with or
27012:  * without JSPROP_PERMANENT. In eval code, indeed, ECMA-262 Editions 1 through
27012:  * 3 require function and var to bind deletable bindings. Global vars thus are
27012:  * properties of the global object, so they can be aliased even if they can't
27012:  * be deleted.
27012:  *
27012:  * Only bindings within function code may be treated as lexical, of course with
27012:  * the caveat that hoisting means use before initialization is allowed. We deal
27012:  * with use before declaration in one pass as follows (error checking elided):
27012:  *
27012:  *   for (each use of unqualified name x in parse order) {
27012:  *       if (this use of x is a declaration) {
27012:  *           if (x in tc->decls) {                          // redeclaring
80631:  *               pn = allocate a PN_NAME ParseNode;
27012:  *           } else {                                       // defining
27012:  *               dn = lookup x in tc->lexdeps;
32752:  *               if (dn)                                    // use before def
27012:  *                   remove x from tc->lexdeps;
32752:  *               else                                       // def before use
80631:  *                   dn = allocate a PN_NAME Definition;
27012:  *               map x to dn via tc->decls;
27012:  *               pn = dn;
27012:  *           }
82024:  *           insert pn into its parent PNK_VAR list;
27012:  *       } else {
80631:  *           pn = allocate a ParseNode for this reference to x;
27012:  *           dn = lookup x in tc's lexical scope chain;
27012:  *           if (!dn) {
27012:  *               dn = lookup x in tc->lexdeps;
27012:  *               if (!dn) {
80631:  *                   dn = pre-allocate a Definition for x;
27012:  *                   map x to dn in tc->lexdeps;
27012:  *               }
27012:  *           }
27012:  *           append pn to dn's use chain;
27012:  *       }
27012:  *   }
27012:  *
80964:  * See frontend/BytecodeEmitter.h for js::TreeContext and its top*Stmt,
80631:  * decls, and lexdeps members.
27012:  *
27012:  * Notes:
27012:  *
80631:  *  0. To avoid bloating ParseNode, we steal a bit from pn_arity for pn_defn
80631:  *     and set it on a ParseNode instead of allocating a Definition.
27012:  *
27012:  *  1. Due to hoisting, a definition cannot be eliminated even if its "Variable
27012:  *     statement" (ECMA-262 12.2) can be proven to be dead code. RecycleTree in
80507:  *     ParseNode.cpp will not recycle a node whose pn_defn bit is set.
27012:  *
27012:  *  2. "lookup x in tc's lexical scope chain" gives up on def/use chaining if a
27012:  *     with statement is found along the the scope chain, which includes tc,
27012:  *     tc->parent, etc. Thus we eagerly connect an inner function's use of an
27012:  *     outer's var x if the var x was parsed before the inner function.
27012:  *
27012:  *  3. A use may be eliminated as dead by the constant folder, which therefore
27012:  *     must remove the dead name node from its singly-linked use chain, which
27012:  *     would mean hashing to find the definition node and searching to update
27012:  *     the pn_link pointing at the use to be removed. This is costly, so as for
27012:  *     dead definitions, we do not recycle dead pn_used nodes.
27012:  *
27012:  * At the end of parsing a function body or global or eval program, tc->lexdeps
27012:  * holds the lexical dependencies of the parsed unit. The name to def/use chain
27012:  * mappings are then merged into the parent tc->lexdeps.
27012:  *
27012:  * Thus if a later var x is parsed in the outer function satisfying an earlier
27012:  * inner function's use of x, we will remove dn from tc->lexdeps and re-use it
27012:  * as the new definition node in the outer function's parse tree.
27012:  *
27012:  * When the compiler unwinds from the outermost tc, tc->lexdeps contains the
27012:  * definition nodes with use chains for all free variables. These are either
27012:  * global variables or reference errors.
27012:  *
27012:  * We analyze whether a binding is initialized, whether the bound names is ever
27012:  * assigned apart from its initializer, and if the bound name definition or use
27012:  * is in a direct child of a block. These PND_* flags allow a subset dominance
27012:  * computation telling whether an initialized var dominates its uses. An inner
27012:  * function using only such outer vars (and formal parameters) can be optimized
27012:  * into a flat closure. See JSOP_{GET,CALL}DSLOT.
27012:  *
27012:  * Another important subset dominance relation: ... { var x = ...; ... x ... }
27012:  * where x is not assigned after initialization and not used outside the block.
27012:  * This style is common in the absence of 'let'. Even though the var x is not
27012:  * at top level, we can tell its initialization dominates all uses cheaply,
27012:  * because the above one-pass algorithm sees the definition before any uses,
27012:  * and because all uses are contained in the same block as the definition.
27012:  *
79382:  * We also analyze function uses to flag upward/downward funargs.  If a lambda
79382:  * post-dominates each of its upvars' sole, inevitable (i.e. not hidden behind
79382:  * conditions or within loops or the like) initialization or assignment; then
79382:  * we can optimize the lambda as a flat closure (after Chez Scheme's display
79382:  * closures).
    1:  */
27012: #define dn_uses         pn_link
    1: 
80631: struct Definition : public ParseNode
27012: {
27012:     /*
80631:      * We store definition pointers in PN_NAMESET AtomDefnMapPtrs in the AST,
72579:      * but due to redefinition these nodes may become uses of other
72579:      * definitions.  This is unusual, so we simply chase the pn_lexdef link to
80992:      * find the final definition node. See functions called from
80992:      * js::frontend::AnalyzeFunctions.
27012:      *
27012:      * FIXME: MakeAssignment mutates for want of a parent link...
27012:      */
80631:     Definition *resolve() {
80631:         ParseNode *pn = this;
78294:         while (!pn->isDefn()) {
82023:             if (pn->isAssignment()) {
27012:                 pn = pn->pn_left;
27012:                 continue;
27012:             }
27012:             pn = pn->lexdef();
27012:         }
80631:         return (Definition *) pn;
27012:     }
    1: 
27012:     bool isFreeVar() const {
78294:         JS_ASSERT(isDefn());
47573:         return pn_cookie.isFree() || test(PND_GVAR);
27012:     }
27012: 
60526:     bool isGlobal() const {
78294:         JS_ASSERT(isDefn());
60526:         return test(PND_GVAR);
60526:     }
60526: 
27012:     enum Kind { VAR, CONST, LET, FUNCTION, ARG, UNKNOWN };
27012: 
27012:     bool isBindingForm() { return int(kind()) <= int(LET); }
27012: 
27012:     static const char *kindString(Kind kind);
27012: 
27012:     Kind kind() {
82024:         if (getKind() == PNK_FUNCTION)
27012:             return FUNCTION;
82024:         JS_ASSERT(getKind() == PNK_NAME);
78294:         if (isOp(JSOP_NOP))
27012:             return UNKNOWN;
78294:         if (isOp(JSOP_GETARG))
27012:             return ARG;
27012:         if (isConst())
27012:             return CONST;
27012:         if (isLet())
27012:             return LET;
27012:         return VAR;
27012:     }
27012: };
27012: 
80641: class ParseNodeAllocator {
80641:   public:
80641:     explicit ParseNodeAllocator(JSContext *cx) : cx(cx), freelist(NULL) {}
80641: 
80641:     void *allocNode();
80641:     void freeNode(ParseNode *pn);
80641:     ParseNode *freeTree(ParseNode *pn);
80641:     void prepareNodeForMutation(ParseNode *pn);
80641: 
80641:   private:
80641:     JSContext *cx;
80641:     ParseNode *freelist;
80641: };
80641: 
27012: inline bool
80631: ParseNode::test(uintN flag) const
27012: {
38606:     JS_ASSERT(pn_defn || pn_arity == PN_FUNC || pn_arity == PN_NAME);
27012: #ifdef DEBUG
38606:     if ((flag & (PND_ASSIGNED | PND_FUNARG)) && pn_defn && !(pn_dflags & flag)) {
80631:         for (ParseNode *pn = ((Definition *) this)->dn_uses; pn; pn = pn->pn_link) {
38606:             JS_ASSERT(!pn->pn_defn);
38606:             JS_ASSERT(!(pn->pn_dflags & flag));
38606:         }
38606:     }
27012: #endif
38606:     return !!(pn_dflags & flag);
27012: }
27012: 
27111: inline void
80631: ParseNode::setFunArg()
27111: {
27164:     /*
27164:      * pn_defn NAND pn_used must be true, per this chart:
27164:      *
27164:      *   pn_defn pn_used
27164:      *         0       0        anonymous function used implicitly, e.g. by
27164:      *                          hidden yield in a genexp
27164:      *         0       1        a use of a definition or placeholder
27164:      *         1       0        a definition or placeholder
27164:      *         1       1        error: this case must not be possible
27164:      */
27164:     JS_ASSERT(!(pn_defn & pn_used));
27164:     if (pn_used)
27111:         pn_lexdef->pn_dflags |= PND_FUNARG;
27111:     pn_dflags |= PND_FUNARG;
27111: }
27111: 
80507: inline void
80631: LinkUseToDef(ParseNode *pn, Definition *dn, TreeContext *tc)
80507: {
80507:     JS_ASSERT(!pn->isUsed());
80507:     JS_ASSERT(!pn->isDefn());
80507:     JS_ASSERT(pn != dn->dn_uses);
80507:     pn->pn_link = dn->dn_uses;
80507:     dn->dn_uses = pn;
80507:     dn->pn_dflags |= pn->pn_dflags & PND_USE2DEF_FLAGS;
80507:     pn->setUsed(true);
80507:     pn->pn_lexdef = dn;
80507: }
80507: 
80631: struct ObjectBox {
80631:     ObjectBox           *traceLink;
80631:     ObjectBox           *emitLink;
26970:     JSObject            *object;
80631:     ObjectBox           *parent;
54855:     uintN               index;
59968:     bool                isFunctionBox;
26970: };
26970: 
28814: #define JSFB_LEVEL_BITS 14
28814: 
80631: struct FunctionBox : public ObjectBox
27012: {
80631:     ParseNode           *node;
80631:     FunctionBox         *siblings;
80631:     FunctionBox         *kids;
80631:     FunctionBox         *parent;
80631:     ParseNode           *methods;               /* would-be methods set on this;
37685:                                                    these nodes are linked via
37685:                                                    pn_link, since lambdas are
37685:                                                    neither definitions nor uses
37685:                                                    of a binding */
80631:     Bindings            bindings;               /* bindings for this function */
27012:     uint32              queued:1,
28814:                         inLoop:1,               /* in a loop in parent function */
33752:                         level:JSFB_LEVEL_BITS;
33752:     uint32              tcflags;
37685: 
64294:     JSFunction *function() const { return (JSFunction *) object; }
64294: 
37685:     bool joinable() const;
37685: 
37685:     /*
61210:      * True if this function is inside the scope of a with-statement, an E4X
61210:      * filter-expression, or a function that uses direct eval.
61210:      */
61210:     bool inAnyDynamicScope() const;
61210: 
61210:     /* 
64296:      * Must this function's descendants be marked as having an extensible
64296:      * ancestor?
64296:      */
64296:     bool scopeIsExtensible() const;
64296: 
64296:     /*
37685:      * Unbrand an object being initialized or constructed if any method cannot
37685:      * be joined to one compiler-created null closure shared among N different
37685:      * closure environments.
37685:      *
52503:      * We despecialize from caching function objects, caching slots or shapes
37685:      * instead, because an unbranded object may still have joined methods (for
52503:      * which shape->isMethod), since PropertyCache::fill gives precedence to
37685:      * joined methods over branded methods.
37685:      */
37685:     bool shouldUnbrand(uintN methods, uintN slowMethods) const;
27012: };
27012: 
80631: struct FunctionBoxQueue {
80631:     FunctionBox         **vector;
27012:     size_t              head, tail;
27012:     size_t              lengthMask;
27012: 
27012:     size_t count()  { return head - tail; }
27012:     size_t length() { return lengthMask + 1; }
27012: 
80631:     FunctionBoxQueue()
27012:       : vector(NULL), head(0), tail(0), lengthMask(0) { }
27012: 
27012:     bool init(uint32 count) {
80202:         lengthMask = JS_BITMASK(JS_CEILING_LOG2W(count));
80631:         vector = (FunctionBox **) OffTheBooks::malloc_(sizeof(FunctionBox) * length());
27012:         return !!vector;
27012:     }
27012: 
80631:     ~FunctionBoxQueue() { UnwantedForeground::free_(vector); }
27012: 
80631:     void push(FunctionBox *funbox) {
27012:         if (!funbox->queued) {
27012:             JS_ASSERT(count() < length());
27012:             vector[head++ & lengthMask] = funbox;
27012:             funbox->queued = true;
27012:         }
27012:     }
27012: 
80631:     FunctionBox *pull() {
27012:         if (tail == head)
27012:             return NULL;
27164:         JS_ASSERT(tail < head);
80631:         FunctionBox *funbox = vector[tail++ & lengthMask];
27012:         funbox->queued = false;
27012:         return funbox;
27012:     }
27012: };
27012: 
80631: } /* namespace js */
80631: 
80507: #endif /* ParseNode_h__ */
