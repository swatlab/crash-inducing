149604: # This Source Code Form is subject to the terms of the Mozilla Public
149604: # License, v. 2.0. If a copy of the MPL was not distributed with this
149604: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
149604: 
149604: from __future__ import unicode_literals
149604: 
149604: import os
149604: 
149604: import mozunit
149604: 
152885: from mozpack.copier import (
152885:     FileCopier,
152885:     FileRegistry,
152885: )
149604: from mozpack.manifests import (
152885:     InstallManifest,
149604: )
149604: from mozpack.test.test_files import TestWithTmpDir
149604: 
149604: 
152885: class TestInstallManifest(TestWithTmpDir):
152885:     def test_construct(self):
152885:         m = InstallManifest()
152885:         self.assertEqual(len(m), 0)
152885: 
152885:     def test_adds(self):
152885:         m = InstallManifest()
152885:         m.add_symlink('s_source', 's_dest')
152885:         m.add_copy('c_source', 'c_dest')
152885:         m.add_required_exists('e_dest')
159242:         m.add_optional_exists('o_dest')
152885: 
176554:         self.assertEqual(len(m), 4)
152885:         self.assertIn('s_dest', m)
152885:         self.assertIn('c_dest', m)
152885:         self.assertIn('e_dest', m)
159242:         self.assertIn('o_dest', m)
152885: 
152885:         with self.assertRaises(ValueError):
152885:             m.add_symlink('s_other', 's_dest')
152885: 
152885:         with self.assertRaises(ValueError):
152885:             m.add_copy('c_other', 'c_dest')
152885: 
152885:         with self.assertRaises(ValueError):
152885:             m.add_required_exists('e_dest')
152885: 
159242:         with self.assertRaises(ValueError):
159242:             m.add_optional_exists('o_dest')
159242: 
152885:     def _get_test_manifest(self):
152885:         m = InstallManifest()
152885:         m.add_symlink(self.tmppath('s_source'), 's_dest')
152885:         m.add_copy(self.tmppath('c_source'), 'c_dest')
152885:         m.add_required_exists('e_dest')
159242:         m.add_optional_exists('o_dest')
152885: 
152885:         return m
152885: 
152885:     def test_serialization(self):
152885:         m = self._get_test_manifest()
152885: 
152885:         p = self.tmppath('m')
152885:         m.write(path=p)
152885:         self.assertTrue(os.path.isfile(p))
152885: 
152885:         with open(p, 'rb') as fh:
152885:             c = fh.read()
152885: 
176554:         self.assertEqual(c.count('\n'), 5)
152885: 
152885:         lines = c.splitlines()
176554:         self.assertEqual(len(lines), 5)
152885: 
176554:         self.assertEqual(lines[0], '2')
176554:         self.assertEqual(lines[1], '2\x1fc_dest\x1f%s' %
176554:             self.tmppath('c_source'))
176554:         self.assertEqual(lines[2], '3\x1fe_dest')
176554:         self.assertEqual(lines[3], '4\x1fo_dest')
176554:         self.assertEqual(lines[4], '1\x1fs_dest\x1f%s' %
176554:             self.tmppath('s_source'))
152885: 
152885:         m2 = InstallManifest(path=p)
152885:         self.assertEqual(m, m2)
152885:         p2 = self.tmppath('m2')
152885:         m2.write(path=p2)
152885: 
152885:         with open(p2, 'rb') as fh:
152885:             c2 = fh.read()
152885: 
152885:         self.assertEqual(c, c2)
152885: 
152885:     def test_populate_registry(self):
152885:         m = self._get_test_manifest()
152885:         r = FileRegistry()
152885:         m.populate_registry(r)
152885: 
159242:         self.assertEqual(len(r), 4)
159242:         self.assertEqual(r.paths(), ['c_dest', 'e_dest', 'o_dest', 's_dest'])
152885: 
152885:     def test_or(self):
152885:         m1 = self._get_test_manifest()
152885:         m2 = InstallManifest()
152885:         m2.add_symlink('s_source2', 's_dest2')
152885:         m2.add_copy('c_source2', 'c_dest2')
152885: 
152885:         m1 |= m2
152885: 
152885:         self.assertEqual(len(m2), 2)
176554:         self.assertEqual(len(m1), 6)
152885: 
152885:         self.assertIn('s_dest2', m1)
152885:         self.assertIn('c_dest2', m1)
152885: 
152885:     def test_copier_application(self):
152885:         dest = self.tmppath('dest')
152885:         os.mkdir(dest)
152885: 
152885:         to_delete = self.tmppath('dest/to_delete')
152885:         with open(to_delete, 'a'):
152885:             pass
152885: 
152885:         with open(self.tmppath('s_source'), 'wt') as fh:
152885:             fh.write('symlink!')
152885: 
152885:         with open(self.tmppath('c_source'), 'wt') as fh:
152885:             fh.write('copy!')
152885: 
152885:         with open(self.tmppath('dest/e_dest'), 'a'):
152885:             pass
152885: 
159242:         with open(self.tmppath('dest/o_dest'), 'a'):
159242:             pass
159242: 
152885:         m = self._get_test_manifest()
152885:         c = FileCopier()
152885:         m.populate_registry(c)
152886:         result = c.copy(dest)
152885: 
152885:         self.assertTrue(os.path.exists(self.tmppath('dest/s_dest')))
152885:         self.assertTrue(os.path.exists(self.tmppath('dest/c_dest')))
152885:         self.assertTrue(os.path.exists(self.tmppath('dest/e_dest')))
159242:         self.assertTrue(os.path.exists(self.tmppath('dest/o_dest')))
152885:         self.assertFalse(os.path.exists(to_delete))
152885: 
152885:         with open(self.tmppath('dest/s_dest'), 'rt') as fh:
152885:             self.assertEqual(fh.read(), 'symlink!')
152885: 
152885:         with open(self.tmppath('dest/c_dest'), 'rt') as fh:
152885:             self.assertEqual(fh.read(), 'copy!')
152885: 
152886:         self.assertEqual(result.updated_files, set(self.tmppath(p) for p in (
152894:             'dest/s_dest', 'dest/c_dest')))
152894:         self.assertEqual(result.existing_files,
159242:             set([self.tmppath('dest/e_dest'), self.tmppath('dest/o_dest')]))
152886:         self.assertEqual(result.removed_files, {to_delete})
152886:         self.assertEqual(result.removed_directories, set())
152886: 
152886: 
152886: 
152885: 
150467: if __name__ == '__main__':
150467:     mozunit.main()
