16299: /*
16299:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16299:    Organisation (CSIRO) Australia
16299: 
16299:    Redistribution and use in source and binary forms, with or without
16299:    modification, are permitted provided that the following conditions
16299:    are met:
16299: 
16299:    - Redistributions of source code must retain the above copyright
16299:    notice, this list of conditions and the following disclaimer.
16299: 
16299:    - Redistributions in binary form must reproduce the above copyright
16299:    notice, this list of conditions and the following disclaimer in the
16299:    documentation and/or other materials provided with the distribution.
16299: 
16299:    - Neither the name of CSIRO Australia nor the names of its
16299:    contributors may be used to endorse or promote products derived from
16299:    this software without specific prior written permission.
16299: 
16299:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16299:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16299:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16299:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16299:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16299:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16299:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16299:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16299:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16299:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16299:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16299: */
16299: 
16299: /*
16299:  * oggplay.c
16299:  *
16299:  * Shane Stephens <shane.stephens@annodex.net>
16299:  * Michael Martin
16299:  */
16299: 
16299: #include "oggplay_private.h"
16299: #include "oggplay_buffer.h"
16299: 
16299: #include <string.h>
16299: #include <stdlib.h>
16299: 
16299: #define OGGZ_READ_CHUNK_SIZE 8192
16299: 
16299: OggPlay *
16299: oggplay_new_with_reader(OggPlayReader *reader) {
16299: 
25830:   OggPlay * me = NULL;
25830: 
25830:   /* check whether the reader is valid. */
25830:   if (reader == NULL)
25830:     return NULL;
25830: 
25830:   me = (OggPlay *)oggplay_malloc (sizeof(OggPlay));
25830:   if (me == NULL)
25830: 	  return NULL;
16299: 
16299:   me->reader = reader;
16299:   me->decode_data = NULL;
16299:   me->callback_info = NULL;
16299:   me->num_tracks = 0;
16299:   me->all_tracks_initialised = 0;
16299:   me->callback_period = 0;
16299:   me->callback = NULL;
16299:   me->target = 0L;
16299:   me->active_tracks = 0;
16299:   me->buffer = NULL;
16299:   me->shutdown = 0;
16299:   me->trash = NULL;
16299:   me->oggz = NULL;
16299:   me->pt_update_valid = 1;
25689:   me->duration = -1;
33412:   me->max_video_frame_pixels = OGGPLAY_TYPE_MAX_SIGNED(int);
16299: 
16299:   return me;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_initialise(OggPlay *me, int block) {
16299: 
16299:   OggPlayErrorCode  return_val;
16299:   int               i;
16299: 
33012:   if (me == NULL) {
33012:     return E_OGGPLAY_BAD_OGGPLAY;
33012:   }
33012:   
16299:   return_val = me->reader->initialise(me->reader, block);
16299: 
16299:   if (return_val != E_OGGPLAY_OK) {
16299:     return return_val;
16299:   }
16299: 
16299:   /*
16299:    * this is the cut-off time value below which packets will be ignored.  Initialise it to 0 here.
16299:    * We'll reinitialise it when/if we encounter a skeleton header
16299:    */
16299:   me->presentation_time = 0;
16299: 
16299:   /*
16299:    * start to retrieve data, until we get all of the track info.  We need
16299:    * to do this now so that the user can query us for this info before entering
16299:    * the main loop
16299:    */
16299:   me->oggz = oggz_new(OGGZ_READ | OGGZ_AUTO);
25830:   if (me->oggz == NULL)
25830:     return E_OGGPLAY_OGGZ_UNHAPPY;
25830: 
25830:   if (oggz_io_set_read(me->oggz, me->reader->io_read, me->reader) != 0)
25830:     return E_OGGPLAY_OGGZ_UNHAPPY;
25830: 
25830:   if (oggz_io_set_seek(me->oggz, me->reader->io_seek, me->reader) != 0)
25830:     return E_OGGPLAY_OGGZ_UNHAPPY;
25830: 
25830:   if (oggz_io_set_tell(me->oggz, me->reader->io_tell, me->reader) != 0)
25830:     return E_OGGPLAY_OGGZ_UNHAPPY;
25830: 
25830:   if (oggz_set_read_callback(me->oggz, -1, oggplay_callback_predetected, me))
25830:     return E_OGGPLAY_OGGZ_UNHAPPY;
16299: 
16299:   while (1) {
33012:     i = oggz_read (me->oggz, OGGZ_READ_CHUNK_SIZE);
16299:     
33012:     switch (i) {
33012:       case 0:
33012:         /* 
33012:          * EOF reached while processing headers,
33012:          * possible erroneous file, mark it as such.
33012:          */
33012:       case OGGZ_ERR_HOLE_IN_DATA:
33012:         /* there was a whole in the data */
16299:         return E_OGGPLAY_BAD_INPUT;
33012:       
33012:       case OGGZ_ERR_OUT_OF_MEMORY:
33012:         /* ran out of memory during decoding! */
33012:         return E_OGGPLAY_OUT_OF_MEMORY;
33012:       
33012:       case OGGZ_ERR_STOP_ERR:
33012:         /* */
33012:         return E_OGGPLAY_BAD_OGGPLAY;
33012: 
33012:       default:
33012:         /* If the read otherwise failed, bail out. */
33012:         if (i < 0)
33012:           return E_OGGPLAY_BAD_INPUT;
33012:         break;
16299:     }
16299: 
16299:     if (me->all_tracks_initialised) {
16299:       break;
16299:     }
16299:   }
16299: 
16299:   /*
16299:    * set all the tracks to inactive
16299:    */
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     me->decode_data[i]->active = 0;
16299:   }
32145:   me->active_tracks = 0;
16299: 
16299:   /*
16299:    * if the buffer was set up before initialisation, prepare it now
16299:    */
16299:   if (me->buffer != NULL) {
16299:     oggplay_buffer_prepare(me);
16299:   }
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlay *
16299: oggplay_open_with_reader(OggPlayReader *reader) {
16299: 
25830:   OggPlay *me = NULL;
25830:   int r = E_OGGPLAY_TIMEOUT;
25791: 
25830:   if ((me = oggplay_new_with_reader(reader)) == NULL)
25830:     return NULL;
25830: 
16299:   while (r == E_OGGPLAY_TIMEOUT) {
16299:     r = oggplay_initialise(me, 0);
16299:   }
16299: 
16299:   if (r != E_OGGPLAY_OK) {
33012:     
25830:     /* in case of error close the OggPlay handle */
25830:     oggplay_close(me);
25830: 
16299:     return NULL;
16299:   }
16299: 
16299:   return me;
16299: }
16299: 
16299: /*
16299:  * API function to prevent bad input, and to prevent data callbacks being registered
16299:  * in buffer mode
16299:  */
16299: OggPlayErrorCode
16299: oggplay_set_data_callback(OggPlay *me, OggPlayDataCallback callback,
16299:                           void *user) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->buffer != NULL) {
16299:     return E_OGGPLAY_BUFFER_MODE;
16299:   }
16299: 
16299:   oggplay_set_data_callback_force(me, callback, user);
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: /*
16299:  * internal function that doesn't perform error checking.  Used so the buffer
16299:  * can register a callback!
16299:  */
16299: void
16299: oggplay_set_data_callback_force(OggPlay *me, OggPlayDataCallback callback,
16299:                                 void *user) {
16299: 
16299:   me->callback = callback;
16299:   me->callback_user_ptr = user;
16299: 
16299: }
16299: 
16299: 
16299: OggPlayErrorCode
16299: oggplay_set_callback_num_frames(OggPlay *me, int track, int frames) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   me->callback_period = me->decode_data[track]->granuleperiod * frames;
16299:   me->target = me->presentation_time + me->callback_period - 1;
16299: 
26904:   return E_OGGPLAY_OK;
26904: }
26904: 
26904: OggPlayErrorCode
26904: oggplay_set_callback_period(OggPlay *me, int track, int milliseconds) {
26904: 
26904:   if (me == NULL) {
26904:     return E_OGGPLAY_BAD_OGGPLAY;
26904:   }
26904: 
26904:   if (track < 0 || track >= me->num_tracks) {
26904:     return E_OGGPLAY_BAD_TRACK;
26904:   }
26904: 
26904:   me->callback_period = OGGPLAY_TIME_INT_TO_FP(((ogg_int64_t)milliseconds))/1000;
26904:   me->target = me->presentation_time + me->callback_period - 1;
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_set_offset(OggPlay *me, int track, ogg_int64_t offset) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
26904:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
26904:   me->decode_data[track]->offset = OGGPLAY_TIME_INT_TO_FP(offset) / 1000;
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_get_video_fps(OggPlay *me, int track, int* fps_denom, int* fps_num) {
16299:   OggPlayTheoraDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
16299: 
16299:   if ((decode->video_info.fps_denominator == 0)
16299:     || (decode->video_info.fps_numerator == 0)) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   (*fps_denom) = decode->video_info.fps_denominator;
16299:   (*fps_num) = decode->video_info.fps_numerator;
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
16299: 
16299: OggPlayErrorCode
28534: oggplay_get_video_aspect_ratio(OggPlay *me, int track, int* aspect_denom, int* aspect_num) {
28534:   OggPlayTheoraDecode *decode;
28534: 
28534:   if (me == NULL) {
28534:     return E_OGGPLAY_BAD_OGGPLAY;
28534:   }
28534: 
28534:   if (track < 0 || track >= me->num_tracks) {
28534:     return E_OGGPLAY_BAD_TRACK;
28534:   }
28534: 
28534:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
28534:     return E_OGGPLAY_WRONG_TRACK_TYPE;
28534:   }
28534: 
28534:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
28534: 
28534:   if ((decode->video_info.aspect_denominator == 0)
28534:     || (decode->video_info.aspect_numerator == 0)) {
28534:     return E_OGGPLAY_UNINITIALISED;
28534:   }
28534: 
28534:   (*aspect_denom) = decode->video_info.aspect_denominator;
28534:   (*aspect_num) = decode->video_info.aspect_numerator;
28534: 
28534:   return E_OGGPLAY_OK;
28534: }
28534: 
28534: OggPlayErrorCode
33012: oggplay_convert_video_to_rgb(OggPlay *me, int track, int convert, int swap_rgb) {
26904:   OggPlayTheoraDecode *decode;
26904: 
26904:   if (me == NULL) {
26904:     return E_OGGPLAY_BAD_OGGPLAY;
26904:   }
26904: 
26904:   if (track < 0 || track >= me->num_tracks) {
26904:     return E_OGGPLAY_BAD_TRACK;
26904:   }
26904: 
26904:   if (me->decode_data[track]->content_type != OGGZ_CONTENT_THEORA) {
26904:     return E_OGGPLAY_WRONG_TRACK_TYPE;
26904:   }
26904: 
26904:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
26904: 
33012:   if (decode->convert_to_rgb != convert || decode->swap_rgb != swap_rgb) {
26904:     decode->convert_to_rgb = convert;
33012:     decode->swap_rgb = swap_rgb;
26904:     me->decode_data[track]->decoded_type = convert ? OGGPLAY_RGBA_VIDEO : OGGPLAY_YUV_VIDEO;
26904: 
26904:     /* flush any records created with previous type */
26904:     oggplay_data_free_list(me->decode_data[track]->data_list);
26904:     me->decode_data[track]->data_list = NULL;
26904:   }
26904: 
26904:   return E_OGGPLAY_OK;
26904: }
26904: 
26904: OggPlayErrorCode
16299: oggplay_get_video_y_size(OggPlay *me, int track, int *y_width, int *y_height) {
16299: 
16299:   OggPlayTheoraDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->y_width == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   (*y_width) = decode->y_width;
16299:   (*y_height) = decode->y_height;
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_get_video_uv_size(OggPlay *me, int track, int *uv_width, int *uv_height)
16299: {
16299: 
16299:   OggPlayTheoraDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->y_width == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   (*uv_width) = decode->uv_width;
16299:   (*uv_height) = decode->uv_height;
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
26904: OggPlayErrorCode
16299: oggplay_get_audio_channels(OggPlay *me, int track, int* channels) {
16299: 
16299:   OggPlayAudioDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_FLOATS_AUDIO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayAudioDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->sound_info.channels == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299:   (*channels) = decode->sound_info.channels;
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
26904: OggPlayErrorCode
16299: oggplay_get_audio_samplerate(OggPlay *me, int track, int* rate) {
16299: 
16299:   OggPlayAudioDecode * decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_FLOATS_AUDIO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayAudioDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->sound_info.channels == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299:   (*rate) = decode->sound_info.samplerate;
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
26904: OggPlayErrorCode
16299: oggplay_get_kate_category(OggPlay *me, int track, const char** category) {
16608: 
16299:   OggPlayKateDecode * decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
26904:   if (me->decode_data[track]->content_type != OGGZ_CONTENT_KATE) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayKateDecode *)(me->decode_data[track]);
16299: 
16608: #ifdef HAVE_KATE
33012:   if (decode->decoder.initialised) {
33012:     (*category) = decode->k_state.ki->category;
16299:     return E_OGGPLAY_OK;
26904:   }
26904:   else return E_OGGPLAY_UNINITIALISED;
16299: #else
16299:   return E_OGGPLAY_NO_KATE_SUPPORT;
16299: #endif
16299: }
16299: 
26904: OggPlayErrorCode
16299: oggplay_get_kate_language(OggPlay *me, int track, const char** language) {
16299: 
16299:   OggPlayKateDecode * decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
26904:   if (me->decode_data[track]->content_type != OGGZ_CONTENT_KATE) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayKateDecode *)(me->decode_data[track]);
16299: 
16299: #ifdef HAVE_KATE
33012:   if (decode->decoder.initialised) {
33012:     (*language) = decode->k_state.ki->language;
16299:     return E_OGGPLAY_OK;
26904:   }
26904:   else return E_OGGPLAY_UNINITIALISED;
26904: #else
26904:   return E_OGGPLAY_NO_KATE_SUPPORT;
26904: #endif
26904: }
26904: 
26904: OggPlayErrorCode
33012: oggplay_set_kate_tiger_rendering(OggPlay *me, int track, int use_tiger, int swap_rgb, int default_width, int default_height) {
26904: 
26904:   OggPlayKateDecode * decode;
26904: 
26904:   if (me == NULL) {
26904:     return E_OGGPLAY_BAD_OGGPLAY;
26904:   }
26904: 
26904:   if (track < 0 || track >= me->num_tracks) {
26904:     return E_OGGPLAY_BAD_TRACK;
26904:   }
26904: 
26904:   if (me->decode_data[track]->content_type != OGGZ_CONTENT_KATE) {
26904:     return E_OGGPLAY_WRONG_TRACK_TYPE;
26904:   }
26904: 
26904:   decode = (OggPlayKateDecode *)(me->decode_data[track]);
26904: 
26904: #ifdef HAVE_KATE
26904: #ifdef HAVE_TIGER
33012:   if (decode->decoder.initialised && decode->tr) {
26904:     decode->use_tiger = use_tiger;
33012:     decode->swap_rgb = swap_rgb;
33012:     decode->default_width = default_width;
33012:     decode->default_height = default_height;
26904:     decode->decoder.decoded_type = use_tiger ? OGGPLAY_RGBA_VIDEO : OGGPLAY_KATE;
26904:     return E_OGGPLAY_OK;
26904:   }
26904:   else return E_OGGPLAY_UNINITIALISED;
26904: #else
26904:   return E_OGGPLAY_NO_TIGER_SUPPORT;
26904: #endif
26904: #else
26904:   return E_OGGPLAY_NO_KATE_SUPPORT;
26904: #endif
26904: }
26904: 
26904: OggPlayErrorCode
26904: oggplay_overlay_kate_track_on_video(OggPlay *me, int kate_track, int video_track) {
26904: 
26904:   OggPlayKateDecode * decode;
26904: 
26904:   if (me == NULL) {
26904:     return E_OGGPLAY_BAD_OGGPLAY;
26904:   }
26904: 
26904:   if (kate_track < 0 || kate_track >= me->num_tracks) {
26904:     return E_OGGPLAY_BAD_TRACK;
26904:   }
26904:   if (video_track < 0 || video_track >= me->num_tracks) {
26904:     return E_OGGPLAY_BAD_TRACK;
26904:   }
26904: 
26904:   if (me->decode_data[kate_track]->content_type != OGGZ_CONTENT_KATE) {
26904:     return E_OGGPLAY_WRONG_TRACK_TYPE;
26904:   }
26904: 
26904:   if (me->decode_data[kate_track]->decoded_type != OGGPLAY_RGBA_VIDEO) {
26904:     return E_OGGPLAY_WRONG_TRACK_TYPE;
26904:   }
26904: 
26904:   if (me->decode_data[video_track]->content_type != OGGZ_CONTENT_THEORA) {
26904:     return E_OGGPLAY_WRONG_TRACK_TYPE;
26904:   }
26904: 
26904:   if (me->decode_data[video_track]->decoded_type != OGGPLAY_RGBA_VIDEO) {
26904:     return E_OGGPLAY_WRONG_TRACK_TYPE;
26904:   }
26904: 
26904:   decode = (OggPlayKateDecode *)(me->decode_data[kate_track]);
26904: 
26904: #ifdef HAVE_KATE
26904: #ifdef HAVE_TIGER
26904:   decode->overlay_dest = video_track;
26904:   return E_OGGPLAY_OK;
26904: #else
26904:   return E_OGGPLAY_NO_TIGER_SUPPORT;
26904: #endif
16299: #else
16299:   return E_OGGPLAY_NO_KATE_SUPPORT;
16299: #endif
16299: }
16299: 
16299: #define MAX_CHUNK_COUNT   10
16299: 
16299: OggPlayErrorCode
16299: oggplay_step_decoding(OggPlay *me) {
16299: 
16299:   OggPlayCallbackInfo  ** info;
16299:   int                     num_records;
16299:   int                     r;
16299:   int                     i;
16299:   int                     need_data  = 0;
16299:   int                     chunk_count = 0;
33825:   int                     read_data = 0;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299:   
16299:   /* 
33012:    * check whether the OggPlayDataCallback is set for the given
33012:    * OggPlay handle. If not return with error as there's no callback 
33012:    * function processing the decoded data.
33012:    */
33012:   if (me->callback == NULL) {
33012:     return E_OGGPLAY_UNINITIALISED;
33012:   }
33012: 
33012:   /*
16299:    * clean up any trash pointers.  As soon as the current buffer has a
16299:    * frame taken out, we know the old buffer will no longer be used.
16299:    */
16299: 
33012:   if 
33012:   (
33012:     me->trash != NULL 
33012:     && 
33012:     (me->buffer == NULL || me->buffer->last_emptied > -1)
33012:   ) 
33012:   {
16299:     oggplay_take_out_trash(me, me->trash);
16299:     me->trash = NULL;
16299:   }
16299: 
16299: read_more_data:
16299: 
16299:   while (1) {
16299:      /*
16299:      * if there are no active tracks, we might need to return some data
16299:      * left over at the end of a once-active track that has had all of its
16299:      * data processed.  Look through the tracks to find these overhangs
16299:      */
16299:     int r;
16299: 
16299:     if (me->active_tracks == 0) {
16299:       int remaining = 0;
16299:       for (i = 0; i < me->num_tracks; i++) {
16299:         if (me->decode_data[i]->current_loc +
16299:                      me->decode_data[i]->granuleperiod >= me->target + me->decode_data[i]->offset) {
16299:           remaining++;
16299:         }
16299:       }
33825:       if (remaining == 0 && !read_data) {
33825:         /*
33825:          * There's no more data to read, and we've not read any that needs 
33825:          * to be sent to the buffer list via a callback, so exit.
33825:          */
16299:         return E_OGGPLAY_OK;
16299:       }
16299:     }
16299: 
16299:     /*
16299:      * if any of the tracks have not yet met the target (modified by that
16299:      * track's offset), then retrieve more data
16299:      */
16299:     need_data = 0;
16299:     for (i = 0; i < me->num_tracks; i++) {
16299:       if (me->decode_data[i]->active == 0)
16299:         continue;
16299:       if (me->decode_data[i]->content_type == OGGZ_CONTENT_CMML)
16299:         continue;
16299:       if (me->decode_data[i]->content_type == OGGZ_CONTENT_KATE)
16299:         continue;
16299:       if
16299:       (
16299:         me->decode_data[i]->current_loc
16299:         <
16299:         me->target + me->decode_data[i]->offset
16299:       )
16299:       {
16299:         need_data = 1;
16299:         break;
16299:       }
16299:     }
16299: 
16299:     if (!need_data) {
16299:       break;
16299:     }
16299: 
16299:     /*
16299:      * get a chunk of data.  If we're at the end of the file, then we must
16299:      * have some final frames to render (?).  E_OGGPLAY_END_OF_FILE is
16299:      * only returned if there is *no* more data.
16299:      */
16299: 
16299:     if (chunk_count > MAX_CHUNK_COUNT) {
16299:       return E_OGGPLAY_TIMEOUT;
16299:     }
16299: 
16299:     chunk_count += 1;
16299: 
16299:     r = oggz_read(me->oggz, OGGZ_READ_CHUNK_SIZE);
16299: 
33012:     switch (r) {
33012:       case 0:
16299:         /* end-of-file */
33012:         
16299:         num_records = oggplay_callback_info_prepare(me, &info);
16299:         /*
25689:         * set all of the tracks to inactive
16299:         */
16299:         for (i = 0; i < me->num_tracks; i++) {
16299:           me->decode_data[i]->active = 0;
30887:         }
16299:         me->active_tracks = 0;
16299: 
16299:         if (info != NULL) {
33855:           /* ensure all tracks have their final data packet set to end_of_stream */
33855:           OggPlayCallbackInfo *p = info[0];
33855:           for (i = 0; i < me->num_tracks; i++) {
33855:             p->stream_info = OGGPLAY_STREAM_LAST_DATA;
33855:             p++;
33855:           }
33855: 
16299:           me->callback (me, num_records, info, me->callback_user_ptr);
16299:           oggplay_callback_info_destroy(me, info);
16299:         }
16299: 
33012:         /* we reached the end of the stream */
16299:         return E_OGGPLAY_OK;
33012:               
33012:       case OGGZ_ERR_HOLE_IN_DATA:
33012:         /* there was a whole in the data */
32145:         return E_OGGPLAY_BAD_INPUT;
33012: 
33012:       case OGGZ_ERR_STOP_ERR:
33012:         /* 
33012:          * one of the callback functions requested us to stop.
33012:          * as this currently happens only when one of the 
33012:          * OggzReadPacket callback functions does not receive
33012:          * the user provided data, i.e. the OggPlayDecode struct
33012:          * for the track mark it as a memory problem, since this
33012:          * could happen only if something is wrong with the memory,
33012:          * e.g. some buffer overflow.
33012:          */
33012:       
33012:       case OGGZ_ERR_OUT_OF_MEMORY:
33012:         /* ran out of memory during decoding! */
33012:         return E_OGGPLAY_OUT_OF_MEMORY;
33012:                 
33012:       default:
33825:         /*
33825:          * We read some data. Set a flag so that we're guaranteed to try to
33825:          * send it to the buffer list via a callback.
33825:          */
33825:         read_data = 1;
33012:         break;
32145:     }
16299:   }
16299:   /*
16299:    * prepare a callback
16299:    */
16299:   num_records = oggplay_callback_info_prepare (me, &info);
16299:   if (info != NULL) {
16299:     r = me->callback (me, num_records, info, me->callback_user_ptr);
16299:     oggplay_callback_info_destroy (me, info);
16299:   } else {
16299:     r = 0;
16299:   }
16299: 
16299:   /*
16299:    * clean the data lists
16299:    */
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     oggplay_data_clean_list (me->decode_data[i]);
16299:   }
16299:   
33012:   /* 
33012:    * there was an error during info prepare!
33012:    * abort decoding! 
33012:    */
33012:   if (num_records < 0) {
33012:     return num_records;
33012:   }
33012:   
33012:   /* if we received an shutdown event, dont try to read more data...*/
28230:   if (me->shutdown) {
28230:     return E_OGGPLAY_OK;
28230:   }
28230:   
33012:   /* we require more data for decoding */
16299:   if (info == NULL) {
16299:     goto read_more_data;
16299:   }
16299: 
16299:   me->target += me->callback_period;
16299:   if (r == -1) {
16299:     return E_OGGPLAY_USER_INTERRUPT;
16299:   }
16299: 
16299:   return E_OGGPLAY_CONTINUE;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_start_decoding(OggPlay *me) {
16299: 
16299:   int r;
16299: 
16299:   while (1) {
25689:     r = oggplay_step_decoding(me);
25689:     if (r == E_OGGPLAY_CONTINUE || r == E_OGGPLAY_TIMEOUT) {
25689:       continue;
25689:     }
16299:     return (OggPlayErrorCode)r;
16299:   }
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_close(OggPlay *me) {
16299: 
16299:   int i;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader != NULL) {
16299:     me->reader->destroy(me->reader);
16299:   }
16299: 
33012:   /* */
33012:   if (me->decode_data != NULL) {
16299:     for (i = 0; i < me->num_tracks; i++) {
16299:       oggplay_callback_shutdown(me->decode_data[i]);
16299:     }
25830:   }
16299: 
25830:   if (me->oggz)
16299:     oggz_close(me->oggz);
16299: 
16299:   if (me->buffer != NULL) {
16299:     oggplay_buffer_shutdown(me, me->buffer);
16299:   }
16299: 
33012:   if (me->callback_info != NULL) {
26904:     oggplay_free(me->callback_info);
33012:   }
33012:     
26904:   oggplay_free(me->decode_data);
25830:   oggplay_free(me);
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
16299: 
16299: /*
16299:  * this function is required to release the frame_sem in the buffer, if
16299:  * the buffer is being used.
16299:  */
16299: void
16299: oggplay_prepare_for_close(OggPlay *me) {
16299: 
16299:   me->shutdown = 1;
16299:   if (me->buffer != NULL) {
16299:     SEM_SIGNAL(((OggPlayBuffer *)(me->buffer))->frame_sem);
16299:   }
16299: }
16299: 
16299: int
16299: oggplay_get_available(OggPlay *me) {
16299: 
16299:   ogg_int64_t current_time, current_byte;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   current_time = oggz_tell_units(me->oggz);
16299:   current_byte = (ogg_int64_t)oggz_tell(me->oggz);
16299: 
16299:   return me->reader->available(me->reader, current_byte, current_time);
16299: 
16299: }
16299: 
21265: ogg_int64_t
16299: oggplay_get_duration(OggPlay *me) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
25689:   /* If the reader has a duration function we always call that
25689:    * function to find the duration. We never cache the result
25689:    * of that function.
25689:    *
25689:    * If there is no reader duration function we use our cached
25689:    * duration value, or do a liboggz seek to find it and cache
25689:    * that.
25689:    */
25689:   if (me->reader->duration) {
25689:       ogg_int64_t d = me->reader->duration(me->reader);
25689:       if (d >= 0) {
25689:         me->duration = d;
25689:       }
25689:   }
25689: 
25689:   if (me->duration < 0) {
21541:     ogg_int64_t pos;
21541:     pos = oggz_tell_units(me->oggz);
25689:     me->duration = oggz_seek_units(me->oggz, 0, SEEK_END);
21265:     oggz_seek_units(me->oggz, pos, SEEK_SET);
21541:     oggplay_seek_cleanup(me, pos);
21265:   }
25689: 
25689:   return me->duration;
16299: }
16299: 
16299: int
16299: oggplay_media_finished_retrieving(OggPlay *me) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return E_OGGPLAY_BAD_READER;
16299:   }
16299: 
16299:   return me->reader->finished_retrieving(me->reader);
16299: 
16299: }
25830: 
33412: int
33412: oggplay_set_max_video_frame_pixels(OggPlay *player,
33412:                                    int max_frame_pixels) {
33412:   if (!player)
33412:     return E_OGGPLAY_BAD_OGGPLAY;
33412:   player->max_video_frame_pixels = max_frame_pixels;
33412:   return E_OGGPLAY_OK;
33412: }
