     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  * vim: set ts=2 sw=2 et tw=78:
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     1:  *
     1:  * This Original Code has been modified by IBM Corporation.
     1:  * Modifications made by IBM described herein are
     1:  * Copyright (c) International Business Machines
     1:  * Corporation, 2000
     1:  *
     1:  * Modifications to Mozilla code or documentation
     1:  * identified per MPL Section 3.3
     1:  *
     1:  * Date         Modified by     Description of modification
     1:  * 05/03/2000   IBM Corp.       Observer events for reflow states
     1:  */
     1: 
     1: /* a presentation of a document, part 2 */
     1: 
 80737: #include "mozilla/dom/PBrowserChild.h"
 80737: #include "mozilla/dom/TabChild.h"
 80467: #include "mozilla/Util.h"
 80467: 
 83033: #ifdef XP_WIN
 83033: #include "winuser.h"
 83033: #endif
 83033: 
 78155: #include "nsPresShell.h"
     1: #include "nsPresContext.h"
     1: #include "nsIContent.h"
 41930: #include "mozilla/dom/Element.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMXULDocument.h"
 42163: #include "nsCSSStyleSheet.h" // XXX for UA sheet loading hack, can this go away please?
     1: #include "nsIDOMCSSStyleSheet.h"  // for Pref-related rule management (bugs 22963,20760,31816)
 67985: #include "nsAnimationManager.h"
     1: #include "nsINameSpaceManager.h"  // for Pref-related rule management (bugs 22963,20760,31816)
     1: #include "nsIServiceManager.h"
     1: #include "nsFrame.h"
 82566: #include "nsViewManager.h"
 82566: #include "nsView.h"
     1: #include "nsCRTGlue.h"
     1: #include "prlog.h"
     1: #include "prmem.h"
     1: #include "prprf.h"
     1: #include "prinrval.h"
 24551: #include "nsTArray.h"
     1: #include "nsCOMArray.h"
     1: #include "nsHashtable.h"
     1: #include "nsContainerFrame.h"
     1: #include "nsDOMEvent.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsISelection.h"
     1: #include "nsISelectionPrivate.h"
101616: #include "mozilla/Selection.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIDOMRange.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsRange.h"
     1: #include "nsCSSPseudoElements.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsIPageSequenceFrame.h"
 15969: #include "nsCaret.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMXMLDocument.h"
     1: #include "nsViewsCID.h"
     1: #include "nsFrameManager.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsXPCOM.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsILayoutHistoryState.h"
     1: #include "nsILineIterator.h" // for ScrollContentIntoView
     1: #include "nsWeakPtr.h"
     1: #include "pldhash.h"
 87650: #include "nsDOMTouchEvent.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIDocShell.h"        // for reflow observation
     1: #include "nsIBaseWindow.h"
     1: #include "nsLayoutErrors.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsCSSRendering.h"
     1:   // for |#ifdef DEBUG| code
     1: #include "prenv.h"
 72953: #include "nsAlgorithm.h"
     1: #include "nsIAttribute.h"
     1: #include "nsIGlobalHistory2.h"
     1: #include "nsDisplayList.h"
     1: #include "nsRegion.h"
 68487: #include "nsRenderingContext.h"
 75018: #include "nsAutoLayoutPhase.h"
 27962: #ifdef MOZ_REFLOW_PERF
 68493: #include "nsFontMetrics.h"
     1: #endif
     1: 
     1: #include "nsIReflowCallback.h"
     1: 
     1: #include "nsPIDOMWindow.h"
 29018: #include "nsFocusManager.h"
 70007: #include "nsNPAPIPluginInstance.h"
     1: #include "nsIObjectFrame.h"
     1: #include "nsIObjectLoadingContent.h"
     1: #include "nsNetUtil.h"
     1: #include "nsEventDispatcher.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsStyleSheetService.h"
     1: #include "gfxImageSurface.h"
     1: #include "gfxContext.h"
 15753: #ifdef MOZ_MEDIA
 21006: #include "nsHTMLMediaElement.h"
 15753: #endif
 38870: #include "nsSMILAnimationController.h"
 98726: #include "nsSVGUtils.h"
 98726: #include "SVGFragmentIdentifier.h"
     1: 
 50698: #include "nsRefreshDriver.h"
 50698: 
     1: // Drag & Drop, Clipboard
     1: #include "nsWidgetsCID.h"
     1: #include "nsIClipboard.h"
     1: #include "nsIClipboardHelper.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIURI.h"
     1: #include "nsIScrollableFrame.h"
     1: #include "prtime.h"
     1: #include "prlong.h"
     1: #include "nsIDragService.h"
     1: #include "nsCopySupport.h"
     1: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsIDOMHTMLAreaElement.h"
     1: #include "nsIDOMHTMLLinkElement.h"
     1: #include "nsITimer.h"
     1: #ifdef ACCESSIBILITY
 61464: #include "nsAccessibilityService.h"
106800: #include "mozilla/a11y/DocAccessible.h"
106800: #ifdef DEBUG
106800: #include "mozilla/a11y/Logging.h"
106800: #endif
     1: #endif
     1: 
     1: // For style data reconstruction
     1: #include "nsStyleChangeList.h"
     1: #include "nsCSSFrameConstructor.h"
     1: #ifdef MOZ_XUL
  3129: #include "nsMenuFrame.h"
 20988: #include "nsTreeBodyFrame.h"
 23881: #include "nsIBoxObject.h"
 23881: #include "nsITreeBoxObject.h"
 23881: #include "nsMenuPopupFrame.h"
 23881: #include "nsITreeColumns.h"
 23881: #include "nsIDOMXULMultSelectCntrlEl.h"
 23881: #include "nsIDOMXULSelectCntrlItemEl.h"
 23881: #include "nsIDOMXULMenuListElement.h"
 23881: 
     1: #endif
     1: #include "nsPlaceholderFrame.h"
 34149: #include "nsCanvasFrame.h"
     1: 
     1: // Content viewer interfaces
     1: #include "nsIContentViewer.h"
  1735: #include "imgIEncoder.h"
  1735: #include "gfxPlatform.h"
     1: 
 42480: #include "mozilla/FunctionTimer.h"
 70840: #include "mozilla/Preferences.h"
 80773: #include "mozilla/Telemetry.h"
 84290: #include "sampler.h"
 42480: 
 48947: #include "Layers.h"
 84833: #include "nsAsyncDOMEvent.h"
 48947: 
 42480: #ifdef NS_FUNCTION_TIMER
 42480: #define NS_TIME_FUNCTION_DECLARE_DOCURL                \
 42480:   nsCAutoString docURL__("N/A");                       \
 42480:   nsIURI *uri__ = mDocument->GetDocumentURI();         \
 42480:   if (uri__) uri__->GetSpec(docURL__);
 42480: #define NS_TIME_FUNCTION_WITH_DOCURL                   \
 42480:   NS_TIME_FUNCTION_DECLARE_DOCURL                      \
 42480:   NS_TIME_FUNCTION_MIN_FMT(1.0,                        \
 42480:      "%s (line %d) (document: %s)", MOZ_FUNCTION_NAME, \
 42480:      __LINE__, docURL__.get())
 42480: #else
 42480: #define NS_TIME_FUNCTION_WITH_DOCURL do{} while(0)
 42480: #endif
 42480: 
 67816: #define ANCHOR_SCROLL_FLAGS (SCROLL_OVERFLOW_HIDDEN | SCROLL_NO_PARENT_FRAMES)
 62343: 
 47737: using namespace mozilla;
 48947: using namespace mozilla::dom;
 38805: using namespace mozilla::layers;
 38805: 
 57052: CapturingContentInfo nsIPresShell::gCaptureInfo =
 95203:   { false /* mAllowed */, false /* mPointerLock */, false /* mRetargetToElement */,
 80486:     false /* mPreventDrag */, nsnull /* mContent */ };
 50720: nsIContent* nsIPresShell::gKeyDownTarget;
 87650: nsInterfaceHashtable<nsUint32HashKey, nsIDOMTouch> nsIPresShell::gCaptureTouchList;
 87650: bool nsIPresShell::gPreventMouseEvents = false;
  1071: 
     1: // convert a color value to a string, in the CSS format #RRGGBB
     1: // *  - initially created for bugs 31816, 20760, 22963
     1: static void ColorToString(nscolor aColor, nsAutoString &aString);
     1: 
     1: // RangePaintInfo is used to paint ranges to offscreen buffers
     1: struct RangePaintInfo {
 86939:   nsRefPtr<nsRange> mRange;
     1:   nsDisplayListBuilder mBuilder;
     1:   nsDisplayList mList;
     1: 
     1:   // offset of builder's reference frame to the root frame
     1:   nsPoint mRootOffset;
     1: 
 86939:   RangePaintInfo(nsRange* aRange, nsIFrame* aFrame)
 80486:     : mRange(aRange), mBuilder(aFrame, nsDisplayListBuilder::PAINTING, false)
     1:   {
 43900:     MOZ_COUNT_CTOR(RangePaintInfo);
     1:   }
     1: 
     1:   ~RangePaintInfo()
     1:   {
     1:     mList.DeleteAll();
 43900:     MOZ_COUNT_DTOR(RangePaintInfo);
     1:   }
     1: };
     1: 
     1: #undef NOISY
     1: 
     1: // ----------------------------------------------------------------------
     1: 
102909: #ifdef DEBUG
     1: // Set the environment variable GECKO_VERIFY_REFLOW_FLAGS to one or
     1: // more of the following flags (comma separated) for handy debug
     1: // output.
     1: static PRUint32 gVerifyReflowFlags;
     1: 
     1: struct VerifyReflowFlags {
     1:   const char*    name;
     1:   PRUint32 bit;
     1: };
     1: 
     1: static const VerifyReflowFlags gFlags[] = {
     1:   { "verify",                VERIFY_REFLOW_ON },
     1:   { "reflow",                VERIFY_REFLOW_NOISY },
     1:   { "all",                   VERIFY_REFLOW_ALL },
     1:   { "list-commands",         VERIFY_REFLOW_DUMP_COMMANDS },
     1:   { "noisy-commands",        VERIFY_REFLOW_NOISY_RC },
     1:   { "really-noisy-commands", VERIFY_REFLOW_REALLY_NOISY_RC },
     1:   { "resize",                VERIFY_REFLOW_DURING_RESIZE_REFLOW },
     1: };
     1: 
     1: #define NUM_VERIFY_REFLOW_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
     1: 
     1: static void
     1: ShowVerifyReflowFlags()
     1: {
     1:   printf("Here are the available GECKO_VERIFY_REFLOW_FLAGS:\n");
     1:   const VerifyReflowFlags* flag = gFlags;
     1:   const VerifyReflowFlags* limit = gFlags + NUM_VERIFY_REFLOW_FLAGS;
     1:   while (flag < limit) {
     1:     printf("  %s\n", flag->name);
     1:     ++flag;
     1:   }
     1:   printf("Note: GECKO_VERIFY_REFLOW_FLAGS is a comma separated list of flag\n");
     1:   printf("names (no whitespace)\n");
     1: }
     1: #endif
     1: 
     1: //========================================================================
     1: //========================================================================
     1: //========================================================================
     1: #ifdef MOZ_REFLOW_PERF
     1: class ReflowCountMgr;
     1: 
     1: static const char kGrandTotalsStr[] = "Grand Totals";
     1: 
     1: // Counting Class
     1: class ReflowCounter {
     1: public:
     1:   ReflowCounter(ReflowCountMgr * aMgr = nsnull);
     1:   ~ReflowCounter();
     1: 
     1:   void ClearTotals();
     1:   void DisplayTotals(const char * aStr);
     1:   void DisplayDiffTotals(const char * aStr);
     1:   void DisplayHTMLTotals(const char * aStr);
     1: 
     1:   void Add()                { mTotal++;         }
     1:   void Add(PRUint32 aTotal) { mTotal += aTotal; }
     1: 
     1:   void CalcDiffInTotals();
     1:   void SetTotalsCache();
     1: 
     1:   void SetMgr(ReflowCountMgr * aMgr) { mMgr = aMgr; }
     1: 
     1:   PRUint32 GetTotal() { return mTotal; }
     1:   
     1: protected:
     1:   void DisplayTotals(PRUint32 aTotal, const char * aTitle);
     1:   void DisplayHTMLTotals(PRUint32 aTotal, const char * aTitle);
     1: 
     1:   PRUint32 mTotal;
     1:   PRUint32 mCacheTotal;
     1: 
     1:   ReflowCountMgr * mMgr; // weak reference (don't delete)
     1: };
     1: 
     1: // Counting Class
     1: class IndiReflowCounter {
     1: public:
     1:   IndiReflowCounter(ReflowCountMgr * aMgr = nsnull)
     1:     : mFrame(nsnull),
     1:       mCount(0),
     1:       mMgr(aMgr),
     1:       mCounter(aMgr),
 80486:       mHasBeenOutput(false)
     1:     {}
     1:   virtual ~IndiReflowCounter() {}
     1: 
     1:   nsAutoString mName;
     1:   nsIFrame *   mFrame;   // weak reference (don't delete)
     1:   PRInt32      mCount;
     1: 
     1:   ReflowCountMgr * mMgr; // weak reference (don't delete)
     1: 
     1:   ReflowCounter mCounter;
 79445:   bool          mHasBeenOutput;
     1: 
     1: };
     1: 
     1: //--------------------
     1: // Manager Class
     1: //--------------------
     1: class ReflowCountMgr {
     1: public:
     1:   ReflowCountMgr();
     1:   virtual ~ReflowCountMgr();
     1: 
     1:   void ClearTotals();
     1:   void ClearGrandTotals();
     1:   void DisplayTotals(const char * aStr);
     1:   void DisplayHTMLTotals(const char * aStr);
     1:   void DisplayDiffsInTotals(const char * aStr);
     1: 
     1:   void Add(const char * aName, nsIFrame * aFrame);
     1:   ReflowCounter * LookUp(const char * aName);
     1: 
 68487:   void PaintCount(const char *aName, nsRenderingContext* aRenderingContext,
 68487:                   nsPresContext *aPresContext, nsIFrame *aFrame,
 68487:                   const nsPoint &aOffset, PRUint32 aColor);
     1: 
     1:   FILE * GetOutFile() { return mFD; }
     1: 
     1:   PLHashTable * GetIndiFrameHT() { return mIndiFrameCounts; }
     1: 
     1:   void SetPresContext(nsPresContext * aPresContext) { mPresContext = aPresContext; } // weak reference
     1:   void SetPresShell(nsIPresShell* aPresShell) { mPresShell= aPresShell; } // weak reference
     1: 
 79445:   void SetDumpFrameCounts(bool aVal)         { mDumpFrameCounts = aVal; }
 79445:   void SetDumpFrameByFrameCounts(bool aVal)  { mDumpFrameByFrameCounts = aVal; }
 79445:   void SetPaintFrameCounts(bool aVal)        { mPaintFrameByFrameCounts = aVal; }
 79445: 
 79445:   bool IsPaintingFrameCounts() { return mPaintFrameByFrameCounts; }
 30512: 
     1: protected:
     1:   void DisplayTotals(PRUint32 aTotal, PRUint32 * aDupArray, char * aTitle);
     1:   void DisplayHTMLTotals(PRUint32 aTotal, PRUint32 * aDupArray, char * aTitle);
     1: 
 20261:   static PRIntn RemoveItems(PLHashEntry *he, PRIntn i, void *arg);
 20261:   static PRIntn RemoveIndiItems(PLHashEntry *he, PRIntn i, void *arg);
     1:   void CleanUp();
     1: 
     1:   // stdout Output Methods
 20261:   static PRIntn DoSingleTotal(PLHashEntry *he, PRIntn i, void *arg);
 20261:   static PRIntn DoSingleIndi(PLHashEntry *he, PRIntn i, void *arg);
     1: 
     1:   void DoGrandTotals();
     1:   void DoIndiTotalsTree();
     1: 
     1:   // HTML Output Methods
 20261:   static PRIntn DoSingleHTMLTotal(PLHashEntry *he, PRIntn i, void *arg);
     1:   void DoGrandHTMLTotals();
     1: 
     1:   // Zero Out the Totals
 20261:   static PRIntn DoClearTotals(PLHashEntry *he, PRIntn i, void *arg);
     1: 
     1:   // Displays the Diff Totals
 20261:   static PRIntn DoDisplayDiffTotals(PLHashEntry *he, PRIntn i, void *arg);
     1: 
     1:   PLHashTable * mCounts;
     1:   PLHashTable * mIndiFrameCounts;
     1:   FILE * mFD;
     1:   
 79445:   bool mDumpFrameCounts;
 79445:   bool mDumpFrameByFrameCounts;
 79445:   bool mPaintFrameByFrameCounts;
 79445: 
 79445:   bool mCycledOnce;
     1: 
     1:   // Root Frame for Individual Tracking
     1:   nsPresContext * mPresContext;
     1:   nsIPresShell*    mPresShell;
     1: 
     1:   // ReflowCountMgr gReflowCountMgr;
     1: };
     1: #endif
     1: //========================================================================
     1: 
     1: // comment out to hide caret
     1: #define SHOW_CARET
     1: 
     1: // The upper bound on the amount of time to spend reflowing, in
     1: // microseconds.  When this bound is exceeded and reflow commands are
     1: // still queued up, a reflow event is posted.  The idea is for reflow
     1: // to not hog the processor beyond the time specifed in
     1: // gMaxRCProcessingTime.  This data member is initialized from the
     1: // layout.reflow.timeslice pref.
     1: #define NS_MAX_REFLOW_TIME    1000000
     1: static PRInt32 gMaxRCProcessingTime = -1;
     1: 
     1: struct nsCallbackEventRequest
     1: {
     1:   nsIReflowCallback* callback;
     1:   nsCallbackEventRequest* next;
     1: };
     1: 
     1: // ----------------------------------------------------------------------------
 38310: #define ASSERT_REFLOW_SCHEDULED_STATE()                                       \
 38310:   NS_ASSERTION(mReflowScheduled ==                                            \
 38310:                  GetPresContext()->RefreshDriver()->                          \
 50365:                    IsLayoutFlushObserver(this), "Unexpected state")
 38310: 
 29804: class nsAutoCauseReflowNotifier
 29804: {
 29804: public:
 29804:   nsAutoCauseReflowNotifier(PresShell* aShell)
 29804:     : mShell(aShell)
 29804:   {
 29804:     mShell->WillCauseReflow();
 29804:   }
 29804:   ~nsAutoCauseReflowNotifier()
 29804:   {
 29804:     // This check should not be needed. Currently the only place that seem
 29804:     // to need it is the code that deals with bug 337586.
 29804:     if (!mShell->mHaveShutDown) {
 29804:       mShell->DidCauseReflow();
 29804:     }
 29804:     else {
 29804:       nsContentUtils::RemoveScriptBlocker();
 29804:     }
 29804:   }
 29804: 
 29804:   PresShell* mShell;
 29804: };
 29804: 
 15594: class NS_STACK_CLASS nsPresShellEventCB : public nsDispatchingCallback
     1: {
     1: public:
     1:   nsPresShellEventCB(PresShell* aPresShell) : mPresShell(aPresShell) {}
     1: 
     1:   virtual void HandleEvent(nsEventChainPostVisitor& aVisitor)
     1:   {
     1:     if (aVisitor.mPresContext && aVisitor.mEvent->eventStructType != NS_EVENT) {
 99684:       if (aVisitor.mEvent->message == NS_MOUSE_BUTTON_DOWN ||
 99684:           aVisitor.mEvent->message == NS_MOUSE_BUTTON_UP) {
 99684:         // Mouse-up and mouse-down events call nsFrame::HandlePress/Release
 99684:         // which call GetContentOffsetsFromPoint which requires up-to-date layout.
 99684:         // Bring layout up-to-date now so that GetCurrentEventFrame() below
 99684:         // will return a real frame and we don't have to worry about
 99684:         // destroying it by flushing later.
 99684:         mPresShell->FlushPendingNotifications(Flush_Layout);
 99684:       }
     1:       nsIFrame* frame = mPresShell->GetCurrentEventFrame();
     1:       if (frame) {
     1:         frame->HandleEvent(aVisitor.mPresContext,
     1:                            (nsGUIEvent*) aVisitor.mEvent,
     1:                            &aVisitor.mEventStatus);
     1:       }
     1:     }
     1:   }
     1: 
     1:   nsRefPtr<PresShell> mPresShell;
     1: };
     1: 
101068: class nsBeforeFirstPaintDispatcher : public nsRunnable
101068: {
101068: public:
101068:   nsBeforeFirstPaintDispatcher(nsIDocument* aDocument)
101068:   : mDocument(aDocument) {}
101068: 
101068:   // Fires the "before-first-paint" event so that interested parties (right now, the
101068:   // mobile browser) are aware of it.
101068:   NS_IMETHOD Run()
101068:   {
101068:     nsCOMPtr<nsIObserverService> observerService =
101068:       mozilla::services::GetObserverService();
101068:     if (observerService) {
101068:       observerService->NotifyObservers(mDocument, "before-first-paint", NULL);
101068:     }
101068:     return NS_OK;
101068:   }
101068: 
101068: private:
101068:   nsCOMPtr<nsIDocument> mDocument;
101068: };
101068: 
 79445: bool PresShell::sDisableNonTestMouseEvents = false;
 24947: 
     1: #ifdef PR_LOGGING
     1: PRLogModuleInfo* PresShell::gLog;
     1: #endif
     1: 
102909: #ifdef DEBUG
     1: static void
     1: VerifyStyleTree(nsPresContext* aPresContext, nsFrameManager* aFrameManager)
     1: {
 31709:   if (nsFrame::GetVerifyStyleTreeEnable()) {
     1:     nsIFrame* rootFrame = aFrameManager->GetRootFrame();
     1:     aFrameManager->DebugVerifyStyleTree(rootFrame);
     1:   }
     1: }
 89328: #define VERIFY_STYLE_TREE ::VerifyStyleTree(mPresContext, mFrameConstructor)
     1: #else
     1: #define VERIFY_STYLE_TREE
     1: #endif
     1: 
 79445: static bool gVerifyReflowEnabled;
 79445: 
 79445: bool
     1: nsIPresShell::GetVerifyReflowEnable()
     1: {
102909: #ifdef DEBUG
 79445:   static bool firstTime = true;
     1:   if (firstTime) {
 80486:     firstTime = false;
     1:     char* flags = PR_GetEnv("GECKO_VERIFY_REFLOW_FLAGS");
     1:     if (flags) {
 79445:       bool error = false;
     1: 
     1:       for (;;) {
     1:         char* comma = PL_strchr(flags, ',');
     1:         if (comma)
     1:           *comma = '\0';
     1: 
 79445:         bool found = false;
     1:         const VerifyReflowFlags* flag = gFlags;
     1:         const VerifyReflowFlags* limit = gFlags + NUM_VERIFY_REFLOW_FLAGS;
     1:         while (flag < limit) {
     1:           if (PL_strcasecmp(flag->name, flags) == 0) {
     1:             gVerifyReflowFlags |= flag->bit;
 80486:             found = true;
     1:             break;
     1:           }
     1:           ++flag;
     1:         }
     1: 
     1:         if (! found)
 80486:           error = true;
     1: 
     1:         if (! comma)
     1:           break;
     1: 
     1:         *comma = ',';
     1:         flags = comma + 1;
     1:       }
     1: 
     1:       if (error)
     1:         ShowVerifyReflowFlags();
     1:     }
     1: 
     1:     if (VERIFY_REFLOW_ON & gVerifyReflowFlags) {
 80486:       gVerifyReflowEnabled = true;
  3232: 
  3232:       printf("Note: verifyreflow is enabled");
     1:       if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
     1:         printf(" (noisy)");
     1:       }
     1:       if (VERIFY_REFLOW_ALL & gVerifyReflowFlags) {
     1:         printf(" (all)");
     1:       }
     1:       if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
     1:         printf(" (show reflow commands)");
     1:       }
     1:       if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
     1:         printf(" (noisy reflow commands)");
     1:         if (VERIFY_REFLOW_REALLY_NOISY_RC & gVerifyReflowFlags) {
     1:           printf(" (REALLY noisy reflow commands)");
     1:         }
     1:       }
     1:       printf("\n");
     1:     }
  3232:   }
     1: #endif
     1:   return gVerifyReflowEnabled;
     1: }
     1: 
     1: void
 79445: nsIPresShell::SetVerifyReflowEnable(bool aEnabled)
     1: {
     1:   gVerifyReflowEnabled = aEnabled;
     1: }
     1: 
 34904: /* virtual */ void
 34904: nsIPresShell::AddWeakFrameExternal(nsWeakFrame* aWeakFrame)
 34904: {
 34904:   AddWeakFrameInternal(aWeakFrame);
 34904: }
 34904: 
     1: void
 34904: nsIPresShell::AddWeakFrameInternal(nsWeakFrame* aWeakFrame)
     1: {
     1:   if (aWeakFrame->GetFrame()) {
     1:     aWeakFrame->GetFrame()->AddStateBits(NS_FRAME_EXTERNAL_REFERENCE);
     1:   }
     1:   aWeakFrame->SetPreviousWeakFrame(mWeakFrames);
     1:   mWeakFrames = aWeakFrame;
     1: }
     1: 
 34904: /* virtual */ void
 34904: nsIPresShell::RemoveWeakFrameExternal(nsWeakFrame* aWeakFrame)
 34904: {
 34904:   RemoveWeakFrameInternal(aWeakFrame);
 34904: }
 34904: 
     1: void
 34904: nsIPresShell::RemoveWeakFrameInternal(nsWeakFrame* aWeakFrame)
     1: {
     1:   if (mWeakFrames == aWeakFrame) {
     1:     mWeakFrames = aWeakFrame->GetPreviousWeakFrame();
     1:     return;
     1:   }
     1:   nsWeakFrame* nextWeak = mWeakFrames;
     1:   while (nextWeak && nextWeak->GetPreviousWeakFrame() != aWeakFrame) {
     1:     nextWeak = nextWeak->GetPreviousWeakFrame();
     1:   }
     1:   if (nextWeak) {
     1:     nextWeak->SetPreviousWeakFrame(aWeakFrame->GetPreviousWeakFrame());
     1:   }
     1: }
     1: 
  8295: already_AddRefed<nsFrameSelection>
  8295: nsIPresShell::FrameSelection()
  8295: {
  8295:   NS_IF_ADDREF(mSelection);
  8295:   return mSelection;
  8295: }
  8295: 
     1: //----------------------------------------------------------------------
     1: 
     1: nsresult
     1: NS_NewPresShell(nsIPresShell** aInstancePtrResult)
     1: {
     1:   NS_PRECONDITION(nsnull != aInstancePtrResult, "null ptr");
 40053: 
 40053:   if (!aInstancePtrResult)
     1:     return NS_ERROR_NULL_POINTER;
 40053: 
 40053:   *aInstancePtrResult = new PresShell();
 40053: 
 40053:   NS_ADDREF(*aInstancePtrResult);
 40053:   return NS_OK;
     1: }
     1: 
 79445: static bool sSynthMouseMove = true;
 42982: 
     1: PresShell::PresShell()
 69702:   : mMouseLocation(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE)
     1: {
     1:   mSelection = nsnull;
     1: #ifdef MOZ_REFLOW_PERF
     1:   mReflowCountMgr = new ReflowCountMgr();
     1:   mReflowCountMgr->SetPresContext(mPresContext);
     1:   mReflowCountMgr->SetPresShell(this);
     1: #endif
     1: #ifdef PR_LOGGING
     1:   if (! gLog)
     1:     gLog = PR_NewLogModule("PresShell");
     1: #endif
     1:   mSelectionFlags = nsISelectionDisplay::DISPLAY_TEXT | nsISelectionDisplay::DISPLAY_IMAGES;
 80486:   mIsThemeSupportDisabled = false;
 80486:   mIsActive = true;
105886:   // FIXME/bug 735029: find a better solution to this problem
105886: #ifdef MOZ_JAVA_COMPOSITOR
105886:   // The java pan/zoom code uses this to mean approximately "request a
105886:   // reset of pan/zoom state" which doesn't necessarily correspond
105886:   // with the first paint of content.
 93057:   mIsFirstPaint = false;
105886: #else
105886:   mIsFirstPaint = true;
105886: #endif
 80486:   mFrozen = false;
 32511: #ifdef DEBUG
 32511:   mPresArenaAllocCount = 0;
 32511: #endif
 54080:   mRenderFlags = 0;
 54081:   mXResolution = 1.0;
 54081:   mYResolution = 1.0;
 80486:   mViewportOverridden = false;
     1: 
 96812:   mScrollPositionClampingScrollPortSizeSet = false;
 96812: 
 91413:   static bool addedSynthMouseMove = false;
 91413:   if (!addedSynthMouseMove) {
 71001:     Preferences::AddBoolVarCache(&sSynthMouseMove,
 80486:                                  "layout.reflow.synthMouseMove", true);
 91413:     addedSynthMouseMove = true;
 91413:   }
     1: }
     1: 
 82568: NS_IMPL_ISUPPORTS7(PresShell, nsIPresShell, nsIDocumentObserver,
 82568:                    nsISelectionController,
     1:                    nsISelectionDisplay, nsIObserver, nsISupportsWeakReference,
 64531:                    nsIMutationObserver)
     1: 
     1: PresShell::~PresShell()
     1: {
     1:   if (!mHaveShutDown) {
     1:     NS_NOTREACHED("Someone did not call nsIPresShell::destroy");
     1:     Destroy();
     1:   }
     1: 
     1:   NS_ASSERTION(mCurrentEventContentStack.Count() == 0,
     1:                "Huh, event content left on the stack in pres shell dtor!");
     1:   NS_ASSERTION(mFirstCallbackEventRequest == nsnull &&
     1:                mLastCallbackEventRequest == nsnull,
     1:                "post-reflow queues not empty.  This means we're leaking");
     1: 
 32511: #ifdef DEBUG
 90455:   MOZ_ASSERT(mPresArenaAllocCount == 0,
 32511:              "Some pres arena objects were not freed");
 32511: #endif
 32511: 
     1:   delete mStyleSet;
 50365:   delete mFrameConstructor;
     1: 
     1:   mCurrentEventContent = nsnull;
     1: 
     1:   NS_IF_RELEASE(mPresContext);
     1:   NS_IF_RELEASE(mDocument);
 13846:   NS_IF_RELEASE(mSelection);
     1: }
     1: 
     1: /**
     1:  * Initialize the presentation shell. Create view manager and style
     1:  * manager.
     1:  */
 39668: nsresult
     1: PresShell::Init(nsIDocument* aDocument,
     1:                 nsPresContext* aPresContext,
     1:                 nsIViewManager* aViewManager,
     1:                 nsStyleSet* aStyleSet,
     1:                 nsCompatibility aCompatMode)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   NS_PRECONDITION(nsnull != aDocument, "null ptr");
     1:   NS_PRECONDITION(nsnull != aPresContext, "null ptr");
     1:   NS_PRECONDITION(nsnull != aViewManager, "null ptr");
     1:   nsresult result;
     1: 
     1:   if ((nsnull == aDocument) || (nsnull == aPresContext) ||
     1:       (nsnull == aViewManager)) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1:   if (mDocument) {
     1:     NS_WARNING("PresShell double init'ed");
     1:     return NS_ERROR_ALREADY_INITIALIZED;
     1:   }
     1: 
 98908:   mFramesToDirty.Init();
 27993: 
     1:   mDocument = aDocument;
     1:   NS_ADDREF(mDocument);
     1:   mViewManager = aViewManager;
     1: 
     1:   // Create our frame constructor.
     1:   mFrameConstructor = new nsCSSFrameConstructor(mDocument, this);
     1: 
 89328:   mFrameManager = mFrameConstructor;
 89328: 
     1:   // The document viewer owns both view manager and pres shell.
 82568:   mViewManager->SetPresShell(this);
     1: 
     1:   // Bind the context to the presentation shell.
     1:   mPresContext = aPresContext;
     1:   NS_ADDREF(mPresContext);
     1:   aPresContext->SetShell(this);
     1: 
     1:   // Now we can initialize the style set.
     1:   result = aStyleSet->Init(aPresContext);
     1:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // From this point on, any time we return an error we need to make
     1:   // sure to null out mStyleSet first, since an error return from this
     1:   // method will cause the caller to delete the style set, so we don't
     1:   // want to delete it in our destructor.
     1:   mStyleSet = aStyleSet;
     1: 
     1:   // Notify our prescontext that it now has a compatibility mode.  Note that
     1:   // this MUST happen after we set up our style set but before we create any
     1:   // frames.
     1:   mPresContext->CompatibilityModeChanged();
     1: 
     1:   // setup the preference style rules (no forced reflow), and do it
     1:   // before creating any frames.
 80486:   SetPreferenceStyleRules(false);
     1: 
 70098:   NS_ADDREF(mSelection = new nsFrameSelection());
     1: 
     1:   // Create and initialize the frame manager
 89328:   // XXXjwatt it would be better if we did this right after creating
 89328:   // mFrameConstructor, since the frame constructor and frame manager
 89328:   // are now the same object.
 89328:   result =  mFrameConstructor->Init(mStyleSet);
     1:   if (NS_FAILED(result)) {
     1:     NS_WARNING("Frame manager initialization failed");
     1:     mStyleSet = nsnull;
     1:     return result;
     1:   }
     1: 
     1:   mSelection->Init(this, nsnull);
     1: 
     1:   // Important: this has to happen after the selection has been set up
     1: #ifdef SHOW_CARET
     1:   // make the caret
 69903:   mCaret = new nsCaret();
     1:   mCaret->Init(this);
  6232:   mOriginalCaret = mCaret;
     1: 
 80486:   //SetCaretEnabled(true);       // make it show in browser windows
     1: #endif  
     1:   //set up selection to be displayed in document
     1:   // Don't enable selection for print media
     1:   nsPresContext::nsPresContextType type = aPresContext->Type();
     1:   if (type != nsPresContext::eContext_PrintPreview &&
     1:       type != nsPresContext::eContext_Print)
     1:     SetDisplaySelection(nsISelectionController::SELECTION_DISABLED);
     1:   
     1:   if (gMaxRCProcessingTime == -1) {
     1:     gMaxRCProcessingTime =
 70842:       Preferences::GetInt("layout.reflow.timeslice", NS_MAX_REFLOW_TIME);
     1:   }
     1: 
     1:   {
 41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
     1:     if (os) {
 80486:       os->AddObserver(this, "agent-sheet-added", false);
 80486:       os->AddObserver(this, "user-sheet-added", false);
 80486:       os->AddObserver(this, "agent-sheet-removed", false);
 80486:       os->AddObserver(this, "user-sheet-removed", false);
     1: #ifdef MOZ_XUL
 80486:       os->AddObserver(this, "chrome-flush-skin-caches", false);
     1: #endif
     1:     }
     1:   }
     1: 
     1: #ifdef MOZ_REFLOW_PERF
     1:     if (mReflowCountMgr) {
 79445:       bool paintFrameCounts =
 70840:         Preferences::GetBool("layout.reflow.showframecounts");
     1: 
 79445:       bool dumpFrameCounts =
 70840:         Preferences::GetBool("layout.reflow.dumpframecounts");
     1: 
 79445:       bool dumpFrameByFrameCounts =
 70840:         Preferences::GetBool("layout.reflow.dumpframebyframecounts");
     1: 
     1:       mReflowCountMgr->SetDumpFrameCounts(dumpFrameCounts);
     1:       mReflowCountMgr->SetDumpFrameByFrameCounts(dumpFrameByFrameCounts);
     1:       mReflowCountMgr->SetPaintFrameCounts(paintFrameCounts);
     1:     }
     1: #endif
     1: 
 39694:   if (mDocument->HasAnimationController()) {
 39694:     nsSMILAnimationController* animCtrl = mDocument->GetAnimationController();
 56137:     animCtrl->NotifyRefreshDriverCreated(GetPresContext()->RefreshDriver());
 39694:   }
 39694: 
 48937:   // Get our activeness from the docShell.
 48937:   QueryIsActive();
 48937: 
101113:   // Setup our font inflation preferences.
101113:   SetupFontInflation();
101113: 
     1:   return NS_OK;
     1: }
     1: 
 39668: void
     1: PresShell::Destroy()
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
 28371:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 28371:     "destroy called on presshell while scripts not blocked");
 28371: 
     1: #ifdef MOZ_REFLOW_PERF
     1:   DumpReflows();
     1:   if (mReflowCountMgr) {
     1:     delete mReflowCountMgr;
     1:     mReflowCountMgr = nsnull;
     1:   }
     1: #endif
     1: 
     1:   if (mHaveShutDown)
 39668:     return;
     1: 
 43765: #ifdef ACCESSIBILITY
106800:   if (mAccDocument) {
106800: #ifdef DEBUG
106800:     if (a11y::logging::IsEnabled(a11y::logging::eDocDestroy))
106800:       a11y::logging::DocDestroy("presshell destroyed", mDocument);
106800: #endif
106800: 
106800:     mAccDocument->Shutdown();
106800:     mAccDocument = nsnull;
 43765:   }
 43765: #endif // ACCESSIBILITY
 43765: 
 35522:   MaybeReleaseCapturingContent();
 35522: 
 80526:   if (gKeyDownTarget && gKeyDownTarget->OwnerDoc() == mDocument) {
 50720:     NS_RELEASE(gKeyDownTarget);
 50720:   }
 50720: 
 98654:   if (mContentToScrollTo) {
 98654:     mContentToScrollTo->DeleteProperty(nsGkAtoms::scrolling);
 27993:     mContentToScrollTo = nsnull;
 98654:   }
 27993: 
     1:   if (mPresContext) {
     1:     // We need to notify the destroying the nsPresContext to ESM for
     1:     // suppressing to use from ESM.
     1:     mPresContext->EventStateManager()->NotifyDestroyPresContext(mPresContext);
     1:   }
     1: 
     1:   {
 41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
     1:     if (os) {
     1:       os->RemoveObserver(this, "agent-sheet-added");
     1:       os->RemoveObserver(this, "user-sheet-added");
     1:       os->RemoveObserver(this, "agent-sheet-removed");
     1:       os->RemoveObserver(this, "user-sheet-removed");
     1: #ifdef MOZ_XUL
     1:       os->RemoveObserver(this, "chrome-flush-skin-caches");
     1: #endif
     1:     }
     1:   }
     1: 
     1:   // If our paint suppression timer is still active, kill it.
     1:   if (mPaintSuppressionTimer) {
     1:     mPaintSuppressionTimer->Cancel();
     1:     mPaintSuppressionTimer = nsnull;
     1:   }
     1: 
 29172:   // Same for our reflow continuation timer
 29172:   if (mReflowContinueTimer) {
 29172:     mReflowContinueTimer->Cancel();
 29172:     mReflowContinueTimer = nsnull;
 29172:   }
 29172: 
 69702:   mSynthMouseMoveEvent.Revoke();
 69702: 
     1:   if (mCaret) {
     1:     mCaret->Terminate();
     1:     mCaret = nsnull;
     1:   }
     1: 
 13846:   if (mSelection) {
 13846:     mSelection->DisconnectFromPresShell();
 13846:   }
 13846: 
     1:   // release our pref style sheet, if we have one still
     1:   ClearPreferenceStyleRules();
     1: 
 80486:   mIsDestroying = true;
     1: 
     1:   // We can't release all the event content in
     1:   // mCurrentEventContentStack here since there might be code on the
     1:   // stack that will release the event content too. Double release
     1:   // bad!
     1: 
     1:   // The frames will be torn down, so remove them from the current
     1:   // event frame stack (since they'd be dangling references if we'd
     1:   // leave them in) and null out the mCurrentEventFrame pointer as
     1:   // well.
     1: 
     1:   mCurrentEventFrame = nsnull;
     1: 
 24551:   PRInt32 i, count = mCurrentEventFrameStack.Length();
     1:   for (i = 0; i < count; i++) {
 24551:     mCurrentEventFrameStack[i] = nsnull;
     1:   }
     1: 
 35246:   mFramesToDirty.Clear();
 35246: 
     1:   if (mViewManager) {
     1:     // Clear the view manager's weak pointer back to |this| in case it
     1:     // was leaked.
 82568:     mViewManager->SetPresShell(nsnull);
     1:     mViewManager = nsnull;
     1:   }
     1: 
     1:   mStyleSet->BeginShutdown(mPresContext);
 47259:   nsRefreshDriver* rd = GetPresContext()->RefreshDriver();
     1: 
     1:   // This shell must be removed from the document before the frame
     1:   // hierarchy is torn down to avoid finding deleted frames through
     1:   // this presshell while the frames are being torn down
     1:   if (mDocument) {
 46225:     NS_ASSERTION(mDocument->GetShell() == this, "Wrong shell?");
 36917:     mDocument->DeleteShell();
 47259: 
 39694:     if (mDocument->HasAnimationController()) {
 56137:       mDocument->GetAnimationController()->NotifyRefreshDriverDestroying(rd);
 39694:     }
 47259:   }
 39694: 
 38310:   // Revoke any pending events.  We need to do this and cancel pending reflows
 38310:   // before we destroy the frame manager, since apparently frame destruction
 38310:   // sometimes spins the event queue when plug-ins are involved(!).
 50365:   rd->RemoveLayoutFlushObserver(this);
 87344:   rd->RevokeViewManagerFlush();
 87344: 
 23685:   mResizeEvent.Revoke();
 31584:   if (mAsyncResizeTimerIsActive) {
 31584:     mAsyncResizeEventTimer->Cancel();
 80486:     mAsyncResizeTimerIsActive = false;
 31584:   }
     1: 
     1:   CancelAllPendingReflows();
  8509:   CancelPostedReflowCallbacks();
     1: 
     1:   // Destroy the frame manager. This will destroy the frame hierarchy
 26803:   mFrameConstructor->WillDestroyFrameTree();
     1: 
 30599:   // Destroy all frame properties (whose destruction was suppressed
 30599:   // while destroying the frame tree, but which might contain more
 30599:   // frames within the properties.
     1:   if (mPresContext) {
     1:     // Clear out the prescontext's property table -- since our frame tree is
     1:     // now dead, we shouldn't be looking up any more properties in that table.
     1:     // We want to do this before we call SetShell() on the prescontext, so
     1:     // property destructors can usefully call GetPresShell() on the
     1:     // prescontext.
 39965:     mPresContext->PropertyTable()->DeleteAll();
 30599:   }
 30599: 
 30599: 
 30599:   NS_WARN_IF_FALSE(!mWeakFrames, "Weak frames alive after destroying FrameManager");
 30599:   while (mWeakFrames) {
 30599:     mWeakFrames->Clear(this);
 30599:   }
 30599: 
 30599:   // Let the style set do its cleanup.
 30599:   mStyleSet->Shutdown(mPresContext);
 30599: 
 30599:   if (mPresContext) {
     1:     // We hold a reference to the pres context, and it holds a weak link back
     1:     // to us. To avoid the pres context having a dangling reference, set its 
     1:     // pres shell to NULL
     1:     mPresContext->SetShell(nsnull);
     1: 
     1:     // Clear the link handler (weak reference) as well
     1:     mPresContext->SetLinkHandler(nsnull);
     1:   }
     1: 
 80486:   mHaveShutDown = true;
     1: }
     1: 
     1: void
 79445: nsIPresShell::SetAuthorStyleDisabled(bool aStyleDisabled)
     1: {
     1:   if (aStyleDisabled != mStyleSet->GetAuthorStyleDisabled()) {
     1:     mStyleSet->SetAuthorStyleDisabled(aStyleDisabled);
     1:     ReconstructStyleData();
     1:   }
     1: }
     1: 
 79445: bool
 40053: nsIPresShell::GetAuthorStyleDisabled() const
     1: {
     1:   return mStyleSet->GetAuthorStyleDisabled();
     1: }
     1: 
 39668: nsresult
 79445: PresShell::SetPreferenceStyleRules(bool aForceReflow)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   if (!mDocument) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   nsPIDOMWindow *window = mDocument->GetWindow();
     1: 
     1:   // If the document doesn't have a window there's no need to notify
     1:   // its presshell about changes to preferences since the document is
     1:   // in a state where it doesn't matter any more (see
     1:   // DocumentViewerImpl::Close()).
     1: 
     1:   if (!window) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   } 
     1: 
     1:   NS_PRECONDITION(mPresContext, "presContext cannot be null");
     1:   if (mPresContext) {
     1:     // first, make sure this is not a chrome shell 
 19869:     if (nsContentUtils::IsInChromeDocshell(mDocument)) {
     1:       return NS_OK;
     1:     }
     1: 
     1: #ifdef DEBUG_attinasi
     1:     printf("Setting Preference Style Rules:\n");
     1: #endif
     1:     // if here, we need to create rules for the prefs
     1:     // - this includes the background-color, the text-color,
     1:     //   the link color, the visited link color and the link-underlining
     1:     
     1:     // first clear any exising rules
 19869:     nsresult result = ClearPreferenceStyleRules();
     1:       
     1:     // now the link rules (must come after the color rules, or links will not be correct color!)
     1:     // XXX - when there is both an override and agent pref stylesheet this won't matter,
     1:     //       as the color rules will be overrides and the links rules will be agent
     1:     if (NS_SUCCEEDED(result)) {
     1:       result = SetPrefLinkRules();
     1:     }
     1:     if (NS_SUCCEEDED(result)) {
     1:       result = SetPrefFocusRules();
     1:     }
     1:     if (NS_SUCCEEDED(result)) {
     1:       result = SetPrefNoScriptRule();
     1:     }
     1:     if (NS_SUCCEEDED(result)) {
     1:       result = SetPrefNoFramesRule();
     1:     }
     1: #ifdef DEBUG_attinasi
     1:     printf( "Preference Style Rules set: error=%ld\n", (long)result);
     1: #endif
     1: 
  3959:     // Note that this method never needs to force any calculation; the caller
  3959:     // will recalculate style if needed
     1: 
     1:     return result;
     1:   }
     1: 
     1:   return NS_ERROR_NULL_POINTER;
     1: }
     1: 
     1: nsresult PresShell::ClearPreferenceStyleRules(void)
     1: {
     1:   nsresult result = NS_OK;
     1:   if (mPrefStyleSheet) {
     1:     NS_ASSERTION(mStyleSet, "null styleset entirely unexpected!");
     1:     if (mStyleSet) {
     1:       // remove the sheet from the styleset: 
     1:       // - note that we have to check for success by comparing the count before and after...
102909: #ifdef DEBUG
     1:       PRInt32 numBefore = mStyleSet->SheetCount(nsStyleSet::eUserSheet);
     1:       NS_ASSERTION(numBefore > 0, "no user stylesheets in styleset, but we have one!");
     1: #endif
     1:       mStyleSet->RemoveStyleSheet(nsStyleSet::eUserSheet, mPrefStyleSheet);
     1: 
     1: #ifdef DEBUG_attinasi
     1:       NS_ASSERTION((numBefore - 1) == mStyleSet->GetNumberOfUserStyleSheets(),
     1:                    "Pref stylesheet was not removed");
     1:       printf("PrefStyleSheet removed\n");
     1: #endif
     1:       // clear the sheet pointer: it is strictly historical now
 10382:       mPrefStyleSheet = nsnull;
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: nsresult PresShell::CreatePreferenceStyleSheet(void)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   NS_ASSERTION(!mPrefStyleSheet, "prefStyleSheet already exists");
 36920:   nsresult result = NS_NewCSSStyleSheet(getter_AddRefs(mPrefStyleSheet));
     1:   if (NS_SUCCEEDED(result)) {
     1:     NS_ASSERTION(mPrefStyleSheet, "null but no error");
     1:     nsCOMPtr<nsIURI> uri;
     1:     result = NS_NewURI(getter_AddRefs(uri), "about:PreferenceStyleSheet", nsnull);
     1:     if (NS_SUCCEEDED(result)) {
     1:       NS_ASSERTION(uri, "null but no error");
 42162:       mPrefStyleSheet->SetURIs(uri, uri, uri);
     1:       mPrefStyleSheet->SetComplete();
     1:       PRUint32 index;
 10382:       result =
 10382:         mPrefStyleSheet->InsertRuleInternal(NS_LITERAL_STRING("@namespace url(http://www.w3.org/1999/xhtml);"),
     1:                                             0, &index);
 10382:       if (NS_SUCCEEDED(result)) {
     1:         mStyleSet->AppendStyleSheet(nsStyleSet::eUserSheet, mPrefStyleSheet);
     1:       }
     1:     }
 10382:   }
     1: 
     1: #ifdef DEBUG_attinasi
     1:   printf("CreatePrefStyleSheet completed: error=%ld\n",(long)result);
     1: #endif
     1: 
 10382:   if (NS_FAILED(result)) {
 10382:     mPrefStyleSheet = nsnull;
 10382:   }
 10382: 
     1:   return result;
     1: }
     1: 
     1: // XXX We want these after the @namespace rule.  Does order matter
 63693: // for these rules, or can we call StyleRule::StyleRuleCount()
     1: // and just "append"?
     1: static PRUint32 sInsertPrefSheetRulesAt = 1;
     1: 
     1: nsresult
     1: PresShell::SetPrefNoScriptRule()
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   // also handle the case where print is done from print preview
     1:   // see bug #342439 for more details
 36473:   nsIDocument* doc = mDocument;
 94112:   if (doc->IsStaticDocument()) {
 36473:     doc = doc->GetOriginalDocument();
 36473:   }
 36473: 
 79445:   bool scriptEnabled = doc->IsScriptEnabled();
     1:   if (scriptEnabled) {
     1:     if (!mPrefStyleSheet) {
     1:       rv = CreatePreferenceStyleSheet();
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
 10382: 
     1:     PRUint32 index = 0;
 10382:     mPrefStyleSheet->
 10382:       InsertRuleInternal(NS_LITERAL_STRING("noscript{display:none!important}"),
     1:                          sInsertPrefSheetRulesAt, &index);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult PresShell::SetPrefNoFramesRule(void)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
     1:   if (!mPresContext) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   nsresult rv = NS_OK;
     1:   
     1:   if (!mPrefStyleSheet) {
     1:     rv = CreatePreferenceStyleSheet();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:   
     1:   NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
     1:   
 79445:   bool allowSubframes = true;
     1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();     
     1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
     1:   if (docShell) {
     1:     docShell->GetAllowSubframes(&allowSubframes);
     1:   }
     1:   if (!allowSubframes) {
     1:     PRUint32 index = 0;
 10382:     rv = mPrefStyleSheet->
 10382:       InsertRuleInternal(NS_LITERAL_STRING("noframes{display:block}"),
     1:                          sInsertPrefSheetRulesAt, &index);
     1:     NS_ENSURE_SUCCESS(rv, rv);
 10382:     rv = mPrefStyleSheet->
 10382:       InsertRuleInternal(NS_LITERAL_STRING("frame, frameset, iframe {display:none!important}"),
     1:                          sInsertPrefSheetRulesAt, &index);
     1:   }
     1:   return rv;
     1: }
     1:   
     1: nsresult PresShell::SetPrefLinkRules(void)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
     1:   if (!mPresContext) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   nsresult rv = NS_OK;
     1:   
     1:   if (!mPrefStyleSheet) {
     1:     rv = CreatePreferenceStyleSheet();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:   
     1:   NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
     1:   
     1:   // support default link colors: 
     1:   //   this means the link colors need to be overridable, 
     1:   //   which they are if we put them in the agent stylesheet,
     1:   //   though if using an override sheet this will cause authors grief still
     1:   //   In the agent stylesheet, they are !important when we are ignoring document colors
     1:   
     1:   nscolor linkColor(mPresContext->DefaultLinkColor());
     1:   nscolor activeColor(mPresContext->DefaultActiveLinkColor());
     1:   nscolor visitedColor(mPresContext->DefaultVisitedLinkColor());
     1:   
  1540:   NS_NAMED_LITERAL_STRING(ruleClose, "}");
     1:   PRUint32 index = 0;
     1:   nsAutoString strColor;
     1: 
     1:   // insert a rule to color links: '*|*:link {color: #RRGGBB [!important];}'
     1:   ColorToString(linkColor, strColor);
 10382:   rv = mPrefStyleSheet->
 10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:link{color:") +
     1:                        strColor + ruleClose,
     1:                        sInsertPrefSheetRulesAt, &index);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // - visited links: '*|*:visited {color: #RRGGBB [!important];}'
     1:   ColorToString(visitedColor, strColor);
 10382:   rv = mPrefStyleSheet->
 10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:visited{color:") +
     1:                        strColor + ruleClose,
     1:                        sInsertPrefSheetRulesAt, &index);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // - active links: '*|*:-moz-any-link:active {color: #RRGGBB [!important];}'
     1:   ColorToString(activeColor, strColor);
 10382:   rv = mPrefStyleSheet->
 10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link:active{color:") +
     1:                        strColor + ruleClose,
     1:                        sInsertPrefSheetRulesAt, &index);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool underlineLinks =
     1:     mPresContext->GetCachedBoolPref(kPresContext_UnderlineLinks);
     1: 
     1:   if (underlineLinks) {
     1:     // create a rule to make underlining happen
     1:     //  '*|*:-moz-any-link {text-decoration:[underline|none];}'
     1:     // no need for important, we want these to be overridable
     1:     // NOTE: these must go in the agent stylesheet or they cannot be
     1:     //       overridden by authors
 10382:     rv = mPrefStyleSheet->
 10382:       InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link{text-decoration:underline}"),
     1:                          sInsertPrefSheetRulesAt, &index);
     1:   } else {
 10382:     rv = mPrefStyleSheet->
 10382:       InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link{text-decoration:none}"),
     1:                          sInsertPrefSheetRulesAt, &index);
     1:   }
     1: 
     1:   return rv;          
     1: }
     1: 
     1: nsresult PresShell::SetPrefFocusRules(void)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
     1:   nsresult result = NS_OK;
     1: 
     1:   if (!mPresContext)
     1:     result = NS_ERROR_FAILURE;
     1: 
     1:   if (NS_SUCCEEDED(result) && !mPrefStyleSheet)
     1:     result = CreatePreferenceStyleSheet();
     1: 
     1:   if (NS_SUCCEEDED(result)) {
     1:     NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
     1: 
     1:     if (mPresContext->GetUseFocusColors()) {
     1:       nscolor focusBackground(mPresContext->FocusBackgroundColor());
     1:       nscolor focusText(mPresContext->FocusTextColor());
     1: 
     1:       // insert a rule to make focus the preferred color
     1:       PRUint32 index = 0;
     1:       nsAutoString strRule, strColor;
     1: 
     1:       ///////////////////////////////////////////////////////////////
     1:       // - focus: '*:focus
     1:       ColorToString(focusText,strColor);
     1:       strRule.AppendLiteral("*:focus,*:focus>font {color: ");
     1:       strRule.Append(strColor);
     1:       strRule.AppendLiteral(" !important; background-color: ");
     1:       ColorToString(focusBackground,strColor);
     1:       strRule.Append(strColor);
     1:       strRule.AppendLiteral(" !important; } ");
     1:       // insert the rules
 10382:       result = mPrefStyleSheet->
 10382:         InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
     1:     }
     1:     PRUint8 focusRingWidth = mPresContext->FocusRingWidth();
 79445:     bool focusRingOnAnything = mPresContext->GetFocusRingOnAnything();
 20177:     PRUint8 focusRingStyle = mPresContext->GetFocusRingStyle();
     1: 
     1:     if ((NS_SUCCEEDED(result) && focusRingWidth != 1 && focusRingWidth <= 4 ) || focusRingOnAnything) {
     1:       PRUint32 index = 0;
     1:       nsAutoString strRule;
     1:       if (!focusRingOnAnything)
     1:         strRule.AppendLiteral("*|*:link:focus, *|*:visited");    // If we only want focus rings on the normal things like links
     1:       strRule.AppendLiteral(":focus {outline: ");     // For example 3px dotted WindowText (maximum 4)
     1:       strRule.AppendInt(focusRingWidth);
 20177:       if (focusRingStyle == 0) // solid
 21040:         strRule.AppendLiteral("px solid -moz-mac-focusring !important; -moz-outline-radius: 3px; outline-offset: 1px; } ");
 20177:       else // dotted
 20177:         strRule.AppendLiteral("px dotted WindowText !important; } ");
     1:       // insert the rules
 10382:       result = mPrefStyleSheet->
 10382:         InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
     1:       NS_ENSURE_SUCCESS(result, result);
     1:       if (focusRingWidth != 1) {
     1:         // If the focus ring width is different from the default, fix buttons with rings
     1:         strRule.AssignLiteral("button::-moz-focus-inner, input[type=\"reset\"]::-moz-focus-inner,");
     1:         strRule.AppendLiteral("input[type=\"button\"]::-moz-focus-inner, ");
     1:         strRule.AppendLiteral("input[type=\"submit\"]::-moz-focus-inner { padding: 1px 2px 1px 2px; border: ");
     1:         strRule.AppendInt(focusRingWidth);
 20177:         if (focusRingStyle == 0) // solid
 20177:           strRule.AppendLiteral("px solid transparent !important; } ");
 20177:         else
     1:           strRule.AppendLiteral("px dotted transparent !important; } ");
 10382:         result = mPrefStyleSheet->
 10382:           InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
     1:         NS_ENSURE_SUCCESS(result, result);
     1:           
     1:         strRule.AssignLiteral("button:focus::-moz-focus-inner, input[type=\"reset\"]:focus::-moz-focus-inner,");
     1:         strRule.AppendLiteral("input[type=\"button\"]:focus::-moz-focus-inner, input[type=\"submit\"]:focus::-moz-focus-inner {");
     1:         strRule.AppendLiteral("border-color: ButtonText !important; }");
 10382:         result = mPrefStyleSheet->
 10382:           InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
     1:       }
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: void
     1: PresShell::AddUserSheet(nsISupports* aSheet)
     1: {
     1:   // Make sure this does what DocumentViewerImpl::CreateStyleSet does wrt
     1:   // ordering. We want this new sheet to come after all the existing stylesheet
     1:   // service sheets, but before other user sheets; see nsIStyleSheetService.idl
     1:   // for the ordering.  Just remove and readd all the nsStyleSheetService
     1:   // sheets.
     1:   nsCOMPtr<nsIStyleSheetService> dummy =
     1:     do_GetService(NS_STYLESHEETSERVICE_CONTRACTID);
     1: 
     1:   mStyleSet->BeginUpdate();
     1:   
     1:   nsStyleSheetService *sheetService = nsStyleSheetService::gInstance;
     1:   nsCOMArray<nsIStyleSheet> & userSheets = *sheetService->UserStyleSheets();
     1:   PRInt32 i;
     1:   // Iterate forwards when removing so the searches for RemoveStyleSheet are as
     1:   // short as possible.
     1:   for (i = 0; i < userSheets.Count(); ++i) {
     1:     mStyleSet->RemoveStyleSheet(nsStyleSet::eUserSheet, userSheets[i]);
     1:   }
     1: 
     1:   // Now iterate backwards, so that the order of userSheets will be the same as
     1:   // the order of sheets from it in the style set.
     1:   for (i = userSheets.Count() - 1; i >= 0; --i) {
     1:     mStyleSet->PrependStyleSheet(nsStyleSet::eUserSheet, userSheets[i]);
     1:   }
     1: 
     1:   mStyleSet->EndUpdate();
     1: 
     1:   ReconstructStyleData();
     1: }
     1: 
     1: void
     1: PresShell::AddAgentSheet(nsISupports* aSheet)
     1: {
     1:   // Make sure this does what DocumentViewerImpl::CreateStyleSet does
     1:   // wrt ordering.
     1:   nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
     1:   if (!sheet) {
     1:     return;
     1:   }
     1: 
     1:   mStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
     1:   ReconstructStyleData();
     1: }
     1: 
     1: void
     1: PresShell::RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet)
     1: {
     1:   nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
     1:   if (!sheet) {
     1:     return;
     1:   }
     1: 
     1:   mStyleSet->RemoveStyleSheet(aType, sheet);
     1:   ReconstructStyleData();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PresShell::SetDisplaySelection(PRInt16 aToggle)
     1: {
     1:   mSelection->SetDisplaySelection(aToggle);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PresShell::GetDisplaySelection(PRInt16 *aToggle)
     1: {
     1:   *aToggle = mSelection->GetDisplaySelection();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PresShell::GetSelection(SelectionType aType, nsISelection **aSelection)
     1: {
     1:   if (!aSelection || !mSelection)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   *aSelection = mSelection->GetSelection(aType);
     1: 
     1:   if (!(*aSelection))
     1:     return NS_ERROR_INVALID_ARG;
     1: 
     1:   NS_ADDREF(*aSelection);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsISelection*
     1: PresShell::GetCurrentSelection(SelectionType aType)
     1: {
     1:   if (!mSelection)
     1:     return nsnull;
     1: 
     1:   return mSelection->GetSelection(aType);
     1: }
     1: 
     1: NS_IMETHODIMP
 56442: PresShell::ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion,
 56442:                                    PRInt16 aFlags)
     1: {
     1:   if (!mSelection)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
 56442:   return mSelection->ScrollSelectionIntoView(aType, aRegion, aFlags);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PresShell::RepaintSelection(SelectionType aType)
     1: {
     1:   if (!mSelection)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   return mSelection->RepaintSelection(aType);
     1: }
     1: 
     1: // Make shell be a document observer
 39668: void
     1: PresShell::BeginObservingDocument()
     1: {
  1416:   if (mDocument && !mIsDestroying) {
     1:     mDocument->AddObserver(this);
     1:     if (mIsDocumentGone) {
     1:       NS_WARNING("Adding a presshell that was disconnected from the document "
     1:                  "as a document observer?  Sounds wrong...");
 80486:       mIsDocumentGone = false;
     1:     }
     1:   }
     1: }
     1: 
     1: // Make shell stop being a document observer
 39668: void
     1: PresShell::EndObservingDocument()
     1: {
     1:   // XXXbz do we need to tell the frame constructor that the document
     1:   // is gone, perhaps?  Except for printing it's NOT gone, sometimes.
 80486:   mIsDocumentGone = true;
     1:   if (mDocument) {
 35581:     mDocument->RemoveObserver(this);
     1:   }
     1: }
     1: 
     1: #ifdef DEBUG_kipp
     1: char* nsPresShell_ReflowStackPointerTop;
     1: #endif
     1: 
 39668: nsresult
     1: PresShell::InitialReflow(nscoord aWidth, nscoord aHeight)
     1: {
   967:   if (mIsDestroying) {
   967:     return NS_OK;
   967:   }
   967: 
 28215:   if (!mDocument) {
 28215:     // Nothing to do
 28215:     return NS_OK;
 28215:   }
 28215: 
 42480:   NS_TIME_FUNCTION_WITH_DOCURL;
 80773:   mozilla::TimeStamp timerStart = mozilla::TimeStamp::Now();
 42480: 
 20272:   NS_ASSERTION(!mDidInitialReflow, "Why are we being called?");
 20272: 
     1:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 80486:   mDidInitialReflow = true;
     1: 
102909: #ifdef DEBUG
     1:   if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
     1:     if (mDocument) {
     1:       nsIURI *uri = mDocument->GetDocumentURI();
     1:       if (uri) {
     1:         nsCAutoString url;
     1:         uri->GetSpec(url);
     1:         printf("*** PresShell::InitialReflow (this=%p, url='%s')\n", (void*)this, url.get());
     1:       }
     1:     }
     1:   }
     1: #endif
     1: 
     1:   if (mCaret)
     1:     mCaret->EraseCaret();
     1: 
     1:   // XXX Do a full invalidate at the beginning so that invalidates along
     1:   // the way don't have region accumulation issues?
     1: 
   967:   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
     1: 
     1:   // Get the root frame from the frame manager
 28215:   // XXXbz it would be nice to move this somewhere else... like frame manager
 28215:   // Init(), say.  But we need to make sure our views are all set up by the
 28215:   // time we do this!
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
 28215:   NS_ASSERTION(!rootFrame, "How did that happen, exactly?");
 28215:   if (!rootFrame) {
 28215:     nsAutoScriptBlocker scriptBlocker;
 28215:     mFrameConstructor->BeginUpdate();
 28215:     mFrameConstructor->ConstructRootFrame(&rootFrame);
 89328:     mFrameConstructor->SetRootFrame(rootFrame);
 28215:     mFrameConstructor->EndUpdate();
 28215:   }
 28215: 
 28215:   NS_ENSURE_STATE(!mHaveShutDown);
 28215: 
 28215:   if (!rootFrame) {
 28215:     return NS_ERROR_OUT_OF_MEMORY;
 28215:   }
 28215: 
106095:   for (nsIFrame* f = rootFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
106686:     if (f->GetStateBits() & NS_FRAME_NO_COMPONENT_ALPHA) {
106686:       f->InvalidateFrameSubtree();
106095:       f->RemoveStateBits(NS_FRAME_NO_COMPONENT_ALPHA);
106095:     }
106686:   }
106095: 
 41634:   Element *root = mDocument->GetRootElement();
     1: 
     1:   if (root) {
 13098:     {
 29804:       nsAutoCauseReflowNotifier reflowNotifier(this);
  6518:       mFrameConstructor->BeginUpdate();
  6518: 
     1:       // Have the style sheet processor construct frame for the root
     1:       // content object down
 80486:       mFrameConstructor->ContentInserted(nsnull, root, nsnull, false);
     1:       VERIFY_STYLE_TREE;
     1: 
     1:       // Something in mFrameConstructor->ContentInserted may have caused
     1:       // Destroy() to get called, bug 337586.
     1:       NS_ENSURE_STATE(!mHaveShutDown);
  1416: 
  6518:       mFrameConstructor->EndUpdate();
 13098:     }
 13098: 
 28215:     // nsAutoScriptBlocker going out of scope may have killed us too
 13098:     NS_ENSURE_STATE(!mHaveShutDown);
  6518: 
  1416:     // Run the XBL binding constructors for any new frames we've constructed
  1416:     mDocument->BindingManager()->ProcessAttachedQueue();
  1416: 
 42480:     NS_TIME_FUNCTION_MARK("XBL binding constructors fired");
 42480: 
  1416:     // Constructors may have killed us too
  1416:     NS_ENSURE_STATE(!mHaveShutDown);
  1416: 
  1416:     // Now flush out pending restyles before we actually reflow, in
  1416:     // case XBL constructors changed styles somewhere.
 23256:     {
 23256:       nsAutoScriptBlocker scriptBlocker;
 40938:       mFrameConstructor->CreateNeededFrames();
  1416:       mFrameConstructor->ProcessPendingRestyles();
 23256:     }
  1416: 
  1416:     // And that might have run _more_ XBL constructors
  1416:     NS_ENSURE_STATE(!mHaveShutDown);
 28215:   }
 28215: 
 28215:   NS_ASSERTION(rootFrame, "How did that happen?");
 28215: 
 79408:   // Note: when the frame was created above it had the NS_FRAME_IS_DIRTY bit
 79408:   // set, but XBL processing could have caused a reflow which clears it.
 79408:   if (NS_LIKELY(rootFrame->GetStateBits() & NS_FRAME_IS_DIRTY)) {
 79408:     // Unset the DIRTY bits so that FrameNeedsReflow() will work right.
 79408:     rootFrame->RemoveStateBits(NS_FRAME_IS_DIRTY |
 79408:                                NS_FRAME_HAS_DIRTY_CHILDREN);
 24551:     NS_ASSERTION(!mDirtyRoots.Contains(rootFrame),
  1158:                  "Why is the root in mDirtyRoots already?");
  1158:     FrameNeedsReflow(rootFrame, eResize, NS_FRAME_IS_DIRTY);
 24551:     NS_ASSERTION(mDirtyRoots.Contains(rootFrame),
  1158:                  "Should be in mDirtyRoots now");
 38310:     NS_ASSERTION(mReflowScheduled, "Why no reflow scheduled?");
 79408:   }
   752: 
   824:   // Restore our root scroll position now if we're getting here after EndLoad
   967:   // got called, since this is our one chance to do it.  Note that we need not
   967:   // have reflowed for this to work; when the scrollframe is finally reflowed
 89543:   // it'll pick up the position we store in it here.
   824:   if (!mDocumentLoading) {
   824:     RestoreRootScrollPosition();
   824:   }
   824: 
     1:   // For printing, we just immediately unsuppress.
     1:   if (!mPresContext->IsPaginated()) {
     1:     // Kick off a one-shot timer based off our pref value.  When this timer
     1:     // fires, if painting is still locked down, then we will go ahead and
     1:     // trigger a full invalidate and allow painting to proceed normally.
 80486:     mPaintingSuppressed = true;
 67577:     // Don't suppress painting if the document isn't loading.
 67577:     nsIDocument::ReadyState readyState = mDocument->GetReadyStateEnum();
 67577:     if (readyState != nsIDocument::READYSTATE_COMPLETE) {
     1:       mPaintSuppressionTimer = do_CreateInstance("@mozilla.org/timer;1");
 67577:     }
 67577:     if (!mPaintSuppressionTimer) {
 80486:       mPaintingSuppressed = false;
 67577:     } else {
     1:       // Initialize the timer.
     1: 
     1:       // Default to PAINTLOCK_EVENT_DELAY if we can't get the pref value.
     1:       PRInt32 delay =
 70842:         Preferences::GetInt("nglayout.initialpaint.delay",
     1:                             PAINTLOCK_EVENT_DELAY);
     1: 
     1:       mPaintSuppressionTimer->InitWithFuncCallback(sPaintSuppressionCallback,
     1:                                                    this, delay, 
     1:                                                    nsITimer::TYPE_ONE_SHOT);
     1:     }
     1:   }
     1: 
 80773:   if (root && root->IsXUL()) {
 80773:     mozilla::Telemetry::AccumulateTimeDelta(Telemetry::XUL_INITIAL_FRAME_CONSTRUCTION,
 80773:                                             timerStart);
 80773:   }
 80773: 
     1:   return NS_OK; //XXX this needs to be real. MMP
     1: }
     1: 
     1: void
     1: PresShell::sPaintSuppressionCallback(nsITimer *aTimer, void* aPresShell)
     1: {
 28249:   nsRefPtr<PresShell> self = static_cast<PresShell*>(aPresShell);
     1:   if (self)
     1:     self->UnsuppressPainting();
     1: }
     1: 
 31584: void
 31584: PresShell::AsyncResizeEventCallback(nsITimer* aTimer, void* aPresShell)
 31584: {
 31584:   static_cast<PresShell*>(aPresShell)->FireResizeEvent();
 31584: }
 31584: 
 39668: nsresult
 54649: PresShell::ResizeReflowOverride(nscoord aWidth, nscoord aHeight)
 54649: {
 80486:   mViewportOverridden = true;
 54649:   return ResizeReflowIgnoreOverride(aWidth, aHeight);
 54649: }
 54649: 
 54649: nsresult
     1: PresShell::ResizeReflow(nscoord aWidth, nscoord aHeight)
     1: {
 54649:   if (mViewportOverridden) {
 54649:     // The viewport has been overridden, and this reflow request
 54649:     // didn't ask to ignore the override.  Pretend it didn't happen.
 54649:     return NS_OK;
 54649:   }
 54649:   return ResizeReflowIgnoreOverride(aWidth, aHeight);
 54649: }
 54649: 
 54649: nsresult
 54649: PresShell::ResizeReflowIgnoreOverride(nscoord aWidth, nscoord aHeight)
 54649: {
  1503:   NS_PRECONDITION(!mIsReflowing, "Shouldn't be in reflow here!");
 12971:   NS_PRECONDITION(aWidth != NS_UNCONSTRAINEDSIZE,
 12971:                   "shouldn't use unconstrained widths anymore");
  1503:   
     1:   // If we don't have a root frame yet, that means we haven't had our initial
     1:   // reflow... If that's the case, and aWidth or aHeight is unconstrained,
     1:   // ignore them altogether.
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
     1: 
 12971:   if (!rootFrame && aHeight == NS_UNCONSTRAINEDSIZE) {
 12971:     // We can't do the work needed for SizeToContent without a root
 12971:     // frame, and we want to return before setting the visible area.
     1:     return NS_ERROR_NOT_AVAILABLE;
     1:   }
     1: 
 84772:   nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
 84772:   // Take this ref after viewManager so it'll make sure to go away first
 84772:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 84772: 
 57661:   if (!mIsDestroying && !mResizeEvent.IsPending() &&
 57661:       !mAsyncResizeTimerIsActive) {
 57661:     FireBeforeResizeEvent();
 57661:   }
 57661: 
   790:   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
   790: 
   790:   // There isn't anything useful we can do if the initial reflow hasn't happened
 89328:   rootFrame = mFrameConstructor->GetRootFrame();
   790:   if (!rootFrame)
   790:     return NS_OK;
   790: 
 23332:   if (!GetPresContext()->SupressingResizeReflow())
 23332:   {
 36817:     // Have to make sure that the content notifications are flushed before we
 36817:     // start messing with the frame model; otherwise we can get content doubling.
 36817:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 36817: 
  6162:     // Make sure style is up to date
 23256:     {
 23256:       nsAutoScriptBlocker scriptBlocker;
 40938:       mFrameConstructor->CreateNeededFrames();
  6162:       mFrameConstructor->ProcessPendingRestyles();
 23256:     }
 10872: 
 89328:     rootFrame = mFrameConstructor->GetRootFrame();
 84772:     if (!mIsDestroying && rootFrame) {
   821:       // XXX Do a full invalidate at the beginning so that invalidates along
   821:       // the way don't have region accumulation issues?
   821: 
 13098:       {
 29804:         nsAutoCauseReflowNotifier crNotifier(this);
   821:         WillDoReflow();
   821: 
     1:         // Kick off a top-down reflow
     1:         AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
 87348:         nsIViewManager::AutoDisableRefresh refreshBlocker(mViewManager);
     1: 
   816:         mDirtyRoots.RemoveElement(rootFrame);
 80486:         DoReflow(rootFrame, true);
 80486:       }
 80486: 
 80486:       DidDoReflow(true);
  6162:     }
 10872:   }
  6162: 
 89328:   rootFrame = mFrameConstructor->GetRootFrame();
 84772:   if (aHeight == NS_UNCONSTRAINEDSIZE && rootFrame) {
 12971:     mPresContext->SetVisibleArea(
 12971:       nsRect(0, 0, aWidth, rootFrame->GetRect().height));
 12971:   }
 12971: 
 31584:   if (!mIsDestroying && !mResizeEvent.IsPending() &&
 31584:       !mAsyncResizeTimerIsActive) {
 31584:     if (mInResize) {
 31584:       if (!mAsyncResizeEventTimer) {
 31584:         mAsyncResizeEventTimer = do_CreateInstance("@mozilla.org/timer;1");
 31584:       }
 31584:       if (mAsyncResizeEventTimer) {
 80486:         mAsyncResizeTimerIsActive = true;
 31584:         mAsyncResizeEventTimer->InitWithFuncCallback(AsyncResizeEventCallback,
 31584:                                                      this, 15,
 31584:                                                      nsITimer::TYPE_ONE_SHOT);
 31584:       }
 31584:     } else {
 23685:       nsRefPtr<nsRunnableMethod<PresShell> > resizeEvent =
 41361:         NS_NewRunnableMethod(this, &PresShell::FireResizeEvent);
 23685:       if (NS_SUCCEEDED(NS_DispatchToCurrentThread(resizeEvent))) {
 23685:         mResizeEvent = resizeEvent;
 84597:         mDocument->SetNeedStyleFlush();
 23685:       }
  6162:     }
 31584:   }
     1: 
     1:   return NS_OK; //XXX this needs to be real. MMP
     1: }
     1: 
     1: void
 57661: PresShell::FireBeforeResizeEvent()
 57661: {
 57661:   if (mIsDocumentGone)
 57661:     return;
 57661: 
 57661:   // Send beforeresize event from here.
 80486:   nsEvent event(true, NS_BEFORERESIZE_EVENT);
 57661: 
 57661:   nsPIDOMWindow *window = mDocument->GetWindow();
 57661:   if (window) {
 57661:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 57661:     nsEventDispatcher::Dispatch(window, mPresContext, &event);
 57661:   }
 57661: }
 57661: 
 57661: void
 23332: PresShell::FireResizeEvent()
 23332: {
 31584:   if (mAsyncResizeTimerIsActive) {
 80486:     mAsyncResizeTimerIsActive = false;
 31584:     mAsyncResizeEventTimer->Cancel();
 31584:   }
 23685:   mResizeEvent.Revoke();
 23685: 
     1:   if (mIsDocumentGone)
     1:     return;
     1: 
     1:   //Send resize event from here.
 80486:   nsEvent event(true, NS_RESIZE_EVENT);
     1:   nsEventStatus status = nsEventStatus_eIgnore;
     1: 
     1:   nsPIDOMWindow *window = mDocument->GetWindow();
     1:   if (window) {
 31584:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 80486:     mInResize = true;
     1:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
 80486:     mInResize = false;
     1:   }
     1: }
     1: 
 40046: void
 79445: PresShell::SetIgnoreFrameDestruction(bool aIgnore)
     1: {
 94919:   if (mPresContext) {
 94919:     // We need to destroy the image loaders first, as they won't be
 94919:     // notified when frames are destroyed once this setting takes effect.
 94919:     // (See bug 673984)
 94919:     mPresContext->DestroyImageLoaders();
 76338:   }
     1:   mIgnoreFrameDestruction = aIgnore;
 40046: }
 40046: 
 40046: void
     1: PresShell::NotifyDestroyingFrame(nsIFrame* aFrame)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
 47756:   mPresContext->ForgetUpdatePluginGeometryFrame(aFrame);
 47756: 
     1:   if (!mIgnoreFrameDestruction) {
 94919:     mPresContext->StopImagesFor(aFrame);
 37172: 
     1:     mFrameConstructor->NotifyDestroyingFrame(aFrame);
     1: 
 24551:     for (PRInt32 idx = mDirtyRoots.Length(); idx; ) {
  1503:       --idx;
  1503:       if (mDirtyRoots[idx] == aFrame) {
  1503:         mDirtyRoots.RemoveElementAt(idx);
  1503:       }
  1503:     }
     1: 
     1:     // Remove frame properties
 47756:     mPresContext->NotifyDestroyingFrame(aFrame);
 35246: 
 35246:     if (aFrame == mCurrentEventFrame) {
 35246:       mCurrentEventContent = aFrame->GetContent();
 35246:       mCurrentEventFrame = nsnull;
 35246:     }
 35246: 
102909:   #ifdef DEBUG
 35246:     if (aFrame == mDrawEventTargetFrame) {
 35246:       mDrawEventTargetFrame = nsnull;
 35246:     }
 35246:   #endif
 35246: 
 35246:     for (unsigned int i=0; i < mCurrentEventFrameStack.Length(); i++) {
 35246:       if (aFrame == mCurrentEventFrameStack.ElementAt(i)) {
 35246:         //One of our stack frames was deleted.  Get its content so that when we
 35246:         //pop it we can still get its new frame from its content
 35246:         nsIContent *currentEventContent = aFrame->GetContent();
 35246:         mCurrentEventContentStack.ReplaceObjectAt(currentEventContent, i);
 35246:         mCurrentEventFrameStack[i] = nsnull;
 35246:       }
 35246:     }
 35246:   
 35246:     mFramesToDirty.RemoveEntry(aFrame);
     1:   }
     1: }
     1: 
 40056: already_AddRefed<nsCaret> PresShell::GetCaret() const
 40045: {
 40045:   nsCaret* caret = mCaret;
 40045:   NS_IF_ADDREF(caret);
 40045:   return caret;
 40045: }
 40045: 
 40045: void PresShell::MaybeInvalidateCaretPosition()
     1: {
     1:   if (mCaret) {
     1:     mCaret->InvalidateOutsideCaret();
     1:   }
     1: }
     1: 
 15969: void PresShell::SetCaret(nsCaret *aNewCaret)
  6232: {
     1:   mCaret = aNewCaret;
  6232: }
  6232: 
  6232: void PresShell::RestoreCaret()
  6232: {
  6232:   mCaret = mOriginalCaret;
     1: }
     1: 
 79445: NS_IMETHODIMP PresShell::SetCaretEnabled(bool aInEnable)
 79445: {
 79445:   bool oldEnabled = mCaretEnabled;
     1: 
     1:   mCaretEnabled = aInEnable;
     1: 
     1:   if (mCaret && (mCaretEnabled != oldEnabled))
     1:   {
     1: /*  Don't change the caret's selection here! This was an evil side-effect of SetCaretEnabled()
     1:     nsCOMPtr<nsIDOMSelection> domSel;
     1:     if (NS_SUCCEEDED(GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel))) && domSel)
     1:       mCaret->SetCaretDOMSelection(domSel);
     1: */
 15969:     mCaret->SetCaretVisible(mCaretEnabled);
 15969:   }
 15969: 
 15969:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP PresShell::SetCaretReadOnly(bool aReadOnly)
     1: {
     1:   if (mCaret)
     1:     mCaret->SetCaretReadOnly(aReadOnly);
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP PresShell::GetCaretEnabled(bool *aOutEnabled)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aOutEnabled);
     1:   *aOutEnabled = mCaretEnabled;
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP PresShell::SetCaretVisibilityDuringSelection(bool aVisibility)
     1: {
     1:   if (mCaret)
     1:     mCaret->SetVisibilityDuringSelection(aVisibility);
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP PresShell::GetCaretVisible(bool *aOutIsVisible)
 14068: {
 80486:   *aOutIsVisible = false;
 14068:   if (mCaret) {
 14068:     nsresult rv = mCaret->GetCaretVisible(aOutIsVisible);
 14068:     NS_ENSURE_SUCCESS(rv,rv);
 14068:   }
 14068:   return NS_OK;
 14068: }
 14068: 
     1: NS_IMETHODIMP PresShell::SetSelectionFlags(PRInt16 aInEnable)
     1: {
     1:   mSelectionFlags = aInEnable;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP PresShell::GetSelectionFlags(PRInt16 *aOutEnable)
     1: {
     1:   if (!aOutEnable)
     1:     return NS_ERROR_INVALID_ARG;
     1:   *aOutEnable = mSelectionFlags;
     1:   return NS_OK;
     1: }
     1: 
     1: //implementation of nsISelectionController
     1: 
     1: NS_IMETHODIMP 
 79445: PresShell::CharacterMove(bool aForward, bool aExtend)
     1: {
     1:   return mSelection->CharacterMove(aForward, aExtend);  
     1: }
     1: 
     1: NS_IMETHODIMP
 20532: PresShell::CharacterExtendForDelete()
 20532: {
 20532:   return mSelection->CharacterExtendForDelete();
 20532: }
 20532: 
 20532: NS_IMETHODIMP
 43298: PresShell::CharacterExtendForBackspace()
 43298: {
 43298:   return mSelection->CharacterExtendForBackspace();
 43298: }
 43298: 
 43298: NS_IMETHODIMP 
 79445: PresShell::WordMove(bool aForward, bool aExtend)
     1: {
 86091:   nsresult result = mSelection->WordMove(aForward, aExtend);
 86091: // if we can't go down/up any more we must then move caret completely to
 86091: // end/beginning respectively.
 86091:   if (NS_FAILED(result))
 86091:     result = CompleteMove(aForward, aExtend);
 86091:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: PresShell::WordExtendForDelete(bool aForward)
     1: {
     1:   return mSelection->WordExtendForDelete(aForward);  
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: PresShell::LineMove(bool aForward, bool aExtend)
     1: {
     1:   nsresult result = mSelection->LineMove(aForward, aExtend);  
     1: // if we can't go down/up any more we must then move caret completely to 
     1: // end/beginning respectively.
     1:   if (NS_FAILED(result)) 
     1:     result = CompleteMove(aForward,aExtend);
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: PresShell::IntraLineMove(bool aForward, bool aExtend)
     1: {
     1:   return mSelection->IntraLineMove(aForward, aExtend);  
     1: }
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP 
 79445: PresShell::PageMove(bool aForward, bool aExtend)
     1: {
 39248:   nsIScrollableFrame *scrollableFrame =
 39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
 37057:   if (!scrollableFrame)
 37057:     return NS_OK;
 37057: 
 37069:   mSelection->CommonPageMove(aForward, aExtend, scrollableFrame);
 12392:   // After ScrollSelectionIntoView(), the pending notifications might be
 12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
 56442:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
 56442:                                  nsISelectionController::SELECTION_FOCUS_REGION,
 56442:                                  nsISelectionController::SCROLL_SYNCHRONOUS);
     1: }
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP 
 79445: PresShell::ScrollPage(bool aForward)
     1: {
 39248:   nsIScrollableFrame* scrollFrame =
 39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
 37057:   if (scrollFrame) {
 37057:     scrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
 37057:                           nsIScrollableFrame::PAGES,
 37057:                           nsIScrollableFrame::SMOOTH);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: PresShell::ScrollLine(bool aForward)
     1: {
 39248:   nsIScrollableFrame* scrollFrame =
 39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
 37057:   if (scrollFrame) {
 90681:     PRInt32 lineCount = Preferences::GetInt("toolkit.scrollbox.verticalScrollDistance",
 90681:                                             NS_DEFAULT_VERTICAL_SCROLL_DISTANCE);
 37057:     scrollFrame->ScrollBy(nsIntPoint(0, aForward ? lineCount : -lineCount),
 37057:                           nsIScrollableFrame::LINES,
 37057:                           nsIScrollableFrame::SMOOTH);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 86684: PresShell::ScrollCharacter(bool aRight)
     1: {
 39248:   nsIScrollableFrame* scrollFrame =
 39248:     GetFrameToScrollAsScrollable(nsIPresShell::eHorizontal);
 37057:   if (scrollFrame) {
 86684:     scrollFrame->ScrollBy(nsIntPoint(aRight ? 1 : -1, 0),
 37057:                           nsIScrollableFrame::LINES,
 37057:                           nsIScrollableFrame::SMOOTH);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: PresShell::CompleteScroll(bool aForward)
     1: {
 39248:   nsIScrollableFrame* scrollFrame =
 39248:     GetFrameToScrollAsScrollable(nsIPresShell::eVertical);
 37057:   if (scrollFrame) {
 37057:     scrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
 37057:                           nsIScrollableFrame::WHOLE,
 37057:                           nsIScrollableFrame::INSTANT);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: PresShell::CompleteMove(bool aForward, bool aExtend)
     1: {
 12392:   // Beware! This may flush notifications via synchronous
 12392:   // ScrollSelectionIntoView.
 38005:   nsIContent* limiter = mSelection->GetAncestorLimiter();
 38005:   nsIFrame* frame = limiter ? limiter->GetPrimaryFrame()
 38005:                             : FrameConstructor()->GetRootElementFrame();
     1:   if (!frame)
     1:     return NS_ERROR_FAILURE;
 94058:   nsIFrame::CaretPosition pos =
 94058:     frame->GetExtremeCaretPosition(!aForward);
 38005:   mSelection->HandleClick(pos.mResultContent, pos.mContentOffset,
 80486:                           pos.mContentOffset, aExtend, false, aForward);
 38005:   if (limiter) {
 38005:     // HandleClick resets ancestorLimiter, so set it again.
 38005:     mSelection->SetAncestorLimiter(limiter);
 38005:   }
   533:     
 12392:   // After ScrollSelectionIntoView(), the pending notifications might be
 12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
 14558:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, 
 14558:                                  nsISelectionController::SELECTION_FOCUS_REGION,
 56442:                                  nsISelectionController::SCROLL_SYNCHRONOUS);
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: PresShell::SelectAll()
     1: {
     1:   return mSelection->SelectAll();
     1: }
     1: 
 88028: static void
 88028: DoCheckVisibility(nsPresContext* aPresContext,
 88028:                   nsIContent* aNode,
 88028:                   PRInt16 aStartOffset,
 88028:                   PRInt16 aEndOffset,
 88028:                   bool* aRetval)
 88028: {
 88028:   nsIFrame* frame = aNode->GetPrimaryFrame();
 88028:   if (!frame) {
 88028:     // No frame to look at so it must not be visible.
 88028:     return;
 88028:   }
 88028: 
 88028:   // Start process now to go through all frames to find startOffset. Then check
 88028:   // chars after that to see if anything until EndOffset is visible.
 88028:   bool finished = false;
 88028:   frame->CheckVisibility(aPresContext, aStartOffset, aEndOffset, true,
 88028:                          &finished, aRetval);
 88028:   // Don't worry about other return value.
 88028: }
 88028: 
     1: NS_IMETHODIMP
 79445: PresShell::CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, bool *_retval)
     1: {
     1:   if (!node || startOffset>EndOffset || !_retval || startOffset<0 || EndOffset<0)
     1:     return NS_ERROR_INVALID_ARG;
 80486:   *_retval = false; //initialize return parameter
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
     1:   if (!content)
     1:     return NS_ERROR_FAILURE;
 88028: 
 88028:   DoCheckVisibility(mPresContext, content, startOffset, EndOffset, _retval);
     1:   return NS_OK;
 88028: }
 88028: 
 88028: nsresult
 88028: PresShell::CheckVisibilityContent(nsIContent* aNode, PRInt16 aStartOffset,
 88028:                                   PRInt16 aEndOffset, bool* aRetval)
 88028: {
 88028:   if (!aNode || aStartOffset > aEndOffset || !aRetval ||
 88028:       aStartOffset < 0 || aEndOffset < 0) {
 88028:     return NS_ERROR_INVALID_ARG;
 88028:   }
 88028: 
 88028:   *aRetval = false;
 88028:   DoCheckVisibility(mPresContext, aNode, aStartOffset, aEndOffset, aRetval);
 88028:   return NS_OK;
     1: }
     1: 
     1: //end implementations nsISelectionController
     1: 
     1: 
 39668: void
     1: PresShell::StyleChangeReflow()
     1: {
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
   790:   // At the moment at least, we don't have a root frame before the initial
   790:   // reflow; it's safe to just ignore the request in that case
   790:   if (!rootFrame)
 39668:     return;
 39668: 
 39668:   FrameNeedsReflow(rootFrame, eStyleChange, NS_FRAME_IS_DIRTY);
     1: }
     1: 
     1: nsIFrame*
 40054: nsIPresShell::GetRootFrameExternal() const
     1: {
 89328:   return mFrameConstructor->GetRootFrame();
     1: }
     1: 
     1: nsIFrame*
     1: nsIPresShell::GetRootScrollFrame() const
     1: {
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
     1:   // Ensure root frame is a viewport frame
     1:   if (!rootFrame || nsGkAtoms::viewportFrame != rootFrame->GetType())
     1:     return nsnull;
 77154:   nsIFrame* theFrame = rootFrame->GetFirstPrincipalChild();
     1:   if (!theFrame || nsGkAtoms::scrollFrame != theFrame->GetType())
     1:     return nsnull;
     1:   return theFrame;
     1: }
     1: 
     1: nsIScrollableFrame*
     1: nsIPresShell::GetRootScrollFrameAsScrollable() const
     1: {
     1:   nsIFrame* frame = GetRootScrollFrame();
     1:   if (!frame)
     1:     return nsnull;
 23554:   nsIScrollableFrame* scrollableFrame = do_QueryFrame(frame);
  1735:   NS_ASSERTION(scrollableFrame,
  1735:                "All scroll frames must implement nsIScrollableFrame");
     1:   return scrollableFrame;
     1: }
     1: 
 34482: nsIScrollableFrame*
 34482: nsIPresShell::GetRootScrollFrameAsScrollableExternal() const
 34482: {
 34482:   return GetRootScrollFrameAsScrollable();
 34482: }
 34482: 
 39668: nsIPageSequenceFrame*
 39668: PresShell::GetPageSequenceFrame() const
 39668: {
     1:   nsIFrame* frame = mFrameConstructor->GetPageSequenceFrame();
 39668:   return do_QueryFrame(frame);
     1: }
     1: 
  5680: nsIFrame*
  5680: PresShell::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt)
  5680: {
  5680:   return nsLayoutUtils::GetFrameForPoint(aFrame, aPt);
  5680: }
  5680: 
     1: void
     1: PresShell::BeginUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
     1: {
     1: #ifdef DEBUG
     1:   mUpdateCount++;
     1: #endif
     1:   mFrameConstructor->BeginUpdate();
     1: 
     1:   if (aUpdateType & UPDATE_STYLE)
     1:     mStyleSet->BeginUpdate();
     1: }
     1: 
     1: void
     1: PresShell::EndUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
     1: {
     1: #ifdef DEBUG
     1:   NS_PRECONDITION(0 != mUpdateCount, "too many EndUpdate's");
     1:   --mUpdateCount;
     1: #endif
     1: 
     1:   if (aUpdateType & UPDATE_STYLE) {
     1:     mStyleSet->EndUpdate();
     1:     if (mStylesHaveChanged)
     1:       ReconstructStyleData();
     1:   }
     1: 
     1:   mFrameConstructor->EndUpdate();
     1: }
     1: 
     1: void
   824: PresShell::RestoreRootScrollPosition()
   824: {
     1:   // Restore frame state for the root scroll frame
     1:   nsCOMPtr<nsILayoutHistoryState> historyState =
   824:     mDocument->GetLayoutHistoryState();
     1:   // Make sure we don't reenter reflow via the sync paint that happens while
     1:   // we're scrolling to our restored position.  Entering reflow for the
     1:   // scrollable frame will cause it to reenter ScrollToRestoredPosition(), and
     1:   // it'll get all confused.
 13098:   nsAutoScriptBlocker scriptBlocker;
 29804:   ++mChangeNestCount;
     1: 
     1:   if (historyState) {
     1:     nsIFrame* scrollFrame = GetRootScrollFrame();
     1:     if (scrollFrame) {
 23554:       nsIScrollableFrame* scrollableFrame = do_QueryFrame(scrollFrame);
     1:       if (scrollableFrame) {
 89328:         mFrameConstructor->RestoreFrameStateFor(scrollFrame, historyState,
     1:                                                 nsIStatefulFrame::eDocumentScrollState);
     1:         scrollableFrame->ScrollToRestoredPosition();
     1:       }
     1:     }
     1:   }
 29804: 
 29804:   --mChangeNestCount;
   824: }
   824: 
   824: void
   824: PresShell::BeginLoad(nsIDocument *aDocument)
   824: {  
 80486:   mDocumentLoading = true;
   824: }
   824: 
   824: void
   824: PresShell::EndLoad(nsIDocument *aDocument)
   824: {
   824:   NS_PRECONDITION(aDocument == mDocument, "Wrong document");
   824:   
   824:   RestoreRootScrollPosition();
     1:   
 80486:   mDocumentLoading = false;
     1: }
     1: 
   925: #ifdef DEBUG
   925: void
   925: PresShell::VerifyHasDirtyRootAncestor(nsIFrame* aFrame)
   925: {
   925:   // XXXbz due to bug 372769, can't actually assert anything here...
   925:   return;
   925:   
   925:   // XXXbz shouldn't need this part; remove it once FrameNeedsReflow
   925:   // handles the root frame correctly.
   925:   if (!aFrame->GetParent()) {
   925:     return;
   925:   }
   925:         
   925:   // Make sure that there is a reflow root ancestor of |aFrame| that's
   925:   // in mDirtyRoots already.
   925:   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)) {
   925:     if (((aFrame->GetStateBits() & NS_FRAME_REFLOW_ROOT) ||
   925:          !aFrame->GetParent()) &&
 24551:         mDirtyRoots.Contains(aFrame)) {
   925:       return;
   925:     }
   925: 
   925:     aFrame = aFrame->GetParent();
   925:   }
   925:   NS_NOTREACHED("Frame has dirty bits set but isn't scheduled to be "
   925:                 "reflowed?");
   925: }
   925: #endif
   925: 
 39668: void
  1158: PresShell::FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
  1161:                             nsFrameState aBitToAdd)
  1161: {
 42480: #ifdef NS_FUNCTION_TIMER
 42480:   NS_TIME_FUNCTION_DECLARE_DOCURL;
 42480:   nsCAutoString frameType__("N/A");
 42480:   nsIAtom *atomType__ = aFrame ? aFrame->GetType() : nsnull;
 42480:   if (atomType__) atomType__->ToUTF8String(frameType__);
 42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (document: %s, frame type: %s)", MOZ_FUNCTION_NAME,
 42480:                            __LINE__, docURL__.get(), frameType__.get());
 42480: #endif
 42480: 
  1161:   NS_PRECONDITION(aBitToAdd == NS_FRAME_IS_DIRTY ||
  1161:                   aBitToAdd == NS_FRAME_HAS_DIRTY_CHILDREN,
  1158:                   "Unexpected bits being added");
 24631:   NS_PRECONDITION(aIntrinsicDirty != eStyleChange ||
 24631:                   aBitToAdd == NS_FRAME_IS_DIRTY,
 24631:                   "bits don't correspond to style change reason");
     1: 
  1503:   NS_ASSERTION(!mIsReflowing, "can't mark frame dirty during reflow");
     1: 
     1:   // If we've not yet done the initial reflow, then don't bother
     1:   // enqueuing a reflow command yet.
     1:   if (! mDidInitialReflow)
 39668:     return;
     1: 
     1:   // If we're already destroying, don't bother with this either.
     1:   if (mIsDestroying)
 39668:     return;
     1: 
     1: #ifdef DEBUG
     1:   //printf("gShellCounter: %d\n", gShellCounter++);
 39668:   if (mInVerifyReflow)
 39668:     return;
  1735: 
     1:   if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
     1:     printf("\nPresShell@%p: frame %p needs reflow\n", (void*)this, (void*)aFrame);
     1:     if (VERIFY_REFLOW_REALLY_NOISY_RC & gVerifyReflowFlags) {
     1:       printf("Current content model:\n");
 41634:       Element *rootElement = mDocument->GetRootElement();
 41634:       if (rootElement) {
 41634:         rootElement->List(stdout, 0);
     1:       }
     1:     }
     1:   }  
     1: #endif
     1: 
 24631:   nsAutoTArray<nsIFrame*, 4> subtrees;
 24631:   subtrees.AppendElement(aFrame);
 24631: 
 24631:   do {
 24631:     nsIFrame *subtreeRoot = subtrees.ElementAt(subtrees.Length() - 1);
 24631:     subtrees.RemoveElementAt(subtrees.Length() - 1);
 24631: 
 24631:     // Grab |wasDirty| now so we can go ahead and update the bits on
 24631:     // subtreeRoot.
 79445:     bool wasDirty = NS_SUBTREE_DIRTY(subtreeRoot);
 24631:     subtreeRoot->AddStateBits(aBitToAdd);
 24631: 
 24631:     // Now if subtreeRoot is a reflow root we can cut off this reflow at it if
 24631:     // the bit being added is NS_FRAME_HAS_DIRTY_CHILDREN.
 79445:     bool targetFrameDirty = (aBitToAdd == NS_FRAME_IS_DIRTY);
  2472: 
  1158: #define FRAME_IS_REFLOW_ROOT(_f)                   \
  1158:   ((_f->GetStateBits() & NS_FRAME_REFLOW_ROOT) &&  \
 24631:    (_f != subtreeRoot || !targetFrameDirty))
  1158: 
  1158: 
     1:     // Mark the intrinsic widths as dirty on the frame, all of its ancestors,
     1:     // and all of its descendants, if needed:
     1: 
     1:     if (aIntrinsicDirty != eResize) {
 24631:       // Mark argument and all ancestors dirty. (Unless we hit a reflow
 24631:       // root that should contain the reflow.  That root could be
 24631:       // subtreeRoot itself if it's not dirty, or it could be some
 24631:       // ancestor of subtreeRoot.)
 24631:       for (nsIFrame *a = subtreeRoot;
  1158:            a && !FRAME_IS_REFLOW_ROOT(a);
     1:            a = a->GetParent())
     1:         a->MarkIntrinsicWidthsDirty();
     1:     }
     1: 
     1:     if (aIntrinsicDirty == eStyleChange) {
 24551:       // Mark all descendants dirty (using an nsTArray stack rather than
     1:       // recursion).
101736:       // Note that nsHTMLReflowState::InitResizeFlags has some similar
101736:       // code; see comments there for how and why it differs.
 24631:       nsAutoTArray<nsIFrame*, 32> stack;
 24631:       stack.AppendElement(subtreeRoot);
 24631: 
 24631:       do {
 24631:         nsIFrame *f = stack.ElementAt(stack.Length() - 1);
 24551:         stack.RemoveElementAt(stack.Length() - 1);
     1: 
 24631:         if (f->GetType() == nsGkAtoms::placeholderFrame) {
 24631:           nsIFrame *oof = nsPlaceholderFrame::GetRealFrameForPlaceholder(f);
 24631:           if (!nsLayoutUtils::IsProperAncestorFrame(subtreeRoot, oof)) {
 24631:             // We have another distinct subtree we need to mark.
 24631:             subtrees.AppendElement(oof);
 24631:           }
 24631:         }
 24631: 
 77153:         nsIFrame::ChildListIterator lists(f);
 77153:         for (; !lists.IsDone(); lists.Next()) {
 77153:           nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:           for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:             nsIFrame* kid = childFrames.get();
     1:             kid->MarkIntrinsicWidthsDirty();
     1:             stack.AppendElement(kid);
     1:           }
 77153:         }
 24631:       } while (stack.Length() != 0);
 24631:     }
 24631: 
 24631:     // Set NS_FRAME_HAS_DIRTY_CHILDREN bits (via nsIFrame::ChildIsDirty)
 24631:     // up the tree until we reach either a frame that's already dirty or
 24631:     // a reflow root.
 24631:     nsIFrame *f = subtreeRoot;
     1:     for (;;) {
  1158:       if (FRAME_IS_REFLOW_ROOT(f) || !f->GetParent()) {
     1:         // we've hit a reflow root or the root frame
     1:         if (!wasDirty) {
     1:           mDirtyRoots.AppendElement(f);
 84597:           mDocument->SetNeedLayoutFlush();
     1:         }
   925: #ifdef DEBUG
   925:         else {
   925:           VerifyHasDirtyRootAncestor(f);
   925:         }
   925: #endif
   925:         
     1:         break;
     1:       }
     1: 
     1:       nsIFrame *child = f;
     1:       f = f->GetParent();
  1158:       wasDirty = NS_SUBTREE_DIRTY(f);
     1:       f->ChildIsDirty(child);
     1:       NS_ASSERTION(f->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN,
     1:                    "ChildIsDirty didn't do its job");
     1:       if (wasDirty) {
     1:         // This frame was already marked dirty.
   925: #ifdef DEBUG
   925:         VerifyHasDirtyRootAncestor(f);
   925: #endif
     1:         break;
     1:       }
     1:     }
 24631:   } while (subtrees.Length() != 0);
     1: 
 38310:   MaybeScheduleReflow();
 39668: }
 39668: 
 39668: void
 27993: PresShell::FrameNeedsToContinueReflow(nsIFrame *aFrame)
 27993: {
 27993:   NS_ASSERTION(mIsReflowing, "Must be in reflow when marking path dirty.");  
 27993:   NS_PRECONDITION(mCurrentReflowRoot, "Must have a current reflow root here");
 27993:   NS_ASSERTION(aFrame == mCurrentReflowRoot ||
 27993:                nsLayoutUtils::IsProperAncestorFrame(mCurrentReflowRoot, aFrame),
 27993:                "Frame passed in is not the descendant of mCurrentReflowRoot");
 27993:   NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IN_REFLOW,
 27993:                "Frame passed in not in reflow?");
 27993: 
 27993:   mFramesToDirty.PutEntry(aFrame);
 27993: }
 27993: 
 37057: nsIScrollableFrame*
 39248: nsIPresShell::GetFrameToScrollAsScrollable(
 39248:                 nsIPresShell::ScrollDirection aDirection)
 37057: {
 37057:   nsIScrollableFrame* scrollFrame = nsnull;
 29018: 
     1:   nsCOMPtr<nsIContent> focusedContent;
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm && mDocument) {
 29018:     nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(mDocument->GetWindow());
 29018: 
 29018:     nsCOMPtr<nsIDOMElement> focusedElement;
 80486:     fm->GetFocusedElementForWindow(window, false, nsnull, getter_AddRefs(focusedElement));
 29018:     focusedContent = do_QueryInterface(focusedElement);
 29018:   }
     1:   if (!focusedContent && mSelection) {
     1:     nsISelection* domSelection = mSelection->
     1:       GetSelection(nsISelectionController::SELECTION_NORMAL);
     1:     if (domSelection) {
     1:       nsCOMPtr<nsIDOMNode> focusedNode;
     1:       domSelection->GetFocusNode(getter_AddRefs(focusedNode));
     1:       focusedContent = do_QueryInterface(focusedNode);
     1:     }
     1:   }
     1:   if (focusedContent) {
 36656:     nsIFrame* startFrame = focusedContent->GetPrimaryFrame();
     1:     if (startFrame) {
 37057:       scrollFrame = startFrame->GetScrollTargetFrame();
 37057:       if (scrollFrame) {
 37057:         startFrame = scrollFrame->GetScrolledFrame();
 37057:       }
 39248:       if (aDirection == nsIPresShell::eEither) {
 37057:         scrollFrame =
 39248:           nsLayoutUtils::GetNearestScrollableFrame(startFrame);
 39248:       } else {
 39248:         scrollFrame =
 39248:           nsLayoutUtils::GetNearestScrollableFrameForDirection(startFrame,
 39248:             aDirection == eVertical ? nsLayoutUtils::eVertical :
 39248:                                       nsLayoutUtils::eHorizontal);
 39248:       }
 37057:     }
 37057:   }
 37057:   if (!scrollFrame) {
 37057:     scrollFrame = GetRootScrollFrameAsScrollable();
 37057:   }
 37057:   return scrollFrame;
     1: }
     1: 
 39668: void
     1: PresShell::CancelAllPendingReflows()
     1: {
     1:   mDirtyRoots.Clear();
     1: 
 38310:   if (mReflowScheduled) {
 50365:     GetPresContext()->RefreshDriver()->RemoveLayoutFlushObserver(this);
 80486:     mReflowScheduled = false;
 38310:   }
 38310: 
 38310:   ASSERT_REFLOW_SCHEDULED_STATE();
     1: }
     1: 
 40046: nsresult
     1: PresShell::RecreateFramesFor(nsIContent* aContent)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   NS_ENSURE_TRUE(mPresContext, NS_ERROR_FAILURE);
  1271:   if (!mDidInitialReflow) {
  1271:     // Nothing to do here.  In fact, if we proceed and aContent is the
  1271:     // root we will crash.
  1271:     return NS_OK;
  1271:   }
     1: 
     1:   // Don't call RecreateFramesForContent since that is not exported and we want
     1:   // to keep the number of entrypoints down.
     1: 
     1:   NS_ASSERTION(mViewManager, "Should have view manager");
     1: 
     1:   // Have to make sure that the content notifications are flushed before we
     1:   // start messing with the frame model; otherwise we can get content doubling.
     1:   mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
     1: 
 13098:   nsAutoScriptBlocker scriptBlocker;
 13098: 
     1:   nsStyleChangeList changeList;
     1:   changeList.AppendChange(nsnull, aContent, nsChangeHint_ReconstructFrame);
     1: 
 29804:   // Mark ourselves as not safe to flush while we're doing frame construction.
 29804:   ++mChangeNestCount;
     1:   nsresult rv = mFrameConstructor->ProcessRestyledFrames(changeList);
 29804:   --mChangeNestCount;
  7017:   
     1:   return rv;
     1: }
     1: 
 15538: void
 42327: nsIPresShell::PostRecreateFramesFor(Element* aElement)
 42327: {
 43794:   FrameConstructor()->PostRestyleEvent(aElement, nsRestyleHint(0),
 15538:                                        nsChangeHint_ReconstructFrame);
 15538: }
 15538: 
 32401: void
 46468: nsIPresShell::RestyleForAnimation(Element* aElement, nsRestyleHint aHint)
 46468: {
 46468:   FrameConstructor()->PostAnimationRestyleEvent(aElement, aHint,
 32401:                                                 NS_STYLE_HINT_NONE);
 32401: }
 32401: 
 40046: void
     1: PresShell::ClearFrameRefs(nsIFrame* aFrame)
     1: {
     1:   mPresContext->EventStateManager()->ClearFrameRefs(aFrame);
     1: 
     1:   nsWeakFrame* weakFrame = mWeakFrames;
     1:   while (weakFrame) {
     1:     nsWeakFrame* prev = weakFrame->GetPreviousWeakFrame();
     1:     if (weakFrame->GetFrame() == aFrame) {
     1:       // This removes weakFrame from mWeakFrames.
     1:       weakFrame->Clear(this);
     1:     }
     1:     weakFrame = prev;
     1:   }
 40046: }
 40046: 
 68481: already_AddRefed<nsRenderingContext>
 51038: PresShell::GetReferenceRenderingContext()
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
 68668:   nsDeviceContext* devCtx = mPresContext->DeviceContext();
 68481:   nsRefPtr<nsRenderingContext> rc;
     1:   if (mPresContext->IsScreen()) {
 68670:     rc = new nsRenderingContext();
 51038:     rc->Init(devCtx, gfxPlatform::GetPlatform()->ScreenReferenceSurface());
     1:   } else {
 51038:     devCtx->CreateRenderingContext(*getter_AddRefs(rc));
 51038:   }
 51038:   return rc.forget();
     1: }
     1: 
 40046: nsresult
 79445: PresShell::GoToAnchor(const nsAString& aAnchorName, bool aScroll)
     1: {
     1:   if (!mDocument) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   
 98726:   const Element *root = mDocument->GetRootElement();
 98726:   if (root && root->IsSVG(nsGkAtoms::svg)) {
 98726:     // We need to execute this even if there is an empty anchor name
 98726:     // so that any existing SVG fragment identifier effect is removed
 98726:     if (SVGFragmentIdentifier::ProcessFragmentIdentifier(mDocument, aAnchorName)) {
 98726:       return NS_OK;
 98726:     }
 98726:   }
 98726: 
     1:   // Hold a reference to the ESM in case event dispatch tears us down.
 68780:   nsRefPtr<nsEventStateManager> esm = mPresContext->EventStateManager();
     1: 
     1:   if (aAnchorName.IsEmpty()) {
     1:     NS_ASSERTION(!aScroll, "can't scroll to empty anchor name");
     1:     esm->SetContentState(nsnull, NS_EVENT_STATE_URLTARGET);
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
     1:   nsresult rv = NS_OK;
     1:   nsCOMPtr<nsIContent> content;
     1: 
     1:   // Search for an element with a matching "id" attribute
 44209:   if (mDocument) {    
 44209:     content = mDocument->GetElementById(aAnchorName);
     1:   }
     1: 
     1:   // Search for an anchor element with a matching "name" attribute
     1:   if (!content && htmlDoc) {
     1:     nsCOMPtr<nsIDOMNodeList> list;
     1:     // Find a matching list of named nodes
     1:     rv = htmlDoc->GetElementsByName(aAnchorName, getter_AddRefs(list));
     1:     if (NS_SUCCEEDED(rv) && list) {
     1:       PRUint32 i;
     1:       // Loop through the named nodes looking for the first anchor
 80486:       for (i = 0; true; i++) {
     1:         nsCOMPtr<nsIDOMNode> node;
     1:         rv = list->Item(i, getter_AddRefs(node));
     1:         if (!node) {  // End of list
     1:           break;
     1:         }
     1:         // Ensure it's an anchor element
     1:         content = do_QueryInterface(node);
     1:         if (content) {
 33329:           if (content->Tag() == nsGkAtoms::a && content->IsHTML()) {
     1:             break;
     1:           }
     1:           content = nsnull;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   // Search for anchor in the HTML namespace with a matching name
     1:   if (!content && !htmlDoc)
     1:   {
 44209:     nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(mDocument);
     1:     nsCOMPtr<nsIDOMNodeList> list;
     1:     NS_NAMED_LITERAL_STRING(nameSpace, "http://www.w3.org/1999/xhtml");
     1:     // Get the list of anchor elements
     1:     rv = doc->GetElementsByTagNameNS(nameSpace, NS_LITERAL_STRING("a"), getter_AddRefs(list));
     1:     if (NS_SUCCEEDED(rv) && list) {
     1:       PRUint32 i;
     1:       // Loop through the named nodes looking for the first anchor
 80486:       for (i = 0; true; i++) {
     1:         nsCOMPtr<nsIDOMNode> node;
     1:         rv = list->Item(i, getter_AddRefs(node));
     1:         if (!node) { // End of list
     1:           break;
     1:         }
     1:         // Compare the name attribute
     1:         nsCOMPtr<nsIDOMElement> element = do_QueryInterface(node);
     1:         nsAutoString value;
     1:         if (element && NS_SUCCEEDED(element->GetAttribute(NS_LITERAL_STRING("name"), value))) {
     1:           if (value.Equals(aAnchorName)) {
     1:             content = do_QueryInterface(element);
     1:             break;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   esm->SetContentState(content, NS_EVENT_STATE_URLTARGET);
     1: 
 34455: #ifdef ACCESSIBILITY
 34455:   nsIContent *anchorTarget = content;
 34455: #endif
 34455: 
     1:   if (content) {
     1:     if (aScroll) {
 93554:       rv = ScrollContentIntoView(content,
 93554:                                  ScrollAxis(SCROLL_TOP, SCROLL_ALWAYS),
 93554:                                  ScrollAxis(),
 62343:                                  ANCHOR_SCROLL_FLAGS);
     1:       NS_ENSURE_SUCCESS(rv, rv);
 12356: 
 12356:       nsIScrollableFrame* rootScroll = GetRootScrollFrameAsScrollable();
 12356:       if (rootScroll) {
 12356:         mLastAnchorScrolledTo = content;
 12356:         mLastAnchorScrollPositionY = rootScroll->GetScrollPosition().y;
 12356:       }
     1:     }
     1: 
     1:     // Should we select the target? This action is controlled by a
     1:     // preference: the default is to not select.
 79445:     bool selectAnchor = Preferences::GetBool("layout.selectanchor");
     1: 
     1:     // Even if select anchor pref is false, we must still move the
     1:     // caret there. That way tabbing will start from the new
     1:     // location
 86939:     nsRefPtr<nsIDOMRange> jumpToRange = new nsRange();
 87304:     while (content && content->GetFirstChild()) {
 87304:       content = content->GetFirstChild();
     1:     }
     1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));
     1:     NS_ASSERTION(node, "No nsIDOMNode for descendant of anchor");
     1:     jumpToRange->SelectNodeContents(node);
     1:     // Select the anchor
     1:     nsISelection* sel = mSelection->
     1:       GetSelection(nsISelectionController::SELECTION_NORMAL);
     1:     if (sel) {
     1:       sel->RemoveAllRanges();
     1:       sel->AddRange(jumpToRange);
     1:       if (!selectAnchor) {
     1:         // Use a caret (collapsed selection) at the start of the anchor
     1:         sel->CollapseToStart();
     1:       }
 59581:     }
     1:     // Selection is at anchor.
     1:     // Now focus the document itself if focus is on an element within it.
     1:     nsPIDOMWindow *win = mDocument->GetWindow();
     1: 
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     if (fm && win) {
 29018:       nsCOMPtr<nsIDOMWindow> focusedWindow;
 29018:       fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
 86939:       if (SameCOMIdentity(win, focusedWindow)) {
 29018:         fm->ClearFocus(focusedWindow);
     1:       }
     1:     }
 98726: 
 98726:     // If the target is an animation element, activate the animation
 98726:     if (content->IsNodeOfType(nsINode::eANIMATION)) {
 98726:       nsSVGUtils::ActivateByHyperlink(content.get());
 98726:     }
     1:   } else {
 79615:     rv = NS_ERROR_FAILURE;
 79615:     NS_NAMED_LITERAL_STRING(top, "top");
 79615:     if (nsContentUtils::EqualsIgnoreASCIICase(aAnchorName, top)) {
 79615:       // Scroll to the top/left if aAnchorName is "top" and there is no element
 79615:       // with such a name or id.
     1:       rv = NS_OK;
 37073:       nsIScrollableFrame* sf = GetRootScrollFrameAsScrollable();
     1:       // Check |aScroll| after setting |rv| so we set |rv| to the same
     1:       // thing whether or not |aScroll| is true.
 37073:       if (aScroll && sf) {
     1:         // Scroll to the top of the page
 37073:         sf->ScrollTo(nsPoint(0, 0), nsIScrollableFrame::INSTANT);
     1:       }
     1:     }
     1:   }
     1: 
 34455: #ifdef ACCESSIBILITY
 61464:   if (anchorTarget) {
 61464:     nsAccessibilityService* accService = AccService();
 34455:     if (accService)
 34455:       accService->NotifyOfAnchorJumpTo(anchorTarget);
 34455:   }
 34455: #endif
 34455: 
     1:   return rv;
     1: }
     1: 
 40046: nsresult
 12356: PresShell::ScrollToAnchor()
 12356: {
 12356:   if (!mLastAnchorScrolledTo)
 12356:     return NS_OK;
 12356: 
 42357:   NS_ASSERTION(mDidInitialReflow, "should have done initial reflow by now");
 42357: 
 12356:   nsIScrollableFrame* rootScroll = GetRootScrollFrameAsScrollable();
 12356:   if (!rootScroll ||
 12356:       mLastAnchorScrollPositionY != rootScroll->GetScrollPosition().y)
 12356:     return NS_OK;
 12356: 
 93554:   nsresult rv = ScrollContentIntoView(mLastAnchorScrolledTo,
 93554:                                       ScrollAxis(SCROLL_TOP, SCROLL_ALWAYS),
 93554:                                       ScrollAxis(),
 62343:                                       ANCHOR_SCROLL_FLAGS);
 12356:   mLastAnchorScrolledTo = nsnull;
 12356:   return rv;
 12356: }
 12356: 
  3508: /*
  3508:  * Helper (per-continuation) for ScrollContentIntoView.
  3508:  *
 37074:  * @param aContainerFrame [in] the frame which aRect is relative to
  3508:  * @param aFrame [in] Frame whose bounds should be unioned
 37074:  * @param aUseWholeLineHeightForInlines [in] if true, then for inline frames
 37074:  * we should include the top of the line in the added rectangle
  3508:  * @param aRect [inout] rect into which its bounds should be unioned
  3510:  * @param aHaveRect [inout] whether aRect contains data yet
 77978:  * @param aPrevBlock [inout] the block aLines is a line iterator for
 77978:  * @param aLines [inout] the line iterator we're using
 77978:  * @param aCurLine [inout] the line to start looking from in this iterator
  3508:  */
  3508: static void
 37074: AccumulateFrameBounds(nsIFrame* aContainerFrame,
 37074:                       nsIFrame* aFrame,
 79445:                       bool aUseWholeLineHeightForInlines,
  3508:                       nsRect& aRect,
 79445:                       bool& aHaveRect,
 77978:                       nsIFrame*& aPrevBlock,
 77978:                       nsAutoLineIterator& aLines,
 77978:                       PRInt32& aCurLine)
 37074: {
102668:   nsRect frameBounds = aFrame->GetRect() +
102668:     aFrame->GetParent()->GetOffsetTo(aContainerFrame);
  3508: 
  3508:   // If this is an inline frame and either the bounds height is 0 (quirks
 37074:   // layout model) or aUseWholeLineHeightForInlines is set, we need to
  3508:   // change the top of the bounds to include the whole line.
 37074:   if (frameBounds.height == 0 || aUseWholeLineHeightForInlines) {
102668:     nsIAtom* frameType = NULL;
  3508:     nsIFrame *prevFrame = aFrame;
  3508:     nsIFrame *f = aFrame;
  3508: 
102668:     while (f &&
102668:            (frameType = f->GetType()) == nsGkAtoms::inlineFrame) {
  3508:       prevFrame = f;
  3508:       f = prevFrame->GetParent();
  3508:     }
  3508: 
  3508:     if (f != aFrame &&
  3508:         f &&
102668:         frameType == nsGkAtoms::blockFrame) {
  3508:       // find the line containing aFrame and increase the top of |offset|.
 77978:       if (f != aPrevBlock) {
 77978:         aLines = f->GetLineIterator();
 77978:         aPrevBlock = f;
 77978:         aCurLine = 0;
 77978:       }
 77978:       if (aLines) {
 77978:         PRInt32 index = aLines->FindLineContaining(prevFrame, aCurLine);
  3508:         if (index >= 0) {
 77978:           aCurLine = index;
  3508:           nsIFrame *trash1;
  3508:           PRInt32 trash2;
  3508:           nsRect lineBounds;
  3508:           PRUint32 trash3;
  3508: 
 77978:           if (NS_SUCCEEDED(aLines->GetLine(index, &trash1, &trash2,
  3508:                                            lineBounds, &trash3))) {
102668:             lineBounds += f->GetOffsetTo(aContainerFrame);
 37074:             if (lineBounds.y < frameBounds.y) {
 37074:               frameBounds.height = frameBounds.YMost() - lineBounds.y;
 37074:               frameBounds.y = lineBounds.y;
 37074:             }
 37074:           }
 37074:         }
 37074:       }
 37074:     }
 37074:   }
 37074: 
  3510:   if (aHaveRect) {
  3510:     // We can't use nsRect::UnionRect since it drops empty rects on
  3510:     // the floor, and we need to include them.  (Thus we need
  3510:     // aHaveRect to know when to drop the initial value on the floor.)
102668:     aRect.UnionRectEdges(aRect, frameBounds);
  3510:   } else {
 80486:     aHaveRect = true;
102668:     aRect = frameBounds;
  3510:   }
  3508: }
  3508: 
 93554: static bool
 93554: ComputeNeedToScroll(nsIPresShell::WhenToScroll aWhenToScroll,
 93554:                     nscoord                    aLineSize,
 93554:                     nscoord                    aRectMin,
 93554:                     nscoord                    aRectMax,
 93554:                     nscoord                    aViewMin,
 93554:                     nscoord                    aViewMax) {
 93554:   // See how the rect should be positioned vertically
 93554:   if (nsIPresShell::SCROLL_ALWAYS == aWhenToScroll) {
 93554:     // The caller wants the frame as visible as possible
 93554:     return true;
 93554:   } else if (nsIPresShell::SCROLL_IF_NOT_VISIBLE == aWhenToScroll) {
 93554:     // Scroll only if no part of the frame is visible in this view
 93554:     return aRectMax - aLineSize <= aViewMin ||
 93554:            aRectMin + aLineSize >= aViewMax;
 93554:   } else if (nsIPresShell::SCROLL_IF_NOT_FULLY_VISIBLE == aWhenToScroll) {
 93554:     // Scroll only if part of the frame is hidden and more can fit in view
 93554:     return !(aRectMin >= aViewMin && aRectMax <= aViewMax) &&
 93554:       NS_MIN(aViewMax, aRectMax) - NS_MAX(aRectMin, aViewMin) < aViewMax - aViewMin;
 93554:   }
 93554:   return false;
 93554: }
 93554: 
 93554: static nscoord
 93554: ComputeWhereToScroll(PRInt16 aWhereToScroll,
 93554:                      nscoord aOriginalCoord,
 93554:                      nscoord aRectMin,
 93554:                      nscoord aRectMax,
 93554:                      nscoord aViewMin,
 98196:                      nscoord aViewMax,
 98196:                      nscoord* aRangeMin,
 98196:                      nscoord* aRangeMax) {
 93554:   nscoord resultCoord = aOriginalCoord;
 98196:   // Allow the scroll operation to land anywhere that
 98196:   // makes the whole rectangle visible.
 93554:   if (nsIPresShell::SCROLL_MINIMUM == aWhereToScroll) {
 93554:     if (aRectMin < aViewMin) {
 93554:       // Scroll up so the frame's top edge is visible
 93554:       resultCoord = aRectMin;
 93554:     } else if (aRectMax > aViewMax) {
 93554:       // Scroll down so the frame's bottom edge is visible. Make sure the
 93554:       // frame's top edge is still visible
 93554:       resultCoord = aOriginalCoord + aRectMax - aViewMax;
 93554:       if (resultCoord > aRectMin) {
 93554:         resultCoord = aRectMin;
 93554:       }
 93554:     }
 93554:   } else {
 93554:     nscoord frameAlignCoord =
 93554:       NSToCoordRound(aRectMin + (aRectMax - aRectMin) * (aWhereToScroll / 100.0f));
 93554:     resultCoord =  NSToCoordRound(frameAlignCoord - (aViewMax - aViewMin) * (
 93554:                                   aWhereToScroll / 100.0f));
 93554:   }
 98196:   nscoord scrollPortLength = aViewMax - aViewMin;
 98196:   // Force the scroll range to extend to include resultCoord.
 98196:   *aRangeMin = NS_MIN(resultCoord, aRectMax - scrollPortLength);
 98196:   *aRangeMax = NS_MAX(resultCoord, aRectMin);
 93554:   return resultCoord;
 93554: }
 93554: 
     1: /**
 37074:  * This function takes a scrollable frame, a rect in the coordinate system
 37074:  * of the scrolled frame, and a desired percentage-based scroll
 37074:  * position and attempts to scroll the rect to that position in the
 37074:  * scrollport.
 37077:  * 
 37077:  * This needs to work even if aRect has a width or height of zero.
     1:  */
 37074: static void ScrollToShowRect(nsIScrollableFrame*      aScrollFrame,
 37074:                              const nsRect&            aRect,
 93554:                              nsIPresShell::ScrollAxis aVertical,
 93554:                              nsIPresShell::ScrollAxis aHorizontal,
 37077:                              PRUint32                 aFlags)
     1: {
 37074:   nsPoint scrollPt = aScrollFrame->GetScrollPosition();
101616:   nsRect visibleRect(scrollPt,
101616:                      aScrollFrame->GetScrollPositionClampingScrollPortSize());
101616: 
 98196:   nsSize lineSize;
 98196:   // Don't call GetLineScrollAmount unless we actually need it. Not only
 98196:   // does this save time, but it's not safe to call GetLineScrollAmount
 98196:   // during reflow (because it depends on font size inflation and doesn't
 98196:   // use the in-reflow-safe font-size inflation path). If we did call it,
 98196:   // it would assert and possible give the wrong result.
 98196:   if (aVertical.mWhenToScroll == nsIPresShell::SCROLL_IF_NOT_VISIBLE ||
 98196:       aHorizontal.mWhenToScroll == nsIPresShell::SCROLL_IF_NOT_VISIBLE) {
 98196:     lineSize = aScrollFrame->GetLineScrollAmount();
 98196:   }
 37077:   nsPresContext::ScrollbarStyles ss = aScrollFrame->GetScrollbarStyles();
 98196:   nsRect allowedRange(scrollPt, nsSize(0, 0));
 98617:   bool needToScroll = false;
 37077: 
 37077:   if ((aFlags & nsIPresShell::SCROLL_OVERFLOW_HIDDEN) ||
 37077:       ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN) {
 93554: 
 93554:     if (ComputeNeedToScroll(aVertical.mWhenToScroll,
 93554:                             lineSize.height,
 93554:                             aRect.y,
 93554:                             aRect.YMost(),
 93554:                             visibleRect.y,
 93554:                             visibleRect.YMost())) {
 98196:       nscoord maxHeight;
 93554:       scrollPt.y = ComputeWhereToScroll(aVertical.mWhereToScroll,
 93554:                                         scrollPt.y,
 93554:                                         aRect.y,
 93554:                                         aRect.YMost(),
 93554:                                         visibleRect.y,
 98196:                                         visibleRect.YMost(),
 98196:                                         &allowedRange.y, &maxHeight);
 98196:       allowedRange.height = maxHeight - allowedRange.y;
 98617:       needToScroll = true;
     1:     }
 37077:   }
 37077: 
 37077:   if ((aFlags & nsIPresShell::SCROLL_OVERFLOW_HIDDEN) ||
 37077:       ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN) {
 93554: 
 93554:     if (ComputeNeedToScroll(aHorizontal.mWhenToScroll,
 93554:                             lineSize.width,
 93554:                             aRect.x,
 93554:                             aRect.XMost(),
 93554:                             visibleRect.x,
 93554:                             visibleRect.XMost())) {
 98196:       nscoord maxWidth;
 93554:       scrollPt.x = ComputeWhereToScroll(aHorizontal.mWhereToScroll,
 93554:                                         scrollPt.x,
 93554:                                         aRect.x,
 93554:                                         aRect.XMost(),
 93554:                                         visibleRect.x,
 98196:                                         visibleRect.XMost(),
 98196:                                         &allowedRange.x, &maxWidth);
 98196:       allowedRange.width = maxWidth - allowedRange.x;
 98617:       needToScroll = true;
 98617:     }
 98617:   }
 98617: 
 98617:   // If we don't need to scroll, then don't try since it might cancel
 98617:   // a current smooth scroll operation.
 98617:   if (needToScroll) {
 98196:     aScrollFrame->ScrollTo(scrollPt, nsIScrollableFrame::INSTANT, &allowedRange);
     1:   }
 98617: }
     1: 
 98654: static void
 98654: DeleteScrollIntoViewData(void* aObject, nsIAtom* aPropertyName,
 98654:                          void* aPropertyValue, void* aData)
 98654: {
 98654:   PresShell::ScrollIntoViewData* data =
 98654:     static_cast<PresShell::ScrollIntoViewData*>(aPropertyValue);
 98654:   delete data;
 98654: }
 98654: 
 40046: nsresult
     1: PresShell::ScrollContentIntoView(nsIContent*              aContent,
 93554:                                  nsIPresShell::ScrollAxis aVertical,
 93554:                                  nsIPresShell::ScrollAxis aHorizontal,
 56647:                                  PRUint32                 aFlags)
 27993: {
 98654:   NS_ENSURE_TRUE(aContent, NS_ERROR_NULL_POINTER);
 98654:   nsCOMPtr<nsIDocument> currentDoc = aContent->GetCurrentDoc();
     1:   NS_ENSURE_STATE(currentDoc);
     1: 
 42357:   NS_ASSERTION(mDidInitialReflow, "should have done initial reflow by now");
 42357: 
 98654:   if (mContentToScrollTo) {
 98654:     mContentToScrollTo->DeleteProperty(nsGkAtoms::scrolling);
 98654:   }
 28165:   mContentToScrollTo = aContent;
 98654:   ScrollIntoViewData* data = new ScrollIntoViewData();
 98654:   data->mContentScrollVAxis = aVertical;
 98654:   data->mContentScrollHAxis = aHorizontal;
 98654:   data->mContentToScrollToFlags = aFlags;
 98654:   if (NS_FAILED(mContentToScrollTo->SetProperty(nsGkAtoms::scrolling, data,
 98654:                                                 ::DeleteScrollIntoViewData))) {
 98654:     mContentToScrollTo = nsnull;
 98654:   }
 28165: 
 28165:   // Flush layout and attempt to scroll in the process.
 84597:   currentDoc->SetNeedLayoutFlush();
 28165:   currentDoc->FlushPendingNotifications(Flush_InterruptibleLayout);
 28165: 
 28165:   // If mContentToScrollTo is non-null, that means we interrupted the reflow
 28165:   // (or suppressed it altogether because we're suppressing interruptible
 28165:   // flushes right now) and won't necessarily get the position correct, but do
 28165:   // a best-effort scroll here.  The other option would be to do this inside
 28165:   // FlushPendingNotifications, but I'm not sure the repeated scrolling that
 28165:   // could trigger if reflows keep getting interrupted would be more desirable
 28165:   // than a single best-effort scroll followed by one final scroll on the first
 28165:   // completed reflow.
 28165:   if (mContentToScrollTo) {
 98654:     DoScrollContentIntoView();
 28165:   }
 28165:   return NS_OK;
 28165: }
 28165: 
 28165: void
 98654: PresShell::DoScrollContentIntoView()
 27993: {
 42357:   NS_ASSERTION(mDidInitialReflow, "should have done initial reflow by now");
 42357: 
 98654:   nsIFrame* frame = mContentToScrollTo->GetPrimaryFrame();
 27993:   if (!frame) {
 98654:     mContentToScrollTo->DeleteProperty(nsGkAtoms::scrolling);
 27993:     mContentToScrollTo = nsnull;
 28165:     return;
 27993:   }
 27993: 
 28358:   if (frame->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
 28358:     // The reflow flush before this scroll got interrupted, and this frame's
 28358:     // coords and size are all zero, and it has no content showing anyway.
 28358:     // Don't bother scrolling to it.  We'll try again when we finish up layout.
 28358:     return;
 28358:   }
 28358: 
 37074:   nsIFrame* container =
 37074:     nsLayoutUtils::GetClosestFrameOfType(frame, nsGkAtoms::scrollFrame);
 37074:   if (!container) {
 37074:     // nothing can be scrolled
 37074:     return;
 37074:   }
 37074: 
 98654:   ScrollIntoViewData* data = static_cast<ScrollIntoViewData*>(
 98654:     mContentToScrollTo->GetProperty(nsGkAtoms::scrolling));
 98654:   if (NS_UNLIKELY(!data)) {
 98654:     mContentToScrollTo = nsnull;
 98654:     return;
 98654:   }
 98654: 
     1:   // This is a two-step process.
     1:   // Step 1: Find the bounds of the rect we want to scroll into view.  For
     1:   //         example, for an inline frame we may want to scroll in the whole
 37074:   //         line, or we may want to scroll multiple lines into view.
 37074:   // Step 2: Walk container frame and its ancestors and scroll them
     1:   //         appropriately.
 37074:   // frameBounds is relative to container. We're assuming
 37074:   // that scrollframes don't split so every continuation of frame will
 37074:   // be a descendant of container. (Things would still mostly work
 37074:   // even if that assumption was false.)
  3508:   nsRect frameBounds;
 79445:   bool haveRect = false;
 98654:   bool useWholeLineHeightForInlines =
 98654:     data->mContentScrollVAxis.mWhenToScroll != nsIPresShell::SCROLL_IF_NOT_FULLY_VISIBLE;
 77978:   // Reuse the same line iterator across calls to AccumulateFrameBounds.  We set
 77978:   // it every time we detect a new block (stored in prevBlock).
 77978:   nsIFrame* prevBlock = nsnull;
 77978:   nsAutoLineIterator lines;
 77978:   // The last line we found a continuation on in |lines|.  We assume that later
 77978:   // continuations cannot come on earlier lines.
 77978:   PRInt32 curLine = 0;
  3508:   do {
 37074:     AccumulateFrameBounds(container, frame, useWholeLineHeightForInlines,
 77978:                           frameBounds, haveRect, prevBlock, lines, curLine);
  3508:   } while ((frame = frame->GetNextContinuation()));
     1: 
 98654:   ScrollFrameRectIntoView(container, frameBounds, data->mContentScrollVAxis,
 98654:                           data->mContentScrollHAxis,
 98654:                           data->mContentToScrollToFlags);
 37077: }
 37077: 
 79445: bool
 37077: PresShell::ScrollFrameRectIntoView(nsIFrame*                aFrame,
 37077:                                    const nsRect&            aRect,
 93554:                                    nsIPresShell::ScrollAxis aVertical,
 93554:                                    nsIPresShell::ScrollAxis aHorizontal,
 37077:                                    PRUint32                 aFlags)
 37077: {
 79445:   bool didScroll = false;
 37077:   // This function needs to work even if rect has a width or height of 0.
 37077:   nsRect rect = aRect;
 37077:   nsIFrame* container = aFrame;
 37077:   // Walk up the frame hierarchy scrolling the rect into view and
 37077:   // keeping rect relative to container
 37077:   do {
 37074:     nsIScrollableFrame* sf = do_QueryFrame(container);
 37074:     if (sf) {
 37074:       nsPoint oldPosition = sf->GetScrollPosition();
 37077:       ScrollToShowRect(sf, rect - sf->GetScrolledFrame()->GetPosition(),
 93554:                        aVertical, aHorizontal, aFlags);
 37074:       nsPoint newPosition = sf->GetScrollPosition();
 41181:       // If the scroll position increased, that means our content moved up,
 41181:       // so our rect's offset should decrease
 41181:       rect += oldPosition - newPosition;
 37077: 
 37077:       if (oldPosition != newPosition) {
 80486:         didScroll = true;
 37077:       }
 37077: 
 38842:       // only scroll one container when this flag is set
 56442:       if (aFlags & nsIPresShell::SCROLL_FIRST_ANCESTOR_ONLY) {
 38842:         break;
 38842:       }
 37077:     }
 37077:     rect += container->GetPosition();
102668:     nsIFrame* parent = container->GetParent();
 62343:     if (!parent && !(aFlags & nsIPresShell::SCROLL_NO_PARENT_FRAMES)) {
 41180:       nsPoint extraOffset(0,0);
 47902:       parent = nsLayoutUtils::GetCrossDocParentFrame(container, &extraOffset);
 47902:       if (parent) {
 47902:         PRInt32 APD = container->PresContext()->AppUnitsPerDevPixel();        
 47902:         PRInt32 parentAPD = parent->PresContext()->AppUnitsPerDevPixel();
 47902:         rect = rect.ConvertAppUnitsRoundOut(APD, parentAPD);
 41180:         rect += extraOffset;
 47902:       }
 47902:     }
 47902:     container = parent;
 38842:   } while (container);
 37077: 
 37077:   return didScroll;
     1: }
     1: 
 37073: nsRectVisibility
 37073: PresShell::GetRectVisibility(nsIFrame* aFrame,
 37073:                              const nsRect &aRect,
 40053:                              nscoord aMinTwips) const
 37073: {
 47902:   NS_ASSERTION(aFrame->PresContext() == GetPresContext(),
 47902:                "prescontext mismatch?");
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
 37073:   NS_ASSERTION(rootFrame,
 37073:                "How can someone have a frame for this presshell when there's no root?");
 37073:   nsIScrollableFrame* sf = GetRootScrollFrameAsScrollable();
 37073:   nsRect scrollPortRect;
 37073:   if (sf) {
 37073:     scrollPortRect = sf->GetScrollPortRect();
 37073:     nsIFrame* f = do_QueryFrame(sf);
 37073:     scrollPortRect += f->GetOffsetTo(rootFrame);
 37073:   } else {
 37073:     scrollPortRect = nsRect(nsPoint(0,0), rootFrame->GetSize());
 37073:   }
 37073: 
 37073:   nsRect r = aRect + aFrame->GetOffsetTo(rootFrame);
 37073:   // If aRect is entirely visible then we don't need to ensure that
 37073:   // at least aMinTwips of it is visible
 37073:   if (scrollPortRect.Contains(r))
 37073:     return nsRectVisibility_kVisible;
 37073: 
 37073:   nsRect insetRect = scrollPortRect;
 37073:   insetRect.Deflate(aMinTwips, aMinTwips);
 37073:   if (r.YMost() <= insetRect.y)
 37073:     return nsRectVisibility_kAboveViewport;
 37073:   if (r.y >= insetRect.YMost())
 37073:     return nsRectVisibility_kBelowViewport;
 37073:   if (r.XMost() <= insetRect.x)
 37073:     return nsRectVisibility_kLeftOfViewport;
 37073:   if (r.x >= insetRect.XMost())
 37073:     return nsRectVisibility_kRightOfViewport;
 37073: 
 37073:   return nsRectVisibility_kVisible;
 37073: }
 37073: 
 82568: void
103528: PresShell::ScheduleViewManagerFlush()
 87344: {
 87344:   nsPresContext* presContext = GetPresContext();
 87344:   if (presContext) {
 87344:     presContext->RefreshDriver()->ScheduleViewManagerFlush();
 87344:   }
 87349:   if (mDocument) {
 87349:     mDocument->SetNeedLayoutFlush();
 87349:   }
 87344: }
 87344: 
 87344: void
 22471: PresShell::DispatchSynthMouseMove(nsGUIEvent *aEvent,
 79445:                                   bool aFlushOnHoverChange)
 22471: {
 22471:   PRUint32 hoverGenerationBefore = mFrameConstructor->GetHoverGeneration();
 22471:   nsEventStatus status;
 47898:   nsIView* targetView = nsIView::GetViewFor(aEvent->widget);
 47898:   targetView->GetViewManager()->DispatchEvent(aEvent, targetView, &status);
 22471:   if (aFlushOnHoverChange &&
 22471:       hoverGenerationBefore != mFrameConstructor->GetHoverGeneration()) {
 22471:     // Flush so that the resulting reflow happens now so that our caller
 22471:     // can suppress any synthesized mouse moves caused by that reflow.
 22471:     FlushPendingNotifications(Flush_Layout);
 22471:   }
 22471: }
 22471: 
 82568: void
 82568: PresShell::ClearMouseCaptureOnView(nsIView* aView)
 32435: {
 81274:   if (gCaptureInfo.mContent) {
 81274:     if (aView) {
 81274:       // if a view was specified, ensure that the captured content is within
 81274:       // this view.
 81274:       nsIFrame* frame = gCaptureInfo.mContent->GetPrimaryFrame();
 81274:       if (frame) {
 81274:         nsIView* view = frame->GetClosestView();
 81274:         // if there is no view, capturing won't be handled any more, so
 81274:         // just release the capture.
 81274:         if (view) {
 81274:           do {
 81274:             if (view == aView) {
 81274:               NS_RELEASE(gCaptureInfo.mContent);
 81274:               // the view containing the captured content likely disappeared so
 81274:               // disable capture for now.
 81274:               gCaptureInfo.mAllowed = false;
 81274:               break;
 81274:             }
 81274: 
 81274:             view = view->GetParent();
 81274:           } while (view);
 81274:           // return if the view wasn't found
 80851:           return;
 80851:         }
 81274:       }
 81274:     }
 81274: 
 81274:     NS_RELEASE(gCaptureInfo.mContent);
 81274:   }
 81274: 
 81274:   // disable mouse capture until the next mousedown as a dialog has opened
 81274:   // or a drag has started. Otherwise, someone could start capture during
 81274:   // the modal dialog or drag.
 81274:   gCaptureInfo.mAllowed = false;
 80851: }
 80851: 
 80851: void
 80851: nsIPresShell::ClearMouseCapture(nsIFrame* aFrame)
 80851: {
 80851:   if (!gCaptureInfo.mContent) {
 80851:     gCaptureInfo.mAllowed = false;
 80851:     return;
 80851:   }
 80851: 
 80851:   // null frame argument means clear the capture
 80851:   if (!aFrame) {
 32435:     NS_RELEASE(gCaptureInfo.mContent);
 80486:     gCaptureInfo.mAllowed = false;
 32435:     return;
 32435:   }
 80851: 
 80851:   nsIFrame* capturingFrame = gCaptureInfo.mContent->GetPrimaryFrame();
 80851:   if (!capturingFrame) {
 32435:     NS_RELEASE(gCaptureInfo.mContent);
 80486:     gCaptureInfo.mAllowed = false;
 80851:     return;
 80851:   }
 80851: 
 80851:   if (nsLayoutUtils::IsAncestorFrameCrossDoc(aFrame, capturingFrame)) {
 80851:     NS_RELEASE(gCaptureInfo.mContent);
 80851:     gCaptureInfo.mAllowed = false;
 80851:   }
 32435: }
 32435: 
 40046: nsresult
 79445: PresShell::CaptureHistoryState(nsILayoutHistoryState** aState, bool aLeavingPage)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   NS_PRECONDITION(nsnull != aState, "null state pointer");
     1: 
     1:   // We actually have to mess with the docshell here, since we want to
     1:   // store the state back in it.
     1:   // XXXbz this isn't really right, since this is being called in the
     1:   // content viewer's Hide() method...  by that point the docshell's
     1:   // state could be wrong.  We should sort out a better ownership
     1:   // model for the layout history state.
     1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
     1:   if (!container)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
     1:   if (!docShell)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsILayoutHistoryState> historyState;
     1:   docShell->GetLayoutHistoryState(getter_AddRefs(historyState));
     1:   if (!historyState) {
     1:     // Create the document state object
     1:     rv = NS_NewLayoutHistoryState(getter_AddRefs(historyState));
     1:   
     1:     if (NS_FAILED(rv)) { 
     1:       *aState = nsnull;
     1:       return rv;
     1:     }    
     1: 
     1:     docShell->SetLayoutHistoryState(historyState);
     1:   }
     1: 
     1:   *aState = historyState;
     1:   NS_IF_ADDREF(*aState);
     1:   
     1:   // Capture frame state for the entire frame hierarchy
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
     1:   if (!rootFrame) return NS_OK;
     1:   // Capture frame state for the root scroll frame
     1:   // Don't capture state when first creating doc element hierarchy
 30710:   // As the scroll position is 0 and this will cause us to lose
     1:   // our previously saved place!
     1:   if (aLeavingPage) {
     1:     nsIFrame* scrollFrame = GetRootScrollFrame();
     1:     if (scrollFrame) {
 89328:       mFrameConstructor->CaptureFrameStateFor(scrollFrame, historyState,
     1:                                               nsIStatefulFrame::eDocumentScrollState);
     1:     }
     1:   }
     1: 
 89328:   mFrameConstructor->CaptureFrameState(rootFrame, historyState);  
     1:  
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: PresShell::UnsuppressAndInvalidate()
     1: {
 52218:   // Note: We ignore the EnsureVisible check for resource documents, because
 52218:   // they won't have a docshell, so they'll always fail EnsureVisible.
 52218:   if ((!mDocument->IsResourceDoc() && !mPresContext->EnsureVisible()) ||
 52218:       mHaveShutDown) {
     1:     // No point; we're about to be torn down anyway.
     1:     return;
     1:   }
     1: 
101068:   if (!mDocument->IsResourceDoc()) {
101068:     // Notify observers that a new page is about to be drawn. Execute this
101068:     // as soon as it is safe to run JS, which is guaranteed to be before we
101068:     // go back to the event loop and actually draw the page.
101068:     nsContentUtils::AddScriptRunner(new nsBeforeFirstPaintDispatcher(mDocument));
101068:   }
101068: 
 80486:   mPaintingSuppressed = false;
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
     1:   if (rootFrame) {
     1:     // let's assume that outline on a root frame is not supported
103530:     nsRect rect(nsPoint(0, 0), rootFrame->GetSize());
103530:     rootFrame->Invalidate(rect);
     1: 
 33905:     if (mCaretEnabled && mCaret) {
 33905:       mCaret->CheckCaretDrawingState();
 33905:     }
 33905: 
 37502:     nsRootPresContext* rootPC = mPresContext->GetRootPresContext();
 37502:     if (rootPC) {
 47756:       rootPC->RequestUpdatePluginGeometry(rootFrame);
 37502:     }
 32992:   }
 30522: 
 29018:   // now that painting is unsuppressed, focus may be set on the document
 29018:   nsPIDOMWindow *win = mDocument->GetWindow();
 29018:   if (win)
 29018:     win->SetReadyForFocus();
     1: 
 52492:   if (!mHaveShutDown)
 80486:     SynthesizeMouseMove(false);
     1: }
     1: 
 40049: void
     1: PresShell::UnsuppressPainting()
     1: {
     1:   if (mPaintSuppressionTimer) {
     1:     mPaintSuppressionTimer->Cancel();
     1:     mPaintSuppressionTimer = nsnull;
     1:   }
     1: 
     1:   if (mIsDocumentGone || !mPaintingSuppressed)
 40049:     return;
     1: 
     1:   // If we have reflows pending, just wait until we process
     1:   // the reflows and get all the frames where we want them
     1:   // before actually unlocking the painting.  Otherwise
     1:   // go ahead and unlock now.
 84596:   if (!mDirtyRoots.IsEmpty())
 80486:     mShouldUnsuppressPainting = true;
     1:   else
     1:     UnsuppressAndInvalidate();
 40020: }
 40020: 
     1: // Post a request to handle an arbitrary callback after reflow has finished.
 40046: nsresult
     1: PresShell::PostReflowCallback(nsIReflowCallback* aCallback)
     1: {
 31620:   void* result = AllocateMisc(sizeof(nsCallbackEventRequest));
     1:   if (NS_UNLIKELY(!result)) {
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1:   nsCallbackEventRequest* request = (nsCallbackEventRequest*)result;
     1: 
     1:   request->callback = aCallback;
     1:   request->next = nsnull;
     1: 
     1:   if (mLastCallbackEventRequest) {
     1:     mLastCallbackEventRequest = mLastCallbackEventRequest->next = request;
     1:   } else {
     1:     mFirstCallbackEventRequest = request;
     1:     mLastCallbackEventRequest = request;
     1:   }
     1:  
     1:   return NS_OK;
     1: }
     1: 
 40046: void
     1: PresShell::CancelReflowCallback(nsIReflowCallback* aCallback)
     1: {
     1:    nsCallbackEventRequest* before = nsnull;
     1:    nsCallbackEventRequest* node = mFirstCallbackEventRequest;
     1:    while(node)
     1:    {
     1:       nsIReflowCallback* callback = node->callback;
     1: 
     1:       if (callback == aCallback) 
     1:       {
     1:         nsCallbackEventRequest* toFree = node;
     1:         if (node == mFirstCallbackEventRequest) {
     1:           node = node->next;
     1:           mFirstCallbackEventRequest = node;
     1:           NS_ASSERTION(before == nsnull, "impossible");
     1:         } else {
     1:           node = node->next;
     1:           before->next = node;
     1:         }
     1: 
     1:         if (toFree == mLastCallbackEventRequest) {
     1:           mLastCallbackEventRequest = before;
     1:         }
     1: 
 31620:         FreeMisc(sizeof(nsCallbackEventRequest), toFree);
     1:       } else {
     1:         before = node;
     1:         node = node->next;
     1:       }
     1:    }
     1: }
     1: 
     1: void
  8509: PresShell::CancelPostedReflowCallbacks()
  8509: {
  8509:   while (mFirstCallbackEventRequest) {
  8509:     nsCallbackEventRequest* node = mFirstCallbackEventRequest;
  8509:     mFirstCallbackEventRequest = node->next;
  8509:     if (!mFirstCallbackEventRequest) {
  8509:       mLastCallbackEventRequest = nsnull;
  8509:     }
  8509:     nsIReflowCallback* callback = node->callback;
 31620:     FreeMisc(sizeof(nsCallbackEventRequest), node);
  8509:     if (callback) {
  8509:       callback->ReflowCallbackCanceled();
  8509:     }
  8509:   }
  8509: }
  8509: 
  8509: void
 79445: PresShell::HandlePostedReflowCallbacks(bool aInterruptible)
 79445: {
 79445:    bool shouldFlush = false;
     1: 
     1:    while (mFirstCallbackEventRequest) {
     1:      nsCallbackEventRequest* node = mFirstCallbackEventRequest;
     1:      mFirstCallbackEventRequest = node->next;
     1:      if (!mFirstCallbackEventRequest) {
     1:        mLastCallbackEventRequest = nsnull;
     1:      }
     1:      nsIReflowCallback* callback = node->callback;
 31620:      FreeMisc(sizeof(nsCallbackEventRequest), node);
     1:      if (callback) {
     1:        if (callback->ReflowFinished()) {
 80486:          shouldFlush = true;
     1:        }
     1:      }
     1:    }
     1: 
 27993:    mozFlushType flushType =
 27993:      aInterruptible ? Flush_InterruptibleLayout : Flush_Layout;
     1:    if (shouldFlush)
 27993:      FlushPendingNotifications(flushType);
     1: }
     1: 
 79445: bool
 40044: PresShell::IsSafeToFlush() const
     1: {
     1:   // Not safe if we are reflowing or in the middle of frame construction
 79445:   bool isSafeToFlush = !mIsReflowing &&
 29804:                          !mChangeNestCount;
 29804: 
 39668:   if (isSafeToFlush) {
     1:     // Not safe if we are painting
     1:     nsIViewManager* viewManager = GetViewManager();
     1:     if (viewManager) {
 79445:       bool isPainting = false;
     1:       viewManager->IsPainting(isPainting);
     1:       if (isPainting) {
 80486:         isSafeToFlush = false;
 39668:       }
 39668:     }
 39668:   }
 39668: 
 39668:   return isSafeToFlush;
 39668: }
 39668: 
 39668: 
 39668: void
     1: PresShell::FlushPendingNotifications(mozFlushType aType)
     1: {
 84597:   /**
 84597:    * VERY IMPORTANT: If you add some sort of new flushing to this
 84597:    * method, make sure to add the relevant SetNeedLayoutFlush or
 84597:    * SetNeedStyleFlush calls on the document.
 84597:    */
 84597: 
 42480: #ifdef NS_FUNCTION_TIMER
 42480:   NS_TIME_FUNCTION_DECLARE_DOCURL;
 42480:   static const char *flushTypeNames[] = {
 42480:     "Flush_Content",
 42480:     "Flush_ContentAndNotify",
 42480:     "Flush_Styles",
 42480:     "Flush_InterruptibleLayout",
 42480:     "Flush_Layout",
 42480:     "Flush_Display"
 42480:   };
 42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (document: %s, type: %s)", MOZ_FUNCTION_NAME,
 42480:                            __LINE__, docURL__.get(), flushTypeNames[aType - 1]);
 42480: #endif
 84290:   SAMPLE_LABEL("layout", "FlushPendingNotifications");
 42480: 
 79853: #ifdef ACCESSIBILITY
 79853: #ifdef DEBUG
 79853:   nsAccessibilityService* accService = GetAccService();
 79853:   if (accService) {
 79853:     NS_ASSERTION(!accService->IsProcessingRefreshDriverNotification(),
 79853:                  "Flush during accessible tree update!");
 79853:   }
 79853: #endif
 79853: #endif
 79853: 
  4886:   NS_ASSERTION(aType >= Flush_Frames, "Why did we get called?");
     1: 
 79445:   bool isSafeToFlush = IsSafeToFlush();
 52202: 
 52202:   // If layout could possibly trigger scripts, then it's only safe to flush if
 52202:   // it's safe to run script.
 79445:   bool hasHadScriptObject;
 62731:   if (mDocument->GetScriptHandlingObject(hasHadScriptObject) ||
 62731:       hasHadScriptObject) {
 29804:     isSafeToFlush = isSafeToFlush && nsContentUtils::IsSafeToRunScript();
 52202:   }
     1: 
     1:   NS_ASSERTION(!isSafeToFlush || mViewManager, "Must have view manager");
 87348:   // Make sure the view manager stays alive.
 10730:   nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
 10730:   if (isSafeToFlush && mViewManager) {
   721:     // Processing pending notifications can kill us, and some callers only
   721:     // hold weak refs when calling FlushPendingNotifications().  :(
   721:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
   721: 
 23685:     if (mResizeEvent.IsPending()) {
 23685:       FireResizeEvent();
 23685:       if (mIsDestroying) {
 39668:         return;
 23685:       }
 23685:     }
 23685: 
 40701:     // We need to make sure external resource documents are flushed too (for
 40701:     // example, svg filters that reference a filter in an external document
 40701:     // need the frames in the external document to be constructed for the
 40701:     // filter to work). We only need external resources to be flushed when the
 40701:     // main document is flushing >= Flush_Frames, so we flush external
 40701:     // resources here instead of nsDocument::FlushPendingNotifications.
 40701:     mDocument->FlushExternalResources(aType);
 40701: 
  5623:     // Force flushing of any pending content notifications that might have
  5623:     // queued up while our event was pending.  That will ensure that we don't
  5623:     // construct frames for content right now that's still waiting to be
  5623:     // notified on,
  5623:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
  6023: 
  6023:     // Process pending restyles, since any flush of the presshell wants
  6023:     // up-to-date style data.
  5623:     if (!mIsDestroying) {
 80486:       mViewManager->FlushDelayedResize(false);
 16226:       mPresContext->FlushPendingMediaFeatureValuesChanged();
 16226: 
 22507:       // Flush any pending update of the user font set, since that could
 22507:       // cause style changes (for updating ex/ch units, and to cause a
 22507:       // reflow).
 22507:       mPresContext->FlushUserFontSet();
 22507: 
 38870:       // Flush any requested SMIL samples.
 38870:       if (mDocument->HasAnimationController()) {
 38870:         mDocument->GetAnimationController()->FlushResampleRequests();
 38870:       }
 38870: 
 93602:       // The FlushResampleRequests() above flushed style changes.
 93602:       if (!mIsDestroying) {
 23256:         nsAutoScriptBlocker scriptBlocker;
 40938:         mFrameConstructor->CreateNeededFrames();
     1:         mFrameConstructor->ProcessPendingRestyles();
  5623:       }
 93602:     }
  4886: 
 67988:     // Dispatch any 'animationstart' events those (or earlier) restyles
 67988:     // queued up.
 67988:     if (!mIsDestroying) {
 67988:       mPresContext->AnimationManager()->DispatchEvents();
 67988:     }
 67988: 
  6023:     // Process whatever XBL constructors those restyles queued up.  This
  6023:     // ensures that onload doesn't fire too early and that we won't do extra
  6023:     // reflows after those constructors run.
  5872:     if (!mIsDestroying) {
  5872:       mDocument->BindingManager()->ProcessAttachedQueue();
  5872:     }
  5872: 
 67988:     // Now those constructors or events might have posted restyle
 67988:     // events.  At the same time, we still need up-to-date style data.
 67988:     // In particular, reflow depends on style being completely up to
 67988:     // date.  If it's not, then style context reparenting, which can
 67988:     // happen during reflow, might suddenly pick up the new rules and
 67988:     // we'll end up with frames whose style doesn't match the frame
 67988:     // type.
  6023:     if (!mIsDestroying) {
 23256:       nsAutoScriptBlocker scriptBlocker;
 40938:       mFrameConstructor->CreateNeededFrames();
  6023:       mFrameConstructor->ProcessPendingRestyles();
  6023:     }
  6023: 
 21925: 
  6023:     // There might be more pending constructors now, but we're not going to
  6023:     // worry about them.  They can't be triggered during reflow, so we should
  6023:     // be good.
  6023: 
 27993:     if (aType >= (mSuppressInterruptibleReflows ? Flush_Layout : Flush_InterruptibleLayout) &&
 27993:         !mIsDestroying) {
   550:       mFrameConstructor->RecalcQuotesAndCounters();
 80486:       mViewManager->FlushDelayedResize(true);
 27993:       if (ProcessReflowCommands(aType < Flush_Layout) && mContentToScrollTo) {
 27993:         // We didn't get interrupted.  Go ahead and scroll to our content
 98654:         DoScrollContentIntoView();
 98654:         if (mContentToScrollTo) {
 98654:           mContentToScrollTo->DeleteProperty(nsGkAtoms::scrolling);
 27993:           mContentToScrollTo = nsnull;
 27993:         }
 98654:       }
 84597:     } else if (!mIsDestroying && mSuppressInterruptibleReflows &&
 84597:                aType == Flush_InterruptibleLayout) {
 84597:       // We suppressed this flush, but the document thinks it doesn't
 84597:       // need to flush anymore.  Let it know what's really going on.
 84597:       mDocument->SetNeedLayoutFlush();
     1:     }
     1: 
 47756:     if (aType >= Flush_Layout) {
 47756:       // Flush plugin geometry. Don't flush plugin geometry for
 47756:       // interruptible layouts, since WillPaint does an interruptible
 47756:       // layout.
 47756:       nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
 47756:       if (rootPresContext) {
 47756:         rootPresContext->UpdatePluginGeometry();
 47756:       }
 87349: 
 87349:       if (!mIsDestroying) {
 87349:         mViewManager->UpdateWidgetGeometry();
 87349:       }
 47756:     }
     1:   }
     1: }
     1: 
     1: void
     1: PresShell::CharacterDataChanged(nsIDocument *aDocument,
     1:                                 nsIContent*  aContent,
     1:                                 CharacterDataChangeInfo* aInfo)
     1: {
     1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected CharacterDataChanged");
     1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
     1: 
 29804:   nsAutoCauseReflowNotifier crNotifier(this);
 13098: 
     1:   if (mCaret) {
     1:     // Invalidate the caret's current location before we call into the frame
     1:     // constructor. It is important to do this now, and not wait until the
     1:     // resulting reflow, because this call causes continuation frames of the
     1:     // text frame the caret is in to forget what part of the content they
     1:     // refer to, making it hard for them to return the correct continuation
     1:     // frame to the caret.
     1:     mCaret->InvalidateOutsideCaret();
     1:   }
 11845: 
 11845:   // Call this here so it only happens for real content mutations and
 11845:   // not cases when the frame constructor calls its own methods to force
 11845:   // frame reconstruction.
 11845:   nsIContent *container = aContent->GetParent();
 11845:   PRUint32 selectorFlags =
 11845:     container ? (container->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
 16128:   if (selectorFlags != 0 && !aContent->IsRootOfAnonymousSubtree()) {
 42324:     Element* element = container->AsElement();
 42324:     if (aInfo->mAppend && !aContent->GetNextSibling())
 42324:       mFrameConstructor->RestyleForAppend(element, aContent);
 11845:     else
 42324:       mFrameConstructor->RestyleForInsertOrChange(element, aContent);
 11845:   }
 11845: 
 31131:   mFrameConstructor->CharacterDataChanged(aContent, aInfo);
     1:   VERIFY_STYLE_TREE;
     1: }
     1: 
     1: void
 64120: PresShell::ContentStateChanged(nsIDocument* aDocument,
 64120:                                nsIContent* aContent,
 56168:                                nsEventStates aStateMask)
     1: {
 64120:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentStateChanged");
     1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
     1: 
  3410:   if (mDidInitialReflow) {
 29804:     nsAutoCauseReflowNotifier crNotifier(this);
 64120:     mFrameConstructor->ContentStateChanged(aContent, aStateMask);
     1:     VERIFY_STYLE_TREE;
     1:   }
  3410: }
     1: 
 35534: void
 39698: PresShell::DocumentStatesChanged(nsIDocument* aDocument,
 56168:                                  nsEventStates aStateMask)
 39698: {
 39698:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected DocumentStatesChanged");
 39698:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
 39698: 
 39698:   if (mDidInitialReflow &&
 39698:       mStyleSet->HasDocumentStateDependentStyle(mPresContext,
 41634:                                                 mDocument->GetRootElement(),
 39698:                                                 aStateMask)) {
 41634:     mFrameConstructor->PostRestyleEvent(mDocument->GetRootElement(),
 43793:                                         eRestyle_Subtree, NS_STYLE_HINT_NONE);
 39698:     VERIFY_STYLE_TREE;
 39698:   }
 47737: 
103530:   if (aStateMask.HasState(NS_DOCUMENT_STATE_WINDOW_INACTIVE)) {
103530:     nsIFrame* root = mFrameConstructor->GetRootFrame();
103530:     if (root) {
103530:       root->InvalidateFrameSubtree();
103530:     }
103530:   }
 39698: }
 39698: 
 39698: void
 35534: PresShell::AttributeWillChange(nsIDocument* aDocument,
 51352:                                Element*     aElement,
 35534:                                PRInt32      aNameSpaceID,
 35534:                                nsIAtom*     aAttribute,
 35534:                                PRInt32      aModType)
 35534: {
 51352:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected AttributeWillChange");
 35534:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
 35534: 
 35534:   // XXXwaterson it might be more elegant to wait until after the
 35534:   // initial reflow to begin observing the document. That would
 35534:   // squelch any other inappropriate notifications as well.
 35534:   if (mDidInitialReflow) {
 35534:     nsAutoCauseReflowNotifier crNotifier(this);
 51352:     mFrameConstructor->AttributeWillChange(aElement, aNameSpaceID,
 35534:                                            aAttribute, aModType);
 35534:     VERIFY_STYLE_TREE;
 35534:   }
 35534: }
     1: 
     1: void
     1: PresShell::AttributeChanged(nsIDocument* aDocument,
 51350:                             Element*     aElement,
     1:                             PRInt32      aNameSpaceID,
     1:                             nsIAtom*     aAttribute,
 35535:                             PRInt32      aModType)
     1: {
     1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected AttributeChanged");
     1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
     1: 
     1:   // XXXwaterson it might be more elegant to wait until after the
     1:   // initial reflow to begin observing the document. That would
     1:   // squelch any other inappropriate notifications as well.
     1:   if (mDidInitialReflow) {
 29804:     nsAutoCauseReflowNotifier crNotifier(this);
 51350:     mFrameConstructor->AttributeChanged(aElement, aNameSpaceID,
 35535:                                         aAttribute, aModType);
     1:     VERIFY_STYLE_TREE;
     1:   }
     1: }
     1: 
     1: void
     1: PresShell::ContentAppended(nsIDocument *aDocument,
     1:                            nsIContent* aContainer,
 42107:                            nsIContent* aFirstNewContent,
     1:                            PRInt32     aNewIndexInContainer)
     1: {
     1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentAppended");
     1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
 11845:   NS_PRECONDITION(aContainer, "must have container");
     1:   
     1:   if (!mDidInitialReflow) {
     1:     return;
     1:   }
     1:   
 29804:   nsAutoCauseReflowNotifier crNotifier(this);
     1: 
 11845:   // Call this here so it only happens for real content mutations and
 11845:   // not cases when the frame constructor calls its own methods to force
 11845:   // frame reconstruction.
 42324:   mFrameConstructor->RestyleForAppend(aContainer->AsElement(), aFirstNewContent);
 11845: 
 80486:   mFrameConstructor->ContentAppended(aContainer, aFirstNewContent, true);
     1:   VERIFY_STYLE_TREE;
     1: }
     1: 
     1: void
     1: PresShell::ContentInserted(nsIDocument* aDocument,
     1:                            nsIContent*  aContainer,
     1:                            nsIContent*  aChild,
     1:                            PRInt32      aIndexInContainer)
     1: {
     1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentInserted");
     1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
     1: 
     1:   if (!mDidInitialReflow) {
     1:     return;
     1:   }
     1:   
 29804:   nsAutoCauseReflowNotifier crNotifier(this);
 11845: 
 11845:   // Call this here so it only happens for real content mutations and
 11845:   // not cases when the frame constructor calls its own methods to force
 11845:   // frame reconstruction.
 11845:   if (aContainer)
 42324:     mFrameConstructor->RestyleForInsertOrChange(aContainer->AsElement(), aChild);
 11845: 
 80486:   mFrameConstructor->ContentInserted(aContainer, aChild, nsnull, true);
     1:   VERIFY_STYLE_TREE;
     1: }
     1: 
     1: void
     1: PresShell::ContentRemoved(nsIDocument *aDocument,
     1:                           nsIContent* aContainer,
     1:                           nsIContent* aChild,
 48038:                           PRInt32     aIndexInContainer,
 48038:                           nsIContent* aPreviousSibling)
     1: {
     1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentRemoved");
     1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
     1: 
     1:   // Make sure that the caret doesn't leave a turd where the child used to be.
     1:   if (mCaret) {
     1:     mCaret->InvalidateOutsideCaret();
     1:   }
     1: 
     1:   // Notify the ESM that the content has been removed, so that
     1:   // it can clean up any state related to the content.
 29018:   mPresContext->EventStateManager()->ContentRemoved(aDocument, aChild);
     1: 
 29804:   nsAutoCauseReflowNotifier crNotifier(this);
 11845: 
 11845:   // Call this here so it only happens for real content mutations and
 11845:   // not cases when the frame constructor calls its own methods to force
 11845:   // frame reconstruction.
 47669:   nsIContent* oldNextSibling;
 47669:   if (aContainer) {
 47669:     oldNextSibling = aContainer->GetChildAt(aIndexInContainer);
 47669:   } else {
 47669:     oldNextSibling = nsnull;
 47669:   }
 47669:   
102818:   if (aContainer && aContainer->IsElement()) {
 42324:     mFrameConstructor->RestyleForRemove(aContainer->AsElement(), aChild,
 47669:                                         oldNextSibling);
102818:   }
 11845: 
 79445:   bool didReconstruct;
 47669:   mFrameConstructor->ContentRemoved(aContainer, aChild, oldNextSibling,
 29501:                                     nsCSSFrameConstructor::REMOVE_CONTENT,
 29501:                                     &didReconstruct);
     1: 
     1:   VERIFY_STYLE_TREE;
     1: }
     1: 
     1: nsresult
     1: PresShell::ReconstructFrames(void)
     1: {
 89328:   NS_PRECONDITION(!mFrameConstructor->GetRootFrame() || mDidInitialReflow,
 61541:                   "Must not have root frame before initial reflow");
 61541:   if (!mDidInitialReflow) {
 61541:     // Nothing to do here
 61541:     return NS_OK;
 61541:   }
 61541: 
 36817:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 36817: 
 36817:   // Have to make sure that the content notifications are flushed before we
 36817:   // start messing with the frame model; otherwise we can get content doubling.
 36817:   mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 36817: 
 29804:   nsAutoCauseReflowNotifier crNotifier(this);
 15817:   mFrameConstructor->BeginUpdate();
 13098:   nsresult rv = mFrameConstructor->ReconstructDocElementHierarchy();
     1:   VERIFY_STYLE_TREE;
 15817:   mFrameConstructor->EndUpdate();
     1: 
     1:   return rv;
     1: }
     1: 
     1: void
     1: nsIPresShell::ReconstructStyleDataInternal()
     1: {
 80486:   mStylesHaveChanged = false;
     1: 
 21925:   if (mIsDestroying) {
 21925:     // We don't want to mess with restyles at this point
 21925:     return;
 21925:   }
 21925: 
 21925:   if (mPresContext) {
 21925:     mPresContext->RebuildUserFontSet();
 67985:     mPresContext->AnimationManager()->KeyframesListIsDirty();
 21925:   }
 21925: 
 41634:   Element* root = mDocument->GetRootElement();
 21920:   if (!mDidInitialReflow) {
 21920:     // Nothing to do here, since we have no frames yet
 21920:     return;
 21920:   }
 21920: 
     1:   if (!root) {
     1:     // No content to restyle
     1:     return;
     1:   }
     1:   
 43793:   mFrameConstructor->PostRestyleEvent(root, eRestyle_Subtree, NS_STYLE_HINT_NONE);
     1: }
     1: 
     1: void
     1: nsIPresShell::ReconstructStyleDataExternal()
     1: {
     1:   ReconstructStyleDataInternal();
     1: }
     1: 
     1: void
     1: PresShell::StyleSheetAdded(nsIDocument *aDocument,
     1:                            nsIStyleSheet* aStyleSheet,
 79445:                            bool aDocumentSheet)
     1: {
     1:   // We only care when enabled sheets are added
     1:   NS_PRECONDITION(aStyleSheet, "Must have a style sheet!");
 42232: 
 42332:   if (aStyleSheet->IsApplicable() && aStyleSheet->HasRules()) {
 80486:     mStylesHaveChanged = true;
     1:   }
     1: }
     1: 
     1: void 
     1: PresShell::StyleSheetRemoved(nsIDocument *aDocument,
     1:                              nsIStyleSheet* aStyleSheet,
 79445:                              bool aDocumentSheet)
     1: {
     1:   // We only care when enabled sheets are removed
     1:   NS_PRECONDITION(aStyleSheet, "Must have a style sheet!");
 42232: 
 42332:   if (aStyleSheet->IsApplicable() && aStyleSheet->HasRules()) {
 80486:     mStylesHaveChanged = true;
     1:   }
     1: }
     1: 
     1: void
     1: PresShell::StyleSheetApplicableStateChanged(nsIDocument *aDocument,
     1:                                             nsIStyleSheet* aStyleSheet,
 79445:                                             bool aApplicable)
     1: {
     1:   if (aStyleSheet->HasRules()) {
 80486:     mStylesHaveChanged = true;
     1:   }
     1: }
     1: 
     1: void
     1: PresShell::StyleRuleChanged(nsIDocument *aDocument,
     1:                             nsIStyleSheet* aStyleSheet,
     1:                             nsIStyleRule* aOldStyleRule,
     1:                             nsIStyleRule* aNewStyleRule)
     1: {
 80486:   mStylesHaveChanged = true;
     1: }
     1: 
     1: void
     1: PresShell::StyleRuleAdded(nsIDocument *aDocument,
     1:                           nsIStyleSheet* aStyleSheet,
     1:                           nsIStyleRule* aStyleRule) 
     1: {
 80486:   mStylesHaveChanged = true;
     1: }
     1: 
     1: void
     1: PresShell::StyleRuleRemoved(nsIDocument *aDocument,
     1:                             nsIStyleSheet* aStyleSheet,
     1:                             nsIStyleRule* aStyleRule) 
     1: {
 80486:   mStylesHaveChanged = true;
     1: }
     1: 
     1: nsIFrame*
 10998: PresShell::GetRealPrimaryFrameFor(nsIContent* aContent) const
 10998: {
 36656:   if (aContent->GetDocument() != GetDocument()) {
 36656:     return nsnull;
 36656:   }
 36656:   nsIFrame *primaryFrame = aContent->GetPrimaryFrame();
 10998:   if (!primaryFrame)
 10998:     return nsnull;
 10998:   return nsPlaceholderFrame::GetRealFrameFor(primaryFrame);
 10998: }
 10998: 
 39668: nsIFrame*
 39668: PresShell::GetPlaceholderFrameFor(nsIFrame* aFrame) const
 39668: {
 89328:   return mFrameConstructor->GetPlaceholderFrameFor(aFrame);
     1: }
     1: 
 47739: nsresult
 47739: PresShell::RenderDocument(const nsRect& aRect, PRUint32 aFlags,
 47739:                           nscolor aBackgroundColor,
 47739:                           gfxContext* aThebesContext)
 47739: {
 47739:   NS_TIME_FUNCTION_WITH_DOCURL;
 47739: 
 47739:   NS_ENSURE_TRUE(!(aFlags & RENDER_IS_UNTRUSTED), NS_ERROR_NOT_IMPLEMENTED);
 47739: 
 80879:   nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
 80879:   if (rootPresContext) {
 80879:     rootPresContext->FlushWillPaintObservers();
 80879:     if (mIsDestroying)
 80879:       return NS_OK;
 80879:   }
 80879: 
 59486:   nsAutoScriptBlocker blockScripts;
 59486: 
 47739:   // Set up the rectangle as the path in aThebesContext
  7683:   gfxRect r(0, 0,
  7683:             nsPresContext::AppUnitsToFloatCSSPixels(aRect.width),
  7683:             nsPresContext::AppUnitsToFloatCSSPixels(aRect.height));
 20226:   aThebesContext->NewPath();
 20282: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
 80486:   aThebesContext->Rectangle(r, true);
 20226: #else
 20226:   aThebesContext->Rectangle(r);
 20226: #endif
 47739: 
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
 47739:   if (!rootFrame) {
 47739:     // Nothing to paint, just fill the rect
 47739:     aThebesContext->SetColor(gfxRGBA(aBackgroundColor));
 47739:     aThebesContext->Fill();
 47739:     return NS_OK;
 47739:   }
 47739: 
 47739:   gfxContextAutoSaveRestore save(aThebesContext);
 47739: 
 47739:   gfxContext::GraphicsOperator oldOperator = aThebesContext->CurrentOperator();
 47739:   if (oldOperator == gfxContext::OPERATOR_OVER) {
 47739:     // Clip to the destination rectangle before we push the group,
 47739:     // to limit the size of the temporary surface
 20226:     aThebesContext->Clip();
 47739:   }
 47739: 
 47739:   // we want the window to be composited as a single image using
 47739:   // whatever operator was set; set OPERATOR_OVER here, which is
 47739:   // either already the case, or overrides the operator in a group.
 47739:   // the original operator will be present when we PopGroup.
 20226:   // we can avoid using a temporary surface if we're using OPERATOR_OVER
 20226:   // and our background color has no alpha (so we'll be compositing on top
 20226:   // of a fully opaque solid color region)
 79445:   bool needsGroup = NS_GET_A(aBackgroundColor) < 0xff ||
 47739:     oldOperator != gfxContext::OPERATOR_OVER;
 20226: 
 20226:   if (needsGroup) {
  1735:     aThebesContext->PushGroup(NS_GET_A(aBackgroundColor) == 0xff ?
  1735:                               gfxASurface::CONTENT_COLOR :
  1735:                               gfxASurface::CONTENT_COLOR_ALPHA);
  1735:     aThebesContext->Save();
 47739: 
 47739:     if (oldOperator != gfxContext::OPERATOR_OVER) {
 47739:       // Clip now while we paint to the temporary surface. For
 47739:       // non-source-bounded operators (e.g., SOURCE), we need to do clip
 47739:       // here after we've pushed the group, so that eventually popping
 47739:       // the group and painting it will be able to clear the entire
 47739:       // destination surface.
 47739:       aThebesContext->Clip();
 34441:       aThebesContext->SetOperator(gfxContext::OPERATOR_OVER);
 47739:     }
 47739:   }
 47739: 
 47739:   aThebesContext->Translate(gfxPoint(-nsPresContext::AppUnitsToFloatCSSPixels(aRect.x),
 47739:                                      -nsPresContext::AppUnitsToFloatCSSPixels(aRect.y)));
  1735: 
 68668:   nsDeviceContext* devCtx = mPresContext->DeviceContext();
  7683:   gfxFloat scale = gfxFloat(devCtx->AppUnitsPerDevPixel())/nsPresContext::AppUnitsPerCSSPixel();
  7683:   aThebesContext->Scale(scale, scale);
  7683: 
 47758:   // Since canvas APIs use floats to set up their matrices, we may have
 47758:   // some slight inaccuracy here. Adjust matrix components that are
 47758:   // integers up to the accuracy of floats to be those integers.
 47758:   aThebesContext->NudgeCurrentMatrixToIntegers();
 47758: 
 54080:   AutoSaveRestoreRenderingState _(this);
 54080: 
 68670:   nsRefPtr<nsRenderingContext> rc = new nsRenderingContext();
  1735:   rc->Init(devCtx, aThebesContext);
  1735: 
 79445:   bool wouldFlushRetainedLayers = false;
 48224:   PRUint32 flags = nsLayoutUtils::PAINT_IGNORE_SUPPRESSION;
 60027:   if (aThebesContext->CurrentMatrix().HasNonIntegerTranslation()) {
 60027:     flags |= nsLayoutUtils::PAINT_IN_TRANSFORM;
 60027:   }
 48224:   if (!(aFlags & RENDER_ASYNC_DECODE_IMAGES)) {
 48224:     flags |= nsLayoutUtils::PAINT_SYNC_DECODE_IMAGES;
 48224:   }
 38805:   if (aFlags & RENDER_USE_WIDGET_LAYERS) {
 49168:     // We only support using widget layers on display root's with widgets.
 49168:     nsIView* view = rootFrame->GetView();
 49168:     if (view && view->GetWidget() &&
 49168:         nsLayoutUtils::GetDisplayRootFrame(rootFrame) == rootFrame) {
 47739:       flags |= nsLayoutUtils::PAINT_WIDGET_LAYERS;
 47739:     }
 49168:   }
 47739:   if (!(aFlags & RENDER_CARET)) {
 80486:     wouldFlushRetainedLayers = true;
 47739:     flags |= nsLayoutUtils::PAINT_HIDE_CARET;
 47739:   }
 47739:   if (aFlags & RENDER_IGNORE_VIEWPORT_SCROLLING) {
 54080:     wouldFlushRetainedLayers = !IgnoringViewportScrolling();
 80486:     mRenderFlags = ChangeFlag(mRenderFlags, true, STATE_IGNORING_VIEWPORT_SCROLLING);
 51761:   }
 54079:   if (aFlags & RENDER_DOCUMENT_RELATIVE) {
 54080:     // XXX be smarter about this ... drawWindow might want a rect
 54080:     // that's "pretty close" to what our retained layer tree covers.
 54080:     // In that case, it wouldn't disturb normal rendering too much,
 54080:     // and we should allow it.
 80486:     wouldFlushRetainedLayers = true;
 54079:     flags |= nsLayoutUtils::PAINT_DOCUMENT_RELATIVE;
 54079:   }
 54080: 
 54080:   // Don't let drawWindow blow away our retained layer tree
 54080:   if ((flags & nsLayoutUtils::PAINT_WIDGET_LAYERS) && wouldFlushRetainedLayers) {
 54080:     flags &= ~nsLayoutUtils::PAINT_WIDGET_LAYERS;
 54080:   }
 54080: 
 47739:   nsLayoutUtils::PaintFrame(rc, rootFrame, nsRegion(aRect),
 47739:                             aBackgroundColor, flags);
 34441: 
 20226:   // if we had to use a group, paint it to the destination now
 20226:   if (needsGroup) {
  1735:     aThebesContext->Restore();
  1735:     aThebesContext->PopGroupToSource();
  1735:     aThebesContext->Paint();
 20226:   }
  1735: 
     1:   return NS_OK;
     1: }
     1: 
     1: /*
     1:  * Clip the display list aList to a range. Returns the clipped
     1:  * rectangle surrounding the range.
     1:  */
     1: nsRect
     1: PresShell::ClipListToRange(nsDisplayListBuilder *aBuilder,
     1:                            nsDisplayList* aList,
 86939:                            nsRange* aRange)
     1: {
 42480:   NS_TIME_FUNCTION_WITH_DOCURL;
 42480: 
     1:   // iterate though the display items and add up the bounding boxes of each.
     1:   // This will allow the total area of the frames within the range to be
     1:   // determined. To do this, remove an item from the bottom of the list, check
     1:   // whether it should be part of the range, and if so, append it to the top
     1:   // of the temporary list tmpList. If the item is a text frame at the end of
     1:   // the selection range, wrap it in an nsDisplayClip to clip the display to
     1:   // the portion of the text frame that is part of the selection. Then, append
     1:   // the wrapper to the top of the list. Otherwise, just delete the item and
     1:   // don't append it.
     1:   nsRect surfaceRect;
     1:   nsDisplayList tmpList;
     1: 
     1:   nsDisplayItem* i;
     1:   while ((i = aList->RemoveBottom())) {
     1:     // itemToInsert indiciates the item that should be inserted into the
     1:     // temporary list. If null, no item should be inserted.
     1:     nsDisplayItem* itemToInsert = nsnull;
     1:     nsIFrame* frame = i->GetUnderlyingFrame();
     1:     if (frame) {
     1:       nsIContent* content = frame->GetContent();
     1:       if (content) {
 79445:         bool atStart = (content == aRange->GetStartParent());
 79445:         bool atEnd = (content == aRange->GetEndParent());
     1:         if ((atStart || atEnd) && frame->GetType() == nsGkAtoms::textFrame) {
     1:           PRInt32 frameStartOffset, frameEndOffset;
     1:           frame->GetOffsets(frameStartOffset, frameEndOffset);
     1: 
     1:           PRInt32 hilightStart =
 32531:             atStart ? NS_MAX(aRange->StartOffset(), frameStartOffset) : frameStartOffset;
     1:           PRInt32 hilightEnd =
 32531:             atEnd ? NS_MIN(aRange->EndOffset(), frameEndOffset) : frameEndOffset;
     1:           if (hilightStart < hilightEnd) {
     1:             // determine the location of the start and end edges of the range.
     1:             nsPoint startPoint, endPoint;
  4741:             frame->GetPointFromOffset(hilightStart, &startPoint);
  4741:             frame->GetPointFromOffset(hilightEnd, &endPoint);
     1: 
     1:             // the clip rectangle is determined by taking the the start and
     1:             // end points of the range, offset from the reference frame.
     1:             // Because of rtl, the end point may be to the left of the
     1:             // start point, so x is set to the lowest value
     1:             nsRect textRect(aBuilder->ToReferenceFrame(frame), frame->GetSize());
 32531:             nscoord x = NS_MIN(startPoint.x, endPoint.x);
     1:             textRect.x += x;
 32531:             textRect.width = NS_MAX(startPoint.x, endPoint.x) - x;
     1:             surfaceRect.UnionRect(surfaceRect, textRect);
     1: 
     1:             // wrap the item in an nsDisplayClip so that it can be clipped to
     1:             // the selection. If the allocation fails, fall through and delete
     1:             // the item below.
 51260:             itemToInsert = new (aBuilder)
 52289:                 nsDisplayClip(aBuilder, frame, i, textRect);
     1:           }
     1:         }
 43138:         // Don't try to descend into subdocuments.
 43138:         // If this ever changes we'd need to add handling for subdocuments with
 43138:         // different zoom levels.
 43138:         else if (content->GetCurrentDoc() ==
 43138:                    aRange->GetStartParent()->GetCurrentDoc()) {
     1:           // if the node is within the range, append it to the temporary list
 79445:           bool before, after;
 43138:           nsresult rv =
     1:             nsRange::CompareNodeToRange(content, aRange, &before, &after);
 43138:           if (NS_SUCCEEDED(rv) && !before && !after) {
     1:             itemToInsert = i;
 95051:             bool snap;
 95051:             surfaceRect.UnionRect(surfaceRect, i->GetBounds(aBuilder, &snap));
     1:           }
     1:         }
     1:       }
     1:     }
     1: 
     1:     // insert the item into the list if necessary. If the item has a child
     1:     // list, insert that as well
     1:     nsDisplayList* sublist = i->GetList();
     1:     if (itemToInsert || sublist) {
     1:       tmpList.AppendToTop(itemToInsert ? itemToInsert : i);
     1:       // if the item is a list, iterate over it as well
     1:       if (sublist)
     1:         surfaceRect.UnionRect(surfaceRect,
  4741:           ClipListToRange(aBuilder, sublist, aRange));
     1:     }
     1:     else {
     1:       // otherwise, just delete the item and don't readd it to the list
     1:       i->~nsDisplayItem();
     1:     }
     1:   }
     1: 
     1:   // now add all the items back onto the original list again
     1:   aList->AppendToTop(&tmpList);
     1: 
     1:   return surfaceRect;
     1: }
     1: 
 43138: #ifdef DEBUG
 43138: #include <stdio.h>
 43138: 
 79445: static bool gDumpRangePaintList = false;
 43138: #endif
 43138: 
     1: RangePaintInfo*
     1: PresShell::CreateRangePaintInfo(nsIDOMRange* aRange,
 47337:                                 nsRect& aSurfaceRect,
 79445:                                 bool aForPrimarySelection)
     1: {
 42480:   NS_TIME_FUNCTION_WITH_DOCURL;
 42480: 
     1:   RangePaintInfo* info = nsnull;
     1: 
 86939:   nsRange* range = static_cast<nsRange*>(aRange);
     1: 
   219:   nsIFrame* ancestorFrame;
   219:   nsIFrame* rootFrame = GetRootFrame();
   219: 
   219:   // If the start or end of the range is the document, just use the root
   219:   // frame, otherwise get the common ancestor of the two endpoints of the
   219:   // range.
   219:   nsINode* startParent = range->GetStartParent();
   219:   nsINode* endParent = range->GetEndParent();
   219:   nsIDocument* doc = startParent->GetCurrentDoc();
   219:   if (startParent == doc || endParent == doc) {
   219:     ancestorFrame = rootFrame;
   219:   }
   219:   else {
   219:     nsINode* ancestor = nsContentUtils::GetCommonAncestor(startParent, endParent);
     1:     NS_ASSERTION(!ancestor || ancestor->IsNodeOfType(nsINode::eCONTENT),
     1:                  "common ancestor is not content");
     1:     if (!ancestor || !ancestor->IsNodeOfType(nsINode::eCONTENT))
     1:       return nsnull;
     1: 
  3233:     nsIContent* ancestorContent = static_cast<nsIContent*>(ancestor);
 36656:     ancestorFrame = ancestorContent->GetPrimaryFrame();
     1: 
     1:     // use the nearest ancestor frame that includes all continuations as the
     1:     // root for building the display list
    94:     while (ancestorFrame &&
    94:            nsLayoutUtils::GetNextContinuationOrSpecialSibling(ancestorFrame))
     1:       ancestorFrame = ancestorFrame->GetParent();
   219:   }
     1: 
     1:   if (!ancestorFrame)
     1:     return nsnull;
     1: 
     1:   info = new RangePaintInfo(range, ancestorFrame);
     1: 
 55040:   nsRect ancestorRect = ancestorFrame->GetVisualOverflowRect();
     1: 
     1:   // get a display list containing the range
 58774:   info->mBuilder.SetIncludeAllOutOfFlows();
 47337:   if (aForPrimarySelection) {
 47337:     info->mBuilder.SetSelectedFramesOnly();
 47337:   }
     1:   info->mBuilder.EnterPresShell(ancestorFrame, ancestorRect);
     1:   ancestorFrame->BuildDisplayListForStackingContext(&info->mBuilder,
     1:                                                     ancestorRect, &info->mList);
     1: 
 43138: #ifdef DEBUG
 43138:   if (gDumpRangePaintList) {
 43138:     fprintf(stderr, "CreateRangePaintInfo --- before ClipListToRange:\n");
 43138:     nsFrame::PrintDisplayList(&(info->mBuilder), info->mList);
 43138:   }
 43138: #endif
 43138: 
  4741:   nsRect rangeRect = ClipListToRange(&info->mBuilder, &info->mList, range);
     1: 
 60095:   info->mBuilder.LeavePresShell(ancestorFrame, ancestorRect);
 60095: 
 43138: #ifdef DEBUG
 43138:   if (gDumpRangePaintList) {
 43138:     fprintf(stderr, "CreateRangePaintInfo --- after ClipListToRange:\n");
 43138:     nsFrame::PrintDisplayList(&(info->mBuilder), info->mList);
 43138:   }
 43138: #endif
 43138: 
     1:   // determine the offset of the reference frame for the display list
     1:   // to the root frame. This will allow the coordinates used when painting
     1:   // to all be offset from the same point
   219:   info->mRootOffset = ancestorFrame->GetOffsetTo(rootFrame);
     1:   rangeRect.MoveBy(info->mRootOffset);
     1:   aSurfaceRect.UnionRect(aSurfaceRect, rangeRect);
     1: 
     1:   return info;
     1: }
     1: 
     1: already_AddRefed<gfxASurface>
     1: PresShell::PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
     1:                                nsISelection* aSelection,
 43137:                                nsIntRegion* aRegion,
     1:                                nsRect aArea,
 23738:                                nsIntPoint& aPoint,
 23738:                                nsIntRect* aScreenRect)
     1: {
 42480:   NS_TIME_FUNCTION_WITH_DOCURL;
 42480: 
     1:   nsPresContext* pc = GetPresContext();
  1562:   if (!pc || aArea.width == 0 || aArea.height == 0)
     1:     return nsnull;
     1: 
 68668:   nsDeviceContext* deviceContext = pc->DeviceContext();
     1: 
     1:   // use the rectangle to create the surface
 28113:   nsIntRect pixelArea = aArea.ToOutsidePixels(pc->AppUnitsPerDevPixel());
     1: 
     1:   // if the area of the image is larger than the maximum area, scale it down
     1:   float scale = 0.0;
 48930:   nsIntRect rootScreenRect =
 48930:     GetRootFrame()->GetScreenRectInAppUnits().ToNearestPixels(
 48930:       pc->AppUnitsPerDevPixel());
     1: 
     1:   // if the image is larger in one or both directions than half the size of
     1:   // the available screen area, scale the image down to that size.
     1:   nsRect maxSize;
     1:   deviceContext->GetClientRect(maxSize);
     1:   nscoord maxWidth = pc->AppUnitsToDevPixels(maxSize.width >> 1);
     1:   nscoord maxHeight = pc->AppUnitsToDevPixels(maxSize.height >> 1);
 79445:   bool resize = (pixelArea.width > maxWidth || pixelArea.height > maxHeight);
     1:   if (resize) {
     1:     scale = 1.0;
     1:     // divide the maximum size by the image size in both directions. Whichever
     1:     // direction produces the smallest result determines how much should be
     1:     // scaled.
     1:     if (pixelArea.width > maxWidth)
 32531:       scale = NS_MIN(scale, float(maxWidth) / pixelArea.width);
     1:     if (pixelArea.height > maxHeight)
 32531:       scale = NS_MIN(scale, float(maxHeight) / pixelArea.height);
     1: 
     1:     pixelArea.width = NSToIntFloor(float(pixelArea.width) * scale);
     1:     pixelArea.height = NSToIntFloor(float(pixelArea.height) * scale);
     1: 
     1:     // adjust the screen position based on the rescaled size
     1:     nscoord left = rootScreenRect.x + pixelArea.x;
     1:     nscoord top = rootScreenRect.y + pixelArea.y;
     1:     aScreenRect->x = NSToIntFloor(aPoint.x - float(aPoint.x - left) * scale);
     1:     aScreenRect->y = NSToIntFloor(aPoint.y - float(aPoint.y - top) * scale);
     1:   }
     1:   else {
     1:     // move aScreenRect to the position of the surface in screen coordinates
     1:     aScreenRect->MoveTo(rootScreenRect.x + pixelArea.x, rootScreenRect.y + pixelArea.y);
     1:   }
     1:   aScreenRect->width = pixelArea.width;
     1:   aScreenRect->height = pixelArea.height;
     1: 
     1:   gfxImageSurface* surface =
     1:     new gfxImageSurface(gfxIntSize(pixelArea.width, pixelArea.height),
     1:                         gfxImageSurface::ImageFormatARGB32);
 72510:   if (surface->CairoStatus()) {
  1562:     delete surface;
     1:     return nsnull;
  1562:   }
     1: 
     1:   // clear the image
     1:   gfxContext context(surface);
     1:   context.SetOperator(gfxContext::OPERATOR_CLEAR);
     1:   context.Rectangle(gfxRect(0, 0, pixelArea.width, pixelArea.height));
     1:   context.Fill();
     1: 
 68670:   nsRefPtr<nsRenderingContext> rc = new nsRenderingContext();
     1:   rc->Init(deviceContext, surface);
     1: 
 43137:   if (aRegion) {
 43137:     // Convert aRegion from CSS pixels to dev pixels
 43137:     nsIntRegion region =
 43137:       aRegion->ToAppUnits(nsPresContext::AppUnitsPerCSSPixel())
 43137:         .ToOutsidePixels(pc->AppUnitsPerDevPixel());
 68485:     rc->SetClip(region);
 43137:   }
     1: 
     1:   if (resize)
     1:     rc->Scale(scale, scale);
     1: 
     1:   // translate so that points are relative to the surface area
 68479:   rc->Translate(-aArea.TopLeft());
     1: 
     1:   // temporarily hide the selection so that text is drawn normally. If a
     1:   // selection is being rendered, use that, otherwise use the presshell's
     1:   // selection.
 70097:   nsRefPtr<nsFrameSelection> frameSelection;
     1:   if (aSelection) {
     1:     nsCOMPtr<nsISelectionPrivate> selpriv = do_QueryInterface(aSelection);
     1:     selpriv->GetFrameSelection(getter_AddRefs(frameSelection));
     1:   }
     1:   else {
     1:     frameSelection = FrameSelection();
     1:   }
     1:   PRInt16 oldDisplaySelection = frameSelection->GetDisplaySelection();
     1:   frameSelection->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
     1: 
     1:   // next, paint each range in the selection
     1:   PRInt32 count = aItems->Length();
     1:   for (PRInt32 i = 0; i < count; i++) {
     1:     RangePaintInfo* rangeInfo = (*aItems)[i];
     1:     // the display lists paint relative to the offset from the reference
     1:     // frame, so translate the rendering context
 68481:     nsRenderingContext::AutoPushTranslation
 68479:       translate(rc, rangeInfo->mRootOffset);
     1: 
     1:     aArea.MoveBy(-rangeInfo->mRootOffset.x, -rangeInfo->mRootOffset.y);
 33368:     nsRegion visible(aArea);
 51633:     rangeInfo->mList.ComputeVisibilityForRoot(&rangeInfo->mBuilder, &visible);
 42246:     rangeInfo->mList.PaintRoot(&rangeInfo->mBuilder, rc, nsDisplayList::PAINT_DEFAULT);
     1:     aArea.MoveBy(rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
     1:   }
     1: 
     1:   // restore the old selection display state
     1:   frameSelection->SetDisplaySelection(oldDisplaySelection);
     1: 
     1:   NS_ADDREF(surface);
     1:   return surface;
     1: }
     1: 
     1: already_AddRefed<gfxASurface>
     1: PresShell::RenderNode(nsIDOMNode* aNode,
 43137:                       nsIntRegion* aRegion,
 23738:                       nsIntPoint& aPoint,
 23738:                       nsIntRect* aScreenRect)
     1: {
     1:   // area will hold the size of the surface needed to draw the node, measured
     1:   // from the root frame.
     1:   nsRect area;
     1:   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
     1: 
 18448:   // nothing to draw if the node isn't in a document
 18448:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 18448:   if (!node->IsInDoc())
 18448:     return nsnull;
 18448:   
 86939:   nsRefPtr<nsRange> range = new nsRange();
 20084:   if (NS_FAILED(range->SelectNode(aNode)))
 20084:     return nsnull;
     1: 
 80486:   RangePaintInfo* info = CreateRangePaintInfo(range, area, false);
     1:   if (info && !rangeItems.AppendElement(info)) {
     1:     delete info;
     1:     return nsnull;
     1:   }
     1: 
     1:   if (aRegion) {
     1:     // combine the area with the supplied region
 43137:     nsIntRect rrectPixels = aRegion->GetBounds();
     1: 
 28113:     nsRect rrect = rrectPixels.ToAppUnits(nsPresContext::AppUnitsPerCSSPixel());
     1:     area.IntersectRect(area, rrect);
     1:     
     1:     nsPresContext* pc = GetPresContext();
     1:     if (!pc)
     1:       return nsnull;
     1: 
     1:     // move the region so that it is offset from the topleft corner of the surface
 43138:     aRegion->MoveBy(-pc->AppUnitsToDevPixels(area.x),
 43138:                     -pc->AppUnitsToDevPixels(area.y));
     1:   }
     1: 
     1:   return PaintRangePaintInfo(&rangeItems, nsnull, aRegion, area, aPoint,
     1:                              aScreenRect);
     1: }
     1: 
     1: already_AddRefed<gfxASurface>
     1: PresShell::RenderSelection(nsISelection* aSelection,
 23738:                            nsIntPoint& aPoint,
 23738:                            nsIntRect* aScreenRect)
     1: {
     1:   // area will hold the size of the surface needed to draw the selection,
     1:   // measured from the root frame.
     1:   nsRect area;
     1:   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
     1: 
     1:   // iterate over each range and collect them into the rangeItems array.
     1:   // This is done so that the size of selection can be determined so as
     1:   // to allocate a surface area
     1:   PRInt32 numRanges;
     1:   aSelection->GetRangeCount(&numRanges);
  1562:   NS_ASSERTION(numRanges > 0, "RenderSelection called with no selection");
  1562: 
     1:   for (PRInt32 r = 0; r < numRanges; r++)
     1:   {
     1:     nsCOMPtr<nsIDOMRange> range;
     1:     aSelection->GetRangeAt(r, getter_AddRefs(range));
     1: 
 80486:     RangePaintInfo* info = CreateRangePaintInfo(range, area, true);
     1:     if (info && !rangeItems.AppendElement(info)) {
     1:       delete info;
     1:       return nsnull;
     1:     }
     1:   }
     1: 
     1:   return PaintRangePaintInfo(&rangeItems, aSelection, nsnull, area, aPoint,
     1:                              aScreenRect);
     1: }
     1: 
 49166: nsresult
 49166: PresShell::AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
 49166:                                          nsDisplayList&        aList,
 49166:                                          nsIFrame*             aFrame,
 49166:                                          const nsRect&         aBounds)
 49166: {
 51260:   return aList.AppendNewToBottom(new (&aBuilder)
 51260:     nsDisplaySolidColor(&aBuilder, aFrame, aBounds, NS_RGB(115, 115, 115)));
 49166: }
 49166: 
 79445: static bool
 47741: AddCanvasBackgroundColor(const nsDisplayList& aList, nsIFrame* aCanvasFrame,
 47741:                          nscolor aColor)
 47741: {
 47741:   for (nsDisplayItem* i = aList.GetBottom(); i; i = i->GetAbove()) {
 47741:     if (i->GetUnderlyingFrame() == aCanvasFrame &&
 47741:         i->GetType() == nsDisplayItem::TYPE_CANVAS_BACKGROUND) {
 47741:       nsDisplayCanvasBackground* bg = static_cast<nsDisplayCanvasBackground*>(i);
 47741:       bg->SetExtraBackgroundColor(aColor);
 80486:       return true;
 47741:     }
 47741:     nsDisplayList* sublist = i->GetList();
 47741:     if (sublist && AddCanvasBackgroundColor(*sublist, aCanvasFrame, aColor))
 80486:       return true;
 80486:   }
 80486:   return false;
 47741: }
 47741: 
 29987: nsresult PresShell::AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
 29987:                                                  nsDisplayList&        aList,
 29987:                                                  nsIFrame*             aFrame,
 47739:                                                  const nsRect&         aBounds,
 35428:                                                  nscolor               aBackstopColor,
 61411:                                                  PRUint32              aFlags)
 61411: {
 80559:   if (aBounds.IsEmpty()) {
 80559:     return NS_OK;
 80559:   }
 30107:   // We don't want to add an item for the canvas background color if the frame
 30107:   // (sub)tree we are painting doesn't include any canvas frames. There isn't
 30107:   // an easy way to check this directly, but if we check if the root of the
 30107:   // (sub)tree we are painting is a canvas frame that should cover us in all
 30107:   // cases (it will usually be a viewport frame when we have a canvas frame in
 30107:   // the (sub)tree).
 64531:   if (!(aFlags & nsIPresShell::FORCE_DRAW) &&
 61411:       !nsCSSRendering::IsCanvasFrame(aFrame)) {
 30107:     return NS_OK;
 61411:   }
 30107: 
 29987:   nscolor bgcolor = NS_ComposeColors(aBackstopColor, mCanvasBackgroundColor);
 60674:   if (NS_GET_A(bgcolor) == 0)
 60674:     return NS_OK;
 47741: 
 47741:   // To make layers work better, we want to avoid having a big non-scrolled 
 47741:   // color background behind a scrolled transparent background. Instead,
 47741:   // we'll try to move the color background into the scrolled content
 47741:   // by making nsDisplayCanvasBackground paint it.
 47741:   if (!aFrame->GetParent()) {
 47741:     nsIScrollableFrame* sf =
 47741:       aFrame->PresContext()->PresShell()->GetRootScrollFrameAsScrollable();
 47741:     if (sf) {
 47741:       nsCanvasFrame* canvasFrame = do_QueryFrame(sf->GetScrolledFrame());
 47741:       if (canvasFrame && canvasFrame->IsVisibleForPainting(&aBuilder)) {
 47741:         if (AddCanvasBackgroundColor(aList, canvasFrame, bgcolor))
 47741:           return NS_OK;
 47741:       }
 47741:     }
 47741:   }
 47741: 
 47739:   return aList.AppendNewToBottom(
 69802:       new (&aBuilder) nsDisplaySolidColor(&aBuilder, aFrame, aBounds, bgcolor));
 29987: }
 29987: 
 79445: static bool IsTransparentContainerElement(nsPresContext* aPresContext)
 51627: {
 51627:   nsCOMPtr<nsISupports> container = aPresContext->GetContainerInternal();
 51627:   nsCOMPtr<nsIDocShellTreeItem> docShellItem = do_QueryInterface(container);
 51627:   nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(docShellItem));
 51627:   if (!pwin)
 80486:     return false;
 51627:   nsCOMPtr<nsIContent> containerElement =
 51627:     do_QueryInterface(pwin->GetFrameElementInternal());
 51627:   return containerElement &&
 51627:          containerElement->HasAttr(kNameSpaceID_None, nsGkAtoms::transparent);
 51627: }
 51627: 
 78004: nscolor PresShell::GetDefaultBackgroundColorToDraw()
 78004: {
 78004:   if (!mPresContext || !mPresContext->GetBackgroundColorDraw()) {
 78004:     return NS_RGB(255,255,255);
 78004:   }
 78004:   return mPresContext->DefaultBackgroundColor();
 78004: }
 78004: 
 27834: void PresShell::UpdateCanvasBackground()
 27834: {
 25385:   // If we have a frame tree and it has style information that
 25385:   // specifies the background color of the canvas, update our local
 25385:   // cache of that color.
 51627:   nsIFrame* rootStyleFrame = FrameConstructor()->GetRootElementStyleFrame();
 51627:   if (rootStyleFrame) {
 40177:     nsStyleContext* bgStyle =
 51627:       nsCSSRendering::FindRootFrameBackground(rootStyleFrame);
 29987:     // XXX We should really be passing the canvasframe, not the root element
 29987:     // style frame but we don't have access to the canvasframe here. It isn't
 29987:     // a problem because only a few frames can return something other than true
 29987:     // and none of them would be a canvas frame or root element style frame.
 97536:     bool drawBackgroundImage;
 97536:     bool drawBackgroundColor;
 97536: 
 29987:     mCanvasBackgroundColor =
 51627:       nsCSSRendering::DetermineBackgroundColor(mPresContext, bgStyle,
 97536:                                                rootStyleFrame,
 97536:                                                drawBackgroundImage,
 97536:                                                drawBackgroundColor);
 77931:     if (GetPresContext()->IsRootContentDocument() &&
 51627:         !IsTransparentContainerElement(mPresContext)) {
 51627:       mCanvasBackgroundColor =
 78004:         NS_ComposeColors(GetDefaultBackgroundColorToDraw(), mCanvasBackgroundColor);
 51627:     }
 29987:   }
 29987: 
 29987:   // If the root element of the document (ie html) has style 'display: none'
 29987:   // then the document's background color does not get drawn; cache the
 29987:   // color we actually draw.
 29987:   if (!FrameConstructor()->GetRootElementFrame()) {
 78004:     mCanvasBackgroundColor = GetDefaultBackgroundColorToDraw();
 29987:   }
 80737:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 80737:     if (TabChild* tabChild = GetTabChildFrom(this)) {
 80737:       tabChild->SetBackgroundColor(mCanvasBackgroundColor);
 80737:     }
 80737:   }
 29987: }
 29987: 
 38805: nscolor PresShell::ComputeBackstopColor(nsIView* aDisplayRoot)
 38805: {
 38805:   nsIWidget* widget = aDisplayRoot->GetWidget();
 95568:   if (widget && (widget->GetTransparencyMode() != eTransparencyOpaque ||
 95568:                  widget->WidgetPaintsBackground())) {
 29987:     // Within a transparent widget, so the backstop color must be
 29987:     // totally transparent.
 29987:     return NS_RGBA(0,0,0,0);
 29987:   }
 29987:   // Within an opaque widget (or no widget at all), so the backstop
 29987:   // color must be totally opaque. The user's default background
 29987:   // as reported by the prescontext is guaranteed to be opaque.
 78004:   return GetDefaultBackgroundColorToDraw();
 27834: }
 27834: 
 42593: struct PaintParams {
 42593:   nscolor mBackgroundColor;
 42593: };
 42593: 
 48947: LayerManager* PresShell::GetLayerManager()
 48947: {
 48947:   NS_ASSERTION(mViewManager, "Should have view manager");
 48947: 
 64435:   nsIView* rootView = mViewManager->GetRootView();
 64435:   if (rootView) {
 48947:     if (nsIWidget* widget = rootView->GetWidget()) {
 48947:       return widget->GetLayerManager();
 48947:     }
 48947:   }
 48947:   return nsnull;
 48947: }
 48947: 
 79445: void PresShell::SetIgnoreViewportScrolling(bool aIgnore)
 54080: {
 54080:   if (IgnoringViewportScrolling() == aIgnore) {
 54080:     return;
 54080:   }
 54080:   RenderingState state(this);
 54080:   state.mRenderFlags = ChangeFlag(state.mRenderFlags, aIgnore,
 54080:                                   STATE_IGNORING_VIEWPORT_SCROLLING);
 54080:   SetRenderingState(state);
 54080: }
 54080: 
 54080: void PresShell::SetDisplayPort(const nsRect& aDisplayPort)
 54080: {
 63413:   NS_ABORT_IF_FALSE(false, "SetDisplayPort is deprecated");
 54080: }
 54080: 
 54081: nsresult PresShell::SetResolution(float aXResolution, float aYResolution)
 54081: {
 90287:   if (!(aXResolution > 0.0 && aYResolution > 0.0)) {
 54081:     return NS_ERROR_ILLEGAL_VALUE;
 54081:   }
 54081:   if (aXResolution == mXResolution && aYResolution == mYResolution) {
 54081:     return NS_OK;
 54081:   }
 54081:   RenderingState state(this);
 54081:   state.mXResolution = aXResolution;
 54081:   state.mYResolution = aYResolution;
 54081:   SetRenderingState(state);
 54081:   return NS_OK;
 54081:  }
 54081: 
 54080: void PresShell::SetRenderingState(const RenderingState& aState)
 54080: {
 54080:   if (mRenderFlags != aState.mRenderFlags) {
 54080:     // Rendering state changed in a way that forces us to flush any
 54080:     // retained layers we might already have.
 54080:     LayerManager* manager = GetLayerManager();
 54080:     if (manager) {
 54080:       FrameLayerBuilder::InvalidateAllLayers(manager);
 54080:     }
 54080:   }
 54080: 
 54080:   mRenderFlags = aState.mRenderFlags;
 54081:   mXResolution = aState.mXResolution;
 54081:   mYResolution = aState.mYResolution;
 60447: }
 54080: 
 79445: void PresShell::SynthesizeMouseMove(bool aFromScroll)
 52492: {
 92149:   if (!sSynthMouseMove)
 92149:     return;
 92149: 
 69702:   if (mPaintingSuppressed || !mIsActive || !mPresContext) {
 69702:     return;
 69702:   }
 69702: 
 69702:   if (!mPresContext->IsRoot()) {
 69702:     nsIPresShell* rootPresShell = GetRootPresShell();
 69702:     if (rootPresShell) {
 69702:       rootPresShell->SynthesizeMouseMove(aFromScroll);
 69702:     }
 69702:     return;
 69702:   }
 69702: 
 69702:   if (mMouseLocation == nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE))
 69702:     return;
 69702: 
 69702:   if (!mSynthMouseMoveEvent.IsPending()) {
 69702:     nsRefPtr<nsSynthMouseMoveEvent> ev =
 69702:         new nsSynthMouseMoveEvent(this, aFromScroll);
 69702: 
 87190:     if (!GetPresContext()->RefreshDriver()->AddRefreshObserver(ev,
 87190:                                                                Flush_Display)) {
 69702:       NS_WARNING("failed to dispatch nsSynthMouseMoveEvent");
 69702:       return;
 69702:     }
 69702: 
 69702:     mSynthMouseMoveEvent = ev;
 69702:   }
 69702: }
 69702: 
 69702: /**
 69702:  * Find the first floating view with a widget in a postorder traversal of the
 69702:  * view tree that contains the point. Thus more deeply nested floating views
 69702:  * are preferred over their ancestors, and floating views earlier in the
 69702:  * view hierarchy (i.e., added later) are preferred over their siblings.
 69702:  * This is adequate for finding the "topmost" floating view under a point,
 69702:  * given that floating views don't supporting having a specific z-index.
 69702:  * 
 69702:  * We cannot exit early when aPt is outside the view bounds, because floating
 69702:  * views aren't necessarily included in their parent's bounds, so this could
 69702:  * traverse the entire view hierarchy --- use carefully.
 69702:  */
 69702: static nsIView* FindFloatingViewContaining(nsIView* aView, nsPoint aPt)
 69702: {
 69702:   if (aView->GetVisibility() == nsViewVisibility_kHide)
 69702:     // No need to look into descendants.
 69702:     return nsnull;
 69702: 
 82566:   nsIFrame* frame = aView->GetFrame();
 80910:   if (frame) {
 80910:     if (!frame->IsVisibleConsideringAncestors(nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY) ||
 80910:         !frame->PresContext()->PresShell()->IsActive()) {
 69702:       return nsnull;
 69702:     }
 80910:   }
 69702: 
 69702:   for (nsIView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
 69702:     nsIView* r = FindFloatingViewContaining(v, v->ConvertFromParentCoords(aPt));
 69702:     if (r)
 69702:       return r;
 69702:   }
 69702: 
 69702:   if (aView->GetFloating() && aView->HasWidget() &&
 69702:       aView->GetDimensions().Contains(aPt))
 69702:     return aView;
 69702:     
 69702:   return nsnull;
 69702: }
 69702: 
 69702: /*
 69702:  * This finds the first view containing the given point in a postorder
 69702:  * traversal of the view tree that contains the point, assuming that the
 69702:  * point is not in a floating view.  It assumes that only floating views
 69702:  * extend outside the bounds of their parents.
 69702:  *
 69702:  * This methods should only be called if FindFloatingViewContaining
 69702:  * returns null.
 69702:  */
 69702: static nsIView* FindViewContaining(nsIView* aView, nsPoint aPt)
 69702: {
 69702:   if (!aView->GetDimensions().Contains(aPt) ||
 69702:       aView->GetVisibility() == nsViewVisibility_kHide) {
 69702:     return nsnull;
 69702:   }
 69702: 
 82566:   nsIFrame* frame = aView->GetFrame();
 80910:   if (frame) {
 80910:     if (!frame->IsVisibleConsideringAncestors(nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY) ||
 80910:         !frame->PresContext()->PresShell()->IsActive()) {
 69702:       return nsnull;
 69702:     }
 80910:   }
 69702: 
 69702:   for (nsIView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
 69702:     nsIView* r = FindViewContaining(v, v->ConvertFromParentCoords(aPt));
 69702:     if (r)
 69702:       return r;
 69702:   }
 69702: 
 69702:   return aView;
 69702: }
 69702: 
 69702: void
 79445: PresShell::ProcessSynthMouseMoveEvent(bool aFromScroll)
 69702: {
 90547:   // If drag session has started, we shouldn't synthesize mousemove event.
 90547:   nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
 90547:   if (dragSession) {
 90881:     mSynthMouseMoveEvent.Forget();
 90547:     return;
 90547:   }
 90547: 
 69702:   // allow new event to be posted while handling this one only if the
 69702:   // source of the event is a scroll (to prevent infinite reflow loops)
 69702:   if (aFromScroll) {
 69702:     mSynthMouseMoveEvent.Forget();
 69702:   }
 69702: 
 69702:   nsIView* rootView = mViewManager ? mViewManager->GetRootView() : nsnull;
 69702:   if (mMouseLocation == nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) ||
 69702:       !rootView || !rootView->HasWidget() || !mPresContext) {
 69702:     mSynthMouseMoveEvent.Forget();
 69702:     return;
 69702:   }
 69702: 
 69702:   NS_ASSERTION(mPresContext->IsRoot(), "Only a root pres shell should be here");
 69702: 
 69702:   // Hold a ref to ourselves so DispatchEvent won't destroy us (since
 69702:   // we need to access members after we call DispatchEvent).
 69702:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 69702:   
 69702: #ifdef DEBUG_MOUSE_LOCATION
 69702:   printf("[ps=%p]synthesizing mouse move to (%d,%d)\n",
 69702:          this, mMouseLocation.x, mMouseLocation.y);
 69702: #endif
 69702: 
 69702:   PRInt32 APD = mPresContext->AppUnitsPerDevPixel();
 69702: 
 69702:   // We need a widget to put in the event we are going to dispatch so we look
 69702:   // for a view that has a widget and the mouse location is over. We first look
 69702:   // for floating views, if there isn't one we use the root view. |view| holds
 69702:   // that view.
 69702:   nsIView* view = nsnull;
 69702: 
 69702:   // The appunits per devpixel ratio of |view|.
 69702:   PRInt32 viewAPD;
 69702: 
 69702:   // refPoint will be mMouseLocation relative to the widget of |view|, the
 69702:   // widget we will put in the event we dispatch, in viewAPD appunits
 69702:   nsPoint refpoint(0, 0);
 69702: 
 69702:   // We always dispatch the event to the pres shell that contains the view that
 69702:   // the mouse is over. pointVM is the VM of that pres shell.
 69702:   nsIViewManager *pointVM = nsnull;
 69702: 
 69702:   // This could be a bit slow (traverses entire view hierarchy)
 69702:   // but it's OK to do it once per synthetic mouse event
 69702:   view = FindFloatingViewContaining(rootView, mMouseLocation);
 69702:   if (!view) {
 69702:     view = rootView;
 69702:     nsIView *pointView = FindViewContaining(rootView, mMouseLocation);
 69702:     // pointView can be null in situations related to mouse capture
 69702:     pointVM = (pointView ? pointView : view)->GetViewManager();
 69702:     refpoint = mMouseLocation + rootView->ViewToWidgetOffset();
 69702:     viewAPD = APD;
 69702:   } else {
 69702:     pointVM = view->GetViewManager();
 82566:     nsIFrame* frame = view->GetFrame();
 69702:     NS_ASSERTION(frame, "floating views can't be anonymous");
 69702:     viewAPD = frame->PresContext()->AppUnitsPerDevPixel();
 69702:     refpoint = mMouseLocation.ConvertAppUnits(APD, viewAPD);
 69702:     refpoint -= view->GetOffsetTo(rootView);
 69702:     refpoint += view->ViewToWidgetOffset();
 69702:   }
 69702:   NS_ASSERTION(view->GetWidget(), "view should have a widget here");
 80486:   nsMouseEvent event(true, NS_MOUSE_MOVE, view->GetWidget(),
 69702:                      nsMouseEvent::eSynthesized);
 69702:   event.refPoint = refpoint.ToNearestPixels(viewAPD);
 69702:   event.time = PR_IntervalNow();
 96893:   // XXX set event.modifiers ?
 96887:   // XXX mnakano I think that we should get the latest information from widget.
 69702: 
 82568:   nsCOMPtr<nsIPresShell> shell = pointVM->GetPresShell();
 82568:   if (shell) {
 82568:     shell->DispatchSynthMouseMove(&event, !aFromScroll);
 69702:   }
 69702: 
 69702:   if (!aFromScroll) {
 69702:     mSynthMouseMoveEvent.Forget();
 52492:   }
 52492: }
 52492: 
 90410: class nsAutoNotifyDidPaint
 90410: {
 90410: public:
 90410:   nsAutoNotifyDidPaint(bool aWillSendDidPaint)
 90410:     : mWillSendDidPaint(aWillSendDidPaint)
 90410:   {
 90410:   }
 90410:   ~nsAutoNotifyDidPaint()
 90410:   {
 90410:     if (!mWillSendDidPaint && nsContentUtils::XPConnect()) {
 90410:       nsContentUtils::XPConnect()->NotifyDidPaint();
 90410:     }
 90410:   }
 90410: 
 90410: private:
 90410:   bool mWillSendDidPaint;
 90410: };
 90410: 
 82568: void
 67811: PresShell::Paint(nsIView*           aViewToPaint,
103532:                  nsIWidget*         aWidgetToPaint,
 38805:                  const nsRegion&    aDirtyRegion,
103532:                  const nsIntRegion& aIntDirtyRegion,
 79445:                  bool               aWillSendDidPaint)
 38805: {
 42480: #ifdef NS_FUNCTION_TIMER
 42480:   NS_TIME_FUNCTION_DECLARE_DOCURL;
 42480:   const nsRect& bounds__ = aDirtyRegion.GetBounds();
 42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (document: %s, dirty rect: (<%f, %f>, <%f, %f>)",
 42480:                            MOZ_FUNCTION_NAME, __LINE__, docURL__.get(),
 42480:                            NSCoordToFloat(bounds__.x),
 42480:                            NSCoordToFloat(bounds__.y),
 42480:                            NSCoordToFloat(bounds__.XMost()),
 42480:                            NSCoordToFloat(bounds__.YMost()));
 42480: #endif
 42480: 
 84290:   SAMPLE_LABEL("Paint", "PresShell::Paint");
 27834:   NS_ASSERTION(!mIsDestroying, "painting a destroyed PresShell");
 38805:   NS_ASSERTION(aViewToPaint, "null view");
103532:   NS_ASSERTION(aWidgetToPaint, "Can't paint without a widget");
 38805: 
 90410:   nsAutoNotifyDidPaint notifyDidPaint(aWillSendDidPaint);
 90410: 
 60645:   nsPresContext* presContext = GetPresContext();
 60645:   AUTO_LAYOUT_PHASE_ENTRY_POINT(presContext, Paint);
 60645: 
 88468:   nsIFrame* frame = aViewToPaint->GetFrame();
 38805: 
 61835:   bool isRetainingManager;
 61835:   LayerManager* layerManager =
103532:     aWidgetToPaint->GetLayerManager(&isRetainingManager);
 59684:   NS_ASSERTION(layerManager, "Must be in paint event");
 93058: 
 93058:   if (mIsFirstPaint) {
 93058:     layerManager->SetIsFirstPaint();
 93058:     mIsFirstPaint = false;
 93058:   }
103532:   layerManager->BeginTransaction();
 59684: 
 61835:   if (frame && isRetainingManager) {
 61835:     // Try to do an empty transaction, if the frame tree does not
 61835:     // need to be updated. Do not try to do an empty transaction on
 61835:     // a non-retained layer manager (like the BasicLayerManager that
 61835:     // draws the window title bar on Mac), because a) it won't work
103528:     // and b) below we don't want to clear NS_FRAME_UPDATE_LAYER_TREE,
 61835:     // that will cause us to forget to update the real layer manager!
103532:     if (!(frame->GetStateBits() & NS_FRAME_UPDATE_LAYER_TREE)) {
103532:       if (layerManager->EndEmptyTransaction()) {
103532:         frame->UpdatePaintCountForPaintedPresShells();
103532:         presContext->NotifyDidPaintForSubtree();
103293:         return;
103293:       }
101657:     }
101681: 
103528:     frame->RemoveStateBits(NS_FRAME_UPDATE_LAYER_TREE);
 61835:   }
 61835:   if (frame) {
 61717:     frame->ClearPresShellsFromLastPaint();
 59684:   }
 59684: 
 67811:   nscolor bgcolor = ComputeBackstopColor(aViewToPaint);
 67811: 
 67811:   if (frame) {
 47735:     // Defer invalidates that are triggered during painting, and discard
 47735:     // invalidates of areas that are already being repainted.
 47735:     // The layer system can trigger invalidates during painting
 47735:     // (see FrameLayerBuilder).
 47735:     frame->BeginDeferringInvalidatesForDisplayRoot(aDirtyRegion);
 47735: 
 38805:     // We can paint directly into the widget using its layer manager.
103532:     nsLayoutUtils::PaintFrame(nsnull, frame, aDirtyRegion, bgcolor,
103532:                               nsLayoutUtils::PAINT_WIDGET_LAYERS |
103532:                               nsLayoutUtils::PAINT_EXISTING_TRANSACTION);
 47735: 
 47735:     frame->EndDeferringInvalidatesForDisplayRoot();
 60645:     presContext->NotifyDidPaintForSubtree();
 82568:     return;
 38805:   }
 38805: 
 77096:   nsRefPtr<ColorLayer> root = layerManager->CreateColorLayer();
 38805:   if (root) {
 77096:     nsPresContext* pc = GetPresContext();
 77096:     nsIntRect bounds =
 77096:       pc->GetVisibleArea().ToOutsidePixels(pc->AppUnitsPerDevPixel());
 77096:     bgcolor = NS_ComposeColors(bgcolor, mCanvasBackgroundColor);
 77096:     root->SetColor(bgcolor);
 77096:     root->SetVisibleRegion(bounds);
 38805:     layerManager->SetRoot(root);
 38805:   }
103532:   layerManager->EndTransaction(NULL, NULL);
103532: 
 60645:   presContext->NotifyDidPaintForSubtree();
     1: }
     1: 
 32435: // static
 32435: void
 32435: nsIPresShell::SetCapturingContent(nsIContent* aContent, PRUint8 aFlags)
 32435: {
 95203:   // If capture was set for pointer lock, don't unlock unless we are coming
 95203:   // out of pointer lock explicitly.
 95203:   if (!aContent && gCaptureInfo.mPointerLock &&
 95203:       !(aFlags & CAPTURE_POINTERLOCK)) {
 95203:     return;
 95203:   }
 95203: 
 32435:   NS_IF_RELEASE(gCaptureInfo.mContent);
 32435: 
 95203:   // only set capturing content if allowed or the CAPTURE_IGNOREALLOWED or
 95203:   // CAPTURE_POINTERLOCK flags are used.
 95203:   if ((aFlags & CAPTURE_IGNOREALLOWED) || gCaptureInfo.mAllowed ||
 95203:       (aFlags & CAPTURE_POINTERLOCK)) {
 32435:     if (aContent) {
 32435:       NS_ADDREF(gCaptureInfo.mContent = aContent);
 32435:     }
 95203:     // CAPTURE_POINTERLOCK is the same as CAPTURE_RETARGETTOELEMENT & CAPTURE_IGNOREALLOWED
 95203:     gCaptureInfo.mRetargetToElement = ((aFlags & CAPTURE_RETARGETTOELEMENT) != 0) ||
 95203:                                       ((aFlags & CAPTURE_POINTERLOCK) != 0);
 37876:     gCaptureInfo.mPreventDrag = (aFlags & CAPTURE_PREVENTDRAG) != 0;
 95203:     gCaptureInfo.mPointerLock = (aFlags & CAPTURE_POINTERLOCK) != 0;
 32435:   }
 32435: }
 32435: 
     1: nsIFrame*
     1: PresShell::GetCurrentEventFrame()
     1: {
 22472:   if (NS_UNLIKELY(mIsDestroying)) {
 22472:     return nsnull;
 22472:   }
 22472:     
     1:   if (!mCurrentEventFrame && mCurrentEventContent) {
     1:     // Make sure the content still has a document reference. If not,
     1:     // then we assume it is no longer in the content tree and the
     1:     // frame shouldn't get an event, nor should we even assume its
     1:     // safe to try and find the frame.
     1:     if (mCurrentEventContent->GetDocument()) {
 36656:       mCurrentEventFrame = mCurrentEventContent->GetPrimaryFrame();
     1:     }
     1:   }
     1: 
     1:   return mCurrentEventFrame;
     1: }
     1: 
 40047: nsIFrame*
 40047: PresShell::GetEventTargetFrame()
 40047: {
 40047:   return GetCurrentEventFrame();
 40047: }
 40047: 
 40047: already_AddRefed<nsIContent>
 40047: PresShell::GetEventTargetContent(nsEvent* aEvent)
 40047: {
 40047:   nsIContent* content = nsnull;
 40047: 
     1:   if (mCurrentEventContent) {
 40047:     content = mCurrentEventContent;
 40047:     NS_IF_ADDREF(content);
     1:   } else {
     1:     nsIFrame* currentEventFrame = GetCurrentEventFrame();
     1:     if (currentEventFrame) {
 79435:       currentEventFrame->GetContentForEvent(aEvent, &content);
     1:     } else {
 40047:       content = nsnull;
 40047:     }
 40047:   }
 40047:   return content;
     1: }
     1: 
     1: void
     1: PresShell::PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent)
     1: {
     1:   if (mCurrentEventFrame || mCurrentEventContent) {
 24551:     mCurrentEventFrameStack.InsertElementAt(0, mCurrentEventFrame);
     1:     mCurrentEventContentStack.InsertObjectAt(mCurrentEventContent, 0);
     1:   }
     1:   mCurrentEventFrame = aFrame;
     1:   mCurrentEventContent = aContent;
     1: }
     1: 
     1: void
     1: PresShell::PopCurrentEventInfo()
     1: {
     1:   mCurrentEventFrame = nsnull;
     1:   mCurrentEventContent = nsnull;
     1: 
 24551:   if (0 != mCurrentEventFrameStack.Length()) {
 24551:     mCurrentEventFrame = mCurrentEventFrameStack.ElementAt(0);
     1:     mCurrentEventFrameStack.RemoveElementAt(0);
     1:     mCurrentEventContent = mCurrentEventContentStack.ObjectAt(0);
     1:     mCurrentEventContentStack.RemoveObjectAt(0);
     1:   }
     1: }
     1: 
 79445: bool PresShell::InZombieDocument(nsIContent *aContent)
     1: {
     1:   // If a content node points to a null document, or the document is not
     1:   // attached to a window, then it is possibly in a zombie document,
     1:   // about to be replaced by a newly loading document.
     1:   // Such documents cannot handle DOM events.
     1:   // It might actually be in a node not attached to any document,
     1:   // in which case there is not parent presshell to retarget it to.
     1:   nsIDocument *doc = aContent->GetDocument();
     1:   return !doc || !doc->GetWindow();
     1: }
     1: 
 47198: already_AddRefed<nsPIDOMWindow>
 47198: PresShell::GetRootWindow()
 47198: {
 47198:   nsCOMPtr<nsPIDOMWindow> window =
 47198:     do_QueryInterface(mDocument->GetWindow());
 47198:   if (window) {
 47198:     nsCOMPtr<nsPIDOMWindow> rootWindow = window->GetPrivateRoot();
 47198:     NS_ASSERTION(rootWindow, "nsPIDOMWindow::GetPrivateRoot() returns NULL");
 47198:     return rootWindow.forget();
 47198:   }
 47198: 
 47198:   // If we don't have DOM window, we're zombie, we should find the root window
 47198:   // with our parent shell.
 47198:   nsCOMPtr<nsIPresShell> parent = GetParentPresShell();
 47198:   NS_ENSURE_TRUE(parent, nsnull);
 47198:   return parent->GetRootWindow();
 47198: }
 47198: 
 47198: already_AddRefed<nsIPresShell>
 47198: PresShell::GetParentPresShell()
 47198: {
 47198:   NS_ENSURE_TRUE(mPresContext, nsnull);
 47198:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
 47198:   if (!container) {
 47198:     container = do_QueryReferent(mForwardingContainer);
 47198:   }
 47198: 
 47198:   // Now, find the parent pres shell and send the event there
 47198:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(container);
 47198:   // Might have gone away, or never been around to start with
 47198:   NS_ENSURE_TRUE(treeItem, nsnull);
 47198: 
 47198:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
 47198:   treeItem->GetParent(getter_AddRefs(parentTreeItem));
 47198:   nsCOMPtr<nsIDocShell> parentDocShell = do_QueryInterface(parentTreeItem);
 47198:   NS_ENSURE_TRUE(parentDocShell && treeItem != parentTreeItem, nsnull);
 47198: 
 47198:   nsIPresShell* parentPresShell = nsnull;
 47198:   parentDocShell->GetPresShell(&parentPresShell);
 47198:   return parentPresShell;
 47198: }
 47198: 
 47198: nsresult
 47198: PresShell::RetargetEventToParent(nsGUIEvent*     aEvent,
     1:                                  nsEventStatus*  aEventStatus)
     1: {
     1:   // Send this events straight up to the parent pres shell.
     1:   // We do this for keystroke events in zombie documents or if either a frame
     1:   // or a root content is not present.
     1:   // That way at least the UI key bindings can work.
     1: 
     1:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 47198:   nsCOMPtr<nsIPresShell> parentPresShell = GetParentPresShell();
 47198:   NS_ENSURE_TRUE(parentPresShell, NS_ERROR_FAILURE);
     1: 
 82566:   // Fake the event as though it's from the parent pres shell's root frame.
 82568:   return parentPresShell->HandleEvent(parentPresShell->GetRootFrame(), aEvent, true, aEventStatus);
     1: }
     1: 
 40052: void
 79445: PresShell::DisableNonTestMouseEvents(bool aDisable)
 24947: {
 24947:   sDisableNonTestMouseEvents = aDisable;
 24947: }
 24947: 
 36337: already_AddRefed<nsPIDOMWindow>
 36337: PresShell::GetFocusedDOMWindowInOurWindow()
 36337: {
 47198:   nsCOMPtr<nsPIDOMWindow> rootWindow = GetRootWindow();
 36337:   NS_ENSURE_TRUE(rootWindow, nsnull);
 36337:   nsPIDOMWindow* focusedWindow;
 80486:   nsFocusManager::GetFocusedDescendant(rootWindow, true, &focusedWindow);
 36337:   return focusedWindow;
 36337: }
 36337: 
 69702: void
 69702: PresShell::RecordMouseLocation(nsGUIEvent* aEvent)
 69702: {
 69702:   if (!mPresContext)
 69702:     return;
 69702: 
 69702:   if (!mPresContext->IsRoot()) {
 69702:     PresShell* rootPresShell = GetRootPresShell();
 69702:     if (rootPresShell) {
 69702:       rootPresShell->RecordMouseLocation(aEvent);
 69702:     }
 69702:     return;
 69702:   }
 69702: 
 69702:   if ((aEvent->message == NS_MOUSE_MOVE &&
 69702:        static_cast<nsMouseEvent*>(aEvent)->reason == nsMouseEvent::eReal) ||
 69702:       aEvent->message == NS_MOUSE_ENTER ||
 69702:       aEvent->message == NS_MOUSE_BUTTON_DOWN ||
 69702:       aEvent->message == NS_MOUSE_BUTTON_UP) {
 69702:     nsIFrame* rootFrame = GetRootFrame();
 69702:     if (!rootFrame) {
 69702:       nsIView* rootView = mViewManager->GetRootView();
 69702:       mMouseLocation = nsLayoutUtils::TranslateWidgetToView(mPresContext,
 69702:         aEvent->widget, aEvent->refPoint, rootView);
 69702:     } else {
 69702:       mMouseLocation =
 69702:         nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, rootFrame);
 69702:     }
 69702: #ifdef DEBUG_MOUSE_LOCATION
 69702:     if (aEvent->message == NS_MOUSE_ENTER)
 69702:       printf("[ps=%p]got mouse enter for %p\n",
 69702:              this, aEvent->widget);
 69702:     printf("[ps=%p]setting mouse location to (%d,%d)\n",
 69702:            this, mMouseLocation.x, mMouseLocation.y);
 69702: #endif
 69702:     if (aEvent->message == NS_MOUSE_ENTER)
 80486:       SynthesizeMouseMove(false);
 69702:   } else if (aEvent->message == NS_MOUSE_EXIT) {
 69702:     // Although we only care about the mouse moving into an area for which this
 69702:     // pres shell doesn't receive mouse move events, we don't check which widget
 69702:     // the mouse exit was for since this seems to vary by platform.  Hopefully
 69702:     // this won't matter at all since we'll get the mouse move or enter after
 69702:     // the mouse exit when the mouse moves from one of our widgets into another.
 69702:     mMouseLocation = nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 69702: #ifdef DEBUG_MOUSE_LOCATION
 69702:     printf("[ps=%p]got mouse exit for %p\n",
 69702:            this, aEvent->widget);
 69702:     printf("[ps=%p]clearing mouse location\n",
 69702:            this);
 69702: #endif
 69702:   }
 69702: }
 69702: 
 87650: static void
 87650: EvictTouchPoint(nsCOMPtr<nsIDOMTouch>& aTouch)
 87650: {
 87650:   nsIWidget *widget = nsnull;
 87650:   // is there an easier/better way to dig out the widget?
 87650:   nsCOMPtr<nsINode> node(do_QueryInterface(aTouch->GetTarget()));
 87650:   if (!node) {
 87650:     return;
 87650:   }
 87650:   nsIDocument* doc = node->GetCurrentDoc();
 87650:   if (!doc) {
 87650:     return;
 87650:   }
 87650:   nsIPresShell *presShell = doc->GetShell();
 87650:   if (!presShell) {
 87650:     return;
 87650:   }
 87650:   nsIFrame* frame = presShell->GetRootFrame();
 87650:   if (!frame) {
 87650:     return;
 87650:   }
105850:   nsPoint pt(aTouch->mRefPoint.x, aTouch->mRefPoint.y);
105850:   widget = frame->GetView()->GetNearestWidget(&pt);
105850: 
 87650:   if (!widget) {
 87650:     return;
 87650:   }
105850:   
 87650:   nsTouchEvent event(true, NS_TOUCH_END, widget);
 87650:   event.widget = widget;
 87650:   event.time = PR_IntervalNow();
 87650:   event.touches.AppendElement(aTouch);
 87650: 
 87650:   nsEventStatus status;
 87650:   widget->DispatchEvent(&event, status);
 87650: }
 87650: 
 87650: static PLDHashOperator
 87650: AppendToTouchList(const PRUint32& aKey, nsCOMPtr<nsIDOMTouch>& aData, void *aTouchList)
 87650: {
 87650:   nsTArray<nsCOMPtr<nsIDOMTouch> > *touches = static_cast<nsTArray<nsCOMPtr<nsIDOMTouch> > *>(aTouchList);
 87650:   aData->mChanged = false;
 87650:   touches->AppendElement(aData);
 87650:   return PL_DHASH_NEXT;
 87650: }
 87650: 
 82568: nsresult
 82566: PresShell::HandleEvent(nsIFrame        *aFrame,
     1:                        nsGUIEvent*     aEvent,
 79445:                        bool            aDontRetargetEvents,
     1:                        nsEventStatus*  aEventStatus)
     1: {
 82566:   NS_ASSERTION(aFrame, "null frame");
     1: 
 54519:   if (mIsDestroying ||
 24947:       (sDisableNonTestMouseEvents && NS_IS_MOUSE_EVENT(aEvent) &&
 33400:        !(aEvent->flags & NS_EVENT_FLAG_SYNTHETIC_TEST_EVENT))) {
     1:     return NS_OK;
     1:   }
     1: 
 69702:   RecordMouseLocation(aEvent);
 69702: 
     1: #ifdef ACCESSIBILITY
     1:   if (aEvent->eventStructType == NS_ACCESSIBLE_EVENT) {
 54519:     NS_TIME_FUNCTION_MIN(1.0);
 54519: 
 13287:     // Accessibility events come through OS requests and not from scripts,
 13287:     // so it is safe to handle here
 82566:     return HandleEventInternal(aEvent, aEventStatus);
     1:   }
     1: #endif
 14479: 
 54519:   if (!nsContentUtils::IsSafeToRunScript())
 54519:     return NS_OK;
 54519: 
 54519:   NS_TIME_FUNCTION_MIN(1.0);
 54519: 
 33240:   nsIContent* capturingContent =
 95203:     NS_IS_MOUSE_EVENT(aEvent) || aEvent->eventStructType == NS_MOUSE_SCROLL_EVENT ?
 95203:       GetCapturingContent() : nsnull;
 33240: 
 32435:   nsCOMPtr<nsIDocument> retargetEventDoc;
 58209:   if (!aDontRetargetEvents) {
 43624:     // key and IME related events should not cross top level window boundary.
 43624:     // Basically, such input events should be fired only on focused widget.
 43624:     // However, some IMEs might need to clean up composition after focused
 43624:     // window is deactivated.  And also some tests on MozMill want to test key
 43624:     // handling on deactivated window because MozMill window can be activated
 43624:     // during tests.  So, there is no merit the events should be redirected to
 43624:     // active window.  So, the events should be handled on the last focused
 43624:     // content in the last focused DOM window in same top level window.
 43624:     // Note, if no DOM window has been focused yet, we can discard the events.
 32435:     if (NS_IsEventTargetedAtFocusedWindow(aEvent)) {
 43624:       nsCOMPtr<nsPIDOMWindow> window = GetFocusedDOMWindowInOurWindow();
 43624:       // No DOM window in same top level window has not been focused yet,
 43624:       // discard the events.
 43624:       if (!window) {
 29018:         return NS_OK;
 43624:       }
 43624: 
 43624:       retargetEventDoc = do_QueryInterface(window->GetExtantDocument());
 32435:       if (!retargetEventDoc)
 29018:         return NS_OK;
 33240:     } else if (capturingContent) {
 32435:       // if the mouse is being captured then retarget the mouse event at the
 32435:       // document that is being captured.
 33240:       retargetEventDoc = capturingContent->GetCurrentDoc();
 97066: #ifdef ANDROID
 97066:     } else if (aEvent->eventStructType == NS_TOUCH_EVENT) {
 97066:       retargetEventDoc = GetTouchEventTargetDocument();
 97066: #endif
 32435:     }
 32435: 
 32435:     if (retargetEventDoc) {
 82568:       nsCOMPtr<nsIPresShell> presShell = retargetEventDoc->GetShell();
 29018:       if (!presShell)
 29018:         return NS_OK;
 29018: 
 29018:       if (presShell != this) {
 86273:         nsIFrame* frame = presShell->GetRootFrame();
 86273:         if (!frame) {
 86273:           if (aEvent->message == NS_QUERY_TEXT_CONTENT ||
 86273:               NS_IS_CONTENT_COMMAND_EVENT(aEvent)) {
 86273:             return NS_OK;
 86273:           }
 86273: 
 86273:           nsIView* view = presShell->GetViewManager()->GetRootView();
 86273:           while (view && !view->GetFrame()) {
 86273:             view = view->GetParent();
 86273:           }
 86273: 
 86273:           if (view) {
 86273:             frame = view->GetFrame();
 86273:           }
 86273:         }
 86273: 
 86273:         if (!frame)
 86273:           return NS_OK;
 86273: 
 86273:         nsCOMPtr<nsIPresShell> shell = frame->PresContext()->GetPresShell();
 86273:         return shell->HandleEvent(frame, aEvent, true, aEventStatus);
 29018:       }
 29018:     }
 32435:   }
 29018: 
     1:   // Check for a theme change up front, since the frame type is irrelevant
     1:   if (aEvent->message == NS_THEMECHANGED && mPresContext) {
     1:     mPresContext->ThemeChanged();
     1:     return NS_OK;
     1:   }
     1: 
 41071:   if (aEvent->message == NS_UISTATECHANGED && mDocument) {
 41071:     nsPIDOMWindow* win = mDocument->GetWindow();
 41071:     if (win) {
 41071:       nsUIStateChangeEvent* event = (nsUIStateChangeEvent*)aEvent;
 41071:       win->SetKeyboardIndicators(event->showAccelerators, event->showFocusRings);
 41071:     }
 41071:     return NS_OK;
 41071:   }
 41071: 
     1:   // Check for a system color change up front, since the frame type is
     1:   // irrelevant
 82566:   if ((aEvent->message == NS_SYSCOLORCHANGED) && mPresContext &&
 89328:       aFrame == mFrameConstructor->GetRootFrame()) {
     1:     *aEventStatus = nsEventStatus_eConsumeDoDefault;
     1:     mPresContext->SysColorChanged();
     1:     return NS_OK;
     1:   }
     1: 
 38961:   if (aEvent->eventStructType == NS_KEY_EVENT &&
 38961:       mDocument && mDocument->EventHandlingSuppressed()) {
 28498:     if (aEvent->message == NS_KEY_DOWN) {
 80486:       mNoDelayedKeyEvents = true;
 28498:     } else if (!mNoDelayedKeyEvents) {
 38961:       nsDelayedEvent* event =
 38961:         new nsDelayedKeyEvent(static_cast<nsKeyEvent*>(aEvent));
 72510:       if (!mDelayedEvents.AppendElement(event)) {
 28498:         delete event;
 28498:       }
 38961:     }
 25722:     return NS_OK;
 25722:   }
 25722: 
 82566:   nsIFrame* frame = aFrame;
 79445:   bool dispatchUsingCoordinates = NS_IsEventUsingCoordinates(aEvent);
     1:   if (dispatchUsingCoordinates) {
 27619:     NS_WARN_IF_FALSE(frame, "Nothing to handle this event!");
     1:     if (!frame)
     1:       return NS_OK;
     1: 
   238:     nsPresContext* framePresContext = frame->PresContext();
 37502:     nsPresContext* rootPresContext = framePresContext->GetRootPresContext();
 37502:     NS_ASSERTION(rootPresContext == mPresContext->GetRootPresContext(),
     1:                  "How did we end up outside the connected prescontext/viewmanager hierarchy?"); 
     1:     // If we aren't starting our event dispatch from the root frame of the root prescontext,
     1:     // then someone must be capturing the mouse. In that case we don't want to search the popup
     1:     // list.
     1:     if (framePresContext == rootPresContext &&
 89328:         frame == mFrameConstructor->GetRootFrame()) {
 39629:       nsIFrame* popupFrame =
 48255:         nsLayoutUtils::GetPopupFrameForEventCoordinates(rootPresContext, aEvent);
 39629:       // If the popupFrame is an ancestor of the 'frame', the frame should
 39629:       // handle the event, otherwise, the popup should handle it.
 39629:       if (popupFrame &&
 37138:           !nsContentUtils::ContentIsCrossDocDescendantOf(
 39629:              framePresContext->GetPresShell()->GetDocument(),
 39629:              popupFrame->GetContent())) {
 39629:         frame = popupFrame;
 39629:       }
  3516:     }
     1: 
 79445:     bool captureRetarget = false;
 33240:     if (capturingContent) {
 38335:       // If a capture is active, determine if the docshell is visible. If not,
 38335:       // clear the capture and target the mouse event normally instead. This
 38335:       // would occur if the mouse button is held down while a tab change occurs.
 38335:       // If the docshell is visible, look for a scrolling container.
 79445:       bool vis;
 38335:       nsCOMPtr<nsISupports> supports = mPresContext->GetContainer();
 38335:       nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(supports));
 38335:       if (baseWin && NS_SUCCEEDED(baseWin->GetVisibility(&vis)) && vis) {
 33240:         captureRetarget = gCaptureInfo.mRetargetToElement;
 33710:         if (!captureRetarget) {
 36656:           // A check was already done above to ensure that capturingContent is
 38335:           // in this presshell.
 36656:           NS_ASSERTION(capturingContent->GetCurrentDoc() == GetDocument(),
 36656:                        "Unexpected document");
 36656:           nsIFrame* captureFrame = capturingContent->GetPrimaryFrame();
 33710:           if (captureFrame) {
 33710:             if (capturingContent->Tag() == nsGkAtoms::select &&
 33329:                 capturingContent->IsHTML()) {
 33710:               // a dropdown <select> has a child in its selectPopupList and we should
 33710:               // capture on that instead.
 77154:               nsIFrame* childFrame = captureFrame->GetChildList(nsIFrame::kSelectPopupList).FirstChild();
 33710:               if (childFrame) {
 33710:                 captureFrame = childFrame;
 33710:               }
 33710:             }
 33710: 
 33710:             // scrollable frames should use the scrolling container as
 33710:             // the root instead of the document
 33710:             nsIScrollableFrame* scrollFrame = do_QueryFrame(captureFrame);
 33710:             if (scrollFrame) {
 33710:               frame = scrollFrame->GetScrolledFrame();
 33240:             }
 33240:           }
 33240:         }
 33240:       }
 38335:       else {
 38335:         ClearMouseCapture(nsnull);
 38335:         capturingContent = nsnull;
 38335:       }
 38335:     }
 33240: 
 95622:     // all touch events except for touchstart use a captured target
 95622:     if (aEvent->eventStructType == NS_TOUCH_EVENT &&
 95622:         aEvent->message != NS_TOUCH_START) {
 95622:       captureRetarget = true;
 95622:     }
 95622: 
 79445:     bool isWindowLevelMouseExit = (aEvent->message == NS_MOUSE_EXIT) &&
 69930:       (static_cast<nsMouseEvent*>(aEvent)->exit == nsMouseEvent::eTopLevel);
 69930: 
 33240:     // Get the frame at the event point. However, don't do this if we're
 33240:     // capturing and retargeting the event because the captured frame will
 69930:     // be used instead below. Also keep using the root frame if we're dealing
 69930:     // with a window-level mouse exit event since we want to start sending
 69930:     // mouse out events at the root EventStateManager.
 69930:     if (!captureRetarget && !isWindowLevelMouseExit) {
 87650:       nsPoint eventPoint;
 87650:       if (aEvent->message == NS_TOUCH_START) {
 87650:         // Add any new touches to the queue
 87650:         nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
 87650:         // if there is only one touch in this touchstart event, assume that it is
 87650:         // the start of a new touch session and evict any old touches in the
 87650:         // queue
 87650:         if (touchEvent->touches.Length() == 1) {
 87650:           nsTArray<nsCOMPtr<nsIDOMTouch> > touches;
 87650:           gCaptureTouchList.Enumerate(&AppendToTouchList, (void *)&touches);
 87650:           for (PRUint32 i = 0; i < touches.Length(); ++i) {
 87650:             EvictTouchPoint(touches[i]);
 87650:           }
 87650:         }
 87650:         for (PRUint32 i = 0; i < touchEvent->touches.Length(); ++i) {
 87650:           nsIDOMTouch *touch = touchEvent->touches[i];
 87650:           nsDOMTouch *domtouch = static_cast<nsDOMTouch*>(touch);
 87650:           touch->mMessage = aEvent->message;
 87650: 
 87650:           PRInt32 id = 0;
 87650:           touch->GetIdentifier(&id);
 87650:           if (!gCaptureTouchList.Get(id, nsnull)) {
 87650:             // This event is a new touch. Mark it as a changedTouch and
 87650:             // add it to the queue.
 87650:             touch->mChanged = true;
 87650:             gCaptureTouchList.Put(id, touch);
 87650: 
 87650:             eventPoint = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, touch->mRefPoint, frame);
 87650:           } else {
 87650:             // This touch is an old touch, we need to ensure that is not
 87650:             // marked as changed and set its target correctly
 87650:             touch->mChanged = false;
 87650:             PRInt32 id;
 87650:             touch->GetIdentifier(&id);
 87650: 
 87650:             nsCOMPtr<nsIDOMTouch> oldTouch;
 87650:             gCaptureTouchList.Get(id, getter_AddRefs(oldTouch));
 87650:             if (oldTouch) {
 87650:               nsCOMPtr<nsPIDOMEventTarget> targetPtr;
 87650:               oldTouch->GetTarget(getter_AddRefs(targetPtr));
 87650:               domtouch->SetTarget(targetPtr);
 87650:               gCaptureTouchList.Put(id, touch);
 87650:             }
 87650:           }
 87650:         }
 87650:       } else {
 87650:         eventPoint = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
 87650:       }
 11016:       {
 79445:         bool ignoreRootScrollFrame = false;
 20863:         if (aEvent->eventStructType == NS_MOUSE_EVENT) {
 22095:           ignoreRootScrollFrame = static_cast<nsMouseEvent*>(aEvent)->ignoreRootScrollFrame;
 20863:         }
 38961:         nsIFrame* target = nsLayoutUtils::GetFrameForPoint(frame, eventPoint,
 80486:                                                            false, ignoreRootScrollFrame);
 38961:         if (target) {
 38961:           frame = target;
 38961:         }
 11016:       }
 32435:     }
 11016: 
 33240:     // if a node is capturing the mouse, check if the event needs to be
 33240:     // retargeted at the capturing content instead. This will be the case when
 33240:     // capture retargeting is being used, no frame was found or the frame's
 33240:     // content is not a descendant of the capturing content.
 33240:     if (capturingContent &&
 38961:         (gCaptureInfo.mRetargetToElement || !frame->GetContent() ||
 38961:          !nsContentUtils::ContentIsCrossDocDescendantOf(frame->GetContent(),
 33240:                                                         capturingContent))) {
 33240:       // A check was already done above to ensure that capturingContent is
 38335:       // in this presshell.
 36656:       NS_ASSERTION(capturingContent->GetCurrentDoc() == GetDocument(),
 36656:                    "Unexpected document");
 36656:       nsIFrame* capturingFrame = capturingContent->GetPrimaryFrame();
 33240:       if (capturingFrame) {
 38961:         frame = capturingFrame;
 38961:       }
 38961:     }
 38961: 
 38961:     // Suppress mouse event if it's being targeted at an element inside
 38961:     // a document which needs events suppressed
 38961:     if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 38961:         frame->PresContext()->Document()->EventHandlingSuppressed()) {
 38961:       if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
 80486:         mNoDelayedMouseEvents = true;
 38961:       } else if (!mNoDelayedMouseEvents && aEvent->message == NS_MOUSE_BUTTON_UP) {
 38961:         nsDelayedEvent* event =
 38961:           new nsDelayedMouseEvent(static_cast<nsMouseEvent*>(aEvent));
 38961:         if (!mDelayedEvents.AppendElement(event)) {
 38961:           delete event;
 38961:         }
 38961:       }
 38961: 
 38961:       return NS_OK;
 38961:     }
 38961: 
     1:     PresShell* shell =
 38961:         static_cast<PresShell*>(frame->PresContext()->PresShell());
 56077: 
104398:     switch (aEvent->message) {
104398:       case NS_TOUCH_MOVE:
104398:       case NS_TOUCH_CANCEL:
104398:       case NS_TOUCH_END: {
104398:         // Remove the changed touches
104398:         // need to make sure we only remove touches that are ending here
104398:         nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
104398:         nsTArray<nsCOMPtr<nsIDOMTouch> >  &touches = touchEvent->touches;
104398:         for (PRUint32 i = 0; i < touches.Length(); ++i) {
104398:           nsIDOMTouch *touch = touches[i];
104398:           if (!touch) {
104398:             break;
104398:           }
104398:   
104398:           PRInt32 id;
104398:           touch->GetIdentifier(&id);
104398:           nsCOMPtr<nsIDOMTouch> oldTouch;
104398:           gCaptureTouchList.Get(id, getter_AddRefs(oldTouch));
104398:           if (!oldTouch) {
104398:             break;
104398:           }
104398:   
104398:           nsCOMPtr<nsPIDOMEventTarget> targetPtr;
104398:           oldTouch->GetTarget(getter_AddRefs(targetPtr));
104398:           nsCOMPtr<nsIContent> content = do_QueryInterface(targetPtr);
104398:           if (!content) {
104398:             break;
104398:           }
104398: 
104398:           nsIFrame* contentFrame = content->GetPrimaryFrame();
104398:           if (!contentFrame) {
104398:             break;
104398:           }
104398: 
104398:           shell = static_cast<PresShell*>(
104398:                       contentFrame->PresContext()->PresShell());
104398:         }
104398:         break;
104398:       }
104398:     }
104398: 
 56077:     // Check if we have an active EventStateManager which isn't the
 56077:     // EventStateManager of the current PresContext.
 56077:     // If that is the case, and mouse is over some ancestor document,
 56077:     // forward event handling to the active document.
 56077:     // This way content can get mouse events even when
 56077:     // mouse is over the chrome or outside the window.
 56077:     //
 56077:     // Note, currently for backwards compatibility we don't forward mouse events
 56077:     // to the active document when mouse is over some subdocument.
 68780:     nsEventStateManager* activeESM =
 56077:       nsEventStateManager::GetActiveEventStateManager();
 56077:     if (activeESM && NS_IS_MOUSE_EVENT(aEvent) &&
 56077:         activeESM != shell->GetPresContext()->EventStateManager() &&
 56077:         static_cast<nsEventStateManager*>(activeESM)->GetPresContext()) {
 56077:       nsIPresShell* activeShell =
 56077:         static_cast<nsEventStateManager*>(activeESM)->GetPresContext()->GetPresShell();
 56077:       if (activeShell &&
 56077:           nsContentUtils::ContentIsCrossDocDescendantOf(activeShell->GetDocument(),
 56077:                                                         shell->GetDocument())) {
 56077:         shell = static_cast<PresShell*>(activeShell);
 82566:         frame = shell->GetRootFrame();
 56077:       }
 56077:     }
 56077: 
     1:     if (shell != this) {
     1:       // Handle the event in the correct shell.
     1:       // Prevent deletion until we're done with event handling (bug 336582).
  2706:       nsCOMPtr<nsIPresShell> kungFuDeathGrip(shell);
 82566:       // We pass the subshell's root frame as the frame to start from. This is
     1:       // the only correct alternative; if the event was captured then it
     1:       // must have been captured by us or some ancestor shell and we
     1:       // now ask the subshell to dispatch it normally.
 82566:       return shell->HandlePositionedEvent(frame, aEvent, aEventStatus);
 82566:     }
 82566: 
 82566:     return HandlePositionedEvent(frame, aEvent, aEventStatus);
     1:   }
     1:   
     1:   nsresult rv = NS_OK;
     1:   
     1:   if (frame) {
     1:     PushCurrentEventInfo(nsnull, nsnull);
     1: 
 43624:     // key and IME related events go to the focused frame in this DOM window.
 43624:     if (NS_IsEventTargetedAtFocusedContent(aEvent)) {
 62899:       mCurrentEventContent = nsnull;
 62899: 
 43624:       nsCOMPtr<nsPIDOMWindow> window =
 43624:         do_QueryInterface(mDocument->GetWindow());
 29018:       nsCOMPtr<nsPIDOMWindow> focusedWindow;
 62899:       nsCOMPtr<nsIContent> eventTarget =
 80486:         nsFocusManager::GetFocusedDescendant(window, false,
 43624:                                              getter_AddRefs(focusedWindow));
 29018: 
 29018:       // otherwise, if there is no focused content or the focused content has
 29018:       // no frame, just use the root content. This ensures that key events
 29018:       // still get sent to the window properly if nothing is focused or if a
 29018:       // frame goes away while it is focused.
 62899:       if (!eventTarget || !eventTarget->GetPrimaryFrame()) {
 80835:         nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
 80835:         if (htmlDoc) {
 80835:           nsCOMPtr<nsIDOMHTMLElement> body;
 80835:           htmlDoc->GetBody(getter_AddRefs(body));
 80835:           eventTarget = do_QueryInterface(body);
 80835:           if (!eventTarget) {
 62899:             eventTarget = mDocument->GetRootElement();
 62899:           }
 80835:         } else {
 80835:           eventTarget = mDocument->GetRootElement();
 80835:         }
 80835:       }
 50720: 
 50720:       if (aEvent->message == NS_KEY_DOWN) {
 50720:         NS_IF_RELEASE(gKeyDownTarget);
 62899:         NS_IF_ADDREF(gKeyDownTarget = eventTarget);
 50720:       }
 50720:       else if ((aEvent->message == NS_KEY_PRESS || aEvent->message == NS_KEY_UP) &&
 50720:                gKeyDownTarget) {
 50720:         // If a different element is now focused for the keypress/keyup event
 50720:         // than what was focused during the keydown event, check if the new
 50720:         // focused element is not in a chrome document any more, and if so,
 50720:         // retarget the event back at the keydown target. This prevents a
 50720:         // content area from grabbing the focus from chrome in-between key
 50720:         // events.
 62899:         if (eventTarget &&
 61728:             nsContentUtils::IsChromeDoc(gKeyDownTarget->GetCurrentDoc()) !=
 62899:             nsContentUtils::IsChromeDoc(eventTarget->GetCurrentDoc())) {
 62899:           eventTarget = gKeyDownTarget;
 50720:         }
 50720: 
 50720:         if (aEvent->message == NS_KEY_UP) {
 50720:           NS_RELEASE(gKeyDownTarget);
 50720:         }
 50720:       }
 50720: 
 29018:       mCurrentEventFrame = nsnull;
 80526:       nsIDocument* targetDoc = eventTarget ? eventTarget->OwnerDoc() : nsnull;
 62899:       if (targetDoc && targetDoc != mDocument) {
 62899:         PopCurrentEventInfo();
 82568:         nsCOMPtr<nsIPresShell> shell = targetDoc->GetShell();
 82568:         if (shell) {
 82568:           rv = static_cast<PresShell*>(shell.get())->
 82568:             HandleRetargetedEvent(aEvent, aEventStatus, eventTarget);
 62899:         }
 62899:         return rv;
 62899:       } else {
 62899:         mCurrentEventContent = eventTarget;
 62899:       }
 29018:         
 37863:       if (!mCurrentEventContent || !GetCurrentEventFrame() ||
 37863:           InZombieDocument(mCurrentEventContent)) {
     1:         rv = RetargetEventToParent(aEvent, aEventStatus);
     1:         PopCurrentEventInfo();
     1:         return rv;
     1:       }
     1:     } else {
     1:       mCurrentEventFrame = frame;
     1:     }
     1:     if (GetCurrentEventFrame()) {
 82566:       rv = HandleEventInternal(aEvent, aEventStatus);
     1:     }
     1:   
102909: #ifdef DEBUG
     1:     ShowEventTargetDebug();
     1: #endif
     1:     PopCurrentEventInfo();
     1:   } else {
 33344:     // Activation events need to be dispatched even if no frame was found, since
 29018:     // we don't want the focus to be out of sync.
     1: 
     1:     if (!NS_EVENT_NEEDS_FRAME(aEvent)) {
     1:       mCurrentEventFrame = nsnull;
 82566:       return HandleEventInternal(aEvent, aEventStatus);
     1:     }
     1:     else if (NS_IS_KEY_EVENT(aEvent)) {
     1:       // Keypress events in new blank tabs should not be completely thrown away.
     1:       // Retarget them -- the parent chrome shell might make use of them.
     1:       return RetargetEventToParent(aEvent, aEventStatus);
     1:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
 97066: #ifdef ANDROID
 97066: nsIDocument*
 97066: PresShell::GetTouchEventTargetDocument()
 97066: {
 97066:   nsPresContext* context = GetPresContext();
 97066:   if (!context || !context->IsRoot()) {
 97066:     return nsnull;
 97066:   }
 97066: 
 97066:   nsCOMPtr<nsISupports> container = context->GetContainer();
 97066:   nsCOMPtr<nsIDocShellTreeItem> shellAsTreeItem = do_QueryInterface(container);
 97066:   if (!shellAsTreeItem) {
 97066:     return nsnull;
 97066:   }
 97066: 
 97066:   nsCOMPtr<nsIDocShellTreeOwner> owner;
 97066:   shellAsTreeItem->GetTreeOwner(getter_AddRefs(owner));
 97066:   if (!owner) {
 97066:     return nsnull;
 97066:   }
 97066: 
 97066:   // now get the primary content shell (active tab)
 97066:   nsCOMPtr<nsIDocShellTreeItem> item;
 97066:   owner->GetPrimaryContentShell(getter_AddRefs(item));
 97066:   nsCOMPtr<nsIDocShell> childDocShell = do_QueryInterface(item);
 97066:   nsCOMPtr<nsIDocument> result = do_GetInterface(childDocShell);
 97066:   return result;
 97066: }
 97066: #endif
 97066: 
102909: #ifdef DEBUG
     1: void
     1: PresShell::ShowEventTargetDebug()
     1: {
 31709:   if (nsFrame::GetShowEventTargetFrameBorder() &&
     1:       GetCurrentEventFrame()) {
     1:     if (mDrawEventTargetFrame) {
103530:       mDrawEventTargetFrame->Invalidate(
103530:           nsRect(nsPoint(0, 0), mDrawEventTargetFrame->GetSize()));
     1:     }
     1: 
     1:     mDrawEventTargetFrame = mCurrentEventFrame;
103530:     mDrawEventTargetFrame->Invalidate(
103530:         nsRect(nsPoint(0, 0), mDrawEventTargetFrame->GetSize()));
     1:   }
     1: }
     1: #endif
     1: 
     1: nsresult
 82566: PresShell::HandlePositionedEvent(nsIFrame*      aTargetFrame,
     1:                                  nsGUIEvent*    aEvent,
     1:                                  nsEventStatus* aEventStatus)
     1: {
     1:   nsresult rv = NS_OK;
     1:   
     1:   PushCurrentEventInfo(nsnull, nsnull);
     1:   
     1:   mCurrentEventFrame = aTargetFrame;
     1: 
     1:   if (mCurrentEventFrame) {
     1:     nsCOMPtr<nsIContent> targetElement;
 79435:     mCurrentEventFrame->GetContentForEvent(aEvent,
     1:                                            getter_AddRefs(targetElement));
     1: 
     1:     // If there is no content for this frame, target it anyway.  Some
     1:     // frames can be targeted but do not have content, particularly
     1:     // windows with scrolling off.
     1:     if (targetElement) {
     1:       // Bug 103055, bug 185889: mouse events apply to *elements*, not all
     1:       // nodes.  Thus we get the nearest element parent here.
     1:       // XXX we leave the frame the same even if we find an element
     1:       // parent, so that the text frame will receive the event (selection
     1:       // and friends are the ones who care about that anyway)
     1:       //
     1:       // We use weak pointers because during this tight loop, the node
     1:       // will *not* go away.  And this happens on every mousemove.
 41640:       while (targetElement && !targetElement->IsElement()) {
     1:         targetElement = targetElement->GetParent();
     1:       }
     1: 
     1:       // If we found an element, target it.  Otherwise, target *nothing*.
     1:       if (!targetElement) {
     1:         mCurrentEventContent = nsnull;
     1:         mCurrentEventFrame = nsnull;
     1:       } else if (targetElement != mCurrentEventContent) {
     1:         mCurrentEventContent = targetElement;
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (GetCurrentEventFrame()) {
 82566:     rv = HandleEventInternal(aEvent, aEventStatus);
     1:   }
     1: 
102909: #ifdef DEBUG
     1:   ShowEventTargetDebug();
     1: #endif
     1:   PopCurrentEventInfo();
     1:   return rv;
     1: }
     1: 
 40055: nsresult
     1: PresShell::HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
     1:                                  nsIContent* aContent, nsEventStatus* aStatus)
     1: {
     1:   PushCurrentEventInfo(aFrame, aContent);
 82566:   nsresult rv = HandleEventInternal(aEvent, aStatus);
     1:   PopCurrentEventInfo();
 40055:   return rv;
     1: }
     1: 
 79445: static inline bool
 39761: IsSynthesizedMouseEvent(nsEvent* aEvent)
     1: {
     1:   return aEvent->eventStructType == NS_MOUSE_EVENT &&
  3233:          static_cast<nsMouseEvent*>(aEvent)->reason != nsMouseEvent::eReal;
     1: }
     1: 
 79445: static bool CanHandleContextMenuEvent(nsMouseEvent* aMouseEvent,
 31431:                                         nsIFrame* aFrame)
 31431: {
 31431: #if defined(XP_MACOSX) && defined(MOZ_XUL)
 31431:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 31431:   if (pm) {
 31431:     nsIFrame* popupFrame = pm->GetTopPopup(ePopupTypeMenu);
 31431:     if (popupFrame) {
 31431:       // context menus should not be opened while another menu is open on Mac,
 31431:       // so return false so that the event is not fired.
 31431:       if (aMouseEvent->context == nsMouseEvent::eContextMenuKey) {
 80486:         return false;
 31431:       } else if (aMouseEvent->widget) {
 31431:          nsWindowType windowType;
 31431:          aMouseEvent->widget->GetWindowType(windowType);
 31431:          if (windowType == eWindowType_popup) {
 31431:            for (nsIFrame* current = aFrame; current;
 31431:                 current = nsLayoutUtils::GetCrossDocParentFrame(current)) {
 31431:              if (current->GetType() == nsGkAtoms::menuPopupFrame) {
 80486:                return false;
 31431:              }
 31431:            }
 31431:          }
 31431:       }
 31431:     }
 31431:   }
 31431: #endif
 80486:   return true;
 31431: }
 31431: 
     1: nsresult
 82566: PresShell::HandleEventInternal(nsEvent* aEvent, nsEventStatus* aStatus)
     1: {
 42480:   NS_TIME_FUNCTION_MIN(1.0);
 42480: 
     1: #ifdef ACCESSIBILITY
     1:   if (aEvent->eventStructType == NS_ACCESSIBLE_EVENT)
     1:   {
 42313:     nsAccessibleEvent *accEvent = static_cast<nsAccessibleEvent*>(aEvent);
 42313:     accEvent->mAccessible = nsnull;
 42313: 
     1:     nsCOMPtr<nsIAccessibilityService> accService =
     1:       do_GetService("@mozilla.org/accessibilityService;1");
     1:     if (accService) {
     1:       nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
     1:       if (!container) {
     1:         // This presshell is not active. This often happens when a
     1:         // preshell is being held onto for fastback.
     1:         return NS_OK;
     1:       }
 42313: 
 54519:       // Accessible creation might be not safe so we make sure it's not created
 54519:       // at unsafe times.
 54519:       accEvent->mAccessible =
 54519:         accService->GetRootDocumentAccessible(this, nsContentUtils::IsSafeToRunScript());
 42313: 
     1:       return NS_OK;
     1:     }
     1:   }
     1: #endif
     1: 
 68780:   nsRefPtr<nsEventStateManager> manager = mPresContext->EventStateManager();
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (!NS_EVENT_NEEDS_FRAME(aEvent) || GetCurrentEventFrame()) {
 87650:     bool touchIsNew = false;
 79445:     bool isHandlingUserInput = false;
     1: 
 69670:     // XXX How about IME events and input events for plugins?
     1:     if (NS_IS_TRUSTED_EVENT(aEvent)) {
     1:       switch (aEvent->message) {
     1:       case NS_KEY_PRESS:
     1:       case NS_KEY_DOWN:
 81145:       case NS_KEY_UP: {
 81145:         nsIDocument *doc = mCurrentEventContent ?
 81145:                            mCurrentEventContent->OwnerDoc() : nsnull;
 82213:         nsIDocument* root = nsnull;
 82213:         if (static_cast<const nsKeyEvent*>(aEvent)->keyCode == NS_VK_ESCAPE &&
 82213:             (root = nsContentUtils::GetRootDocument(doc)) &&
 82213:             root->IsFullScreenDoc()) {
 81145:           // Prevent default action on ESC key press when exiting
 81145:           // DOM full-screen mode. This prevents the browser ESC key
 81145:           // handler from stopping all loads in the document, which
 81145:           // would cause <video> loads to stop.
 81145:           aEvent->flags |= (NS_EVENT_FLAG_NO_DEFAULT |
 81145:                             NS_EVENT_FLAG_ONLY_CHROME_DISPATCH);
 81146: 
 81146:           if (aEvent->message == NS_KEY_UP) {
 81146:              // ESC key released while in DOM full-screen mode.
 81146:              // Exit full-screen mode.
 84109:             nsIDocument::ExitFullScreen(true);
 81146:           }
 81145:         }
 77849:         // Else not full-screen mode or key code is unrestricted, fall
 77849:         // through to normal handling.
 81145:       }
 77849:       case NS_MOUSE_BUTTON_DOWN:
 77849:       case NS_MOUSE_BUTTON_UP:
 80486:         isHandlingUserInput = true;
 34272:         break;
 87650:       case NS_TOUCH_CANCEL:
 87650:       case NS_TOUCH_END: {
 87650:         // Remove the changed touches
 87650:         // need to make sure we only remove touches that are ending here
 87650:         nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
 87650:         nsTArray<nsCOMPtr<nsIDOMTouch> >  &touches = touchEvent->touches;
 87650:         for (PRUint32 i = 0; i < touches.Length(); ++i) {
 87650:           nsIDOMTouch *touch = touches[i];
 87650:           nsDOMTouch *domtouch = static_cast<nsDOMTouch*>(touch);
 87650:           if (!touch) {
 87650:             continue;
 87650:           }
 87650:           touch->mMessage = aEvent->message;
 87650:           touch->mChanged = true;
 87650:           nsCOMPtr<nsIDOMTouch> oldTouch;
 87650: 
 87650:           PRInt32 id;
 87650:           touch->GetIdentifier(&id);
 87650: 
 87650:           gCaptureTouchList.Get(id, getter_AddRefs(oldTouch));
 87650:           if (!oldTouch) {
 87650:             continue;
 87650:           }
 87650:           nsCOMPtr<nsPIDOMEventTarget> targetPtr;
 87650:           oldTouch->GetTarget(getter_AddRefs(targetPtr));
 87650: 
 87650:           mCurrentEventContent = do_QueryInterface(targetPtr);
 87650:           domtouch->SetTarget(targetPtr);
 87650:           gCaptureTouchList.Remove(id);
 87650:         }
 87650:         // add any touches left in the touch list, but ensure changed=false
 87650:         gCaptureTouchList.Enumerate(&AppendToTouchList, (void *)&touches);
 87650:         break;
 87650:       }
 87650:       case NS_TOUCH_MOVE: {
 87650:         // Check for touches that changed. Mark them add to queue
 87650:         nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
 87650:         nsTArray<nsCOMPtr<nsIDOMTouch> > touches = touchEvent->touches;
 87650:         bool haveChanged = false;
 87650:         for (PRUint32 i = 0; i < touches.Length(); ++i) {
 87650:           nsIDOMTouch *touch = touches[i];
 87650:           nsDOMTouch *domtouch = static_cast<nsDOMTouch*>(touch);
 87650:           if (!touch) {
 87650:             continue;
 87650:           }
 87650:           PRInt32 id;
 87650:           touch->GetIdentifier(&id);
 87650:           touch->mMessage = aEvent->message;
 87650: 
 87650:           nsCOMPtr<nsIDOMTouch> oldTouch;
 87650:           gCaptureTouchList.Get(id, getter_AddRefs(oldTouch));
 87650:           if (!oldTouch) {
 87650:             continue;
 87650:           }
 87650:           if(domtouch->Equals(oldTouch)) {
 87650:             touch->mChanged = true;
 87650:             haveChanged = true;
 87650:           }
 87650: 
 87650:           nsCOMPtr<nsPIDOMEventTarget> targetPtr;
 87650:           oldTouch->GetTarget(getter_AddRefs(targetPtr));
 87650:           domtouch->SetTarget(targetPtr);
 87650: 
 87650:           gCaptureTouchList.Put(id, touch);
 87650:           // if we're moving from touchstart to touchmove for this touch
 87650:           // we allow preventDefault to prevent mouse events
 87650:           if (oldTouch->mMessage != touch->mMessage) {
 87650:             touchIsNew = true;
 87650:           }
 87650:         }
 87650:         // is nothing has changed, we should just return
 87650:         if (!haveChanged) {
 89244:           if (gPreventMouseEvents) {
 89244:               *aStatus = nsEventStatus_eConsumeNoDefault;
 89244:           }
 87650:           return NS_OK;
 87650:         }
 87650:         break;
 87650:       }
 34272:       case NS_DRAGDROP_DROP:
 34272:         nsCOMPtr<nsIDragSession> session = nsContentUtils::GetDragSession();
 34272:         if (session) {
 79445:           bool onlyChromeDrop = false;
 34272:           session->GetOnlyChromeDrop(&onlyChromeDrop);
 34272:           if (onlyChromeDrop) {
 34272:             aEvent->flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH;
 34272:           }
 34272:         }
 34272:         break;
     1:       }
     1:     }
     1: 
 31431:     if (aEvent->message == NS_CONTEXTMENU) {
 31431:       nsMouseEvent* me = static_cast<nsMouseEvent*>(aEvent);
 31431:       if (!CanHandleContextMenuEvent(me, GetCurrentEventFrame())) {
 23881:         return NS_OK;
 23881:       }
 31431:       if (me->context == nsMouseEvent::eContextMenuKey &&
 31431:           !AdjustContextMenuKeyEvent(me)) {
 31431:         return NS_OK;
 31431:       }
 96893:       if (me->IsShift())
 72004:         aEvent->flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH |
 72004:                          NS_EVENT_RETARGET_TO_NON_NATIVE_ANONYMOUS;
 31431:     }
 23881: 
 32435:     nsAutoHandlingUserInputStatePusher userInpStatePusher(isHandlingUserInput,
 56988:                                                           aEvent, mDocument);
     1: 
 55892:     if (NS_IS_TRUSTED_EVENT(aEvent) && aEvent->message == NS_MOUSE_MOVE) {
 55892:       nsIPresShell::AllowMouseCapture(
 55892:         nsEventStateManager::GetActiveEventStateManager() == manager);
 55892:     }
 55892: 
     1:     nsAutoPopupStatePusher popupStatePusher(nsDOMEvent::GetEventPopupControlState(aEvent));
     1: 
     1:     // FIXME. If the event was reused, we need to clear the old target,
     1:     // bug 329430
     1:     aEvent->target = nsnull;
     1: 
     1:     // 1. Give event to event manager for pre event state changes and
     1:     //    generation of synthetic events.
 82566:     rv = manager->PreHandleEvent(mPresContext, aEvent, mCurrentEventFrame, aStatus);
     1: 
     1:     // 2. Give event to the DOM for third party and JS use.
101341:     if (NS_SUCCEEDED(rv)) {
 79445:       bool wasHandlingKeyBoardEvent =
 41239:         nsContentUtils::IsHandlingKeyBoardEvent();
 41239:       if (aEvent->eventStructType == NS_KEY_EVENT) {
 80486:         nsContentUtils::SetIsHandlingKeyBoardEvent(true);
 41239:       }
     1:       // We want synthesized mouse moves to cause mouseover and mouseout
     1:       // DOM events (PreHandleEvent above), but not mousemove DOM events.
 39761:       // Synthesized button up events also do not cause DOM events
 39761:       // because they do not have a reliable refPoint.
 39761:       if (!IsSynthesizedMouseEvent(aEvent)) {
     1:         nsPresShellEventCB eventCB(this);
 87650:         if (aEvent->eventStructType == NS_TOUCH_EVENT) {
 87650:           DispatchTouchEvent(aEvent, aStatus, &eventCB, touchIsNew);
 87650:         }
 87650:         else if (mCurrentEventContent) {
     1:           nsEventDispatcher::Dispatch(mCurrentEventContent, mPresContext,
     1:                                       aEvent, nsnull, aStatus, &eventCB);
     1:         }
     1:         else {
     1:           nsCOMPtr<nsIContent> targetContent;
101616:           if (mCurrentEventFrame) {
 79435:             rv = mCurrentEventFrame->GetContentForEvent(aEvent,
     1:                                                         getter_AddRefs(targetContent));
101616:           }
     1:           if (NS_SUCCEEDED(rv) && targetContent) {
     1:             nsEventDispatcher::Dispatch(targetContent, mPresContext, aEvent,
     1:                                         nsnull, aStatus, &eventCB);
     1:           } else if (mDocument) {
     1:             nsEventDispatcher::Dispatch(mDocument, mPresContext, aEvent,
     1:                                         nsnull, aStatus, nsnull);
     1:           }
     1:         }
     1:       }
     1: 
 41239:       nsContentUtils::SetIsHandlingKeyBoardEvent(wasHandlingKeyBoardEvent);
 41239: 
     1:       // 3. Give event to event manager for post event state changes and
     1:       //    generation of synthetic events.
 22729:       if (!mIsDestroying && NS_SUCCEEDED(rv)) {
  8236:         rv = manager->PostHandleEvent(mPresContext, aEvent,
 82566:                                       GetCurrentEventFrame(), aStatus);
     1:       }
     1:     }
 32435: 
 32435:     if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 32435:       // reset the capturing content now that the mouse button is up
 32435:       SetCapturingContent(nsnull, 0);
 55892:     } else if (aEvent->message == NS_MOUSE_MOVE) {
 80486:       nsIPresShell::AllowMouseCapture(false);
 32435:     }
     1:   }
     1:   return rv;
     1: }
     1: 
 87650: void
 87650: PresShell::DispatchTouchEvent(nsEvent *aEvent,
 87650:                               nsEventStatus* aStatus,
 87650:                               nsPresShellEventCB* aEventCB,
 87650:                               bool aTouchIsNew)
 87650: {
 87650:   nsresult rv = NS_OK;
 87650:   // calling preventDefault on touchstart or the first touchmove for a
 87650:   // point prevents mouse events
 87650:   bool canPrevent = aEvent->message == NS_TOUCH_START ||
 87650:               (aEvent->message == NS_TOUCH_MOVE && aTouchIsNew);
 87650:   bool preventDefault = false;
 87650:   nsEventStatus tmpStatus = nsEventStatus_eIgnore;
 87650:   nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
 87650:   // touch events should fire on all targets
 87650:   if (aEvent->message != NS_TOUCH_START) {
105850:     for (PRUint32 i = 0; i < touchEvent->touches.Length(); ++i) {
105850:       nsIDOMTouch *touch = touchEvent->touches[i];
 87650:       if (!touch || !touch->mChanged) {
 87650:         continue;
 87650:       }
 87650:       // copy the event
 87650:       nsCOMPtr<nsPIDOMEventTarget> targetPtr;
 87650:       touch->GetTarget(getter_AddRefs(targetPtr));
 87650:       if (!targetPtr) {
 87650:         continue;
 87650:       }
 87650: 
 94753:       nsTouchEvent newEvent(NS_IS_TRUSTED_EVENT(touchEvent) ?
 94753:                               true : false,
 94753:                             touchEvent);
 87650:       newEvent.target = targetPtr;
 87650: 
104398:       // If someone is capturing, all touch events are filtered to their target
104398:       nsCOMPtr<nsIContent> content = GetCapturingContent();
104398: 
104398:       // if no one is capturing, set the capturing target
104398:       if (!content) {
104398:         content = do_QueryInterface(targetPtr);
104398:       }
104398:       PresShell* contentPresShell = nsnull;
104398:       if (content && content->OwnerDoc() == mDocument) {
104398:         contentPresShell = static_cast<PresShell*>
104398:             (content->OwnerDoc()->GetShell());
104398:         if (contentPresShell) {
104398:           contentPresShell->PushCurrentEventInfo(
104398:               content->GetPrimaryFrame(), content);
104398:         }
104398:       }
 87650:       nsPresContext *context = nsContentUtils::GetContextForContent(content);
 87650:       if (!context) {
 87650:         context = mPresContext;
 87650:       }
 87650:       tmpStatus = nsEventStatus_eIgnore;
 87650:       nsEventDispatcher::Dispatch(targetPtr, context,
 87650:                                   &newEvent, nsnull, &tmpStatus, aEventCB);
 87650:       if (nsEventStatus_eConsumeNoDefault == tmpStatus) {
 87650:         preventDefault = true;
 87650:       }
104398:       if (contentPresShell) {
104398:         contentPresShell->PopCurrentEventInfo();
104398:       }
 87650:     }
 87650:   } else {
 87650:     // touchevents need to have the target attribute set on each touch
105850:     for (PRUint32 i = 0; i < touchEvent->touches.Length(); ++i) {
105850:       nsIDOMTouch *touch = touchEvent->touches[i];
 87650:       if (touch->mChanged) {
 87650:         touch->SetTarget(mCurrentEventContent);
 87650:       }
 87650:     }
 87650: 
 87650:     if (mCurrentEventContent) {
 87650:       nsEventDispatcher::Dispatch(mCurrentEventContent, mPresContext,
 87650:                                   aEvent, nsnull, &tmpStatus, aEventCB);
 87650:     } else {
 87650:       nsCOMPtr<nsIContent> targetContent;
 87650:       rv = mCurrentEventFrame->GetContentForEvent(aEvent,
 87650:                                                   getter_AddRefs(targetContent));
 87650:       if (NS_SUCCEEDED(rv) && targetContent) {
 87650:         nsEventDispatcher::Dispatch(targetContent, mPresContext, aEvent,
 87650:                                     nsnull, &tmpStatus, aEventCB);
 87650:       } else if (mDocument) {
 87650:         nsEventDispatcher::Dispatch(mDocument, mPresContext, aEvent,
 87650:                                     nsnull, &tmpStatus, nsnull);
 87650:       }
 87650:     }
 87650:     if (nsEventStatus_eConsumeNoDefault == tmpStatus) {
 87650:       preventDefault = true;
 87650:     }
 87650: 
 87650:     if (touchEvent->touches.Length() == 1) {
 87650:       gPreventMouseEvents = false;
 87650:     }
 87650:   }
 87650: 
 87650:   // if preventDefault was called on any of the events dispatched
 87650:   // and this is touchstart, or the first touchmove, widget should consume
 87650:   // other events that would be associated with this touch session
 87650:   if (preventDefault && canPrevent) {
 87650:     gPreventMouseEvents = true;
 87650:   }
 87650: 
 87650:   if (gPreventMouseEvents) {
 87650:     *aStatus = nsEventStatus_eConsumeNoDefault;
 87650:   } else {
 87650:     *aStatus = nsEventStatus_eIgnore;
 87650:   }
 87650: }
 87650: 
     1: // Dispatch event to content only (NOT full processing)
     1: // See also HandleEventWithTarget which does full event processing.
 40055: nsresult
     1: PresShell::HandleDOMEventWithTarget(nsIContent* aTargetContent, nsEvent* aEvent,
     1:                                     nsEventStatus* aStatus)
     1: {
 40055:   nsresult rv = NS_OK;
 40055: 
     1:   PushCurrentEventInfo(nsnull, aTargetContent);
     1: 
     1:   // Bug 41013: Check if the event should be dispatched to content.
     1:   // It's possible that we are in the middle of destroying the window
     1:   // and the js context is out of date. This check detects the case
     1:   // that caused a crash in bug 41013, but there may be a better way
     1:   // to handle this situation!
     1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
     1:   if (container) {
     1: 
     1:     // Dispatch event to content
 40055:     rv = nsEventDispatcher::Dispatch(aTargetContent, mPresContext, aEvent, nsnull,
     1:                                      aStatus);
     1:   }
     1: 
     1:   PopCurrentEventInfo();
 40055:   return rv;
     1: }
     1: 
 29844: // See the method above.
 40055: nsresult
 29844: PresShell::HandleDOMEventWithTarget(nsIContent* aTargetContent,
 29844:                                     nsIDOMEvent* aEvent,
 29844:                                     nsEventStatus* aStatus)
 29844: {
 40055:   nsresult rv = NS_OK;
 40055: 
 29844:   PushCurrentEventInfo(nsnull, aTargetContent);
 29844:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
 29844:   if (container) {
 40055:     rv = nsEventDispatcher::DispatchDOMEvent(aTargetContent, nsnull, aEvent,
 29844:                                              mPresContext, aStatus);
 29844:   }
 29844: 
 29844:   PopCurrentEventInfo();
 40055:   return rv;
 29844: }
 29844: 
 79445: bool
 23881: PresShell::AdjustContextMenuKeyEvent(nsMouseEvent* aEvent)
 23881: {
 23881: #ifdef MOZ_XUL
 23881:   // if a menu is open, open the context menu relative to the active item on the menu. 
 23881:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 23881:   if (pm) {
 23881:     nsIFrame* popupFrame = pm->GetTopPopup(ePopupTypeMenu);
 23881:     if (popupFrame) {
 23881:       nsIFrame* itemFrame = 
 23881:         (static_cast<nsMenuPopupFrame *>(popupFrame))->GetCurrentMenuItem();
 23881:       if (!itemFrame)
 23881:         itemFrame = popupFrame;
 23881: 
 47148:       nsCOMPtr<nsIWidget> widget = popupFrame->GetNearestWidget();
 23881:       aEvent->widget = widget;
 25183:       nsIntPoint widgetPoint = widget->WidgetToScreenOffset();
 25183:       aEvent->refPoint = itemFrame->GetScreenRect().BottomLeft() - widgetPoint;
 23881: 
 23881:       mCurrentEventContent = itemFrame->GetContent();
 23881:       mCurrentEventFrame = itemFrame;
 23881: 
 80486:       return true;
 23881:     }
 23881:   }
 23881: #endif
 23881: 
 23881:   // If we're here because of the key-equiv for showing context menus, we
 23881:   // have to twiddle with the NS event to make sure the context menu comes
 23881:   // up in the upper left of the relevant content area before we create
 23881:   // the DOM event. Since we never call InitMouseEvent() on the event, 
 23881:   // the client X/Y will be 0,0. We can make use of that if the widget is null.
 30534:   // Use the root view manager's widget since it's most likely to have one,
 30534:   // and the coordinates returned by GetCurrentItemAndPositionForElement
 47905:   // are relative to the widget of the root of the root view manager.
 37502:   nsRootPresContext* rootPC = mPresContext->GetRootPresContext();
 47905:   aEvent->refPoint.x = 0;
 47905:   aEvent->refPoint.y = 0;
 37502:   if (rootPC) {
 37502:     rootPC->PresShell()->GetViewManager()->
 30534:       GetRootWidget(getter_AddRefs(aEvent->widget));
 47905: 
 47905:     if (aEvent->widget) {
 47905:       // default the refpoint to the topleft of our document
 47905:       nsPoint offset(0, 0);
 89328:       nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
 47905:       if (rootFrame) {
 47905:         nsIView* view = rootFrame->GetClosestView(&offset);
 47905:         offset += view->GetOffsetToWidget(aEvent->widget);
 47905:         aEvent->refPoint =
 47905:           offset.ToNearestPixels(mPresContext->AppUnitsPerDevPixel());
 47905:       }
 47905:     }
 37502:   } else {
 37502:     aEvent->widget = nsnull;
 37502:   }
 23881: 
 23881:   // see if we should use the caret position for the popup
 23884:   nsIntPoint caretPoint;
 23881:   // Beware! This may flush notifications via synchronous
 23881:   // ScrollSelectionIntoView.
 23881:   if (PrepareToUseCaretPosition(aEvent->widget, caretPoint)) {
 23881:     // caret position is good
 23881:     aEvent->refPoint = caretPoint;
 80486:     return true;
 23881:   }
 23881: 
 23881:   // If we're here because of the key-equiv for showing context menus, we
 23881:   // have to reset the event target to the currently focused element. Get it
 23881:   // from the focus controller.
 23881:   nsCOMPtr<nsIDOMElement> currentFocus;
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm)
 29018:     fm->GetFocusedElement(getter_AddRefs(currentFocus));
 29018: 
 23881:   // Reset event coordinates relative to focused frame in view
 23881:   if (currentFocus) {
 23881:     nsCOMPtr<nsIContent> currentPointElement;
 23881:     GetCurrentItemAndPositionForElement(currentFocus,
 23881:                                         getter_AddRefs(currentPointElement),
 47902:                                         aEvent->refPoint,
 47902:                                         aEvent->widget);
 23881:     if (currentPointElement) {
 23881:       mCurrentEventContent = currentPointElement;
 23881:       mCurrentEventFrame = nsnull;
 23881:       GetCurrentEventFrame();
 23881:     }
 23881:   }
 23881: 
 80486:   return true;
 23881: }
 23881: 
 47902: // PresShell::PrepareToUseCaretPosition
 23881: //
 23881: //    This checks to see if we should use the caret position for popup context
 23881: //    menus. Returns true if the caret position should be used, and the
 23881: //    coordinates of that position is returned in aTargetPt. This function
 23881: //    will also scroll the window as needed to make the caret visible.
 23881: //
 23881: //    The event widget should be the widget that generated the event, and
 23881: //    whose coordinate system the resulting event's refPoint should be
 23881: //    relative to.  The returned point is in device pixels realtive to the
 23881: //    widget passed in.
 79445: bool
 23881: PresShell::PrepareToUseCaretPosition(nsIWidget* aEventWidget, nsIntPoint& aTargetPt)
 23881: {
 23881:   nsresult rv;
 23881: 
 23881:   // check caret visibility
 40045:   nsRefPtr<nsCaret> caret = GetCaret();
 80486:   NS_ENSURE_TRUE(caret, false);
 23881: 
 79445:   bool caretVisible = false;
 23881:   rv = caret->GetCaretVisible(&caretVisible);
 23881:   if (NS_FAILED(rv) || ! caretVisible)
 80486:     return false;
 23881: 
 23881:   // caret selection, this is a temporary weak reference, so no refcounting is 
 23881:   // needed
 23881:   nsISelection* domSelection = caret->GetCaretDOMSelection();
 80486:   NS_ENSURE_TRUE(domSelection, false);
 23881: 
 23881:   // since the match could be an anonymous textnode inside a
 23881:   // <textarea> or text <input>, we need to get the outer frame
 23881:   // note: frames are not refcounted
 23881:   nsIFrame* frame = nsnull; // may be NULL
 23881:   nsCOMPtr<nsIDOMNode> node;
 23881:   rv = domSelection->GetFocusNode(getter_AddRefs(node));
 80486:   NS_ENSURE_SUCCESS(rv, false);
 80486:   NS_ENSURE_TRUE(node, false);
 23881:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
 23881:   if (content) {
 23881:     nsIContent* nonNative = content->FindFirstNonNativeAnonymous();
 23881:     content = nonNative;
 23881:   }
 23881: 
 23881:   if (content) {
 23881:     // It seems like ScrollSelectionIntoView should be enough, but it's
 23881:     // not. The problem is that scrolling the selection into view when it is
 23881:     // below the current viewport will align the top line of the frame exactly
 23881:     // with the bottom of the window. This is fine, BUT, the popup event causes
 23881:     // the control to be re-focused which does this exact call to
 23881:     // ScrollContentIntoView, which has a one-pixel disagreement of whether the
 23881:     // frame is actually in view. The result is that the frame is aligned with
 23881:     // the top of the window, but the menu is still at the bottom.
 23881:     //
 23881:     // Doing this call first forces the frame to be in view, eliminating the
 23881:     // problem. The only difference in the result is that if your cursor is in
 23881:     // an edit box below the current view, you'll get the edit box aligned with
 23881:     // the top of the window. This is arguably better behavior anyway.
 93554:     rv = ScrollContentIntoView(content,
 93554:                                ScrollAxis(),
 93554:                                ScrollAxis(),
 56647:                                SCROLL_OVERFLOW_HIDDEN);
 80486:     NS_ENSURE_SUCCESS(rv, false);
 36656:     frame = content->GetPrimaryFrame();
 23881:     NS_WARN_IF_FALSE(frame, "No frame for focused content?");
 23881:   }
 23881: 
 23881:   // Actually scroll the selection (ie caret) into view. Note that this must
 23881:   // be synchronous since we will be checking the caret position on the screen.
 23881:   //
 23881:   // Be easy about errors, and just don't scroll in those cases. Better to have
 23881:   // the correct menu at a weird place than the wrong menu.
 23881:   // After ScrollSelectionIntoView(), the pending notifications might be
 23881:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
 23881:   nsCOMPtr<nsISelectionController> selCon;
 23881:   if (frame)
 23881:     frame->GetSelectionController(GetPresContext(), getter_AddRefs(selCon));
 23881:   else
 23881:     selCon = static_cast<nsISelectionController *>(this);
 23881:   if (selCon) {
 23881:     rv = selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
 56442:                                          nsISelectionController::SELECTION_FOCUS_REGION,
 56442:                                          nsISelectionController::SCROLL_SYNCHRONOUS);
 80486:     NS_ENSURE_SUCCESS(rv, false);
 23881:   }
 23881: 
 47902:   nsPresContext* presContext = GetPresContext();
 47902: 
 47902:   // get caret position relative to the closest view
 23881:   nsRect caretCoords;
 39425:   nsIFrame* caretFrame = caret->GetGeometry(domSelection, &caretCoords);
 39425:   if (!caretFrame)
 80486:     return false;
 47902:   nsPoint viewOffset;
 47902:   nsIView* view = caretFrame->GetClosestView(&viewOffset);
 47902:   if (!view)
 80486:     return false;
 47902:   // and then get the caret coords relative to the event widget
 47902:   if (aEventWidget) {
 47902:     viewOffset += view->GetOffsetToWidget(aEventWidget);
 47902:   }
 47902:   caretCoords.MoveBy(viewOffset);
 23881: 
 23881:   // caret coordinates are in app units, convert to pixels
 47902:   aTargetPt.x =
 47902:     presContext->AppUnitsToDevPixels(caretCoords.x + caretCoords.width);
 47902:   aTargetPt.y =
 47902:     presContext->AppUnitsToDevPixels(caretCoords.y + caretCoords.height);
 23881: 
 36975:   // make sure rounding doesn't return a pixel which is outside the caret
 36975:   // (e.g. one line lower)
 36975:   aTargetPt.y -= 1;
 36975: 
 80486:   return true;
 23881: }
 23881: 
 23881: void
 23881: PresShell::GetCurrentItemAndPositionForElement(nsIDOMElement *aCurrentEl,
 23881:                                                nsIContent** aTargetToUse,
 47902:                                                nsIntPoint& aTargetPt,
 47902:                                                nsIWidget *aRootWidget)
 23881: {
 23881:   nsCOMPtr<nsIContent> focusedContent(do_QueryInterface(aCurrentEl));
 93554:   ScrollContentIntoView(focusedContent,
 93554:                         ScrollAxis(),
 93554:                         ScrollAxis(),
 56647:                         SCROLL_OVERFLOW_HIDDEN);
 23881: 
 47902:   nsPresContext* presContext = GetPresContext();
 47902: 
 79445:   bool istree = false, checkLineHeight = true;
 47902:   nscoord extraTreeY = 0;
 23881: 
 23881: #ifdef MOZ_XUL
 23881:   // Set the position to just underneath the current item for multi-select
 23881:   // lists or just underneath the selected item for single-select lists. If
 23881:   // the element is not a list, or there is no selection, leave the position
 23881:   // as is.
 23881:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
 23881:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSelect =
 23881:     do_QueryInterface(aCurrentEl);
 23881:   if (multiSelect) {
 80486:     checkLineHeight = false;
 23881:     
 23881:     PRInt32 currentIndex;
 23881:     multiSelect->GetCurrentIndex(&currentIndex);
 23881:     if (currentIndex >= 0) {
 23881:       nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(aCurrentEl));
 23881:       if (xulElement) {
 23881:         nsCOMPtr<nsIBoxObject> box;
 23881:         xulElement->GetBoxObject(getter_AddRefs(box));
 23881:         nsCOMPtr<nsITreeBoxObject> treeBox(do_QueryInterface(box));
 23881:         // Tree view special case (tree items have no frames)
 23881:         // Get the focused row and add its coordinates, which are already in pixels
 23881:         // XXX Boris, should we create a new interface so that this doesn't
 23881:         // need to know about trees? Something like nsINodelessChildCreator which
 23881:         // could provide the current focus coordinates?
 23881:         if (treeBox) {
 23881:           treeBox->EnsureRowIsVisible(currentIndex);
 23881:           PRInt32 firstVisibleRow, rowHeight;
 23881:           treeBox->GetFirstVisibleRow(&firstVisibleRow);
 23881:           treeBox->GetRowHeight(&rowHeight);
 23881: 
 47902:           extraTreeY += presContext->CSSPixelsToAppUnits(
 47902:                           (currentIndex - firstVisibleRow + 1) * rowHeight);
 80486:           istree = true;
 23881: 
 23881:           nsCOMPtr<nsITreeColumns> cols;
 23881:           treeBox->GetColumns(getter_AddRefs(cols));
 23881:           if (cols) {
 23881:             nsCOMPtr<nsITreeColumn> col;
 23881:             cols->GetFirstColumn(getter_AddRefs(col));
 23881:             if (col) {
 23881:               nsCOMPtr<nsIDOMElement> colElement;
 23881:               col->GetElement(getter_AddRefs(colElement));
 23881:               nsCOMPtr<nsIContent> colContent(do_QueryInterface(colElement));
 23881:               if (colContent) {
 36656:                 nsIFrame* frame = colContent->GetPrimaryFrame();
 23881:                 if (frame) {
 47902:                   extraTreeY += frame->GetSize().height;
 23881:                 }
 23881:               }
 23881:             }
 23881:           }
 23881:         }
 23881:         else {
 23881:           multiSelect->GetCurrentItem(getter_AddRefs(item));
 23881:         }
 23881:       }
 23881:     }
 23881:   }
 23881:   else {
 23881:     // don't check menulists as the selected item will be inside a popup.
 23881:     nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(aCurrentEl);
 23881:     if (!menulist) {
 23881:       nsCOMPtr<nsIDOMXULSelectControlElement> select =
 23881:         do_QueryInterface(aCurrentEl);
 46317:       if (select) {
 80486:         checkLineHeight = false;
 23881:         select->GetSelectedItem(getter_AddRefs(item));
 23881:       }
 23881:     }
 46317:   }
 23881: 
 23881:   if (item)
 23881:     focusedContent = do_QueryInterface(item);
 23881: #endif
 23881: 
 36656:   nsIFrame *frame = focusedContent->GetPrimaryFrame();
 23881:   if (frame) {
 47902:     NS_ASSERTION(frame->PresContext() == GetPresContext(),
 47902:       "handling event for focused content that is not in our document?");
 47902: 
 23881:     nsPoint frameOrigin(0, 0);
 23881: 
 23881:     // Get the frame's origin within its view
 23881:     nsIView *view = frame->GetClosestView(&frameOrigin);
 23881:     NS_ASSERTION(view, "No view for frame");
 23881: 
 47902:     // View's origin relative the widget
 47902:     if (aRootWidget) {
 47902:       frameOrigin += view->GetOffsetToWidget(aRootWidget);
 47902:     }
 23881: 
 23881:     // Start context menu down and to the right from top left of frame
 23881:     // use the lineheight. This is a good distance to move the context
 23881:     // menu away from the top left corner of the frame. If we always 
 23881:     // used the frame height, the context menu could end up far away,
 23881:     // for example when we're focused on linked images.
 23881:     // On the other hand, we want to use the frame height if it's less
 23881:     // than the current line height, so that the context menu appears
 23881:     // associated with the correct frame.
 23881:     nscoord extra = 0;
 23881:     if (!istree) {
 23881:       extra = frame->GetSize().height;
 23881:       if (checkLineHeight) {
 37057:         nsIScrollableFrame *scrollFrame =
 37057:           nsLayoutUtils::GetNearestScrollableFrame(frame);
 37057:         if (scrollFrame) {
 47902:           nsSize scrollAmount = scrollFrame->GetLineScrollAmount();
 47902:           nsIFrame* f = do_QueryFrame(scrollFrame);
 47902:           PRInt32 APD = presContext->AppUnitsPerDevPixel();
 47902:           PRInt32 scrollAPD = f->PresContext()->AppUnitsPerDevPixel();
 47902:           scrollAmount = scrollAmount.ConvertAppUnits(scrollAPD, APD);
 47902:           if (extra > scrollAmount.height) {
 47902:             extra = scrollAmount.height;
 47902:           }
 47902:         }
 47902:       }
 47902:     }
 47902: 
 23881:     aTargetPt.x = presContext->AppUnitsToDevPixels(frameOrigin.x);
 23881:     aTargetPt.y = presContext->AppUnitsToDevPixels(
 47902:                     frameOrigin.y + extra + extraTreeY);
 23881:   }
 23881: 
 23881:   NS_IF_ADDREF(*aTargetToUse = focusedContent);
 23881: }
 23881: 
 82568: bool
 50857: PresShell::ShouldIgnoreInvalidation()
 50857: {
 51761:   return mPaintingSuppressed || !mIsActive;
 50857: }
 50857: 
 82568: void
 79445: PresShell::WillPaint(bool aWillSendDidPaint)
 47756: {
 52491:   // Don't bother doing anything if some viewmanager in our tree is painting
 52491:   // while we still have painting suppressed or we are not active.
 80910:   if (mPaintingSuppressed || !mIsActive || !IsVisible()) {
     1:     return;
     1:   }
     1: 
 47756:   nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
 47756:   if (!rootPresContext) {
 47756:     return;
 47756:   }
 80879: 
 80879:   if (!aWillSendDidPaint && rootPresContext == mPresContext) {
 47756:     rootPresContext->UpdatePluginGeometry();
 47756:   }
 80879:   rootPresContext->FlushWillPaintObservers();
 80879:   if (mIsDestroying)
 80879:     return;
 47756: 
     1:   // Process reflows, if we have them, to reduce flicker due to invalidates and
     1:   // reflow being interspersed.  Note that we _do_ allow this to be
     1:   // interruptible; if we can't do all the reflows it's better to flicker a bit
     1:   // than to freeze up.
 27993:   FlushPendingNotifications(Flush_InterruptibleLayout);
     1: }
     1: 
 82568: void
 47756: PresShell::DidPaint()
 47756: {
 80910:   if (mPaintingSuppressed || !mIsActive || !IsVisible()) {
 69183:     return;
 69183:   }
 69183: 
 88468:   NS_ASSERTION(mPresContext->IsRoot(), "Should only call DidPaint on root presshells");
 88468: 
 47756:   nsRootPresContext* rootPresContext = mPresContext->GetRootPresContext();
 88468:   // This should only be called on root presshells, but maybe if a document
 88468:   // tree is torn down we might not be a root presshell...
 47756:   if (rootPresContext == mPresContext) {
 47756:     rootPresContext->UpdatePluginGeometry();
 47756:   }
 90410: 
 90410:   if (nsContentUtils::XPConnect()) {
 90410:     nsContentUtils::XPConnect()->NotifyDidPaint();
 90410:   }
 47756: }
 47756: 
 82568: bool
 80910: PresShell::IsVisible()
 80910: {
 80910:   if (!mViewManager)
 80910:     return false;
 80910: 
 80910:   nsIView* view = mViewManager->GetRootView();
 80910:   if (!view)
 80910:     return true;
 80910: 
 80910:   // inner view of subdoc frame
 80910:   view = view->GetParent();
 80910:   if (!view)
 80910:     return true;
 80910:   
 80910:   // subdoc view
 80910:   view = view->GetParent();
 80910:   if (!view)
 80910:     return true;
 80910: 
 82566:   nsIFrame* frame = view->GetFrame();
 80910:   if (!frame)
 80910:     return true;
 80910: 
 80910:   return frame->IsVisibleConsideringAncestors(nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY);
 80910: }
 80910: 
     1: nsresult
     1: PresShell::GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets)
     1: {
     1:   aSheets.Clear();
     1:   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eAgentSheet);
     1: 
     1:   for (PRInt32 i = 0; i < sheetCount; ++i) {
     1:     nsIStyleSheet *sheet = mStyleSet->StyleSheetAt(nsStyleSet::eAgentSheet, i);
     1:     if (!aSheets.AppendObject(sheet))
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: PresShell::SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets)
     1: {
     1:   return mStyleSet->ReplaceSheets(nsStyleSet::eAgentSheet, aSheets);
     1: }
     1: 
     1: nsresult
     1: PresShell::AddOverrideStyleSheet(nsIStyleSheet *aSheet)
     1: {
     1:   return mStyleSet->PrependStyleSheet(nsStyleSet::eOverrideSheet, aSheet);
     1: }
     1: 
     1: nsresult
     1: PresShell::RemoveOverrideStyleSheet(nsIStyleSheet *aSheet)
     1: {
     1:   return mStyleSet->RemoveStyleSheet(nsStyleSet::eOverrideSheet, aSheet);
     1: }
     1: 
     1: static void
 36656: FreezeElement(nsIContent *aContent, void * /* unused */)
 36656: {
 89114:   nsCOMPtr<nsIObjectLoadingContent> olc(do_QueryInterface(aContent));
 89114:   if (olc) {
 89114:     olc->StopPluginInstance();
 28108:   }
 28108: }
 28108: 
 79445: static bool
     1: FreezeSubDocument(nsIDocument *aDocument, void *aData)
     1: {
 46225:   nsIPresShell *shell = aDocument->GetShell();
     1:   if (shell)
     1:     shell->Freeze();
     1: 
 80486:   return true;
     1: }
     1: 
     1: void
     1: PresShell::Freeze()
     1: {
 35522:   MaybeReleaseCapturingContent();
 35522: 
 36656:   mDocument->EnumerateFreezableElements(FreezeElement, nsnull);
     1: 
 59014:   if (mCaret) {
 80486:     mCaret->SetCaretVisible(false);
 80486:   }
 80486: 
 80486:   mPaintingSuppressed = true;
     1: 
 59014:   if (mDocument) {
     1:     mDocument->EnumerateSubDocuments(FreezeSubDocument, nsnull);
 59014:   }
 37880: 
 37880:   nsPresContext* presContext = GetPresContext();
 50366:   if (presContext &&
 50366:       presContext->RefreshDriver()->PresContext() == presContext) {
 37880:     presContext->RefreshDriver()->Freeze();
 37880:   }
 50815: 
 67576:   if (presContext) {
 67576:     nsRootPresContext* rootPresContext = presContext->GetRootPresContext();
 67576:     if (rootPresContext) {
 67576:       rootPresContext->
 67576:         RootForgetUpdatePluginGeometryFrameForPresContext(mPresContext);
 67576:     }
 67576:   }
 67576: 
 80486:   mFrozen = true;
 59014:   if (mDocument) {
 50815:     UpdateImageLockingState();
     1:   }
 59014: }
     1: 
 25722: void
 79445: PresShell::FireOrClearDelayedEvents(bool aFireEvents)
 25722: {
 80486:   mNoDelayedMouseEvents = false;
 80486:   mNoDelayedKeyEvents = false;
 25722:   if (!aFireEvents) {
 28498:     mDelayedEvents.Clear();
 25722:     return;
 25722:   }
 25722: 
 29275:   if (mDocument) {
 25722:     nsCOMPtr<nsIDocument> doc = mDocument;
 29275:     while (!mIsDestroying && mDelayedEvents.Length() &&
 29275:            !doc->EventHandlingSuppressed()) {
 29275:       nsAutoPtr<nsDelayedEvent> ev(mDelayedEvents[0].forget());
 28498:       mDelayedEvents.RemoveElementAt(0);
 29275:       ev->Dispatch(this);
 25724:     }
 25724:     if (!doc->EventHandlingSuppressed()) {
 28498:       mDelayedEvents.Clear();
 25722:     }
 25722:   }
 25722: }
 25722: 
     1: static void
 28108: ThawElement(nsIContent *aContent, void *aShell)
 28108: {
 89114:   nsCOMPtr<nsIObjectLoadingContent> olc(do_QueryInterface(aContent));
 89114:   if (olc) {
 89114:     olc->AsyncStartPluginInstance();
     1:   }
 28108: }
 15751: 
 79445: static bool
     1: ThawSubDocument(nsIDocument *aDocument, void *aData)
     1: {
 46225:   nsIPresShell *shell = aDocument->GetShell();
     1:   if (shell)
     1:     shell->Thaw();
     1: 
 80486:   return true;
     1: }
     1: 
     1: void
     1: PresShell::Thaw()
     1: {
 37880:   nsPresContext* presContext = GetPresContext();
 50366:   if (presContext &&
 50366:       presContext->RefreshDriver()->PresContext() == presContext) {
 37880:     presContext->RefreshDriver()->Thaw();
 37880:   }
 37880: 
 28108:   mDocument->EnumerateFreezableElements(ThawElement, this);
     1: 
     1:   if (mDocument)
     1:     mDocument->EnumerateSubDocuments(ThawSubDocument, nsnull);
     1: 
 48937:   // Get the activeness of our presshell, as this might have changed
 48937:   // while we were in the bfcache
 48937:   QueryIsActive();
 50815: 
 50815:   // We're now unfrozen
 80486:   mFrozen = false;
 50815:   UpdateImageLockingState();
 52487: 
 52487:   UnsuppressPainting();
     1: }
     1: 
     1: //--------------------------------------------------------
     1: // Start of protected and private methods on the PresShell
     1: //--------------------------------------------------------
     1: 
     1: void
 38310: PresShell::MaybeScheduleReflow()
 38310: {
 38310:   ASSERT_REFLOW_SCHEDULED_STATE();
 38310:   if (mReflowScheduled || mIsDestroying || mIsReflowing ||
 24551:       mDirtyRoots.Length() == 0)
     1:     return;
     1: 
 38310:   if (!mPresContext->HasPendingInterrupt() || !ScheduleReflowOffTimer()) {
 38310:     ScheduleReflow();
 38310:   }
 38310: 
 38310:   ASSERT_REFLOW_SCHEDULED_STATE();
 29172: }
 29172: 
 29172: void
 38310: PresShell::ScheduleReflow()
 38310: {
 38310:   NS_PRECONDITION(!mReflowScheduled, "Why are we trying to schedule a reflow?");
 38310:   ASSERT_REFLOW_SCHEDULED_STATE();
 38310: 
 50365:   if (GetPresContext()->RefreshDriver()->AddLayoutFlushObserver(this)) {
 80486:     mReflowScheduled = true;
 38310:   }
 38310: 
 38310:   ASSERT_REFLOW_SCHEDULED_STATE();
     1: }
     1: 
 29804: nsresult
 29804: PresShell::DidCauseReflow()
 29804: {
 29804:   NS_ASSERTION(mChangeNestCount != 0, "Unexpected call to DidCauseReflow()");
 29804:   --mChangeNestCount;
 29804:   nsContentUtils::RemoveScriptBlocker();
 29804: 
 29804:   return NS_OK;
 29804: }
 29804: 
     1: void
     1: PresShell::WillDoReflow()
     1: {
     1:   // We just reflowed, tell the caret that its frame might have moved.
  6518:   // XXXbz that comment makes no sense
     1:   if (mCaret) {
     1:     mCaret->InvalidateOutsideCaret();
     1:   }
  6518: 
 21925:   mPresContext->FlushUserFontSet();
 21925: 
  6518:   mFrameConstructor->BeginUpdate();
     1: }
     1: 
     1: void
 79445: PresShell::DidDoReflow(bool aInterruptible)
     1: {
  6518:   mFrameConstructor->EndUpdate();
  6518:   
 27993:   HandlePostedReflowCallbacks(aInterruptible);
 70860:   if (sSynthMouseMove) {
 80486:     SynthesizeMouseMove(false);
 70860:   }
     1:   if (mCaret) {
     1:     // Update the caret's position now to account for any changes created by
     1:     // the reflow.
     1:     mCaret->InvalidateOutsideCaret();
     1:     mCaret->UpdateCaretPosition();
     1:   }
     1: }
     1: 
 27993: static PLDHashOperator
 27993: MarkFramesDirtyToRoot(nsPtrHashKey<nsIFrame>* p, void* closure)
 27993: {
 27993:   nsIFrame* target = static_cast<nsIFrame*>(closure);
 27993:   for (nsIFrame* f = p->GetKey(); f && !NS_SUBTREE_DIRTY(f);
 27993:        f = f->GetParent()) {
 27993:     f->AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
 27993: 
 27993:     if (f == target) {
 27993:       break;
 27993:     }
 27993:   }
 27993: 
 27993:   return PL_DHASH_NEXT;
 27993: }
 27993: 
 29172: void
 29172: PresShell::sReflowContinueCallback(nsITimer* aTimer, void* aPresShell)
 29172: {
 29172:   nsRefPtr<PresShell> self = static_cast<PresShell*>(aPresShell);
 29172: 
 29172:   NS_PRECONDITION(aTimer == self->mReflowContinueTimer, "Unexpected timer");
 29172:   self->mReflowContinueTimer = nsnull;
 38310:   self->ScheduleReflow();
 29172: }
 29172: 
 79445: bool
 38310: PresShell::ScheduleReflowOffTimer()
 38310: {
 38310:   NS_PRECONDITION(!mReflowScheduled, "Shouldn't get here");
 38310:   ASSERT_REFLOW_SCHEDULED_STATE();
 38310: 
 29172:   if (!mReflowContinueTimer) {
 29172:     mReflowContinueTimer = do_CreateInstance("@mozilla.org/timer;1");
 29172:     if (!mReflowContinueTimer ||
 29172:         NS_FAILED(mReflowContinueTimer->
 33392:                     InitWithFuncCallback(sReflowContinueCallback, this, 30,
 29172:                                          nsITimer::TYPE_ONE_SHOT))) {
 80486:       return false;
 80486:     }
 80486:   }
 80486:   return true;
 29172: }
 29172: 
 79445: bool
 79445: PresShell::DoReflow(nsIFrame* target, bool aInterruptible)
   790: {
 42480:   NS_TIME_FUNCTION_WITH_DOCURL;
 84290:   SAMPLE_LABEL("layout", "DoReflow");
 42480: 
 33393:   if (mReflowContinueTimer) {
 33393:     mReflowContinueTimer->Cancel();
 33393:     mReflowContinueTimer = nsnull;
 33393:   }
 33393: 
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
   790: 
 68481:   nsRefPtr<nsRenderingContext> rcx = GetReferenceRenderingContext();
 51038:   if (!rcx) {
   790:     NS_NOTREACHED("CreateRenderingContext failure");
 80486:     return false;
 27993:   }
 27993: 
 27993: #ifdef DEBUG
 27993:   mCurrentReflowRoot = target;
 27993: #endif
     1: 
     1:   target->WillReflow(mPresContext);
     1: 
     1:   // If the target frame is the root of the frame hierarchy, then
     1:   // use all the available space. If it's simply a `reflow root',
     1:   // then use the target frame's size as the available space.
     1:   nsSize size;
 47775:   if (target == rootFrame) {
   790:      size = mPresContext->GetVisibleArea().Size();
103530: 
103530:      // target->GetRect() has the old size of the frame,
103530:      // mPresContext->GetVisibleArea() has the new size.
103530:      target->InvalidateRectDifference(mPresContext->GetVisibleArea(),
103530:                                       target->GetRect());
 47775:   } else {
     1:      size = target->GetSize();
 47775:   }
     1: 
     1:   NS_ASSERTION(!target->GetNextInFlow() && !target->GetPrevInFlow(),
     1:                "reflow roots should never split");
     1: 
     1:   // Don't pass size directly to the reflow state, since a
     1:   // constrained height implies page/column breaking.
 24416:   nsSize reflowSize(size.width, NS_UNCONSTRAINEDSIZE);
   790:   nsHTMLReflowState reflowState(mPresContext, target, rcx, reflowSize);
     1: 
 55051:   if (rootFrame == target) {
 55051:     // When the root frame is being reflowed with unconstrained height
 55051:     // (which happens when we're called from
 55051:     // DocumentViewerImpl::SizeToContent), we're effectively doing a
 55051:     // vertical resize, since it changes the meaning of percentage
 55051:     // heights even if no heights actually changed.  The same applies
 55051:     // when we reflow again after that computation.  This is an unusual
 55051:     // case, and isn't caught by nsHTMLReflowState::InitResizeFlags.
 79445:     bool hasUnconstrainedHeight = size.height == NS_UNCONSTRAINEDSIZE;
 55051: 
 55051:     if (hasUnconstrainedHeight || mLastRootReflowHadUnconstrainedHeight) {
 80486:       reflowState.mFlags.mVResize = true;
 55051:     }
 55051: 
 55051:     mLastRootReflowHadUnconstrainedHeight = hasUnconstrainedHeight;
 55051:   }
 55051: 
     1:   // fix the computed height
     1:   NS_ASSERTION(reflowState.mComputedMargin == nsMargin(0, 0, 0, 0),
     1:                "reflow state should not set margin for reflow roots");
   967:   if (size.height != NS_UNCONSTRAINEDSIZE) {
  4166:     nscoord computedHeight =
     1:       size.height - reflowState.mComputedBorderPadding.TopBottom();
 32531:     computedHeight = NS_MAX(computedHeight, 0);
  4166:     reflowState.SetComputedHeight(computedHeight);
   967:   }
     1:   NS_ASSERTION(reflowState.ComputedWidth() ==
     1:                  size.width -
     1:                    reflowState.mComputedBorderPadding.LeftRight(),
     1:                "reflow state computed incorrect width");
     1: 
 27993:   mPresContext->ReflowStarted(aInterruptible);
 80486:   mIsReflowing = true;
 27993: 
     1:   nsReflowStatus status;
   790:   nsHTMLReflowMetrics desiredSize;
     1:   target->Reflow(mPresContext, desiredSize, reflowState, status);
     1: 
     1:   // If an incremental reflow is initiated at a frame other than the
   967:   // root frame, then its desired size had better not change!  If it's
   967:   // initiated at the root, then the size better not change unless its
   967:   // height was unconstrained to start with.
 84217:   nsRect boundsRelativeToTarget = nsRect(0, 0, desiredSize.width, desiredSize.height);
   967:   NS_ASSERTION((target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) ||
     1:                (desiredSize.width == size.width &&
     1:                 desiredSize.height == size.height),
     1:                "non-root frame's desired size changed during an "
     1:                "incremental reflow");
 84217:   NS_ASSERTION(target == rootFrame ||
 84217:                desiredSize.VisualOverflow().IsEqualInterior(boundsRelativeToTarget),
 83439:                "non-root reflow roots must not have visible overflow");
 84217:   NS_ASSERTION(target == rootFrame ||
 84217:                desiredSize.ScrollableOverflow().IsEqualEdges(boundsRelativeToTarget),
 83439:                "non-root reflow roots must not have scrollable overflow");
     1:   NS_ASSERTION(status == NS_FRAME_COMPLETE,
     1:                "reflow roots should never split");
     1: 
 84217:   target->SetSize(boundsRelativeToTarget.Size());
 84217: 
 84217:   // Always use boundsRelativeToTarget here, not desiredSize.GetVisualOverflowArea(),
 84217:   // because for root frames (where they could be different, since root frames
 84217:   // are allowed to have overflow) the root view bounds need to match the
 84217:   // viewport bounds; the view manager "window dimensions" code depends on it.
     1:   nsContainerFrame::SyncFrameViewAfterReflow(mPresContext, target,
     1:                                              target->GetView(),
 84217:                                              boundsRelativeToTarget);
 31401:   nsContainerFrame::SyncWindowProperties(mPresContext, target,
 31401:                                          target->GetView());
     1: 
     1:   target->DidReflow(mPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
   967:   if (target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) {
 84217:     mPresContext->SetVisibleArea(boundsRelativeToTarget);
   967:   }
 27993: 
 27993: #ifdef DEBUG
 27993:   mCurrentReflowRoot = nsnull;
 27993: #endif
 27993: 
 27993:   NS_ASSERTION(mPresContext->HasPendingInterrupt() ||
 27993:                mFramesToDirty.Count() == 0,
 27993:                "Why do we need to dirty anything if not interrupted?");
 27993: 
 80486:   mIsReflowing = false;
 79445:   bool interrupted = mPresContext->HasPendingInterrupt();
 27993:   if (interrupted) {
 27993:     // Make sure target gets reflowed again.
 27993:     mFramesToDirty.EnumerateEntries(&MarkFramesDirtyToRoot, target);
 27993:     NS_ASSERTION(NS_SUBTREE_DIRTY(target), "Why is the target not dirty?");
 27993:     mDirtyRoots.AppendElement(target);
 84597:     mDocument->SetNeedLayoutFlush();
 27993: 
 27993:     // Clear mFramesToDirty after we've done the NS_SUBTREE_DIRTY(target)
 27993:     // assertion so that if it fails it's easier to see what's going on.
 27993: #ifdef NOISY_INTERRUPTIBLE_REFLOW
 27993:     printf("mFramesToDirty.Count() == %u\n", mFramesToDirty.Count());
 27993: #endif /* NOISY_INTERRUPTIBLE_REFLOW */
 27993:     mFramesToDirty.Clear();
 27993: 
 27993:     // Any FlushPendingNotifications with interruptible reflows
 27993:     // should be suppressed now. We don't want to do extra reflow work
 27993:     // before our reflow event happens.
 80486:     mSuppressInterruptibleReflows = true;
 38310:     MaybeScheduleReflow();
 27993:   }
 27993: 
 37502:   nsRootPresContext* rootPC = mPresContext->GetRootPresContext();
 37502:   if (rootPC) {
 47756:     rootPC->RequestUpdatePluginGeometry(target);
 37502:   }
 30522: 
 27993:   return !interrupted;
   790: }
     1: 
     1: #ifdef DEBUG
   790: void
   790: PresShell::DoVerifyReflow()
   790: {
     1:   if (GetVerifyReflowEnable()) {
     1:     // First synchronously render what we have so far so that we can
     1:     // see it.
 64435:     nsIView* rootView = mViewManager->GetRootView();
 87353:     mViewManager->InvalidateView(rootView);
     1: 
   790:     FlushPendingNotifications(Flush_Layout);
 80486:     mInVerifyReflow = true;
 79445:     bool ok = VerifyIncrementalReflow();
 80486:     mInVerifyReflow = false;
     1:     if (VERIFY_REFLOW_ALL & gVerifyReflowFlags) {
     1:       printf("ProcessReflowCommands: finished (%s)\n",
     1:              ok ? "ok" : "failed");
     1:     }
     1: 
 84596:     if (!mDirtyRoots.IsEmpty()) {
     1:       printf("XXX yikes! reflow commands queued during verify-reflow\n");
     1:     }
     1:   }
   790: }
     1: #endif
     1: 
 79445: bool
 79445: PresShell::ProcessReflowCommands(bool aInterruptible)
   790: {
 84596:   if (mDirtyRoots.IsEmpty() && !mShouldUnsuppressPainting) {
 84596:     // Nothing to do; bail out
 84596:     return true;
 84596:   }
 84596: 
 42480:   NS_TIME_FUNCTION_WITH_DOCURL;
 80773:   mozilla::TimeStamp timerStart = mozilla::TimeStamp::Now();
 79445:   bool interrupted = false;
 84596:   if (!mDirtyRoots.IsEmpty()) {
   790: 
   790: #ifdef DEBUG
   790:     if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
   790:       printf("ProcessReflowCommands: begin incremental reflow\n");
   790:     }
   790: #endif
   790: 
   790:     // If reflow is interruptible, then make a note of our deadline.
   790:     const PRIntervalTime deadline = aInterruptible
   790:         ? PR_IntervalNow() + PR_MicrosecondsToInterval(gMaxRCProcessingTime)
   790:         : (PRIntervalTime)0;
   790: 
  6171:     // Scope for the reflow entry point
  6171:     {
 13098:       nsAutoScriptBlocker scriptBlocker;
 29072:       WillDoReflow();
   790:       AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
 87348:       nsIViewManager::AutoDisableRefresh refreshBlocker(mViewManager);
   790: 
   790:       do {
   790:         // Send an incremental reflow notification to the target frame.
 24551:         PRInt32 idx = mDirtyRoots.Length() - 1;
 24551:         nsIFrame *target = mDirtyRoots[idx];
   790:         mDirtyRoots.RemoveElementAt(idx);
   790: 
  1158:         if (!NS_SUBTREE_DIRTY(target)) {
   790:           // It's not dirty anymore, which probably means the notification
   790:           // was posted in the middle of a reflow (perhaps with a reflow
   790:           // root in the middle).  Don't do anything.
   790:           continue;
   790:         }
   790: 
 27993:         interrupted = !DoReflow(target, aInterruptible);
   790: 
   790:         // Keep going until we're out of reflow commands, or we've run
 27993:         // past our deadline, or we're interrupted.
 84596:       } while (!interrupted && !mDirtyRoots.IsEmpty() &&
   790:                (!aInterruptible || PR_IntervalNow() < deadline));
   790: 
 84596:       interrupted = !mDirtyRoots.IsEmpty();
   790:     }
   790: 
 13098:     // Exiting the scriptblocker might have killed us
 13098:     if (!mIsDestroying) {
 27993:       DidDoReflow(aInterruptible);
 13098:     }
     1: 
  6162:     // DidDoReflow might have killed us
  6162:     if (!mIsDestroying) {
   790: #ifdef DEBUG
   790:       if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
  6162:         printf("\nPresShell::ProcessReflowCommands() finished: this=%p\n",
  6162:                (void*)this);
   790:       }
   790:       DoVerifyReflow();
   790: #endif
   790: 
   921:       // If any new reflow commands were enqueued during the reflow, schedule
   921:       // another reflow event to process them.  Note that we want to do this
   921:       // after DidDoReflow(), since that method can change whether there are
  6162:       // dirty roots around by flushing, and there's no point in posting a
  6162:       // reflow event just to have the flush revoke it.
 84597:       if (!mDirtyRoots.IsEmpty()) {
 38310:         MaybeScheduleReflow();
 84597:         // And tell our document that we might need flushing
 84597:         mDocument->SetNeedLayoutFlush();
 84597:       }
     1:     }
  6162:   }
     1: 
  6162:   if (!mIsDestroying && mShouldUnsuppressPainting &&
 84596:       mDirtyRoots.IsEmpty()) {
     1:     // We only unlock if we're out of reflows.  It's pointless
     1:     // to unlock if reflows are still pending, since reflows
     1:     // are just going to thrash the frames around some more.  By
     1:     // waiting we avoid an overeager "jitter" effect.
 80486:     mShouldUnsuppressPainting = false;
     1:     UnsuppressAndInvalidate();
     1:   }
     1: 
 87106:   if (mDocument->GetRootElement()) {
 89400:     Telemetry::ID id;
 89400:     if (mDocument->GetRootElement()->IsXUL()) {
 89400:       id = mIsActive
 89400:         ? Telemetry::XUL_FOREGROUND_REFLOW_MS
 89400:         : Telemetry::XUL_BACKGROUND_REFLOW_MS;
 89400:     } else {
 89400:       id = mIsActive
 89400:         ? Telemetry::HTML_FOREGROUND_REFLOW_MS
 89400:         : Telemetry::HTML_BACKGROUND_REFLOW_MS;
 89400:     }
 87106:     Telemetry::AccumulateTimeDelta(id, timerStart);
 80773:   }
 80773: 
 27993:   return !interrupted;
     1: }
     1: 
     1: #ifdef MOZ_XUL
     1: /*
     1:  * It's better to add stuff to the |DidSetStyleContext| method of the
     1:  * relevant frames than adding it here.  These methods should (ideally,
     1:  * anyway) go away.
     1:  */
     1: 
     1: // Return value says whether to walk children.
 79445: typedef bool (* frameWalkerFn)(nsIFrame *aFrame, void *aClosure);
 79445:    
 79445: static bool
     1: ReResolveMenusAndTrees(nsIFrame *aFrame, void *aClosure)
     1: {
     1:   // Trees have a special style cache that needs to be flushed when
     1:   // the theme changes.
 23554:   nsTreeBodyFrame *treeBody = do_QueryFrame(aFrame);
 20988:   if (treeBody)
 20988:     treeBody->ClearStyleAndImageCaches();
     1: 
     1:   // We deliberately don't re-resolve style on a menu's popup
     1:   // sub-content, since doing so slows menus to a crawl.  That means we
     1:   // have to special-case them on a skin switch, and ensure that the
     1:   // popup frames just get destroyed completely.
  3129:   if (aFrame && aFrame->GetType() == nsGkAtoms::menuFrame)
 80486:     (static_cast<nsMenuFrame *>(aFrame))->CloseMenu(true);
 80486:   return true;
     1: }
     1: 
 79445: static bool
     1: ReframeImageBoxes(nsIFrame *aFrame, void *aClosure)
     1: {
  3233:   nsStyleChangeList *list = static_cast<nsStyleChangeList*>(aClosure);
     1:   if (aFrame->GetType() == nsGkAtoms::imageBoxFrame) {
     1:     list->AppendChange(aFrame, aFrame->GetContent(),
     1:                        NS_STYLE_HINT_FRAMECHANGE);
 80486:     return false; // don't walk descendants
 80486:   }
 80486:   return true; // walk descendants
     1: }
     1: 
     1: static void
     1: WalkFramesThroughPlaceholders(nsPresContext *aPresContext, nsIFrame *aFrame,
     1:                               frameWalkerFn aFunc, void *aClosure)
     1: {
 79445:   bool walkChildren = (*aFunc)(aFrame, aClosure);
     1:   if (!walkChildren)
     1:     return;
     1: 
 77153:   nsIFrame::ChildListIterator lists(aFrame);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       nsIFrame* child = childFrames.get();
     1:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
     1:         // only do frames that are in flow, and recur through the
     1:         // out-of-flows of placeholders.
     1:         WalkFramesThroughPlaceholders(aPresContext,
     1:                                       nsPlaceholderFrame::GetRealFrameFor(child),
     1:                                       aFunc, aClosure);
     1:       }
 77153:     }
 77153:   }
     1: }
     1: #endif
     1: 
     1: NS_IMETHODIMP
     1: PresShell::Observe(nsISupports* aSubject, 
     1:                    const char* aTopic,
     1:                    const PRUnichar* aData)
     1: {
     1: #ifdef MOZ_XUL
     1:   if (!nsCRT::strcmp(aTopic, "chrome-flush-skin-caches")) {
 89328:     nsIFrame *rootFrame = mFrameConstructor->GetRootFrame();
     1:     // Need to null-check because "chrome-flush-skin-caches" can happen
     1:     // at interesting times during startup.
     1:     if (rootFrame) {
     1:       NS_ASSERTION(mViewManager, "View manager must exist");
     1: 
 36817:       nsWeakFrame weakRoot(rootFrame);
 36817:       // Have to make sure that the content notifications are flushed before we
 36817:       // start messing with the frame model; otherwise we can get content doubling.
 36817:       mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 36817: 
 36817:       if (weakRoot.IsAlive()) {
     1:         WalkFramesThroughPlaceholders(mPresContext, rootFrame,
     1:                                       &ReResolveMenusAndTrees, nsnull);
     1: 
     1:         // Because "chrome:" URL equality is messy, reframe image box
     1:         // frames (hack!).
     1:         nsStyleChangeList changeList;
     1:         WalkFramesThroughPlaceholders(mPresContext, rootFrame,
     1:                                       ReframeImageBoxes, &changeList);
  7017:         // Mark ourselves as not safe to flush while we're doing frame
  7017:         // construction.
 13098:         {
 13098:           nsAutoScriptBlocker scriptBlocker;
 29804:           ++mChangeNestCount;
     1:           mFrameConstructor->ProcessRestyledFrames(changeList);
 29804:           --mChangeNestCount;
 13098:         }
 36817:       }
     1:     }
     1:     return NS_OK;
     1:   }
     1: #endif
     1: 
     1:   if (!nsCRT::strcmp(aTopic, "agent-sheet-added") && mStyleSet) {
     1:     AddAgentSheet(aSubject);
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (!nsCRT::strcmp(aTopic, "user-sheet-added") && mStyleSet) {
     1:     AddUserSheet(aSubject);
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (!nsCRT::strcmp(aTopic, "agent-sheet-removed") && mStyleSet) {
     1:     RemoveSheet(nsStyleSet::eAgentSheet, aSubject);
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (!nsCRT::strcmp(aTopic, "user-sheet-removed") && mStyleSet) {
     1:     RemoveSheet(nsStyleSet::eUserSheet, aSubject);
     1:     return NS_OK;
     1:   }
     1: 
     1:   NS_WARNING("unrecognized topic in PresShell::Observe");
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 79445: bool
 43799: nsIPresShell::AddRefreshObserverInternal(nsARefreshObserver* aObserver,
 43799:                                          mozFlushType aFlushType)
 43799: {
 61723:   nsPresContext* presContext = GetPresContext();
 61723:   return presContext ? presContext->RefreshDriver()->
 80486:     AddRefreshObserver(aObserver, aFlushType) : false;
 43799: }
 43799: 
 79445: /* virtual */ bool
 43799: nsIPresShell::AddRefreshObserverExternal(nsARefreshObserver* aObserver,
 43799:                                          mozFlushType aFlushType)
 43799: {
 43799:   return AddRefreshObserverInternal(aObserver, aFlushType);
 43799: }
 43799: 
 79445: bool
 43799: nsIPresShell::RemoveRefreshObserverInternal(nsARefreshObserver* aObserver,
 43799:                                             mozFlushType aFlushType)
 43799: {
 61723:   nsPresContext* presContext = GetPresContext();
 61723:   return presContext ? presContext->RefreshDriver()->
 80486:     RemoveRefreshObserver(aObserver, aFlushType) : false;
 43799: }
 43799: 
 79445: /* virtual */ bool
 43799: nsIPresShell::RemoveRefreshObserverExternal(nsARefreshObserver* aObserver,
 43799:                                             mozFlushType aFlushType)
 43799: {
 43799:   return RemoveRefreshObserverInternal(aObserver, aFlushType);
 43799: }
 43799: 
     1: //------------------------------------------------------
     1: // End of protected and private methods on the PresShell
     1: //------------------------------------------------------
     1: 
     1: // Start of DEBUG only code
     1: 
102909: #ifdef DEBUG
     1: #include "nsIURL.h"
     1: #include "nsILinkHandler.h"
     1: 
     1: static NS_DEFINE_CID(kViewManagerCID, NS_VIEW_MANAGER_CID);
     1: 
     1: static void
     1: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg)
     1: {
 31709:   nsAutoString n1, n2;
 31709:   if (k1) {
 31709:     k1->GetFrameName(n1);
 31709:   } else {
 31709:     n1.Assign(NS_LITERAL_STRING("(null)"));
 31709:   }
 31709: 
 31709:   if (k2) {
 31709:     k2->GetFrameName(n2);
 31709:   } else {
 31709:     n2.Assign(NS_LITERAL_STRING("(null)"));
 31709:   }
 31709: 
 31709:   printf("verifyreflow: %s %p != %s %p  %s\n",
 31709:          NS_LossyConvertUTF16toASCII(n1).get(), (void*)k1,
 31709:          NS_LossyConvertUTF16toASCII(n2).get(), (void*)k2, aMsg);
     1: }
     1: 
     1: static void
     1: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg,
     1:                  const nsRect& r1, const nsRect& r2)
     1: {
     1:   printf("VerifyReflow Error:\n");
     1:   nsAutoString name;
 31709: 
 31709:   if (k1) {
 31709:     k1->GetFrameName(name);
 31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k1);
 31709:   }
 31709:   printf("{%d, %d, %d, %d} != \n", r1.x, r1.y, r1.width, r1.height);
 31709: 
 31709:   if (k2) {
 31709:     k2->GetFrameName(name);
 31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k2);
 31709:   }
 31709:   printf("{%d, %d, %d, %d}\n  %s\n",
 31709:          r2.x, r2.y, r2.width, r2.height, aMsg);
     1: }
     1: 
 23738: static void
 23738: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg,
 23738:                  const nsIntRect& r1, const nsIntRect& r2)
 23738: {
 23738:   printf("VerifyReflow Error:\n");
 23738:   nsAutoString name;
 31709: 
 31709:   if (k1) {
 31709:     k1->GetFrameName(name);
 31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k1);
 31709:   }
 31709:   printf("{%d, %d, %d, %d} != \n", r1.x, r1.y, r1.width, r1.height);
 31709: 
 31709:   if (k2) {
 31709:     k2->GetFrameName(name);
 31709:     printf("  %s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)k2);
 31709:   }
 31709:   printf("{%d, %d, %d, %d}\n  %s\n",
 31709:          r2.x, r2.y, r2.width, r2.height, aMsg);
 23738: }
 23738: 
 79445: static bool
     1: CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame, 
     1:              nsPresContext* aSecondPresContext, nsIFrame* aSecondFrame)
     1: {
     1:   if (!aFirstPresContext || !aFirstFrame || !aSecondPresContext || !aSecondFrame)
 80486:     return true;
  1735:   // XXX Evil hack to reduce false positives; I can't seem to figure
  1735:   // out how to flush scrollbar changes correctly
  1735:   //if (aFirstFrame->GetType() == nsGkAtoms::scrollbarFrame)
 80486:   //  return true;
 79445:   bool ok = true;
 77153:   nsIFrame::ChildListIterator lists1(aFirstFrame);
 77153:   nsIFrame::ChildListIterator lists2(aSecondFrame);
     1:   do {
 77153:     const nsFrameList& kids1 = !lists1.IsDone() ? lists1.CurrentList() : nsFrameList();
 77153:     const nsFrameList& kids2 = !lists2.IsDone() ? lists2.CurrentList() : nsFrameList();
 30787:     PRInt32 l1 = kids1.GetLength();
 30787:     PRInt32 l2 = kids2.GetLength();;
     1:     if (l1 != l2) {
 80486:       ok = false;
 30787:       LogVerifyMessage(kids1.FirstChild(), kids2.FirstChild(),
 30787:                        "child counts don't match: ");
     1:       printf("%d != %d\n", l1, l2);
     1:       if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
     1:         break;
     1:       }
     1:     }
     1: 
 23738:     nsIntRect r1, r2;
     1:     nsIView* v1, *v2;
 30787:     for (nsFrameList::Enumerator e1(kids1), e2(kids2);
 30787:          ;
 30787:          e1.Next(), e2.Next()) {
 30787:       nsIFrame* k1 = e1.get();
 30787:       nsIFrame* k2 = e2.get();
     1:       if (((nsnull == k1) && (nsnull != k2)) ||
     1:           ((nsnull != k1) && (nsnull == k2))) {
 80486:         ok = false;
     1:         LogVerifyMessage(k1, k2, "child lists are different\n");
     1:         break;
     1:       }
     1:       else if (nsnull != k1) {
     1:         // Verify that the frames are the same size
 68638:         if (!k1->GetRect().IsEqualInterior(k2->GetRect())) {
 80486:           ok = false;
     1:           LogVerifyMessage(k1, k2, "(frame rects)", k1->GetRect(), k2->GetRect());
     1:         }
     1: 
     1:         // Make sure either both have views or neither have views; if they
     1:         // do have views, make sure the views are the same size. If the
     1:         // views have widgets, make sure they both do or neither does. If
     1:         // they do, make sure the widgets are the same size.
     1:         v1 = k1->GetView();
     1:         v2 = k2->GetView();
     1:         if (((nsnull == v1) && (nsnull != v2)) ||
     1:             ((nsnull != v1) && (nsnull == v2))) {
 80486:           ok = false;
     1:           LogVerifyMessage(k1, k2, "child views are not matched\n");
     1:         }
     1:         else if (nsnull != v1) {
 68638:           if (!v1->GetBounds().IsEqualInterior(v2->GetBounds())) {
     1:             LogVerifyMessage(k1, k2, "(view rects)", v1->GetBounds(), v2->GetBounds());
     1:           }
     1: 
     1:           nsIWidget* w1 = v1->GetWidget();
     1:           nsIWidget* w2 = v2->GetWidget();
     1:           if (((nsnull == w1) && (nsnull != w2)) ||
     1:               ((nsnull != w1) && (nsnull == w2))) {
 80486:             ok = false;
     1:             LogVerifyMessage(k1, k2, "child widgets are not matched\n");
     1:           }
     1:           else if (nsnull != w1) {
     1:             w1->GetBounds(r1);
     1:             w2->GetBounds(r2);
 68638:             if (!r1.IsEqualEdges(r2)) {
     1:               LogVerifyMessage(k1, k2, "(widget rects)", r1, r2);
     1:             }
     1:           }
     1:         }
     1:         if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
     1:           break;
     1:         }
     1: 
 23300:         // XXX Should perhaps compare their float managers.
     1: 
     1:         // Compare the sub-trees too
     1:         if (!CompareTrees(aFirstPresContext, k1, aSecondPresContext, k2)) {
 80486:           ok = false;
     1:           if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
     1:             break;
     1:           }
     1:         }
     1:       }
     1:       else {
     1:         break;
     1:       }
     1:     }
     1:     if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
     1:       break;
     1:     }
     1: 
 77153:     lists1.Next();
 77153:     lists2.Next();
 77153:     if (lists1.IsDone() != lists2.IsDone() ||
 77153:         (!lists1.IsDone() && lists1.CurrentID() != lists2.CurrentID())) {
     1:       if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
 80486:         ok = false;
     1:       }
 30787:       LogVerifyMessage(kids1.FirstChild(), kids2.FirstChild(),
 30787:                        "child list names are not matched: ");
 77153:       fprintf(stdout, "%s != %s\n",
 77153:               !lists1.IsDone() ? mozilla::layout::ChildListName(lists1.CurrentID()) : "(null)",
 77153:               !lists2.IsDone() ? mozilla::layout::ChildListName(lists2.CurrentID()) : "(null)");
     1:       break;
     1:     }
 77153:   } while (ok && !lists1.IsDone());
     1: 
     1:   return ok;
     1: }
     1: #endif
     1: 
     1: #if 0
     1: static nsIFrame*
     1: FindTopFrame(nsIFrame* aRoot)
     1: {
     1:   if (aRoot) {
     1:     nsIContent* content = aRoot->GetContent();
     1:     if (content) {
     1:       nsIAtom* tag;
     1:       content->GetTag(tag);
     1:       if (nsnull != tag) {
     1:         NS_RELEASE(tag);
     1:         return aRoot;
     1:       }
     1:     }
     1: 
     1:     // Try one of the children
 77154:     nsIFrame* kid = aRoot->GetFirstPrincipalChild();
     1:     while (nsnull != kid) {
     1:       nsIFrame* result = FindTopFrame(kid);
     1:       if (nsnull != result) {
     1:         return result;
     1:       }
     1:       kid = kid->GetNextSibling();
     1:     }
     1:   }
     1:   return nsnull;
     1: }
     1: #endif
     1: 
     1: 
     1: #ifdef DEBUG
     1: 
 72504: nsStyleSet*
 72504: PresShell::CloneStyleSet(nsStyleSet* aSet)
     1: {
     1:   nsStyleSet *clone = new nsStyleSet();
     1: 
     1:   PRInt32 i, n = aSet->SheetCount(nsStyleSet::eOverrideSheet);
     1:   for (i = 0; i < n; i++) {
     1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eOverrideSheet, i);
     1:     if (ss)
     1:       clone->AppendStyleSheet(nsStyleSet::eOverrideSheet, ss);
     1:   }
     1: 
  1735:   // The document expects to insert document stylesheets itself
  1735: #if 0
     1:   n = aSet->SheetCount(nsStyleSet::eDocSheet);
     1:   for (i = 0; i < n; i++) {
     1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eDocSheet, i);
     1:     if (ss)
     1:       clone->AddDocStyleSheet(ss, mDocument);
     1:   }
  1735: #endif
  1735: 
     1:   n = aSet->SheetCount(nsStyleSet::eUserSheet);
     1:   for (i = 0; i < n; i++) {
     1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eUserSheet, i);
     1:     if (ss)
     1:       clone->AppendStyleSheet(nsStyleSet::eUserSheet, ss);
     1:   }
     1: 
     1:   n = aSet->SheetCount(nsStyleSet::eAgentSheet);
     1:   for (i = 0; i < n; i++) {
     1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eAgentSheet, i);
     1:     if (ss)
     1:       clone->AppendStyleSheet(nsStyleSet::eAgentSheet, ss);
     1:   }
 72504:   return clone;
     1: }
     1: 
  1735: #ifdef DEBUG_Eli
  1735: static nsresult
  1735: DumpToPNG(nsIPresShell* shell, nsAString& name) {
  1735:   PRInt32 width=1000, height=1000;
  1735:   nsRect r(0, 0, shell->GetPresContext()->DevPixelsToAppUnits(width),
  1735:                  shell->GetPresContext()->DevPixelsToAppUnits(height));
  1735: 
  1735:   nsRefPtr<gfxImageSurface> imgSurface =
  1735:      new gfxImageSurface(gfxIntSize(width, height),
  1735:                          gfxImageSurface::ImageFormatARGB32);
  1735: 
  1735:   nsRefPtr<gfxContext> imgContext = new gfxContext(imgSurface);
  1735: 
  1735:   nsRefPtr<gfxASurface> surface = 
  1735:     gfxPlatform::GetPlatform()->
  1735:     CreateOffscreenSurface(gfxIntSize(width, height),
 54254:       gfxASurface::ContentFromFormat(gfxASurface::ImageFormatARGB32));
  1735:   NS_ENSURE_TRUE(surface, NS_ERROR_OUT_OF_MEMORY);
  1735: 
  1735:   nsRefPtr<gfxContext> context = new gfxContext(surface);
  1735: 
 40052:   shell->RenderDocument(r, 0, NS_RGB(255, 255, 0), context);
  1735: 
  1735:   imgContext->DrawSurface(surface, gfxSize(width, height));
  1735: 
  1735:   nsCOMPtr<imgIEncoder> encoder = do_CreateInstance("@mozilla.org/image/encoder;2?type=image/png");
  1735:   NS_ENSURE_TRUE(encoder, NS_ERROR_FAILURE);
  1735:   encoder->InitFromData(imgSurface->Data(), imgSurface->Stride() * height,
  1735:                         width, height, imgSurface->Stride(),
  1735:                         imgIEncoder::INPUT_FORMAT_HOSTARGB, EmptyString());
  1735: 
  1735:   // XXX not sure if this is the right way to write to a file
101111:   nsCOMPtr<nsIFile> file = do_CreateInstance("@mozilla.org/file/local;1");
  1735:   NS_ENSURE_TRUE(file, NS_ERROR_FAILURE);
  1735:   rv = file->InitWithPath(name);
  1735:   NS_ENSURE_SUCCESS(rv, rv);
  1735: 
  1735:   PRUint32 length;
  1735:   encoder->Available(&length);
  1735: 
  1735:   nsCOMPtr<nsIOutputStream> outputStream;
  1735:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(outputStream), file);
  1735:   NS_ENSURE_SUCCESS(rv, rv);
  1735: 
  1735:   nsCOMPtr<nsIOutputStream> bufferedOutputStream;
  1735:   rv = NS_NewBufferedOutputStream(getter_AddRefs(bufferedOutputStream),
  1735:                                   outputStream, length);
  1735: 
  1735:   PRUint32 numWritten;
  1735:   rv = bufferedOutputStream->WriteFrom(encoder, length, &numWritten);
  1735:   NS_ENSURE_SUCCESS(rv, rv);
  1735: 
  1735:   return NS_OK;
  1735: }
  1735: #endif
  1735: 
     1: // After an incremental reflow, we verify the correctness by doing a
     1: // full reflow into a fresh frame tree.
 79445: bool
     1: PresShell::VerifyIncrementalReflow()
     1: {
     1:    if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
     1:      printf("Building Verification Tree...\n");
     1:    }
     1: 
     1:   // Create a presentation context to view the new frame tree
 39823:   nsRefPtr<nsPresContext> cx =
 30514:        new nsRootPresContext(mDocument, mPresContext->IsPaginated() ?
     1:                                         nsPresContext::eContext_PrintPreview :
   790:                                         nsPresContext::eContext_Galley);
 80486:   NS_ENSURE_TRUE(cx, false);
     1: 
 68668:   nsDeviceContext *dc = mPresContext->DeviceContext();
     1:   nsresult rv = cx->Init(dc);
 80486:   NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:   // Get our scrolling preference
 64435:   nsIView* rootView = mViewManager->GetRootView();
 80486:   NS_ENSURE_TRUE(rootView->HasWidget(), false);
 51048:   nsIWidget* parentWidget = rootView->GetWidget();
     1: 
     1:   // Create a new view manager.
   790:   nsCOMPtr<nsIViewManager> vm = do_CreateInstance(kViewManagerCID);
 80486:   NS_ENSURE_TRUE(vm, false);
     1:   rv = vm->Init(dc);
 80486:   NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:   // Create a child window of the parent that is our "root view/window"
     1:   // Create a view
     1:   nsRect tbounds = mPresContext->GetVisibleArea();
     1:   nsIView* view = vm->CreateView(tbounds, nsnull);
 80486:   NS_ENSURE_TRUE(view, false);
     1: 
     1:   //now create the widget for the view
 80486:   rv = view->CreateWidgetForParent(parentWidget, nsnull, true);
 80486:   NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:   // Setup hierarchical relationship in view manager
     1:   vm->SetRootView(view);
     1: 
     1:   // Make the new presentation context the same size as our
     1:   // presentation context.
     1:   nsRect r = mPresContext->GetVisibleArea();
     1:   cx->SetVisibleArea(r);
     1: 
     1:   // Create a new presentation shell to view the document. Use the
     1:   // exact same style information that this document has.
 72504:   nsAutoPtr<nsStyleSet> newSet(CloneStyleSet(mStyleSet));
   790:   nsCOMPtr<nsIPresShell> sh;
   790:   rv = mDocument->CreateShell(cx, vm, newSet, getter_AddRefs(sh));
 80486:   NS_ENSURE_SUCCESS(rv, false);
   790:   newSet.forget();
   790:   // Note that after we create the shell, we must make sure to destroy it
 80486:   sh->SetVerifyReflowEnable(false); // turn off verify reflow while we're reflowing the test frame tree
 82568:   vm->SetPresShell(sh);
 22979:   {
 29804:     nsAutoCauseReflowNotifier crNotifier(this);
   790:     sh->InitialReflow(r.width, r.height);
 22979:   }
   790:   mDocument->BindingManager()->ProcessAttachedQueue();
   790:   sh->FlushPendingNotifications(Flush_Layout);
 80486:   sh->SetVerifyReflowEnable(true);  // turn on verify reflow again now that we're done reflowing the test frame tree
  1735:   // Force the non-primary presshell to unsuppress; it doesn't want to normally
  1735:   // because it thinks it's hidden
 80486:   ((PresShell*)sh.get())->mPaintingSuppressed = false;
     1:   if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
     1:      printf("Verification Tree built, comparing...\n");
     1:   }
     1: 
     1:   // Now that the document has been reflowed, use its frame tree to
     1:   // compare against our frame tree.
 89328:   nsIFrame* root1 = mFrameConstructor->GetRootFrame();
 89328:   nsIFrame* root2 = sh->GetRootFrame();
 79445:   bool ok = CompareTrees(mPresContext, root1, cx, root2);
     1:   if (!ok && (VERIFY_REFLOW_NOISY & gVerifyReflowFlags)) {
     1:     printf("Verify reflow failed, primary tree:\n");
 31709:     root1->List(stdout, 0);
     1:     printf("Verification tree:\n");
 31709:     root2->List(stdout, 0);
     1:   }
     1: 
  1735: #ifdef DEBUG_Eli
  1735:   // Sample code for dumping page to png
  1735:   // XXX Needs to be made more flexible
  1735:   if (!ok) {
  1735:     nsString stra;
  1735:     static int num = 0;
  1735:     stra.AppendLiteral("C:\\mozilla\\mozilla\\debug\\filea");
  1735:     stra.AppendInt(num);
  1735:     stra.AppendLiteral(".png");
  1735:     DumpToPNG(sh, stra);
  1735:     nsString strb;
  1735:     strb.AppendLiteral("C:\\mozilla\\mozilla\\debug\\fileb");
  1735:     strb.AppendInt(num);
  1735:     strb.AppendLiteral(".png");
  1735:     DumpToPNG(this, strb);
  1735:     ++num;
  1735:   }
  1735: #endif
  1735: 
     1:   sh->EndObservingDocument();
   790:   sh->Destroy();
     1:   if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
     1:     printf("Finished Verifying Reflow...\n");
     1:   }
     1: 
     1:   return ok;
     1: }
     1: 
     1: // Layout debugging hooks
     1: void
     1: PresShell::ListStyleContexts(nsIFrame *aRootFrame, FILE *out, PRInt32 aIndent)
     1: {
     1:   nsStyleContext *sc = aRootFrame->GetStyleContext();
     1:   if (sc)
     1:     sc->List(out, aIndent);
     1: }
     1: 
     1: void
     1: PresShell::ListStyleSheets(FILE *out, PRInt32 aIndent)
     1: {
     1:   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eDocSheet);
     1:   for (PRInt32 i = 0; i < sheetCount; ++i) {
     1:     mStyleSet->StyleSheetAt(nsStyleSet::eDocSheet, i)->List(out, aIndent);
     1:     fputs("\n", out);
     1:   }
     1: }
     1: 
     1: void
     1: PresShell::VerifyStyleTree()
     1: {
     1:   VERIFY_STYLE_TREE;
     1: }
     1: #endif
     1: 
     1: //=============================================================
     1: //=============================================================
     1: //-- Debug Reflow Counts
     1: //=============================================================
     1: //=============================================================
     1: #ifdef MOZ_REFLOW_PERF
     1: //-------------------------------------------------------------
 40052: void
     1: PresShell::DumpReflows()
     1: {
     1:   if (mReflowCountMgr) {
     1:     nsCAutoString uriStr;
     1:     if (mDocument) {
     1:       nsIURI *uri = mDocument->GetDocumentURI();
     1:       if (uri) {
     1:         uri->GetPath(uriStr);
     1:       }
     1:     }
     1:     mReflowCountMgr->DisplayTotals(uriStr.get());
     1:     mReflowCountMgr->DisplayHTMLTotals(uriStr.get());
     1:     mReflowCountMgr->DisplayDiffsInTotals("Differences");
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
 40052: void
     1: PresShell::CountReflows(const char * aName, nsIFrame * aFrame)
     1: {
     1:   if (mReflowCountMgr) {
     1:     mReflowCountMgr->Add(aName, aFrame);
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
 40052: void
 40052: PresShell::PaintCount(const char * aName,
 68481:                       nsRenderingContext* aRenderingContext,
 40052:                       nsPresContext* aPresContext,
 40052:                       nsIFrame * aFrame,
 68487:                       const nsPoint& aOffset,
 40052:                       PRUint32 aColor)
     1: {
     1:   if (mReflowCountMgr) {
 68487:     mReflowCountMgr->PaintCount(aName, aRenderingContext, aPresContext,
 68487:                                 aFrame, aOffset, aColor);
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
 40052: void
 79445: PresShell::SetPaintFrameCount(bool aPaintFrameCounts)
     1: {
     1:   if (mReflowCountMgr) {
     1:     mReflowCountMgr->SetPaintFrameCounts(aPaintFrameCounts);
     1:   }
     1: }
     1: 
 79445: bool
 30512: PresShell::IsPaintingFrameCounts()
 30512: {
 30512:   if (mReflowCountMgr)
 30512:     return mReflowCountMgr->IsPaintingFrameCounts();
 80486:   return false;
 30512: }
 30512: 
     1: //------------------------------------------------------------------
     1: //-- Reflow Counter Classes Impls
     1: //------------------------------------------------------------------
     1: 
     1: //------------------------------------------------------------------
     1: ReflowCounter::ReflowCounter(ReflowCountMgr * aMgr) :
     1:   mMgr(aMgr)
     1: {
     1:   ClearTotals();
     1:   SetTotalsCache();
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: ReflowCounter::~ReflowCounter()
     1: {
     1:   
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::ClearTotals()
     1: {
     1:   mTotal = 0;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::SetTotalsCache()
     1: {
     1:   mCacheTotal = mTotal;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::CalcDiffInTotals()
     1: {
     1:   mCacheTotal = mTotal - mCacheTotal;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::DisplayTotals(const char * aStr)
     1: {
     1:   DisplayTotals(mTotal, aStr?aStr:"Totals");
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::DisplayDiffTotals(const char * aStr)
     1: {
     1:   DisplayTotals(mCacheTotal, aStr?aStr:"Diff Totals");
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::DisplayHTMLTotals(const char * aStr)
     1: {
     1:   DisplayHTMLTotals(mTotal, aStr?aStr:"Totals");
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::DisplayTotals(PRUint32 aTotal, const char * aTitle)
     1: {
     1:   // figure total
     1:   if (aTotal == 0) {
     1:     return;
     1:   }
     1:   ReflowCounter * gTots = (ReflowCounter *)mMgr->LookUp(kGrandTotalsStr);
     1: 
     1:   printf("%25s\t", aTitle);
     1:   printf("%d\t", aTotal);
     1:   if (gTots != this && aTotal > 0) {
     1:     gTots->Add(aTotal);
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCounter::DisplayHTMLTotals(PRUint32 aTotal, const char * aTitle)
     1: {
     1:   if (aTotal == 0) {
     1:     return;
     1:   }
     1: 
     1:   ReflowCounter * gTots = (ReflowCounter *)mMgr->LookUp(kGrandTotalsStr);
     1:   FILE * fd = mMgr->GetOutFile();
     1:   if (!fd) {
     1:     return;
     1:   }
     1: 
     1:   fprintf(fd, "<tr><td><center>%s</center></td>", aTitle);
     1:   fprintf(fd, "<td><center>%d</center></td></tr>\n", aTotal);
     1: 
     1:   if (gTots != this && aTotal > 0) {
     1:     gTots->Add(aTotal);
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: //-- ReflowCountMgr
     1: //------------------------------------------------------------------
 93217: 
 93217: #define KEY_BUF_SIZE_FOR_PTR  24 // adequate char[] buffer to sprintf a pointer
 93217: 
     1: ReflowCountMgr::ReflowCountMgr()
     1: {
     1:   mCounts = PL_NewHashTable(10, PL_HashString, PL_CompareStrings, 
     1:                                 PL_CompareValues, nsnull, nsnull);
     1:   mIndiFrameCounts = PL_NewHashTable(10, PL_HashString, PL_CompareStrings, 
     1:                                      PL_CompareValues, nsnull, nsnull);
 80486:   mCycledOnce              = false;
 80486:   mDumpFrameCounts         = false;
 80486:   mDumpFrameByFrameCounts  = false;
 80486:   mPaintFrameByFrameCounts = false;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: ReflowCountMgr::~ReflowCountMgr()
     1: {
     1:   CleanUp();
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: ReflowCounter * ReflowCountMgr::LookUp(const char * aName)
     1: {
     1:   if (nsnull != mCounts) {
     1:     ReflowCounter * counter = (ReflowCounter *)PL_HashTableLookup(mCounts, aName);
     1:     return counter;
     1:   }
     1:   return nsnull;
     1: 
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::Add(const char * aName, nsIFrame * aFrame)
     1: {
     1:   NS_ASSERTION(aName != nsnull, "Name shouldn't be null!");
     1: 
     1:   if (mDumpFrameCounts && nsnull != mCounts) {
     1:     ReflowCounter * counter = (ReflowCounter *)PL_HashTableLookup(mCounts, aName);
     1:     if (counter == nsnull) {
     1:       counter = new ReflowCounter(this);
     1:       char * name = NS_strdup(aName);
     1:       NS_ASSERTION(name != nsnull, "null ptr");
     1:       PL_HashTableAdd(mCounts, name, counter);
     1:     }
     1:     counter->Add();
     1:   }
     1: 
     1:   if ((mDumpFrameByFrameCounts || mPaintFrameByFrameCounts) && 
     1:       nsnull != mIndiFrameCounts && 
     1:       aFrame != nsnull) {
 93217:     char key[KEY_BUF_SIZE_FOR_PTR];
     1:     sprintf(key, "%p", (void*)aFrame);
     1:     IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(mIndiFrameCounts, key);
     1:     if (counter == nsnull) {
     1:       counter = new IndiReflowCounter(this);
     1:       counter->mFrame = aFrame;
     1:       counter->mName.AssignASCII(aName);
 93217:       PL_HashTableAdd(mIndiFrameCounts, NS_strdup(key), counter);
     1:     }
     1:     // this eliminates extra counts from super classes
     1:     if (counter != nsnull && counter->mName.EqualsASCII(aName)) {
     1:       counter->mCount++;
     1:       counter->mCounter.Add(1);
     1:     }
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::PaintCount(const char*     aName,
 68481:                                 nsRenderingContext* aRenderingContext,
     1:                                 nsPresContext*  aPresContext,
     1:                                 nsIFrame*       aFrame,
 68487:                                 const nsPoint&  aOffset,
     1:                                 PRUint32        aColor)
     1: {
     1:   if (mPaintFrameByFrameCounts &&
     1:       nsnull != mIndiFrameCounts &&
     1:       aFrame != nsnull) {
 93217:     char key[KEY_BUF_SIZE_FOR_PTR];
     1:     sprintf(key, "%p", (void*)aFrame);
 68487:     IndiReflowCounter * counter =
 68487:       (IndiReflowCounter *)PL_HashTableLookup(mIndiFrameCounts, key);
     1:     if (counter != nsnull && counter->mName.EqualsASCII(aName)) {
     1:       aRenderingContext->PushState();
 68487:       aRenderingContext->Translate(aOffset);
     1:       nsFont font("Times", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
 24408:                   NS_FONT_WEIGHT_NORMAL, NS_FONT_STRETCH_NORMAL, 0,
     1:                   nsPresContext::CSSPixelsToAppUnits(11));
     1: 
 76297:       nsRefPtr<nsFontMetrics> fm;
 76297:       aPresContext->DeviceContext()->GetMetricsFor(font,
 76297:         // We have one frame, therefore we must have a root...
 89328:         aPresContext->GetPresShell()->GetRootFrame()->
 88039:           GetStyleFont()->mLanguage,
 76297:         aPresContext->GetUserFontSet(), *getter_AddRefs(fm));
 76297: 
     1:       aRenderingContext->SetFont(fm);
     1:       char buf[16];
     1:       sprintf(buf, "%d", counter->mCount);
 68495:       nscoord x = 0, y = fm->MaxAscent();
 68495:       nscoord width, height = fm->MaxHeight();
 80486:       aRenderingContext->SetTextRunRTL(false);
 69217:       width = aRenderingContext->GetWidth(buf);
     1: 
     1:       PRUint32 color;
     1:       PRUint32 color2;
     1:       if (aColor != 0) {
     1:         color  = aColor;
     1:         color2 = NS_RGB(0,0,0);
     1:       } else {
     1:         PRUint8 rc = 0, gc = 0, bc = 0;
     1:         if (counter->mCount < 5) {
     1:           rc = 255;
     1:           gc = 255;
     1:         } else if ( counter->mCount < 11) {
     1:           gc = 255;
     1:         } else {
     1:           rc = 255;
     1:         }
     1:         color  = NS_RGB(rc,gc,bc);
     1:         color2 = NS_RGB(rc/2,gc/2,bc/2);
     1:       }
     1: 
     1:       nsRect rect(0,0, width+15, height+15);
     1:       aRenderingContext->SetColor(NS_RGB(0,0,0));
     1:       aRenderingContext->FillRect(rect);
     1:       aRenderingContext->SetColor(color2);
     1:       aRenderingContext->DrawString(buf, strlen(buf), x+15,y+15);
     1:       aRenderingContext->SetColor(color);
     1:       aRenderingContext->DrawString(buf, strlen(buf), x,y);
     1: 
     1:       aRenderingContext->PopState();
     1:     }
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::RemoveItems(PLHashEntry *he, PRIntn i, void *arg)
     1: {
     1:   char *str = (char *)he->key;
     1:   ReflowCounter * counter = (ReflowCounter *)he->value;
     1:   delete counter;
     1:   NS_Free(str);
     1: 
     1:   return HT_ENUMERATE_REMOVE;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::RemoveIndiItems(PLHashEntry *he, PRIntn i, void *arg)
     1: {
     1:   char *str = (char *)he->key;
     1:   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
     1:   delete counter;
     1:   NS_Free(str);
     1: 
     1:   return HT_ENUMERATE_REMOVE;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::CleanUp()
     1: {
     1:   if (nsnull != mCounts) {
     1:     PL_HashTableEnumerateEntries(mCounts, RemoveItems, nsnull);
     1:     PL_HashTableDestroy(mCounts);
     1:     mCounts = nsnull;
     1:   }
     1: 
     1:   if (nsnull != mIndiFrameCounts) {
     1:     PL_HashTableEnumerateEntries(mIndiFrameCounts, RemoveIndiItems, nsnull);
     1:     PL_HashTableDestroy(mIndiFrameCounts);
     1:     mIndiFrameCounts = nsnull;
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::DoSingleTotal(PLHashEntry *he, PRIntn i, void *arg)
     1: {
     1:   char *str = (char *)he->key;
     1:   ReflowCounter * counter = (ReflowCounter *)he->value;
     1: 
     1:   counter->DisplayTotals(str);
     1: 
     1:   return HT_ENUMERATE_NEXT;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::DoGrandTotals()
     1: {
     1:   if (nsnull != mCounts) {
     1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
     1:     if (gTots == nsnull) {
     1:       gTots = new ReflowCounter(this);
     1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
     1:     } else {
     1:       gTots->ClearTotals();
     1:     }
     1: 
     1:     printf("\t\t\t\tTotal\n");
     1:     for (PRUint32 i=0;i<78;i++) {
     1:       printf("-");
     1:     }
     1:     printf("\n");
     1:     PL_HashTableEnumerateEntries(mCounts, DoSingleTotal, this);
     1:   }
     1: }
     1: 
     1: static void RecurseIndiTotals(nsPresContext* aPresContext, 
     1:                               PLHashTable *   aHT, 
     1:                               nsIFrame *      aParentFrame,
     1:                               PRInt32         aLevel)
     1: {
     1:   if (aParentFrame == nsnull) {
     1:     return;
     1:   }
     1: 
 93217:   char key[KEY_BUF_SIZE_FOR_PTR];
     1:   sprintf(key, "%p", (void*)aParentFrame);
     1:   IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(aHT, key);
     1:   if (counter) {
 80486:     counter->mHasBeenOutput = true;
     1:     char * name = ToNewCString(counter->mName);
     1:     for (PRInt32 i=0;i<aLevel;i++) printf(" ");
     1:     printf("%s - %p   [%d][", name, (void*)aParentFrame, counter->mCount);
     1:     printf("%d", counter->mCounter.GetTotal());
     1:     printf("]\n");
     1:     nsMemory::Free(name);
     1:   }
     1: 
 77154:   nsIFrame* child = aParentFrame->GetFirstPrincipalChild();
     1:   while (child) {
     1:     RecurseIndiTotals(aPresContext, aHT, child, aLevel+1);
     1:     child = child->GetNextSibling();
     1:   }
     1: 
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::DoSingleIndi(PLHashEntry *he, PRIntn i, void *arg)
     1: {
     1:   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
     1:   if (counter && !counter->mHasBeenOutput) {
     1:     char * name = ToNewCString(counter->mName);
     1:     printf("%s - %p   [%d][", name, (void*)counter->mFrame, counter->mCount);
     1:     printf("%d", counter->mCounter.GetTotal());
     1:     printf("]\n");
     1:     nsMemory::Free(name);
     1:   }
     1:   return HT_ENUMERATE_NEXT;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::DoIndiTotalsTree()
     1: {
     1:   if (nsnull != mCounts) {
     1:     printf("\n------------------------------------------------\n");
     1:     printf("-- Individual Frame Counts\n");
     1:     printf("------------------------------------------------\n");
     1: 
     1:     if (mPresShell) {
     1:       nsIFrame * rootFrame = mPresShell->FrameManager()->GetRootFrame();
     1:       RecurseIndiTotals(mPresContext, mIndiFrameCounts, rootFrame, 0);
     1:       printf("------------------------------------------------\n");
     1:       printf("-- Individual Counts of Frames not in Root Tree\n");
     1:       printf("------------------------------------------------\n");
     1:       PL_HashTableEnumerateEntries(mIndiFrameCounts, DoSingleIndi, this);
     1:     }
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::DoSingleHTMLTotal(PLHashEntry *he, PRIntn i, void *arg)
     1: {
     1:   char *str = (char *)he->key;
     1:   ReflowCounter * counter = (ReflowCounter *)he->value;
     1: 
     1:   counter->DisplayHTMLTotals(str);
     1: 
     1:   return HT_ENUMERATE_NEXT;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::DoGrandHTMLTotals()
     1: {
     1:   if (nsnull != mCounts) {
     1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
     1:     if (gTots == nsnull) {
     1:       gTots = new ReflowCounter(this);
     1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
     1:     } else {
     1:       gTots->ClearTotals();
     1:     }
     1: 
     1:     static const char * title[] = {"Class", "Reflows"};
     1:     fprintf(mFD, "<tr>");
 80467:     for (PRUint32 i=0; i < ArrayLength(title); i++) {
     1:       fprintf(mFD, "<td><center><b>%s<b></center></td>", title[i]);
     1:     }
     1:     fprintf(mFD, "</tr>\n");
     1:     PL_HashTableEnumerateEntries(mCounts, DoSingleHTMLTotal, this);
     1:   }
     1: }
     1: 
     1: //------------------------------------
     1: void ReflowCountMgr::DisplayTotals(const char * aStr)
     1: {
     1: #ifdef DEBUG_rods
     1:   printf("%s\n", aStr?aStr:"No name");
     1: #endif
     1:   if (mDumpFrameCounts) {
     1:     DoGrandTotals();
     1:   }
     1:   if (mDumpFrameByFrameCounts) {
     1:     DoIndiTotalsTree();
     1:   }
     1: 
     1: }
     1: //------------------------------------
     1: void ReflowCountMgr::DisplayHTMLTotals(const char * aStr)
     1: {
     1: #ifdef WIN32x // XXX NOT XP!
     1:   char name[1024];
     1:   
     1:   char * sptr = strrchr(aStr, '/');
     1:   if (sptr) {
     1:     sptr++;
     1:     strcpy(name, sptr);
     1:     char * eptr = strrchr(name, '.');
     1:     if (eptr) {
     1:       *eptr = 0;
     1:     }
     1:     strcat(name, "_stats.html");
     1:   }
     1:   mFD = fopen(name, "w");
     1:   if (mFD) {
     1:     fprintf(mFD, "<html><head><title>Reflow Stats</title></head><body>\n");
     1:     const char * title = aStr?aStr:"No name";
     1:     fprintf(mFD, "<center><b>%s</b><br><table border=1 style=\"background-color:#e0e0e0\">", title);
     1:     DoGrandHTMLTotals();
     1:     fprintf(mFD, "</center></table>\n");
     1:     fprintf(mFD, "</body></html>\n");
     1:     fclose(mFD);
     1:     mFD = nsnull;
     1:   }
     1: #endif // not XP!
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::DoClearTotals(PLHashEntry *he, PRIntn i, void *arg)
     1: {
     1:   ReflowCounter * counter = (ReflowCounter *)he->value;
     1:   counter->ClearTotals();
     1: 
     1:   return HT_ENUMERATE_NEXT;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::ClearTotals()
     1: {
     1:   PL_HashTableEnumerateEntries(mCounts, DoClearTotals, this);
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::ClearGrandTotals()
     1: {
     1:   if (nsnull != mCounts) {
     1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
     1:     if (gTots == nsnull) {
     1:       gTots = new ReflowCounter(this);
     1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
     1:     } else {
     1:       gTots->ClearTotals();
     1:       gTots->SetTotalsCache();
     1:     }
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: PRIntn ReflowCountMgr::DoDisplayDiffTotals(PLHashEntry *he, PRIntn i, void *arg)
     1: {
 79445:   bool cycledOnce = (arg != 0);
     1: 
     1:   char *str = (char *)he->key;
     1:   ReflowCounter * counter = (ReflowCounter *)he->value;
     1: 
     1:   if (cycledOnce) {
     1:     counter->CalcDiffInTotals();
     1:     counter->DisplayDiffTotals(str);
     1:   }
     1:   counter->SetTotalsCache();
     1: 
     1:   return HT_ENUMERATE_NEXT;
     1: }
     1: 
     1: //------------------------------------------------------------------
     1: void ReflowCountMgr::DisplayDiffsInTotals(const char * aStr)
     1: {
     1:   if (mCycledOnce) {
     1:     printf("Differences\n");
     1:     for (PRInt32 i=0;i<78;i++) {
     1:       printf("-");
     1:     }
     1:     printf("\n");
     1:     ClearGrandTotals();
     1:   }
     1:   PL_HashTableEnumerateEntries(mCounts, DoDisplayDiffTotals, (void *)mCycledOnce);
     1: 
 80486:   mCycledOnce = true;
     1: }
     1: 
     1: #endif // MOZ_REFLOW_PERF
     1: 
     1: // make a color string like #RRGGBB
     1: void ColorToString(nscolor aColor, nsAutoString &aString)
     1: {
     1:   char buf[8];
     1: 
     1:   PR_snprintf(buf, sizeof(buf), "#%02x%02x%02x",
     1:               NS_GET_R(aColor), NS_GET_G(aColor), NS_GET_B(aColor));
     1:   CopyASCIItoUTF16(buf, aString);
     1: }
 10522: 
 10522: nsIFrame* nsIPresShell::GetAbsoluteContainingBlock(nsIFrame *aFrame)
 10522: {
 10522:   return FrameConstructor()->GetAbsoluteContainingBlock(aFrame);
 10522: }
 42982: 
 61464: #ifdef ACCESSIBILITY
 74013: bool
 74013: nsIPresShell::IsAccessibilityActive()
 74013: {
 74013:   return GetAccService() != nsnull;
 74013: }
 74013: 
 61464: nsAccessibilityService*
 61464: nsIPresShell::AccService()
 61464: {
 61464:   return GetAccService();
 61464: }
 61464: #endif
 61464: 
 91413: static bool inited = false;
 91413: 
 42982: void nsIPresShell::InitializeStatics()
 42982: {
 91413:   NS_ASSERTION(!inited, "InitializeStatics called multiple times!");
 87650:   gCaptureTouchList.Init();
 91413:   inited = true;
 42982: }
 42982: 
 42982: void nsIPresShell::ReleaseStatics()
 42982: {
 91413:   NS_ASSERTION(inited, "ReleaseStatics called without Initialize!");
 42982: }
 48937: 
 48937: // Asks our docshell whether we're active.
 48937: void PresShell::QueryIsActive()
 48937: {
 48937:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
 57282:   if (mDocument) {
 57282:     nsIDocument* displayDoc = mDocument->GetDisplayDocument();
 57282:     if (displayDoc) {
 57282:       // Ok, we're an external resource document -- we need to use our display
 57282:       // document's docshell to determine "IsActive" status, since we lack
 57282:       // a container.
 57282:       NS_ABORT_IF_FALSE(!container,
 57282:                         "external resource doc shouldn't have "
 57282:                         "its own container");
 57282: 
 57282:       nsIPresShell* displayPresShell = displayDoc->GetShell();
 57282:       if (displayPresShell) {
 57282:         container = displayPresShell->GetPresContext()->GetContainer();
 57282:       }
 57282:     }
 57282:   }
 57282: 
 48937:   nsCOMPtr<nsIDocShell> docshell(do_QueryInterface(container));
 48937:   if (docshell) {
 79445:     bool isActive;
 48937:     nsresult rv = docshell->GetIsActive(&isActive);
 48937:     if (NS_SUCCEEDED(rv))
 48937:       SetIsActive(isActive);
 48937:   }
 48937: }
 50815: 
 57282: // Helper for propagating mIsActive changes to external resources
 79445: static bool
 57282: SetExternalResourceIsActive(nsIDocument* aDocument, void* aClosure)
 57282: {
 57282:   nsIPresShell* shell = aDocument->GetShell();
 57282:   if (shell) {
 79445:     shell->SetIsActive(*static_cast<bool*>(aClosure));
 57282:   }
 80486:   return true;
 57282: }
 57282: 
 76815: static void
 76815: SetPluginIsActive(nsIContent* aContent, void* aClosure)
 76815: {
 76815:   nsIFrame *frame = aContent->GetPrimaryFrame();
 76815:   nsIObjectFrame *objectFrame = do_QueryFrame(frame);
 76815:   if (objectFrame) {
 79445:     objectFrame->SetIsDocumentActive(*static_cast<bool*>(aClosure));
 76815:   }
 76815: }
 76815: 
 50815: nsresult
 79445: PresShell::SetIsActive(bool aIsActive)
 50815: {
 58966:   NS_PRECONDITION(mDocument, "should only be called with a document");
 58966: 
 50815:   mIsActive = aIsActive;
 51546:   nsPresContext* presContext = GetPresContext();
 51546:   if (presContext &&
 51546:       presContext->RefreshDriver()->PresContext() == presContext) {
 51546:     presContext->RefreshDriver()->SetThrottled(!mIsActive);
 51546:   }
 57282: 
 57282:   // Propagate state-change to my resource documents' PresShells
 57282:   mDocument->EnumerateExternalResources(SetExternalResourceIsActive,
 57282:                                         &aIsActive);
 76815:   mDocument->EnumerateFreezableElements(SetPluginIsActive,
 76815:                                         &aIsActive);
 63261:   nsresult rv = UpdateImageLockingState();
 63261: #ifdef ACCESSIBILITY
 74972:   if (aIsActive) {
 63261:     nsAccessibilityService* accService = AccService();
 63261:     if (accService) {
 63261:       accService->PresShellActivated(this);
 63261:     }
 74972:   }
 63261: #endif
 63261:   return rv;
 50815: }
 50815: 
 50815: /*
 50815:  * Determines the current image locking state. Called when one of the
 50815:  * dependent factors changes.
 50815:  */
 50815: nsresult
 50815: PresShell::UpdateImageLockingState()
 50815: {
 50815:   // We're locked if we're both thawed and active.
 50815:   return mDocument->SetImageLockingState(!mFrozen && mIsActive);
 50815: }
 69702: 
 69702: PresShell*
 69702: PresShell::GetRootPresShell()
 69702: {
 69702:   if (mPresContext) {
 69702:     nsPresContext* rootPresContext = mPresContext->GetRootPresContext();
 69702:     if (rootPresContext) {
 69702:       return static_cast<PresShell*>(rootPresContext->PresShell());
 69702:     }
 69702:   }
 69702:   return nsnull;
 69702: }
 80375: 
 91413: void
 91413: PresShell::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
101693:                                nsArenaMemoryStats *aArenaObjectsSize,
101693:                                size_t *aPresShellSize,
 91413:                                size_t *aStyleSetsSize,
 98124:                                size_t *aTextRunsSize,
101693:                                size_t *aPresContextSize)
101693: {
101693:   mFrameArena.SizeOfExcludingThis(aMallocSizeOf, aArenaObjectsSize);
101693:   *aPresShellSize = aMallocSizeOf(this);
101693:   *aPresShellSize += aArenaObjectsSize->mOther;
 91413: 
 91413:   *aStyleSetsSize = StyleSet()->SizeOfIncludingThis(aMallocSizeOf);
 91413: 
 91413:   *aTextRunsSize = SizeOfTextRuns(aMallocSizeOf);
 98124: 
 98124:   *aPresContextSize = mPresContext->SizeOfIncludingThis(aMallocSizeOf);
 91413: }
 91413: 
 82849: size_t
 91413: PresShell::SizeOfTextRuns(nsMallocSizeOfFun aMallocSizeOf) const
 80375: {
 89328:   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
 80375:   if (!rootFrame) {
 80375:     return 0;
 80375:   }
 80375: 
 80375:   // clear the TEXT_RUN_MEMORY_ACCOUNTED flags
 82849:   nsLayoutUtils::SizeOfTextRunsForFrames(rootFrame, nsnull,
 82849:                                          /* clear = */true);
 80375: 
 80375:   // collect the total memory in use for textruns
 82849:   return nsLayoutUtils::SizeOfTextRunsForFrames(rootFrame, aMallocSizeOf,
 82849:                                                 /* clear = */false);
 82849: }
 82849: 
 96812: void
 96812: nsIPresShell::SetScrollPositionClampingScrollPortSize(nscoord aWidth, nscoord aHeight)
 96812: {
103083:   if (!mScrollPositionClampingScrollPortSizeSet ||
103083:       mScrollPositionClampingScrollPortSize.width != aWidth ||
103083:       mScrollPositionClampingScrollPortSize.height != aHeight) {
 96812:     mScrollPositionClampingScrollPortSizeSet = true;
 96812:     mScrollPositionClampingScrollPortSize.width = aWidth;
 96812:     mScrollPositionClampingScrollPortSize.height = aHeight;
103083: 
103083:     // Reflow fixed position children.
103083:     nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
103083:     if (rootFrame) {
103083:       const nsFrameList& childList = rootFrame->GetChildList(nsIFrame::kFixedList);
103083:       for (nsIFrame* child = childList.FirstChild(); child;
103083:            child = child->GetNextSibling()) {
103083:         FrameNeedsReflow(child, eResize, NS_FRAME_IS_DIRTY);
103083:       }
103083:     }
103083:   }
 96812: }
101113: 
101113: void
101113: PresShell::SetupFontInflation()
101113: {
101113:   mFontSizeInflationEmPerLine = nsLayoutUtils::FontSizeInflationEmPerLine();
101113:   mFontSizeInflationMinTwips = nsLayoutUtils::FontSizeInflationMinTwips();
101113:   mFontSizeInflationLineThreshold = nsLayoutUtils::FontSizeInflationLineThreshold();
101113: }
