  4891: <?xml version="1.0"?>
  4891: 
 98983: <!-- This Source Code Form is subject to the terms of the Mozilla Public
 98983:    - License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
  4891: 
  4891: <!DOCTYPE bindings [
  5173: <!ENTITY % tabBrowserDTD SYSTEM "chrome://browser/locale/tabbrowser.dtd" >
  4891: %tabBrowserDTD;
  4891: ]>
  4891: 
  4891: <bindings id="tabBrowserBindings"
  4891:           xmlns="http://www.mozilla.org/xbl"
  4891:           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  4891:           xmlns:xbl="http://www.mozilla.org/xbl">
  4891: 
  4891:   <binding id="tabbrowser">
  4891:     <resources>
 10272:       <stylesheet src="chrome://browser/content/tabbrowser.css"/>
  4891:     </resources>
  4891: 
  4891:     <content>
  5173:       <xul:stringbundle anonid="tbstringbundle" src="chrome://browser/locale/tabbrowser.properties"/>
 39508:       <xul:tabbox anonid="tabbox" class="tabbrowser-tabbox"
 39508:                   flex="1" eventnode="document" xbl:inherits="handleCtrlPageUpDown"
 38729:                   onselect="if (event.target.localName == 'tabpanels') this.parentNode.updateCurrentBrowser();">
  5028:         <xul:tabpanels flex="1" class="plain" selectedIndex="0" anonid="panelcontainer">
  5036:           <xul:notificationbox flex="1">
111101:             <xul:hbox flex="1" class="browserSidebarContainer">
111101:               <xul:vbox flex="1" class="browserContainer">
111101:                 <xul:stack flex="1" class="browserStack">
111101:                   <xul:browser anonid="initialBrowser" type="content-primary" message="true" disablehistory="true"
  5036:                                xbl:inherits="tooltip=contenttooltip,contextmenu=contentcontextmenu,autocompletepopup"/>
 54453:                 </xul:stack>
 99978:               </xul:vbox>
111101:             </xul:hbox>
  5036:           </xul:notificationbox>
  4891:         </xul:tabpanels>
  4891:       </xul:tabbox>
  4891:       <children/>
  4891:     </content>
 38729:     <implementation implements="nsIDOMEventListener">
 39825: 
 39825:       <property name="tabContextMenu" readonly="true"
 39825:                 onget="return this.tabContainer.contextMenu;"/>
 39825: 
 39702:       <field name="tabContainer" readonly="true">
 39702:         document.getElementById(this.getAttribute("tabcontainer"));
 39702:       </field>
 39702:       <field name="tabs" readonly="true">
 39702:         this.tabContainer.childNodes;
 39702:       </field>
 97274: 
 50740:       <property name="visibleTabs" readonly="true">
 50740:         <getter><![CDATA[
 97274:           if (!this._visibleTabs)
 97274:             this._visibleTabs = Array.filter(this.tabs,
 97274:                                              function (tab) !tab.hidden && !tab.closing);
 97274:           return this._visibleTabs;
 50740:         ]]></getter>
 50740:       </property>
 97274:       <field name="_visibleTabs">null</field>
 97274: 
  4957:       <field name="mURIFixup" readonly="true">
  4957:         Components.classes["@mozilla.org/docshell/urifixup;1"]
  4957:                   .getService(Components.interfaces.nsIURIFixup);
  4957:       </field>
  6783:       <field name="mFaviconService" readonly="true">
  6783:         Components.classes["@mozilla.org/browser/favicon-service;1"]
  6783:                   .getService(Components.interfaces.nsIFaviconService);
  6783:       </field>
 59359:       <field name="_placesAutocomplete" readonly="true">
 59347:          Components.classes["@mozilla.org/autocomplete/search;1?name=history"]
 59347:                    .getService(Components.interfaces.mozIPlacesAutoComplete);
 39889:       </field>
  5028:       <field name="mTabBox" readonly="true">
  5028:         document.getAnonymousElementByAttribute(this, "anonid", "tabbox");
  4891:       </field>
  5028:       <field name="mPanelContainer" readonly="true">
  5028:         document.getAnonymousElementByAttribute(this, "anonid", "panelcontainer");
  4972:       </field>
  4891:       <field name="mStringBundle">
  5028:         document.getAnonymousElementByAttribute(this, "anonid", "tbstringbundle");
  4891:       </field>
  4891:       <field name="mCurrentTab">
  4891:         null
  4891:       </field>
 32240:       <field name="_lastRelatedTab">
 32240:         null
 32240:       </field>
  4891:       <field name="mCurrentBrowser">
  4891:         null
  4891:       </field>
  4891:       <field name="mProgressListeners">
  5028:         []
  4891:       </field>
 21759:       <field name="mTabsProgressListeners">
 21759:         []
 21759:       </field>
  4891:       <field name="mTabListeners">
 63659:         []
  4891:       </field>
  4891:       <field name="mTabFilters">
 63659:         []
  4891:       </field>
  4891:       <field name="mIsBusy">
  4891:         false
  4891:       </field>
  4972:       <field name="arrowKeysShouldWrap" readonly="true">
  4972: #ifdef XP_MACOSX
  4972:         true
  4972: #else
  4972:         false
  4972: #endif
  4972:       </field>
  4891: 
  5134:       <field name="_autoScrollPopup">
  5134:         null
  5134:       </field>
  5059: 
 33489:       <field name="_previewMode">
 33489:         false
 33489:       </field>
 33489: 
 46158:       <property name="_numPinnedTabs" readonly="true">
 46158:         <getter><![CDATA[
 46158:           for (var i = 0; i < this.tabs.length; i++) {
 46158:             if (!this.tabs[i].pinned)
 46158:               break;
 46158:           }
 46158:           return i;
 46158:         ]]></getter>
 46158:       </property>
 46158: 
 60693:       <method name="updateWindowResizers">
 60693:         <body><![CDATA[
 60693:           if (!window.gShowPageResizers)
 60693:             return;
 60693: 
 61274:           var show = document.getElementById("addon-bar").collapsed &&
 61274:                      window.windowState == window.STATE_NORMAL;
 60693:           for (let i = 0; i < this.browsers.length; i++) {
 60693:             this.browsers[i].showWindowResizer = show;
 60693:           }
 60693:         ]]></body>
 60693:       </method>
 60693: 
 62092:       <method name="_setCloseKeyState">
 62092:         <parameter name="aEnabled"/>
 62092:         <body><![CDATA[
 62092:           let keyClose = document.getElementById("key_close");
 62092:           let closeKeyEnabled = keyClose.getAttribute("disabled") != "true";
 62092:           if (closeKeyEnabled == aEnabled)
 62092:             return;
 62092: 
 62092:           if (aEnabled)
 62092:             keyClose.removeAttribute("disabled");
 62092:           else
 62092:             keyClose.setAttribute("disabled", "true");
 62092: 
 62092:           // We also want to remove the keyboard shortcut from the file menu
 62092:           // when the shortcut is disabled, and bring it back when it's
 62092:           // renabled.
 62092:           //
 62092:           // Fixing bug 630826 could make that happen automatically.
 62092:           // Fixing bug 630830 could avoid the ugly hack below.
 62092: 
 62092:           let closeMenuItem = document.getElementById("menu_close");
 62092:           let parentPopup = closeMenuItem.parentNode;
 62092:           let nextItem = closeMenuItem.nextSibling;
 62092:           let clonedItem = closeMenuItem.cloneNode(true);
 62092: 
 62092:           parentPopup.removeChild(closeMenuItem);
 62092: 
 62092:           if (aEnabled)
 62092:             clonedItem.setAttribute("key", "key_close");
 62092:           else
 62092:             clonedItem.removeAttribute("key");
 62092: 
 62092:           parentPopup.insertBefore(clonedItem, nextItem);
 62092:         ]]></body>
 62092:       </method>
 62092: 
 46158:       <method name="pinTab">
 46158:         <parameter name="aTab"/>
 46158:         <body><![CDATA[
 46158:           if (aTab.pinned)
 46158:             return;
 46158: 
 55352:           if (aTab.hidden)
 55352:             this.showTab(aTab);
 55352: 
 46158:           this.moveTabTo(aTab, this._numPinnedTabs);
 46158:           aTab.setAttribute("pinned", "true");
 67993:           this.tabContainer._unlockTabSizing();
 46158:           this.tabContainer._positionPinnedTabs();
 51347:           this.tabContainer.adjustTabstrip();
 52338: 
 56685:           this.getBrowserForTab(aTab).docShell.isAppTab = true;
 56685: 
 62092:           if (aTab.selected)
 62092:             this._setCloseKeyState(false);
 62092: 
 52338:           let event = document.createEvent("Events");
 52469:           event.initEvent("TabPinned", true, false);
 52338:           aTab.dispatchEvent(event);
 46158:         ]]></body>
 46158:       </method>
 46158: 
 46158:       <method name="unpinTab">
 46158:         <parameter name="aTab"/>
 46158:         <body><![CDATA[
 46158:           if (!aTab.pinned)
 46158:             return;
 46158: 
 46158:           this.moveTabTo(aTab, this._numPinnedTabs - 1);
 49014:           aTab.setAttribute("fadein", "true");
 46158:           aTab.removeAttribute("pinned");
 46158:           aTab.style.MozMarginStart = "";
 67993:           this.tabContainer._unlockTabSizing();
 46158:           this.tabContainer._positionPinnedTabs();
 51347:           this.tabContainer.adjustTabstrip();
 52338: 
 56685:           this.getBrowserForTab(aTab).docShell.isAppTab = false;
 56685: 
 62092:           if (aTab.selected)
 62092:             this._setCloseKeyState(true);
 62092: 
 52338:           let event = document.createEvent("Events");
 52469:           event.initEvent("TabUnpinned", true, false);
 52338:           aTab.dispatchEvent(event);
 46158:         ]]></body>
 46158:       </method>
 46158: 
 33489:       <method name="previewTab">
 33489:         <parameter name="aTab"/>
 33489:         <parameter name="aCallback"/>
 33489:         <body>
 33489:           <![CDATA[
 33489:             let currentTab = this.selectedTab;
 33489:             try {
 33489:               // Suppress focus, ownership and selected tab changes
 33489:               this._previewMode = true;
 33489:               this.selectedTab = aTab;
 33489:               aCallback();
 33489:             } finally {
 33489:               this.selectedTab = currentTab;
 33489:               this._previewMode = false;
 33489:             }
 33489:           ]]>
 33489:         </body>
 33489:       </method>
 33489: 
  4943:       <method name="getBrowserAtIndex">
  4943:         <parameter name="aIndex"/>
  4943:         <body>
  4943:           <![CDATA[
  8209:             return this.browsers[aIndex];
  4943:           ]]>
  4943:         </body>
  4943:       </method>
  4943: 
  4943:       <method name="getBrowserIndexForDocument">
  4943:         <parameter name="aDocument"/>
  4943:         <body>
  4943:           <![CDATA[
 38729:             var tab = this._getTabForContentWindow(aDocument.defaultView);
 38729:             return tab ? tab._tPos : -1;
  4943:           ]]>
  4943:         </body>
  4943:       </method>
  4943: 
  5039:       <method name="getBrowserForDocument">
  5039:         <parameter name="aDocument"/>
  5039:         <body>
  5039:           <![CDATA[
 38729:             var tab = this._getTabForContentWindow(aDocument.defaultView);
 38729:             return tab ? tab.linkedBrowser : null;
 38729:           ]]>
 38729:         </body>
 38729:       </method>
 38729: 
 38729:       <method name="_getTabForContentWindow">
 38729:         <parameter name="aWindow"/>
 38729:         <body>
 38729:         <![CDATA[
 38729:           for (let i = 0; i < this.browsers.length; i++) {
 38729:             if (this.browsers[i].contentWindow == aWindow)
 39702:               return this.tabs[i];
 38729:           }
  5039:           return null;
  5039:         ]]>
  5039:         </body>
  5039:       </method>
  5039: 
  5036:       <method name="getNotificationBox">
  4943:         <parameter name="aBrowser"/>
  4943:         <body>
  4943:           <![CDATA[
111101:             return this.getSidebarContainer(aBrowser).parentNode;
111101:           ]]>
111101:         </body>
111101:       </method>
111101: 
111101:       <method name="getSidebarContainer">
111101:         <parameter name="aBrowser"/>
111101:         <body>
111101:           <![CDATA[
 99978:             return this.getBrowserContainer(aBrowser).parentNode;
 99978:           ]]>
 99978:         </body>
 99978:       </method>
 99978: 
 99978:       <method name="getBrowserContainer">
 99978:         <parameter name="aBrowser"/>
 99978:         <body>
 99978:           <![CDATA[
 54453:             return (aBrowser || this.mCurrentBrowser).parentNode.parentNode;
  4943:           ]]>
  4943:         </body>
  4943:       </method>
  4943: 
 57936:       <method name="getTabModalPromptBox">
 57936:         <parameter name="aBrowser"/>
 57936:         <body>
 57936:           <![CDATA[
 57936:             const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 57936:             let browser = (aBrowser || this.mCurrentBrowser);
 57936:             let stack = browser.parentNode;
 57936:             let self = this;
 57936: 
 57936:             let promptBox = {
 57936:               appendPrompt : function(args, onCloseCallback) {
 57936:                 let newPrompt = document.createElementNS(XUL_NS, "tabmodalprompt");
 57936:                 stack.appendChild(newPrompt);
 68688:                 browser.setAttribute("tabmodalPromptShowing", true);
 68688: 
 57936:                 newPrompt.clientTop; // style flush to assure binding is attached
 57936: 
 57936:                 let tab = self._getTabForContentWindow(browser.contentWindow);
 57936:                 newPrompt.init(args, tab, onCloseCallback);
 57936:                 return newPrompt;
 57936:               },
 57936: 
 57936:               removePrompt : function(aPrompt) {
 68688:                 stack.removeChild(aPrompt);
 68688: 
 68688:                 let prompts = this.listPrompts();
 68688:                 if (prompts.length) {
 68688:                   let prompt = prompts[prompts.length - 1];
 68688:                   prompt.Dialog.setDefaultFocus();
 68688:                 } else {
 57936:                   browser.removeAttribute("tabmodalPromptShowing");
 68688:                   browser.focus();
 68688:                 }
 57936:               },
 57936: 
 57936:               listPrompts : function(aPrompt) {
 57936:                 let els = stack.getElementsByTagNameNS(XUL_NS, "tabmodalprompt");
 57936:                 // NodeList --> real JS array
 68688:                 let prompts = Array.slice(els);
 57936:                 return prompts;
 57936:               },
 57936:             };
 57936: 
 57936:             return promptBox;
 57936:           ]]>
 57936:         </body>
 57936:       </method>
 57936: 
 47240:       <method name="_callProgressListeners">
 47240:         <parameter name="aBrowser"/>
 47240:         <parameter name="aMethod"/>
 47240:         <parameter name="aArguments"/>
 47240:         <parameter name="aCallGlobalListeners"/>
 47240:         <parameter name="aCallTabsListeners"/>
 47240:         <body><![CDATA[
 47240:           var rv = true;
 47240: 
 47240:           if (!aBrowser)
 47240:             aBrowser = this.mCurrentBrowser;
 47240: 
 47240:           if (aCallGlobalListeners != false &&
 47240:               aBrowser == this.mCurrentBrowser) {
 47240:             this.mProgressListeners.forEach(function (p) {
 47240:               if (aMethod in p) {
 47240:                 try {
 47240:                   if (!p[aMethod].apply(p, aArguments))
 47240:                     rv = false;
 47240:                 } catch (e) {
 47240:                   // don't inhibit other listeners
 47240:                   Components.utils.reportError(e);
 47240:                 }
 47240:               }
 47240:             });
 47240:           }
 47240: 
 47240:           if (aCallTabsListeners != false) {
 47240:             aArguments.unshift(aBrowser);
 47240: 
 47240:             this.mTabsProgressListeners.forEach(function (p) {
 47240:               if (aMethod in p) {
 47240:                 try {
 47240:                   if (!p[aMethod].apply(p, aArguments))
 47240:                     rv = false;
 47240:                 } catch (e) {
 47240:                   // don't inhibit other listeners
 47240:                   Components.utils.reportError(e);
 47240:                 }
 47240:               }
 47240:             });
 47240:           }
 47240: 
 47240:           return rv;
 47240:         ]]></body>
 47240:       </method>
 47240: 
  4891:       <!-- A web progress listener object definition for a given tab. -->
  4891:       <method name="mTabProgressListener">
  4891:         <parameter name="aTab"/>
  4924:         <parameter name="aBrowser"/>
  4891:         <parameter name="aStartsBlank"/>
  4891:         <body>
  4891:         <![CDATA[
  4891:           return ({
  4924:             mTabBrowser: this,
  4891:             mTab: aTab,
  4924:             mBrowser: aBrowser,
  4891:             mBlank: aStartsBlank,
  4891: 
 54522:             // cache flags for correct status UI update after tab switching
  5029:             mStateFlags: 0,
  5029:             mStatus: 0,
  5029:             mMessage: "",
  5029:             mTotalProgress: 0,
  5029: 
  5033:             // count of open requests (should always be 0 or 1)
  5033:             mRequestCount: 0,
  5033: 
 33328:             destroy: function () {
 33337:               delete this.mTab;
 33337:               delete this.mBrowser;
 33337:               delete this.mTabBrowser;
 33328:             },
 33328: 
 47240:             _callProgressListeners: function () {
 47240:               Array.unshift(arguments, this.mBrowser);
 47240:               return this.mTabBrowser._callProgressListeners.apply(this.mTabBrowser, arguments);
 47240:             },
 47240: 
  4891:             onProgressChange: function (aWebProgress, aRequest,
  4891:                                         aCurSelfProgress, aMaxSelfProgress,
 47240:                                         aCurTotalProgress, aMaxTotalProgress) {
 21759:               this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;
 21759: 
 21759:               if (this.mBlank)
 21759:                 return;
 21759: 
 55337:               if (this.mTotalProgress)
 55337:                 this.mTab.setAttribute("progress", "true");
 33328: 
 47240:               this._callProgressListeners("onProgressChange",
 47240:                                           [aWebProgress, aRequest,
  4891:                                            aCurSelfProgress, aMaxSelfProgress,
 47240:                                            aCurTotalProgress, aMaxTotalProgress]);
  4891:             },
  4891: 
  5117:             onProgressChange64: function (aWebProgress, aRequest,
  5117:                                           aCurSelfProgress, aMaxSelfProgress,
 47240:                                           aCurTotalProgress, aMaxTotalProgress) {
  5117:               return this.onProgressChange(aWebProgress, aRequest,
  5117:                 aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
  5117:                 aMaxTotalProgress);
  5117:             },
  5117: 
 47240:             onStateChange: function (aWebProgress, aRequest, aStateFlags, aStatus) {
  4891:               if (!aRequest)
  4891:                 return;
  4891: 
  4891:               var oldBlank = this.mBlank;
  4891: 
  4891:               const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
  4891:               const nsIChannel = Components.interfaces.nsIChannel;
  4924: 
  5033:               if (aStateFlags & nsIWebProgressListener.STATE_START) {
  5033:                 this.mRequestCount++;
  5033:               }
  5033:               else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
  5033:                 const NS_ERROR_UNKNOWN_HOST = 2152398878;
  5033:                 if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
  5033:                   // to prevent bug 235825: wait for the request handled
  5033:                   // by the automatic keyword resolver
  5033:                   return;
  5033:                 }
  5033:                 // since we (try to) only handle STATE_STOP of the last request,
  5033:                 // the count of open requests should now be 0
  5033:                 this.mRequestCount = 0;
  5033:               }
  5033: 
  4924:               if (aStateFlags & nsIWebProgressListener.STATE_START &&
  4891:                   aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
  4933:                 // It's okay to clear what the user typed when we start
  4997:                 // loading a document. If the user types, this counter gets
  4997:                 // set to zero, if the document load ends without an
  4997:                 // onLocationChange, this counter gets decremented
  4997:                 // (so we keep it while switching tabs after failed loads)
 10049:                 // We need to add 2 because loadURIWithFlags may have
 10049:                 // cancelled a pending load which would have cleared
 10049:                 // its anchor scroll detection temporary increment.
  4924:                 if (aWebProgress.DOMWindow == this.mBrowser.contentWindow)
 10049:                   this.mBrowser.userTypedClear += 2;
  4924: 
  4924:                 if (!this.mBlank) {
 32344:                   if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING)) {
  4891:                     this.mTab.setAttribute("busy", "true");
 90242:                     if (!(this.mBrowser.docShell.loadType & Ci.nsIDocShell.LOAD_CMD_RELOAD))
  4998:                       this.mTabBrowser.setTabTitleLoading(this.mTab);
 32344:                   }
  4891: 
 52370:                   if (this.mTab.selected)
  4891:                     this.mTabBrowser.mIsBusy = true;
  4891:                 }
  4924:               }
  4891:               else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
  4891:                        aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
  4891: 
 78401:                 if (this.mTab.hasAttribute("busy")) {
  4891:                   this.mTab.removeAttribute("busy");
 78401:                   this.mTabBrowser._tabAttrModified(this.mTab);
 80041:                   if (!this.mTab.selected)
 80041:                     this.mTab.setAttribute("unread", "true");
 78401:                 }
 55337:                 this.mTab.removeAttribute("progress");
  4891: 
 94252:                 if (aWebProgress.DOMWindow == this.mBrowser.contentWindow) {
 94252:                   if (!Components.isSuccessCode(aStatus) &&
 94252:                       !isTabEmpty(this.mTab)) {
 94252:                     // Restore the current document's location in case the
 94252:                     // request was stopped (possibly from a content script)
 94252:                     // before the location changed.
 94252: 
 94252:                     this.mBrowser.userTypedValue = null;
 94252: 
 94252:                     if (this.mTab.selected && gURLBar)
 94252:                       URLBarSetURI();
 94252:                   } else {
 94252:                     // The document is done loading, we no longer want the
 94252:                     // value cleared.
 94252: 
 94252:                     if (this.mBrowser.userTypedClear > 1)
 94252:                       this.mBrowser.userTypedClear -= 2;
 94252:                     else if (this.mBrowser.userTypedClear > 0)
 94252:                       this.mBrowser.userTypedClear--;
 94252:                   }
 94252: 
 94252:                   if (!this.mBrowser.mIconURL)
 94252:                     this.mTabBrowser.useDefaultIcon(this.mTab);
 94252:                 }
 94252: 
 94252:                 if (this.mBlank)
 94252:                   this.mBlank = false;
 94252: 
  4891:                 var location = aRequest.QueryInterface(nsIChannel).URI;
  4943: 
  4943:                 // For keyword URIs clear the user typed value since they will be changed into real URIs
  4943:                 if (location.scheme == "keyword")
  4943:                   this.mBrowser.userTypedValue = null;
  4943: 
 55383:                 if (this.mTab.label == this.mTabBrowser.mStringBundle.getString("tabs.connecting"))
  4891:                   this.mTabBrowser.setTabTitle(this.mTab);
  4891: 
 52370:                 if (this.mTab.selected)
  4891:                   this.mTabBrowser.mIsBusy = false;
  4891:               }
  4891: 
 47240:               if (oldBlank) {
 47240:                 this._callProgressListeners("onUpdateCurrentBrowser",
 47240:                                             [aStateFlags, aStatus, "", 0],
 47240:                                             true, false);
 47240:               } else {
 47240:                 this._callProgressListeners("onStateChange",
 47240:                                             [aWebProgress, aRequest, aStateFlags, aStatus],
 47240:                                             true, false);
 12626:               }
 47240: 
 47240:               this._callProgressListeners("onStateChange",
 47240:                                           [aWebProgress, aRequest, aStateFlags, aStatus],
 47240:                                           false);
 21759: 
  5029:               if (aStateFlags & (nsIWebProgressListener.STATE_START |
  5029:                                  nsIWebProgressListener.STATE_STOP)) {
  5029:                 // reset cached temporary values at beginning and end
  5029:                 this.mMessage = "";
  5029:                 this.mTotalProgress = 0;
  5029:               }
  5029:               this.mStateFlags = aStateFlags;
  5029:               this.mStatus = aStatus;
  4945:             },
  4891: 
 82127:             onLocationChange: function (aWebProgress, aRequest, aLocation,
 82127:                                         aFlags) {
 49211:               // OnLocationChange is called for both the top-level content
 49211:               // and the subframes.
 49211:               let topLevel = aWebProgress.DOMWindow == this.mBrowser.contentWindow;
 49211: 
 49211:               if (topLevel) {
  4933:                 // The document loaded correctly, clear the value if we should
 84898:                 if (this.mBrowser.userTypedClear > 0 ||
 98377:                     (aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE))
  4933:                   this.mBrowser.userTypedValue = null;
  4933: 
 49211:                 // Clear out the missing plugins list since it's related to the
 49211:                 // previous location.
 49211:                 this.mBrowser.missingPlugins = null;
 49211: 
 49211:                 // Don't clear the favicon if this onLocationChange was
 49211:                 // triggered by a pushState or a replaceState.  See bug 550565.
 49211:                 if (aWebProgress.isLoadingDocument &&
 49211:                     !(this.mBrowser.docShell.loadType & Ci.nsIDocShell.LOAD_CMD_PUSHSTATE))
 39774:                   this.mBrowser.mIconURL = null;
 49211: 
 59359:                 let autocomplete = this.mTabBrowser._placesAutocomplete;
 50528:                 if (this.mBrowser.registeredOpenURI) {
 59347:                   autocomplete.unregisterOpenPage(this.mBrowser.registeredOpenURI);
 50528:                   delete this.mBrowser.registeredOpenURI;
 50528:                 }
124742:                 // Tabs in private windows aren't registered as "Open" so
124742:                 // that they don't appear as switch-to-tab candidates.
130857:                 if (!isBlankPageURL(aLocation.spec) &&
130857:                     !PrivateBrowsingUtils.isWindowPrivate(window)) {
 59347:                   autocomplete.registerOpenPage(aLocation);
 50528:                   this.mBrowser.registeredOpenURI = aLocation;
 49211:                 }
 57064:               }
 39889: 
 39889:               if (!this.mBlank) {
 47240:                 this._callProgressListeners("onLocationChange",
 82127:                                             [aWebProgress, aRequest, aLocation,
 82127:                                              aFlags]);
 12626:               }
 39889: 
 49211:               if (topLevel)
 39889:                 this.mBrowser.lastURI = aLocation;
  4891:             },
  4891: 
 47240:             onStatusChange: function (aWebProgress, aRequest, aStatus, aMessage) {
  4920:               if (this.mBlank)
  4891:                 return;
  4891: 
 47240:               this._callProgressListeners("onStatusChange",
 47240:                                           [aWebProgress, aRequest, aStatus, aMessage]);
 21759: 
  5029:               this.mMessage = aMessage;
  4891:             },
  4891: 
 47240:             onSecurityChange: function (aWebProgress, aRequest, aState) {
 47240:               this._callProgressListeners("onSecurityChange",
 47240:                                           [aWebProgress, aRequest, aState]);
  4891:             },
  4891: 
 47240:             onRefreshAttempted: function (aWebProgress, aURI, aDelay, aSameURI) {
 47240:               return this._callProgressListeners("onRefreshAttempted",
 47240:                                                  [aWebProgress, aURI, aDelay, aSameURI]);
  5117:             },
  5117: 
 47240:             QueryInterface: function (aIID) {
  4891:               if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
  5117:                   aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
  4891:                   aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
  4891:                   aIID.equals(Components.interfaces.nsISupports))
  4891:                 return this;
  4891:               throw Components.results.NS_NOINTERFACE;
  4891:             }
  4891:           });
  4891:         ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4976:       <method name="setIcon">
  4976:         <parameter name="aTab"/>
  4891:         <parameter name="aURI"/>
  4891:         <body>
  4891:           <![CDATA[
  4976:             var browser = this.getBrowserForTab(aTab);
137404:             browser.mIconURL = aURI instanceof Ci.nsIURI ? aURI.spec : aURI;
 30813: 
 30813:             if (aURI && this.mFaviconService) {
 30813:               if (!(aURI instanceof Ci.nsIURI))
 30813:                 aURI = makeURI(aURI);
 90987:               this.mFaviconService.setAndFetchFaviconForPage(browser.currentURI,
114145:                                                              aURI, false,
118331:                                                              PrivateBrowsingUtils.isWindowPrivate(window) ?
114145:                                                                this.mFaviconService.FAVICON_LOAD_PRIVATE :
114145:                                                                this.mFaviconService.FAVICON_LOAD_NON_PRIVATE);
  6783:             }
  6783: 
137505:             if ((browser.mIconURL || "") != aTab.getAttribute("image")) {
137505:               if (browser.mIconURL)
137505:                 aTab.setAttribute("image", browser.mIconURL);
 54613:               else
 54613:                 aTab.removeAttribute("image");
 54613:               this._tabAttrModified(aTab);
 54613:             }
  4976: 
 47240:             this._callProgressListeners(browser, "onLinkIconAvailable", [browser.mIconURL]);
  4976:           ]]>
  4976:         </body>
  4976:       </method>
  4976: 
 36203:       <method name="getIcon">
 36203:         <parameter name="aTab"/>
 36203:         <body>
 36203:           <![CDATA[
 36203:             let browser = aTab ? this.getBrowserForTab(aTab) : this.selectedBrowser;
 36203:             return browser.mIconURL;
 36203:           ]]>
 36203:         </body>
 36203:       </method>
 36203: 
  4891:       <method name="shouldLoadFavIcon">
  4891:         <parameter name="aURI"/>
  4891:         <body>
  4891:           <![CDATA[
 39682:             return (aURI &&
 39682:                     Services.prefs.getBoolPref("browser.chrome.site_icons") &&
 39682:                     Services.prefs.getBoolPref("browser.chrome.favicons") &&
  4891:                     ("schemeIs" in aURI) && (aURI.schemeIs("http") || aURI.schemeIs("https")));
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4976:       <method name="useDefaultIcon">
  4976:         <parameter name="aTab"/>
  4891:         <body>
  4891:           <![CDATA[
  4976:             var browser = this.getBrowserForTab(aTab);
 32964:             var docURIObject = browser.contentDocument.documentURIObject;
 54613:             var icon = null;
  4976:             if (browser.contentDocument instanceof ImageDocument) {
 39682:               if (Services.prefs.getBoolPref("browser.chrome.site_icons")) {
 54613:                 let sz = Services.prefs.getIntPref("browser.chrome.image_icons.max_size");
  4994:                 try {
 54613:                   let req = browser.contentDocument.imageRequest;
 54613:                   if (req &&
 54613:                       req.image &&
 54613:                       req.image.width <= sz &&
 54613:                       req.image.height <= sz)
 54613:                     icon = browser.currentURI;
  4994:                 } catch (e) { }
  4994:               }
  4976:             }
 20731:             // Use documentURIObject in the check for shouldLoadFavIcon so that we
 20731:             // do the right thing with about:-style error pages.  Bug 453442
 32964:             else if (this.shouldLoadFavIcon(docURIObject)) {
 54613:               let url = docURIObject.prePath + "/favicon.ico";
  6783:               if (!this.isFailedIcon(url))
 54613:                 icon = url;
  4976:             }
 54613:             this.setIcon(aTab, icon);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  6783:       <method name="isFailedIcon">
  4891:         <parameter name="aURI"/>
  4891:         <body>
  4891:           <![CDATA[
 30813:             if (this.mFaviconService) {
 30813:               if (!(aURI instanceof Ci.nsIURI))
 30813:                 aURI = makeURI(aURI);
 30813:               return this.mFaviconService.isFailedFavicon(aURI);
  4920:             }
 23189:             return null;
  4943:           ]]>
  4943:         </body>
  4943:       </method>
  4943: 
 39174:       <method name="getWindowTitleForBrowser">
 39174:         <parameter name="aBrowser"/>
  4891:         <body>
  4891:           <![CDATA[
  4891:             var newTitle = "";
  5005:             var docElement = this.ownerDocument.documentElement;
  5005:             var sep = docElement.getAttribute("titlemenuseparator");
  5005: 
135243:             // Strip out any null bytes in the content title, since the
135243:             // underlying widget implementations of nsWindow::SetTitle pass
135243:             // null-terminated strings to system APIs.
135561:             var docTitle = aBrowser.contentTitle.replace("\0", "", "g");
  4891: 
  4915:             if (!docTitle)
  5005:               docTitle = docElement.getAttribute("titledefault");
  4915: 
  5005:             var modifier = docElement.getAttribute("titlemodifier");
  4891:             if (docTitle) {
  5005:               newTitle += docElement.getAttribute("titlepreface");
  4891:               newTitle += docTitle;
  4918:               if (modifier)
  4918:                 newTitle += sep;
  4891:             }
  4918:             newTitle += modifier;
  5005: 
  5005:             // If location bar is hidden and the URL type supports a host,
  5005:             // add the scheme and host to the title to prevent spoofing.
  5005:             // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
  5005:             try {
111526:               if (docElement.getAttribute("chromehidden").contains("location")) {
  5008:                 var uri = this.mURIFixup.createExposableURI(
 39174:                             aBrowser.currentURI);
  5121:                 if (uri.scheme == "about")
  5121:                   newTitle = uri.spec + sep + newTitle;
  5121:                 else
  5008:                   newTitle = uri.prePath + sep + newTitle;
  5005:               }
  5005:             } catch (e) {}
  5005: 
 39174:             return newTitle;
 39174:           ]]>
 39174:         </body>
 39174:       </method>
 39174: 
 39174:       <method name="updateTitlebar">
 39174:         <body>
 39174:           <![CDATA[
 68565:             if ("TabView" in window && TabView.isVisible()) {
 50317:               // ToDo: this will be removed when we gain ability to draw to the menu bar.
 50317:               // Bug 586175
 50328:               this.ownerDocument.title = TabView.windowTitle;
 53741:             }
 53741:             else {
 39174:               this.ownerDocument.title = this.getWindowTitleForBrowser(this.mCurrentBrowser);
 50127:             }
  4943:           ]]>
  4943:         </body>
  4943:       </method>
  4943: 
  4891:       <method name="updateCurrentBrowser">
 21712:         <parameter name="aForceUpdate"/>
  4891:         <body>
  4891:           <![CDATA[
 39702:             var newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);
 21712:             if (this.mCurrentBrowser == newBrowser && !aForceUpdate)
  4901:               return;
  4901: 
118620:             if (!aForceUpdate) {
114675:               TelemetryStopwatch.start("FX_TAB_SWITCH_UPDATE_MS");
118620:               window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils)
118620:                                                              .beginTabSwitch();
118620:             }
114675: 
 35638:             var oldTab = this.mCurrentTab;
 35638: 
 33489:             // Preview mode should not reset the owner
126878:             if (!this._previewMode && !oldTab.selected)
 35638:               oldTab.owner = null;
 27698: 
 52075:             if (this._lastRelatedTab) {
126878:               if (!this._lastRelatedTab.selected)
 52075:                 this._lastRelatedTab.owner = null;
 32240:               this._lastRelatedTab = null;
 52075:             }
 32240: 
 29018:             var oldBrowser = this.mCurrentBrowser;
 48937:             if (oldBrowser) {
 29018:               oldBrowser.setAttribute("type", "content-targetable");
 73596:               oldBrowser.docShellIsActive = false;
 48937:             }
  4891: 
  4902:             var updatePageReport = false;
 29018:             if (!oldBrowser ||
 29018:                 (oldBrowser.pageReport && !newBrowser.pageReport) ||
 29018:                 (!oldBrowser.pageReport && newBrowser.pageReport))
  4902:               updatePageReport = true;
  4902: 
  4891:             newBrowser.setAttribute("type", "content-primary");
 73680:             newBrowser.docShellIsActive =
 73680:               (window.windowState != window.STATE_MINIMIZED);
  4891:             this.mCurrentBrowser = newBrowser;
127078:             this.mCurrentTab = this.tabContainer.selectedItem;
 50697:             this.showTab(this.mCurrentTab);
  4891: 
 80128:             var backForwardContainer = document.getElementById("unified-back-forward-button");
120712:             if (backForwardContainer) {
 80128:               backForwardContainer.setAttribute("switchingtabs", "true");
120712:               window.addEventListener("MozAfterPaint", function removeSwitchingtabsAttr() {
120712:                 window.removeEventListener("MozAfterPaint", removeSwitchingtabsAttr);
120712:                 backForwardContainer.removeAttribute("switchingtabs");
120712:               });
120712:             }
 80128: 
  4902:             if (updatePageReport)
  4902:               this.mCurrentBrowser.updatePageReport();
  4902: 
  4891:             // Update the URL bar.
  4891:             var loc = this.mCurrentBrowser.currentURI;
  4902: 
 73596: #ifdef MOZ_E10S_COMPAT
 73596:             // Bug 666801 - WebProgress support for e10s and
 73596:             // Bug 666809 - SecurityUI support for e10s
 73596: #else
  4891:             var webProgress = this.mCurrentBrowser.webProgress;
  4891:             var securityUI = this.mCurrentBrowser.securityUI;
  5012: 
 47240:             this._callProgressListeners(null, "onLocationChange",
 82127:                                         [webProgress, null, loc, 0], true,
 82127:                                         false);
 47240: 
 47240:             if (securityUI) {
 47240:               this._callProgressListeners(null, "onSecurityChange",
 47240:                                           [webProgress, null, securityUI.state], true, false);
  5029:             }
 73596: #endif
 47240: 
 47240:             var listener = this.mTabListeners[this.tabContainer.selectedIndex] || null;
 47240:             if (listener && listener.mStateFlags) {
 47240:               this._callProgressListeners(null, "onUpdateCurrentBrowser",
 47240:                                           [listener.mStateFlags, listener.mStatus,
 47240:                                            listener.mMessage, listener.mTotalProgress],
 47240:                                           true, false);
  4943:             }
  4891: 
 39176:             if (!this._previewMode) {
 80042:               this.mCurrentTab.removeAttribute("unread");
 95569:               this.selectedTab.lastAccessed = Date.now();
 80042: 
 73596: #ifdef MOZ_E10S_COMPAT
 73596:               // Bug 666816 - TypeAheadFind support for e10s
 73596: #else
  4943:               this._fastFind.setDocShell(this.mCurrentBrowser.docShell);
 73596: #endif
  4943: 
  4891:               this.updateTitlebar();
 51923: 
 51923:               this.mCurrentTab.removeAttribute("titlechanged");
 39176:             }
  4891: 
  4891:             // If the new tab is busy, and our current state is not busy, then
  4891:             // we need to fire a start to all progress listeners.
  4891:             const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
  4891:             if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
  4891:               this.mIsBusy = true;
 47240:               this._callProgressListeners(null, "onStateChange",
 47240:                                           [webProgress, null,
 47240:                                            nsIWebProgressListener.STATE_START |
 47240:                                            nsIWebProgressListener.STATE_IS_NETWORK, 0],
 47240:                                           true, false);
  4891:             }
  4891: 
  4891:             // If the new tab is not busy, and our current state is busy, then
  4891:             // we need to fire a stop to all progress listeners.
  4891:             if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
  4891:               this.mIsBusy = false;
 47240:               this._callProgressListeners(null, "onStateChange",
 47240:                                           [webProgress, null,
 47240:                                            nsIWebProgressListener.STATE_STOP |
 47240:                                            nsIWebProgressListener.STATE_IS_NETWORK, 0],
 47240:                                           true, false);
  4891:             }
  4891: 
 62092:             this._setCloseKeyState(!this.mCurrentTab.pinned);
 62092: 
 33489:             // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code
 33489:             // that might rely upon the other changes suppressed.
 33489:             // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window
 33489:             if (!this._previewMode) {
  5091:               // We've selected the new tab, so go ahead and notify listeners.
 57145:               let event = document.createEvent("Events");
  5091:               event.initEvent("TabSelect", true, false);
  5091:               this.mCurrentTab.dispatchEvent(event);
  5091: 
 35638:               this._tabAttrModified(oldTab);
 35638:               this._tabAttrModified(this.mCurrentTab);
 35638: 
 57145:               // Adjust focus
 72831:               oldBrowser._urlbarFocused = (gURLBar && gURLBar.focused);
 57145:               do {
 72987:                 // When focus is in the tab bar, retain it there.
 72987:                 if (document.activeElement == oldTab) {
 72987:                   // We need to explicitly focus the new tab, because
 72987:                   // tabbox.xml does this only in some cases.
 72987:                   this.mCurrentTab.focus();
 72987:                   break;
 72987:                 }
 68688: 
 68688:                 // If there's a tabmodal prompt showing, focus it.
 68688:                 if (newBrowser.hasAttribute("tabmodalPromptShowing")) {
 68688:                   let XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
 68688:                   let prompts = newBrowser.parentNode.getElementsByTagNameNS(XUL_NS, "tabmodalprompt");
 68688:                   let prompt = prompts[prompts.length - 1];
 68688:                   prompt.Dialog.setDefaultFocus();
 68688:                   break;
 68688:                 }
 68688: 
 57145:                 // Focus the location bar if it was previously focused for that tab.
 57145:                 // In full screen mode, only bother making the location bar visible
 57145:                 // if the tab is a blank one.
 68878:                 if (newBrowser._urlbarFocused && gURLBar) {
 70862: 
 70862:                   // Explicitly close the popup if the URL bar retains focus
 70862:                   gURLBar.closePopup();
 70862: 
 68878:                   if (!window.fullScreen) {
 57145:                     gURLBar.focus();
 57145:                     break;
 68878:                   } else if (isTabEmpty(this.mCurrentTab)) {
 57145:                     focusAndSelectUrlBar();
 57145:                     break;
 57145:                   }
 68878:                 }
 57145: 
 63182:                 // If the find bar is focused, keep it focused.
 63182:                 if (gFindBarInitialized &&
 63182:                     !gFindBar.hidden &&
 63182:                     gFindBar.getElement("findbar-textbox").getAttribute("focused") == "true")
 63182:                   break;
 63182: 
 57145:                 // Otherwise, focus the content area.
 57145:                 let fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
 57145:                 let newFocusedElement = fm.getFocusedElementForWindow(window.content, true, {});
 41071: 
 41071:                 // for anchors, use FLAG_SHOWRING so that it is clear what link was
 41071:                 // last clicked when switching back to that tab
 57145:                 let focusFlags = fm.FLAG_NOSCROLL;
 41071:                 if (newFocusedElement &&
 41071:                     (newFocusedElement instanceof HTMLAnchorElement ||
 41071:                      newFocusedElement.getAttributeNS("http://www.w3.org/1999/xlink", "type") == "simple"))
 41071:                   focusFlags |= fm.FLAG_SHOWRING;
 41071:                 fm.setFocus(newBrowser, focusFlags);
 57145:               } while (false);
 33489:             }
114675: 
136922:             this.tabContainer._setPositionalAttributes();
136922: 
114675:             if (!aForceUpdate)
114675:               TelemetryStopwatch.finish("FX_TAB_SWITCH_UPDATE_MS");
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
 35638:       <method name="_tabAttrModified">
 35638:         <parameter name="aTab"/>
 35638:         <body><![CDATA[
 70847:           if (aTab.closing)
 54361:             return;
 54361: 
 35638:           // This event should be dispatched when any of these attributes change:
 35638:           // label, crop, busy, image, selected
 35638:           var event = document.createEvent("Events");
 35638:           event.initEvent("TabAttrModified", true, false);
 35638:           aTab.dispatchEvent(event);
 35638:         ]]></body>
 35638:       </method>
 35638: 
  4998:       <method name="setTabTitleLoading">
  4998:         <parameter name="aTab"/>
  4998:         <body>
  4998:           <![CDATA[
 55383:             aTab.label = this.mStringBundle.getString("tabs.connecting");
 52023:             aTab.crop = "end";
 35638:             this._tabAttrModified(aTab);
  4998:           ]]>
  4998:         </body>
  4998:       </method>
  4998: 
  4891:       <method name="setTabTitle">
  4891:         <parameter name="aTab"/>
  4891:         <body>
  4891:           <![CDATA[
  4891:             var browser = this.getBrowserForTab(aTab);
  4891:             var crop = "end";
  5104:             var title = browser.contentTitle;
  4957: 
  4957:             if (!title) {
  4957:               if (browser.currentURI.spec) {
  4957:                 try {
  4957:                   title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
  4957:                 } catch(ex) {
  4902:                   title = browser.currentURI.spec;
  4957:                 }
  4957:               }
  4957: 
 88384:               if (title && !isBlankPageURL(title)) {
  4957:                 // At this point, we now have a URI.
  4957:                 // Let's try to unescape it using a character set
  4957:                 // in case the URI is not ASCII.
  4957:                 try {
  4986:                   var characterSet = browser.contentDocument.characterSet;
  4957:                   const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
  4957:                                                  .getService(Components.interfaces.nsITextToSubURI);
  4957:                   title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
  4957:                 } catch(ex) { /* Do nothing. */ }
  4957: 
  4902:                 crop = "center";
  4957: 
  4957:               } else // Still no title?  Fall back to our untitled string.
 39570:                 title = this.mStringBundle.getString("tabs.emptyTabTitle");
  4900:             }
  4891: 
 52014:             if (aTab.label == title &&
 52014:                 aTab.crop == crop)
 52014:               return false;
 52014: 
  4891:             aTab.label = title;
 52023:             aTab.crop = crop;
 35638:             this._tabAttrModified(aTab);
 52370: 
 52370:             if (aTab.selected)
 52370:               this.updateTitlebar();
 52370: 
 52014:             return true;
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4990:       <method name="loadOneTab">
  4990:         <parameter name="aURI"/>
  4990:         <parameter name="aReferrerURI"/>
  4990:         <parameter name="aCharset"/>
  4990:         <parameter name="aPostData"/>
  4990:         <parameter name="aLoadInBackground"/>
  5032:         <parameter name="aAllowThirdPartyFixup"/>
  4990:         <body>
  4990:           <![CDATA[
 43382:             var aFromExternal;
 32469:             var aRelatedToCurrent;
 81496:             var aIsUTF8;
 32469:             if (arguments.length == 2 &&
 32469:                 typeof arguments[1] == "object" &&
 32469:                 !(arguments[1] instanceof Ci.nsIURI)) {
 32469:               let params = arguments[1];
 32469:               aReferrerURI          = params.referrerURI;
 32469:               aCharset              = params.charset;
 32469:               aPostData             = params.postData;
 32469:               aLoadInBackground     = params.inBackground;
 32469:               aAllowThirdPartyFixup = params.allowThirdPartyFixup;
 43382:               aFromExternal         = params.fromExternal;
 32469:               aRelatedToCurrent     = params.relatedToCurrent;
 81496:               aIsUTF8               = params.isUTF8;
 32469:             }
 32469: 
  5070:             var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
 39682:                          Services.prefs.getBoolPref("browser.tabs.loadInBackground");
  5070:             var owner = bgLoad ? null : this.selectedTab;
 32469:             var tab = this.addTab(aURI, {
 32469:                                   referrerURI: aReferrerURI,
 32469:                                   charset: aCharset,
 32469:                                   postData: aPostData,
 32469:                                   ownerTab: owner,
 32469:                                   allowThirdPartyFixup: aAllowThirdPartyFixup,
 43382:                                   fromExternal: aFromExternal,
 81496:                                   relatedToCurrent: aRelatedToCurrent,
 81496:                                   isUTF8: aIsUTF8});
  5018:             if (!bgLoad)
  5018:               this.selectedTab = tab;
  5060: 
  4990:             return tab;
  4990:          ]]>
  4990:         </body>
  4990:       </method>
  4990: 
  5018:       <method name="loadTabs">
  5018:         <parameter name="aURIs"/>
  5018:         <parameter name="aLoadInBackground"/>
  5018:         <parameter name="aReplace"/>
  5018:         <body><![CDATA[
 23891:           if (!aURIs.length)
 23891:             return;
 23891: 
  5018:           // The tab selected after this new tab is closed (i.e. the new tab's
  5018:           // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
  5018:           // when several urls are opened here (i.e. closing the first should select
  5018:           // the next of many URLs opened) or if the pref to have UI links opened in
  5018:           // the background is set (i.e. the link is not being opened modally)
  5018:           //
  5018:           // i.e.
  5018:           //    Number of URLs    Load UI Links in BG       Focus Last Viewed?
  5018:           //    == 1              false                     YES
  5018:           //    == 1              true                      NO
  5018:           //    > 1               false/true                NO
 49630:           var multiple = aURIs.length > 1;
 49630:           var owner = multiple || aLoadInBackground ? null : this.selectedTab;
  5018:           var firstTabAdded = null;
 24120: 
 24120:           if (aReplace) {
 24120:             try {
  5018:               this.loadURI(aURIs[0], null, null);
 24120:             } catch (e) {
 24120:               // Ignore failure in case a URI is wrong, so we can continue
 24120:               // opening the next ones.
 24120:             }
 24120:           }
  5018:           else
 49630:             firstTabAdded = this.addTab(aURIs[0], {ownerTab: owner, skipAnimation: multiple});
  5018: 
 39702:           var tabNum = this.tabContainer.selectedIndex;
 15777:           for (let i = 1; i < aURIs.length; ++i) {
 43571:             let tab = this.addTab(aURIs[i], {skipAnimation: true});
  5068:             if (aReplace)
  5068:               this.moveTabTo(tab, ++tabNum);
  5068:           }
  5068: 
  5018:           if (!aLoadInBackground) {
  5018:             if (firstTabAdded) {
  5018:               // .selectedTab setter focuses the content area
  5018:               this.selectedTab = firstTabAdded;
  5018:             }
  5018:             else
114365:               this.selectedBrowser.focus();
  5018:           }
  5018:         ]]></body>
  5018:       </method>
  5018: 
  4891:       <method name="addTab">
  4891:         <parameter name="aURI"/>
  4891:         <parameter name="aReferrerURI"/>
  4911:         <parameter name="aCharset"/>
  4927:         <parameter name="aPostData"/>
  5018:         <parameter name="aOwner"/>
  5032:         <parameter name="aAllowThirdPartyFixup"/>
  4891:         <body>
  4891:           <![CDATA[
 43382:             var aFromExternal;
 32469:             var aRelatedToCurrent;
 43571:             var aSkipAnimation;
 81496:             var aIsUTF8;
 32469:             if (arguments.length == 2 &&
 32469:                 typeof arguments[1] == "object" &&
 32469:                 !(arguments[1] instanceof Ci.nsIURI)) {
 32469:               let params = arguments[1];
 32469:               aReferrerURI          = params.referrerURI;
 32469:               aCharset              = params.charset;
 32469:               aPostData             = params.postData;
 32469:               aOwner                = params.ownerTab;
 32469:               aAllowThirdPartyFixup = params.allowThirdPartyFixup;
 43382:               aFromExternal         = params.fromExternal;
 32469:               aRelatedToCurrent     = params.relatedToCurrent;
 43571:               aSkipAnimation        = params.skipAnimation;
 81496:               aIsUTF8               = params.isUTF8;
 32469:             }
 32469: 
  5050:             // if we're adding tabs, we're past interrupt mode, ditch the owner
  5050:             if (this.mCurrentTab.owner)
  5050:               this.mCurrentTab.owner = null;
  5050: 
  5060:             var t = document.createElementNS(
  5060:               "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
  4891:                                              "tab");
  4891: 
106272:             var uriIsBlankPage = !aURI || isBlankPageURL(aURI);
106272:             var uriIsNotAboutBlank = aURI && aURI != "about:blank";
106272: 
114104:             if (uriIsBlankPage)
114104:               t.setAttribute("label", this.mStringBundle.getString("tabs.emptyTabTitle"));
114104:             else
114104:               t.setAttribute("label", aURI);
114104: 
  4891:             t.setAttribute("crop", "end");
  6783:             t.setAttribute("onerror", "this.removeAttribute('image');");
  5018:             t.className = "tabbrowser-tab";
  5050: 
 67993:             this.tabContainer._unlockTabSizing();
 67993: 
 43571:             // When overflowing, new tabs are scrolled into view smoothly, which
 43571:             // doesn't go well together with the width transition. So we skip the
 43571:             // transition in that case.
135169:             let animate = !aSkipAnimation &&
135169:                           this.tabContainer.getAttribute("overflow") != "true" &&
135169:                           Services.prefs.getBoolPref("browser.tabs.animate");
135169:             if (!animate) {
 43571:               t.setAttribute("fadein", "true");
 43571:               setTimeout(function (tabContainer) {
 43571:                 tabContainer._handleNewTab(t);
 43571:               }, 0, this.tabContainer);
 43571:             }
 43571: 
 97274:             // invalidate caches
 97274:             this._browsers = null;
 97274:             this._visibleTabs = null;
 97274: 
 39702:             this.tabContainer.appendChild(t);
  5073: 
  5018:             // If this new tab is owned by another, assert that relationship
 27698:             if (aOwner)
  5018:               t.owner = aOwner;
  5018: 
  5060:             var b = document.createElementNS(
  5060:               "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
  4945:                                              "browser");
  5025:             b.setAttribute("type", "content-targetable");
  4943:             b.setAttribute("message", "true");
  4891:             b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
  4891:             b.setAttribute("tooltip", this.getAttribute("contenttooltip"));
 60693: 
 73594:             if (Services.prefs.getPrefType("browser.tabs.remote") == Services.prefs.PREF_BOOL &&
 73594:                 Services.prefs.getBoolPref("browser.tabs.remote")) {
 73594:               b.setAttribute("remote", "true");
 73594:             }
 73594: 
 61724:             if (window.gShowPageResizers && document.getElementById("addon-bar").collapsed &&
 61724:                 window.windowState == window.STATE_NORMAL) {
 60693:               b.setAttribute("showresizer", "true");
 60693:             }
 60693: 
  5010:             if (this.hasAttribute("autocompletepopup"))
  4909:               b.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
  5134:             b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
  4917: 
 54453:             // Create the browserStack container
 54453:             var stack = document.createElementNS(
 54453:                                     "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
 54453:                                     "stack");
111101:             stack.className = "browserStack";
 54453:             stack.appendChild(b);
 54453:             stack.setAttribute("flex", "1");
 54453: 
 99978:             // Create the browserContainer
111101:             var browserContainer = document.createElementNS(
 99978:                                     "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
 99978:                                     "vbox");
111101:             browserContainer.className = "browserContainer";
111101:             browserContainer.appendChild(stack);
111101:             browserContainer.setAttribute("flex", "1");
111101: 
111101:             // Create the sidebar container
111101:             var browserSidebarContainer = document.createElementNS(
111101:                                       "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
111101:                                       "hbox");
111101:             browserSidebarContainer.className = "browserSidebarContainer";
111101:             browserSidebarContainer.appendChild(browserContainer);
111101:             browserSidebarContainer.setAttribute("flex", "1");
 99978: 
  4943:             // Add the Message and the Browser to the box
  5036:             var notificationbox = document.createElementNS(
  5036:                                     "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
  5036:                                     "notificationbox");
  5036:             notificationbox.setAttribute("flex", "1");
111101:             notificationbox.appendChild(browserSidebarContainer);
 49091: 
 49091:             var position = this.tabs.length - 1;
 68410:             var uniqueId = "panel" + Date.now() + position;
 49091:             notificationbox.id = uniqueId;
 49091:             t.linkedPanel = uniqueId;
 49091:             t.linkedBrowser = b;
 49091:             t._tPos = position;
136922:             this.tabContainer._setPositionalAttributes();
 49091: 
 49091:             // NB: this appendChild call causes us to run constructors for the
 49091:             // browser element, which fires off a bunch of notifications. Some
 49091:             // of those notifications can cause code to run that inspects our
 49091:             // state, so it is important that the tab element is fully
 49091:             // initialized by this point.
  5036:             this.mPanelContainer.appendChild(notificationbox);
  4891: 
 39508:             this.tabContainer.updateVisibility();
  4891: 
106272:             if (uriIsNotAboutBlank) {
106272:               // Stop the existing about:blank load.  Otherwise, if aURI
106272:               // doesn't stop in-progress loads on its own, we'll get into
106272:               // trouble with multiple parallel loads running at once.
106272:               b.stop();
106272:             }
106272: 
  4891:             // wire up a progress listener for the new browser object.
106272:             var tabListener = this.mTabProgressListener(t, b, uriIsBlankPage);
  4891:             const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
  4891:                                      .createInstance(Components.interfaces.nsIWebProgress);
  4891:             filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
 73596: #ifdef MOZ_E10S_COMPAT
 73596:             // Bug 666801 - WebProgress support for e10s
 73596: #else
  4891:             b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
 73596: #endif
  4891:             this.mTabListeners[position] = tabListener;
  4891:             this.mTabFilters[position] = filter;
  4891: 
  4943:             b._fastFind = this.fastFind;
 40970:             b.droppedLinkHandler = handleDroppedLink;
  4943: 
  5050:             // Dispatch a new tab notification.  We do this once we're
  5050:             // entirely done, so that things are in a consistent state
  5050:             // even if the event listener opens or closes tabs.
  5050:             var evt = document.createEvent("Events");
  5050:             evt.initEvent("TabOpen", true, false);
  5050:             t.dispatchEvent(evt);
  5075: 
106272:             if (uriIsNotAboutBlank) {
 42320:               // pretend the user typed this so it'll be available till
 42320:               // the document successfully loads
106272:               if (!uriIsBlankPage)
 42320:                 b.userTypedValue = aURI;
 42320: 
 43382:               let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
 43382:               if (aAllowThirdPartyFixup)
 43382:                 flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
 43382:               if (aFromExternal)
 43382:                 flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
 81496:               if (aIsUTF8)
 81496:                 flags |= Ci.nsIWebNavigation.LOAD_FLAGS_URI_IS_UTF8;
 33716:               try {
 33716:                 b.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset, aPostData);
 71280:               } catch (ex) {
 71280:                 Cu.reportError(ex);
 58400:               }
 58400:             }
 58400: 
 48937:             // We start our browsers out as inactive, and then maintain
 48937:             // activeness in the tab switcher.
 73596:             b.docShellIsActive = false;
 33716: 
108212:             // If we just created a new tab that loads the default
108212:             // newtab url, swap in a preloaded page if possible.
131386:             // Do nothing if we're a private window.
131386:             if (aURI == BROWSER_NEW_TAB_URL &&
131386:                 !PrivateBrowsingUtils.isWindowPrivate(window)) {
108212:               gBrowserNewTabPreloader.newTab(t);
108212:             }
108212: 
 32240:             // Check if we're opening a tab related to the current tab and
 32240:             // move it to after the current tab.
 32240:             // aReferrerURI is null or undefined if the tab is opened from
 32240:             // an external application or bookmark, i.e. somewhere other
 32240:             // than the current tab.
 74777:             if ((aRelatedToCurrent == null ? aReferrerURI : aRelatedToCurrent) &&
 74777:                 Services.prefs.getBoolPref("browser.tabs.insertRelatedAfterCurrent")) {
 32240:               let newTabPos = (this._lastRelatedTab ||
 32240:                                this.selectedTab)._tPos + 1;
 52075:               if (this._lastRelatedTab)
 52075:                 this._lastRelatedTab.owner = null;
 52075:               else
 52075:                 t.owner = this.selectedTab;
 32240:               this.moveTabTo(t, newTabPos);
 32240:               this._lastRelatedTab = t;
 32240:             }
 32240: 
135169:             if (animate) {
135573:               this.tabContainer._handleTabTelemetryStart(t, aURI);
135169: 
135169:               // kick the animation off
135169:               t.clientTop;
135169:               t.setAttribute("fadein", "true");
135169: 
135169:               // This call to adjustTabstrip is redundant but needed so that
135169:               // when opening a second tab, the first tab's close buttons
135169:               // appears immediately rather than when the transition ends.
135169:               if (this.tabContainer.childNodes.length == 2)
135169:                 this.tabContainer.adjustTabstrip();
135169:             }
135169: 
  4891:             return t;
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4943:       <method name="warnAboutClosingTabs">
  4943:       <parameter name="aAll"/>
  4943:       <body>
  4943:         <![CDATA[
 91288:           var tabsToClose = (aAll ?
 91288:                                this.tabs.length - this._removingTabs.length :
 91288:                                this.visibleTabs.length - 1)
 51017:                             - gBrowser._numPinnedTabs;
 40709:           if (tabsToClose <= 1)
 40709:             return true;
  4943: 
116302:           const pref = aAll ?
116302:                        "browser.tabs.warnOnClose" : "browser.tabs.warnOnCloseOtherTabs";
116302:           var shouldPrompt = Services.prefs.getBoolPref(pref);
116302:           if (!shouldPrompt)
 40709:             return true;
 40709: 
 40709:           var ps = Services.prompt;
  4943: 
  4943:           // default to true: if it were false, we wouldn't get this far
  4943:           var warnOnClose = { value: true };
  4943:           var bundle = this.mStringBundle;
 40709: 
  5093:           // focus the window before prompting.
  5093:           // this will raise any minimized window, which will
  5093:           // make it obvious which window the prompt is for and will
  5093:           // solve the problem of windows "obscuring" the prompt.
  5093:           // see bug #350299 for more details
  5093:           window.focus();
 40709:           var buttonPressed =
 40709:             ps.confirmEx(window,
 40709:                          bundle.getString("tabs.closeWarningTitle"),
 40709:                          bundle.getFormattedString("tabs.closeWarningMultipleTabs",
 40709:                                                    [tabsToClose]),
 40709:                          (ps.BUTTON_TITLE_IS_STRING * ps.BUTTON_POS_0)
 40709:                          + (ps.BUTTON_TITLE_CANCEL * ps.BUTTON_POS_1),
 40709:                          bundle.getString("tabs.closeButtonMultiple"),
  4943:                          null, null,
116302:                          aAll ?
103545:                            bundle.getString("tabs.closeWarningPromptMe") : null,
  4943:                          warnOnClose);
 40709:           var reallyClose = (buttonPressed == 0);
103545: 
  4943:           // don't set the pref unless they press OK and it's false
116302:           if (aAll && reallyClose && !warnOnClose.value)
 39682:             Services.prefs.setBoolPref(pref, false);
 40709: 
  4943:           return reallyClose;
  4943:         ]]>
  4943:       </body>
  4943:       </method>
  4943: 
  4912:       <method name="removeAllTabsBut">
  4912:         <parameter name="aTab"/>
  4912:         <body>
  4912:           <![CDATA[
 48120:             if (aTab.pinned)
 48120:               return;
 48120: 
  4943:             if (this.warnAboutClosingTabs(false)) {
 49634:               let tabs = this.visibleTabs;
 20730:               this.selectedTab = aTab;
 20730: 
 49634:               for (let i = tabs.length - 1; i >= 0; --i) {
 49634:                 if (tabs[i] != aTab && !tabs[i].pinned)
 49634:                   this.removeTab(tabs[i]);
  4926:               }
  4943:             }
  4912:           ]]>
  4912:         </body>
  4912:       </method>
  4912: 
  4891:       <method name="removeCurrentTab">
 49132:         <parameter name="aParams"/>
  4891:         <body>
  4891:           <![CDATA[
 49132:             this.removeTab(this.mCurrentTab, aParams);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
 26500:       <field name="_removingTabs">
 26500:         []
 26500:       </field>
 26500: 
  4891:       <method name="removeTab">
  4891:         <parameter name="aTab"/>
 49132:         <parameter name="aParams"/>
  4891:         <body>
  4891:           <![CDATA[
 67993:             if (aParams) {
 49132:               var animate = aParams.animate;
 67993:               var byMouse = aParams.byMouse;
 67993:             }
 49132: 
 49631:             // Handle requests for synchronously removing an already
 49631:             // asynchronously closing tab.
 49631:             if (!animate &&
 70847:                 aTab.closing) {
 49631:               this._endRemoveTab(aTab);
 49631:               return;
 49631:             }
 49631: 
 49631:             var isLastTab = (this.tabs.length - this._removingTabs.length == 1);
 49631: 
 49132:             if (!this._beginRemoveTab(aTab, false, null, true))
 49132:               return;
 49132: 
 67993:             if (!aTab.pinned && !aTab.hidden && aTab._fullyOpen && byMouse)
 67993:               this.tabContainer._lockTabSizing(aTab);
 67993:             else
 67993:               this.tabContainer._unlockTabSizing();
 67993: 
 56357:             if (!animate /* the caller didn't opt in */ ||
 49132:                 isLastTab ||
 49132:                 aTab.pinned ||
 91282:                 aTab.hidden ||
 56357:                 this._removingTabs.length > 3 /* don't want lots of concurrent animations */ ||
 56357:                 aTab.getAttribute("fadein") != "true" /* fade-in transition hasn't been triggered yet */ ||
 58254:                 window.getComputedStyle(aTab).maxWidth == "0.1px" /* fade-in transition hasn't moved yet */ ||
 49132:                 !Services.prefs.getBoolPref("browser.tabs.animate")) {
 49132:               this._endRemoveTab(aTab);
 49132:               return;
 49132:             }
 49132: 
135573:             this.tabContainer._handleTabTelemetryStart(aTab);
 84831: 
 49132:             this._blurTab(aTab);
136377:             aTab.style.maxWidth = ""; // ensure that fade-out transition happens
 49132:             aTab.removeAttribute("fadein");
 59644: 
 59644:             setTimeout(function (tab, tabbrowser) {
 60492:               if (tab.parentNode &&
 60492:                   window.getComputedStyle(tab).maxWidth == "0.1px") {
 59644:                 NS_ASSERT(false, "Giving up waiting for the tab closing animation to finish (bug 608589)");
 59644:                 tabbrowser._endRemoveTab(tab);
 59644:               }
 60122:             }, 3000, aTab, this);
 16549:           ]]>
 16549:         </body>
 16549:       </method>
 16549: 
 26500:       <!-- Tab close requests are ignored if the window is closing anyway,
 26500:            e.g. when holding Ctrl+W. -->
 26500:       <field name="_windowIsClosing">
 26500:         false
 26500:       </field>
 26500: 
 16549:       <method name="_beginRemoveTab">
 16549:         <parameter name="aTab"/>
 28379:         <parameter name="aTabWillBeMoved"/>
 20727:         <parameter name="aCloseWindowWithLastTab"/>
 26925:         <parameter name="aCloseWindowFastpath"/>
 16549:         <body>
 16549:           <![CDATA[
 90401:             if (aTab.closing ||
 90401:                 aTab._pendingPermitUnload ||
 90401:                 this._windowIsClosing)
 49132:               return false;
 26500: 
 26500:             var browser = this.getBrowserForTab(aTab);
 26500: 
 28379:             if (!aTabWillBeMoved) {
 26500:               let ds = browser.docShell;
 90401:               if (ds && ds.contentViewer) {
 90401:                 // We need to block while calling permitUnload() because it
 90401:                 // processes the event queue and may lead to another removeTab()
 90401:                 // call before permitUnload() even returned.
 90401:                 aTab._pendingPermitUnload = true;
 90401:                 let permitUnload = ds.contentViewer.permitUnload();
 90401:                 delete aTab._pendingPermitUnload;
 90401: 
 90401:                 if (!permitUnload)
 49132:                   return false;
 19341:               }
 90401:             }
 19341: 
 20727:             var closeWindow = false;
 27831:             var newTab = false;
 50436:             if (this.tabs.length - this._removingTabs.length == 1) {
 34645:               closeWindow = aCloseWindowWithLastTab != null ? aCloseWindowWithLastTab :
 34645:                             !window.toolbar.visible ||
 39706:                               this.tabContainer._closeWindowWithLastTab;
 20727: 
 26925:               // Closing the tab and replacing it with a blank one is notably slower
 26925:               // than closing the window right away. If the caller opts in, take
 26925:               // the fast path.
 26925:               if (closeWindow &&
 26925:                   aCloseWindowFastpath &&
 26925:                   this._removingTabs.length == 0 &&
129525:                   (this._windowIsClosing = window.closeWindow(true, window.warnAboutClosingWindow)))
 26925:                 return null;
 26925: 
 27831:               newTab = true;
 19500:             }
  8287: 
 70847:             aTab.closing = true;
 26500:             this._removingTabs.push(aTab);
 97274:             this._visibleTabs = null; // invalidate cache
 70042:             if (newTab)
 88384:               this.addTab(BROWSER_NEW_TAB_URL, {skipAnimation: true});
 70042:             else
 39508:               this.tabContainer.updateVisibility();
 39508: 
  5071:             // We're committed to closing the tab now.
  5071:             // Dispatch a notification.
  5071:             // We dispatch it before any teardown so that event listeners can
  5071:             // inspect the tab that's about to close.
 28379:             var evt = document.createEvent("UIEvent");
 28379:             evt.initUIEvent("TabClose", true, false, window, aTabWillBeMoved ? 1 : 0);
  5071:             aTab.dispatchEvent(evt);
  5071: 
108233:             // Prevent this tab from showing further dialogs, since we're closing it
108233:             var windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).
108233:                               getInterface(Ci.nsIDOMWindowUtils);
108233:             windowUtils.preventFurtherDialogs();
108233: 
  4891:             // Remove the tab's filter and progress listener.
 26500:             const filter = this.mTabFilters[aTab._tPos];
 73596: #ifdef MOZ_E10S_COMPAT
 73596:             // Bug 666801 - WebProgress support for e10s
 73596: #else
 26500:             browser.webProgress.removeProgressListener(filter);
 73596: #endif
 26500:             filter.removeProgressListener(this.mTabListeners[aTab._tPos]);
 33328:             this.mTabListeners[aTab._tPos].destroy();
  4891: 
 52081:             if (browser.registeredOpenURI && !aTabWillBeMoved) {
 59359:               this._placesAutocomplete.unregisterOpenPage(browser.registeredOpenURI);
 50528:               delete browser.registeredOpenURI;
 50528:             }
 39889: 
  4891:             // We are no longer the primary content area.
 26500:             browser.setAttribute("type", "content-targetable");
  4891: 
 13380:             // Remove this tab as the owner of any other tabs, since it's going away.
 39702:             Array.forEach(this.tabs, function (tab) {
 16549:               if ("owner" in tab && tab.owner == aTab)
 13380:                 // |tab| is a child of the tab we're removing, make it an orphan
 13380:                 tab.owner = null;
 26500:             });
  5018: 
 49132:             aTab._endRemoveArgs = [closeWindow, newTab];
 49132:             return true;
 16549:           ]]>
 16549:         </body>
 16549:       </method>
 16549: 
 16549:       <method name="_endRemoveTab">
 49132:         <parameter name="aTab"/>
 16549:         <body>
 16549:           <![CDATA[
 49132:             if (!aTab || !aTab._endRemoveArgs)
 19500:               return;
 49132: 
 49132:             var [aCloseWindow, aNewTab] = aTab._endRemoveArgs;
 49132:             aTab._endRemoveArgs = null;
 49132: 
 49132:             if (this._windowIsClosing) {
 49132:               aCloseWindow = false;
 49132:               aNewTab = false;
 49132:             }
 19341: 
 32240:             this._lastRelatedTab = null;
 32240: 
 26500:             // update the UI early for responsiveness
 26500:             aTab.collapsed = true;
 26500:             this.tabContainer._fillTrailingGap();
 26500:             this._blurTab(aTab);
 26500: 
 26500:             this._removingTabs.splice(this._removingTabs.indexOf(aTab), 1);
 26500: 
 26500:             if (aCloseWindow) {
 26500:               this._windowIsClosing = true;
 26500:               while (this._removingTabs.length)
 49132:                 this._endRemoveTab(this._removingTabs[0]);
 26500:             } else if (!this._windowIsClosing) {
 33463:               if (aNewTab)
 33463:                 focusAndSelectUrlBar();
 30181: 
 30181:               // workaround for bug 345399
 30181:               this.tabContainer.mTabstrip._updateScrollButtonsDisabledState();
 26587:             }
 26500: 
 26500:             // We're going to remove the tab and the browser now.
 26500:             // Clean up mTabFilters and mTabListeners now rather than in
 26500:             // _beginRemoveTab, so that their size is always in sync with the
 26500:             // number of tabs and browsers (the xbl destructor depends on this).
 26500:             this.mTabFilters.splice(aTab._tPos, 1);
 26500:             this.mTabListeners.splice(aTab._tPos, 1);
 26500: 
 16549:             var browser = this.getBrowserForTab(aTab);
 16549: 
  4958:             // Because of the way XBL works (fields just set JS
  4958:             // properties on the element) and the code we have in place
  4958:             // to preserve the JS objects for any elements that have
  4958:             // JS properties set on them, the browser element won't be
  4958:             // destroyed until the document goes away.  So we force a
  4958:             // cleanup ourselves.
  4960:             // This has to happen before we remove the child so that the
 29018:             // XBL implementation of nsIObserver still works.
 16549:             browser.destroy();
 16549: 
 16549:             if (browser == this.mCurrentBrowser)
  9100:               this.mCurrentBrowser = null;
  9100: 
 60754:             var wasPinned = aTab.pinned;
 60754: 
 26500:             // Invalidate browsers cache, as the tab is removed from the
 26500:             // tab container.
 13380:             this._browsers = null;
 26500: 
 26500:             // Remove the tab ...
 26500:             this.tabContainer.removeChild(aTab);
 26500: 
 26500:             // ... and fix up the _tPos properties immediately.
 39702:             for (let i = aTab._tPos; i < this.tabs.length; i++)
 39702:               this.tabs[i]._tPos = i;
 26500: 
 46158:             if (!this._windowIsClosing) {
 60754:               if (wasPinned)
 46158:                 this.tabContainer._positionPinnedTabs();
 46158: 
 31586:               // update tab close buttons state
 31586:               this.tabContainer.adjustTabstrip();
136377: 
136377:               setTimeout(function(tabs) {
136377:                 tabs._lastTabClosedByMouse = false;
136377:               }, 0, this.tabContainer);
 46158:             }
 31586: 
136922:             // update tab positional properties and attributes
 26500:             this.selectedTab._selected = true;
136922:             this.tabContainer._setPositionalAttributes();
 26500: 
 48398:             // Removing the panel requires fixing up selectedPanel immediately
 48398:             // (see below), which would be hindered by the potentially expensive
 48398:             // browser removal. So we remove the browser and the panel in two
 48398:             // steps.
 99978: 
 99978:             var panel = this.getNotificationBox(browser);
 48398: 
 26500:             // This will unload the document. An unload handler could remove
 26500:             // dependant tabs, so it's important that the tabbrowser is now in
 26500:             // a consistent state (tab removed, tab positions updated, etc.).
111101:             browser.parentNode.removeChild(browser);
 48398: 
 71963:             // Release the browser in case something is erroneously holding a
 71963:             // reference to the tab after its removal.
 71963:             aTab.linkedBrowser = null;
 71963: 
 48398:             // As the browser is removed, the removal of a dependent document can
 26500:             // cause the whole window to close. So at this point, it's possible
 26500:             // that the binding is destructed.
 48398:             if (this.mTabBox) {
 48398:               let selectedPanel = this.mTabBox.selectedPanel;
 48398: 
 48398:               this.mPanelContainer.removeChild(panel);
 48398: 
 48398:               // Under the hood, a selectedIndex attribute controls which panel
 48398:               // is displayed. Removing a panel A which precedes the selected
 48398:               // panel B makes selectedIndex point to the panel next to B. We
 48398:               // need to explicitly preserve B as the selected panel.
 48398:               this.mTabBox.selectedPanel = selectedPanel;
 48398:             }
 26500: 
 20727:             if (aCloseWindow)
129525:               this._windowIsClosing = closeWindow(true, window.warnAboutClosingWindow);
 26500:           ]]>
 26500:         </body>
 26500:       </method>
 26500: 
 26500:       <method name="_blurTab">
 26500:         <parameter name="aTab"/>
 26500:         <body>
 26500:           <![CDATA[
126878:             if (!aTab.selected)
 26500:               return;
 26500: 
 26500:             if (aTab.owner &&
 60821:                 !aTab.owner.hidden &&
 70847:                 !aTab.owner.closing &&
 39682:                 Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")) {
 26500:               this.selectedTab = aTab.owner;
 26500:               return;
 26500:             }
 26500: 
 50740:             // Switch to a visible tab unless there aren't any others remaining
 50740:             let remainingTabs = this.visibleTabs;
 50740:             let numTabs = remainingTabs.length;
 50740:             if (numTabs == 0 || numTabs == 1 && remainingTabs[0] == aTab) {
 50740:               remainingTabs = Array.filter(this.tabs, function(tab) {
 70847:                 return !tab.closing;
 50740:               }, this);
 49634:             }
 49634: 
 49634:             // Try to find a remaining tab that comes after the given tab
 26500:             var tab = aTab;
 26500:             do {
 26500:               tab = tab.nextSibling;
 49634:             } while (tab && remainingTabs.indexOf(tab) == -1);
 26500: 
 26500:             if (!tab) {
 26500:               tab = aTab;
 26500: 
 26500:               do {
 26500:                 tab = tab.previousSibling;
 49634:               } while (tab && remainingTabs.indexOf(tab) == -1);
 26500:             }
 26500: 
 26500:             this.selectedTab = tab;
 16549:           ]]>
 16549:         </body>
 16549:       </method>
 16549: 
108211:       <method name="swapNewTabWithBrowser">
108211:         <parameter name="aNewTab"/>
108211:         <parameter name="aBrowser"/>
108211:         <body>
108211:           <![CDATA[
108211:             // The browser must be standalone.
108211:             if (aBrowser.getTabBrowser())
108211:               throw Cr.NS_ERROR_INVALID_ARG;
108211: 
108211:             // The tab is definitely not loading.
108211:             aNewTab.removeAttribute("busy");
126878:             if (aNewTab.selected) {
108211:               this.mIsBusy = false;
108211:             }
108211: 
108211:             this._swapBrowserDocShells(aNewTab, aBrowser);
108211: 
108211:             // Update the new tab's title.
108211:             this.setTabTitle(aNewTab);
108211: 
126878:             if (aNewTab.selected) {
108211:               this.updateCurrentBrowser(true);
108211:             }
108211:           ]]>
108211:         </body>
108211:       </method>
108211: 
 16549:       <method name="swapBrowsersAndCloseOther">
 16549:         <parameter name="aOurTab"/>
 16549:         <parameter name="aOtherTab"/>
 16549:         <body>
 16549:           <![CDATA[
125007:             // Do not allow transfering a private tab to a non-private window
125007:             // and vice versa.
125007:             if (PrivateBrowsingUtils.isWindowPrivate(window) !=
125007:                 PrivateBrowsingUtils.isWindowPrivate(aOtherTab.ownerDocument.defaultView))
125007:               return;
125007: 
 27396:             // That's gBrowser for the other window, not the tab's browser!
 49132:             var remoteBrowser = aOtherTab.ownerDocument.defaultView.gBrowser;
134025:             var isPending = aOtherTab.hasAttribute("pending");
 16549: 
 16549:             // First, start teardown of the other browser.  Make sure to not
 20727:             // fire the beforeunload event in the process.  Close the other
 20727:             // window if this was its last tab.
 49132:             if (!remoteBrowser._beginRemoveTab(aOtherTab, true, true))
 49132:               return;
 16549: 
134025:             let ourBrowser = this.getBrowserForTab(aOurTab);
134025:             let otherBrowser = aOtherTab.linkedBrowser;
134025: 
134025:             // If the other tab is pending (i.e. has not been restored, yet)
134025:             // then do not switch docShells but retrieve the other tab's state
134025:             // and apply it to our tab.
134025:             if (isPending) {
134025:               let ss = Cc["@mozilla.org/browser/sessionstore;1"]
134025:                          .getService(Ci.nsISessionStore)
134025:               ss.setTabState(aOurTab, ss.getTabState(aOtherTab));
134025: 
134025:               // Make sure to unregister any open URIs.
134025:               this._swapRegisteredOpenURIs(ourBrowser, otherBrowser);
134025:             } else {
 27396:               // Workarounds for bug 458697
 27396:               // Icon might have been set on DOMLinkAdded, don't override that.
 52081:               if (!ourBrowser.mIconURL && otherBrowser.mIconURL)
 52081:                 this.setIcon(aOurTab, otherBrowser.mIconURL);
 27396:               var isBusy = aOtherTab.hasAttribute("busy");
 27396:               if (isBusy) {
 27396:                 aOurTab.setAttribute("busy", "true");
 35638:                 this._tabAttrModified(aOurTab);
126878:                 if (aOurTab.selected)
 27396:                   this.mIsBusy = true;
 27396:               }
 27396: 
108211:               this._swapBrowserDocShells(aOurTab, otherBrowser);
134025:             }
 16549: 
 16549:             // Finish tearing down the tab that's going away.
 49132:             remoteBrowser._endRemoveTab(aOtherTab);
 16549: 
 27396:             if (isBusy)
 27396:               this.setTabTitleLoading(aOurTab);
 27396:             else
 21712:               this.setTabTitle(aOurTab);
 21712: 
 24093:             // If the tab was already selected (this happpens in the scenario
 24093:             // of replaceTabWithWindow), notify onLocationChange, etc.
126878:             if (aOurTab.selected)
 21712:               this.updateCurrentBrowser(true);
 13380:           ]]>
 13380:         </body>
  4891:       </method>
  4891: 
108211:       <method name="_swapBrowserDocShells">
108211:         <parameter name="aOurTab"/>
108211:         <parameter name="aOtherBrowser"/>
108211:         <body>
108211:           <![CDATA[
108211:             // Unhook our progress listener
108211:             let index = aOurTab._tPos;
108211:             const filter = this.mTabFilters[index];
108211:             let tabListener = this.mTabListeners[index];
108211:             let ourBrowser = this.getBrowserForTab(aOurTab);
108211:             ourBrowser.webProgress.removeProgressListener(filter);
108211:             filter.removeProgressListener(tabListener);
108211: 
134025:             // Make sure to unregister any open URIs.
134025:             this._swapRegisteredOpenURIs(ourBrowser, aOtherBrowser);
108211: 
108211:             // Swap the docshells
108211:             ourBrowser.swapDocShells(aOtherBrowser);
108211: 
108211:             // Restore the progress listener
108211:             this.mTabListeners[index] = tabListener =
108211:               this.mTabProgressListener(aOurTab, ourBrowser, false);
108211: 
108211:             const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
108211:             filter.addProgressListener(tabListener, notifyAll);
108211:             ourBrowser.webProgress.addProgressListener(filter, notifyAll);
108211:           ]]>
108211:         </body>
108211:       </method>
108211: 
134025:       <method name="_swapRegisteredOpenURIs">
134025:         <parameter name="aOurBrowser"/>
134025:         <parameter name="aOtherBrowser"/>
134025:         <body>
134025:           <![CDATA[
134025:             // If the current URI is registered as open remove it from the list.
134025:             if (aOurBrowser.registeredOpenURI) {
134025:               this._placesAutocomplete.unregisterOpenPage(aOurBrowser.registeredOpenURI);
134025:               delete aOurBrowser.registeredOpenURI;
134025:             }
134025: 
134025:             // If the other/new URI is registered as open then copy it over.
134025:             if (aOtherBrowser.registeredOpenURI) {
134025:               aOurBrowser.registeredOpenURI = aOtherBrowser.registeredOpenURI;
134025:               delete aOtherBrowser.registeredOpenURI;
134025:             }
134025:           ]]>
134025:         </body>
134025:       </method>
134025: 
  4891:       <method name="reloadAllTabs">
  4891:         <body>
  4891:           <![CDATA[
 49634:             let tabs = this.visibleTabs;
 49634:             let l = tabs.length;
  4920:             for (var i = 0; i < l; i++) {
  4920:               try {
 49634:                 this.getBrowserForTab(tabs[i]).reload();
  4920:               } catch (e) {
  4920:                 // ignore failure to reload so others will be reloaded
  4920:               }
  4920:             }
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="reloadTab">
  4891:         <parameter name="aTab"/>
  4891:         <body>
  4891:           <![CDATA[
  4920:             this.getBrowserForTab(aTab).reload();
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="addProgressListener">
  4891:         <parameter name="aListener"/>
  4891:         <body>
  4891:           <![CDATA[
 63921:             if (arguments.length != 1) {
 63921:               Components.utils.reportError("gBrowser.addProgressListener was " +
 63921:                                            "called with a second argument, " +
 63921:                                            "which is not supported. See bug " +
 63921:                                            "608628.");
 63921:             }
 63660: 
  4891:             this.mProgressListeners.push(aListener);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="removeProgressListener">
  4891:         <parameter name="aListener"/>
  4891:         <body>
  4891:           <![CDATA[
 47240:             this.mProgressListeners =
 47240:               this.mProgressListeners.filter(function (l) l != aListener);
  4891:          ]]>
  4891:         </body>
  4891:       </method>
  4891: 
 21759:       <method name="addTabsProgressListener">
 21759:         <parameter name="aListener"/>
 21759:         <body>
 21759:           this.mTabsProgressListeners.push(aListener);
 21759:         </body>
 21759:       </method>
 21759: 
 21759:       <method name="removeTabsProgressListener">
 21759:         <parameter name="aListener"/>
 21759:         <body>
 21759:         <![CDATA[
 47240:           this.mTabsProgressListeners =
 47240:             this.mTabsProgressListeners.filter(function (l) l != aListener);
 21759:         ]]>
 21759:         </body>
 21759:       </method>
 21759: 
  4891:       <method name="getBrowserForTab">
  4891:         <parameter name="aTab"/>
  4891:         <body>
  4891:         <![CDATA[
  4972:           return aTab.linkedBrowser;
  4891:         ]]>
  4891:         </body>
  4891:       </method>
  4891: 
 49634:       <method name="showOnlyTheseTabs">
 49634:         <parameter name="aTabs"/>
 49634:         <body>
 49634:         <![CDATA[
 49634:           Array.forEach(this.tabs, function(tab) {
 50697:             if (aTabs.indexOf(tab) == -1)
 50697:               this.hideTab(tab);
 50697:             else
 50697:               this.showTab(tab);
 50697:           }, this);
 83455: 
120065:           this.tabContainer._handleTabSelect(false);
 50697:         ]]>
 50697:         </body>
 50697:       </method>
 50697: 
 50697:       <method name="showTab">
 50697:         <parameter name="aTab"/>
 50697:         <body>
 50697:         <![CDATA[
 50697:           if (aTab.hidden) {
 55352:             aTab.removeAttribute("hidden");
 97274:             this._visibleTabs = null; // invalidate cache
 97274: 
 58273:             this.tabContainer.adjustTabstrip();
 97274: 
136922:             this.tabContainer._setPositionalAttributes();
136922: 
 50697:             let event = document.createEvent("Events");
 50697:             event.initEvent("TabShow", true, false);
 50697:             aTab.dispatchEvent(event);
 50697:           }
 50697:         ]]>
 50697:         </body>
 50697:       </method>
 50697: 
 50697:       <method name="hideTab">
 50697:         <parameter name="aTab"/>
 50697:         <body>
 50697:         <![CDATA[
 50740:           if (!aTab.hidden && !aTab.pinned && !aTab.selected &&
 70847:               !aTab.closing) {
 55352:             aTab.setAttribute("hidden", "true");
 97274:             this._visibleTabs = null; // invalidate cache
 97274: 
 58273:             this.tabContainer.adjustTabstrip();
 97274: 
136922:             this.tabContainer._setPositionalAttributes();
136922: 
 50697:             let event = document.createEvent("Events");
 50697:             event.initEvent("TabHide", true, false);
 50697:             aTab.dispatchEvent(event);
 50697:           }
 49634:         ]]>
 49634:         </body>
 49634:       </method>
 49634: 
 18574:       <method name="selectTabAtIndex">
 18574:         <parameter name="aIndex"/>
 18574:         <parameter name="aEvent"/>
 18574:         <body>
 18574:         <![CDATA[
 49634:           let tabs = this.visibleTabs;
 49634: 
 18574:           // count backwards for aIndex < 0
 18574:           if (aIndex < 0)
 49634:             aIndex += tabs.length;
 49634: 
 49634:           if (aIndex >= 0 && aIndex < tabs.length)
 49634:             this.selectedTab = tabs[aIndex];
 18574: 
 18574:           if (aEvent) {
 18574:             aEvent.preventDefault();
 18574:             aEvent.stopPropagation();
 18574:           }
 18574:         ]]>
 18574:         </body>
 18574:       </method>
 18574: 
  4891:       <property name="selectedTab">
  4891:         <getter>
127078:           return this.mCurrentTab;
  4891:         </getter>
  4891:         <setter>
  4891:           <![CDATA[
  4989:           // Update the tab
  4989:           this.mTabBox.selectedTab = val;
  4891:           return val;
  4891:           ]]>
  4891:         </setter>
  4891:       </property>
  4891: 
  4891:       <property name="selectedBrowser"
  4891:                 onget="return this.mCurrentBrowser;"
  4891:                 readonly="true"/>
  4891: 
  4972:       <property name="browsers" readonly="true">
  4972:        <getter>
  4972:           <![CDATA[
 18579:             return this._browsers ||
 39702:                    (this._browsers = Array.map(this.tabs, function (tab) tab.linkedBrowser));
  4972:           ]]>
  4972:         </getter>
  4972:       </property>
 97274:       <field name="_browsers">null</field>
  4891: 
 25823:       <!-- Moves a tab to a new browser window, unless it's already the only tab
 25823:            in the current window, in which case this will do nothing. -->
 24093:       <method name="replaceTabWithWindow">
 21712:         <parameter name="aTab"/>
 72978:         <parameter name="aOptions"/>
 21712:         <body>
 21712:           <![CDATA[
 57194:             if (this.tabs.length == 1)
 28384:               return null;
 25823: 
 72978:             var options = "chrome,dialog=no,all";
 72978:             for (var name in aOptions)
 72978:               options += "," + name + "=" + aOptions[name];
 72978: 
 21712:             // tell a new window to take the "dropped" tab
 72978:             return window.openDialog(getBrowserURL(), "_blank", options, aTab);
 21712:           ]]>
 21712:         </body>
 21712:       </method>
 21712: 
  4972:       <method name="moveTabTo">
  4972:         <parameter name="aTab"/>
  4972:         <parameter name="aIndex"/>
  4972:         <body>
  4972:         <![CDATA[
 37917:           var oldPosition = aTab._tPos;
 37917:           if (oldPosition == aIndex)
 37917:             return;
 37917: 
 46158:           // Don't allow mixing pinned and unpinned tabs.
 46158:           if (aTab.pinned)
 46158:             aIndex = Math.min(aIndex, this._numPinnedTabs - 1);
 46158:           else
 46158:             aIndex = Math.max(aIndex, this._numPinnedTabs);
 46158:           if (oldPosition == aIndex)
 46158:             return;
 46158: 
 32240:           this._lastRelatedTab = null;
 46158: 
  4972:           this.mTabFilters.splice(aIndex, 0, this.mTabFilters.splice(aTab._tPos, 1)[0]);
  4972:           this.mTabListeners.splice(aIndex, 0, this.mTabListeners.splice(aTab._tPos, 1)[0]);
  4972: 
126863:           let wasFocused = (document.activeElement == this.mCurrentTab);
126863: 
  4972:           aIndex = aIndex < aTab._tPos ? aIndex: aIndex+1;
  5119:           this.mCurrentTab._selected = false;
 97274: 
 97274:           // invalidate caches
 97274:           this._browsers = null;
 97274:           this._visibleTabs = null;
 97274: 
  5107:           // use .item() instead of [] because dragging to the end of the strip goes out of
  5107:           // bounds: .item() returns null (so it acts like appendChild), but [] throws
 39702:           this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));
  5006: 
 39702:           for (let i = 0; i < this.tabs.length; i++) {
 39702:             this.tabs[i]._tPos = i;
 39702:             this.tabs[i]._selected = false;
  4972:           }
  5119:           this.mCurrentTab._selected = true;
126863: 
126863:           if (wasFocused)
126863:             this.mCurrentTab.focus();
126863: 
120065:           this.tabContainer._handleTabSelect(false);
  5050: 
 46158:           if (aTab.pinned)
 46158:             this.tabContainer._positionPinnedTabs();
 46158: 
136922:           this.tabContainer._setPositionalAttributes();
136922: 
  5050:           var evt = document.createEvent("UIEvents");
  5050:           evt.initUIEvent("TabMove", true, false, window, oldPosition);
  5050:           aTab.dispatchEvent(evt);
  4972:         ]]>
  4972:         </body>
  4972:       </method>
  4972: 
  4972:       <method name="moveTabForward">
  4972:         <body>
  4972:           <![CDATA[
126880:             let nextTab = this.mCurrentTab.nextSibling;
126880:             while (nextTab && nextTab.hidden)
126880:               nextTab = nextTab.nextSibling;
126880: 
126880:             if (nextTab)
126880:               this.moveTabTo(this.mCurrentTab, nextTab._tPos);
  4972:             else if (this.arrowKeysShouldWrap)
  4972:               this.moveTabToStart();
  4972:           ]]>
  4972:         </body>
  4972:       </method>
  4972: 
  4972:       <method name="moveTabBackward">
  4972:         <body>
  4972:           <![CDATA[
126880:             let previousTab = this.mCurrentTab.previousSibling;
126880:             while (previousTab && previousTab.hidden)
126880:               previousTab = previousTab.previousSibling;
126880: 
126880:             if (previousTab)
126880:               this.moveTabTo(this.mCurrentTab, previousTab._tPos);
  4972:             else if (this.arrowKeysShouldWrap)
  4972:               this.moveTabToEnd();
  4972:           ]]>
  4972:         </body>
  4972:       </method>
  4972: 
  4972:       <method name="moveTabToStart">
  4972:         <body>
  4972:           <![CDATA[
  4972:             var tabPos = this.mCurrentTab._tPos;
126863:             if (tabPos > 0)
  4972:               this.moveTabTo(this.mCurrentTab, 0);
  4972:           ]]>
  4972:         </body>
  4972:       </method>
  4972: 
  4972:       <method name="moveTabToEnd">
  4972:         <body>
  4972:           <![CDATA[
  4972:             var tabPos = this.mCurrentTab._tPos;
126863:             if (tabPos < this.browsers.length - 1)
126863:               this.moveTabTo(this.mCurrentTab, this.browsers.length - 1);
  4972:           ]]>
  4972:         </body>
  4972:       </method>
  4972: 
  4972:       <method name="moveTabOver">
  4972:         <parameter name="aEvent"/>
  4972:         <body>
  4972:           <![CDATA[
  4972:             var direction = window.getComputedStyle(this.parentNode, null).direction;
  4972:             if ((direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||
  4972:                 (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))
  4972:               this.moveTabForward();
  4972:             else
  4972:               this.moveTabBackward();
  4972:           ]]>
  4972:         </body>
  4972:       </method>
  4972: 
  8949:       <method name="duplicateTab">
  8949:         <parameter name="aTab"/><!-- can be from a different window as well -->
  8949:         <body>
  8949:           <![CDATA[
 52468:             return Cc["@mozilla.org/browser/sessionstore;1"]
 52468:                      .getService(Ci.nsISessionStore)
 52468:                      .duplicateTab(window, aTab);
  8949:           ]]>
  8949:         </body>
  8949:       </method>
  8949: 
  4891:       <!-- BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
  4891:            MAKE SURE TO ADD IT HERE AS WELL. -->
  4891:       <property name="canGoBack"
  4891:                 onget="return this.mCurrentBrowser.canGoBack;"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="canGoForward"
  4891:                 onget="return this.mCurrentBrowser.canGoForward;"
  4891:                 readonly="true"/>
  4891: 
  4891:       <method name="goBack">
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.goBack();
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="goForward">
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.goForward();
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="reload">
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.reload();
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="reloadWithFlags">
  4891:         <parameter name="aFlags"/>
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.reloadWithFlags(aFlags);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="stop">
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.stop();
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <!-- throws exception for unknown schemes -->
  4891:       <method name="loadURI">
  4891:         <parameter name="aURI"/>
  4891:         <parameter name="aReferrerURI"/>
  4911:         <parameter name="aCharset"/>
  4891:         <body>
  4891:           <![CDATA[
  4911:             return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <!-- throws exception for unknown schemes -->
  4891:       <method name="loadURIWithFlags">
  4891:         <parameter name="aURI"/>
  4891:         <parameter name="aFlags"/>
  4891:         <parameter name="aReferrerURI"/>
  4911:         <parameter name="aCharset"/>
 10400:         <parameter name="aPostData"/>
  4891:         <body>
  4891:           <![CDATA[
 10400:             return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <method name="goHome">
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.goHome();
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4891:       <property name="homePage">
  4891:         <getter>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.homePage;
  4891:           ]]>
  4891:         </getter>
  4891:         <setter>
  4891:           <![CDATA[
  4891:             this.mCurrentBrowser.homePage = val;
  4891:             return val;
  4891:           ]]>
  4891:         </setter>
  4891:       </property>
  4891: 
  4891:       <method name="gotoIndex">
  4891:         <parameter name="aIndex"/>
  4891:         <body>
  4891:           <![CDATA[
  4891:             return this.mCurrentBrowser.gotoIndex(aIndex);
  4891:           ]]>
  4891:         </body>
  4891:       </method>
  4891: 
  4908:       <method name="attachFormFill">
  4908:         <body><![CDATA[
  4943:           for (var i = 0; i < this.mPanelContainer.childNodes.length; ++i) {
  4943:             var cb = this.getBrowserAtIndex(i);
  4917:             cb.attachFormFill();
  4917:           }
  4908:         ]]></body>
  4908:       </method>
  4908: 
  4908:       <method name="detachFormFill">
  4908:         <body><![CDATA[
  4943:           for (var i = 0; i < this.mPanelContainer.childNodes.length; ++i) {
  4943:             var cb = this.getBrowserAtIndex(i);
  4917:             cb.detachFormFill();
  4917:           }
  4908:         ]]></body>
  4908:       </method>
  4908: 
  4902:       <property name="pageReport"
  4902:                 onget="return this.mCurrentBrowser.pageReport;"
  4902:                 readonly="true"/>
  4902: 
  4891:       <property name="currentURI"
  4891:                 onget="return this.mCurrentBrowser.currentURI;"
  4891:                 readonly="true"/>
  4891: 
  4943:       <field name="_fastFind">null</field>
  4943:       <property name="fastFind"
  4943:                 readonly="true">
  4943:         <getter>
  4943:         <![CDATA[
  4943:           if (!this._fastFind) {
  4943:             this._fastFind = Components.classes["@mozilla.org/typeaheadfind;1"]
  4943:                                        .createInstance(Components.interfaces.nsITypeAheadFind);
  4943:             this._fastFind.init(this.docShell);
  4943:           }
  4943:           return this._fastFind;
  4943:         ]]>
  4943:         </getter>
  4943:       </property>
  4943: 
  4891:       <property name="docShell"
  4891:                 onget="return this.mCurrentBrowser.docShell"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="webNavigation"
  4891:                 onget="return this.mCurrentBrowser.webNavigation"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="webBrowserFind"
  4891:                 readonly="true"
  4891:                 onget="return this.mCurrentBrowser.webBrowserFind"/>
  4891: 
  4891:       <property name="webProgress"
  4891:                 readonly="true"
  4891:                 onget="return this.mCurrentBrowser.webProgress"/>
  4891: 
  4891:       <property name="contentWindow"
  4891:                 readonly="true"
  4891:                 onget="return this.mCurrentBrowser.contentWindow"/>
  4891: 
  4891:       <property name="sessionHistory"
  4891:                 onget="return this.mCurrentBrowser.sessionHistory;"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="markupDocumentViewer"
  4891:                 onget="return this.mCurrentBrowser.markupDocumentViewer;"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="contentViewerEdit"
  4891:                 onget="return this.mCurrentBrowser.contentViewerEdit;"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="contentViewerFile"
  4891:                 onget="return this.mCurrentBrowser.contentViewerFile;"
  4891:                 readonly="true"/>
  4891: 
  4891:       <property name="contentDocument"
  4891:                 onget="return this.mCurrentBrowser.contentDocument;"
  4891:                 readonly="true"/>
  4891: 
  4937:       <property name="contentTitle"
  4937:                 onget="return this.mCurrentBrowser.contentTitle;"
  4937:                 readonly="true"/>
  4937: 
  5118:       <property name="contentPrincipal"
  5118:                 onget="return this.mCurrentBrowser.contentPrincipal;"
  5118:                 readonly="true"/>
  5118: 
  4891:       <property name="securityUI"
  4891:                 onget="return this.mCurrentBrowser.securityUI;"
  4891:                 readonly="true"/>
  4891: 
 38729:       <method name="_handleKeyEvent">
 38729:         <parameter name="aEvent"/>
 38729:         <body><![CDATA[
  4943:           if (!aEvent.isTrusted) {
  4943:             // Don't let untrusted events mess with tabs.
  4943:             return;
  4943:           }
  4943: 
 42273:           if (aEvent.altKey)
  4979:             return;
 42273: 
127742:           if (aEvent.ctrlKey && aEvent.shiftKey && !aEvent.metaKey) {
127742:             switch (aEvent.keyCode) {
127742:               case aEvent.DOM_VK_PAGE_UP:
127742:                 this.moveTabBackward();
127742:                 aEvent.stopPropagation();
127742:                 aEvent.preventDefault();
127742:                 return;
127742:               case aEvent.DOM_VK_PAGE_DOWN:
127742:                 this.moveTabForward();
127742:                 aEvent.stopPropagation();
127742:                 aEvent.preventDefault();
127742:                 return;
127742:             }
127742:           }
127742: 
 42930:           // We need to take care of FAYT-watching as long as the findbar
 42930:           // isn't initialized.  The checks on aEvent are copied from
 42930:           // _shouldFastFind (see findbar.xml).
 42930:           if (!gFindBarInitialized &&
 42930:               !(aEvent.ctrlKey || aEvent.metaKey) &&
 84229:               !aEvent.defaultPrevented) {
 42930:             let charCode = aEvent.charCode;
 42930:             if (charCode) {
 42930:               let char = String.fromCharCode(charCode);
 42930:               if (char == "'" || char == "/" ||
 42930:                   Services.prefs.getBoolPref("accessibility.typeaheadfind")) {
 42930:                 gFindBar._onBrowserKeypress(aEvent);
 42930:                 return;
 42930:               }
 42930:             }
 42930:           }
 42930: 
  4972: #ifdef XP_MACOSX
 42273:           if (!aEvent.metaKey)
 42273:             return;
 42273: 
 13695:           var offset = 1;
 13695:           switch (aEvent.charCode) {
 13695:             case '}'.charCodeAt(0):
 42273:               offset = -1;
 13695:             case '{'.charCodeAt(0):
 38729:               if (window.getComputedStyle(this, null).direction == "ltr")
 13695:                 offset *= -1;
 39702:               this.tabContainer.advanceSelectedTab(offset, true);
 13695:               aEvent.stopPropagation();
 13695:               aEvent.preventDefault();
 13695:           }
  4972: #else
 42273:           if (aEvent.ctrlKey && !aEvent.shiftKey && !aEvent.metaKey &&
 42273:               aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
 81349:               !this.mCurrentTab.pinned) {
 49132:             this.removeCurrentTab({animate: true});
  4979:             aEvent.stopPropagation();
  4979:             aEvent.preventDefault();
  4972:           }
 42273: #endif
 38729:         ]]></body>
 38729:       </method>
  4923: 
  4933:       <property name="userTypedClear"
  4933:                 onget="return this.mCurrentBrowser.userTypedClear;"
  4933:                 onset="return this.mCurrentBrowser.userTypedClear = val;"/>
  4933: 
  4924:       <property name="userTypedValue"
  4924:                 onget="return this.mCurrentBrowser.userTypedValue;"
  4924:                 onset="return this.mCurrentBrowser.userTypedValue = val;"/>
  4924: 
  5018:       <method name="createTooltip">
  5018:         <parameter name="event"/>
 39508:         <body><![CDATA[
  5031:           event.stopPropagation();
 39508:           var tab = document.tooltipNode;
 80894:           if (tab.localName != "tab") {
 39508:             event.preventDefault();
 39508:             return;
  5018:           }
 39508:           event.target.setAttribute("label", tab.mOverCloseButton ?
 39508:                                              tab.getAttribute("closetabtext") :
 39508:                                              tab.getAttribute("label"));
 39508:         ]]></body>
  5018:       </method>
  5018: 
 38729:       <method name="handleEvent">
 38729:         <parameter name="aEvent"/>
 38729:         <body><![CDATA[
 38729:           switch (aEvent.type) {
 38729:             case "keypress":
 38729:               this._handleKeyEvent(aEvent);
 38729:               break;
 73680:             case "sizemodechange":
 73680:               if (aEvent.target == window) {
 73680:                 this.mCurrentBrowser.docShellIsActive =
 73680:                   (window.windowState != window.STATE_MINIMIZED);
 73680:               }
 73680:               break;
 38729:           }
 38729:         ]]></body>
 38729:       </method>
 38729: 
  4891:       <constructor>
  4891:         <![CDATA[
111101:           this.mCurrentBrowser = document.getAnonymousElementByAttribute(this, "anonid", "initialBrowser");
 39702:           this.mCurrentTab = this.tabContainer.firstChild;
 38729:           document.addEventListener("keypress", this, false);
 73680:           window.addEventListener("sizemodechange", this, false);
  4972: 
 67998:           var uniqueId = "panel" + Date.now();
  4972:           this.mPanelContainer.childNodes[0].id = uniqueId;
 39508:           this.mCurrentTab.linkedPanel = uniqueId;
 39508:           this.mCurrentTab._tPos = 0;
 67993:           this.mCurrentTab._fullyOpen = true;
 39508:           this.mCurrentTab.linkedBrowser = this.mCurrentBrowser;
  5134: 
  5134:           // set up the shared autoscroll popup
  5134:           this._autoScrollPopup = this.mCurrentBrowser._createAutoScrollPopup();
 25842:           this._autoScrollPopup.id = "autoscroller";
  5134:           this.appendChild(this._autoScrollPopup);
  5134:           this.mCurrentBrowser.setAttribute("autoscrollpopup", this._autoScrollPopup.id);
 40970:           this.mCurrentBrowser.droppedLinkHandler = handleDroppedLink;
 60693:           this.updateWindowResizers();
 63659: 
 63659:           // Hook up the event listeners to the first browser
 63659:           var tabListener = this.mTabProgressListener(this.mCurrentTab, this.mCurrentBrowser, true);
 63659:           const nsIWebProgress = Components.interfaces.nsIWebProgress;
 63659:           const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
 63659:                                    .createInstance(nsIWebProgress);
 63659:           filter.addProgressListener(tabListener, nsIWebProgress.NOTIFY_ALL);
 63659:           this.mTabListeners[0] = tabListener;
 63659:           this.mTabFilters[0] = filter;
 63659:           this.init();
 69295: 
 69295:           this.style.backgroundColor =
 69295:             Services.prefs.getBoolPref("browser.display.use_system_colors") ?
 69295:               "-moz-default-background-color" :
 69295:               Services.prefs.getCharPref("browser.display.background_color");
  4891:         ]]>
  4891:       </constructor>
  4891: 
 63659:       <method name="init">
 63659:         <body><![CDATA[
 63659:           if (!this._initialProgressListenerAdded) {
 63659:             this._initialProgressListenerAdded = true;
 63659:             try {
 63659:               this.webProgress.addProgressListener(this.mTabFilters[0], Components.interfaces.nsIWebProgress.NOTIFY_ALL);
 63659:             } catch (e) {
 63659:               // The binding was constructed too early, need to try this again later. See bug 463384.
 63659:               this._initialProgressListenerAdded = false;
 63659:             }
 63659:           }
 63659:         ]]></body>
 63659:       </method>
 63659: 
  4891:       <destructor>
  4891:         <![CDATA[
  4891:           for (var i = 0; i < this.mTabListeners.length; ++i) {
 39889:             let browser = this.getBrowserAtIndex(i);
 50528:             if (browser.registeredOpenURI) {
 59359:               this._placesAutocomplete.unregisterOpenPage(browser.registeredOpenURI);
 50528:               delete browser.registeredOpenURI;
 50528:             }
 39889:             browser.webProgress.removeProgressListener(this.mTabFilters[i]);
  4891:             this.mTabFilters[i].removeProgressListener(this.mTabListeners[i]);
  4891:             this.mTabFilters[i] = null;
 33328:             this.mTabListeners[i].destroy();
  4891:             this.mTabListeners[i] = null;
  4891:           }
 38729:           document.removeEventListener("keypress", this, false);
 73680:           window.removeEventListener("sizemodechange", this, false);
  4891:         ]]>
  4891:       </destructor>
 39508: 
 39508:       <!-- Deprecated stuff, implemented for backwards compatibility. -->
 63659:       <method name="enterTabbedMode">
 63659:         <body>
 63659:           Application.console.log("enterTabbedMode is an obsolete method and " +
 63659:                                   "will be removed in a future release.");
 63659:         </body>
 63659:       </method>
 63659:       <field name="mTabbedMode" readonly="true">true</field>
 39508:       <method name="setStripVisibilityTo">
 39508:         <parameter name="aShow"/>
 39508:         <body>
 39508:           this.tabContainer.visible = aShow;
 39508:         </body>
 39508:       </method>
 39508:       <method name="getStripVisibility">
 39508:         <body>
 39508:           return this.tabContainer.visible;
 39508:         </body>
 39508:       </method>
 39508:       <property name="mContextTab" readonly="true"
 40059:                 onget="return TabContextMenu.contextTab;"/>
 39682:       <property name="mPrefs" readonly="true"
 39682:                 onget="return Services.prefs;"/>
 39702:       <property name="mTabContainer" readonly="true"
 39702:                 onget="return this.tabContainer;"/>
 39702:       <property name="mTabs" readonly="true"
 39702:                 onget="return this.tabs;"/>
 39825:       <!--
 39825:         - Compatibility hack: several extensions depend on this property to
 39825:         - access the tab context menu or tab container, so keep that working for
 39825:         - now. Ideally we can remove this once extensions are using
 39825:         - tabbrowser.tabContextMenu and tabbrowser.tabContainer directly.
 39825:         -->
 39825:       <property name="mStrip" readonly="true">
 39825:         <getter>
 39825:         <![CDATA[
 39825:           return ({
 39825:             self: this,
 39825:             childNodes: [null, this.tabContextMenu, this.tabContainer],
 39825:             firstChild: { nextSibling: this.tabContextMenu },
 39825:             getElementsByAttribute: function (attr, attrValue) {
 39825:               if (attr == "anonid" && attrValue == "tabContextMenu")
 39825:                 return [this.self.tabContextMenu];
 39825:               return [];
 39825:             },
 39825:             // Also support adding event listeners (forward to the tab container)
 39825:             addEventListener: function (a,b,c) { this.self.tabContainer.addEventListener(a,b,c); },
 39825:             removeEventListener: function (a,b,c) { this.self.tabContainer.removeEventListener(a,b,c); }
 39825:           });
 39825:         ]]>
 39825:         </getter>
 39825:       </property>
  4891:     </implementation>
  4891: 
  4891:     <handlers>
  5040:       <handler event="DOMWindowClose" phase="capturing">
  4891:         <![CDATA[
  4941:           if (!event.isTrusted)
  4941:             return;
  4941: 
 39702:           if (this.tabs.length == 1)
 39684:             return;
 39684: 
 38729:           var tab = this._getTabForContentWindow(event.target);
 38729:           if (tab) {
 38729:             this.removeTab(tab);
  4943:             event.preventDefault();
  4943:           }
  4891:         ]]>
  4891:       </handler>
  5040:       <handler event="DOMWillOpenModalDialog" phase="capturing">
  4942:         <![CDATA[
  4942:           if (!event.isTrusted)
  4942:             return;
  4942: 
  4942:           // We're about to open a modal dialog, make sure the opening
  4942:           // tab is brought to the front.
 38729:           this.selectedTab = this._getTabForContentWindow(event.target.top);
 38729:         ]]>
 38729:       </handler>
 38729:       <handler event="DOMTitleChanged">
 38729:         <![CDATA[
 38729:           if (!event.isTrusted)
 38729:             return;
 38729: 
 38729:           var contentWin = event.target.defaultView;
 38729:           if (contentWin != contentWin.top)
 38729:             return;
 38729: 
 38729:           var tab = this._getTabForContentWindow(contentWin);
 52014:           var titleChanged = this.setTabTitle(tab);
 52370:           if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
 51923:             tab.setAttribute("titlechanged", "true");
  4942:         ]]>
  4942:       </handler>
  4891:     </handlers>
  4891:   </binding>
  4891: 
 39508:   <binding id="tabbrowser-tabbox"
 39508:            extends="chrome://global/content/bindings/tabbox.xml#tabbox">
 39508:     <implementation>
 39508:       <property name="tabs" readonly="true"
 39508:                 onget="return document.getBindingParent(this).tabContainer;"/>
 39508:     </implementation>
 39508:   </binding>
 39508: 
  5100:   <binding id="tabbrowser-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
 24186:     <implementation>
 24186:       <!-- Override scrollbox.xml method, since our scrollbox's children are
 24186:            inherited from the binding parent -->
 24186:       <method name="_getScrollableElements">
 24186:         <body><![CDATA[
 48122:           return Array.filter(document.getBindingParent(this).childNodes,
 48122:                               this._canScrollToElement, this);
 24186:         ]]></body>
 24186:       </method>
 46158:       <method name="_canScrollToElement">
 46158:         <parameter name="tab"/>
 49634:         <body><![CDATA[
 49634:           return !tab.pinned && !tab.hidden;
 49634:         ]]></body>
 46158:       </method>
 24186:     </implementation>
 24186: 
 24945:     <handlers>
 67993:       <handler event="underflow" phase="capturing"><![CDATA[
 80894:         if (event.detail == 0)
 24945:           return; // Ignore vertical events
 24945: 
 24945:         var tabs = document.getBindingParent(this);
136377:         tabs.removeAttribute("overflow");
136377: 
136377:         if (tabs._lastTabClosedByMouse)
136377:           tabs._expandSpacerBy(this._scrollButtonDown.clientWidth);
130978: 
 49631:         tabs.tabbrowser._removingTabs.forEach(tabs.tabbrowser.removeTab,
 49132:                                               tabs.tabbrowser);
 49132: 
 46158:         tabs._positionPinnedTabs();
 24945:       ]]></handler>
 24945:       <handler event="overflow"><![CDATA[
 80894:         if (event.detail == 0)
 24945:           return; // Ignore vertical events
 24945: 
 24945:         var tabs = document.getBindingParent(this);
 24945:         tabs.setAttribute("overflow", "true");
 46158:         tabs._positionPinnedTabs();
120065:         tabs._handleTabSelect(false);
 24945:       ]]></handler>
 24945:     </handlers>
  5100:   </binding>
  5100: 
  5018:   <binding id="tabbrowser-tabs"
  5018:            extends="chrome://global/content/bindings/tabbox.xml#tabs">
 39508:     <resources>
 39508:       <stylesheet src="chrome://browser/content/tabbrowser.css"/>
 39508:     </resources>
 39508: 
 40059:     <content>
 61980:       <xul:hbox align="end">
 39508:         <xul:image class="tab-drop-indicator" anonid="tab-drop-indicator" collapsed="true"/>
 39508:       </xul:hbox>
  5886:       <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
 30836:                           style="min-width: 1px;"
  8254: #ifndef XP_MACOSX
  8254:                           clicktoscroll="true"
  8254: #endif
  5886:                           class="tabbrowser-arrowscrollbox">
 24146: # This is a hack to circumvent bug 472020, otherwise the tabs show up on the
 24146: # right of the newtab button.
 24108:         <children includes="tab"/>
 24146: # This is to ensure anything extensions put here will go before the newtab
 24146: # button, necessary due to the previous hack.
  5886:         <children/>
 24108:         <xul:toolbarbutton class="tabs-newtab-button"
 30836:                            command="cmd_newNavigatorTab"
 42820:                            onclick="checkForMiddleClick(this, event);"
136922:                            onmouseenter="document.getBindingParent(this)._enterNewTab();"
136922:                            onmouseleave="document.getBindingParent(this)._leaveNewTab();"
 24108:                            tooltiptext="&newTabButton.tooltip;"/>
136377:         <xul:spacer class="closing-tabs-spacer" anonid="closing-tabs-spacer"
136377:                     style="width: 0;"/>
  5050:       </xul:arrowscrollbox>
  5018:     </content>
 39508: 
 34585:     <implementation implements="nsIDOMEventListener">
  5018:       <constructor>
  5053:         <![CDATA[
 39682:           this.mTabClipWidth = Services.prefs.getIntPref("browser.tabs.tabClipWidth");
 39682:           this.mCloseButtons = Services.prefs.getIntPref("browser.tabs.closeButtons");
 39706:           this._closeWindowWithLastTab = Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab");
  5018: 
 39508:           var tab = this.firstChild;
114104:           tab.setAttribute("label",
114104:                            this.tabbrowser.mStringBundle.getString("tabs.emptyTabTitle"));
 39508:           tab.setAttribute("crop", "end");
 39508:           tab.setAttribute("onerror", "this.removeAttribute('image');");
  5082:           this.adjustTabstrip();
  5050: 
 47378:           Services.prefs.addObserver("browser.tabs.", this._prefObserver, false);
  5137:           window.addEventListener("resize", this, false);
 91977:           window.addEventListener("load", this, false);
127403: 
127403:           try {
127403:             this._tabAnimationLoggingEnabled = Services.prefs.getBoolPref("browser.tabs.animationLogging.enabled");
127403:           } catch (ex) {
127403:             this._tabAnimationLoggingEnabled = false;
127403:           }
132021:           this._browserNewtabpageEnabled = Services.prefs.getBoolPref("browser.newtabpage.enabled");
  5053:         ]]>
  5018:       </constructor>
  5018: 
  5060:       <destructor>
  5060:         <![CDATA[
 47378:           Services.prefs.removeObserver("browser.tabs.", this._prefObserver);
  5060:         ]]>
  5060:       </destructor>
  5060: 
 39508:       <field name="tabbrowser" readonly="true">
 39508:         document.getElementById(this.getAttribute("tabbrowser"));
 39508:       </field>
 39508: 
 39508:       <field name="tabbox" readonly="true">
 39508:         this.tabbrowser.mTabBox;
 39508:       </field>
 39508: 
 39825:       <field name="contextMenu" readonly="true">
 47855:         document.getElementById("tabContextMenu");
 39825:       </field>
 39825: 
  5054:       <field name="mTabstripWidth">0</field>
  5054: 
  5050:       <field name="mTabstrip">
  5050:         document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
  5050:       </field>
  5050: 
136922:       <field name="_firstTab">null</field>
136922:       <field name="_lastTab">null</field>
136922:       <field name="_afterSelectedTab">null</field>
136922:       <field name="_beforeHoveredTab">null</field>
136922:       <field name="_afterHoveredTab">null</field>
136922: 
136922:       <method name="_setPositionalAttributes">
136922:         <body><![CDATA[
136922:           let visibleTabs = this.tabbrowser.visibleTabs;
136922: 
136922:           if (!visibleTabs.length)
136922:             return;
136922: 
136922:           let selectedIndex = visibleTabs.indexOf(this.selectedItem);
136922: 
136922:           let lastVisible = visibleTabs.length - 1;
136922: 
136922:           // selectedItem will not be in visibleTabs briefly when
136922:           // browser.tabs.closeWindowWithLastTab is disabled and the user closes
136922:           // the last tab
136922:           if (!this.selectedItem.closing && selectedIndex != 0) {
136922:             let beforeSelectedTab = visibleTabs[selectedIndex - 1];
136922:             beforeSelectedTab.removeAttribute("beforehovered");
136922:           }
136922: 
136922:           if (this._afterSelectedTab)
136922:             this._afterSelectedTab.removeAttribute("afterselected-visible");
136922:           if (this.selectedItem.closing || selectedIndex == lastVisible) {
136922:             this._afterSelectedTab = null;
136922:           } else {
136922:             this._afterSelectedTab = visibleTabs[selectedIndex + 1];
136922:             this._afterSelectedTab.setAttribute("afterselected-visible",
136922:                                                 "true");
136922:             this._afterSelectedTab.removeAttribute("afterhovered");
136922:           }
136922: 
136922:           if (this._firstTab)
136922:             this._firstTab.removeAttribute("first-visible-tab");
136922:           this._firstTab = visibleTabs[0];
136922:           this._firstTab.setAttribute("first-visible-tab", "true");
136922:           if (this._lastTab)
136922:             this._lastTab.removeAttribute("last-visible-tab");
136922:           this._lastTab = visibleTabs[lastVisible];
136922:           this._lastTab.setAttribute("last-visible-tab", "true");
136922:         ]]></body>
136922:       </method>
136922: 
 39508:       <field name="_prefObserver"><![CDATA[({
 39508:         tabContainer: this,
 39508: 
 39508:         observe: function (subject, topic, data) {
  5050:           switch (data) {
  5050:             case "browser.tabs.closeButtons":
 39682:               this.tabContainer.mCloseButtons = Services.prefs.getIntPref(data);
 39508:               this.tabContainer.adjustTabstrip();
 39508:               break;
 39508:             case "browser.tabs.autoHide":
 39508:               this.tabContainer.updateVisibility();
  5050:               break;
 39706:             case "browser.tabs.closeWindowWithLastTab":
 39706:               this.tabContainer._closeWindowWithLastTab = Services.prefs.getBoolPref(data);
 39706:               this.tabContainer.adjustTabstrip();
 39706:               break;
  5050:           }
  5050:         }
 39508:       });]]></field>
 39508:       <field name="_blockDblClick">false</field>
 39508: 
 39508:       <field name="_tabDropIndicator">
 39508:         document.getAnonymousElementByAttribute(this, "anonid", "tab-drop-indicator");
 39508:       </field>
 39508: 
 39508:       <field name="_dragOverDelay">350</field>
 39508:       <field name="_dragTime">0</field>
 39508: 
 39508:       <field name="_container" readonly="true"><![CDATA[
 39508:         this.parentNode && this.parentNode.localName == "toolbar" ? this.parentNode : this;
 39508:       ]]></field>
 39508: 
 91977:       <field name="_propagatedVisibilityOnce">false</field>
 91977: 
 39508:       <property name="visible"
 39508:                 onget="return !this._container.collapsed;">
 39508:         <setter><![CDATA[
 91977:           if (val == this.visible &&
 91977:               this._propagatedVisibilityOnce)
 60222:             return val;
 60222: 
 39508:           this._container.collapsed = !val;
 39508: 
 86817:           this._propagateVisibility();
 91977:           this._propagatedVisibilityOnce = true;
 60222: 
 39508:           return val;
 39508:         ]]></setter>
 39508:       </property>
 39508: 
136922:       <method name="_enterNewTab">
136922:         <body><![CDATA[
136922:           let visibleTabs = this.tabbrowser.visibleTabs;
136922:           let candidate = visibleTabs[visibleTabs.length - 1];
136922:           if (!candidate.selected) {
136922:             this._beforeHoveredTab = candidate;
136922:             candidate.setAttribute("beforehovered", "true");
136922:           }
136922:         ]]></body>
136922:       </method>
136922: 
136922:       <method name="_leaveNewTab">
136922:         <body><![CDATA[
136922:           if (this._beforeHoveredTab) {
136922:             this._beforeHoveredTab.removeAttribute("beforehovered");
136922:             this._beforeHoveredTab = null;
136922:           }
136922:         ]]></body>
136922:       </method>
136922: 
 86817:       <method name="_propagateVisibility">
 86817:         <body><![CDATA[
 86817:           let visible = this.visible;
 86817: 
 86817:           document.getElementById("menu_closeWindow").hidden = !visible;
 86817:           document.getElementById("menu_close").setAttribute("label",
 86817:             this.tabbrowser.mStringBundle.getString(visible ? "tabs.closeTab" : "tabs.close"));
 86817: 
 86817:           goSetCommandEnabled("cmd_ToggleTabsOnTop", visible);
 86817: 
 86817:           TabsOnTop.syncUI();
 86817: 
 86817:           TabsInTitlebar.allowedBy("tabs-visible", visible);
 86817:         ]]></body>
 86817:       </method>
 86817: 
 39508:       <method name="updateVisibility">
 39508:         <body><![CDATA[
 64495:           if (this.childNodes.length - this.tabbrowser._removingTabs.length == 1)
 64495:             this.visible = window.toolbar.visible &&
 64495:                            !Services.prefs.getBoolPref("browser.tabs.autoHide");
 39508:           else
 39508:             this.visible = true;
 39508:         ]]></body>
 39508:       </method>
  5050: 
  5050:       <method name="adjustTabstrip">
  5018:         <body><![CDATA[
  5050:           // modes for tabstrip
 60227:           // 0 - button on active tab only
 60227:           // 1 - close buttons on all tabs
 60227:           // 2 - no close buttons at all
 60227:           // 3 - close button at the end of the tabstrip
  5050:           switch (this.mCloseButtons) {
  5050:           case 0:
 39706:             if (this.childNodes.length == 1 && this._closeWindowWithLastTab)
 60227:               this.setAttribute("closebuttons", "hidden");
 39706:             else
  5050:               this.setAttribute("closebuttons", "activetab");
  5050:             break;
  5050:           case 1:
 51505:             if (this.childNodes.length == 1) {
 51505:               if (this._closeWindowWithLastTab)
 60227:                 this.setAttribute("closebuttons", "hidden");
 51505:               else
 51505:                 this.setAttribute("closebuttons", "alltabs");
 51505:             } else {
 50686:               let tab = this.tabbrowser.visibleTabs[this.tabbrowser._numPinnedTabs];
 46158:               if (tab && tab.getBoundingClientRect().width > this.mTabClipWidth)
  5050:                 this.setAttribute("closebuttons", "alltabs");
  5018:               else
  5050:                 this.setAttribute("closebuttons", "activetab");
 46158:             }
  5050:             break;
  5050:           case 2:
  5050:           case 3:
 60227:             this.setAttribute("closebuttons", "never");
  5050:             break;
  5050:           }
 41426:           var tabstripClosebutton = document.getElementById("tabs-closebutton");
 41426:           if (tabstripClosebutton && tabstripClosebutton.parentNode == this._container)
 41426:             tabstripClosebutton.collapsed = this.mCloseButtons != 3;
  5050:         ]]></body>
  5050:       </method>
  5050: 
  5050:       <method name="_handleTabSelect">
120065:         <parameter name="aSmoothScroll"/>
  5050:         <body><![CDATA[
120065:           if (this.getAttribute("overflow") == "true")
120065:             this.mTabstrip.ensureElementIsVisible(this.selectedItem, aSmoothScroll);
  5050:         ]]></body>
  5050:       </method>
  5050: 
 23742:       <method name="_fillTrailingGap">
 23742:         <body><![CDATA[
 23742:           try {
 23742:             // if we're at the right side (and not the logical end,
 23742:             // which is why this works for both LTR and RTL)
 23742:             // of the tabstrip, we need to ensure that we stay
 23742:             // completely scrolled to the right side
 23742:             var tabStrip = this.mTabstrip;
 42857:             if (tabStrip.scrollPosition + tabStrip.scrollClientSize >
 30175:                 tabStrip.scrollSize)
 23742:               tabStrip.scrollByPixels(-1);
 23742:           } catch (e) {}
 23742:         ]]></body>
 23742:       </method>
 23742: 
 67993:       <field name="_closingTabsSpacer">
 67993:         document.getAnonymousElementByAttribute(this, "anonid", "closing-tabs-spacer");
 67993:       </field>
 67993: 
136377:       <field name="_tabDefaultMaxWidth">NaN</field>
136377:       <field name="_lastTabClosedByMouse">false</field>
136377:       <field name="_hasTabTempMaxWidth">false</field>
 67993: 
 67993:       <!-- Try to keep the active tab's close button under the mouse cursor -->
 67993:       <method name="_lockTabSizing">
 67993:         <parameter name="aTab"/>
 67993:         <body><![CDATA[
 67993:           var tabs = this.tabbrowser.visibleTabs;
 67993:           if (!tabs.length)
 67993:             return;
 67993: 
136377:           var isEndTab = (aTab._tPos > tabs[tabs.length-1]._tPos);
136377:           var tabWidth = aTab.getBoundingClientRect().width;
136377: 
136377:           if (!this._tabDefaultMaxWidth)
136377:             this._tabDefaultMaxWidth =
136377:               parseFloat(window.getComputedStyle(aTab).maxWidth);
136377:           this._lastTabClosedByMouse = true;
136377: 
136377:           if (this.getAttribute("overflow") == "true") {
136377:             // Don't need to do anything if we're in overflow mode and aren't scrolled
136377:             // all the way to the right, or if we're closing the last tab.
136377:             if (isEndTab || !this.mTabstrip._scrollButtonDown.disabled)
136377:               return;
136377: 
136377:             // If the tab has an owner that will become the active tab, the owner will
136377:             // be to the left of it, so we actually want the left tab to slide over.
136377:             // This can't be done as easily in non-overflow mode, so we don't bother.
136377:             if (aTab.owner)
136377:               return;
136377: 
136377:             this._expandSpacerBy(tabWidth);
136377:           } else { // non-overflow mode
136377:             // Locking is neither in effect nor needed, so let tabs expand normally.
136377:             if (isEndTab && !this._hasTabTempMaxWidth)
136377:               return;
136377: 
136377:             let numPinned = this.tabbrowser._numPinnedTabs;
136377:             // Force tabs to stay the same width, unless we're closing the last tab,
136377:             // which case we need to let them expand just enough so that the overall
136377:             // tabbar width is the same.
136377:             if (isEndTab) {
136377:               let numNormalTabs = tabs.length - numPinned;
136377:               tabWidth = tabWidth * (numNormalTabs + 1) / numNormalTabs;
136377:               if (tabWidth > this._tabDefaultMaxWidth)
136377:                 tabWidth = this._tabDefaultMaxWidth;
136377:             }
136377:             tabWidth += "px";
136377:             for (let i = numPinned; i < tabs.length; i++) {
136377:               let tab = tabs[i];
136377:               tab.style.setProperty("max-width", tabWidth, "important");
136377:               if (!isEndTab) { // keep tabs the same width
136377:                 tab.style.transition = "none";
136377:                 tab.clientTop; // flush styles to skip animation; see bug 649247
136377:                 tab.style.transition = "";
136377:               }
136377:             }
136377:             this._hasTabTempMaxWidth = true;
135778:             this.tabbrowser.addEventListener("mousemove", this, false);
135778:             window.addEventListener("mouseout", this, false);
136377:           }
136377:         ]]></body>
136377:       </method>
136377: 
136377:       <method name="_expandSpacerBy">
136377:         <parameter name="pixels"/>
136377:         <body><![CDATA[
130977:           let spacer = this._closingTabsSpacer;
136377:           spacer.style.width = parseFloat(spacer.style.width) + pixels + "px";
136377:           this.setAttribute("using-closing-tabs-spacer", "true");
136377:           this.tabbrowser.addEventListener("mousemove", this, false);
136377:           window.addEventListener("mouseout", this, false);
 67993:         ]]></body>
 67993:       </method>
 67993: 
 67993:       <method name="_unlockTabSizing">
 67993:         <body><![CDATA[
 80894:           this.tabbrowser.removeEventListener("mousemove", this, false);
 80894:           window.removeEventListener("mouseout", this, false);
 86616: 
136377:           if (this._hasTabTempMaxWidth) {
136377:             this._hasTabTempMaxWidth = false;
136377:             let tabs = this.tabbrowser.visibleTabs;
136377:             for (let i = 0; i < tabs.length; i++)
136377:               tabs[i].style.maxWidth = "";
136377:           }
136377: 
136377:           if (this.hasAttribute("using-closing-tabs-spacer")) {
136377:             this.removeAttribute("using-closing-tabs-spacer");
136377:             this._closingTabsSpacer.style.width = 0;
 67993:           }
 67993:         ]]></body>
 67993:       </method>
 67993: 
120065:       <field name="_lastNumPinned">0</field>
 46158:       <method name="_positionPinnedTabs">
 46158:         <body><![CDATA[
 60221:           var numPinned = this.tabbrowser._numPinnedTabs;
 60688:           var doPosition = this.getAttribute("overflow") == "true" &&
 70835:                            numPinned > 0;
 60688: 
 60688:           if (doPosition) {
 60688:             this.setAttribute("positionpinnedtabs", "true");
 60688: 
102549:             let scrollButtonWidth = this.mTabstrip._scrollButtonDown.getBoundingClientRect().width;
 60688:             let paddingStart = this.mTabstrip.scrollboxPaddingStart;
 60688:             let width = 0;
 60688: 
 60688:             for (let i = numPinned - 1; i >= 0; i--) {
 46158:               let tab = this.childNodes[i];
102549:               width += tab.getBoundingClientRect().width;
 58136:               tab.style.MozMarginStart = - (width + scrollButtonWidth + paddingStart) + "px";
 46158:             }
 60688: 
110736:             this.style.MozPaddingStart = width + paddingStart + "px";
 60688: 
 60688:           } else {
 60688:             this.removeAttribute("positionpinnedtabs");
 60688: 
 60688:             for (let i = 0; i < numPinned; i++) {
 60688:               let tab = this.childNodes[i];
 60688:               tab.style.MozMarginStart = "";
 60688:             }
 60688: 
110736:             this.style.MozPaddingStart = "";
 60688:           }
 60688: 
120065:           if (this._lastNumPinned != numPinned) {
120065:             this._lastNumPinned = numPinned;
120065:             this._handleTabSelect(false);
120065:           }
 46158:         ]]></body>
 46158:       </method>
 46158: 
109537:       <method name="_animateTabMove">
109537:         <parameter name="event"/>
109537:         <body><![CDATA[
109537:           let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
109537: 
109537:           if (this.getAttribute("movingtab") != "true") {
109537:             this.setAttribute("movingtab", "true");
109537:             this.selectedItem = draggedTab;
109537:           }
109537: 
109537:           if (!("animLastScreenX" in draggedTab._dragData))
109537:             draggedTab._dragData.animLastScreenX = draggedTab._dragData.screenX;
109537: 
109537:           let screenX = event.screenX;
109537:           if (screenX == draggedTab._dragData.animLastScreenX)
109537:             return;
109537: 
109537:           let draggingRight = screenX > draggedTab._dragData.animLastScreenX;
109537:           draggedTab._dragData.animLastScreenX = screenX;
109537: 
109537:           let rtl = (window.getComputedStyle(this).direction == "rtl");
109537:           let pinned = draggedTab.pinned;
109537:           let numPinned = this.tabbrowser._numPinnedTabs;
109537:           let tabs = this.tabbrowser.visibleTabs
109537:                                     .slice(pinned ? 0 : numPinned,
109537:                                            pinned ? numPinned : undefined);
109537:           if (rtl)
109537:             tabs.reverse();
109537:           let tabWidth = draggedTab.getBoundingClientRect().width;
109537: 
109537:           // Move the dragged tab based on the mouse position.
109537: 
109537:           let leftTab = tabs[0];
109537:           let rightTab = tabs[tabs.length - 1];
109537:           let tabScreenX = draggedTab.boxObject.screenX;
109537:           let translateX = screenX - draggedTab._dragData.screenX;
109537:           if (!pinned)
109537:             translateX += this.mTabstrip.scrollPosition - draggedTab._dragData.scrollX;
109537:           let leftBound = leftTab.boxObject.screenX - tabScreenX;
109537:           let rightBound = (rightTab.boxObject.screenX + rightTab.boxObject.width) -
109537:                            (tabScreenX + tabWidth);
109537:           translateX = Math.max(translateX, leftBound);
109537:           translateX = Math.min(translateX, rightBound);
109537:           draggedTab.style.transform = "translateX(" + translateX + "px)";
109537: 
109537:           // Determine what tab we're dragging over.
109537:           // * Point of reference is the center of the dragged tab. If that
109537:           //   point touches a background tab, the dragged tab would take that
109537:           //   tab's position when dropped.
109537:           // * We're doing a binary search in order to reduce the amount of
109537:           //   tabs we need to check.
109537: 
109537:           let tabCenter = tabScreenX + translateX + tabWidth / 2;
109537:           let newIndex = -1;
109537:           let oldIndex = "animDropIndex" in draggedTab._dragData ?
109537:                          draggedTab._dragData.animDropIndex : draggedTab._tPos;
109537:           let low = 0;
109537:           let high = tabs.length - 1;
109537:           while (low <= high) {
109537:             let mid = Math.floor((low + high) / 2);
109537:             if (tabs[mid] == draggedTab &&
109537:                 ++mid > high)
109537:               break;
109537:             let boxObject = tabs[mid].boxObject;
109537:             let screenX = boxObject.screenX + getTabShift(tabs[mid], oldIndex);
109537:             if (screenX > tabCenter) {
109537:               high = mid - 1;
109537:             } else if (screenX + boxObject.width < tabCenter) {
109537:               low = mid + 1;
109537:             } else {
109537:               newIndex = tabs[mid]._tPos;
109537:               break;
109537:             }
109537:           }
109537:           if (newIndex >= oldIndex)
109537:             newIndex++;
109537:           if (newIndex < 0 || newIndex == oldIndex)
109537:             return;
109537:           draggedTab._dragData.animDropIndex = newIndex;
109537: 
109537:           // Shift background tabs to leave a gap where the dragged tab
109537:           // would currently be dropped.
109537: 
109537:           for (let tab of tabs) {
109537:             if (tab != draggedTab) {
109537:               let shift = getTabShift(tab, newIndex);
109537:               tab.style.transform = shift ? "translateX(" + shift + "px)" : "";
109537:             }
109537:           }
109537: 
109537:           function getTabShift(tab, dropIndex) {
109537:             if (tab._tPos < draggedTab._tPos && tab._tPos >= dropIndex)
109537:               return rtl ? -tabWidth : tabWidth;
109537:             if (tab._tPos > draggedTab._tPos && tab._tPos < dropIndex)
109537:               return rtl ? tabWidth : -tabWidth;
109537:             return 0;
109537:           }
109537:         ]]></body>
109537:       </method>
109537: 
109537:       <method name="_finishAnimateTabMove">
109537:         <body><![CDATA[
109537:           if (this.getAttribute("movingtab") != "true")
109537:             return;
109537: 
109537:           for (let tab of this.tabbrowser.visibleTabs)
109537:             tab.style.transform = "";
109537: 
109537:           this.removeAttribute("movingtab");
111009: 
111009:           this._handleTabSelect();
109537:         ]]></body>
109537:       </method>
109537: 
  5080:       <method name="handleEvent">
  5080:         <parameter name="aEvent"/>
  5080:         <body><![CDATA[
  5080:           switch (aEvent.type) {
 91977:             case "load":
 91977:               this.updateVisibility();
 91977:               break;
  5137:             case "resize":
 57569:               if (aEvent.target != window)
 57569:                 break;
106563: 
106563:               let sizemode = document.documentElement.getAttribute("sizemode");
106563:               TabsInTitlebar.allowedBy("sizemode",
106563:                                        sizemode == "maximized" || sizemode == "fullscreen");
106563: 
  5137:               var width = this.mTabstrip.boxObject.width;
  5137:               if (width != this.mTabstripWidth) {
  5137:                 this.adjustTabstrip();
 23742:                 this._fillTrailingGap();
  5137:                 this._handleTabSelect();
  5137:                 this.mTabstripWidth = width;
  5137:               }
106563: 
 61274:               this.tabbrowser.updateWindowResizers();
  5137:               break;
 67993:             case "mouseout":
 80894:               // If the "related target" (the node to which the pointer went) is not
 80894:               // a child of the current document, the mouse just left the window.
 80894:               let relatedTarget = aEvent.relatedTarget;
 80894:               if (relatedTarget && relatedTarget.ownerDocument == document)
 67993:                 break;
 67993:             case "mousemove":
 80894:               if (document.getElementById("tabContextMenu").state != "open")
 80894:                 this._unlockTabSizing();
 67993:               break;
  5080:           }
  5080:         ]]></body>
  5080:       </method>
  5080: 
 33806:       <field name="_animateElement">
 33806:         this.mTabstrip._scrollButtonDown;
  5100:       </field>
  5100: 
  5060:       <method name="_notifyBackgroundTab">
  5060:         <parameter name="aTab"/>
  5060:         <body><![CDATA[
 46158:           if (aTab.pinned)
 46158:             return;
 46158: 
 30175:           var scrollRect = this.mTabstrip.scrollClientRect;
 30175:           var tab = aTab.getBoundingClientRect();
  5060: 
 12544:           // Is the new tab already completely visible?
 30175:           if (scrollRect.left <= tab.left && tab.right <= scrollRect.right)
 12544:             return;
 12544: 
 12544:           if (this.mTabstrip.smoothScroll) {
 51013:             let selected = !this.selectedItem.pinned &&
 51013:                            this.selectedItem.getBoundingClientRect();
 12544: 
 12544:             // Can we make both the new tab and the selected tab completely visible?
 51013:             if (!selected ||
 51013:                 Math.max(tab.right - selected.left, selected.right - tab.left) <=
 30175:                   scrollRect.width) {
 12544:               this.mTabstrip.ensureElementIsVisible(aTab);
 12544:               return;
 12544:             }
 12544: 
 27274:             this.mTabstrip._smoothScrollByPixels(this.mTabstrip._isRTLScrollbox ?
 30175:                                                  selected.right - scrollRect.right :
 30175:                                                  selected.left - scrollRect.left);
 12544:           }
 12544: 
 34585:           if (!this._animateElement.hasAttribute("notifybgtab")) {
 34585:             this._animateElement.setAttribute("notifybgtab", "true");
 34585:             setTimeout(function (ele) {
 34585:               ele.removeAttribute("notifybgtab");
 34585:             }, 150, this._animateElement);
 34585:           }
  5060:         ]]></body>
  5060:       </method>
 39508: 
 39508:       <method name="_getDragTargetTab">
 39508:         <parameter name="event"/>
 39508:         <body><![CDATA[
 51922:           let tab = event.target.localName == "tab" ? event.target : null;
 51922:           if (tab &&
 51922:               (event.type == "drop" || event.type == "dragover") &&
 51922:               event.dataTransfer.dropEffect == "link") {
 51922:             let boxObject = tab.boxObject;
 51922:             if (event.screenX < boxObject.screenX + boxObject.width * .25 ||
 51922:                 event.screenX > boxObject.screenX + boxObject.width * .75)
 51922:               return null;
 51922:           }
 51922:           return tab;
 39508:         ]]></body>
 39508:       </method>
 39508: 
 39508:       <method name="_getDropIndex">
 39508:         <parameter name="event"/>
 39508:         <body><![CDATA[
 80894:           var tabs = this.childNodes;
 80894:           var tab = this._getDragTargetTab(event);
 80894:           if (window.getComputedStyle(this, null).direction == "ltr") {
 80894:             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
 80894:               if (event.screenX < tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
 74391:                 return i;
 80894:           } else {
 80894:             for (let i = tab ? tab._tPos : 0; i < tabs.length; i++)
 80894:               if (event.screenX > tabs[i].boxObject.screenX + tabs[i].boxObject.width / 2)
 80894:                 return i;
 74391:           }
 80894:           return tabs.length;
 39508:         ]]></body>
 39508:       </method>
 39508: 
 39508:       <method name="_setEffectAllowedForDataTransfer">
 39508:         <parameter name="event"/>
 39508:         <body><![CDATA[
 39508:           var dt = event.dataTransfer;
 39508:           // Disallow dropping multiple items
 39508:           if (dt.mozItemCount > 1)
 39508:             return dt.effectAllowed = "none";
 39508: 
 80894:           var types = dt.mozTypesAt(0);
 80894:           var sourceNode = null;
 80894:           // tabs are always added as the first type
 80894:           if (types[0] == TAB_DROP_TYPE) {
 80894:             var sourceNode = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
 80894:             if (sourceNode instanceof XULElement &&
 80894:                 sourceNode.localName == "tab" &&
109537:                 sourceNode.ownerDocument.defaultView instanceof ChromeWindow &&
109537:                 sourceNode.ownerDocument.documentElement.getAttribute("windowtype") == "navigator:browser" &&
109537:                 sourceNode.ownerDocument.defaultView.gBrowser.tabContainer == sourceNode.parentNode) {
125007:               // Do not allow transfering a private tab to a non-private window
125007:               // and vice versa.
125007:               if (PrivateBrowsingUtils.isWindowPrivate(window) !=
125007:                   PrivateBrowsingUtils.isWindowPrivate(sourceNode.ownerDocument.defaultView))
125007:                 return dt.effectAllowed = "none";
125007: 
109537: #ifdef XP_MACOSX
109537:               return dt.effectAllowed = event.altKey ? "copy" : "move";
109537: #else
109537:               return dt.effectAllowed = event.ctrlKey ? "copy" : "move";
109537: #endif
 80894:             }
 80894:           }
 80894: 
 42827:           if (browserDragAndDrop.canDropLink(event)) {
 42827:             // Here we need to do this manually
 39508:             return dt.effectAllowed = dt.dropEffect = "link";
 39508:           }
 39508:           return dt.effectAllowed = "none";
 39508:         ]]></body>
 39508:       </method>
 39508: 
 43571:       <method name="_handleNewTab">
 43571:         <parameter name="tab"/>
 43571:         <body><![CDATA[
 69864:           if (tab.parentNode != this)
 69864:             return;
 78256:           tab._fullyOpen = true;
 69864: 
 69864:           this.adjustTabstrip();
 69864: 
 43571:           if (tab.getAttribute("selected") == "true") {
 43571:             this._fillTrailingGap();
 43571:             this._handleTabSelect();
 43571:           } else {
 43571:             this._notifyBackgroundTab(tab);
 43571:           }
 43571: 
 43571:           // XXXmano: this is a temporary workaround for bug 345399
 43571:           // We need to manually update the scroll buttons disabled state
 43571:           // if a tab was inserted to the overflow area or removed from it
 43571:           // without any scrolling and when the tabbar has already
 43571:           // overflowed.
 43571:           this.mTabstrip._updateScrollButtonsDisabledState();
 43571:         ]]></body>
 43571:       </method>
 43571: 
 51428:       <method name="_canAdvanceToTab">
 51428:         <parameter name="aTab"/>
 51428:         <body>
 51428:         <![CDATA[
 70847:           return !aTab.closing;
 51428:         ]]>
 51428:         </body>
 51428:       </method>
 51428: 
132021:       <method name="_handleTabTelemetryStart">
132021:         <parameter name="aTab"/>
132021:         <parameter name="aURI"/>
132021:         <body>
132021:         <![CDATA[
132021:           // Animation-smoothness telemetry/logging
135573:           if (Services.telemetry.canRecord || this._tabAnimationLoggingEnabled) {
132021:             if (aURI == "about:newtab" && (aTab._tPos == 1 || aTab._tPos == 2)) {
132021:               // Indicate newtab page animation where other tabs are unaffected
132021:               // (for which case, the 2nd or 3rd tabs are good representatives, even if not absolute)
132021:               aTab._recordingTabOpenPlain = true;
132021:             }
132021:             aTab._recordingHandle = window.QueryInterface(Ci.nsIInterfaceRequestor)
132021:                                           .getInterface(Ci.nsIDOMWindowUtils)
132021:                                           .startFrameTimeRecording();
132021:           }
132021: 
132021:           // Overall animation duration
132021:           aTab._animStartTime = Date.now();
132021:         ]]>
132021:         </body>
132021:       </method>
132021: 
132021:       <method name="_handleTabTelemetryEnd">
132021:         <parameter name="aTab"/>
132021:         <body>
132021:         <![CDATA[
132021:           if (!aTab._animStartTime) {
132021:             return;
132021:           }
132021: 
132021:           Services.telemetry.getHistogramById(aTab.closing ?
132021:                                               "FX_TAB_ANIM_CLOSE_MS" :
132021:                                               "FX_TAB_ANIM_OPEN_MS")
132021:                             .add(Date.now() - aTab._animStartTime);
132021:           aTab._animStartTime = 0;
132021: 
132021:           // Handle tab animation smoothness telemetry/logging of frame intervals and paint times
132021:           if (!("_recordingHandle" in aTab)) {
132021:             return;
132021:           }
132021: 
132021:           let paints = {};
132021:           let intervals = window.QueryInterface(Ci.nsIInterfaceRequestor)
132021:                                 .getInterface(Ci.nsIDOMWindowUtils)
132021:                                 .stopFrameTimeRecording(aTab._recordingHandle, paints);
132021:           delete aTab._recordingHandle;
132021:           paints = paints.value; // The result array itself.
132021:           let frameCount = intervals.length;
132021: 
132021:           if (this._tabAnimationLoggingEnabled) {
132021:             let msg = "Tab " + (aTab.closing ? "close" : "open") + " (Frame-interval / paint-processing):\n";
132021:             for (let i = 0; i < frameCount; i++) {
132021:               msg += Math.round(intervals[i]) + " / " + Math.round(paints[i]) + "\n";
132021:             }
132021:             Services.console.logStringMessage(msg);
132021:           }
132021: 
132021:           // For telemetry, the first frame interval is not useful since it may represent an interval
132021:           // to a relatively old frame (prior to recording start). So we'll ignore it for the average.
132021:           // But if we recorded only 1 frame (very rare), then the first paint duration is a good
132021:           // representative of the first frame interval for our cause (indicates very bad animation).
132021:           // First paint duration is always useful for us.
132021:           if (frameCount > 0) {
132021:             let averageInterval = 0;
132021:             let averagePaint = paints[0];
132021:             for (let i = 1; i < frameCount; i++) {
132021:               averageInterval += intervals[i];
132021:               averagePaint    += paints[i];
132021:             };
132021:             averagePaint /= frameCount;
132021:             averageInterval = (frameCount == 1)
132021:                               ? averagePaint
132021:                               : averageInterval / (frameCount - 1);
132021: 
132021:             Services.telemetry.getHistogramById("FX_TAB_ANIM_ANY_FRAME_INTERVAL_MS").add(averageInterval);
132021:             Services.telemetry.getHistogramById("FX_TAB_ANIM_ANY_FRAME_PAINT_MS").add(averagePaint);
132021: 
132021:             if (aTab._recordingTabOpenPlain) {
132021:               delete aTab._recordingTabOpenPlain;
132021:               // While we do have a telemetry probe NEWTAB_PAGE_ENABLED to monitor newtab preview, it'll be
132021:               // easier to overview the data without slicing by it. Hence the additional histograms with _PREVIEW.
132021:               let preview = this._browserNewtabpageEnabled ? "_PREVIEW" : "";
132021:               Services.telemetry.getHistogramById("FX_TAB_ANIM_OPEN" + preview + "_FRAME_INTERVAL_MS").add(averageInterval);
132021:               Services.telemetry.getHistogramById("FX_TAB_ANIM_OPEN" + preview + "_FRAME_PAINT_MS").add(averagePaint);
132021:             }
132021:           }
132021:         ]]>
132021:         </body>
132021:       </method>
132021: 
 41426:       <!-- Deprecated stuff, implemented for backwards compatibility. -->
 41426:       <property name="mTabstripClosebutton" readonly="true"
 41426:                 onget="return document.getElementById('tabs-closebutton');"/>
 41426:       <property name="mAllTabsPopup" readonly="true"
 41426:                 onget="return document.getElementById('alltabs-popup');"/>
  5018:     </implementation>
 39508: 
  5018:     <handlers>
  5054:       <handler event="TabSelect" action="this._handleTabSelect();"/>
 39508: 
 43571:       <handler event="transitionend"><![CDATA[
 49132:         if (event.propertyName != "max-width")
 49132:           return;
 49132: 
 49132:         var tab = event.target;
 49132: 
132021:         this._handleTabTelemetryEnd(tab);
 84831: 
 78256:         if (tab.getAttribute("fadein") == "true") {
 78256:           if (tab._fullyOpen)
 78256:             this.adjustTabstrip();
 78256:           else
 49132:             this._handleNewTab(tab);
 78256:         } else if (tab.closing) {
 49132:           this.tabbrowser._endRemoveTab(tab);
 78256:         }
 43571:       ]]></handler>
 43571: 
 39508:       <handler event="dblclick"><![CDATA[
 71877: #ifndef XP_MACOSX
 71877:         // When the tabbar has an unified appearance with the titlebar
 71877:         // and menubar, a double-click in it should have the same behavior
 71877:         // as double-clicking the titlebar
 71877:         if (TabsInTitlebar.enabled ||
 71877:             (TabsOnTop.enabled && this.parentNode._dragBindingAlive))
 63021:           return;
 63021: #endif
 71877: 
 71877:         if (event.button != 0 ||
 71877:             event.originalTarget.localName != "box")
 71877:           return;
 71877: 
 63021:         // See hack note in the tabbrowser-close-tab-button binding
 71877:         if (!this._blockDblClick)
 39508:           BrowserOpenTab();
 71877: 
 71877:         event.preventDefault();
 39508:       ]]></handler>
 39508: 
 39508:       <handler event="click"><![CDATA[
 44123:         if (event.button != 1)
 39508:           return;
 39508: 
 44123:         if (event.target.localName == "tab") {
 44123:           if (this.childNodes.length > 1 || !this._closeWindowWithLastTab)
 67993:             this.tabbrowser.removeTab(event.target, {animate: true, byMouse: true});
 44123:         } else if (event.originalTarget.localName == "box") {
 44123:           BrowserOpenTab();
 44123:         } else {
 44123:           return;
 44123:         }
 39508: 
 39508:         event.stopPropagation();
 39508:       ]]></handler>
 39508: 
 42273:       <handler event="keypress"><![CDATA[
 42273:         if (event.altKey || event.shiftKey ||
 42273: #ifdef XP_MACOSX
 42273:             !event.metaKey)
 42273: #else
 42273:             !event.ctrlKey || event.metaKey)
 42273: #endif
 42273:           return;
 42273: 
 42273:         switch (event.keyCode) {
 42273:           case KeyEvent.DOM_VK_UP:
 42273:             this.tabbrowser.moveTabBackward();
 42273:             break;
 42273:           case KeyEvent.DOM_VK_DOWN:
 42273:             this.tabbrowser.moveTabForward();
 42273:             break;
 42273:           case KeyEvent.DOM_VK_RIGHT:
 42273:           case KeyEvent.DOM_VK_LEFT:
 42273:             this.tabbrowser.moveTabOver(event);
 42273:             break;
 42273:           case KeyEvent.DOM_VK_HOME:
 42273:             this.tabbrowser.moveTabToStart();
 42273:             break;
 42273:           case KeyEvent.DOM_VK_END:
 42273:             this.tabbrowser.moveTabToEnd();
 42273:             break;
 42273:           default:
 42273:             // Stop the keypress event for the above keyboard
 42273:             // shortcuts only.
 42273:             return;
 42273:         }
 42273:         event.stopPropagation();
 42273:         event.preventDefault();
 42273:       ]]></handler>
 42273: 
 39508:       <handler event="dragstart"><![CDATA[
 80894:         var tab = this._getDragTargetTab(event);
 80894:         if (!tab)
 74391:           return;
 80894: 
 74522:         let dt = event.dataTransfer;
 80894:         dt.mozSetDataAt(TAB_DROP_TYPE, tab, 0);
114498:         let browser = tab.linkedBrowser;
 80894: 
 80894:         // We must not set text/x-moz-url or text/plain data here,
 80894:         // otherwise trying to deatch the tab by dropping it on the desktop
 80894:         // may result in an "internet shortcut"
114498:         dt.mozSetDataAt("text/x-moz-text-internal", browser.currentURI.spec, 0);
 80894: 
 80894:         // Set the cursor to an arrow during tab drags.
 80894:         dt.mozCursor = "default";
 80894: 
107930:         // Create a canvas to which we capture the current tab.
115495:         // Until canvas is HiDPI-aware (bug 780362), we need to scale the desired
115495:         // canvas size (in CSS pixels) to the window's backing resolution in order
115495:         // to get a full-resolution drag image for use on HiDPI displays.
115495:         let windowUtils = window.getInterface(Ci.nsIDOMWindowUtils);
115495:         let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;
107930:         let canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
107930:         canvas.mozOpaque = true;
115495:         canvas.width = 160 * scale;
115495:         canvas.height = 90 * scale;
107930:         PageThumbs.captureToCanvas(browser.contentWindow, canvas);
115495:         dt.setDragImage(canvas, -16 * scale, -16 * scale);
 80894: 
109537:         // _dragData.offsetX/Y give the coordinates that the mouse should be
 80894:         // positioned relative to the corner of the new window created upon
 80894:         // dragend such that the mouse appears to have the same position
 80894:         // relative to the corner of the dragged tab.
 80894:         function clientX(ele) ele.getBoundingClientRect().left;
114498:         let tabOffsetX = clientX(tab) - clientX(this);
109537:         tab._dragData = {
109537:           offsetX: event.screenX - window.screenX - tabOffsetX,
109537:           offsetY: event.screenY - window.screenY,
109537:           scrollX: this.mTabstrip.scrollPosition,
109537:           screenX: event.screenX
109537:         };
 80894: 
 80894:         event.stopPropagation();
 80894:       ]]></handler>
 80894: 
 80894:       <handler event="dragover"><![CDATA[
 80894:         var effects = this._setEffectAllowedForDataTransfer(event);
 80894: 
 80894:         var ind = this._tabDropIndicator;
 80894:         if (effects == "" || effects == "none") {
 80894:           ind.collapsed = true;
 74522:           return;
 74522:         }
 80894:         event.preventDefault();
 39508:         event.stopPropagation();
 80894: 
 80894:         var tabStrip = this.mTabstrip;
 80894:         var ltr = (window.getComputedStyle(this, null).direction == "ltr");
 80894: 
 80894:         // autoscroll the tab strip if we drag over the scroll
 80894:         // buttons, even if we aren't dragging a tab, but then
 80894:         // return to avoid drawing the drop indicator
 80894:         var pixelsToScroll = 0;
 80894:         if (this.getAttribute("overflow") == "true") {
 80894:           var targetAnonid = event.originalTarget.getAttribute("anonid");
 80894:           switch (targetAnonid) {
 80894:             case "scrollbutton-up":
 80894:               pixelsToScroll = tabStrip.scrollIncrement * -1;
 80894:               break;
 80894:             case "scrollbutton-down":
 80894:               pixelsToScroll = tabStrip.scrollIncrement;
 80894:               break;
 80894:           }
 80894:           if (pixelsToScroll)
 80894:             tabStrip.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll);
 80894:         }
 80894: 
109537:         if (effects == "move" &&
109537:             this == event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0).parentNode) {
109537:           ind.collapsed = true;
109537:           this._animateTabMove(event);
109537:           return;
109537:         }
109537: 
111009:         this._finishAnimateTabMove();
109537: 
 80894:         if (effects == "link") {
 80894:           let tab = this._getDragTargetTab(event);
 80894:           if (tab) {
 80894:             if (!this._dragTime)
 80894:               this._dragTime = Date.now();
 80894:             if (Date.now() >= this._dragTime + this._dragOverDelay)
 80894:               this.selectedItem = tab;
 80894:             ind.collapsed = true;
 80894:             return;
 80894:           }
 80894:         }
 80894: 
111025:         var rect = tabStrip.getBoundingClientRect();
111570:         var newMargin;
111570:         if (pixelsToScroll) {
111570:           // if we are scrolling, put the drop indicator at the edge
111570:           // so that it doesn't jump while scrolling
111570:           let scrollRect = tabStrip.scrollClientRect;
111570:           let minMargin = scrollRect.left - rect.left;
111570:           let maxMargin = Math.min(minMargin + scrollRect.width,
 80894:                                    scrollRect.right);
 80894:           if (!ltr)
 80894:             [minMargin, maxMargin] = [this.clientWidth - maxMargin,
 80894:                                       this.clientWidth - minMargin];
 80894:           newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
 80894:         }
 80894:         else {
111341:           let newIndex = this._getDropIndex(event);
 80894:           if (newIndex == this.childNodes.length) {
 80894:             let tabRect = this.childNodes[newIndex-1].getBoundingClientRect();
 80894:             if (ltr)
 80894:               newMargin = tabRect.right - rect.left;
 80894:             else
 80894:               newMargin = rect.right - tabRect.left;
 80894:           }
 80894:           else {
 80894:             let tabRect = this.childNodes[newIndex].getBoundingClientRect();
 80894:             if (ltr)
 80894:               newMargin = tabRect.left - rect.left;
 80894:             else
 80894:               newMargin = rect.right - tabRect.right;
 80894:           }
 80894:         }
 80894: 
 80894:         ind.collapsed = false;
 80894: 
 80894:         newMargin += ind.clientWidth / 2;
 80894:         if (!ltr)
 80894:           newMargin *= -1;
 80894: 
105446:         ind.style.transform = "translate(" + Math.round(newMargin) + "px)";
 80894:         ind.style.MozMarginStart = (-ind.clientWidth) + "px";
 39508:       ]]></handler>
 39508: 
 74391:       <handler event="drop"><![CDATA[
 80894:         var dt = event.dataTransfer;
 80894:         var dropEffect = dt.dropEffect;
 80894:         var draggedTab;
 80894:         if (dropEffect != "link") { // copy or move
 80894:           draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
 80894:           // not our drop then
 80894:           if (!draggedTab)
 80894:             return;
 80894:         }
 80894: 
 74391:         this._tabDropIndicator.collapsed = true;
 80894:         event.stopPropagation();
109537:         if (draggedTab && dropEffect == "copy") {
109537:           // copy the dropped tab (wherever it's from)
 80894:           let newIndex = this._getDropIndex(event);
 80894:           let newTab = this.tabbrowser.duplicateTab(draggedTab);
 80894:           this.tabbrowser.moveTabTo(newTab, newIndex);
 80894:           if (draggedTab.parentNode != this || event.shiftKey)
 80894:             this.selectedItem = newTab;
109537:         } else if (draggedTab && draggedTab.parentNode == this) {
125052:           this._finishAnimateTabMove();
125052: 
111009:           // actually move the dragged tab
111009:           if ("animDropIndex" in draggedTab._dragData) {
111009:             let newIndex = draggedTab._dragData.animDropIndex;
111009:             if (newIndex > draggedTab._tPos)
111009:               newIndex--;
111009:             this.tabbrowser.moveTabTo(draggedTab, newIndex);
111009:           }
 80894:         } else if (draggedTab) {
 80894:           // swap the dropped tab with a new one we create and then close
 80894:           // it in the other window (making it seem to have moved between
 80894:           // windows)
 80894:           let newIndex = this._getDropIndex(event);
 80894:           let newTab = this.tabbrowser.addTab("about:blank");
 80894:           let newBrowser = this.tabbrowser.getBrowserForTab(newTab);
 80894:           // Stop the about:blank load
 80894:           newBrowser.stop();
 80894:           // make sure it has a docshell
 80894:           newBrowser.docShell;
 80894: 
109537:           let numPinned = this.tabbrowser._numPinnedTabs;
109537:           if (newIndex < numPinned || draggedTab.pinned && newIndex == numPinned)
109537:             this.tabbrowser.pinTab(newTab);
 80894:           this.tabbrowser.moveTabTo(newTab, newIndex);
 80894: 
136343:           // We need to select the tab before calling swapBrowsersAndCloseOther
136343:           // so that window.content in chrome windows points to the right tab
136343:           // when pagehide/show events are fired.
136343:           this.tabbrowser.selectedTab = newTab;
136343: 
110734:           draggedTab.parentNode._finishAnimateTabMove();
 80894:           this.tabbrowser.swapBrowsersAndCloseOther(newTab, draggedTab);
 80894: 
136343:           // Call updateCurrentBrowser to make sure the URL bar is up to date
136343:           // for our new tab after we've done swapBrowsersAndCloseOther.
136589:           this.tabbrowser.updateCurrentBrowser(true);
 80894:         } else {
 90411:           // Pass true to disallow dropping javascript: or data: urls
 90411:           let url;
 90411:           try {
 90411:             url = browserDragAndDrop.drop(event, { }, true);
 90411:           } catch (ex) {}
 39508: 
 80894:           // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
111526:           if (!url || url.contains(" "))
 39508:             return;
 39508: 
 39682:           let bgLoad = Services.prefs.getBoolPref("browser.tabs.loadInBackground");
 39508: 
 39508:           if (event.shiftKey)
 39508:             bgLoad = !bgLoad;
 39508: 
 39508:           let tab = this._getDragTargetTab(event);
 80894:           if (!tab || dropEffect == "copy") {
 39508:             // We're adding a new tab.
 39508:             let newIndex = this._getDropIndex(event);
 39508:             let newTab = this.tabbrowser.loadOneTab(getShortcutOrURI(url), {inBackground: bgLoad});
 39508:             this.tabbrowser.moveTabTo(newTab, newIndex);
 39508:           } else {
 39508:             // Load in an existing tab.
 39508:             try {
 39508:               this.tabbrowser.getBrowserForTab(tab).loadURI(getShortcutOrURI(url));
 39508:               if (!bgLoad)
 39508:                 this.selectedItem = tab;
 80894:             } catch(ex) {
 80894:               // Just ignore invalid urls
 80894:             }
 80894:           }
 80894:         }
 80894: 
 90164:         if (draggedTab) {
109537:           delete draggedTab._dragData;
 90164:         }
 80894:       ]]></handler>
 80894: 
 80894:       <handler event="dragend"><![CDATA[
 80894:         // Note: while this case is correctly handled here, this event
 80894:         // isn't dispatched when the tab is moved within the tabstrip,
 80894:         // see bug 460801.
 80894: 
111009:         this._finishAnimateTabMove();
109537: 
 80894:         var dt = event.dataTransfer;
109537:         var draggedTab = dt.mozGetDataAt(TAB_DROP_TYPE, 0);
109537:         if (dt.mozUserCancelled || dt.dropEffect != "none") {
109537:           delete draggedTab._dragData;
 74391:           return;
109537:         }
 80894: 
 80894:         // Disable detach within the browser toolbox
 80894:         var eX = event.screenX;
 80894:         var eY = event.screenY;
 80894:         var wX = window.screenX;
 80894:         // check if the drop point is horizontally within the window
 80894:         if (eX > wX && eX < (wX + window.outerWidth)) {
 80894:           let bo = this.mTabstrip.boxObject;
 80894:           // also avoid detaching if the the tab was dropped too close to
 80894:           // the tabbar (half a tab)
 80894:           let endScreenY = bo.screenY + 1.5 * bo.height;
 80894:           if (eY < endScreenY && eY > window.screenY)
 80894:             return;
 39508:         }
 80894: 
 80894:         // screen.availLeft et. al. only check the screen that this window is on,
 80894:         // but we want to look at the screen the tab is being dropped onto.
 80894:         var sX = {}, sY = {}, sWidth = {}, sHeight = {};
 80894:         Cc["@mozilla.org/gfx/screenmanager;1"]
 80894:           .getService(Ci.nsIScreenManager)
 80894:           .screenForRect(eX, eY, 1, 1)
 80894:           .GetAvailRect(sX, sY, sWidth, sHeight);
 80894:         // ensure new window entirely within screen
 80894:         var winWidth = Math.min(window.outerWidth, sWidth.value);
 80894:         var winHeight = Math.min(window.outerHeight, sHeight.value);
109537:         var left = Math.min(Math.max(eX - draggedTab._dragData.offsetX, sX.value),
 80894:                             sX.value + sWidth.value - winWidth);
109537:         var top = Math.min(Math.max(eY - draggedTab._dragData.offsetY, sY.value),
 80894:                            sY.value + sHeight.value - winHeight);
 80894: 
109537:         delete draggedTab._dragData;
 80894: 
 80894:         if (this.tabbrowser.tabs.length == 1) {
 80894:           // resize _before_ move to ensure the window fits the new screen.  if
 80894:           // the window is too large for its screen, the window manager may do
 80894:           // automatic repositioning.
 80894:           window.resizeTo(winWidth, winHeight);
 80894:           window.moveTo(left, top);
 80894:           window.focus();
 80894:         } else {
 80894:           this.tabbrowser.replaceTabWithWindow(draggedTab, { screenX: left,
 80894:                                                              screenY: top,
 80894: #ifndef XP_WIN
 80894:                                                              outerWidth: winWidth,
 80894:                                                              outerHeight: winHeight
 80894: #endif
 80894:                                                              });
 39508:         }
 80894:         event.stopPropagation();
 39508:       ]]></handler>
 39508: 
 58550:       <handler event="dragexit"><![CDATA[
 39508:         this._dragTime = 0;
 39508: 
 39508:         // This does not work at all (see bug 458613)
 39508:         var target = event.relatedTarget;
 39508:         while (target && target != this)
 39508:           target = target.parentNode;
 39508:         if (target)
 39508:           return;
 39508: 
 39508:         this._tabDropIndicator.collapsed = true;
 39508:         event.stopPropagation();
 39508:       ]]></handler>
  5060:     </handlers>
  5060:   </binding>
  5060: 
  5059:   <!-- close-tab-button binding
  5059:        This binding relies on the structure of the tabbrowser binding.
  5060:        Therefore it should only be used as a child of the tab or the tabs
  5059:        element (in both cases, when they are anonymous nodes of <tabbrowser>).
  5059:   -->
  5059:   <binding id="tabbrowser-close-tab-button"
  5087:            extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image">
  5059:     <handlers>
  5095:       <handler event="click" button="0"><![CDATA[
  5059:         var bindingParent = document.getBindingParent(this);
 41426:         var tabContainer = bindingParent.parentNode;
  5092:         /* The only sequence in which a second click event (i.e. dblclik)
  5092:          * can be dispatched on an in-tab close button is when it is shown
  5092:          * after the first click (i.e. the first click event was dispatched
  5092:          * on the tab). This happens when we show the close button only on
  5123:          * the active tab. (bug 352021)
  5123:          * The only sequence in which a third click event can be dispatched
  5123:          * on an in-tab close button is when the tab was opened with a
  5123:          * double click on the tabbar. (bug 378344)
  5123:          * In both cases, it is most likely that the close button area has
  5123:          * been accidentally clicked, therefore we do not close the tab.
 12810:          *
 12810:          * We don't want to ignore processing of more than one click event,
 12810:          * though, since the user might actually be repeatedly clicking to
 12810:          * close many tabs at once.
  5092:          */
 12810:         if (event.detail > 1 && !this._ignoredClick) {
 12810:           this._ignoredClick = true;
  5092:           return;
 12810:         }
 12810: 
 12810:         // Reset the "ignored click" flag
 12810:         this._ignoredClick = false;
  5092: 
 67993:         tabContainer.tabbrowser.removeTab(bindingParent, {animate: true, byMouse: true});
 43569:         tabContainer._blockDblClick = true;
  5059: 
  5059:         /* XXXmano hack (see bug 343628):
  5059:          * Since we're removing the event target, if the user
  5059:          * double-clicks this button, the dblclick event will be dispatched
  5059:          * with the tabbar as its event target (and explicit/originalTarget),
  5059:          * which treats that as a mouse gesture for opening a new tab.
  5122:          * In this context, we're manually blocking the dblclick event
 39508:          * (see dblclick handler).
  5059:          */
 41426:         var clickedOnce = false;
  5122:         function enableDblClick(event) {
  5122:           if (event.detail == 1 && !clickedOnce) {
  5122:             clickedOnce = true;
  5122:             return;
  5122:           }
  5122:           setTimeout(function() {
 43569:             tabContainer._blockDblClick = false;
  5122:           }, 0);
 39508:           tabContainer.removeEventListener("click", enableDblClick, false);
  5059:         }
 39508:         tabContainer.addEventListener("click", enableDblClick, false);
  5059:       ]]></handler>
 39508: 
  5095:       <handler event="dblclick" button="0" phase="capturing">
  5059:         // for the one-close-button case
  5059:         event.stopPropagation();
  5059:       </handler>
 39508: 
 39508:       <handler event="dragstart">
 39508:         event.stopPropagation();
 39508:       </handler>
  5059:     </handlers>
  5059:   </binding>
  5059: 
  8254:   <binding id="tabbrowser-tab" display="xul:hbox"
  5018:            extends="chrome://global/content/bindings/tabbox.xml#tab">
 39508:     <resources>
 39508:       <stylesheet src="chrome://browser/content/tabbrowser.css"/>
 39508:     </resources>
 39508: 
 47855:     <content context="tabContextMenu" closetabtext="&closeTab.label;">
 53882:       <xul:stack class="tab-stack" flex="1">
 58323:         <xul:hbox xbl:inherits="pinned,selected,titlechanged"
 58323:                   class="tab-background">
 58323:           <xul:hbox xbl:inherits="pinned,selected,titlechanged"
 58323:                     class="tab-background-start"/>
 58323:           <xul:hbox xbl:inherits="pinned,selected,titlechanged"
 58323:                     class="tab-background-middle"/>
 58323:           <xul:hbox xbl:inherits="pinned,selected,titlechanged"
 58323:                     class="tab-background-end"/>
 58323:         </xul:hbox>
 58323:         <xul:hbox xbl:inherits="pinned,selected,titlechanged"
 58323:                   class="tab-content" align="center">
 55337:           <xul:image xbl:inherits="fadein,pinned,busy,progress,selected"
 55337:                      class="tab-throbber"
115337:                      role="presentation"
115337:                      layer="true" />
132789:           <xul:image xbl:inherits="src=image,fadein,pinned,selected"
 37304:                      class="tab-icon-image"
132789:                      validate="never"
 37304:                      role="presentation"/>
 37304:           <xul:label flex="1"
114104:                      xbl:inherits="value=label,crop,accesskey,fadein,pinned,selected"
 53882:                      class="tab-text tab-label"
 37304:                      role="presentation"/>
 37304:           <xul:toolbarbutton anonid="close-button"
 53882:                              xbl:inherits="fadein,pinned,selected"
 37304:                              class="tab-close-button"/>
 53882:         </xul:hbox>
 53882:       </xul:stack>
  5018:     </content>
  5018: 
  5018:     <implementation>
 46158:       <property name="pinned" readonly="true">
 46158:         <getter>
 46158:           return this.getAttribute("pinned") == "true";
 46158:         </getter>
 46158:       </property>
 55352:       <property name="hidden" readonly="true">
 55352:         <getter>
 55352:           return this.getAttribute("hidden") == "true";
 55352:         </getter>
 55352:       </property>
 46158: 
  5018:       <field name="mOverCloseButton">false</field>
 30185:       <field name="mCorrespondingMenuitem">null</field>
 70847:       <field name="closing">false</field>
 95569:       <field name="lastAccessed">0</field>
  5018:     </implementation>
  5018: 
  5018:     <handlers>
  5018:       <handler event="mouseover">
  5018:         var anonid = event.originalTarget.getAttribute("anonid");
  5018:         if (anonid == "close-button")
  5018:           this.mOverCloseButton = true;
  5018:       </handler>
  5018:       <handler event="mouseout">
  5018:         var anonid = event.originalTarget.getAttribute("anonid");
  5018:         if (anonid == "close-button")
  5018:           this.mOverCloseButton = false;
  5018:       </handler>
136922:       <handler event="mouseenter" phase="target"><![CDATA[
136922:         let tab = event.target;
136922:         if (tab.selected)
136922:           return;
136922: 
136922:         let tabContainer = this.parentNode;
136922:         let visibleTabs = tabContainer.tabbrowser.visibleTabs;
136922:         let tabIndex = visibleTabs.indexOf(tab);
136922:         if (tabIndex == 0) {
136922:           tabContainer._beforeHoveredTab = null;
136922:         } else {
136922:           let candidate = visibleTabs[tabIndex - 1];
136922:           if (!candidate.selected) {
136922:             tabContainer._beforeHoveredTab = candidate;
136922:             candidate.setAttribute("beforehovered", "true");
136922:           }
136922:         }
136922: 
136922:         if (tabIndex == visibleTabs.length - 1) {
136922:           tabContainer._afterHoveredTab = null;
136922:         } else {
136922:           let candidate = visibleTabs[tabIndex + 1];
136922:           if (!candidate.selected) {
136922:             tabContainer._afterHoveredTab = candidate;
136922:             candidate.setAttribute("afterhovered", "true");
136922:           }
136922:         }
136922:       ]]></handler>
136922:       <handler event="mouseleave" phase="target"><![CDATA[
136922:         let tabContainer = this.parentNode;
136922:         if (tabContainer._beforeHoveredTab) {
136922:           tabContainer._beforeHoveredTab.removeAttribute("beforehovered");
136922:           tabContainer._beforeHoveredTab = null;
136922:         }
136922:         if (tabContainer._afterHoveredTab) {
136922:           tabContainer._afterHoveredTab.removeAttribute("afterhovered");
136922:           tabContainer._afterHoveredTab = null;
136922:         }
136922:       ]]></handler>
 25877:       <handler event="dragstart" phase="capturing">
 25877:         this.style.MozUserFocus = '';
 25877:       </handler>
 77911:       <handler event="mousedown" phase="capturing">
  5018:       <![CDATA[
 77531:         if (this.selected) {
 25877:           this.style.MozUserFocus = 'ignore';
 25877:           this.clientTop; // just using this to flush style updates
 77911:         } else if (this.mOverCloseButton) {
 77911:           // Prevent tabbox.xml from selecting the tab.
 77911:           event.stopPropagation();
 25877:         }
  5018:       ]]>
  5018:       </handler>
 25877:       <handler event="mouseup">
 25877:         this.style.MozUserFocus = '';
 25877:       </handler>
  5018:     </handlers>
  5018:   </binding>
  5018: 
 30185:   <binding id="tabbrowser-alltabs-popup"
 30185:            extends="chrome://global/content/bindings/popup.xml#popup">
 30185:     <implementation implements="nsIDOMEventListener">
 30185:       <method name="_tabOnAttrModified">
 30185:         <parameter name="aEvent"/>
 30185:         <body><![CDATA[
 35638:           var tab = aEvent.target;
 87979:           if (tab.mCorrespondingMenuitem)
 35638:             this._setMenuitemAttributes(tab.mCorrespondingMenuitem, tab);
 30185:         ]]></body>
 30185:       </method>
 30185: 
 30185:       <method name="_tabOnTabClose">
 30185:         <parameter name="aEvent"/>
 30185:         <body><![CDATA[
 87979:           var tab = aEvent.target;
 87979:           if (tab.mCorrespondingMenuitem)
 87979:             this.removeChild(tab.mCorrespondingMenuitem);
 30185:         ]]></body>
 30185:       </method>
 30185: 
 30185:       <method name="handleEvent">
 30185:         <parameter name="aEvent"/>
 30185:         <body><![CDATA[
 30185:           switch (aEvent.type) {
 35638:             case "TabAttrModified":
 30185:               this._tabOnAttrModified(aEvent);
 30185:               break;
 30185:             case "TabClose":
 30185:               this._tabOnTabClose(aEvent);
 30185:               break;
 30185:             case "scroll":
 30185:               this._updateTabsVisibilityStatus();
 30185:               break;
 30185:           }
 30185:         ]]></body>
 30185:       </method>
 30185: 
 30185:       <method name="_updateTabsVisibilityStatus">
 30185:         <body><![CDATA[
 41426:           var tabContainer = gBrowser.tabContainer;
 30185:           // We don't want menu item decoration unless there is overflow.
 30185:           if (tabContainer.getAttribute("overflow") != "true")
 30185:             return;
 30185: 
 30185:           var tabstripBO = tabContainer.mTabstrip.scrollBoxObject;
 30185:           for (var i = 0; i < this.childNodes.length; i++) {
 69906:             let curTab = this.childNodes[i].tab;
 69906:             if (!curTab) // "Tab Groups" menuitem and its menuseparator
 69906:               continue;
 69906:             let curTabBO = curTab.boxObject;
 30185:             if (curTabBO.screenX >= tabstripBO.screenX &&
 30185:                 curTabBO.screenX + curTabBO.width <= tabstripBO.screenX + tabstripBO.width)
 30185:               this.childNodes[i].setAttribute("tabIsVisible", "true");
 30185:             else
 30185:               this.childNodes[i].removeAttribute("tabIsVisible");
 30185:           }
 30185:         ]]></body>
 30185:       </method>
 30185: 
 30185:       <method name="_createTabMenuItem">
 30185:         <parameter name="aTab"/>
 30185:         <body><![CDATA[
 30185:           var menuItem = document.createElementNS(
 30185:             "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
 30185:             "menuitem");
 30185: 
 41426:           menuItem.setAttribute("class", "menuitem-iconic alltabs-item menuitem-with-favicon");
 30185: 
 35638:           this._setMenuitemAttributes(menuItem, aTab);
 30185: 
 30185:           aTab.mCorrespondingMenuitem = menuItem;
 30185:           menuItem.tab = aTab;
 30185: 
 30185:           this.appendChild(menuItem);
 30185:         ]]></body>
 30185:       </method>
 35638: 
 35638:       <method name="_setMenuitemAttributes">
 35638:         <parameter name="aMenuitem"/>
 35638:         <parameter name="aTab"/>
 35638:         <body><![CDATA[
 35638:           aMenuitem.setAttribute("label", aTab.label);
 35638:           aMenuitem.setAttribute("crop", aTab.getAttribute("crop"));
 78401: 
 78401:           if (aTab.hasAttribute("busy")) {
 78401:             aMenuitem.setAttribute("busy", aTab.getAttribute("busy"));
 78401:             aMenuitem.removeAttribute("image");
 78401:           } else {
 35638:             aMenuitem.setAttribute("image", aTab.getAttribute("image"));
 35638:             aMenuitem.removeAttribute("busy");
 78401:           }
 35638: 
 78997:           if (aTab.hasAttribute("pending"))
 78997:             aMenuitem.setAttribute("pending", aTab.getAttribute("pending"));
 78997:           else
 78997:             aMenuitem.removeAttribute("pending");
 78997: 
 35638:           if (aTab.selected)
 35638:             aMenuitem.setAttribute("selected", "true");
 35638:           else
 35638:             aMenuitem.removeAttribute("selected");
 35638:         ]]></body>
 35638:       </method>
 30185:     </implementation>
 30185: 
 30185:     <handlers>
 30185:       <handler event="popupshowing">
 30185:       <![CDATA[
 41426:         var tabcontainer = gBrowser.tabContainer;
 30185: 
 30185:         // Listen for changes in the tab bar.
 35638:         tabcontainer.addEventListener("TabAttrModified", this, false);
 35638:         tabcontainer.addEventListener("TabClose", this, false);
 30185:         tabcontainer.mTabstrip.addEventListener("scroll", this, false);
 30185: 
 87979:         let tabs = gBrowser.visibleTabs;
 30185:         for (var i = 0; i < tabs.length; i++) {
 87979:           if (!tabs[i].pinned)
 30185:             this._createTabMenuItem(tabs[i]);
 30185:         }
 30185:         this._updateTabsVisibilityStatus();
 30185:       ]]></handler>
 30185: 
 35627:       <handler event="popuphidden">
 30185:       <![CDATA[
 30185:         // clear out the menu popup and remove the listeners
 62882:         for (let i = this.childNodes.length - 1; i > 0; i--) {
 62882:           let menuItem = this.childNodes[i];
 69906:           if (menuItem.tab) {
 30185:             menuItem.tab.mCorrespondingMenuitem = null;
 30185:             this.removeChild(menuItem);
 30185:           }
 62882:         }
 41426:         var tabcontainer = gBrowser.tabContainer;
 30185:         tabcontainer.mTabstrip.removeEventListener("scroll", this, false);
 35638:         tabcontainer.removeEventListener("TabAttrModified", this, false);
 35638:         tabcontainer.removeEventListener("TabClose", this, false);
 30185:       ]]></handler>
 30185: 
 30185:       <handler event="DOMMenuItemActive">
 30185:       <![CDATA[
 30185:         var tab = event.target.tab;
 30185:         if (tab) {
 55355:           let overLink = tab.linkedBrowser.currentURI.spec;
 55355:           if (overLink == "about:blank")
 55355:             overLink = "";
 55355:           XULBrowserWindow.setOverLink(overLink, null);
 30185:         }
 30185:       ]]></handler>
 30185: 
 30185:       <handler event="DOMMenuItemInactive">
 30185:       <![CDATA[
 30482:         XULBrowserWindow.setOverLink("", null);
 30185:       ]]></handler>
 30185: 
 87979:       <handler event="command"><![CDATA[
 87979:         if (event.target.tab)
 87979:           gBrowser.selectedTab = event.target.tab;
 87979:       ]]></handler>
 87979: 
 30185:     </handlers>
 30185:   </binding>
 30185: 
 61538:   <binding id="statuspanel" display="xul:hbox">
 61538:     <content>
 61538:       <xul:hbox class="statuspanel-inner">
 61538:         <xul:label class="statuspanel-label"
 61558:                    role="status"
137145:                    aria-live="off"
 63166:                    xbl:inherits="value=label,crop,mirror"
 61538:                    flex="1"
 61538:                    crop="end"/>
 61538:       </xul:hbox>
 61538:     </content>
 61538: 
 63295:     <implementation implements="nsIDOMEventListener">
 63295:       <constructor><![CDATA[
 87185:         window.addEventListener("resize", this, false);
 63295:       ]]></constructor>
 63295: 
 63295:       <destructor><![CDATA[
 87185:         window.removeEventListener("resize", this, false);
 87185:         MousePosTracker.removeListener(this);
 63295:       ]]></destructor>
 63295: 
 61538:       <property name="label">
 62269:         <setter><![CDATA[
 95243:           if (!this.label) {
 61538:             this.removeAttribute("mirror");
 95243:             this.removeAttribute("sizelimit");
 95243:           }
 62269: 
 62269:           this.style.minWidth = this.getAttribute("type") == "status" &&
 62269:                                 this.getAttribute("previoustype") == "status"
 62269:                                   ? getComputedStyle(this).width : "";
 62269: 
 78971:           if (val) {
 61538:             this.setAttribute("label", val);
 78971:             this.removeAttribute("inactive");
 87185:             this._calcMouseTargetRect();
 87185:             MousePosTracker.addListener(this);
 78971:           } else {
 78971:             this.setAttribute("inactive", "true");
 87185:             MousePosTracker.removeListener(this);
 78971:           }
 78971: 
 61538:           return val;
 62269:         ]]></setter>
 61538:         <getter>
 78971:           return this.hasAttribute("inactive") ? "" : this.getAttribute("label");
 61538:         </getter>
 61538:       </property>
 61925: 
 87185:       <method name="getMouseTargetRect">
 87185:         <body><![CDATA[
 87185:           return this._mouseTargetRect;
 87185:         ]]></body>
 87185:       </method>
 87185: 
 87185:       <method name="onMouseEnter">
 87185:         <body>
 87185:           this._mirror();
 87185:         </body>
 87185:       </method>
 87185: 
 87185:       <method name="onMouseLeave">
 87185:         <body>
 87185:           this._mirror();
 87185:         </body>
 87185:       </method>
 87185: 
 63295:       <method name="handleEvent">
 63295:         <parameter name="event"/>
 63295:         <body><![CDATA[
 87185:           if (!this.label)
 87185:             return;
 87185: 
 87185:           switch (event.type) {
 87185:             case "resize":
 87185:               this._calcMouseTargetRect();
 87185:               break;
 87185:           }
 87185:         ]]></body>
 87185:       </method>
 87185: 
 87185:       <method name="_calcMouseTargetRect">
 87185:         <body><![CDATA[
 90204:           let alignRight = false;
 87185: 
 87185:           if (getComputedStyle(document.documentElement).direction == "rtl")
 90286:             alignRight = !alignRight;
 87185: 
 87185:           let rect = this.getBoundingClientRect();
 87185:           this._mouseTargetRect = {
 87185:             top:    rect.top,
 87185:             bottom: rect.bottom,
 87185:             left:   alignRight ? window.innerWidth - rect.width : 0,
 87185:             right:  alignRight ? window.innerWidth : rect.width
 87185:           };
 63295:         ]]></body>
 63295:       </method>
 63295: 
 61925:       <method name="_mirror">
 61925:         <body>
 61538:           if (this.hasAttribute("mirror"))
 61538:             this.removeAttribute("mirror");
 61538:           else
 61538:             this.setAttribute("mirror", "true");
 95243: 
 95243:           if (!this.hasAttribute("sizelimit")) {
 95243:             this.setAttribute("sizelimit", "true");
 95243:             this._calcMouseTargetRect();
 95243:           }
 61925:         </body>
 61925:       </method>
 61925:     </implementation>
 61538:   </binding>
 61538: 
  4891: </bindings>
