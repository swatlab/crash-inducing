    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sts=2 sw=2 et cin: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
26617:  *   Ere Maijala <emaijala@kolumbus.fi>
    1:  *   Mark Hammond <markh@activestate.com>
    1:  *   Michael Lowe <michael.lowe@bigfoot.com>
    1:  *   Peter Bajusz <hyp-x@inf.bme.hu>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Roy Yokoyama <yokoyama@netscape.com>
    1:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
    1:  *   Christian Biesinger <cbiesinger@web.de>
43018:  *   Mats Palmgren <matspal@gmail.com>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
29835:  *   Jim Mathies <jmathies@mozilla.com>
32183:  *   Kyle Huey <me@kylehuey.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
29835: /*
29841:  * nsWindow - Native window management and event handling.
29841:  * 
29835:  * nsWindow is organized into a set of major blocks and
29835:  * block subsections. The layout is as follows:
29835:  *
29835:  *  Includes
29835:  *  Variables
29835:  *  nsIWidget impl.
29835:  *     nsIWidget methods and utilities
29835:  *  nsSwitchToUIThread impl.
29835:  *     nsSwitchToUIThread methods and utilities
29835:  *  Moz events
29835:  *     Event initialization
29835:  *     Event dispatching
29835:  *  Native events
29835:  *     Wndproc(s)
29835:  *     Event processing
29835:  *     OnEvent event handlers
29835:  *  IME management and accessibility
29835:  *  Transparency
29835:  *  Popup hook handling
29835:  *  Misc. utilities
29835:  *  Child window impl.
29835:  *
29835:  * Search for "BLOCK:" to find major blocks.
29835:  * Search for "SECTION:" to find specific sections.
29835:  *
29835:  * Blocks should be split out into separate files if they
29835:  * become unmanageable.
29835:  *
29835:  * Related source:
29835:  *
29835:  *  nsWindowDefs.h     - Definitions, macros, structs, enums
29835:  *                       and general setup.
29835:  *  nsWindowDbg.h/.cpp - Debug related code and directives.
29835:  *  nsWindowGfx.h/.cpp - Graphics and painting.
29835:  *
29835:  */
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Includes
29835:  **
29835:  ** Include headers.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
38103: #include "mozilla/ipc/RPCChannel.h"
36056: 
80467: /* This must occur *after* ipc/RPCChannel.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsWindow.h"
29835: 
29835: #include <windows.h>
29835: #include <process.h>
29835: #include <commctrl.h>
29835: #include <unknwn.h>
90802: #include <psapi.h>
29835: 
29835: #include "prlog.h"
29835: #include "prtime.h"
29835: #include "prprf.h"
29835: #include "prmem.h"
29835: 
68748: #include "mozilla/WidgetTraceEvent.h"
    1: #include "nsIAppShell.h"
29835: #include "nsISupportsPrimitives.h"
77227: #include "nsIDOMMouseEvent.h"
29835: #include "nsITheme.h"
29835: #include "nsIObserverService.h"
29835: #include "nsIScreenManager.h"
29835: #include "imgIContainer.h"
29835: #include "nsIFile.h"
29835: #include "nsIRollupListener.h"
29835: #include "nsIServiceManager.h"
29835: #include "nsIClipboard.h"
29835: #include "nsIMM32Handler.h"
29835: #include "nsILocalFile.h"
68493: #include "nsFontMetrics.h"
    1: #include "nsIFontEnumerator.h"
29835: #include "nsGUIEvent.h"
    1: #include "nsFont.h"
    1: #include "nsRect.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNativeCharsetUtils.h"
80435: #include "nsGkAtoms.h"
14799: #include "nsUnicharUtils.h"
29835: #include "nsCRT.h"
29835: #include "nsAppDirectoryServiceDefs.h"
29835: #include "nsXPIDLString.h"
29835: #include "nsWidgetsCID.h"
30540: #include "nsTHashtable.h"
30540: #include "nsHashKeys.h"
32183: #include "nsString.h"
41540: #include "mozilla/Services.h"
49249: #include "nsNativeThemeWin.h"
57388: #include "nsWindowsDllInterceptor.h"
58814: #include "nsIWindowMediator.h"
58814: #include "nsIServiceManager.h"
29835: #include "nsWindowGfx.h"
38727: #include "gfxWindowsPlatform.h"
40028: #include "Layers.h"
77158: #include "nsPrintfCString.h"
70956: #include "mozilla/Preferences.h"
78043: #include "nsISound.h"
81361: #include "WinTaskbar.h"
86569: #include "WinUtils.h"
68855: 
43174: #ifdef MOZ_ENABLE_D3D9_LAYER
42612: #include "LayerManagerD3D9.h"
43174: #endif
68855: 
54816: #ifdef MOZ_ENABLE_D3D10_LAYER
54816: #include "LayerManagerD3D10.h"
54816: #endif
68855: 
42612: #include "LayerManagerOGL.h"
60833: #include "nsIGfxInfo.h"
50583: #include "BasicLayers.h"
26576: #include "nsUXThemeConstants.h"
48247: #include "KeyboardLayout.h"
23335: #include "nsNativeDragTarget.h"
29835: #include <mmsystem.h> // needed for WIN32_LEAN_AND_MEAN
29835: #include <zmouse.h>
31281: #include <richedit.h>
29835: 
29835: #if defined(ACCESSIBILITY)
31281: #include "oleidl.h"
 7756: #include <winuser.h>
47996: #include "nsIAccessibleDocument.h"
29835: #if !defined(WINABLEAPI)
 7756: #include <winable.h>
29835: #endif // !defined(WINABLEAPI)
29835: #endif // defined(ACCESSIBILITY)
29835: 
33486: #include "nsIWinTaskbar.h"
77693: #define NS_TASKBAR_CONTRACTID "@mozilla.org/windows-taskbar;1"
33486: 
29835: #if defined(NS_ENABLE_TSF)
29835: #include "nsTextStore.h"
29835: #endif // defined(NS_ENABLE_TSF)
29835: 
29835: // Windowless plugin support
32799: #include "npapi.h"
    1: 
29835: #include "nsWindowDefs.h"
29835: 
41343: #include "mozilla/FunctionTimer.h"
62476: #include "nsCrashOnException.h"
51658: #include "nsIXULRuntime.h"
51658: 
82052: #include "nsIContent.h"
82052: 
48247: using namespace mozilla::widget;
58633: using namespace mozilla::layers;
70956: using namespace mozilla;
48247: 
31122: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Variables
29835:  **
29835:  ** nsWindow Class static initializations and global variables. 
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsWindow statics
29835:  *
29835:  **************************************************************/
29835: 
79445: bool            nsWindow::sDropShadowEnabled      = true;
    1: PRUint32        nsWindow::sInstanceCount          = 0;
79445: bool            nsWindow::sSwitchKeyboardLayout   = false;
 7271: BOOL            nsWindow::sIsOleInitialized       = FALSE;
29835: HCURSOR         nsWindow::sHCursor                = NULL;
29835: imgIContainer*  nsWindow::sCursorImgContainer     = nsnull;
29835: nsWindow*       nsWindow::sCurrentWindow          = nsnull;
79445: bool            nsWindow::sJustGotDeactivate      = false;
79445: bool            nsWindow::sJustGotActivate        = false;
79445: bool            nsWindow::sIsInMouseCapture       = false;
29835: 
29835: // imported in nsWidgetFactory.cpp
29835: TriStateBool    nsWindow::sCanQuit                = TRI_UNKNOWN;
29835: 
29835: // Hook Data Memebers for Dropdowns. sProcessHook Tells the
29835: // hook methods whether they should be processing the hook
29835: // messages.
29835: HHOOK           nsWindow::sMsgFilterHook          = NULL;
29835: HHOOK           nsWindow::sCallProcHook           = NULL;
29835: HHOOK           nsWindow::sCallMouseHook          = NULL;
79445: bool            nsWindow::sProcessHook            = false;
29835: UINT            nsWindow::sRollupMsgId            = 0;
29835: HWND            nsWindow::sRollupMsgWnd           = NULL;
29835: UINT            nsWindow::sHookTimerId            = 0;
29835: 
29835: // Rollup Listener
29835: nsIRollupListener* nsWindow::sRollupListener      = nsnull;
29835: nsIWidget*      nsWindow::sRollupWidget           = nsnull;
79445: bool            nsWindow::sRollupConsumeEvent     = false;
29835: 
29835: // Mouse Clicks - static variable definitions for figuring
29835: // out 1 - 3 Clicks.
29835: POINT           nsWindow::sLastMousePoint         = {0};
29835: POINT           nsWindow::sLastMouseMovePoint     = {0};
29835: LONG            nsWindow::sLastMouseDownTime      = 0L;
29835: LONG            nsWindow::sLastClickCount         = 0L;
29835: BYTE            nsWindow::sLastMouseButton        = 0;
29835: 
29835: // Trim heap on minimize. (initialized, but still true.)
29835: int             nsWindow::sTrimOnMinimize         = 2;
    1: 
57092: // Default value for Trackpoint hack (used when the pref is set to -1).
79445: bool            nsWindow::sDefaultTrackPointHack  = false;
57092: // Default value for general window class (used when the pref is the empty string).
57092: const char*     nsWindow::sDefaultMainWindowClass = kClassNameGeneral;
72254: // Whether to enable the Elantech swipe gesture hack.
79445: bool            nsWindow::sUseElantechSwipeHack  = false;
72254: // Whether to enable the Elantech pinch-to-zoom gesture hack.
79445: bool            nsWindow::sUseElantechPinchHack  = false;
57092: 
58814: // If we're using D3D9, this will not be allowed during initial 5 seconds.
58814: bool            nsWindow::sAllowD3D9              = false;
33529: 
63258: TriStateBool nsWindow::sHasBogusPopupsDropShadowOnMultiMonitor = TRI_UNKNOWN;
63258: 
37550: // Used in OOPP plugin focus processing.
37550: const PRUnichar* kOOPPPluginFocusEventId   = L"OOPP Plugin Focus Widget Event";
37550: PRUint32        nsWindow::sOOPPPluginFocusEvent   =
37550:                   RegisterWindowMessageW(kOOPPPluginFocusEventId);
37550: 
60495: MSG             nsWindow::sRedirectedKeyDown;
60495: 
79445: bool            nsWindow::sEnablePixelScrolling = true;
79445: bool            nsWindow::sNeedsToInitMouseWheelSettings = true;
69947: ULONG           nsWindow::sMouseWheelScrollLines  = 0;
69947: ULONG           nsWindow::sMouseWheelScrollChars  = 0;
69947: 
69947: HWND            nsWindow::sLastMouseWheelWnd = NULL;
69947: PRInt32         nsWindow::sRemainingDeltaForScroll = 0;
69947: PRInt32         nsWindow::sRemainingDeltaForPixel = 0;
79445: bool            nsWindow::sLastMouseWheelDeltaIsPositive = false;
79445: bool            nsWindow::sLastMouseWheelOrientationIsVertical = false;
79445: bool            nsWindow::sLastMouseWheelUnitIsPage = false;
69947: PRUint32        nsWindow::sLastMouseWheelTime = 0;
69947: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: globals variables
29835:  *
29835:  **************************************************************/
29835: 
29835: static const char *sScreenManagerContractID       = "@mozilla.org/gfx/screenmanager;1";
29835: 
29835: #ifdef PR_LOGGING
29835: PRLogModuleInfo* gWindowsLog                      = nsnull;
    1: #endif
29835: 
29835: // Kbd layout. Used throughout character processing.
48050: static KeyboardLayout gKbdLayout;
31985: 
29835: // Global user preference for disabling native theme. Used
29835: // in NativeWindowTheme.
79445: bool            gDisableNativeTheme               = false;
29835: 
29835: // Global used in Show window enumerations.
79445: static bool     gWindowsVisible                   = false;
29835: 
82031: // True if we have sent a notification that we are suspending/sleeping.
82031: static bool     gIsSleepMode                      = false;
82031: 
29835: static NS_DEFINE_CID(kCClipboardCID, NS_CLIPBOARD_CID);
29835: 
57388: // General purpose user32.dll hook object
57388: static WindowsDllInterceptor sUser32Intercept;
57388: 
87238: // 2 pixel offset for eTransparencyBorderlessGlass which equals the size of
87238: // the default window border Windows paints. Glass will be extended inward
87238: // this distance to remove the border.
61413: static const PRInt32 kGlassMarginAdjustment = 2;
61413: 
87238: // When the client area is extended out into the default window frame area,
87238: // this is the minimum amount of space along the edge of resizable windows
87238: // we will always display a resize cursor in, regardless of the underlying
87238: // content.
87238: static const PRInt32 kResizableBorderMinSize = 3;
79695: 
79695: // We should never really try to accelerate windows bigger than this. In some
79695: // cases this might lead to no D3D9 acceleration where we could have had it
79695: // but D3D9 does not reliably report when it supports bigger windows. 8192
79695: // is as safe as we can get, we know at least D3D10 hardware always supports
79695: // this, other hardware we expect to report correctly in D3D9.
79695: #define MAX_ACCELERATED_DIMENSION 8192
79695: 
79695: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: nsIWidget impl.
29835:  **
29835:  ** nsIWidget interface implementation, broken down into
29835:  ** sections.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsWindow construction and destruction
29835:  *
29835:  **************************************************************/
29835: 
29835: nsWindow::nsWindow() : nsBaseWidget()
29835: {
29835: #ifdef PR_LOGGING
76714:   if (!gWindowsLog) {
76714:     gWindowsLog = PR_NewLogModule("nsWindow");
76714:   }
    1: #endif
    1: 
29835:   mWnd                  = nsnull;
29835:   mPaintDC              = nsnull;
29835:   mPrevWndProc          = nsnull;
29835:   mNativeDragTarget     = nsnull;
79626:   mInDtor               = false;
79626:   mIsVisible            = false;
79626:   mIsTopWidgetWindow    = false;
79626:   mUnicodeWidget        = true;
79626:   mDisplayPanFeedback   = false;
79626:   mTouchWindow          = false;
79626:   mCustomNonClient      = false;
79626:   mHideChrome           = false;
79626:   mFullscreenMode       = false;
79626:   mMousePresent         = false;
84178:   mDestroyCalled        = false;
84178:   mPickerDisplayCount   = 0;
29835:   mWindowType           = eWindowType_child;
29835:   mBorderStyle          = eBorderStyle_default;
29835:   mPopupType            = ePopupTypeAny;
46335:   mOldSizeMode          = nsSizeMode_Normal;
    1:   mLastPoint.x          = 0;
    1:   mLastPoint.y          = 0;
    1:   mLastSize.width       = 0;
    1:   mLastSize.height      = 0;
    1:   mOldStyle             = 0;
    1:   mOldExStyle           = 0;
    1:   mPainting             = 0;
29835:   mLastKeyboardLayout   = 0;
62480:   mAssumeWheelIsZoomUntil = 0;
29835:   mBlurSuppressLevel    = 0;
89510:   mLastPaintEndTime     = TimeStamp::Now();
29835: #ifdef MOZ_XUL
29835:   mTransparentSurface   = nsnull;
29835:   mMemoryDC             = nsnull;
29835:   mTransparencyMode     = eTransparencyOpaque;
39718:   memset(&mGlassMargins, 0, sizeof mGlassMargins);
29835: #endif
29835:   mBackground           = ::GetSysColor(COLOR_BTNFACE);
29835:   mBrush                = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
29835:   mForeground           = ::GetSysColor(COLOR_WINDOWTEXT);
29835: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486:   mTaskbarPreview = nsnull;
79626:   mHasTaskbarIconBeenCreated = false;
33486: #endif
33486: 
29835:   // Global initialization
29835:   if (!sInstanceCount) {
81361: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
81361:     // Global app registration id for Win7 and up. See
81361:     // WinTaskbar.cpp for details.
81361:     mozilla::widget::WinTaskbar::RegisterAppUserModelID();
81361: #endif
81361: 
22411:     gKbdLayout.LoadLayout(::GetKeyboardLayout(0));
29835: 
29835:     // Init IME handler
27961:     nsIMM32Handler::Initialize();
    1: 
24836: #ifdef NS_ENABLE_TSF
24836:     nsTextStore::Initialize();
29835: #endif
29835: 
29835:     if (SUCCEEDED(::OleInitialize(NULL)))
 7271:       sIsOleInitialized = TRUE;
 7271:     NS_ASSERTION(sIsOleInitialized, "***** OLE is not initialized!\n");
68855: 
62477:     InitInputWorkaroundPrefDefaults();
49249: 
49249:     // Init titlebar button info for custom frames.
49249:     nsUXThemeData::InitTitlebarInfo();
55268:     // Init theme data
55268:     nsUXThemeData::UpdateNativeThemeInfo();
60495: 
60495:     ForgetRedirectedKeyDownMessage();
29835:   } // !sInstanceCount
29835: 
40944:   mIdleService = nsnull;
27326: 
    1:   sInstanceCount++;
23335: }
23335: 
    1: nsWindow::~nsWindow()
    1: {
79626:   mInDtor = true;
30223: 
30223:   // If the widget was released without calling Destroy() then the native window still
30223:   // exists, and we need to destroy it. This will also result in a call to OnDestroy.
30223:   //
30223:   // XXX How could this happen???
30223:   if (NULL != mWnd)
    1:     Destroy();
    1: 
24836:   sInstanceCount--;
24836: 
29835:   // Global shutdown
29841:   if (sInstanceCount == 0) {
24836: #ifdef NS_ENABLE_TSF
24836:     nsTextStore::Terminate();
29835: #endif
29835:     NS_IF_RELEASE(sCursorImgContainer);
 7271:     if (sIsOleInitialized) {
 7968:       ::OleFlushClipboard();
 7271:       ::OleUninitialize();
 7271:       sIsOleInitialized = FALSE;
 7271:     }
29835:     // delete any of the IME structures that we allocated
27961:     nsIMM32Handler::Terminate();
68855:   }
68855: 
    1:   NS_IF_RELEASE(mNativeDragTarget);
29835: }
29835: 
29835: NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Create, nsIWidget::Destroy
29835:  *
29835:  * Creating and destroying windows for this widget.
29835:  *
29835:  **************************************************************/
29835: 
33013: // Allow Derived classes to modify the height that is passed
68855: // when the window is created or resized.
33013: PRInt32 nsWindow::GetHeight(PRInt32 aProposedHeight)
33013: {
68855:   return aProposedHeight;
33013: }
33013: 
29835: // Create the proper widget
33013: nsresult
33013: nsWindow::Create(nsIWidget *aParent,
33013:                  nsNativeWidget aNativeParent,
29835:                  const nsIntRect &aRect,
29835:                  EVENT_CALLBACK aHandleEventFunction,
68668:                  nsDeviceContext *aContext,
29835:                  nsWidgetInitData *aInitData)
29835: {
51041:   nsWidgetInitData defaultInitData;
51041:   if (!aInitData)
51041:     aInitData = &defaultInitData;
51041: 
29835:   mUnicodeWidget = aInitData->mUnicode;
33013: 
51041:   nsIWidget *baseParent = aInitData->mWindowType == eWindowType_dialog ||
    1:                           aInitData->mWindowType == eWindowType_toplevel ||
51041:                           aInitData->mWindowType == eWindowType_invisible ?
    1:                           nsnull : aParent;
    1: 
    1:   mIsTopWidgetWindow = (nsnull == baseParent);
55224:   mBounds = aRect;
    1: 
80842:   // Ensure that the toolkit is created.
80842:   nsToolkit::GetToolkit();
80842: 
80842:   BaseCreate(baseParent, aRect, aHandleEventFunction, aContext, aInitData);
    1: 
    1:   HWND parent;
43018:   if (aParent) { // has a nsIWidget parent
43018:     parent = aParent ? (HWND)aParent->GetNativeData(NS_NATIVE_WINDOW) : NULL;
43018:     mParent = aParent;
    1:   } else { // has a nsNative parent
    1:     parent = (HWND)aNativeParent;
86569:     mParent = aNativeParent ?
86569:       WinUtils::GetNSWindowPtr((HWND)aNativeParent) : nsnull;
    1:   }
    1: 
26576:   mPopupType = aInitData->mPopupHint;
51919:   mIsRTL = aInitData->mRTL;
    1: 
    1:   DWORD style = WindowStyle();
    1:   DWORD extendedStyle = WindowExStyle();
    1: 
    1:   if (mWindowType == eWindowType_popup) {
48254:     if (!aParent)
 8587:       parent = NULL;
77050: 
77050:     if (aInitData->mIsDragPopup) {
77050:       // This flag makes the window transparent to mouse events
77050:       extendedStyle |= WS_EX_TRANSPARENT;
77050:     }
31952:   } else if (mWindowType == eWindowType_invisible) {
31952:     // Make sure CreateWindowEx succeeds at creating a toplevel window
31960:     style &= ~0x40000000; // WS_CHILDWINDOW
51041:   } else {
    1:     // See if the caller wants to explictly set clip children and clip siblings
    1:     if (aInitData->clipChildren) {
    1:       style |= WS_CLIPCHILDREN;
    1:     } else {
    1:       style &= ~WS_CLIPCHILDREN;
    1:     }
    1:     if (aInitData->clipSiblings) {
    1:       style |= WS_CLIPSIBLINGS;
    1:     }
    1:   }
    1: 
57092:   nsAutoString className;
57092:   if (aInitData->mDropShadow) {
57092:     GetWindowPopupClass(className);
57092:   } else {
57092:     GetWindowClass(className);
57092:   }
77660:   // Plugins are created in the disabled state so that they can't
77660:   // steal focus away from our main window.  This is especially
77660:   // important if the plugin has loaded in a background tab.
77660:   if(aInitData->mWindowType == eWindowType_plugin) {
77660:     style |= WS_DISABLED;
77660:   }
    1:   mWnd = ::CreateWindowExW(extendedStyle,
57092:                            className.get(),
    1:                            L"",
    1:                            style,
    1:                            aRect.x,
    1:                            aRect.y,
    1:                            aRect.width,
    1:                            GetHeight(aRect.height),
    1:                            parent,
    1:                            NULL,
    1:                            nsToolkit::mDllInstance,
    1:                            NULL);
    1: 
46192:   if (!mWnd) {
46192:     NS_WARNING("nsWindow CreateWindowEx failed.");
    1:     return NS_ERROR_FAILURE;
46192:   }
    1: 
52118:   if (mIsRTL && nsUXThemeData::dwmSetWindowAttributePtr) {
52118:     DWORD dwAttribute = TRUE;    
52118:     nsUXThemeData::dwmSetWindowAttributePtr(mWnd, DWMWA_NONCLIENT_RTL_LAYOUT, &dwAttribute, sizeof dwAttribute);
52118:   }
52118: 
57092:   if (mWindowType != eWindowType_plugin &&
57092:       mWindowType != eWindowType_invisible &&
57092:       UseTrackPointHack()) {
59750:     // Ugly Thinkpad Driver Hack (Bugs 507222 and 594977)
59750:     //
59750:     // We create two zero-sized windows as descendants of the top-level window,
59750:     // like so:
59750:     //
59750:     //   Top-level window (MozillaWindowClass)
59750:     //     FAKETRACKPOINTSCROLLCONTAINER (MozillaWindowClass)
59750:     //       FAKETRACKPOINTSCROLLABLE (MozillaWindowClass)
59750:     //
59750:     // We need to have the middle window, otherwise the Trackpoint driver
59750:     // will fail to deliver scroll messages.  WM_MOUSEWHEEL messages are
59750:     // sent to the FAKETRACKPOINTSCROLLABLE, which then propagate up the
59750:     // window hierarchy until they are handled by nsWindow::WindowProc.
59750:     // WM_HSCROLL messages are also sent to the FAKETRACKPOINTSCROLLABLE,
59750:     // but these do not propagate automatically, so we have the window
59750:     // procedure pretend that they were dispatched to the top-level window
59750:     // instead.
59750:     //
59750:     // The FAKETRACKPOINTSCROLLABLE needs to have the specific window styles it
59750:     // is given below so that it catches the Trackpoint driver's heuristics.
59750:     HWND scrollContainerWnd = ::CreateWindowW
59750:       (className.get(), L"FAKETRACKPOINTSCROLLCONTAINER",
59750:        WS_CHILD | WS_VISIBLE,
59750:        0, 0, 0, 0, mWnd, NULL, nsToolkit::mDllInstance, NULL);
59750:     HWND scrollableWnd = ::CreateWindowW
59750:       (className.get(), L"FAKETRACKPOINTSCROLLABLE",
59750:        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP | 0x30,
59750:        0, 0, 0, 0, scrollContainerWnd, NULL, nsToolkit::mDllInstance, NULL);
59750: 
59750:     // Give the FAKETRACKPOINTSCROLLABLE window a specific ID so that
59750:     // WindowProcInternal can distinguish it from the top-level window
59750:     // easily.
59750:     ::SetWindowLongPtrW(scrollableWnd, GWLP_ID, eFakeTrackPointScrollableID);
59750: 
59750:     // Make FAKETRACKPOINTSCROLLABLE use nsWindow::WindowProc, and store the
59750:     // old window procedure in its "user data".
59750:     WNDPROC oldWndProc;
59750:     if (mUnicodeWidget)
59750:       oldWndProc = (WNDPROC)::SetWindowLongPtrW(scrollableWnd, GWLP_WNDPROC,
59750:                                                 (LONG_PTR)nsWindow::WindowProc);
59750:     else
59750:       oldWndProc = (WNDPROC)::SetWindowLongPtrA(scrollableWnd, GWLP_WNDPROC,
59750:                                                 (LONG_PTR)nsWindow::WindowProc);
59750:     ::SetWindowLongPtrW(scrollableWnd, GWLP_USERDATA, (LONG_PTR)oldWndProc);
33357:   }
32183: 
    1:   // call the event callback to notify about creation
    1: 
    1:   DispatchStandardEvent(NS_CREATE);
    1:   SubclassWindow(TRUE);
    1: 
70972:   // If the internal variable set by the config.trim_on_minimize pref has not
70972:   // been initialized, and if this is the hidden window (conveniently created
70972:   // before any visible windows, and after the profile has been initialized),
70972:   // do some initialization work.
29835:   if (sTrimOnMinimize == 2 && mWindowType == eWindowType_invisible) {
70972:     // Our internal trim prevention logic is effective on 2K/XP at maintaining
70972:     // the working set when windows are minimized, but on Vista and up it has
70972:     // little to no effect. Since this feature has been the source of numerous
70972:     // bugs over the years, disable it (sTrimOnMinimize=1) on Vista and up.
70956:     sTrimOnMinimize =
70972:       Preferences::GetBool("config.trim_on_minimize",
86569:         (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION)) ? 1 : 0;
70956:     sSwitchKeyboardLayout =
79445:       Preferences::GetBool("intl.keyboard.per_window_layout", false);
70956:     gDisableNativeTheme =
79445:       Preferences::GetBool("mozilla.widget.disable-native-theme", false);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
30223: // Close this nsWindow
30223: NS_METHOD nsWindow::Destroy()
30223: {
77212:   // WM_DESTROY has already fired, avoid calling it twice
77212:   if (mOnDestroyCalled)
30223:     return NS_OK;
30223: 
84178:   // Don't destroy windows that have file pickers open, we'll tear these down
84178:   // later once the picker is closed.
84178:   mDestroyCalled = true;
84178:   if (mPickerDisplayCount)
84178:     return NS_OK;
84178: 
30223:   // During the destruction of all of our children, make sure we don't get deleted.
30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
30223: 
40028:   /**
40028:    * On windows the LayerManagerOGL destructor wants the widget to be around for
40028:    * cleanup. It also would like to have the HWND intact, so we NULL it here.
40028:    */
49074:   if (mLayerManager) {
49074:     mLayerManager->Destroy();
49074:   }
49074:   mLayerManager = nsnull;
40028: 
51000:   /* We should clear our cached resources now and not wait for the GC to
50777:    * delete the nsWindow. */
51000:   ClearCachedResources();
50777: 
30223:   // The DestroyWindow function destroys the specified window. The function sends WM_DESTROY
30223:   // and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus
30223:   // from it. The function also destroys the window's menu, flushes the thread message queue,
30223:   // destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if
30223:   // the window is at the top of the viewer chain).
30223:   //
30223:   // If the specified window is a parent or owner window, DestroyWindow automatically destroys
30223:   // the associated child or owned windows when it destroys the parent or owner window. The
30223:   // function first destroys child or owned windows, and then it destroys the parent or owner
30223:   // window.
30223:   VERIFY(::DestroyWindow(mWnd));
30223:   
30223:   // Our windows can be subclassed which may prevent us receiving WM_DESTROY. If OnDestroy()
30223:   // didn't get called, call it now.
79626:   if (false == mOnDestroyCalled) {
58032:     LRESULT result;
58032:     mWindowHook.Notify(mWnd, WM_DESTROY, 0, 0, &result);
30223:     OnDestroy();
58032:   }
30223: 
30223:   return NS_OK;
30223: }
30223: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window class utilities
29835:  *
29835:  * Utilities for calculating the proper window class name for
29835:  * Create window.
29835:  *
29835:  **************************************************************/
29835: 
57092: void nsWindow::RegisterWindowClass(const nsString& aClassName, UINT aExtraStyle,
57092:                                    LPWSTR aIconID)
57092: {
29835:   WNDCLASSW wc;
57092:   if (::GetClassInfoW(nsToolkit::mDllInstance, aClassName.get(), &wc)) {
57092:     // already registered
57092:     return;
57092:   }
57092: 
57092:   wc.style         = CS_DBLCLKS | aExtraStyle;
29835:   wc.lpfnWndProc   = ::DefWindowProcW;
29835:   wc.cbClsExtra    = 0;
29835:   wc.cbWndExtra    = 0;
29835:   wc.hInstance     = nsToolkit::mDllInstance;
57092:   wc.hIcon         = aIconID ? ::LoadIconW(::GetModuleHandleW(NULL), aIconID) : NULL;
29835:   wc.hCursor       = NULL;
29835:   wc.hbrBackground = mBrush;
29835:   wc.lpszMenuName  = NULL;
57092:   wc.lpszClassName = aClassName.get();
57092: 
57092:   if (!::RegisterClassW(&wc)) {
57092:     // For older versions of Win32 (i.e., not XP), the registration may
57092:     // fail with aExtraStyle, so we have to re-register without it.
57092:     wc.style = CS_DBLCLKS;
57092:     ::RegisterClassW(&wc);
57092:   }
57092: }
57092: 
57103: static LPWSTR const gStockApplicationIcon = MAKEINTRESOURCEW(32512);
57103: 
57092: // Return the proper window class for everything except popups.
57092: void nsWindow::GetWindowClass(nsString& aWindowClass)
57092: {
57092:   switch (mWindowType) {
57092:   case eWindowType_invisible:
57092:     aWindowClass.AssignLiteral(kClassNameHidden);
57103:     RegisterWindowClass(aWindowClass, 0, gStockApplicationIcon);
57092:     break;
57092:   case eWindowType_dialog:
57092:     aWindowClass.AssignLiteral(kClassNameDialog);
57092:     RegisterWindowClass(aWindowClass, 0, 0);
57092:     break;
57092:   default:
57092:     GetMainWindowClass(aWindowClass);
57103:     RegisterWindowClass(aWindowClass, 0, gStockApplicationIcon);
57092:     break;
57092:   }
29835: }
29835: 
29835: // Return the proper popup window class
57092: void nsWindow::GetWindowPopupClass(nsString& aWindowClass)
57092: {
57092:   aWindowClass.AssignLiteral(kClassNameDropShadow);
57103:   RegisterWindowClass(aWindowClass, CS_XP_DROPSHADOW, gStockApplicationIcon);
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window styles utilities
29835:  *
29835:  * Return the proper windows styles and extended styles.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Return nsWindow styles
29835: DWORD nsWindow::WindowStyle()
29835: {
29835:   DWORD style;
29835: 
29835:   switch (mWindowType) {
33357:     case eWindowType_plugin:
29835:     case eWindowType_child:
29835:       style = WS_OVERLAPPED;
29835:       break;
29835: 
29835:     case eWindowType_dialog:
46264:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU | DS_3DLOOK |
46264:               DS_MODALFRAME | WS_CLIPCHILDREN;
29835:       if (mBorderStyle != eBorderStyle_default)
29835:         style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
29835:       break;
29835: 
29835:     case eWindowType_popup:
29835:       style = WS_POPUP;
50770:       if (!HasGlass()) {
29835:         style |= WS_OVERLAPPED;
29835:       }
29835:       break;
29835: 
29835:     default:
31561:       NS_ERROR("unknown border style");
29835:       // fall through
29835: 
29835:     case eWindowType_toplevel:
29835:     case eWindowType_invisible:
29835:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU |
46264:               WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN;
29835:       break;
29835:   }
29835: 
31589:   if (mBorderStyle != eBorderStyle_default && mBorderStyle != eBorderStyle_all) {
31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_border))
31589:       style &= ~WS_BORDER;
31589: 
31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_title)) {
31589:       style &= ~WS_DLGFRAME;
31589:       style |= WS_POPUP;
31589:       style &= ~WS_CHILD;
31589:     }
31589: 
31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_close))
31589:       style &= ~0;
31589:     // XXX The close box can only be removed by changing the window class,
31589:     // as far as I know   --- roc+moz@cs.cmu.edu
31589: 
31589:     if (mBorderStyle == eBorderStyle_none ||
31589:       !(mBorderStyle & (eBorderStyle_menu | eBorderStyle_close)))
31589:       style &= ~WS_SYSMENU;
31589:     // Looks like getting rid of the system menu also does away with the
31589:     // close box. So, we only get rid of the system menu if you want neither it
31589:     // nor the close box. How does the Windows "Dialog" window class get just
31589:     // closebox and no sysmenu? Who knows.
31589: 
31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_resizeh))
31589:       style &= ~WS_THICKFRAME;
31589: 
31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_minimize))
31589:       style &= ~WS_MINIMIZEBOX;
31589: 
31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_maximize))
31589:       style &= ~WS_MAXIMIZEBOX;
48256: 
48256:     if (IsPopupWithTitleBar()) {
48256:       style |= WS_CAPTION;
48261:       if (mBorderStyle & eBorderStyle_close) {
48261:         style |= WS_SYSMENU;
48261:       }
48256:     }
48256:   }
48256: 
29835:   VERIFY_WINDOW_STYLE(style);
29835:   return style;
29835: }
29835: 
29835: // Return nsWindow extended styles
29835: DWORD nsWindow::WindowExStyle()
29835: {
29835:   switch (mWindowType)
29835:   {
33357:     case eWindowType_plugin:
29835:     case eWindowType_child:
29835:       return 0;
29835: 
29835:     case eWindowType_dialog:
29835:       return WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
29835: 
29835:     case eWindowType_popup:
48254:     {
68855:       DWORD extendedStyle = WS_EX_TOOLWINDOW;
48254:       if (mPopupLevel == ePopupLevelTop)
48254:         extendedStyle |= WS_EX_TOPMOST;
48254:       return extendedStyle;
48254:     }
29835:     default:
31561:       NS_ERROR("unknown border style");
29835:       // fall through
29835: 
29835:     case eWindowType_toplevel:
29835:     case eWindowType_invisible:
29835:       return WS_EX_WINDOWEDGE;
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window subclassing utilities
29835:  *
29835:  * Set or clear window subclasses on native windows. Used in
29835:  * Create and Destroy.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Subclass (or remove the subclass from) this component's nsWindow
29835: void nsWindow::SubclassWindow(BOOL bState)
29835: {
29835:   if (NULL != mWnd) {
33486:     //NS_PRECONDITION(::IsWindow(mWnd), "Invalid window handle");
33486:     if (!::IsWindow(mWnd)) {
33486:       NS_ERROR("Invalid window handle");
33486:     }
29835: 
29835:     if (bState) {
29835:       // change the nsWindow proc
29835:       if (mUnicodeWidget)
29835:         mPrevWndProc = (WNDPROC)::SetWindowLongPtrW(mWnd, GWLP_WNDPROC,
29835:                                                 (LONG_PTR)nsWindow::WindowProc);
29835:       else
29835:         mPrevWndProc = (WNDPROC)::SetWindowLongPtrA(mWnd, GWLP_WNDPROC,
29835:                                                 (LONG_PTR)nsWindow::WindowProc);
29835:       NS_ASSERTION(mPrevWndProc, "Null standard window procedure");
29835:       // connect the this pointer to the nsWindow handle
86569:       WinUtils::SetNSWindowPtr(mWnd, this);
29835:     }
29835:     else {
29835:       if (mUnicodeWidget)
29835:         ::SetWindowLongPtrW(mWnd, GWLP_WNDPROC, (LONG_PTR)mPrevWndProc);
29835:       else
29835:         ::SetWindowLongPtrA(mWnd, GWLP_WNDPROC, (LONG_PTR)mPrevWndProc);
86569:       WinUtils::SetNSWindowPtr(mWnd, NULL);
29835:       mPrevWndProc = NULL;
29835:     }
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetParent, nsIWidget::GetParent
29835:  *
29835:  * Set or clear the parent widgets using window properties, and
29835:  * handles calculating native parent handles.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Get and set parent widgets
    1: NS_IMETHODIMP nsWindow::SetParent(nsIWidget *aNewParent)
    1: {
43018:   mParent = aNewParent;
43018: 
 3419:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 3419:   nsIWidget* parent = GetParent();
 3419:   if (parent) {
 3419:     parent->RemoveChild(this);
 3419:   }
54312:   if (aNewParent) {
54312:     ReparentNativeWidget(aNewParent);
54312:     aNewParent->AddChild(this);
54312:     return NS_OK;
54312:   }
54312:   if (mWnd) {
54312:     // If we have no parent, SetParent should return the desktop.
54312:     VERIFY(::SetParent(mWnd, nsnull));
54312:   }
54312:   return NS_OK;
54312: }
54312: 
54312: NS_IMETHODIMP
54312: nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
54312: {
54312:   NS_PRECONDITION(aNewParent, "");
54312: 
54312:   mParent = aNewParent;
54312:   if (mWindowType == eWindowType_popup) {
54312:     return NS_OK;
54312:   }
    1:   HWND newParent = (HWND)aNewParent->GetNativeData(NS_NATIVE_WINDOW);
    1:   NS_ASSERTION(newParent, "Parent widget has a null native window handle");
 3419:   if (newParent && mWnd) {
    1:     ::SetParent(mWnd, newParent);
 3419:   }
 4577:   return NS_OK;
    1: }
    1: 
    1: nsIWidget* nsWindow::GetParent(void)
    1: {
79626:   return GetParentWindow(false);
27505: }
27505: 
50783: float nsWindow::GetDPI()
50783: {
50783:   HDC dc = ::GetDC(mWnd);
50783:   if (!dc)
50783:     return 96.0f;
50783: 
50784:   double heightInches = ::GetDeviceCaps(dc, VERTSIZE)/MM_PER_INCH_FLOAT;
50783:   int heightPx = ::GetDeviceCaps(dc, VERTRES);
50783:   ::ReleaseDC(mWnd, dc);
50783:   if (heightInches < 0.25) {
50783:     // Something's broken
50783:     return 96.0f;
50783:   }
50783:   return float(heightPx/heightInches);
50783: }
50783: 
79445: nsWindow* nsWindow::GetParentWindow(bool aIncludeOwner)
19016: {
19016:   if (mIsTopWidgetWindow) {
    1:     // Must use a flag instead of mWindowType to tell if the window is the
    1:     // owned by the topmost widget, because a child window can be embedded inside
    1:     // a HWND which is not associated with a nsIWidget.
    1:     return nsnull;
    1:   }
19016: 
    1:   // If this widget has already been destroyed, pretend we have no parent.
    1:   // This corresponds to code in Destroy which removes the destroyed
    1:   // widget from its parent's child list.
30223:   if (mInDtor || mOnDestroyCalled)
    1:     return nsnull;
    1: 
27505: 
27505:   // aIncludeOwner set to true implies walking the parent chain to retrieve the
27505:   // root owner. aIncludeOwner set to false implies the search will stop at the
27505:   // true parent (default).
    1:   nsWindow* widget = nsnull;
    1:   if (mWnd) {
27505:     HWND parent = nsnull;
27505:     if (aIncludeOwner)
27505:       parent = ::GetParent(mWnd);
27505:     else
27505:       parent = ::GetAncestor(mWnd, GA_PARENT);
68855: 
    1:     if (parent) {
86569:       widget = WinUtils::GetNSWindowPtr(parent);
    1:       if (widget) {
    1:         // If the widget is in the process of being destroyed then
    1:         // do NOT return it
30223:         if (widget->mInDtor) {
    1:           widget = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return widget;
    1: }
    1:  
58811: BOOL CALLBACK
58811: nsWindow::EnumAllChildWindProc(HWND aWnd, LPARAM aParam)
58811: {
86569:   nsWindow *wnd = WinUtils::GetNSWindowPtr(aWnd);
58811:   if (wnd) {
58811:     ((nsWindow::WindowEnumCallback*)aParam)(wnd);
58811:   }
58811:   return TRUE;
58811: }
58811: 
58811: BOOL CALLBACK
58811: nsWindow::EnumAllThreadWindowProc(HWND aWnd, LPARAM aParam)
58811: {
86569:   nsWindow *wnd = WinUtils::GetNSWindowPtr(aWnd);
58811:   if (wnd) {
58811:     ((nsWindow::WindowEnumCallback*)aParam)(wnd);
58811:   }
58811:   EnumChildWindows(aWnd, EnumAllChildWindProc, aParam);
58811:   return TRUE;
58811: }
58811: 
58811: void
58811: nsWindow::EnumAllWindows(WindowEnumCallback aCallback)
58811: {
58811:   EnumThreadWindows(GetCurrentThreadId(),
58811:                     EnumAllThreadWindowProc,
61524:                     (LPARAM)aCallback);
58811: }
58811: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Show
29835:  *
29835:  * Hide or show this component.
29835:  *
29835:  **************************************************************/
    1: 
79445: NS_METHOD nsWindow::Show(bool bState)
    1: {
62852:   if (mWindowType == eWindowType_popup) {
63258:     // See bug 603793. When we try to draw D3D9/10 windows with a drop shadow
62852:     // without the DWM on a secondary monitor, windows fails to composite
62852:     // our windows correctly. We therefor switch off the drop shadow for
62852:     // pop-up windows when the DWM is disabled and two monitors are
62852:     // connected.
63258:     if (HasBogusPopupsDropShadowOnMultiMonitor() &&
86569:         WinUtils::GetMonitorCount() > 1 &&
62852:         !nsUXThemeData::CheckForCompositor())
62852:     {
62852:       if (sDropShadowEnabled) {
62852:         ::SetClassLongA(mWnd, GCL_STYLE, 0);
79626:         sDropShadowEnabled = false;
62852:       }
62852:     } else {
62852:       if (!sDropShadowEnabled) {
62852:         ::SetClassLongA(mWnd, GCL_STYLE, CS_DROPSHADOW);
79626:         sDropShadowEnabled = true;
62852:       }
62852:     }
62852:   }
62852: 
41343: #ifdef NS_FUNCTION_TIMER
41343:   static bool firstShow = true;
41343:   if (firstShow &&
41343:       (mWindowType == eWindowType_toplevel ||
41343:        mWindowType == eWindowType_dialog ||
41343:        mWindowType == eWindowType_popup))
41343:   {
41343:     firstShow = false;
42480:     mozilla::FunctionTimer::LogMessage("@ First toplevel/dialog/popup showing");
41343:   }
41343: #endif
41343: 
79445:   bool syncInvalidate = false;
79445: 
79445:   bool wasVisible = mIsVisible;
16326:   // Set the status now so that anyone asking during ShowWindow or
16326:   // SetWindowPos would get the correct answer.
16326:   mIsVisible = bState;
16326: 
62612:   // We may have cached an out of date visible state. This can happen
62612:   // when session restore sets the full screen mode.
62612:   if (mIsVisible)
62612:     mOldStyle |= WS_VISIBLE;
62612:   else
62612:     mOldStyle &= ~WS_VISIBLE;
62612: 
50583:   if (!mIsVisible && wasVisible) {
51000:       ClearCachedResources();
51000:   }
50583: 
    1:   if (mWnd) {
    1:     if (bState) {
16326:       if (!wasVisible && mWindowType == eWindowType_toplevel) {
62274:         // speed up the initial paint after show for
62274:         // top level windows:
79626:         syncInvalidate = true;
    1:         switch (mSizeMode) {
64173:           case nsSizeMode_Fullscreen:
64173:             ::ShowWindow(mWnd, SW_SHOW);
64173:             break;
24970:           case nsSizeMode_Maximized :
24970:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
24970:             break;
    1:           case nsSizeMode_Minimized :
    1:             ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
24795:             break;
    1:           default:
    1:             if (CanTakeFocus()) {
24795:               ::ShowWindow(mWnd, SW_SHOWNORMAL);
    1:             } else {
    1:               // Place the window behind the foreground window
    1:               // (as long as it is not topmost)
    1:               HWND wndAfter = ::GetForegroundWindow();
    1:               if (!wndAfter)
    1:                 wndAfter = HWND_BOTTOM;
25349:               else if (GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST)
    1:                 wndAfter = HWND_TOP;
    1:               ::SetWindowPos(mWnd, wndAfter, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE | 
    1:                              SWP_NOMOVE | SWP_NOACTIVATE);
    1:               GetAttention(2);
    1:             }
23335:             break;
    1:         }
    1:       } else {
    1:         DWORD flags = SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW;
16326:         if (wasVisible)
    1:           flags |= SWP_NOZORDER;
    1: 
    1:         if (mWindowType == eWindowType_popup) {
    1:           // ensure popups are the topmost of the TOPMOST
    1:           // layer. Remember not to set the SWP_NOZORDER
    1:           // flag as that might allow the taskbar to overlap
68855:           // the popup.
    1:           flags |= SWP_NOACTIVATE;
 8408:           HWND owner = ::GetWindow(mWnd, GW_OWNER);
 8408:           ::SetWindowPos(mWnd, owner ? 0 : HWND_TOPMOST, 0, 0, 0, 0, flags);
    1:         } else {
26616:           if (mWindowType == eWindowType_dialog && !CanTakeFocus())
26616:             flags |= SWP_NOACTIVATE;
68855: 
    1:           ::SetWindowPos(mWnd, HWND_TOP, 0, 0, 0, 0, flags);
    1:         }
    1:       }
41071: 
41071:       if (!wasVisible && (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog)) {
41071:         // when a toplevel window or dialog is shown, initialize the UI state
41071:         ::SendMessageW(mWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
41071:       }
    1:     } else {
    1:       if (mWindowType != eWindowType_dialog) {
    1:         ::ShowWindow(mWnd, SW_HIDE);
    1:       } else {
    1:         ::SetWindowPos(mWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE |
    1:                        SWP_NOZORDER | SWP_NOACTIVATE);
    1:       }
    1:     }
    1:   }
    1:   
    1: #ifdef MOZ_XUL
87336:   if (!wasVisible && bState) {
87336:     Invalidate();
87336:     if (syncInvalidate) {
87336:       ::UpdateWindow(mWnd);
87336:     }
87336:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::IsVisible
29835:  *
29835:  * Returns the visibility state.
29835:  *
29835:  **************************************************************/
29835: 
79626: // Return true if the whether the component is visible, false otherwise
79445: NS_METHOD nsWindow::IsVisible(bool & bState)
    1: {
    1:   bState = mIsVisible;
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window clipping utilities
29835:  *
29835:  * Used in Size and Move operations for setting the proper
29835:  * window clipping regions for window transparency.
29835:  *
29835:  **************************************************************/
    1: 
26576: // XP and Vista visual styles sometimes require window clipping regions to be applied for proper
26576: // transparency. These routines are called on size and move operations.
26576: void nsWindow::ClearThemeRegion()
26576: {
90191:   if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION &&
90191:       !HasGlass() &&
52101:       (mWindowType == eWindowType_popup && !IsPopupWithTitleBar() &&
52101:        (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel))) {
26576:     SetWindowRgn(mWnd, NULL, false);
26650:   }
26576: }
26576: 
26576: void nsWindow::SetThemeRegion()
26576: {
26576:   // Popup types that have a visual styles region applied (bug 376408). This can be expanded
26576:   // for other window types as needed. The regions are applied generically to the base window
26576:   // so default constants are used for part and state. At some point we might need part and
26576:   // state values from nsNativeThemeWin's GetThemePartAndState, but currently windows that
26576:   // change shape based on state haven't come up.
90191:   if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION &&
90191:       !HasGlass() &&
52101:       (mWindowType == eWindowType_popup && !IsPopupWithTitleBar() &&
52101:        (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel))) {
26576:     HRGN hRgn = nsnull;
26576:     RECT rect = {0,0,mBounds.width,mBounds.height};
26576:     
36844:     HDC dc = ::GetDC(mWnd);
90802:     GetThemeBackgroundRegion(nsUXThemeData::GetTheme(eUXTooltip), dc, TTP_STANDARD, TS_NORMAL, &rect, &hRgn);
26576:     if (hRgn) {
26576:       if (!SetWindowRgn(mWnd, hRgn, false)) // do not delete or alter hRgn if accepted.
26576:         DeleteObject(hRgn);
26576:     }
36844:     ::ReleaseDC(mWnd, dc);
26576:   }
26576: }
26576: 
29835: /**************************************************************
29835:  *
48711:  * SECTION: nsIWidget::RegisterTouchWindow,
48711:  * nsIWidget::UnregisterTouchWindow, and helper functions
48711:  *
48711:  * Used to register the native window to receive touch events
48711:  *
48711:  **************************************************************/
48711: 
48711: NS_METHOD nsWindow::RegisterTouchWindow() {
79626:   mTouchWindow = true;
48711:   mGesture.RegisterTouchWindow(mWnd);
51212:   ::EnumChildWindows(mWnd, nsWindow::RegisterTouchForDescendants, 0);
48711:   return NS_OK;
48711: }
48711: 
48711: NS_METHOD nsWindow::UnregisterTouchWindow() {
79626:   mTouchWindow = false;
48711:   mGesture.UnregisterTouchWindow(mWnd);
51212:   ::EnumChildWindows(mWnd, nsWindow::UnregisterTouchForDescendants, 0);
48711:   return NS_OK;
48711: }
48711: 
48711: BOOL CALLBACK nsWindow::RegisterTouchForDescendants(HWND aWnd, LPARAM aMsg) {
86569:   nsWindow* win = WinUtils::GetNSWindowPtr(aWnd);
48711:   if (win)
48711:     win->mGesture.RegisterTouchWindow(aWnd);
48711:   return TRUE;
48711: }
48711: 
48711: BOOL CALLBACK nsWindow::UnregisterTouchForDescendants(HWND aWnd, LPARAM aMsg) {
86569:   nsWindow* win = WinUtils::GetNSWindowPtr(aWnd);
48711:   if (win)
48711:     win->mGesture.UnregisterTouchWindow(aWnd);
48711:   return TRUE;
48711: }
48711: 
48711: /**************************************************************
48711:  *
33506:  * SECTION: nsIWidget::Move, nsIWidget::Resize,
33506:  * nsIWidget::Size, nsIWidget::BeginResizeDrag
29835:  *
29835:  * Repositioning and sizing a window.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Move this component
    1: NS_METHOD nsWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
34488:   if (mWindowType == eWindowType_toplevel ||
34488:       mWindowType == eWindowType_dialog) {
34488:     SetSizeMode(nsSizeMode_Normal);
34488:   }
    1:   // Check to see if window needs to be moved first
    1:   // to avoid a costly call to SetWindowPos. This check
    1:   // can not be moved to the calling code in nsView, because
    1:   // some platforms do not position child windows correctly
    1: 
    1:   // Only perform this check for non-popup windows, since the positioning can
    1:   // in fact change even when the x/y do not.  We always need to perform the
    1:   // check. See bug #97805 for details.
    1:   if (mWindowType != eWindowType_popup && (mBounds.x == aX) && (mBounds.y == aY))
    1:   {
    1:     // Nothing to do, since it is already positioned correctly.
    1:     return NS_OK;
    1:   }
    1: 
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   if (mWnd) {
    1: #ifdef DEBUG
    1:     // complain if a window is moved offscreen (legal, but potentially worrisome)
    1:     if (mIsTopWidgetWindow) { // only a problem for top-level windows
    1:       // Make sure this window is actually on the screen before we move it
    1:       // XXX: Needs multiple monitor support
    1:       HDC dc = ::GetDC(mWnd);
    1:       if (dc) {
    1:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
    1:           RECT workArea;
    1:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);
    1:           // no annoying assertions. just mention the issue.
76714:           if (aX < 0 || aX >= workArea.right || aY < 0 || aY >= workArea.bottom) {
76714:             PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:                    ("window moved to offscreen position\n"));
76714:           }
    1:         }
    1:       ::ReleaseDC(mWnd, dc);
    1:       }
    1:     }
    1: #endif
26576:     ClearThemeRegion();
58633: 
58633:     UINT flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE;
58633:     // Workaround SetWindowPos bug with D3D9. If our window has a clip
58633:     // region, some drivers or OSes may incorrectly copy into the clipped-out
58633:     // area.
58633:     if (mWindowType == eWindowType_plugin &&
58633:         (!mLayerManager || mLayerManager->GetBackendType() == LayerManager::LAYERS_D3D9) &&
58633:         mClipRects &&
68638:         (mClipRectCount != 1 || !mClipRects[0].IsEqualInterior(nsIntRect(0, 0, mBounds.width, mBounds.height)))) {
58633:       flags |= SWP_NOCOPYBITS;
58633:     }
58633:     VERIFY(::SetWindowPos(mWnd, NULL, aX, aY, 0, 0, flags));
58633: 
26576:     SetThemeRegion();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Resize this component
79445: NS_METHOD nsWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, bool aRepaint)
    1: {
    1:   NS_ASSERTION((aWidth >=0 ) , "Negative width passed to nsWindow::Resize");
    1:   NS_ASSERTION((aHeight >=0 ), "Negative height passed to nsWindow::Resize");
    1: 
46192:   // Avoid unnecessary resizing calls
46234:   if (mBounds.width == aWidth && mBounds.height == aHeight && !aRepaint)
46192:     return NS_OK;
46192: 
    1: #ifdef MOZ_XUL
16601:   if (eTransparencyTransparent == mTransparencyMode)
    1:     ResizeTranslucentWindow(aWidth, aHeight);
    1: #endif
    1: 
    1:   // Set cached value for lightweight and printing
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   if (mWnd) {
    1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE;
30750: 
    1:     if (!aRepaint) {
    1:       flags |= SWP_NOREDRAW;
    1:     }
    1: 
26576:     ClearThemeRegion();
    1:     VERIFY(::SetWindowPos(mWnd, NULL, 0, 0, aWidth, GetHeight(aHeight), flags));
26576:     SetThemeRegion();
    1:   }
    1: 
    1:   if (aRepaint)
87336:     Invalidate();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Resize this component
79445: NS_METHOD nsWindow::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, bool aRepaint)
    1: {
    1:   NS_ASSERTION((aWidth >=0 ),  "Negative width passed to nsWindow::Resize");
    1:   NS_ASSERTION((aHeight >=0 ), "Negative height passed to nsWindow::Resize");
    1: 
46192:   // Avoid unnecessary resizing calls
46192:   if (mBounds.x == aX && mBounds.y == aY &&
46234:       mBounds.width == aWidth && mBounds.height == aHeight && !aRepaint)
46192:     return NS_OK;
46192: 
    1: #ifdef MOZ_XUL
16601:   if (eTransparencyTransparent == mTransparencyMode)
    1:     ResizeTranslucentWindow(aWidth, aHeight);
    1: #endif
    1: 
    1:   // Set cached value for lightweight and printing
    1:   mBounds.x      = aX;
    1:   mBounds.y      = aY;
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   if (mWnd) {
    1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE;
    1:     if (!aRepaint) {
    1:       flags |= SWP_NOREDRAW;
    1:     }
26576: 
26576:     ClearThemeRegion();
    1:     VERIFY(::SetWindowPos(mWnd, NULL, aX, aY, aWidth, GetHeight(aHeight), flags));
26576:     SetThemeRegion();
    1:   }
    1: 
    1:   if (aRepaint)
87336:     Invalidate();
    1: 
    1:   return NS_OK;
    1: }
    1: 
33506: NS_IMETHODIMP
33506: nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical)
33506: {
33506:   NS_ENSURE_ARG_POINTER(aEvent);
33506: 
33506:   if (aEvent->eventStructType != NS_MOUSE_EVENT) {
33506:     // you can only begin a resize drag with a mouse event
33506:     return NS_ERROR_INVALID_ARG;
33506:   }
33506: 
33506:   nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
33506:   if (mouseEvent->button != nsMouseEvent::eLeftButton) {
33506:     // you can only begin a resize drag with the left mouse button
33506:     return NS_ERROR_INVALID_ARG;
33506:   }
33506: 
33506:   // work out what sizemode we're talking about
33506:   WPARAM syscommand;
33506:   if (aVertical < 0) {
33506:     if (aHorizontal < 0) {
33506:       syscommand = SC_SIZE | WMSZ_TOPLEFT;
33506:     } else if (aHorizontal == 0) {
33506:       syscommand = SC_SIZE | WMSZ_TOP;
33506:     } else {
33506:       syscommand = SC_SIZE | WMSZ_TOPRIGHT;
33506:     }
33506:   } else if (aVertical == 0) {
33506:     if (aHorizontal < 0) {
33506:       syscommand = SC_SIZE | WMSZ_LEFT;
33506:     } else if (aHorizontal == 0) {
33506:       return NS_ERROR_INVALID_ARG;
33506:     } else {
33506:       syscommand = SC_SIZE | WMSZ_RIGHT;
33506:     }
33506:   } else {
33506:     if (aHorizontal < 0) {
33506:       syscommand = SC_SIZE | WMSZ_BOTTOMLEFT;
33506:     } else if (aHorizontal == 0) {
33506:       syscommand = SC_SIZE | WMSZ_BOTTOM;
33506:     } else {
33506:       syscommand = SC_SIZE | WMSZ_BOTTOMRIGHT;
33506:     }
33506:   }
33506: 
33506:   // resizing doesn't work if the mouse is already captured
79626:   CaptureMouse(false);
33506: 
33506:   // find the top-level window
86569:   HWND toplevelWnd = WinUtils::GetTopLevelHWND(mWnd, true);
33506: 
33506:   // tell Windows to start the resize
33506:   ::PostMessage(toplevelWnd, WM_SYSCOMMAND, syscommand,
33506:                 POINTTOPOINTS(aEvent->refPoint));
33506: 
33506:   return NS_OK;
33506: }
68855: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Window Z-order and state.
29835:  *
29835:  * nsIWidget::PlaceBehind, nsIWidget::SetSizeMode,
29835:  * nsIWidget::ConstrainPosition
29835:  *
29835:  * Z-order, positioning, restore, minimize, and maximize.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Position the window behind the given window
29835: NS_METHOD nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
79445:                                 nsIWidget *aWidget, bool aActivate)
29835: {
29835:   HWND behind = HWND_TOP;
29835:   if (aPlacement == eZPlacementBottom)
29835:     behind = HWND_BOTTOM;
29835:   else if (aPlacement == eZPlacementBelow && aWidget)
29835:     behind = (HWND)aWidget->GetNativeData(NS_NATIVE_WINDOW);
29835:   UINT flags = SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOSIZE;
29835:   if (!aActivate)
29835:     flags |= SWP_NOACTIVATE;
29835: 
29835:   if (!CanTakeFocus() && behind == HWND_TOP)
29835:   {
29835:     // Can't place the window to top so place it behind the foreground window
29835:     // (as long as it is not topmost)
29835:     HWND wndAfter = ::GetForegroundWindow();
29835:     if (!wndAfter)
29835:       behind = HWND_BOTTOM;
29835:     else if (!(GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST))
29835:       behind = wndAfter;
29835:     flags |= SWP_NOACTIVATE;
29835:   }
29835: 
29835:   ::SetWindowPos(mWnd, behind, 0, 0, 0, 0, flags);
29835:   return NS_OK;
29835: }
29835: 
29835: // Maximize, minimize or restore the window.
29835: NS_IMETHODIMP nsWindow::SetSizeMode(PRInt32 aMode) {
29835: 
29835:   nsresult rv;
29835: 
29835:   // Let's not try and do anything if we're already in that state.
29835:   // (This is needed to prevent problems when calling window.minimize(), which
29835:   // calls us directly, and then the OS triggers another call to us.)
29835:   if (aMode == mSizeMode)
29835:     return NS_OK;
29835: 
29835:   // save the requested state
29835:   rv = nsBaseWidget::SetSizeMode(aMode);
29835:   if (NS_SUCCEEDED(rv) && mIsVisible) {
29835:     int mode;
29835: 
29835:     switch (aMode) {
30075:       case nsSizeMode_Fullscreen :
47780:         mode = SW_SHOW;
30075:         break;
30075: 
29835:       case nsSizeMode_Maximized :
29835:         mode = SW_MAXIMIZE;
29835:         break;
34786: 
29835:       case nsSizeMode_Minimized :
34786:         // Using SW_SHOWMINIMIZED prevents the working set from being trimmed but
34786:         // keeps the window active in the tray. So after the window is minimized,
34786:         // windows will fire WM_WINDOWPOSCHANGED (OnWindowPosChanged) at which point
34786:         // we will do some additional processing to get the active window set right.
34786:         // If sTrimOnMinimize is set, we let windows handle minimization normally
34786:         // using SW_MINIMIZE.
29835:         mode = sTrimOnMinimize ? SW_MINIMIZE : SW_SHOWMINIMIZED;
34786:         break;
34786: 
29835:       default :
29835:         mode = SW_RESTORE;
29835:     }
74541: 
74541:     WINDOWPLACEMENT pl;
74541:     pl.length = sizeof(pl);
74541:     ::GetWindowPlacement(mWnd, &pl);
74541:     // Don't call ::ShowWindow if we're trying to "restore" a window that is
74541:     // already in a normal state.  Prevents a bug where snapping to one side
74541:     // of the screen and then minimizing would cause Windows to forget our
74541:     // window's correct restored position/size.
74541:     if( !(pl.showCmd == SW_SHOWNORMAL && mode == SW_RESTORE) ) {
29835:       ::ShowWindow(mWnd, mode);
74541:     }
31384:     // we dispatch an activate event here to ensure that the right child window
31384:     // is focused
69564:     if (mode == SW_RESTORE || mode == SW_MAXIMIZE || mode == SW_SHOW)
31384:       DispatchFocusToTopLevelWindow(NS_ACTIVATE);
29835:   }
29835:   return rv;
29835: }
29835: 
29835: // Constrain a potential move to fit onscreen
79445: NS_METHOD nsWindow::ConstrainPosition(bool aAllowSlop,
29835:                                       PRInt32 *aX, PRInt32 *aY)
29835: {
29835:   if (!mIsTopWidgetWindow) // only a problem for top-level windows
29835:     return NS_OK;
29835: 
79445:   bool doConstrain = false; // whether we have enough info to do anything
29835: 
29835:   /* get our playing field. use the current screen, or failing that
29835:     for any reason, use device caps for the default screen. */
29835:   RECT screenRect;
29835: 
29835:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService(sScreenManagerContractID);
29835:   if (screenmgr) {
29835:     nsCOMPtr<nsIScreen> screen;
29835:     PRInt32 left, top, width, height;
29835: 
29835:     // zero size rects confuse the screen manager
29835:     width = mBounds.width > 0 ? mBounds.width : 1;
29835:     height = mBounds.height > 0 ? mBounds.height : 1;
29835:     screenmgr->ScreenForRect(*aX, *aY, width, height,
29835:                              getter_AddRefs(screen));
29835:     if (screen) {
47969:       if (mSizeMode != nsSizeMode_Fullscreen) {
47969:         // For normalized windows, use the desktop work area.
29835:         screen->GetAvailRect(&left, &top, &width, &height);
47969:       } else {
47969:         // For full screen windows, use the desktop.
47969:         screen->GetRect(&left, &top, &width, &height);
47969:       }
29835:       screenRect.left = left;
29835:       screenRect.right = left+width;
29835:       screenRect.top = top;
29835:       screenRect.bottom = top+height;
79626:       doConstrain = true;
29835:     }
29835:   } else {
29835:     if (mWnd) {
29835:       HDC dc = ::GetDC(mWnd);
29835:       if (dc) {
29835:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
47969:           if (mSizeMode != nsSizeMode_Fullscreen) {
29835:             ::SystemParametersInfo(SPI_GETWORKAREA, 0, &screenRect, 0);
47969:           } else {
47969:             screenRect.left = screenRect.top = 0;
47969:             screenRect.right = GetSystemMetrics(SM_CXFULLSCREEN);
47969:             screenRect.bottom = GetSystemMetrics(SM_CYFULLSCREEN);
47969:           }
79626:           doConstrain = true;
29835:         }
29835:         ::ReleaseDC(mWnd, dc);
29835:       }
29835:     }
29835:   }
29835: 
29835:   if (aAllowSlop) {
29835:     if (*aX < screenRect.left - mBounds.width + kWindowPositionSlop)
29835:       *aX = screenRect.left - mBounds.width + kWindowPositionSlop;
29835:     else if (*aX >= screenRect.right - kWindowPositionSlop)
29835:       *aX = screenRect.right - kWindowPositionSlop;
29835: 
29835:     if (*aY < screenRect.top - mBounds.height + kWindowPositionSlop)
29835:       *aY = screenRect.top - mBounds.height + kWindowPositionSlop;
29835:     else if (*aY >= screenRect.bottom - kWindowPositionSlop)
29835:       *aY = screenRect.bottom - kWindowPositionSlop;
29835: 
29835:   } else {
29835: 
29835:     if (*aX < screenRect.left)
29835:       *aX = screenRect.left;
29835:     else if (*aX >= screenRect.right - mBounds.width)
29835:       *aX = screenRect.right - mBounds.width;
29835: 
29835:     if (*aY < screenRect.top)
29835:       *aY = screenRect.top;
29835:     else if (*aY >= screenRect.bottom - mBounds.height)
29835:       *aY = screenRect.bottom - mBounds.height;
29835:   }
29835: 
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Enable, nsIWidget::IsEnabled
29835:  *
29835:  * Enabling and disabling the widget.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Enable/disable this component
79445: NS_METHOD nsWindow::Enable(bool bState)
    1: {
    1:   if (mWnd) {
    1:     ::EnableWindow(mWnd, bState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
29835: // Return the current enable state
79445: NS_METHOD nsWindow::IsEnabled(bool *aState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aState);
    1:   *aState = !mWnd || (::IsWindowEnabled(mWnd) && ::IsWindowEnabled(::GetAncestor(mWnd, GA_ROOT)));
    1:   return NS_OK;
    1: }
    1: 
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetFocus
29835:  *
29835:  * Give the focus to this widget.
29835:  *
29835:  **************************************************************/
29835: 
79445: NS_METHOD nsWindow::SetFocus(bool aRaise)
    1: {
    1:   if (mWnd) {
34735: #ifdef WINSTATE_DEBUG_OUTPUT
86569:     if (mWnd == WinUtils::GetTopLevelHWND(mWnd)) {
76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:              ("*** SetFocus: [  top] raise=%d\n", aRaise));
76714:     } else {
76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:              ("*** SetFocus: [child] raise=%d\n", aRaise));
76714:     }
34735: #endif
    1:     // Uniconify, if necessary
86569:     HWND toplevelWnd = WinUtils::GetTopLevelHWND(mWnd);
33214:     if (aRaise && ::IsIconic(toplevelWnd)) {
    1:       ::ShowWindow(toplevelWnd, SW_RESTORE);
33214:     }
    1:     ::SetFocus(mWnd);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Bounds
29835:  *
46200:  * GetBounds, GetClientBounds, GetScreenBounds, GetClientOffset
46200:  * SetDrawsInTitlebar, GetNonClientMargins, SetNonClientMargins
29835:  *
29835:  * Bound calculations.
29835:  *
29835:  **************************************************************/
29835: 
46192: // Return the window's full dimensions in screen coordinates.
46192: // If the window has a parent, converts the origin to an offset
46192: // of the parent's screen origin.
23738: NS_METHOD nsWindow::GetBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     // assign size
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
64624:     // popup window bounds' are in screen coordinates, not relative to parent
64624:     // window
64624:     if (mWindowType == eWindowType_popup) {
64624:       aRect.x = r.left;
64624:       aRect.y = r.top;
64624:       return NS_OK;
64624:     }
64624: 
46192:     // chrome on parent:
46192:     //  ___      5,5   (chrome start)
46192:     // |  ____   10,10 (client start)
46192:     // | |  ____ 20,20 (child start)
46192:     // | | |
46192:     // 20,20 - 5,5 = 15,15 (??)
46192:     // minus GetClientOffset:
46192:     // 15,15 - 5,5 = 10,10
46192:     //
46192:     // no chrome on parent:
46192:     //  ______   10,10 (win start)
46192:     // |  ____   20,20 (child start)
46192:     // | |
46192:     // 20,20 - 10,10 = 10,10
46192:     //
46192:     // walking the chain:
46192:     //  ___      5,5   (chrome start)
46192:     // |  ___    10,10 (client start)
46192:     // | |  ___  20,20 (child start)
46192:     // | | |  __ 30,30 (child start)
46192:     // | | | |
46192:     // 30,30 - 20,20 = 10,10 (offset from second child to first)
46192:     // 20,20 - 5,5 = 15,15 + 10,10 = 25,25 (??)
46192:     // minus GetClientOffset:
46192:     // 25,25 - 5,5 = 20,20 (offset from second child to parent client)
46192: 
    1:     // convert coordinates if parent exists
    1:     HWND parent = ::GetParent(mWnd);
    1:     if (parent) {
    1:       RECT pr;
    1:       VERIFY(::GetWindowRect(parent, &pr));
    1:       r.left -= pr.left;
    1:       r.top  -= pr.top;
46192:       // adjust for chrome
46192:       nsWindow* pWidget = static_cast<nsWindow*>(GetParent());
46192:       if (pWidget && pWidget->IsTopLevelWidget()) {
48256:         nsIntPoint clientOffset = pWidget->GetClientOffset();
46192:         r.left -= clientOffset.x;
46192:         r.top  -= clientOffset.y;
46192:       }
    1:     }
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else {
    1:     aRect = mBounds;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Get this component dimension
23738: NS_METHOD nsWindow::GetClientBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetClientRect(mWnd, &r));
    1: 
83107:     nsIntRect bounds;
83107:     GetBounds(bounds);
83107:     aRect.MoveTo(bounds.TopLeft() + GetClientOffset());
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1: 
    1:   } else {
    1:     aRect.SetRect(0,0,0,0);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
29835: // Like GetBounds, but don't offset by the parent
23738: NS_METHOD nsWindow::GetScreenBounds(nsIntRect &aRect)
    1: {
    1:   if (mWnd) {
    1:     RECT r;
    1:     VERIFY(::GetWindowRect(mWnd, &r));
    1: 
    1:     aRect.width  = r.right - r.left;
    1:     aRect.height = r.bottom - r.top;
    1:     aRect.x = r.left;
    1:     aRect.y = r.top;
    1:   } else
    1:     aRect = mBounds;
    1: 
    1:   return NS_OK;
    1: }
    1: 
46192: // return the x,y offset of the client area from the origin
46192: // of the window. If the window is borderless returns (0,0).
48256: nsIntPoint nsWindow::GetClientOffset()
46192: {
46192:   if (!mWnd) {
48256:     return nsIntPoint(0, 0);
46192:   }
46192: 
46192:   RECT r1;
46192:   GetWindowRect(mWnd, &r1);
46192:   nsIntPoint pt = WidgetToScreenOffset();
48256:   return nsIntPoint(pt.x - r1.left, pt.y - r1.top);
46192: }
46192: 
46200: void
79445: nsWindow::SetDrawsInTitlebar(bool aState)
46200: {
79626:   nsWindow * window = GetTopLevelWindow(true);
46200:   if (window && window != this) {
46200:     return window->SetDrawsInTitlebar(aState);
46200:   }
46200: 
46200:   if (aState) {
46200:      // left, top, right, bottom for nsIntMargin
46200:     nsIntMargin margins(-1, 0, -1, -1);
46200:     SetNonClientMargins(margins);
46200:   }
46200:   else {
46200:     nsIntMargin margins(-1, -1, -1, -1);
46200:     SetNonClientMargins(margins);
46200:   }
46200: }
46200: 
46200: NS_IMETHODIMP
46200: nsWindow::GetNonClientMargins(nsIntMargin &margins)
46200: {
79626:   nsWindow * window = GetTopLevelWindow(true);
46200:   if (window && window != this) {
46200:     return window->GetNonClientMargins(margins);
46200:   }
46200: 
46200:   if (mCustomNonClient) {
46200:     margins = mNonClientMargins;
46200:     return NS_OK;
46200:   }
46200: 
46332:   margins.top = GetSystemMetrics(SM_CYCAPTION);
46332:   margins.bottom = GetSystemMetrics(SM_CYFRAME);
46332:   margins.top += margins.bottom;
46332:   margins.left = margins.right = GetSystemMetrics(SM_CYFRAME);
46200: 
46200:   return NS_OK;
46200: }
46200: 
47788: void
47788: nsWindow::ResetLayout()
47788: {
47788:   // This will trigger a frame changed event, triggering
47788:   // nc calc size and a sizemode gecko event.
47788:   SetWindowPos(mWnd, 0, 0, 0, 0, 0,
47788:                SWP_FRAMECHANGED|SWP_NOACTIVATE|SWP_NOMOVE|
47788:                SWP_NOOWNERZORDER|SWP_NOSIZE|SWP_NOZORDER);
47788: 
47788:   // If hidden, just send the frame changed event for now.
47788:   if (!mIsVisible)
47788:     return;
47788: 
47788:   // Send a gecko size event to trigger reflow.
47788:   RECT clientRc = {0};
47788:   GetClientRect(mWnd, &clientRc);
47788:   nsIntRect evRect(nsWindowGfx::ToIntRect(clientRc));
47788:   OnResize(evRect);
47788: 
47788:   // Invalidate and update
87336:   Invalidate();
47788: }
47788: 
57388: // Internally track the caption status via a window property. Required
57388: // due to our internal handling of WM_NCACTIVATE when custom client
57388: // margins are set.
57388: static const PRUnichar kManageWindowInfoProperty[] = L"ManageWindowInfoProperty";
57388: typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
57388: static GetWindowInfoPtr sGetWindowInfoPtrStub = NULL;
57388: 
57388: BOOL WINAPI
57388: GetWindowInfoHook(HWND hWnd, PWINDOWINFO pwi)
57388: {
57388:   if (!sGetWindowInfoPtrStub) {
57388:     NS_ASSERTION(FALSE, "Something is horribly wrong in GetWindowInfoHook!");
57388:     return FALSE;
57388:   }
57388:   int windowStatus = 
61525:     reinterpret_cast<LONG_PTR>(GetPropW(hWnd, kManageWindowInfoProperty));
57388:   // No property set, return the default data.
57388:   if (!windowStatus)
57388:     return sGetWindowInfoPtrStub(hWnd, pwi);
57388:   // Call GetWindowInfo and update dwWindowStatus with our
57388:   // internally tracked value. 
57388:   BOOL result = sGetWindowInfoPtrStub(hWnd, pwi);
57388:   if (result && pwi)
57388:     pwi->dwWindowStatus = (windowStatus == 1 ? 0 : WS_ACTIVECAPTION);
57388:   return result;
57388: }
57388: 
57388: void
79445: nsWindow::UpdateGetWindowInfoCaptionStatus(bool aActiveCaption)
57388: {
57388:   if (!mWnd)
57388:     return;
57388: 
57388:   if (!sGetWindowInfoPtrStub) {
57388:     sUser32Intercept.Init("user32.dll");
69198:     if (!sUser32Intercept.AddHook("GetWindowInfo", reinterpret_cast<intptr_t>(GetWindowInfoHook),
57388:                                   (void**) &sGetWindowInfoPtrStub))
57388:       return;
57388:   }
57388:   // Update our internally tracked caption status
57388:   SetPropW(mWnd, kManageWindowInfoProperty, 
57388:     reinterpret_cast<HANDLE>(static_cast<int>(aActiveCaption) + 1));
57388: }
57388: 
47788: // Called when the window layout changes: full screen mode transitions,
47788: // theme changes, and composition changes. Calculates the new non-client
47788: // margins and fires off a frame changed event, which triggers an nc calc
47788: // size windows event, kicking the changes in.
79445: bool
79445: nsWindow::UpdateNonClientMargins(PRInt32 aSizeMode, bool aReflowWindow)
46200: {
46200:   if (!mCustomNonClient)
79626:     return false;
46200: 
46200:   mNonClientOffset.top = mNonClientOffset.bottom =
46200:     mNonClientOffset.left = mNonClientOffset.right = 0;
87238:   mCaptionHeight = mVertResizeMargin = mHorResizeMargin = 0;
46200: 
46332:   if (aSizeMode == -1)
46332:     aSizeMode = mSizeMode;
46332: 
46332:   if (aSizeMode == nsSizeMode_Minimized ||
46332:       aSizeMode == nsSizeMode_Fullscreen) {
79626:     return true;
46332:   }
46332: 
87238:   bool hasCaption = (mBorderStyle & (eBorderStyle_all |
87238:                                      eBorderStyle_title |
87238:                                      eBorderStyle_menu |
87238:                                      eBorderStyle_default)) > 0 ? true : false;
87238: 
87238:   if (hasCaption)
46332:     mCaptionHeight = GetSystemMetrics(SM_CYCAPTION);
46332:   mHorResizeMargin = GetSystemMetrics(SM_CXFRAME);
46332:   mVertResizeMargin = GetSystemMetrics(SM_CYFRAME);
46332:   mCaptionHeight += mVertResizeMargin;
46200: 
87238:   // Custom margin offset calculations for the chrome margin attribute on a
87238:   // window. The offsets calculated here are added to the client area in the
87238:   // WM_NCCALCSIZE event:
87238:   // -1 - leave the default frame in place
87238:   //  0 - remove the frame, our frame offset equals the default frame size
87238:   // >0 - frame size equals (default frame size - margin value) with the
87238:   //      restriction that the offset <= default frame size.
46200:   if (!mNonClientMargins.top)
46200:     mNonClientOffset.top = mCaptionHeight;
46200:   else if (mNonClientMargins.top > 0)
87238:     mNonClientOffset.top = NS_MIN(mCaptionHeight, mNonClientMargins.top);
46200: 
46200:   if (!mNonClientMargins.left)
46332:     mNonClientOffset.left = mHorResizeMargin;
46200:   else if (mNonClientMargins.left > 0)
87238:     mNonClientOffset.left = NS_MIN(mHorResizeMargin, mNonClientMargins.left);
46200:  
46200:   if (!mNonClientMargins.right)
46332:     mNonClientOffset.right = mHorResizeMargin;
46200:   else if (mNonClientMargins.right > 0)
87238:     mNonClientOffset.right = NS_MIN(mHorResizeMargin, mNonClientMargins.right);
46332: 
46200:   if (!mNonClientMargins.bottom)
46332:     mNonClientOffset.bottom = mVertResizeMargin;
46200:   else if (mNonClientMargins.bottom > 0)
87238:     mNonClientOffset.bottom = NS_MIN(mVertResizeMargin, mNonClientMargins.bottom);
87238: 
87238:   // Disable chrome margins > 0 in two cases:
87238:   // - For non-glass desktops: The window frame is painted with textures that
87238:   //   require the entire space of the default frame. We allow a full frame or
87238:   //   no frame at all.
87238:   // - For maximized windows: Windows positions maximized windows such that the
87238:   //   outer bounds sit off screen a distance equal to the standard frame size.
87238:   if(!nsUXThemeData::CheckForCompositor() || aSizeMode == nsSizeMode_Maximized) {
87238:     if (mNonClientMargins.top > 0)
87238:       mNonClientOffset.top = 0;
87238:     if (mNonClientMargins.bottom > 0)
87238:       mNonClientOffset.bottom = 0;
87238:     if (mNonClientMargins.left > 0)
87238:       mNonClientOffset.left = 0;
87238:     if (mNonClientMargins.right > 0)
87238:       mNonClientOffset.right = 0;
87238:   }
46200: 
48424:   if (aSizeMode == nsSizeMode_Maximized) {
87238:     // For chrome margins = 0 on maximized windows, Windows places the bounds
87238:     // off screen a distance equal to the standard frame size. Remove this
87238:     // area from our expanded client area.
87238:     if (!mNonClientMargins.bottom)
87238:       mNonClientOffset.bottom = 0;
87238:     if (!mNonClientMargins.left)
87238:       mNonClientOffset.left = 0;
87238:     if (!mNonClientMargins.right)
87238:       mNonClientOffset.right = 0;
87238: 
87238:     // This should be (mCaptionHeight - mVertResizeMargin). But if we offset
87238:     // the client area by just SM_CYCAPTION (placing the top of the client
87238:     // area level with the visible screen) Windows dwm def proc fails to pick
87238:     // up mouse hover and clicks on the glass control buttons. To compensate,
87238:     // we position the client area off screen by mVertResizeMargin, and add
87238:     // widget padding in nsNativeThemeWin::GetWidgetPadding().
87238:     if (!mNonClientMargins.top)
87238:       mNonClientOffset.top = mCaptionHeight;
87238: 
48424:     // Address an issue with auto-hide taskbars which fall behind the window.
48424:     // Ensure a 1 pixel margin at the bottom of the monitor so that unhiding
48424:     // the taskbar works properly.
48424:     MONITORINFO info = {sizeof(MONITORINFO)};
48424:     if (::GetMonitorInfo(::MonitorFromWindow(mWnd, MONITOR_DEFAULTTOPRIMARY),
48424:                          &info)) {
48424:       RECT r;
48424:       if (::GetWindowRect(mWnd, &r)) {
48424:         // Adjust window rect to account for non-client margins.
48424:         r.top += mVertResizeMargin - mNonClientOffset.top;
48424:         r.left += mHorResizeMargin - mNonClientOffset.left;
48424:         r.bottom -= mVertResizeMargin - mNonClientOffset.bottom;
48424:         r.right -= mHorResizeMargin - mNonClientOffset.right;
48424:         // Leave the 1 pixel margin if the window covers the monitor.
48424:         if (r.top <= info.rcMonitor.top &&
48424:             r.left <= info.rcMonitor.left && 
48424:             r.right >= info.rcMonitor.right &&
48424:             r.bottom >= info.rcMonitor.bottom)
48424:           mNonClientOffset.bottom -= r.bottom - info.rcMonitor.bottom + 1;
48424:       }
48424:     }
48424:   }
46200: 
47788:   if (aReflowWindow) {
47788:     // Force a reflow of content based on the new client
47788:     // dimensions.
47788:     ResetLayout();
46332:   }
46200: 
79626:   return true;
46200: }
46200: 
46200: NS_IMETHODIMP
46200: nsWindow::SetNonClientMargins(nsIntMargin &margins)
46200: {
46200:   if (!mIsTopWidgetWindow ||
46200:       mBorderStyle & eBorderStyle_none ||
46200:       mHideChrome)
46200:     return NS_ERROR_INVALID_ARG;
46200: 
46200:   // Request for a reset
46200:   if (margins.top == -1 && margins.left == -1 &&
46200:       margins.right == -1 && margins.bottom == -1) {
79626:     mCustomNonClient = false;
46200:     mNonClientMargins = margins;
57394:     RemovePropW(mWnd, kManageWindowInfoProperty);
47788:     // Force a reflow of content based on the new client
47788:     // dimensions.
47788:     ResetLayout();
46200:     return NS_OK;
46200:   }
46200: 
46200:   if (margins.top < -1 || margins.bottom < -1 ||
46200:       margins.left < -1 || margins.right < -1)
46200:     return NS_ERROR_INVALID_ARG;
46200: 
46200:   mNonClientMargins = margins;
79626:   mCustomNonClient = true;
46200:   if (!UpdateNonClientMargins()) {
46200:     NS_WARNING("UpdateNonClientMargins failed!");
79626:     return false;
46200:   }
46200: 
46200:   return NS_OK;
46200: }
46200: 
49251: void
49251: nsWindow::InvalidateNonClientRegion()
49251: {
49251:   // +-+-----------------------+-+
49251:   // | | app non-client chrome | |
49251:   // | +-----------------------+ |
49251:   // | |   app client chrome   | | }
49251:   // | +-----------------------+ | }
49251:   // | |      app content      | | } area we don't want to invalidate
49251:   // | +-----------------------+ | }
49251:   // | |   app client chrome   | | }
49251:   // | +-----------------------+ | 
49251:   // +---------------------------+ <
49251:   //  ^                         ^    windows non-client chrome
49251:   // client area = app *
49251:   RECT rect;
49251:   GetWindowRect(mWnd, &rect);
49251:   MapWindowPoints(NULL, mWnd, (LPPOINT)&rect, 2);
49251:   HRGN winRgn = CreateRectRgnIndirect(&rect);
49251: 
49251:   // Subtract app client chrome and app content leaving
49251:   // windows non-client chrome and app non-client chrome
49251:   // in winRgn.
49251:   GetWindowRect(mWnd, &rect);
49251:   rect.top += mCaptionHeight;
49251:   rect.right -= mHorResizeMargin;
49251:   rect.bottom -= mHorResizeMargin;
49251:   rect.left += mVertResizeMargin;
49251:   MapWindowPoints(NULL, mWnd, (LPPOINT)&rect, 2);
49251:   HRGN clientRgn = CreateRectRgnIndirect(&rect);
49251:   CombineRgn(winRgn, winRgn, clientRgn, RGN_DIFF);
49251:   DeleteObject(clientRgn);
49251: 
49251:   // triggers ncpaint and paint events for the two areas
49251:   RedrawWindow(mWnd, NULL, winRgn, RDW_FRAME|RDW_INVALIDATE);
49251:   DeleteObject(winRgn);
49251: }
49251: 
49251: HRGN
49251: nsWindow::ExcludeNonClientFromPaintRegion(HRGN aRegion)
49251: {
49251:   RECT rect;
49251:   HRGN rgn = NULL;
49251:   if (aRegion == (HRGN)1) { // undocumented value indicating a full refresh
49251:     GetWindowRect(mWnd, &rect);
49251:     rgn = CreateRectRgnIndirect(&rect);
49251:   } else {
49251:     rgn = aRegion;
49251:   }
49251:   GetClientRect(mWnd, &rect);
49251:   MapWindowPoints(mWnd, NULL, (LPPOINT)&rect, 2);
49251:   HRGN nonClientRgn = CreateRectRgnIndirect(&rect);
49251:   CombineRgn(rgn, rgn, nonClientRgn, RGN_DIFF);
49251:   DeleteObject(nonClientRgn);
49251:   return rgn;
49251: }
49251: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetBackgroundColor
29835:  *
29835:  * Sets the window background paint color.
29835:  *
29835:  **************************************************************/
29835: 
    1: NS_METHOD nsWindow::SetBackgroundColor(const nscolor &aColor)
    1: {
    1:   nsBaseWidget::SetBackgroundColor(aColor);
    1: 
    1:   if (mBrush)
    1:     ::DeleteObject(mBrush);
    1: 
    1:   mBrush = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
    1:   if (mWnd != NULL) {
25349:     ::SetClassLongPtrW(mWnd, GCLP_HBRBACKGROUND, (LONG_PTR)mBrush);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetCursor
29835:  *
29835:  * SetCursor and related utilities for manging cursor state.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Set this component cursor
    1: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
    1: {
    1:   // Only change cursor if it's changing
    1: 
    1:   //XXX mCursor isn't always right.  Scrollbars and others change it, too.
    1:   //XXX If we want this optimization we need a better way to do it.
    1:   //if (aCursor != mCursor) {
    1:   HCURSOR newCursor = NULL;
    1: 
    1:   switch (aCursor) {
    1:     case eCursor_select:
    1:       newCursor = ::LoadCursor(NULL, IDC_IBEAM);
    1:       break;
    1: 
    1:     case eCursor_wait:
    1:       newCursor = ::LoadCursor(NULL, IDC_WAIT);
    1:       break;
    1: 
    1:     case eCursor_hyperlink:
    1:     {
    1:       newCursor = ::LoadCursor(NULL, IDC_HAND);
    1:       break;
    1:     }
    1: 
    1:     case eCursor_standard:
    1:       newCursor = ::LoadCursor(NULL, IDC_ARROW);
    1:       break;
    1: 
    1:     case eCursor_n_resize:
    1:     case eCursor_s_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
    1:       break;
    1: 
    1:     case eCursor_w_resize:
    1:     case eCursor_e_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
    1:       break;
    1: 
    1:     case eCursor_nw_resize:
    1:     case eCursor_se_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
    1:       break;
    1: 
    1:     case eCursor_ne_resize:
    1:     case eCursor_sw_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
    1:       break;
    1: 
    1:     case eCursor_crosshair:
    1:       newCursor = ::LoadCursor(NULL, IDC_CROSS);
    1:       break;
    1: 
    1:     case eCursor_move:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
    1:       break;
    1: 
    1:     case eCursor_help:
    1:       newCursor = ::LoadCursor(NULL, IDC_HELP);
    1:       break;
    1: 
    1:     case eCursor_copy: // CSS3
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COPY));
    1:       break;
    1: 
    1:     case eCursor_alias:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ALIAS));
    1:       break;
    1: 
    1:     case eCursor_cell:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_CELL));
    1:       break;
    1: 
    1:     case eCursor_grab:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRAB));
    1:       break;
    1: 
    1:     case eCursor_grabbing:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRABBING));
    1:       break;
    1: 
    1:     case eCursor_spinning:
    1:       newCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
    1:       break;
    1: 
    1:     case eCursor_context_menu:
    1:       // XXX this CSS3 cursor needs to be implemented
    1:       break;
    1: 
    1:     case eCursor_zoom_in:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMIN));
    1:       break;
    1: 
    1:     case eCursor_zoom_out:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMOUT));
    1:       break;
    1: 
    1:     case eCursor_not_allowed:
    1:     case eCursor_no_drop:
    1:       newCursor = ::LoadCursor(NULL, IDC_NO);
    1:       break;
    1: 
    1:     case eCursor_col_resize:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COLRESIZE));
    1:       break;
    1: 
    1:     case eCursor_row_resize:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ROWRESIZE));
    1:       break;
    1: 
    1:     case eCursor_vertical_text:
    1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_VERTICALTEXT));
    1:       break;
    1: 
    1:     case eCursor_all_scroll:
    1:       // XXX not 100% appropriate perhaps
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
    1:       break;
    1: 
    1:     case eCursor_nesw_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
    1:       break;
    1: 
    1:     case eCursor_nwse_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
    1:       break;
    1: 
    1:     case eCursor_ns_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
    1:       break;
    1: 
    1:     case eCursor_ew_resize:
    1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
    1:       break;
    1: 
10405:     case eCursor_none:
10405:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_NONE));
10405:       break;
10405: 
    1:     default:
    1:       NS_ERROR("Invalid cursor type");
    1:       break;
    1:   }
    1: 
    1:   if (NULL != newCursor) {
    1:     mCursor = aCursor;
    1:     HCURSOR oldCursor = ::SetCursor(newCursor);
    1:     
29835:     if (sHCursor == oldCursor) {
29835:       NS_IF_RELEASE(sCursorImgContainer);
29835:       if (sHCursor != NULL)
29835:         ::DestroyIcon(sHCursor);
29835:       sHCursor = NULL;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: // Setting the actual cursor
    1: NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
    1:                                   PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
29835:   if (sCursorImgContainer == aCursor && sHCursor) {
29835:     ::SetCursor(sHCursor);
    1:     return NS_OK;
    1:   }
    1: 
30804:   PRInt32 width;
30804:   PRInt32 height;
30804: 
30804:   nsresult rv;
30804:   rv = aCursor->GetWidth(&width);
30804:   NS_ENSURE_SUCCESS(rv, rv);
30804:   rv = aCursor->GetHeight(&height);
30804:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6354:   // Reject cursors greater than 128 pixels in either direction, to prevent
    1:   // spoofing.
    1:   // XXX ideally we should rescale. Also, we could modify the API to
    1:   // allow trusted content to set larger cursors.
    1:   if (width > 128 || height > 128)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
30804:   HCURSOR cursor;
79420:   // No scaling
79420:   gfxIntSize size(0, 0);
79626:   rv = nsWindowGfx::CreateIcon(aCursor, true, aHotspotX, aHotspotY, size, &cursor);
30804:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mCursor = nsCursor(-1);
    1:   ::SetCursor(cursor);
    1: 
29835:   NS_IF_RELEASE(sCursorImgContainer);
29835:   sCursorImgContainer = aCursor;
29835:   NS_ADDREF(sCursorImgContainer);
29835: 
29835:   if (sHCursor != NULL)
29835:     ::DestroyIcon(sHCursor);
29835:   sHCursor = cursor;
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::Get/SetTransparencyMode
29835:  *
29835:  * Manage the transparency mode of the top-level window
29835:  * containing this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: #ifdef MOZ_XUL
29835: nsTransparencyMode nsWindow::GetTransparencyMode()
29835: {
79626:   return GetTopLevelWindow(true)->GetWindowTranslucencyInner();
29835: }
29835: 
29835: void nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
29835: {
79626:   GetTopLevelWindow(true)->SetWindowTranslucencyInner(aMode);
29835: }
39718: 
61413: static const nsIntRegion
61413: RegionFromArray(const nsTArray<nsIntRect>& aRects)
61413: {
61413:   nsIntRegion region;
61413:   for (PRUint32 i = 0; i < aRects.Length(); ++i) {
61413:     region.Or(region, aRects[i]);
61413:   }
61413:   return region;
61413: }
61413: 
69806: void nsWindow::UpdateOpaqueRegion(const nsIntRegion &aOpaqueRegion)
61413: {
61413:   if (!HasGlass() || GetParent())
39718:     return;
39718: 
46200:   // If there is no opaque region or hidechrome=true, set margins
61413:   // to support a full sheet of glass. Comments in MSDN indicate
61413:   // all values must be set to -1 to get a full sheet of glass.
61413:   MARGINS margins = { -1, -1, -1, -1 };
69806:   if (!aOpaqueRegion.IsEmpty()) {
59822:     nsIntRect pluginBounds;
59822:     for (nsIWidget* child = GetFirstChild(); child; child = child->GetNextSibling()) {
59822:       nsWindowType type;
59822:       child->GetWindowType(type);
59822:       if (type == eWindowType_plugin) {
61413:         // Collect the bounds of all plugins for GetLargestRectangle.
59822:         nsIntRect childBounds;
59822:         child->GetBounds(childBounds);
59822:         pluginBounds.UnionRect(pluginBounds, childBounds);
59822:       }
59822:     }
59822: 
69806:     nsIntRect clientBounds;
69806:     GetClientBounds(clientBounds);
69806: 
59822:     // Find the largest rectangle and use that to calculate the inset. Our top
59822:     // priority is to include the bounds of all plugins.
69806:     nsIntRect largest = aOpaqueRegion.GetLargestRectangle(pluginBounds);
39718:     margins.cxLeftWidth = largest.x;
39718:     margins.cxRightWidth = clientBounds.width - largest.XMost();
39718:     margins.cyBottomHeight = clientBounds.height - largest.YMost();
57439:     if (mCustomNonClient) {
51610:       // The minimum glass height must be the caption buttons height,
51610:       // otherwise the buttons are drawn incorrectly.
72496:       largest.y = NS_MAX<PRUint32>(largest.y,
56099:                          nsUXThemeData::sCommandButtons[CMDBUTTONIDX_BUTTONBOX].cy);
39718:     }
57439:     margins.cyTopHeight = largest.y;
57439:   }
46200: 
46200:   // Only update glass area if there are changes
39718:   if (memcmp(&mGlassMargins, &margins, sizeof mGlassMargins)) {
39718:     mGlassMargins = margins;
39718:     UpdateGlass();
39718:   }
39718: }
39718: 
46200: void nsWindow::UpdateGlass()
46200: {
50770:   MARGINS margins = mGlassMargins;
46200: 
46200:   // DWMNCRP_USEWINDOWSTYLE - The non-client rendering area is
46200:   //                          rendered based on the window style.
46200:   // DWMNCRP_ENABLED        - The non-client area rendering is
46200:   //                          enabled; the window style is ignored.
39718:   DWMNCRENDERINGPOLICY policy = DWMNCRP_USEWINDOWSTYLE;
50770:   switch (mTransparencyMode) {
50770:   case eTransparencyBorderlessGlass:
61976:     // Only adjust if there is some opaque rectangle
51144:     if (margins.cxLeftWidth >= 0) {
61976:       margins.cxLeftWidth += kGlassMarginAdjustment;
61976:       margins.cyTopHeight += kGlassMarginAdjustment;
61976:       margins.cxRightWidth += kGlassMarginAdjustment;
61976:       margins.cyBottomHeight += kGlassMarginAdjustment;
50770:     }
50770:     // Fall through
50770:   case eTransparencyGlass:
39718:     policy = DWMNCRP_ENABLED;
50770:     break;
39718:   }
46200: 
61412:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
61412:          ("glass margins: left:%d top:%d right:%d bottom:%d\n",
61412:           margins.cxLeftWidth, margins.cyTopHeight,
61412:           margins.cxRightWidth, margins.cyBottomHeight));
61412: 
46200:   // Extends the window frame behind the client area
39718:   if(nsUXThemeData::CheckForCompositor()) {
61413:     nsUXThemeData::dwmExtendFrameIntoClientAreaPtr(mWnd, &margins);
61413:     nsUXThemeData::dwmSetWindowAttributePtr(mWnd, DWMWA_NCRENDERING_POLICY, &policy, sizeof policy);
39718:   }
39718: }
29835: #endif
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::HideWindowChrome
29835:  *
29835:  * Show or hide window chrome.
29835:  *
29835:  **************************************************************/
29835: 
79445: NS_IMETHODIMP nsWindow::HideWindowChrome(bool aShouldHide)
    1: {
86569:   HWND hwnd = WinUtils::GetTopLevelHWND(mWnd, true);
86569:   if (!WinUtils::GetNSWindowPtr(hwnd))
    1:   {
    1:     NS_WARNING("Trying to hide window decorations in an embedded context");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
46335:   if (mHideChrome == aShouldHide)
46335:     return NS_OK;
46335: 
25349:   DWORD_PTR style, exStyle;
46200:   mHideChrome = aShouldHide;
    1:   if (aShouldHide) {
25349:     DWORD_PTR tempStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
25349:     DWORD_PTR tempExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
    1: 
46234:     style = tempStyle & ~(WS_CAPTION | WS_THICKFRAME);
    1:     exStyle = tempExStyle & ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE |
    1:                               WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
    1: 
    1:     mOldStyle = tempStyle;
    1:     mOldExStyle = tempExStyle;
    1:   }
    1:   else {
46234:     if (!mOldStyle || !mOldExStyle) {
25349:       mOldStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
25349:       mOldExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
46234:     }
    1: 
    1:     style = mOldStyle;
    1:     exStyle = mOldExStyle;
    1:   }
    1: 
19016:   VERIFY_WINDOW_STYLE(style);
25349:   ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);
25349:   ::SetWindowLongPtrW(hwnd, GWL_EXSTYLE, exStyle);
    1: 
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
80035:  * SECTION: nsWindow::Invalidate
29835:  *
32293:  * Invalidate an area of the client for painting.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Invalidate this component visible area
87336: NS_METHOD nsWindow::Invalidate(bool aEraseBackground, 
80035:                                bool aUpdateNCArea,
80035:                                bool aIncludeChildren)
80035: {
80035:   if (!mWnd) {
80035:     return NS_OK;
80035:   }
80035: 
29835: #ifdef WIDGET_DEBUG_OUTPUT
    1:   debug_DumpInvalidate(stdout,
    1:                        this,
    1:                        nsnull,
    1:                        nsCAutoString("noname"),
    1:                        (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
37619: 
80035:   DWORD flags = RDW_INVALIDATE;
80035:   if (aEraseBackground) {
80035:     flags |= RDW_ERASE;
80035:   }
80035:   if (aUpdateNCArea) {
80035:     flags |= RDW_FRAME;
80035:   }
80035:   if (aIncludeChildren) {
80035:     flags |= RDW_ALLCHILDREN;
80035:   }
80035: 
80035:   VERIFY(::RedrawWindow(mWnd, NULL, NULL, flags));
    1:   return NS_OK;
    1: }
    1: 
    1: // Invalidate this component visible area
87336: NS_METHOD nsWindow::Invalidate(const nsIntRect & aRect)
    1: {
    1:   if (mWnd)
    1:   {
29835: #ifdef WIDGET_DEBUG_OUTPUT
    1:     debug_DumpInvalidate(stdout,
    1:                          this,
    1:                          &aRect,
    1:                          nsCAutoString("noname"),
    1:                          (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
    1: 
    1:     RECT rect;
    1: 
    1:     rect.left   = aRect.x;
    1:     rect.top    = aRect.y;
    1:     rect.right  = aRect.x + aRect.width;
    1:     rect.bottom = aRect.y + aRect.height;
    1: 
    1:     VERIFY(::InvalidateRect(mWnd, &rect, FALSE));
    1:   }
    1:   return NS_OK;
    1: }
    1: 
30075: NS_IMETHODIMP
79445: nsWindow::MakeFullScreen(bool aFullScreen)
30075: {
77693:   // taskbarInfo will be NULL pre Windows 7 until Bug 680227 is resolved.
77693:   nsCOMPtr<nsIWinTaskbar> taskbarInfo =
77693:     do_GetService(NS_TASKBAR_CONTRACTID);
77693: 
52096:   mFullscreenMode = aFullScreen;
46335:   if (aFullScreen) {
51547:     if (mSizeMode == nsSizeMode_Fullscreen)
51547:       return NS_OK;
46335:     mOldSizeMode = mSizeMode;
46335:     SetSizeMode(nsSizeMode_Fullscreen);
77693: 
77693:     // Notify the taskbar that we will be entering full screen mode.
77693:     if (taskbarInfo) {
77693:       taskbarInfo->PrepareFullScreenHWND(mWnd, TRUE);
77693:     }
46335:   } else {
46335:     SetSizeMode(mOldSizeMode);
46335:   }
46335: 
46335:   UpdateNonClientMargins();
46335: 
79445:   bool visible = mIsVisible;
67849:   if (mOldSizeMode == nsSizeMode_Normal)
79626:     Show(false);
53999:   
46335:   // Will call hide chrome, reposition window. Note this will
46335:   // also cache dimensions for restoration, so it should only
46335:   // be called once per fullscreen request.
51547:   nsresult rv = nsBaseWidget::MakeFullScreen(aFullScreen);
51547: 
64073:   if (visible) {
79626:     Show(true);
87336:     Invalidate();
53999:   }
53999: 
77693:   // Notify the taskbar that we have exited full screen mode.
77693:   if (!aFullScreen && taskbarInfo) {
77693:     taskbarInfo->PrepareFullScreenHWND(mWnd, FALSE);
77693:   }
77693: 
51547:   // Let the dom know via web shell window
79626:   nsSizeModeEvent event(true, NS_SIZEMODE, this);
51547:   event.mSizeMode = mSizeMode;
51547:   InitEvent(event);
51547:   DispatchWindowEvent(&event);
51547: 
51547:   return rv;
30075: }
30075: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Native data storage
29835:  *
29835:  * nsIWidget::GetNativeData
29835:  * nsIWidget::FreeNativeData
29835:  *
29835:  * Set or clear native data based on a constant.
29835:  *
29835:  **************************************************************/
29835: 
    1: // Return some native data according to aDataType
    1: void* nsWindow::GetNativeData(PRUint32 aDataType)
    1: {
57092:   nsAutoString className;
    1:   switch (aDataType) {
52079:     case NS_NATIVE_TMP_WINDOW:
57092:       GetWindowClass(className);
54349:       return (void*)::CreateWindowExW(mIsRTL ? WS_EX_LAYOUTRTL : 0,
57092:                                       className.get(),
52079:                                       L"",
52079:                                       WS_CHILD,
52079:                                       CW_USEDEFAULT,
52079:                                       CW_USEDEFAULT,
52079:                                       CW_USEDEFAULT,
52079:                                       CW_USEDEFAULT,
52079:                                       mWnd,
52079:                                       NULL,
52079:                                       nsToolkit::mDllInstance,
52079:                                       NULL);
21999:     case NS_NATIVE_PLUGIN_PORT:
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_WINDOW:
77658:     case NS_NATIVE_SHAREABLE_WINDOW:
    1:       return (void*)mWnd;
    1:     case NS_NATIVE_GRAPHIC:
    1:       // XXX:  This is sleezy!!  Remember to Release the DC after using it!
    1: #ifdef MOZ_XUL
16601:       return (void*)(eTransparencyTransparent == mTransparencyMode) ?
    1:         mMemoryDC : ::GetDC(mWnd);
    1: #else
    1:       return (void*)::GetDC(mWnd);
    1: #endif
24836: 
24836: #ifdef NS_ENABLE_TSF
25395:     case NS_NATIVE_TSF_THREAD_MGR:
25395:       return nsTextStore::GetThreadMgr();
25395:     case NS_NATIVE_TSF_CATEGORY_MGR:
25395:       return nsTextStore::GetCategoryMgr();
25395:     case NS_NATIVE_TSF_DISPLAY_ATTR_MGR:
25395:       return nsTextStore::GetDisplayAttrMgr();
24836: #endif //NS_ENABLE_TSF
24836: 
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   return NULL;
    1: }
    1: 
29835: // Free some native data according to aDataType
    1: void nsWindow::FreeNativeData(void * data, PRUint32 aDataType)
    1: {
    1:   switch (aDataType)
    1:   {
    1:     case NS_NATIVE_GRAPHIC:
    1: #ifdef MOZ_XUL
16601:       if (eTransparencyTransparent != mTransparencyMode)
    1:         ::ReleaseDC(mWnd, (HDC)data);
    1: #else
    1:       ::ReleaseDC(mWnd, (HDC)data);
    1: #endif
    1:       break;
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_WINDOW:
    1:     case NS_NATIVE_PLUGIN_PORT:
    1:       break;
    1:     default:
    1:       break;
    1:   }
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetTitle
29835:  *
29835:  * Set the main windows title text.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
29835: {
29835:   const nsString& strTitle = PromiseFlatString(aTitle);
29835:   ::SendMessageW(mWnd, WM_SETTEXT, (WPARAM)0, (LPARAM)(LPCWSTR)strTitle.get());
    1:   return NS_OK;
    1: }
    1: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::SetIcon
29835:  *
29835:  * Set the main windows icon.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_METHOD nsWindow::SetIcon(const nsAString& aIconSpec) 
29835: {
29835:   // Assume the given string is a local identifier for an icon file.
29835: 
29835:   nsCOMPtr<nsILocalFile> iconFile;
29835:   ResolveIconName(aIconSpec, NS_LITERAL_STRING(".ico"),
29835:                   getter_AddRefs(iconFile));
29835:   if (!iconFile)
29835:     return NS_OK; // not an error if icon is not found
29835: 
29835:   nsAutoString iconPath;
29835:   iconFile->GetPath(iconPath);
29835: 
29835:   // XXX this should use MZLU (see bug 239279)
29835: 
29835:   ::SetLastError(0);
29835: 
29835:   HICON bigIcon = (HICON)::LoadImageW(NULL,
29835:                                       (LPCWSTR)iconPath.get(),
29835:                                       IMAGE_ICON,
29835:                                       ::GetSystemMetrics(SM_CXICON),
29835:                                       ::GetSystemMetrics(SM_CYICON),
29835:                                       LR_LOADFROMFILE );
29835:   HICON smallIcon = (HICON)::LoadImageW(NULL,
29835:                                         (LPCWSTR)iconPath.get(),
29835:                                         IMAGE_ICON,
29835:                                         ::GetSystemMetrics(SM_CXSMICON),
29835:                                         ::GetSystemMetrics(SM_CYSMICON),
29835:                                         LR_LOADFROMFILE );
29835: 
29835:   if (bigIcon) {
29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)bigIcon);
29835:     if (icon)
29835:       ::DestroyIcon(icon);
29835:   }
29835: #ifdef DEBUG_SetIcon
29835:   else {
29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:            ("\nIcon load error; icon=%s, rc=0x%08X\n\n", 
76714:             cPath.get(), ::GetLastError()));
29835:   }
29835: #endif
29835:   if (smallIcon) {
29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)smallIcon);
29835:     if (icon)
29835:       ::DestroyIcon(icon);
29835:   }
29835: #ifdef DEBUG_SetIcon
29835:   else {
29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:            ("\nSmall icon load error; icon=%s, rc=0x%08X\n\n", 
76714:             cPath.get(), ::GetLastError()));
29835:   }
29835: #endif
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::WidgetToScreenOffset
29835:  *
29835:  * Return this widget's origin in screen coordinates.
29835:  *
29835:  **************************************************************/
29835: 
29835: nsIntPoint nsWindow::WidgetToScreenOffset()
29835: {
29835:   POINT point;
29835:   point.x = 0;
29835:   point.y = 0;
29835:   ::ClientToScreen(mWnd, &point);
29835:   return nsIntPoint(point.x, point.y);
29835: }
29835: 
48256: nsIntSize nsWindow::ClientToWindowSize(const nsIntSize& aClientSize)
48256: {
48256:   if (!IsPopupWithTitleBar())
48256:     return aClientSize;
48256: 
48256:   // just use (200, 200) as the position
48256:   RECT r;
48256:   r.left = 200;
48256:   r.top = 200;
48256:   r.right = 200 + aClientSize.width;
48256:   r.bottom = 200 + aClientSize.height;
79626:   ::AdjustWindowRectEx(&r, WindowStyle(), false, WindowExStyle());
48256: 
48256:   return nsIntSize(r.right - r.left, r.bottom - r.top);
48256: }
48256: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::EnableDragDrop
29835:  *
29835:  * Enables/Disables drag and drop of files on this widget.
29835:  *
29835:  **************************************************************/
29835: 
79445: NS_METHOD nsWindow::EnableDragDrop(bool aEnable)
29835: {
43018:   NS_ASSERTION(mWnd, "nsWindow::EnableDragDrop() called after Destroy()");
43018: 
29835:   nsresult rv = NS_ERROR_FAILURE;
29835:   if (aEnable) {
29835:     if (nsnull == mNativeDragTarget) {
29835:        mNativeDragTarget = new nsNativeDragTarget(this);
29835:        if (NULL != mNativeDragTarget) {
29835:          mNativeDragTarget->AddRef();
29835:          if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget,TRUE,FALSE)) {
29835:            if (S_OK == ::RegisterDragDrop(mWnd, (LPDROPTARGET)mNativeDragTarget)) {
29835:              rv = NS_OK;
29835:            }
29835:          }
29835:        }
29835:     }
29835:   } else {
29835:     if (nsnull != mWnd && NULL != mNativeDragTarget) {
29835:       ::RevokeDragDrop(mWnd);
29835:       if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget, FALSE, TRUE)) {
29835:         rv = NS_OK;
29835:       }
43018:       mNativeDragTarget->DragCancel();
29835:       NS_RELEASE(mNativeDragTarget);
29835:     }
29835:   }
29835:   return rv;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::CaptureMouse
29835:  *
29835:  * Enables/Disables system mouse capture.
29835:  *
29835:  **************************************************************/
29835: 
79445: NS_METHOD nsWindow::CaptureMouse(bool aCapture)
29835: {
29835:   if (!nsToolkit::gMouseTrailer) {
29835:     NS_ERROR("nsWindow::CaptureMouse called after nsToolkit destroyed");
29835:     return NS_OK;
29835:   }
29835: 
29835:   if (aCapture) {
29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(mWnd);
29835:     ::SetCapture(mWnd);
29835:   } else {
29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(NULL);
29835:     ::ReleaseCapture();
29835:   }
60909:   sIsInMouseCapture = aCapture;
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::CaptureRollupEvents
29835:  *
29835:  * Dealing with event rollup on destroy for popups. Enables &
29835:  * Disables system capture of any and all events that would
29835:  * cause a dropdown to be rolled up.
29835:  *
29835:  **************************************************************/
29835: 
29835: NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener * aListener,
79445:                                             bool aDoCapture,
79445:                                             bool aConsumeRollupEvent)
29835: {
29835:   if (aDoCapture) {
29835:     /* we haven't bothered carrying a weak reference to sRollupWidget because
29835:        we believe lifespan is properly scoped. this next assertion helps
29835:        assure that remains true. */
29835:     NS_ASSERTION(!sRollupWidget, "rollup widget reassigned before release");
29835:     sRollupConsumeEvent = aConsumeRollupEvent;
29835:     NS_IF_RELEASE(sRollupWidget);
29835:     sRollupListener = aListener;
29835:     sRollupWidget = this;
29835:     NS_ADDREF(this);
29835:     if (!sMsgFilterHook && !sCallProcHook && !sCallMouseHook) {
29835:       RegisterSpecialDropdownHooks();
29835:     }
79626:     sProcessHook = true;
29835:   } else {
36806:     sRollupListener = nsnull;
29835:     NS_IF_RELEASE(sRollupWidget);
79626:     sProcessHook = false;
29835:     UnregisterSpecialDropdownHooks();
29835:   }
29835: 
29835:   return NS_OK;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::GetAttention
29835:  *
29835:  * Bring this window to the user's attention.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Draw user's attention to this window until it comes to foreground.
29835: NS_IMETHODIMP
29835: nsWindow::GetAttention(PRInt32 aCycleCount)
29835: {
29835:   // Got window?
29835:   if (!mWnd)
29835:     return NS_ERROR_NOT_INITIALIZED;
29835: 
86569:   HWND flashWnd = WinUtils::GetTopLevelHWND(mWnd, false, false);
29835:   HWND fgWnd = ::GetForegroundWindow();
80121:   // Don't flash if the flash count is 0 or if the foreground window is our
80121:   // window handle or that of our owned-most window.
80121:   if (aCycleCount == 0 || 
80121:       flashWnd == fgWnd ||
86569:       flashWnd == WinUtils::GetTopLevelHWND(fgWnd, false, false)) {
29835:     return NS_OK;
80121:   }
29835: 
29835:   DWORD defaultCycleCount = 0;
29835:   ::SystemParametersInfo(SPI_GETFOREGROUNDFLASHCOUNT, 0, &defaultCycleCount, 0);
29835: 
29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
29835:     FLASHW_ALL, aCycleCount > 0 ? aCycleCount : defaultCycleCount, 0 };
29835:   ::FlashWindowEx(&flashInfo);
68855: 
29835:   return NS_OK;
29835: }
29835: 
29835: void nsWindow::StopFlashing()
29835: {
29835:   HWND flashWnd = mWnd;
29835:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
29835:     flashWnd = ownerWnd;
29835:   }
29835: 
29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
29835:     FLASHW_STOP, 0, 0 };
29835:   ::FlashWindowEx(&flashInfo);
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsIWidget::HasPendingInputEvent
29835:  *
29835:  * Ask whether there user input events pending.  All input events are
29835:  * included, including those not targeted at this nsIwidget instance.
29835:  *
29835:  **************************************************************/
29835: 
79445: bool
29835: nsWindow::HasPendingInputEvent()
29835: {
29835:   // If there is pending input or the user is currently
29835:   // moving the window then return true.
29835:   // Note: When the user is moving the window WIN32 spins
29835:   // a separate event loop and input events are not
29835:   // reported to the application.
30504:   if (HIWORD(GetQueueStatus(QS_INPUT)))
79626:     return true;
30504:   GUITHREADINFO guiInfo;
30504:   guiInfo.cbSize = sizeof(GUITHREADINFO);
30504:   if (!GetGUIThreadInfo(GetCurrentThreadId(), &guiInfo))
79626:     return false;
30504:   return GUI_INMOVESIZE == (guiInfo.flags & GUI_INMOVESIZE);
29835: }
29835: 
29835: /**************************************************************
29835:  *
40028:  * SECTION: nsIWidget::GetLayerManager
40028:  *
40028:  * Get the layer manager associated with this widget.
40028:  *
40028:  **************************************************************/
40028: 
60398: struct LayerManagerPrefs {
60398:   LayerManagerPrefs()
79626:     : mAccelerateByDefault(true)
79626:     , mDisableAcceleration(false)
79626:     , mPreferOpenGL(false)
79626:     , mPreferD3D9(false)
60398:   {}
79445:   bool mAccelerateByDefault;
79445:   bool mDisableAcceleration;
79445:   bool mForceAcceleration;
79445:   bool mPreferOpenGL;
79445:   bool mPreferD3D9;
60398: };
60398: 
60398: static void
60398: GetLayerManagerPrefs(LayerManagerPrefs* aManagerPrefs)
60398: {
70956:   Preferences::GetBool("layers.acceleration.disabled",
60398:                        &aManagerPrefs->mDisableAcceleration);
70956:   Preferences::GetBool("layers.acceleration.force-enabled",
60833:                        &aManagerPrefs->mForceAcceleration);
70956:   Preferences::GetBool("layers.prefer-opengl",
60398:                        &aManagerPrefs->mPreferOpenGL);
70956:   Preferences::GetBool("layers.prefer-d3d9",
60398:                        &aManagerPrefs->mPreferD3D9);
60398: 
60398:   const char *acceleratedEnv = PR_GetEnv("MOZ_ACCELERATED");
60398:   aManagerPrefs->mAccelerateByDefault =
60398:     aManagerPrefs->mAccelerateByDefault ||
60398:     (acceleratedEnv && (*acceleratedEnv != '0'));
60398: 
79445:   bool safeMode = false;
60398:   nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
60398:   if (xr)
60398:     xr->GetInSafeMode(&safeMode);
60398:   aManagerPrefs->mDisableAcceleration =
60398:     aManagerPrefs->mDisableAcceleration || safeMode;
60398: }
60398: 
75149: LayerManager*
75149: nsWindow::GetLayerManager(PLayersChild* aShadowManager,
75149:                           LayersBackend aBackendHint,
75149:                           LayerManagerPersistence aPersistence,
75149:                           bool* aAllowRetaining)
55858: {
55858:   if (aAllowRetaining) {
55858:     *aAllowRetaining = true;
55858:   }
55858: 
57918: #ifdef MOZ_ENABLE_D3D10_LAYER
57918:   if (mLayerManager) {
57918:     if (mLayerManager->GetBackendType() ==
57918:         mozilla::layers::LayerManager::LAYERS_D3D10)
57918:     {
57918:       mozilla::layers::LayerManagerD3D10 *layerManagerD3D10 =
57918:         static_cast<mozilla::layers::LayerManagerD3D10*>(mLayerManager.get());
57918:       if (layerManagerD3D10->device() !=
57918:           gfxWindowsPlatform::GetPlatform()->GetD3D10Device())
57918:       {
58810:         mLayerManager->Destroy();
57918:         mLayerManager = nsnull;
57918:       }
57918:     }
57918:   }
57918: #endif
57918: 
79695:   RECT windowRect;
79695:   ::GetClientRect(mWnd, &windowRect);
79695: 
58814:   if (!mLayerManager ||
58814:       (!sAllowD3D9 && aPersistence == LAYER_MANAGER_PERSISTENT &&
58814:         mLayerManager->GetBackendType() == 
58814:         mozilla::layers::LayerManager::LAYERS_BASIC)) {
58814:     // If D3D9 is not currently allowed but the permanent manager is required,
58814:     // -and- we're currently using basic layers, run through this check.
60398:     LayerManagerPrefs prefs;
60398:     GetLayerManagerPrefs(&prefs);
51978: 
51995:     /* We don't currently support using an accelerated layer manager with
51995:      * transparent windows so don't even try. I'm also not sure if we even
51995:      * want to support this case. See bug #593471 */
60398:     if (eTransparencyTransparent == mTransparencyMode ||
79695:         prefs.mDisableAcceleration ||
79695:         windowRect.right - windowRect.left > MAX_ACCELERATED_DIMENSION ||
79695:         windowRect.bottom - windowRect.top > MAX_ACCELERATED_DIMENSION)
79626:       mUseAcceleratedRendering = false;
60398:     else if (prefs.mAccelerateByDefault)
79626:       mUseAcceleratedRendering = true;
51655: 
51655:     if (mUseAcceleratedRendering) {
58814:       if (aPersistence == LAYER_MANAGER_PERSISTENT && !sAllowD3D9) {
58814:         // This will clear out our existing layer manager if we have one since
58814:         // if we hit this with a LayerManager we're always using BasicLayers.
58814:         nsToolkit::StartAllowingD3D9();
58814:       }
58814: 
54816: #ifdef MOZ_ENABLE_D3D10_LAYER
81596:       if (!prefs.mPreferD3D9 && !prefs.mPreferOpenGL) {
54816:         nsRefPtr<mozilla::layers::LayerManagerD3D10> layerManager =
54816:           new mozilla::layers::LayerManagerD3D10(this);
91135:         if (layerManager->Initialize(prefs.mForceAcceleration)) {
54816:           mLayerManager = layerManager;
54816:         }
54816:       }
54816: #endif
43174: #ifdef MOZ_ENABLE_D3D9_LAYER
60398:       if (!prefs.mPreferOpenGL && !mLayerManager && sAllowD3D9) {
43174:         nsRefPtr<mozilla::layers::LayerManagerD3D9> layerManager =
43174:           new mozilla::layers::LayerManagerD3D9(this);
91135:         if (layerManager->Initialize(prefs.mForceAcceleration)) {
43174:           mLayerManager = layerManager;
43174:         }
43174:       }
43174: #endif
60398:       if (!mLayerManager && prefs.mPreferOpenGL) {
60833:         nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
60833:         PRInt32 status = nsIGfxInfo::FEATURE_NO_INFO;
60833: 
60833:         if (gfxInfo && !prefs.mForceAcceleration) {
60833:           gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_OPENGL_LAYERS, &status);
60833:         }
60833: 
60833:         if (status == nsIGfxInfo::FEATURE_NO_INFO) {
42612:           nsRefPtr<mozilla::layers::LayerManagerOGL> layerManager =
42612:             new mozilla::layers::LayerManagerOGL(this);
42612:           if (layerManager->Initialize()) {
42612:             mLayerManager = layerManager;
42612:           }
60833: 
60833:         } else {
60833:           NS_WARNING("OpenGL accelerated layers are not supported on this system.");
60833:         }
42612:       }
42612:     }
51995: 
51995:     // Fall back to software if we couldn't use any hardware backends.
51995:     if (!mLayerManager)
54111:       mLayerManager = CreateBasicLayerManager();
51995:   }
51995: 
79629:   NS_ASSERTION(mLayerManager, "Couldn't provide a valid layer manager.");
79629: 
51995:   return mLayerManager;
40028: }
40028: 
40028: /**************************************************************
40028:  *
29835:  * SECTION: nsIWidget::GetThebesSurface
29835:  *
29835:  * Get the Thebes surface associated with this widget.
29835:  *
29835:  **************************************************************/
29835: 
29835: gfxASurface *nsWindow::GetThebesSurface()
29835: {
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:   if (mD2DWindowSurface) {
38727:     return mD2DWindowSurface;
38727:   }
38727: #endif
29835:   if (mPaintDC)
29835:     return (new gfxWindowsSurface(mPaintDC));
29835: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
38727:       gfxWindowsPlatform::RENDER_DIRECT2D) {
43397:     gfxASurface::gfxContentType content = gfxASurface::CONTENT_COLOR;
43397: #if defined(MOZ_XUL)
43397:     if (mTransparencyMode != eTransparencyOpaque) {
43397:       content = gfxASurface::CONTENT_COLOR_ALPHA;
43397:     }
43397: #endif
43397:     return (new gfxD2DSurface(mWnd, content));
38727:   } else {
38727: #endif
47767:     PRUint32 flags = gfxWindowsSurface::FLAG_TAKE_DC;
47767:     if (mTransparencyMode != eTransparencyOpaque) {
47767:         flags |= gfxWindowsSurface::FLAG_IS_TRANSPARENT;
47767:     }
47767:     return (new gfxWindowsSurface(mWnd, flags));
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:   }
38727: #endif
29835: }
29835: 
29835: /**************************************************************
30327:  *
30327:  * SECTION: nsIWidget::OnDefaultButtonLoaded
30327:  *
30327:  * Called after the dialog is loaded and it has a default button.
30327:  *
30327:  **************************************************************/
30327:  
30327: NS_IMETHODIMP
30327: nsWindow::OnDefaultButtonLoaded(const nsIntRect &aButtonRect)
30327: {
30327:   if (aButtonRect.IsEmpty())
30327:     return NS_OK;
30327: 
30327:   // Don't snap when we are not active.
30327:   HWND activeWnd = ::GetActiveWindow();
30327:   if (activeWnd != ::GetForegroundWindow() ||
86569:       WinUtils::GetTopLevelHWND(mWnd, true) !=
86569:         WinUtils::GetTopLevelHWND(activeWnd, true)) {
30327:     return NS_OK;
30327:   }
30327: 
79445:   bool isAlwaysSnapCursor =
79445:     Preferences::GetBool("ui.cursor_snapping.always_enabled", false);
30327: 
30327:   if (!isAlwaysSnapCursor) {
30327:     BOOL snapDefaultButton;
30327:     if (!::SystemParametersInfo(SPI_GETSNAPTODEFBUTTON, 0,
30327:                                 &snapDefaultButton, 0) || !snapDefaultButton)
30327:       return NS_OK;
30327:   }
30327: 
30327:   nsIntRect widgetRect;
30327:   nsresult rv = GetScreenBounds(widgetRect);
30327:   NS_ENSURE_SUCCESS(rv, rv);
30327:   nsIntRect buttonRect(aButtonRect + widgetRect.TopLeft());
30327: 
30327:   nsIntPoint centerOfButton(buttonRect.x + buttonRect.width / 2,
30327:                             buttonRect.y + buttonRect.height / 2);
30327:   // The center of the button can be outside of the widget.
30327:   // E.g., it could be hidden by scrolling.
30327:   if (!widgetRect.Contains(centerOfButton)) {
30327:     return NS_OK;
30327:   }
30327: 
30327:   if (!::SetCursorPos(centerOfButton.x, centerOfButton.y)) {
30327:     NS_ERROR("SetCursorPos failed");
30327:     return NS_ERROR_FAILURE;
30327:   }
30327:   return NS_OK;
30327: }
30327: 
33016: NS_IMETHODIMP
33016: nsWindow::OverrideSystemMouseScrollSpeed(PRInt32 aOriginalDelta,
79445:                                          bool aIsHorizontal,
33016:                                          PRInt32 &aOverriddenDelta)
33016: {
33016:   // The default vertical and horizontal scrolling speed is 3, this is defined
33016:   // on the document of SystemParametersInfo in MSDN.
51212:   const PRUint32 kSystemDefaultScrollingSpeed = 3;
33016: 
72496:   PRInt32 absOriginDelta = NS_ABS(aOriginalDelta);
37978: 
33016:   // Compute the simple overridden speed.
37978:   PRInt32 absComputedOverriddenDelta;
33016:   nsresult rv =
37978:     nsBaseWidget::OverrideSystemMouseScrollSpeed(absOriginDelta, aIsHorizontal,
37978:                                                  absComputedOverriddenDelta);
33016:   NS_ENSURE_SUCCESS(rv, rv);
33016: 
33016:   aOverriddenDelta = aOriginalDelta;
33016: 
37978:   if (absComputedOverriddenDelta == absOriginDelta) {
33016:     // We don't override now.
33016:     return NS_OK;
33016:   }
33016: 
33016:   // Otherwise, we should check whether the user customized the system settings
33016:   // or not.  If the user did it, we should respect the will.
33016:   UINT systemSpeed;
33016:   if (!::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &systemSpeed, 0)) {
33016:     return NS_ERROR_FAILURE;
33016:   }
33016:   // The default vertical scrolling speed is 3, this is defined on the document
33016:   // of SystemParametersInfo in MSDN.
33016:   if (systemSpeed != kSystemDefaultScrollingSpeed) {
33016:     return NS_OK;
33016:   }
33016: 
33016:   // Only Vista and later, Windows has the system setting of horizontal
33016:   // scrolling by the mouse wheel.
86569:   if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION) {
33016:     if (!::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0, &systemSpeed, 0)) {
33016:       return NS_ERROR_FAILURE;
33016:     }
33016:     // The default horizontal scrolling speed is 3, this is defined on the
33016:     // document of SystemParametersInfo in MSDN.
33016:     if (systemSpeed != kSystemDefaultScrollingSpeed) {
33016:       return NS_OK;
33016:     }
33016:   }
33016: 
33016:   // Limit the overridden delta value from the system settings.  The mouse
33016:   // driver might accelerate the scrolling speed already.  If so, we shouldn't
33016:   // override the scrolling speed for preventing the unexpected high speed
33016:   // scrolling.
37978:   PRInt32 absDeltaLimit;
33016:   rv =
33016:     nsBaseWidget::OverrideSystemMouseScrollSpeed(kSystemDefaultScrollingSpeed,
37978:                                                  aIsHorizontal, absDeltaLimit);
33016:   NS_ENSURE_SUCCESS(rv, rv);
33016: 
37978:   // If the given delta is larger than our computed limitation value, the delta
37978:   // was accelerated by the mouse driver.  So, we should do nothing here.
37978:   if (absDeltaLimit <= absOriginDelta) {
37978:     return NS_OK;
37978:   }
37978: 
37978:   absComputedOverriddenDelta =
72496:     NS_MIN(absComputedOverriddenDelta, absDeltaLimit);
37978: 
37978:   aOverriddenDelta = (aOriginalDelta > 0) ? absComputedOverriddenDelta :
37978:                                             -absComputedOverriddenDelta;
33016:   return NS_OK;
33016: }
33016: 
30327: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Moz Events
29835:  **
29835:  ** Moz GUI event management. 
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Mozilla event initialization
29835:  *
29835:  * Helpers for initializing moz events.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Event intialization
29835: void nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
29835: {
29835:   if (nsnull == aPoint) {     // use the point from the event
29835:     // get the message position in client coordinates
29835:     if (mWnd != NULL) {
29835: 
29835:       DWORD pos = ::GetMessagePos();
29835:       POINT cpos;
29835:       
29835:       cpos.x = GET_X_LPARAM(pos);
29835:       cpos.y = GET_Y_LPARAM(pos);
29835: 
29835:       ::ScreenToClient(mWnd, &cpos);
29835:       event.refPoint.x = cpos.x;
29835:       event.refPoint.y = cpos.y;
    1:     } else {
29835:       event.refPoint.x = 0;
29835:       event.refPoint.y = 0;
29835:     }
29835:   }
29835:   else {  
29835:     // use the point override if provided
29835:     event.refPoint.x = aPoint->x;
29835:     event.refPoint.y = aPoint->y;
29835:   }
29835: 
29835:   event.time = ::GetMessageTime();
29835:   mLastPoint = event.refPoint;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Moz event dispatch helpers
29835:  *
29835:  * Helpers for dispatching different types of moz events.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Main event dispatch. Invokes callback and ProcessEvent method on
29835: // Event Listener object. Part of nsIWidget.
29835: NS_IMETHODIMP nsWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus)
29835: {
29835: #ifdef WIDGET_DEBUG_OUTPUT
29835:   debug_DumpEvent(stdout,
29835:                   event->widget,
29835:                   event,
29835:                   nsCAutoString("something"),
29835:                   (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
29835: 
29835:   aStatus = nsEventStatus_eIgnore;
29835: 
29835:   // skip processing of suppressed blur events
29835:   if (event->message == NS_DEACTIVATE && BlurEventsSuppressed())
29835:     return NS_OK;
29835: 
46195:   // Top level windows can have a view attached which requires events be sent
46195:   // to the underlying base window and the view. Added when we combined the
46195:   // base chrome window with the main content child for nc client area (title
46195:   // bar) rendering.
46195:   if (mViewCallback) {
46195:     // A subset of events are sent to the base xul window first
46195:     switch(event->message) {
90615:       // sent to the base window, then to the view
90615:       case NS_SIZE:
90615:       case NS_DEACTIVATE:
90615:       case NS_ACTIVATE:
90615:       case NS_SIZEMODE:
46195:       case NS_UISTATECHANGED:
46195:       case NS_DESTROY:
46195:       case NS_SETZLEVEL:
46195:       case NS_XUL_CLOSE:
46195:       case NS_MOVE:
46195:         (*mEventCallback)(event); // web shell / xul window
46195:         break;
46195:     };
46195:     // attached view events
46195:     aStatus = (*mViewCallback)(event);
46195:   }
46195:   else if (mEventCallback) {
29835:     aStatus = (*mEventCallback)(event);
29835:   }
29835: 
29835:   // the window can be destroyed during processing of seemingly innocuous events like, say,
29835:   // mousedowns due to the magic of scripting. mousedowns will return nsEventStatus_eIgnore,
29835:   // which causes problems with the deleted window. therefore:
29835:   if (mOnDestroyCalled)
29835:     aStatus = nsEventStatus_eConsumeNoDefault;
29835:   return NS_OK;
29835: }
29835: 
79445: bool nsWindow::DispatchStandardEvent(PRUint32 aMsg)
29835: {
79626:   nsGUIEvent event(true, aMsg, this);
29835:   InitEvent(event);
29835: 
79445:   bool result = DispatchWindowEvent(&event);
29835:   return result;
29835: }
29835: 
79445: bool nsWindow::DispatchWindowEvent(nsGUIEvent* event)
29835: {
29835:   nsEventStatus status;
29835:   DispatchEvent(event, status);
29835:   return ConvertStatus(status);
29835: }
29835: 
79445: bool nsWindow::DispatchWindowEvent(nsGUIEvent* event, nsEventStatus &aStatus) {
29835:   DispatchEvent(event, aStatus);
29835:   return ConvertStatus(aStatus);
29835: }
29835: 
79445: bool nsWindow::DispatchKeyEvent(PRUint32 aEventType, WORD aCharCode,
14476:                    const nsTArray<nsAlternativeCharCode>* aAlternativeCharCodes,
22788:                    UINT aVirtualCharCode, const MSG *aMsg,
27961:                    const nsModifierKeyState &aModKeyState,
22788:                    PRUint32 aFlags)
    1: {
40944:   UserActivity();
40944: 
79626:   nsKeyEvent event(true, aEventType, this);
23738:   nsIntPoint point(0, 0);
    1: 
    1:   InitEvent(event, &point); // this add ref's event.widget
    1: 
    1:   event.flags |= aFlags;
    1:   event.charCode = aCharCode;
14476:   if (aAlternativeCharCodes)
14476:     event.alternativeCharCodes.AppendElements(*aAlternativeCharCodes);
    1:   event.keyCode  = aVirtualCharCode;
    1: 
    1: #ifdef KE_DEBUG
    1:   static cnt=0;
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:          ("%d DispatchKE Type: %s charCode %d  keyCode %d ", cnt++, 
76714:           NS_KEY_PRESS == aEventType ? "PRESS : 
76714:                                        (aEventType == NS_KEY_UP ? "Up" : "Down"),
76714:           event.charCode, event.keyCode));
76714: 
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:          ("Shift: %s Control %s Alt: %s \n", (mIsShiftDown ? "D" : "U"), 
76714:          (mIsControlDown ? "D" : "U"), (mIsAltDown ? "D" : "U")));
76714: 
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:          ("[%c][%c][%c] <==   [%c][%c][%c][ space bar ][%c][%c][%c]\n",
    1:           IS_VK_DOWN(NS_VK_SHIFT) ? 'S' : ' ',
    1:           IS_VK_DOWN(NS_VK_CONTROL) ? 'C' : ' ',
    1:           IS_VK_DOWN(NS_VK_ALT) ? 'A' : ' ',
    1:           IS_VK_DOWN(VK_LSHIFT) ? 'S' : ' ',
    1:           IS_VK_DOWN(VK_LCONTROL) ? 'C' : ' ',
    1:           IS_VK_DOWN(VK_LMENU) ? 'A' : ' ',
    1:           IS_VK_DOWN(VK_RMENU) ? 'A' : ' ',
    1:           IS_VK_DOWN(VK_RCONTROL) ? 'C' : ' ',
76714:           IS_VK_DOWN(VK_RSHIFT) ? 'S' : ' '));
    1: #endif
    1: 
27961:   event.isShift   = aModKeyState.mIsShiftDown;
27961:   event.isControl = aModKeyState.mIsControlDown;
79626:   event.isMeta    = false;
27961:   event.isAlt     = aModKeyState.mIsAltDown;
    1: 
32799:   NPEvent pluginEvent;
22788:   if (aMsg && PluginHasFocus()) {
22788:     pluginEvent.event = aMsg->message;
22788:     pluginEvent.wParam = aMsg->wParam;
22788:     pluginEvent.lParam = aMsg->lParam;
34743:     event.pluginEvent = (void *)&pluginEvent;
22788:   }
    1: 
79445:   bool result = DispatchWindowEvent(&event);
    1: 
    1:   return result;
    1: }
    1: 
79445: bool nsWindow::DispatchCommandEvent(PRUint32 aEventCommand)
29835: {
29835:   nsCOMPtr<nsIAtom> command;
29835:   switch (aEventCommand) {
29835:     case APPCOMMAND_BROWSER_BACKWARD:
80435:       command = nsGkAtoms::Back;
29835:       break;
29835:     case APPCOMMAND_BROWSER_FORWARD:
80435:       command = nsGkAtoms::Forward;
29835:       break;
29835:     case APPCOMMAND_BROWSER_REFRESH:
80435:       command = nsGkAtoms::Reload;
29835:       break;
29835:     case APPCOMMAND_BROWSER_STOP:
80435:       command = nsGkAtoms::Stop;
29835:       break;
29835:     case APPCOMMAND_BROWSER_SEARCH:
80435:       command = nsGkAtoms::Search;
29835:       break;
29835:     case APPCOMMAND_BROWSER_FAVORITES:
80435:       command = nsGkAtoms::Bookmarks;
29835:       break;
29835:     case APPCOMMAND_BROWSER_HOME:
80435:       command = nsGkAtoms::Home;
29835:       break;
29835:     default:
79626:       return false;
79626:   }
80435:   nsCommandEvent event(true, nsGkAtoms::onAppCommand, command, this);
29835: 
29835:   InitEvent(event);
29835:   DispatchWindowEvent(&event);
29835: 
79626:   return true;
29835: }
29835: 
29835: // Recursively dispatch synchronous paints for nsIWidget
29835: // descendants with invalidated rectangles.
29835: BOOL CALLBACK nsWindow::DispatchStarvedPaints(HWND aWnd, LPARAM aMsg)
29835: {
29835:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
29835:   if (proc == (LONG_PTR)&nsWindow::WindowProc) {
29835:     // its one of our windows so check to see if it has a
29835:     // invalidated rect. If it does. Dispatch a synchronous
29835:     // paint.
37613:     if (GetUpdateRect(aWnd, NULL, FALSE))
29835:       VERIFY(::UpdateWindow(aWnd));
29835:   }
29835:   return TRUE;
29835: }
29835: 
29835: // Check for pending paints and dispatch any pending paint
29835: // messages for any nsIWidget which is a descendant of the
29835: // top-level window that *this* window is embedded within.
29835: //
29835: // Note: We do not dispatch pending paint messages for non
29835: // nsIWidget managed windows.
29835: void nsWindow::DispatchPendingEvents()
29835: {
35287:   if (mPainting) {
35287:     NS_WARNING("We were asked to dispatch pending events during painting, "
35287:                "denying since that's unsafe.");
35287:     return;
35287:   }
35287: 
29835:   // We need to ensure that reflow events do not get starved.
29835:   // At the same time, we don't want to recurse through here
29835:   // as that would prevent us from dispatching starved paints.
29835:   static int recursionBlocker = 0;
29835:   if (recursionBlocker++ == 0) {
29835:     NS_ProcessPendingEvents(nsnull, PR_MillisecondsToInterval(100));
29835:     --recursionBlocker;
29835:   }
29835: 
87254:   // Quickly check to see if there are any paint events pending,
87254:   // but only dispatch them if it has been long enough since the
87254:   // last paint completed.
87254:   if (::GetQueueStatus(QS_PAINT) &&
87254:       ((TimeStamp::Now() - mLastPaintEndTime).ToMilliseconds() >= 50)) {
29835:     // Find the top level window.
86569:     HWND topWnd = WinUtils::GetTopLevelHWND(mWnd);
29835: 
55226:     // Dispatch pending paints for topWnd and all its descendant windows.
29835:     // Note: EnumChildWindows enumerates all descendant windows not just
55226:     // the children (but not the window itself).
55226:     nsWindow::DispatchStarvedPaints(topWnd, 0);
51212:     ::EnumChildWindows(topWnd, nsWindow::DispatchStarvedPaints, 0);
29835:   }
29835: }
29835: 
29835: // Deal with plugin events
79445: bool nsWindow::DispatchPluginEvent(const MSG &aMsg)
29835: {
29835:   if (!PluginHasFocus())
79626:     return false;
79626: 
79626:   nsPluginEvent event(true, NS_PLUGIN_INPUT_EVENT, this);
29835:   nsIntPoint point(0, 0);
29835:   InitEvent(event, &point);
32799:   NPEvent pluginEvent;
29835:   pluginEvent.event = aMsg.message;
29835:   pluginEvent.wParam = aMsg.wParam;
29835:   pluginEvent.lParam = aMsg.lParam;
34743:   event.pluginEvent = (void *)&pluginEvent;
79626:   event.retargetToFocusedDocument = true;
29835:   return DispatchWindowEvent(&event);
29835: }
29835: 
79445: bool nsWindow::DispatchPluginEvent(UINT aMessage,
49149:                                      WPARAM aWParam,
49149:                                      LPARAM aLParam,
79445:                                      bool aDispatchPendingEvents)
79445: {
86569:   bool ret = DispatchPluginEvent(WinUtils::InitMSG(aMessage, aWParam, aLParam));
49149:   if (aDispatchPendingEvents) {
49149:     DispatchPendingEvents();
49149:   }
49149:   return ret;
49149: }
49149: 
22788: void nsWindow::RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg,
68737:                  UINT aLastMsg, nsFakeCharMessage* aFakeCharMessage)
22788: {
22788:   MSG msg;
68737:   if (aFakeCharMessage) {
68737:     if (aFirstMsg > WM_CHAR || aLastMsg < WM_CHAR) {
68737:       return;
68737:     }
68737:     msg = aFakeCharMessage->GetCharMessage(mWnd);
68737:   } else {
22788:     ::GetMessageW(&msg, mWnd, aFirstMsg, aLastMsg);
68737:   }
22788:   DispatchPluginEvent(msg);
22788: }
22788: 
29835: // Deal with all sort of mouse event
79445: bool nsWindow::DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam,
79445:                                     LPARAM lParam, bool aIsContextMenuKey,
40485:                                     PRInt16 aButton, PRUint16 aInputSource)
29835: {
79445:   bool result = false;
29835: 
40944:   UserActivity();
40944: 
29835:   if (!mEventCallback) {
29835:     return result;
29835:   }
29835: 
46202:   switch (aEventType) {
46202:     case NS_MOUSE_BUTTON_DOWN:
79626:       CaptureMouse(true);
46202:       break;
46202: 
46202:     // NS_MOUSE_MOVE and NS_MOUSE_EXIT are here because we need to make sure capture flag
46202:     // isn't left on after a drag where we wouldn't see a button up message (see bug 324131).
46202:     case NS_MOUSE_BUTTON_UP:
46202:     case NS_MOUSE_MOVE:
46202:     case NS_MOUSE_EXIT:
60909:       if (!(wParam & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) && sIsInMouseCapture)
79626:         CaptureMouse(false);
46202:       break;
46202: 
46202:     default:
46202:       break;
46202: 
46202:   } // switch
46202: 
29835:   nsIntPoint eventPoint;
29835:   eventPoint.x = GET_X_LPARAM(lParam);
29835:   eventPoint.y = GET_Y_LPARAM(lParam);
29835: 
79626:   nsMouseEvent event(true, aEventType, this, nsMouseEvent::eReal,
29835:                      aIsContextMenuKey
29835:                      ? nsMouseEvent::eContextMenuKey
29835:                      : nsMouseEvent::eNormal);
29835:   if (aEventType == NS_CONTEXTMENU && aIsContextMenuKey) {
29835:     nsIntPoint zero(0, 0);
29835:     InitEvent(event, &zero);
29835:   } else {
29835:     InitEvent(event, &eventPoint);
29835:   }
29835: 
29835:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
79626:   event.isMeta    = false;
29835:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:   event.button    = aButton;
40485:   event.inputSource = aInputSource;
29835: 
29835:   nsIntPoint mpScreen = eventPoint + WidgetToScreenOffset();
29835: 
29835:   // Suppress mouse moves caused by widget creation
29835:   if (aEventType == NS_MOUSE_MOVE) 
29835:   {
29835:     if ((sLastMouseMovePoint.x == mpScreen.x) && (sLastMouseMovePoint.y == mpScreen.y))
29835:       return result;
29835:     sLastMouseMovePoint.x = mpScreen.x;
29835:     sLastMouseMovePoint.y = mpScreen.y;
29835:   }
29835: 
79445:   bool insideMovementThreshold = (abs(sLastMousePoint.x - eventPoint.x) < (short)::GetSystemMetrics(SM_CXDOUBLECLK)) &&
29835:                                    (abs(sLastMousePoint.y - eventPoint.y) < (short)::GetSystemMetrics(SM_CYDOUBLECLK));
29835: 
29835:   BYTE eventButton;
29835:   switch (aButton) {
29835:     case nsMouseEvent::eLeftButton:
29835:       eventButton = VK_LBUTTON;
29835:       break;
29835:     case nsMouseEvent::eMiddleButton:
29835:       eventButton = VK_MBUTTON;
29835:       break;
29835:     case nsMouseEvent::eRightButton:
29835:       eventButton = VK_RBUTTON;
29835:       break;
29835:     default:
29835:       eventButton = 0;
29835:       break;
29835:   }
29835: 
29835:   // Doubleclicks are used to set the click count, then changed to mousedowns
29835:   // We're going to time double-clicks from mouse *up* to next mouse *down*
29835:   LONG curMsgTime = ::GetMessageTime();
29835: 
29835:   if (aEventType == NS_MOUSE_DOUBLECLICK) {
29835:     event.message = NS_MOUSE_BUTTON_DOWN;
29835:     event.button = aButton;
29835:     sLastClickCount = 2;
29835:   }
29835:   else if (aEventType == NS_MOUSE_BUTTON_UP) {
29835:     // remember when this happened for the next mouse down
29835:     sLastMousePoint.x = eventPoint.x;
29835:     sLastMousePoint.y = eventPoint.y;
29835:     sLastMouseButton = eventButton;
29835:   }
29835:   else if (aEventType == NS_MOUSE_BUTTON_DOWN) {
29835:     // now look to see if we want to convert this to a double- or triple-click
29835:     if (((curMsgTime - sLastMouseDownTime) < (LONG)::GetDoubleClickTime()) && insideMovementThreshold &&
29835:         eventButton == sLastMouseButton) {
29835:       sLastClickCount ++;
29835:     } else {
29835:       // reset the click count, to count *this* click
29835:       sLastClickCount = 1;
29835:     }
29835:     // Set last Click time on MouseDown only
29835:     sLastMouseDownTime = curMsgTime;
29835:   }
29835:   else if (aEventType == NS_MOUSE_MOVE && !insideMovementThreshold) {
29835:     sLastClickCount = 0;
29835:   }
29835:   else if (aEventType == NS_MOUSE_EXIT) {
29835:     event.exit = IsTopLevelMouseExit(mWnd) ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
29835:   }
46334:   else if (aEventType == NS_MOUSE_MOZHITTEST)
46334:   {
46334:     event.flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH;
46334:   }
29835:   event.clickCount = sLastClickCount;
29835: 
29835: #ifdef NS_DEBUG_XX
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:          ("Msg Time: %d Click Count: %d\n", curMsgTime, event.clickCount));
29835: #endif
29835: 
32799:   NPEvent pluginEvent;
29835: 
29835:   switch (aEventType)
29835:   {
29835:     case NS_MOUSE_BUTTON_DOWN:
29835:       switch (aButton) {
29835:         case nsMouseEvent::eLeftButton:
29835:           pluginEvent.event = WM_LBUTTONDOWN;
29835:           break;
29835:         case nsMouseEvent::eMiddleButton:
29835:           pluginEvent.event = WM_MBUTTONDOWN;
29835:           break;
29835:         case nsMouseEvent::eRightButton:
29835:           pluginEvent.event = WM_RBUTTONDOWN;
29835:           break;
29835:         default:
29835:           break;
29835:       }
29835:       break;
29835:     case NS_MOUSE_BUTTON_UP:
29835:       switch (aButton) {
29835:         case nsMouseEvent::eLeftButton:
29835:           pluginEvent.event = WM_LBUTTONUP;
29835:           break;
29835:         case nsMouseEvent::eMiddleButton:
29835:           pluginEvent.event = WM_MBUTTONUP;
29835:           break;
29835:         case nsMouseEvent::eRightButton:
29835:           pluginEvent.event = WM_RBUTTONUP;
29835:           break;
29835:         default:
29835:           break;
29835:       }
29835:       break;
29835:     case NS_MOUSE_DOUBLECLICK:
29835:       switch (aButton) {
29835:         case nsMouseEvent::eLeftButton:
29835:           pluginEvent.event = WM_LBUTTONDBLCLK;
29835:           break;
29835:         case nsMouseEvent::eMiddleButton:
29835:           pluginEvent.event = WM_MBUTTONDBLCLK;
29835:           break;
29835:         case nsMouseEvent::eRightButton:
29835:           pluginEvent.event = WM_RBUTTONDBLCLK;
29835:           break;
29835:         default:
29835:           break;
29835:       }
29835:       break;
29835:     case NS_MOUSE_MOVE:
29835:       pluginEvent.event = WM_MOUSEMOVE;
29835:       break;
37167:     case NS_MOUSE_EXIT:
37167:       pluginEvent.event = WM_MOUSELEAVE;
37167:       break;
29835:     default:
29835:       pluginEvent.event = WM_NULL;
29835:       break;
29835:   }
29835: 
29835:   pluginEvent.wParam = wParam;     // plugins NEED raw OS event flags!
29835:   pluginEvent.lParam = lParam;
29835: 
34743:   event.pluginEvent = (void *)&pluginEvent;
29835: 
29835:   // call the event callback
29835:   if (nsnull != mEventCallback) {
29835:     if (nsToolkit::gMouseTrailer)
29835:       nsToolkit::gMouseTrailer->Disable();
29835:     if (aEventType == NS_MOUSE_MOVE) {
60909:       if (nsToolkit::gMouseTrailer && !sIsInMouseCapture) {
29835:         nsToolkit::gMouseTrailer->SetMouseTrailerWindow(mWnd);
29835:       }
29835:       nsIntRect rect;
29835:       GetBounds(rect);
29835:       rect.x = 0;
29835:       rect.y = 0;
29835: 
29835:       if (rect.Contains(event.refPoint)) {
29835:         if (sCurrentWindow == NULL || sCurrentWindow != this) {
30223:           if ((nsnull != sCurrentWindow) && (!sCurrentWindow->mInDtor)) {
29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
79626:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, wParam, pos, false, 
40485:                                                nsMouseEvent::eLeftButton, aInputSource);
29835:           }
29835:           sCurrentWindow = this;
30223:           if (!mInDtor) {
29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
79626:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER, wParam, pos, false,
40485:                                                nsMouseEvent::eLeftButton, aInputSource);
29835:           }
29835:         }
29835:       }
29835:     } else if (aEventType == NS_MOUSE_EXIT) {
29835:       if (sCurrentWindow == this) {
29835:         sCurrentWindow = nsnull;
29835:       }
29835:     }
29835: 
29835:     result = DispatchWindowEvent(&event);
29835: 
29835:     if (nsToolkit::gMouseTrailer)
29835:       nsToolkit::gMouseTrailer->Enable();
29835: 
29835:     // Release the widget with NS_IF_RELEASE() just in case
29835:     // the context menu key code in nsEventListenerManager::HandleEvent()
29835:     // released it already.
29835:     return result;
29835:   }
29835: 
29835:   return result;
29835: }
29835: 
29835: // Deal with accessibile event
29835: #ifdef ACCESSIBILITY
42313: nsAccessible*
42313: nsWindow::DispatchAccessibleEvent(PRUint32 aEventType)
42313: {
29835:   if (nsnull == mEventCallback) {
42313:     return nsnull;
42313:   }
29835: 
79626:   nsAccessibleEvent event(true, aEventType, this);
42313:   InitEvent(event, nsnull);
29835: 
29835:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
79626:   event.isMeta    = false;
29835:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
42313: 
42313:   DispatchWindowEvent(&event);
42313: 
42313:   return event.mAccessible;
29835: }
29835: #endif
29835: 
79445: bool nsWindow::DispatchFocusToTopLevelWindow(PRUint32 aEventType)
29835: {
29835:   if (aEventType == NS_ACTIVATE)
79626:     sJustGotActivate = false;
79626:   sJustGotDeactivate = false;
29835: 
35499:   // retrive the toplevel window or dialog
35499:   HWND curWnd = mWnd;
35499:   HWND toplevelWnd = NULL;
35499:   while (curWnd) {
35499:     toplevelWnd = curWnd;
35499: 
86569:     nsWindow *win = WinUtils::GetNSWindowPtr(curWnd);
35499:     if (win) {
35499:       nsWindowType wintype;
35499:       win->GetWindowType(wintype);
35499:       if (wintype == eWindowType_toplevel || wintype == eWindowType_dialog)
35499:         break;
35499:     }
35499: 
35499:     curWnd = ::GetParent(curWnd); // Parent or owner (if has no parent)
35499:   }
35499: 
29835:   if (toplevelWnd) {
86569:     nsWindow *win = WinUtils::GetNSWindowPtr(toplevelWnd);
29835:     if (win)
29835:       return win->DispatchFocus(aEventType);
29835:   }
29835: 
79626:   return false;
29835: }
29835: 
29835: // Deal with focus messages
79445: bool nsWindow::DispatchFocus(PRUint32 aEventType)
29835: {
29835:   // call the event callback
29835:   if (mEventCallback) {
79626:     nsGUIEvent event(true, aEventType, this);
29835:     InitEvent(event);
29835: 
29835:     //focus and blur event should go to their base widget loc, not current mouse pos
29835:     event.refPoint.x = 0;
29835:     event.refPoint.y = 0;
29835: 
32799:     NPEvent pluginEvent;
29835: 
29835:     switch (aEventType)
29835:     {
29835:       case NS_ACTIVATE:
29835:         pluginEvent.event = WM_SETFOCUS;
29835:         break;
29835:       case NS_DEACTIVATE:
29835:         pluginEvent.event = WM_KILLFOCUS;
29835:         break;
29835:       case NS_PLUGIN_ACTIVATE:
29835:         pluginEvent.event = WM_KILLFOCUS;
29835:         break;
29835:       default:
29835:         break;
29835:     }
29835: 
34743:     event.pluginEvent = (void *)&pluginEvent;
29835: 
29835:     return DispatchWindowEvent(&event);
29835:   }
79626:   return false;
29835: }
29835: 
79445: bool nsWindow::IsTopLevelMouseExit(HWND aWnd)
29835: {
29835:   DWORD pos = ::GetMessagePos();
29835:   POINT mp;
29835:   mp.x = GET_X_LPARAM(pos);
29835:   mp.y = GET_Y_LPARAM(pos);
29835:   HWND mouseWnd = ::WindowFromPoint(mp);
29835: 
86569:   // WinUtils::GetTopLevelHWND() will return a HWND for the window frame
86569:   // (which includes the non-client area).  If the mouse has moved into
86569:   // the non-client area, we should treat it as a top-level exit.
86569:   HWND mouseTopLevel = WinUtils::GetTopLevelHWND(mouseWnd);
29835:   if (mouseWnd == mouseTopLevel)
79626:     return true;
29835: 
86569:   return WinUtils::GetTopLevelHWND(aWnd) != mouseTopLevel;
29835: }
29835: 
79445: bool nsWindow::BlurEventsSuppressed()
29835: {
29835:   // are they suppressed in this window?
29835:   if (mBlurSuppressLevel > 0)
79626:     return true;
29835: 
29835:   // are they suppressed by any container widget?
29835:   HWND parentWnd = ::GetParent(mWnd);
29835:   if (parentWnd) {
86569:     nsWindow *parent = WinUtils::GetNSWindowPtr(parentWnd);
29835:     if (parent)
29835:       return parent->BlurEventsSuppressed();
29835:   }
79626:   return false;
29835: }
29835: 
29835: // In some circumstances (opening dependent windows) it makes more sense
29835: // (and fixes a crash bug) to not blur the parent window. Called from
29835: // nsFilePicker.
79445: void nsWindow::SuppressBlurEvents(bool aSuppress)
29835: {
29835:   if (aSuppress)
29835:     ++mBlurSuppressLevel; // for this widget
29835:   else {
29835:     NS_ASSERTION(mBlurSuppressLevel > 0, "unbalanced blur event suppression");
29835:     if (mBlurSuppressLevel > 0)
29835:       --mBlurSuppressLevel;
29835:   }
29835: }
29835: 
79445: bool nsWindow::ConvertStatus(nsEventStatus aStatus)
29835: {
29835:   return aStatus == nsEventStatus_eConsumeNoDefault;
29835: }
29835: 
29835: /**************************************************************
38103:  *
38103:  * SECTION: IPC
38103:  *
38103:  * IPC related helpers.
38103:  *
38103:  **************************************************************/
38103: 
38103: // static
38103: bool
38103: nsWindow::IsAsyncResponseEvent(UINT aMsg, LRESULT& aResult)
38103: {
38103:   switch(aMsg) {
38103:     case WM_SETFOCUS:
38103:     case WM_KILLFOCUS:
38103:     case WM_ENABLE:
38103:     case WM_WINDOWPOSCHANGING:
38103:     case WM_WINDOWPOSCHANGED:
38103:     case WM_PARENTNOTIFY:
38103:     case WM_ACTIVATEAPP:
38103:     case WM_NCACTIVATE:
38103:     case WM_ACTIVATE:
38103:     case WM_CHILDACTIVATE:
38103:     case WM_IME_SETCONTEXT:
38103:     case WM_IME_NOTIFY:
38103:     case WM_SHOWWINDOW:
38103:     case WM_CANCELMODE:
38103:     case WM_MOUSEACTIVATE:
39729:     case WM_CONTEXTMENU:
38103:       aResult = 0;
38103:     return true;
38103: 
38103:     case WM_SETTINGCHANGE:
38103:     case WM_SETCURSOR:
38103:     return false;
38103:   }
38103: 
38103: #ifdef DEBUG
38103:   char szBuf[200];
38103:   sprintf(szBuf,
38103:     "An unhandled ISMEX_SEND message was received during spin loop! (%X)", aMsg);
38103:   NS_WARNING(szBuf);
38103: #endif
38103: 
38103:   return false;
38103: }
38103: 
38103: void
38400: nsWindow::IPCWindowProcHandler(UINT& msg, WPARAM& wParam, LPARAM& lParam)
38103: {
38103:   NS_ASSERTION(!mozilla::ipc::SyncChannel::IsPumpingMessages(),
38103:                "Failed to prevent a nonqueued message from running!");
38400: 
39241:   // Modal UI being displayed in windowless plugins.
39241:   if (mozilla::ipc::RPCChannel::IsSpinLoopActive() &&
39241:       (InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
39241:     LRESULT res;
39241:     if (IsAsyncResponseEvent(msg, res)) {
39241:       ReplyMessage(res);
39241:     }
39241:     return;
39241:   }
39241: 
39241:   // Handle certain sync plugin events sent to the parent which
39241:   // trigger ipc calls that result in deadlocks.
39241: 
40964:   DWORD dwResult = 0;
79445:   bool handled = false;
40964: 
40964:   switch(msg) {
39241:     // Windowless flash sending WM_ACTIVATE events to the main window
39241:     // via calls to ShowWindow.
40964:     case WM_ACTIVATE:
40964:       if (lParam != 0 && LOWORD(wParam) == WA_ACTIVE &&
63933:           IsWindow((HWND)lParam)) {
63933:         // Check for Adobe Reader X sync activate message from their
63933:         // helper window and ignore. Fixes an annoying focus problem.
63933:         if ((InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
63933:           PRUnichar szClass[10];
63933:           HWND focusWnd = (HWND)lParam;
63933:           if (IsWindowVisible(focusWnd) &&
63933:               GetClassNameW(focusWnd, szClass,
63933:                             sizeof(szClass)/sizeof(PRUnichar)) &&
63933:               !wcscmp(szClass, L"Edit") &&
86569:               !WinUtils::IsOurProcessWindow(focusWnd)) {
63933:             break;
63933:           }
63933:         }
79626:         handled = true;
63933:       }
40964:     break;
40964:     // Plugins taking or losing focus triggering focus app messages.
40964:     case WM_SETFOCUS:
40964:     case WM_KILLFOCUS:
39241:     // Windowed plugins that pass sys key events to defwndproc generate
39241:     // WM_SYSCOMMAND events to the main window.
40964:     case WM_SYSCOMMAND:
40964:     // Windowed plugins that fire context menu selection events to parent
40964:     // windows.
40964:     case WM_CONTEXTMENU:
42381:     // IME events fired as a result of synchronous focus changes
42381:     case WM_IME_SETCONTEXT:
79626:       handled = true;
40964:     break;
40964:   }
40964: 
40964:   if (handled &&
39241:       (InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
40964:     ReplyMessage(dwResult);
39037:   }
38103: }
38103: 
38103: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Native events
29835:  **
29835:  ** Main Windows message handlers and OnXXX handlers for
29835:  ** Windows event handling.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Wind proc.
29835:  *
29835:  * The main Windows event procedures and associated
29835:  * message processing methods.
29835:  *
29835:  **************************************************************/
29835: 
79445: static bool
79445: DisplaySystemMenu(HWND hWnd, nsSizeMode sizeMode, bool isRtl, PRInt32 x, PRInt32 y)
56383: {
56383:   HMENU hMenu = GetSystemMenu(hWnd, FALSE);
56383:   if (hMenu) {
69677:     MENUITEMINFO mii;
69677:     mii.cbSize = sizeof(MENUITEMINFO);
69677:     mii.fMask = MIIM_STATE;
69677:     mii.fType = 0;
69677: 
56383:     // update the options
69677:     mii.fState = MF_ENABLED;
69677:     SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
69677:     SetMenuItemInfo(hMenu, SC_SIZE, FALSE, &mii);
69677:     SetMenuItemInfo(hMenu, SC_MOVE, FALSE, &mii);
69677:     SetMenuItemInfo(hMenu, SC_MAXIMIZE, FALSE, &mii);
69677:     SetMenuItemInfo(hMenu, SC_MINIMIZE, FALSE, &mii);
69677: 
69677:     mii.fState = MF_GRAYED;
56383:     switch(sizeMode) {
56383:       case nsSizeMode_Fullscreen:
72140:         SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
56383:         // intentional fall through
56383:       case nsSizeMode_Maximized:
69677:         SetMenuItemInfo(hMenu, SC_SIZE, FALSE, &mii);
69677:         SetMenuItemInfo(hMenu, SC_MOVE, FALSE, &mii);
69677:         SetMenuItemInfo(hMenu, SC_MAXIMIZE, FALSE, &mii);
56383:         break;
56383:       case nsSizeMode_Minimized:
69677:         SetMenuItemInfo(hMenu, SC_MINIMIZE, FALSE, &mii);
56383:         break;
56383:       case nsSizeMode_Normal:
69677:         SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
56383:         break;
56383:     }
56383:     LPARAM cmd =
56383:       TrackPopupMenu(hMenu,
56383:                      (TPM_LEFTBUTTON|TPM_RIGHTBUTTON|
56383:                       TPM_RETURNCMD|TPM_TOPALIGN|
56383:                       (isRtl ? TPM_RIGHTALIGN : TPM_LEFTALIGN)),
56383:                      x, y, 0, hWnd, NULL);
56383:     if (cmd) {
56383:       PostMessage(hWnd, WM_SYSCOMMAND, cmd, 0);
79626:       return true;
79626:     }
79626:   }
79626:   return false;
56383: }
56383: 
50680: // The WndProc procedure for all nsWindows in this toolkit. This merely catches
50681: // exceptions and passes the real work to WindowProcInternal. See bug 587406
50681: // and http://msdn.microsoft.com/en-us/library/ms633573%28VS.85%29.aspx
29835: LRESULT CALLBACK nsWindow::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
29835: {
62476:   return mozilla::CallWindowProcCrashProtected(WindowProcInternal, hWnd, msg, wParam, lParam);
50680: }
50680: 
50680: LRESULT CALLBACK nsWindow::WindowProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
50680: {
42480:   NS_TIME_FUNCTION_MIN_FMT(5.0, "%s (line %d) (hWnd: %p, msg: %p, wParam: %p, lParam: %p",
42480:                            MOZ_FUNCTION_NAME, __LINE__, hWnd, msg,
42480:                            wParam, lParam);
42480: 
59750:   if (::GetWindowLongPtrW(hWnd, GWLP_ID) == eFakeTrackPointScrollableID) {
59750:     // This message was sent to the FAKETRACKPOINTSCROLLABLE.
59750:     if (msg == WM_HSCROLL) {
59750:       // Route WM_HSCROLL messages to the main window.
59750:       hWnd = ::GetParent(::GetParent(hWnd));
59750:     } else {
59750:       // Handle all other messages with its original window procedure.
59750:       WNDPROC prevWindowProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
59750:       return ::CallWindowProcW(prevWindowProc, hWnd, msg, wParam, lParam);
59750:     }
59750:   }
59750: 
68748:   if (msg == MOZ_WM_TRACE) {
68748:     // This is a tracer event for measuring event loop latency.
68748:     // See WidgetTraceEvent.cpp for more details.
68748:     mozilla::SignalTracerThread();
68748:     return 0;
68748:   }
68748: 
38400:   // Get the window which caused the event and ask it to process the message
86569:   nsWindow *someWindow = WinUtils::GetNSWindowPtr(hWnd);
38400: 
38400:   if (someWindow)
38400:     someWindow->IPCWindowProcHandler(msg, wParam, lParam);
36056: 
29835:   // create this here so that we store the last rolled up popup until after
29835:   // the event has been processed.
29835:   nsAutoRollup autoRollup;
29835: 
29835:   LRESULT popupHandlingResult;
29835:   if (DealWithPopups(hWnd, msg, wParam, lParam, &popupHandlingResult))
29835:     return popupHandlingResult;
29835: 
29835:   // XXX This fixes 50208 and we are leaving 51174 open to further investigate
29835:   // why we are hitting this assert
29835:   if (nsnull == someWindow) {
29835:     NS_ASSERTION(someWindow, "someWindow is null, cannot call any CallWindowProc");
29835:     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
29835:   }
29835: 
29835:   // hold on to the window for the life of this method, in case it gets
29835:   // deleted during processing. yes, it's a double hack, since someWindow
29835:   // is not really an interface.
29835:   nsCOMPtr<nsISupports> kungFuDeathGrip;
30223:   if (!someWindow->mInDtor) // not if we're in the destructor!
29835:     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)someWindow);
29835: 
29835:   // Call ProcessMessage
29835:   LRESULT retValue;
79626:   if (true == someWindow->ProcessMessage(msg, wParam, lParam, &retValue)) {
29835:     return retValue;
29835:   }
38401: 
38401:   LRESULT res = ::CallWindowProcW(someWindow->GetPrevWindowProc(),
29835:                                   hWnd, msg, wParam, lParam);
38401: 
38401:   return res;
29835: }
29835: 
29835: // The main windows message processing method for plugins.
29835: // The result means whether this method processed the native
29835: // event for plugin. If false, the native event should be
29835: // processed by the caller self.
79445: bool
29835: nsWindow::ProcessMessageForPlugin(const MSG &aMsg,
29835:                                   LRESULT *aResult,
79445:                                   bool &aCallDefWndProc)
29835: {
29835:   NS_PRECONDITION(aResult, "aResult must be non-null.");
29835:   *aResult = 0;
29835: 
79626:   aCallDefWndProc = false;
79445:   bool eventDispatched = false;
29835:   switch (aMsg.message) {
29835:     case WM_CHAR:
29835:     case WM_SYSCHAR:
29835:       *aResult = ProcessCharMessage(aMsg, &eventDispatched);
29835:       break;
29835: 
29835:     case WM_KEYUP:
29835:     case WM_SYSKEYUP:
29835:       *aResult = ProcessKeyUpMessage(aMsg, &eventDispatched);
29835:       break;
29835: 
29835:     case WM_KEYDOWN:
29835:     case WM_SYSKEYDOWN:
29835:       *aResult = ProcessKeyDownMessage(aMsg, &eventDispatched);
29835:       break;
29835: 
29835:     case WM_DEADCHAR:
29835:     case WM_SYSDEADCHAR:
29835: 
29835:     case WM_CUT:
29835:     case WM_COPY:
29835:     case WM_PASTE:
29835:     case WM_CLEAR:
29835:     case WM_UNDO:
29835:       break;
29835: 
29835:     default:
79626:       return false;
29835:   }
29835: 
29835:   if (!eventDispatched)
29835:     aCallDefWndProc = !DispatchPluginEvent(aMsg);
29835:   DispatchPendingEvents();
79626:   return true;
29835: }
29835: 
71484: static void ForceFontUpdate()
71484: {
71484:   // update device context font cache
71484:   // Dirty but easiest way:
71484:   // Changing nsIPrefBranch entry which triggers callbacks
71484:   // and flows into calling mDeviceContext->FlushFontCache()
71484:   // to update the font cache in all the instance of Browsers
71484:   static const char kPrefName[] = "font.internaluseonly.changed";
79445:   bool fontInternalChange =
79445:     Preferences::GetBool(kPrefName, false);
71484:   Preferences::SetBool(kPrefName, !fontInternalChange);
71484: }
71484: 
79445: static bool CleartypeSettingChanged()
71484: {
71484:   static int currentQuality = -1;
71484:   BYTE quality = cairo_win32_get_system_text_quality();
71484: 
71484:   if (currentQuality == quality)
79626:     return false;
71484: 
71484:   if (currentQuality < 0) {
71484:     currentQuality = quality;
79626:     return false;
71484:   }
71484:   currentQuality = quality;
79626:   return true;
71484: }
71484: 
29835: // The main windows message processing method.
79445: bool nsWindow::ProcessMessage(UINT msg, WPARAM &wParam, LPARAM &lParam,
29835:                                 LRESULT *aRetValue)
29835: {
62480:   // For the Elantech Touchpad Zoom Gesture Hack, we should check that the
62480:   // system time (32-bit milliseconds) hasn't wrapped around.  Otherwise we
62480:   // might get into the situation where wheel events for the next 50 days of
62480:   // system uptime are assumed to be Ctrl+Wheel events.  (It is unlikely that
62480:   // we would get into that state, because the system would already need to be
62480:   // up for 50 days and the Control key message would need to be processed just
62480:   // before the system time overflow and the wheel message just after.)
62480:   //
62480:   // We also take the chance to reset mAssumeWheelIsZoomUntil if we simply have
62480:   // passed that time.
62480:   if (mAssumeWheelIsZoomUntil) {
62480:     LONG msgTime = ::GetMessageTime();
62480:     if ((mAssumeWheelIsZoomUntil >= 0x3fffffffu && DWORD(msgTime) < 0x40000000u) ||
62480:         (mAssumeWheelIsZoomUntil < DWORD(msgTime))) {
62480:       mAssumeWheelIsZoomUntil = 0;
62480:     }
62480:   }
62480: 
29835:   // (Large blocks of code should be broken out into OnEvent handlers.)
31532:   if (mWindowHook.Notify(mWnd, msg, wParam, lParam, aRetValue))
79626:     return true;
29835: 
38103: #if defined(EVENT_DEBUG_OUTPUT)
38103:   // First param shows all events, second param indicates whether
38103:   // to show mouse move events. See nsWindowDbg for details.
38103:   PrintEvent(msg, SHOW_REPEAT_EVENTS, SHOW_MOUSEMOVE_EVENTS);
38103: #endif
38103: 
79445:   bool eatMessage;
29835:   if (nsIMM32Handler::ProcessMessage(this, msg, wParam, lParam, aRetValue,
29835:                                      eatMessage)) {
79626:     return mWnd ? eatMessage : true;
29835:   }
29835: 
29835:   if (PluginHasFocus()) {
79445:     bool callDefaultWndProc;
86569:     MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
29835:     if (ProcessMessageForPlugin(nativeMsg, aRetValue, callDefaultWndProc)) {
79626:       return mWnd ? !callDefaultWndProc : true;
29835:     }
29835:   }
29835: 
79445:   bool result = false;    // call the default nsWindow proc
29835:   *aRetValue = 0;
29835: 
46200:   // Glass hit testing w/custom transparent margins
46200:   LRESULT dwmHitResult;
46200:   if (mCustomNonClient &&
46200:       nsUXThemeData::CheckForCompositor() &&
46200:       nsUXThemeData::dwmDwmDefWindowProcPtr(mWnd, msg, wParam, lParam, &dwmHitResult)) {
46200:     *aRetValue = dwmHitResult;
79626:     return true;
46200:   }
46200: 
29835:   switch (msg) {
29835:     // WM_QUERYENDSESSION must be handled by all windows.
29835:     // Otherwise Windows thinks the window can just be killed at will.
29835:     case WM_QUERYENDSESSION:
29835:       if (sCanQuit == TRI_UNKNOWN)
29835:       {
29835:         // Ask if it's ok to quit, and store the answer until we
29835:         // get WM_ENDSESSION signaling the round is complete.
29835:         nsCOMPtr<nsIObserverService> obsServ =
41540:           mozilla::services::GetObserverService();
29835:         nsCOMPtr<nsISupportsPRBool> cancelQuit =
29835:           do_CreateInstance(NS_SUPPORTS_PRBOOL_CONTRACTID);
79626:         cancelQuit->SetData(false);
29835:         obsServ->NotifyObservers(cancelQuit, "quit-application-requested", nsnull);
29835: 
79445:         bool abortQuit;
29835:         cancelQuit->GetData(&abortQuit);
29835:         sCanQuit = abortQuit ? TRI_FALSE : TRI_TRUE;
29835:       }
29835:       *aRetValue = sCanQuit ? TRUE : FALSE;
79626:       result = true;
29835:       break;
68855: 
29835:     case WM_ENDSESSION:
34610:     case MOZ_WM_APP_QUIT:
34610:       if (msg == MOZ_WM_APP_QUIT || (wParam == TRUE && sCanQuit == TRI_TRUE))
29835:       {
29835:         // Let's fake a shutdown sequence without actually closing windows etc.
29835:         // to avoid Windows killing us in the middle. A proper shutdown would
29835:         // require having a chance to pump some messages. Unfortunately
29835:         // Windows won't let us do that. Bug 212316.
29835:         nsCOMPtr<nsIObserverService> obsServ =
41540:           mozilla::services::GetObserverService();
29835:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
29835:         obsServ->NotifyObservers(nsnull, "quit-application-granted", nsnull);
29835:         obsServ->NotifyObservers(nsnull, "quit-application-forced", nsnull);
29835:         obsServ->NotifyObservers(nsnull, "quit-application", nsnull);
29835:         obsServ->NotifyObservers(nsnull, "profile-change-net-teardown", context.get());
29835:         obsServ->NotifyObservers(nsnull, "profile-change-teardown", context.get());
29835:         obsServ->NotifyObservers(nsnull, "profile-before-change", context.get());
29835:         // Then a controlled but very quick exit.
29835:         _exit(0);
29835:       }
29835:       sCanQuit = TRI_UNKNOWN;
79626:       result = true;
29835:       break;
29835: 
29835:     case WM_DISPLAYCHANGE:
29835:       DispatchStandardEvent(NS_DISPLAYCHANGED);
29835:       break;
29835: 
29835:     case WM_SYSCOLORCHANGE:
82569:       OnSysColorChanged();
29835:       break;
29835: 
29835:     case WM_NOTIFY:
29835:       // TAB change
29835:     {
29835:       LPNMHDR pnmh = (LPNMHDR) lParam;
29835: 
29835:         switch (pnmh->code) {
29835:           case TCN_SELCHANGE:
29835:           {
29835:             DispatchStandardEvent(NS_TABCHANGE);
79626:             result = true;
29835:           }
29835:           break;
29835:         }
29835:     }
29835:     break;
29835: 
58327:     case WM_THEMECHANGED:
29835:     {
46200:       // Update non-client margin offsets 
46200:       UpdateNonClientMargins();
58327:       nsUXThemeData::InitTitlebarInfo();
55268:       nsUXThemeData::UpdateNativeThemeInfo();
46200: 
29835:       DispatchStandardEvent(NS_THEMECHANGED);
29835: 
29835:       // Invalidate the window so that the repaint will
29835:       // pick up the new theme.
87336:       Invalidate(true, true, true);
29835:     }
29835:     break;
29835: 
29835:     case WM_FONTCHANGE:
29835:     {
29835:       nsresult rv;
79445:       bool didChange = false;
29835: 
29835:       // update the global font list
29835:       nsCOMPtr<nsIFontEnumerator> fontEnum = do_GetService("@mozilla.org/gfx/fontenumerator;1", &rv);
29835:       if (NS_SUCCEEDED(rv)) {
29835:         fontEnum->UpdateFontList(&didChange);
29835:         //didChange is TRUE only if new font langGroup is added to the list.
29835:         if (didChange)  {
71484:           ForceFontUpdate();
29835:         }
29835:       } //if (NS_SUCCEEDED(rv))
29835:     }
29835:     break;
29835: 
46200:     case WM_NCCALCSIZE:
46200:     {
46200:       // If wParam is TRUE, it specifies that the application should indicate
46200:       // which part of the client area contains valid information. The system
46200:       // copies the valid information to the specified area within the new
46200:       // client area. If the wParam parameter is FALSE, the application should
46200:       // return zero.
51380:       if (mCustomNonClient) {
46200:         if (!wParam) {
79626:           result = true;
46200:           *aRetValue = 0;
46200:           break;
46200:         }
46200: 
46200:         // before:
46200:         // rgrc[0]: the proposed window
46200:         // rgrc[1]: the current window
46200:         // rgrc[2]: the source client area
46200:         // pncsp->lppos: move/size data
46200:         // after:
46200:         // rgrc[0]: the new client area
46200:         // rgrc[1]: the destination window
46200:         // rgrc[2]: the source client area
46200:         // (all values in screen coordiantes)
46200:         NCCALCSIZE_PARAMS *pncsp = reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam);
46200:         LRESULT res = CallWindowProcW(GetPrevWindowProc(), mWnd, msg, wParam, lParam);
46200:         pncsp->rgrc[0].top      -= mNonClientOffset.top;
46200:         pncsp->rgrc[0].left     -= mNonClientOffset.left;
46200:         pncsp->rgrc[0].right    += mNonClientOffset.right;
46200:         pncsp->rgrc[0].bottom   += mNonClientOffset.bottom;
46200: 
79626:         result = true;
46200:         *aRetValue = res;
46200:       }
46200:       break;
46200:     }
46200: 
46200:     case WM_NCHITTEST:
46200:     {
46200:       /*
46200:        * If an nc client area margin has been moved, we are responsible
46200:        * for calculating where the resize margins are and returning the
46200:        * appropriate set of hit test constants. DwmDefWindowProc (above)
46200:        * will handle hit testing on it's command buttons if we are on a
46200:        * composited desktop.
46200:        */
46200: 
51380:       if (!mCustomNonClient)
46200:         break;
46200: 
46200:       *aRetValue =
46200:         ClientMarginHitTestPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
79626:       result = true;
46200:       break;
46200:     }
46200: 
49251:     case WM_SETTEXT:
49251:       /*
49251:        * WM_SETTEXT paints the titlebar area. Avoid this if we have a
49251:        * custom titlebar we paint ourselves.
49251:        */
49251: 
50350:       if (!mCustomNonClient || mNonClientMargins.top == -1)
49251:         break;
49251: 
49251:       {
49251:         // From msdn, the way around this is to disable the visible state
49251:         // temporarily. We need the text to be set but we don't want the
49251:         // redraw to occur.
49251:         DWORD style = GetWindowLong(mWnd, GWL_STYLE);
49251:         SetWindowLong(mWnd, GWL_STYLE, style & ~WS_VISIBLE);
49251:         *aRetValue = CallWindowProcW(GetPrevWindowProc(), mWnd,
49251:                                      msg, wParam, lParam);
49251:         SetWindowLong(mWnd, GWL_STYLE, style);
79626:         return true;
49251:       }
49251: 
49251:     case WM_NCACTIVATE:
49251:     {
49251:       /*
49251:        * WM_NCACTIVATE paints nc areas. Avoid this and re-route painting
49251:        * through WM_NCPAINT via InvalidateNonClientRegion.
49251:        */
49251: 
49251:       if (!mCustomNonClient)
49251:         break;
49251: 
49251:       // let the dwm handle nc painting on glass
49251:       if(nsUXThemeData::CheckForCompositor())
49251:         break;
49251: 
49251:       if (wParam == TRUE) {
49251:         // going active
49251:         *aRetValue = FALSE; // ignored
79626:         result = true;
79626:         UpdateGetWindowInfoCaptionStatus(true);
49251:         // invalidate to trigger a paint
49251:         InvalidateNonClientRegion();
49251:         break;
49251:       } else {
49251:         // going inactive
49251:         *aRetValue = TRUE; // go ahead and deactive
79626:         result = true;
79626:         UpdateGetWindowInfoCaptionStatus(false);
49251:         // invalidate to trigger a paint
49251:         InvalidateNonClientRegion();
49251:         break;
49251:       }
49251:     }
49251: 
49251:     case WM_NCPAINT:
49251:     {
49251:       /*
49251:        * Reset the non-client paint region so that it excludes the
49251:        * non-client areas we paint manually. Then call defwndproc
49251:        * to do the actual painting.
49251:        */
49251: 
49251:       if (!mCustomNonClient)
49251:         break;
49251: 
49251:       // let the dwm handle nc painting on glass
49251:       if(nsUXThemeData::CheckForCompositor())
49251:         break;
49251: 
49251:       HRGN paintRgn = ExcludeNonClientFromPaintRegion((HRGN)wParam);
49251:       LRESULT res = CallWindowProcW(GetPrevWindowProc(), mWnd,
49251:                                     msg, (WPARAM)paintRgn, lParam);
49251:       if (paintRgn != (HRGN)wParam)
49251:         DeleteObject(paintRgn);
49251:       *aRetValue = res;
79626:       result = true;
49251:     }
49251:     break;
49251: 
29835:     case WM_POWERBROADCAST:
29835:       switch (wParam)
29835:       {
29835:         case PBT_APMSUSPEND:
82031:           PostSleepWakeNotification(true);
29835:           break;
29835:         case PBT_APMRESUMEAUTOMATIC:
29835:         case PBT_APMRESUMECRITICAL:
29835:         case PBT_APMRESUMESUSPEND:
82031:           PostSleepWakeNotification(false);
82031:           break;
29835:       }
29835:       break;
29835: 
29835:     case WM_MOVE: // Window moved
29835:     {
48256:       RECT rect;
48256:       ::GetWindowRect(mWnd, &rect);
48256:       result = OnMove(rect.left, rect.top);
29835:     }
29835:     break;
29835: 
29835:     case WM_CLOSE: // close request
29835:       DispatchStandardEvent(NS_XUL_CLOSE);
79626:       result = true; // abort window closure
29835:       break;
29835: 
29835:     case WM_DESTROY:
29835:       // clean up.
29835:       OnDestroy();
79626:       result = true;
29835:       break;
29835: 
29835:     case WM_PAINT:
71484:       if (CleartypeSettingChanged()) {
71484:         ForceFontUpdate();
71484:         gfxFontCache *fc = gfxFontCache::GetCache();
71484:         if (fc) {
71484:           fc->Flush();
71484:         }
71484:       }
47756:       *aRetValue = (int) OnPaint(NULL, 0);
79626:       result = true;
29835:       break;
29835: 
29835:     case WM_PRINTCLIENT:
47756:       result = OnPaint((HDC) wParam, 0);
29835:       break;
29835: 
29835:     case WM_HOTKEY:
29835:       result = OnHotKey(wParam, lParam);
29835:       break;
29835: 
29835:     case WM_SYSCHAR:
29835:     case WM_CHAR:
29835:     {
86569:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
29835:       result = ProcessCharMessage(nativeMsg, nsnull);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_SYSKEYUP:
29835:     case WM_KEYUP:
29835:     {
86569:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
62480:       nativeMsg.time = ::GetMessageTime();
29835:       result = ProcessKeyUpMessage(nativeMsg, nsnull);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_SYSKEYDOWN:
29835:     case WM_KEYDOWN:
29835:     {
86569:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
29835:       result = ProcessKeyDownMessage(nativeMsg, nsnull);
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     // say we've dealt with erase background if widget does
29835:     // not need auto-erasing
29835:     case WM_ERASEBKGND:
32194:       if (!AutoErase((HDC)wParam)) {
29835:         *aRetValue = 1;
79626:         result = true;
29835:       }
29835:       break;
29835: 
29835:     case WM_MOUSEMOVE:
29835:     {
79626:       mMousePresent = true;
59195: 
29835:       // Suppress dispatch of pending events
29835:       // when mouse moves are generated by widget
29835:       // creation instead of user input.
29835:       LPARAM lParamScreen = lParamToScreen(lParam);
29835:       POINT mp;
29835:       mp.x      = GET_X_LPARAM(lParamScreen);
29835:       mp.y      = GET_Y_LPARAM(lParamScreen);
79445:       bool userMovedMouse = false;
29835:       if ((sLastMouseMovePoint.x != mp.x) || (sLastMouseMovePoint.y != mp.y)) {
79626:         userMovedMouse = true;
29835:       }
29835: 
40485:       result = DispatchMouseEvent(NS_MOUSE_MOVE, wParam, lParam,
79626:                                   false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
29835:       if (userMovedMouse) {
29835:         DispatchPendingEvents();
29835:       }
29835:     }
29835:     break;
29835: 
59195:     case WM_NCMOUSEMOVE:
59195:       // If we receive a mouse move event on non-client chrome, make sure and
59195:       // send an NS_MOUSE_EXIT event as well.
60909:       if (mMousePresent && !sIsInMouseCapture)
59195:         SendMessage(mWnd, WM_MOUSELEAVE, 0, 0);
59195:     break;
59195: 
29835:     case WM_LBUTTONDOWN:
29835:     {
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam,
79626:                                   false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
29835:       DispatchPendingEvents();
29835:     }
29835:     break;
29835: 
29835:     case WM_LBUTTONUP:
29835:     {
29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam,
79626:                                   false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
29835:       DispatchPendingEvents();
68855:     }
68855:     break;
68855: 
29835:     case WM_MOUSELEAVE:
29835:     {
59195:       if (!mMousePresent)
59195:         break;
79626:       mMousePresent = false;
59195: 
29835:       // We need to check mouse button states and put them in for
29835:       // wParam.
29835:       WPARAM mouseState = (GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0)
29835:         | (GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0)
29835:         | (GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0);
29835:       // Synthesize an event position because we don't get one from
29835:       // WM_MOUSELEAVE.
29835:       LPARAM pos = lParamToClient(::GetMessagePos());
79626:       DispatchMouseEvent(NS_MOUSE_EXIT, mouseState, pos, false,
40485:                          nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
29835:     }
29835:     break;
29835: 
29835:     case WM_CONTEXTMENU:
29835:     {
29835:       // if the context menu is brought up from the keyboard, |lParam|
48920:       // will be -1.
29835:       LPARAM pos;
79445:       bool contextMenukey = false;
48920:       if (lParam == -1)
29835:       {
79626:         contextMenukey = true;
29835:         pos = lParamToClient(GetMessagePos());
29835:       }
29835:       else
29835:       {
29835:         pos = lParamToClient(lParam);
29835:       }
40485: 
29835:       result = DispatchMouseEvent(NS_CONTEXTMENU, wParam, pos, contextMenukey,
29835:                                   contextMenukey ?
29835:                                     nsMouseEvent::eLeftButton :
40485:                                     nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
55157:       if (lParam != -1 && !result && mCustomNonClient &&
55157:           DispatchMouseEvent(NS_MOUSE_MOZHITTEST, wParam, pos,
79626:                              false, nsMouseEvent::eLeftButton,
55063:                              MOUSE_INPUT_SOURCE())) {
55063:         // Blank area hit, throw up the system menu.
56383:         DisplaySystemMenu(mWnd, mSizeMode, mIsRTL, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
79626:         result = true;
55157:       }
55157:     }
55157:     break;
55157: 
55157:     case WM_LBUTTONDBLCLK:
79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, false,
55157:                                   nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_MBUTTONDOWN:
79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, false,
55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_MBUTTONUP:
79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, false,
55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_MBUTTONDBLCLK:
79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, false,
55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_NCMBUTTONDOWN:
79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, 0, lParamToClient(lParam), false,
55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_NCMBUTTONUP:
79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam), false,
55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_NCMBUTTONDBLCLK:
79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam), false,
55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_RBUTTONDOWN:
79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, false,
55157:                                   nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
55157: 
55157:     case WM_RBUTTONUP:
79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, false,
40485:                                   nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
29835:       DispatchPendingEvents();
29835:       break;
29835: 
29835:     case WM_RBUTTONDBLCLK:
79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, false,
40485:                                   nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
29835:       break;
29835: 
46334:     case WM_NCRBUTTONDOWN:
46334:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, 0, lParamToClient(lParam), 
79626:                                   false, nsMouseEvent::eRightButton,
46334:                                   MOUSE_INPUT_SOURCE());
46334:       DispatchPendingEvents();
46334:       break;
46334: 
46334:     case WM_NCRBUTTONUP:
46334:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam),
79626:                                   false, nsMouseEvent::eRightButton,
46334:                                   MOUSE_INPUT_SOURCE());
46334:       DispatchPendingEvents();
46334:       break;
46334: 
46334:     case WM_NCRBUTTONDBLCLK:
46334:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam),
79626:                                   false, nsMouseEvent::eRightButton,
46334:                                   MOUSE_INPUT_SOURCE());
55157:       DispatchPendingEvents();
55157:       break;
46334: 
63936:     case WM_EXITSIZEMOVE:
63936:       if (!sIsInMouseCapture) {
63936:         DispatchStandardEvent(NS_DONESIZEMOVE);
63936:       }
63936:       break;
63936: 
71877:     case WM_NCLBUTTONDBLCLK:
71877:       DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam),
79626:                          false, nsMouseEvent::eLeftButton,
71877:                          MOUSE_INPUT_SOURCE());
71877:       result = 
71877:         DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam),
79626:                            false, nsMouseEvent::eLeftButton,
71877:                            MOUSE_INPUT_SOURCE());
71877:       DispatchPendingEvents();
71877:       break;
71877: 
29835:     case WM_APPCOMMAND:
29835:     {
29835:       PRUint32 appCommand = GET_APPCOMMAND_LPARAM(lParam);
29835: 
29835:       switch (appCommand)
29835:       {
29835:         case APPCOMMAND_BROWSER_BACKWARD:
29835:         case APPCOMMAND_BROWSER_FORWARD:
29835:         case APPCOMMAND_BROWSER_REFRESH:
29835:         case APPCOMMAND_BROWSER_STOP:
29835:         case APPCOMMAND_BROWSER_SEARCH:
29835:         case APPCOMMAND_BROWSER_FAVORITES:
29835:         case APPCOMMAND_BROWSER_HOME:
29835:           DispatchCommandEvent(appCommand);
29835:           // tell the driver that we handled the event
29835:           *aRetValue = 1;
79626:           result = true;
79626:           break;
79626:       }
79626:       // default = false - tell the driver that the event was not handled
29835:     }
29835:     break;
29835: 
29835:     case WM_HSCROLL:
29835:     case WM_VSCROLL:
39248:       *aRetValue = 0;
39248:       result = OnScroll(msg, wParam, lParam);
29835:       break;
29835: 
74639:     case MOZ_WM_HSCROLL:
74639:     case MOZ_WM_VSCROLL:
74639:       *aRetValue = 0;
86569:       OnScrollInternal(WinUtils::GetNativeMessage(msg), wParam, lParam);
74639:       // Doesn't need to call next wndproc for internal message.
79626:       return true;
74639: 
29835:     // The WM_ACTIVATE event is fired when a window is raised or lowered,
29835:     // and the loword of wParam specifies which. But we don't want to tell
29835:     // the focus system about this until the WM_SETFOCUS or WM_KILLFOCUS
29835:     // events are fired. Instead, set either the sJustGotActivate or
29835:     // gJustGotDeativate flags and fire the NS_ACTIVATE or NS_DEACTIVATE
29835:     // events once the focus events arrive.
29835:     case WM_ACTIVATE:
29835:       if (mEventCallback) {
29835:         PRInt32 fActive = LOWORD(wParam);
29835: 
29835:         if (WA_INACTIVE == fActive) {
29835:           // when minimizing a window, the deactivation and focus events will
29835:           // be fired in the reverse order. Instead, just dispatch
29835:           // NS_DEACTIVATE right away.
29835:           if (HIWORD(wParam))
29835:             result = DispatchFocusToTopLevelWindow(NS_DEACTIVATE);
29835:           else
79626:             sJustGotDeactivate = true;
68855: 
29835:           if (mIsTopWidgetWindow)
29835:             mLastKeyboardLayout = gKbdLayout.GetLayout();
29835: 
29835:         } else {
29835:           StopFlashing();
29835: 
79626:           sJustGotActivate = true;
79626:           nsMouseEvent event(true, NS_MOUSE_ACTIVATE, this,
29835:                              nsMouseEvent::eReal);
29835:           InitEvent(event);
51212:           DispatchWindowEvent(&event);
29835:           if (sSwitchKeyboardLayout && mLastKeyboardLayout)
29835:             ActivateKeyboardLayout(mLastKeyboardLayout, 0);
68855:         }
68855:       }
68855:       break;
68855:       
29835:     case WM_MOUSEACTIVATE:
29835:       if (mWindowType == eWindowType_popup) {
29835:         // a popup with a parent owner should not be activated when clicked
29835:         // but should still allow the mouse event to be fired, so the return
29835:         // value is set to MA_NOACTIVATE. But if the owner isn't the frontmost
29835:         // window, just use default processing so that the window is activated.
29835:         HWND owner = ::GetWindow(mWnd, GW_OWNER);
29835:         if (owner && owner == ::GetForegroundWindow()) {
29835:           *aRetValue = MA_NOACTIVATE;
79626:           result = true;
29835:         }
29835:       }
29835:       break;
29835: 
29835:     case WM_WINDOWPOSCHANGING:
29835:     {
29835:       LPWINDOWPOS info = (LPWINDOWPOS) lParam;
29835:       OnWindowPosChanging(info);
29835:     }
29835:     break;
29835: 
29835:     case WM_SETFOCUS:
60495:       // If previous focused window isn't ours, it must have received the
60495:       // redirected message.  So, we should forget it.
86569:       if (!WinUtils::IsOurProcessWindow(HWND(wParam))) {
60495:         ForgetRedirectedKeyDownMessage();
60495:       }
29835:       if (sJustGotActivate) {
29835:         result = DispatchFocusToTopLevelWindow(NS_ACTIVATE);
29835:       }
29835:       break;
29835: 
29835:     case WM_KILLFOCUS:
89672:       if (sJustGotDeactivate) {
29835:         result = DispatchFocusToTopLevelWindow(NS_DEACTIVATE);
29835:       }
29835:       break;
29835: 
29835:     case WM_WINDOWPOSCHANGED:
29835:     {
29835:       WINDOWPOS *wp = (LPWINDOWPOS)lParam;
31345:       OnWindowPosChanged(wp, result);
31347:     }
29835:     break;
29835: 
29835:     case WM_SETTINGCHANGE:
69947:       switch (wParam) {
69947:         case SPI_SETWHEELSCROLLLINES:
69947:         case SPI_SETWHEELSCROLLCHARS:
79626:           sNeedsToInitMouseWheelSettings = true;
69947:           break;
69947:       }
29835:       break;
29835: 
29835:     case WM_INPUTLANGCHANGEREQUEST:
29835:       *aRetValue = TRUE;
79626:       result = false;
29835:       break;
29835: 
29835:     case WM_INPUTLANGCHANGE:
29835:       result = OnInputLangChange((HKL)lParam);
29835:       break;
29835: 
29835:     case WM_DESTROYCLIPBOARD:
29835:     {
29835:       nsIClipboard* clipboard;
29835:       nsresult rv = CallGetService(kCClipboardCID, &clipboard);
51212:       if(NS_SUCCEEDED(rv)) {
29835:         clipboard->EmptyClipboard(nsIClipboard::kGlobalClipboard);
29835:         NS_RELEASE(clipboard);
29835:       }
51212:     }
29835:     break;
29835: 
29835: #ifdef ACCESSIBILITY
29835:     case WM_GETOBJECT:
29835:     {
29835:       *aRetValue = 0;
73809:       // Do explicit casting to make it working on 64bit systems (see bug 649236
73809:       // for details).
73809:       DWORD objId = static_cast<DWORD>(lParam);
73809:       if (objId == OBJID_CLIENT) { // oleacc.dll will be loaded dynamically
42313:         nsAccessible *rootAccessible = GetRootAccessible(); // Held by a11y cache
29835:         if (rootAccessible) {
29835:           IAccessible *msaaAccessible = NULL;
29835:           rootAccessible->GetNativeInterface((void**)&msaaAccessible); // does an addref
29835:           if (msaaAccessible) {
29835:             *aRetValue = LresultFromObject(IID_IAccessible, wParam, msaaAccessible); // does an addref
29835:             msaaAccessible->Release(); // release extra addref
79626:             result = true;  // We handled the WM_GETOBJECT message
29835:           }
29835:         }
29835:       }
29835:     }
29835: #endif
29835: 
29835:     case WM_SYSCOMMAND:
58330:     {
58330:       WPARAM filteredWParam = (wParam &0xFFF0);
29835:       // prevent Windows from trimming the working set. bug 76831
58330:       if (!sTrimOnMinimize && filteredWParam == SC_MINIMIZE) {
29835:         ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
79626:         result = true;
29835:       }
56383: 
56383:       // Handle the system menu manually when we're in full screen mode
56383:       // so we can set the appropriate options.
58330:       if (filteredWParam == SC_KEYMENU && lParam == VK_SPACE &&
56383:           mSizeMode == nsSizeMode_Fullscreen) {
56383:         DisplaySystemMenu(mWnd, mSizeMode, mIsRTL,
56383:                           MOZ_SYSCONTEXT_X_POS,
56383:                           MOZ_SYSCONTEXT_Y_POS);
79626:         result = true;
56383:       }
58330:     }
29835:     break;
29835: 
29835:   case WM_MOUSEWHEEL:
29835:   case WM_MOUSEHWHEEL:
74639:     OnMouseWheel(msg, wParam, lParam, aRetValue);
74639:     // We don't need to call next wndproc WM_MOUSEWHEEL and WM_MOUSEHWHEEL.
74639:     // We should consume them always.  If the messages would be handled by
74639:     // our window again, it causes making infinite message loop.
79626:     return true;
74639: 
74639:   case MOZ_WM_MOUSEVWHEEL:
74639:   case MOZ_WM_MOUSEHWHEEL:
74639:     {
86569:       UINT nativeMessage = WinUtils::GetNativeMessage(msg);
29851:       // If OnMouseWheel returns true, the event was forwarded directly to another
29851:       // mozilla window message handler (ProcessMessage). In this case the return
29851:       // value of the forwarded event is in 'result' which we should return immediately.
29851:       // If OnMouseWheel returns false, OnMouseWheel processed the event internally.
29851:       // 'result' and 'aRetValue' will be set based on what we did with the event, so
29851:       // we should fall through.
74639:       OnMouseWheelInternal(nativeMessage, wParam, lParam, aRetValue);
74639:       // Doesn't need to call next wndproc for internal message.
79626:       return true;
74639:     }
29835: 
29835:   case WM_DWMCOMPOSITIONCHANGED:
57844:     // First, update the compositor state to latest one. All other methods
57844:     // should use same state as here for consistency painting.
79626:     nsUXThemeData::CheckForCompositor(true);
57844: 
46200:     UpdateNonClientMargins();
57394:     RemovePropW(mWnd, kManageWindowInfoProperty);
29835:     BroadcastMsg(mWnd, WM_DWMCOMPOSITIONCHANGED);
29835:     DispatchStandardEvent(NS_THEMECHANGED);
39718:     UpdateGlass();
87336:     Invalidate(true, true, true);
29835:     break;
29835: 
41071:   case WM_UPDATEUISTATE:
41071:   {
41071:     // If the UI state has changed, fire an event so the UI updates the
41071:     // keyboard cues based on the system setting and how the window was
41071:     // opened. For example, a dialog opened via a keyboard press on a button
41071:     // should enable cues, whereas the same dialog opened via a mouse click of
41071:     // the button should not.
41071:     PRInt32 action = LOWORD(wParam);
41071:     if (action == UIS_SET || action == UIS_CLEAR) {
79626:       nsUIStateChangeEvent event(true, NS_UISTATECHANGED, this);
41071:       PRInt32 flags = HIWORD(wParam);
41071:       if (flags & UISF_HIDEACCEL)
41071:         event.showAccelerators = (action == UIS_SET) ? UIStateChangeType_Clear : UIStateChangeType_Set;
41071:       if (flags & UISF_HIDEFOCUS)
41071:         event.showFocusRings = (action == UIS_SET) ? UIStateChangeType_Clear : UIStateChangeType_Set;
41071:       DispatchWindowEvent(&event);
41071:     }
41071: 
41071:     break;
41071:   }
41071: 
29835:   /* Gesture support events */
29835:   case WM_TABLET_QUERYSYSTEMGESTURESTATUS:
29835:     // According to MS samples, this must be handled to enable
29835:     // rotational support in multi-touch drivers.
79626:     result = true;
29835:     *aRetValue = TABLET_ROTATE_GESTURE_ENABLE;
29835:     break;
29835: 
48711: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
48711:   case WM_TOUCH:
48711:     result = OnTouch(wParam, lParam);
48711:     if (result) {
48711:       *aRetValue = 0;
48711:     }
48711:     break;
48711: #endif
48711: 
29835:   case WM_GESTURE:
29835:     result = OnGesture(wParam, lParam);
29835:     break;
31443: 
31443:   case WM_GESTURENOTIFY:
31443:     {
31443:       if (mWindowType != eWindowType_invisible &&
51608:           mWindowType != eWindowType_plugin) {
51608:         // A GestureNotify event is dispatched to decide which single-finger panning
51608:         // direction should be active (including none) and if pan feedback should
51608:         // be displayed. Java and plugin windows can make their own calls.
31443:         GESTURENOTIFYSTRUCT * gestureinfo = (GESTURENOTIFYSTRUCT*)lParam;
31443:         nsPointWin touchPoint;
31443:         touchPoint = gestureinfo->ptsLocation;
31443:         touchPoint.ScreenToClient(mWnd);
79626:         nsGestureNotifyEvent gestureNotifyEvent(true, NS_GESTURENOTIFY_EVENT_START, this);
31443:         gestureNotifyEvent.refPoint = touchPoint;
31443:         nsEventStatus status;
31443:         DispatchEvent(&gestureNotifyEvent, status);
31443:         mDisplayPanFeedback = gestureNotifyEvent.displayPanFeedback;
48711:         if (!mTouchWindow)
31443:           mGesture.SetWinGestureSupport(mWnd, gestureNotifyEvent.panDirection);
31443:       }
79626:       result = false; //should always bubble to DefWindowProc
31443:     }
31443:     break;
29835: 
31218:     case WM_CLEAR:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_DELETE, this);
31218:       DispatchWindowEvent(&command);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case WM_CUT:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_CUT, this);
31218:       DispatchWindowEvent(&command);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case WM_COPY:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_COPY, this);
31218:       DispatchWindowEvent(&command);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case WM_PASTE:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE, this);
31218:       DispatchWindowEvent(&command);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case EM_UNDO:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_UNDO, this);
31218:       DispatchWindowEvent(&command);
31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case EM_REDO:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_REDO, this);
31218:       DispatchWindowEvent(&command);
31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case EM_CANPASTE:
31218:     {
31218:       // Support EM_CANPASTE message only when wParam isn't specified or
31218:       // is plain text format.
31218:       if (wParam == 0 || wParam == CF_TEXT || wParam == CF_UNICODETEXT) {
79626:         nsContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE,
79626:                                       this, true);
31218:         DispatchWindowEvent(&command);
31218:         *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
79626:         result = true;
31218:       }
31218:     }
31218:     break;
31218: 
31218:     case EM_CANUNDO:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_UNDO,
79626:                                     this, true);
31218:       DispatchWindowEvent(&command);
31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
79626:       result = true;
31218:     }
31218:     break;
31218: 
31218:     case EM_CANREDO:
31218:     {
79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_REDO,
79626:                                     this, true);
31218:       DispatchWindowEvent(&command);
31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
79626:       result = true;
31218:     }
31218:     break;
31985: 
29835:     default:
29835:     {
29835: #ifdef NS_ENABLE_TSF
29835:       if (msg == WM_USER_TSF_TEXTCHANGE) {
29835:         nsTextStore::OnTextChangeMsg();
29835:       }
29835: #endif //NS_ENABLE_TSF
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486:       if (msg == nsAppShell::GetTaskbarButtonCreatedMessage())
33486:         SetHasTaskbarIconBeenCreated();
33486: #endif
37550:       if (msg == sOOPPPluginFocusEvent) {
44190:         if (wParam == 1) {
37550:           // With OOPP, the plugin window exists in another process and is a child of
37550:           // this window. This window is a placeholder plugin window for the dom. We
37550:           // receive this event when the child window receives focus. (sent from
37550:           // PluginInstanceParent.cpp)
37550:           ::SendMessage(mWnd, WM_MOUSEACTIVATE, 0, 0); // See nsPluginNativeWindowWin.cpp
44190:         } else {
44190:           // WM_KILLFOCUS was received by the child process.
44190:           if (sJustGotDeactivate) {
44190:             DispatchFocusToTopLevelWindow(NS_DEACTIVATE);
44190:           }
44190:         }
37550:       }
29835:     }
29835:     break;
29835:   }
29835: 
29835:   //*aRetValue = result;
29835:   if (mWnd) {
29835:     return result;
29835:   }
29835:   else {
29835:     //Events which caused mWnd destruction and aren't consumed
29835:     //will crash during the Windows default processing.
79626:     return true;
29835:   }
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Broadcast messaging
29835:  *
29835:  * Broadcast messages to all windows.
29835:  *
29835:  **************************************************************/
29835: 
29835: // Enumerate all child windows sending aMsg to each of them
29835: BOOL CALLBACK nsWindow::BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg)
29835: {
29835:   WNDPROC winProc = (WNDPROC)::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
29835:   if (winProc == &nsWindow::WindowProc) {
29835:     // it's one of our windows so go ahead and send a message to it
29835:     ::CallWindowProcW(winProc, aWnd, aMsg, 0, 0);
29835:   }
29835:   return TRUE;
29835: }
29835: 
29835: // Enumerate all top level windows specifying that the children of each
29835: // top level window should be enumerated. Do *not* send the message to
29835: // each top level window since it is assumed that the toolkit will send
29835: // aMsg to them directly.
29835: BOOL CALLBACK nsWindow::BroadcastMsg(HWND aTopWindow, LPARAM aMsg)
29835: {
29835:   // Iterate each of aTopWindows child windows sending the aMsg
29835:   // to each of them.
29835:   ::EnumChildWindows(aTopWindow, nsWindow::BroadcastMsgToChildren, aMsg);
29835:   return TRUE;
29835: }
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: Event processing helpers
29835:  *
29835:  * Special processing for certain event types and 
29835:  * synthesized events.
29835:  *
29835:  **************************************************************/
29835: 
46200: PRInt32
46200: nsWindow::ClientMarginHitTestPoint(PRInt32 mx, PRInt32 my)
46200: {
87238:   if (mSizeMode == nsSizeMode_Minimized ||
87238:       mSizeMode == nsSizeMode_Fullscreen) {
87238:     return HTCLIENT;
87238:   }
87238: 
46200:   // Calculations are done in screen coords
46200:   RECT winRect;
46200:   GetWindowRect(mWnd, &winRect);
46200: 
46200:   // hit return constants:
46200:   // HTBORDER                     - non-resizable border
46200:   // HTBOTTOM, HTLEFT, HTRIGHT, HTTOP - resizable border
46200:   // HTBOTTOMLEFT, HTBOTTOMRIGHT  - resizable corner
46200:   // HTTOPLEFT, HTTOPRIGHT        - resizable corner
46200:   // HTCAPTION                    - general title bar area
46200:   // HTCLIENT                     - area considered the client
46200:   // HTCLOSE                      - hovering over the close button
46200:   // HTMAXBUTTON                  - maximize button
46200:   // HTMINBUTTON                  - minimize button
46200: 
46200:   PRInt32 testResult = HTCLIENT;
46200: 
87238:   bool isResizable = (mBorderStyle & (eBorderStyle_all |
87238:                                       eBorderStyle_resizeh |
87238:                                       eBorderStyle_default)) > 0 ? true : false;
87238:   if (mSizeMode == nsSizeMode_Maximized)
87238:     isResizable = false;
87238: 
79445:   bool top    = false;
79445:   bool bottom = false;
79445:   bool left   = false;
79445:   bool right  = false;
46200: 
87238:   int topOffset = NS_MAX(mCaptionHeight - mNonClientOffset.top,
87238:                          kResizableBorderMinSize);
87238:   int bottomOffset = NS_MAX(mVertResizeMargin - mNonClientOffset.bottom,
87238:                             kResizableBorderMinSize);
87238:   int topBounds = winRect.top + topOffset;
87238:   int bottomBounds = winRect.bottom - bottomOffset;
87238: 
87238:   if (my >= winRect.top && my < topBounds)
79626:     top = true;
87238:   else if (my <= winRect.bottom && my > bottomBounds)
79626:     bottom = true;
46200: 
87238:   int leftOffset = NS_MAX(mHorResizeMargin - mNonClientOffset.left,
87238:                           kResizableBorderMinSize);
87238:   int rightOffset = NS_MAX(mHorResizeMargin - mNonClientOffset.right,
87238:                            kResizableBorderMinSize);
87238:   // (the 2x case here doubles the resize area for corners)
87238:   int leftBounds = winRect.left +
87238:                    (bottom ? (2*leftOffset) : leftOffset);
87238:   int rightBounds = winRect.right -
87238:                     (bottom ? (2*rightOffset) : rightOffset);
87238: 
87238:   if (mx >= winRect.left && mx < leftBounds)
79626:     left = true;
87238:   else if (mx <= winRect.right && mx > rightBounds)
79626:     right = true;
46200: 
87238:   if (isResizable) {
46200:     if (top) {
46200:       testResult = HTTOP;
46200:       if (left)
46200:         testResult = HTTOPLEFT;
46200:       else if (right)
46200:         testResult = HTTOPRIGHT;
46200:     } else if (bottom) {
46200:       testResult = HTBOTTOM;
46200:       if (left)
46200:         testResult = HTBOTTOMLEFT;
46200:       else if (right)
46200:         testResult = HTBOTTOMRIGHT;
46200:     } else {
46200:       if (left)
46200:         testResult = HTLEFT;
46200:       if (right)
46200:         testResult = HTRIGHT;
46200:     }
87238:   } else {
87238:     if (top)
87238:       testResult = HTCAPTION;
87238:     else if (bottom || left || right)
87238:       testResult = HTBORDER;
87238:   }
46200: 
79445:   bool contentOverlap = true;
48061: 
87238:   if (mSizeMode != nsSizeMode_Maximized) {
87238:     contentOverlap = mx >= winRect.left + leftOffset &&
87238:                      mx <= winRect.right - rightOffset &&
87238:                      my >= winRect.top + topOffset &&
87238:                      my <= winRect.bottom - bottomOffset;
48061:   }
46464: 
60909:   if (!sIsInMouseCapture &&
48061:       contentOverlap &&
46464:       (testResult == HTCLIENT ||
46464:        testResult == HTTOP ||
87238:        testResult == HTBORDER ||
46464:        testResult == HTTOPLEFT ||
46464:        testResult == HTCAPTION)) {
46334:     LPARAM lParam = MAKELPARAM(mx, my);
46334:     LPARAM lParamClient = lParamToClient(lParam);
79445:     bool result = DispatchMouseEvent(NS_MOUSE_MOZHITTEST, 0, lParamClient,
79626:                                      false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
46334:     if (result) {
46334:       // The mouse is over a blank area
46334:       testResult = testResult == HTCLIENT ? HTCAPTION : testResult;
46334: 
46334:     } else {
46334:       // There's content over the mouse pointer. Set HTCLIENT
46334:       // to possibly override a resizer border.
46334:       testResult = HTCLIENT;
46334:     }
46334:   }
46334: 
46200:   return testResult;
46200: }
46200: 
82031: void nsWindow::PostSleepWakeNotification(const bool aIsSleepMode)
82031: {
82031:   if (aIsSleepMode == gIsSleepMode)
82031:     return;
82031: 
82031:   gIsSleepMode = aIsSleepMode;
82031: 
41540:   nsCOMPtr<nsIObserverService> observerService =
41540:     mozilla::services::GetObserverService();
29835:   if (observerService)
82031:     observerService->NotifyObservers(nsnull,
82031:       aIsSleepMode ? "sleep_notification" : "wake_notification", nsnull);
29835: }
29835: 
60495: // RemoveNextCharMessage() should be called by WM_KEYDOWN or WM_SYSKEYDOWM
60495: // message handler.  If there is no WM_(SYS)CHAR message for it, this
60495: // method does nothing.
60495: // NOTE: WM_(SYS)CHAR message is posted by TranslateMessage() API which is
60495: // called in message loop.  So, WM_(SYS)KEYDOWN message should have
60495: // WM_(SYS)CHAR message in the queue if the keydown event causes character
60495: // input.
60495: 
60495: /* static */
60495: void nsWindow::RemoveNextCharMessage(HWND aWnd)
60495: {
60495:   MSG msg;
60495:   if (::PeekMessageW(&msg, aWnd,
60495:                      WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD) &&
60495:       (msg.message == WM_CHAR || msg.message == WM_SYSCHAR)) {
60495:     ::GetMessageW(&msg, aWnd, msg.message, msg.message);
60495:   }
60495: }
60495: 
79445: LRESULT nsWindow::ProcessCharMessage(const MSG &aMsg, bool *aEventDispatched)
29835: {
29835:   NS_PRECONDITION(aMsg.message == WM_CHAR || aMsg.message == WM_SYSCHAR,
29835:                   "message is not keydown event");
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
29835:          ("%s charCode=%d scanCode=%d\n",
29835:           aMsg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
29835:           aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF));
29835: 
29835:   // These must be checked here too as a lone WM_CHAR could be received
29835:   // if a child window didn't handle it (for example Alt+Space in a content window)
29835:   nsModifierKeyState modKeyState;
29835:   return OnChar(aMsg, modKeyState, aEventDispatched);
29835: }
29835: 
79445: LRESULT nsWindow::ProcessKeyUpMessage(const MSG &aMsg, bool *aEventDispatched)
29835: {
29835:   NS_PRECONDITION(aMsg.message == WM_KEYUP || aMsg.message == WM_SYSKEYUP,
29835:                   "message is not keydown event");
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
29835:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
29835:                         "WM_SYSKEYUP" : "WM_KEYUP", aMsg.wParam));
29835: 
29835:   nsModifierKeyState modKeyState;
29835: 
29835:   // Note: the original code passed (HIWORD(lParam)) to OnKeyUp as
29835:   // scan code. However, this breaks Alt+Num pad input.
29835:   // MSDN states the following:
29835:   //  Typically, ToAscii performs the translation based on the
29835:   //  virtual-key code. In some cases, however, bit 15 of the
29835:   //  uScanCode parameter may be used to distinguish between a key
29835:   //  press and a key release. The scan code is used for
29835:   //  translating ALT+number key combinations.
29835: 
29835:   // ignore [shift+]alt+space so the OS can handle it
29835:   if (modKeyState.mIsAltDown && !modKeyState.mIsControlDown &&
29835:       IS_VK_DOWN(NS_VK_SPACE)) {
29835:     return FALSE;
29835:   }
29835: 
49149:   if (!nsIMM32Handler::IsComposingOn(this) &&
39867:       (aMsg.message != WM_KEYUP || aMsg.wParam != VK_MENU)) {
29835:     // Ignore VK_MENU if it's not a system key release, so that the menu bar does not trigger
29835:     // This helps avoid triggering the menu bar for ALT key accelerators used in
29835:     // assistive technologies such as Window-Eyes and ZoomText, and when using Alt+Tab
29835:     // to switch back to Mozilla in Windows 95 and Windows 98
29835:     return OnKeyUp(aMsg, modKeyState, aEventDispatched);
29835:   }
29835: 
29835:   return 0;
29835: }
29835: 
29835: LRESULT nsWindow::ProcessKeyDownMessage(const MSG &aMsg,
79445:                                         bool *aEventDispatched)
29835: {
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
29835:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
29835:                         "WM_SYSKEYDOWN" : "WM_KEYDOWN", aMsg.wParam));
29835:   NS_PRECONDITION(aMsg.message == WM_KEYDOWN || aMsg.message == WM_SYSKEYDOWN,
29835:                   "message is not keydown event");
29835: 
60495:   // If this method doesn't call OnKeyDown(), this method must clean up the
60495:   // redirected message information itself.  For more information, see above
60495:   // comment of AutoForgetRedirectedKeyDownMessage struct definition in
60495:   // nsWindow.h.
60495:   AutoForgetRedirectedKeyDownMessage forgetRedirectedMessage(this, aMsg);
60495: 
29835:   nsModifierKeyState modKeyState;
29835: 
29835:   // Note: the original code passed (HIWORD(lParam)) to OnKeyDown as
29835:   // scan code. However, this breaks Alt+Num pad input.
29835:   // MSDN states the following:
29835:   //  Typically, ToAscii performs the translation based on the
29835:   //  virtual-key code. In some cases, however, bit 15 of the
29835:   //  uScanCode parameter may be used to distinguish between a key
29835:   //  press and a key release. The scan code is used for
29835:   //  translating ALT+number key combinations.
29835: 
29835:   // ignore [shift+]alt+space so the OS can handle it
29835:   if (modKeyState.mIsAltDown && !modKeyState.mIsControlDown &&
29835:       IS_VK_DOWN(NS_VK_SPACE))
29835:     return FALSE;
29835: 
29835:   LRESULT result = 0;
29835:   if (modKeyState.mIsAltDown && nsIMM32Handler::IsStatusChanged()) {
29835:     nsIMM32Handler::NotifyEndStatusChange();
49149:   } else if (!nsIMM32Handler::IsComposingOn(this)) {
29835:     result = OnKeyDown(aMsg, modKeyState, aEventDispatched, nsnull);
60495:     // OnKeyDown cleaned up the redirected message information itself, so,
60495:     // we should do nothing.
79626:     forgetRedirectedMessage.mCancel = true;
29835:   }
29835: 
29835:   if (aMsg.wParam == VK_MENU ||
29835:       (aMsg.wParam == VK_F10 && !modKeyState.mIsShiftDown)) {
29835:     // We need to let Windows handle this keypress,
79626:     // by returning false, if there's a native menu
29835:     // bar somewhere in our containing window hierarchy.
29835:     // Otherwise we handle the keypress and don't pass
79626:     // it on to Windows, by returning true.
79445:     bool hasNativeMenu = false;
29835:     HWND hWnd = mWnd;
29835:     while (hWnd) {
29835:       if (::GetMenu(hWnd)) {
79626:         hasNativeMenu = true;
29835:         break;
29835:       }
29835:       hWnd = ::GetParent(hWnd);
29835:     }
29835:     result = !hasNativeMenu;
29835:   }
29835: 
29835:   return result;
29835: }
29835: 
29835: nsresult
29835: nsWindow::SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
29835:                                    PRInt32 aNativeKeyCode,
29835:                                    PRUint32 aModifierFlags,
29835:                                    const nsAString& aCharacters,
29835:                                    const nsAString& aUnmodifiedCharacters)
29835: {
29835:   nsPrintfCString layoutName("%08x", aNativeKeyboardLayout);
29835:   HKL loadedLayout = LoadKeyboardLayoutA(layoutName.get(), KLF_NOTELLSHELL);
29835:   if (loadedLayout == NULL)
29835:     return NS_ERROR_NOT_AVAILABLE;
29835: 
29835:   // Setup clean key state and load desired layout
29835:   BYTE originalKbdState[256];
29835:   ::GetKeyboardState(originalKbdState);
29835:   BYTE kbdState[256];
29835:   memset(kbdState, 0, sizeof(kbdState));
29835:   // This changes the state of the keyboard for the current thread only,
29835:   // and we'll restore it soon, so this should be OK.
29835:   ::SetKeyboardState(kbdState);
29835:   HKL oldLayout = gKbdLayout.GetLayout();
29835:   gKbdLayout.LoadLayout(loadedLayout);
29835: 
29835:   nsAutoTArray<KeyPair,10> keySequence;
29835:   SetupKeyModifiersSequence(&keySequence, aModifierFlags);
29835:   NS_ASSERTION(aNativeKeyCode >= 0 && aNativeKeyCode < 256,
29835:                "Native VK key code out of range");
29835:   keySequence.AppendElement(KeyPair(aNativeKeyCode, 0));
29835: 
29835:   // Simulate the pressing of each modifier key and then the real key
29835:   for (PRUint32 i = 0; i < keySequence.Length(); ++i) {
29835:     PRUint8 key = keySequence[i].mGeneral;
29835:     PRUint8 keySpecific = keySequence[i].mSpecific;
29835:     kbdState[key] = 0x81; // key is down and toggled on if appropriate
29835:     if (keySpecific) {
29835:       kbdState[keySpecific] = 0x81;
29835:     }
29835:     ::SetKeyboardState(kbdState);
29835:     nsModifierKeyState modKeyState;
86569:     MSG msg = WinUtils::InitMSG(WM_KEYDOWN, key, 0);
29835:     if (i == keySequence.Length() - 1 && aCharacters.Length() > 0) {
29835:       UINT scanCode = ::MapVirtualKeyEx(aNativeKeyCode, MAPVK_VK_TO_VSC,
29835:                                         gKbdLayout.GetLayout());
29835:       nsFakeCharMessage fakeMsg = { aCharacters.CharAt(0), scanCode };
29835:       OnKeyDown(msg, modKeyState, nsnull, &fakeMsg);
29835:     } else {
29835:       OnKeyDown(msg, modKeyState, nsnull, nsnull);
29835:     }
29835:   }
29835:   for (PRUint32 i = keySequence.Length(); i > 0; --i) {
29835:     PRUint8 key = keySequence[i - 1].mGeneral;
29835:     PRUint8 keySpecific = keySequence[i - 1].mSpecific;
29835:     kbdState[key] = 0; // key is up and toggled off if appropriate
29835:     if (keySpecific) {
29835:       kbdState[keySpecific] = 0;
29835:     }
29835:     ::SetKeyboardState(kbdState);
29835:     nsModifierKeyState modKeyState;
86569:     MSG msg = WinUtils::InitMSG(WM_KEYUP, key, 0);
29835:     OnKeyUp(msg, modKeyState, nsnull);
29835:   }
29835: 
29835:   // Restore old key state and layout
29835:   ::SetKeyboardState(originalKbdState);
29835:   gKbdLayout.LoadLayout(oldLayout);
29835: 
29835:   UnloadKeyboardLayout(loadedLayout);
29835:   return NS_OK;
29835: }
29835: 
33863: nsresult
33863: nsWindow::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
33863:                                      PRUint32 aNativeMessage,
33863:                                      PRUint32 aModifierFlags)
33863: {
33863:   RECT r;
33863:   ::GetWindowRect(mWnd, &r);
33863:   ::SetCursorPos(r.left + aPoint.x, r.top + aPoint.y);
33863: 
33863:   INPUT input;
33863:   memset(&input, 0, sizeof(input));
33863: 
33863:   input.type = INPUT_MOUSE;
33863:   input.mi.dwFlags = aNativeMessage;
33863:   ::SendInput(1, &input, sizeof(INPUT));
33863: 
33863:   return NS_OK;
33863: }
33863: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: OnXXX message handlers
29835:  *
29835:  * For message handlers that need to be broken out or
29835:  * implemented in specific platform code.
29835:  *
29835:  **************************************************************/
29835: 
29835: BOOL nsWindow::OnInputLangChange(HKL aHKL)
29835: {
29835: #ifdef KE_DEBUG
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("OnInputLanguageChange\n"));
29835: #endif
29835:   gKbdLayout.LoadLayout(aHKL);
79626:   return false;   // always pass to child window
29835: }
29835: 
79445: void nsWindow::OnWindowPosChanged(WINDOWPOS *wp, bool& result)
31345: {
31345:   if (wp == nsnull)
31345:     return;
31345: 
34735: #ifdef WINSTATE_DEBUG_OUTPUT
86569:   if (mWnd == WinUtils::GetTopLevelHWND(mWnd)) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** OnWindowPosChanged: [  top] "));
76714:   } else {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** OnWindowPosChanged: [child] "));
76714:   }
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("WINDOWPOS flags:"));
76714:   if (wp->flags & SWP_FRAMECHANGED) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_FRAMECHANGED "));
76714:   }
76714:   if (wp->flags & SWP_SHOWWINDOW) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_SHOWWINDOW "));
76714:   }
76714:   if (wp->flags & SWP_NOSIZE) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOSIZE "));
76714:   }
76714:   if (wp->flags & SWP_HIDEWINDOW) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_HIDEWINDOW "));
76714:   }
76714:   if (wp->flags & SWP_NOZORDER) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOZORDER "));
76714:   }
76714:   if (wp->flags & SWP_NOACTIVATE) {
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOACTIVATE "));
76714:   }
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n"));
31345: #endif
31345: 
34735:   // Handle window size mode changes
46335:   if (wp->flags & SWP_FRAMECHANGED && mSizeMode != nsSizeMode_Fullscreen) {
56369: 
56369:     // Bug 566135 - Windows theme code calls show window on SW_SHOWMINIMIZED
56369:     // windows when fullscreen games disable desktop composition. If we're
56369:     // minimized and not being activated, ignore the event and let windows
56369:     // handle it.
56369:     if (mSizeMode == nsSizeMode_Minimized && (wp->flags & SWP_NOACTIVATE))
56369:       return;
56369: 
79626:     nsSizeModeEvent event(true, NS_SIZEMODE, this);
34735: 
31345:     WINDOWPLACEMENT pl;
31345:     pl.length = sizeof(pl);
31345:     ::GetWindowPlacement(mWnd, &pl);
31345: 
31345:     if (pl.showCmd == SW_SHOWMAXIMIZED)
62115:       event.mSizeMode = (mFullscreenMode ? nsSizeMode_Fullscreen : nsSizeMode_Maximized);
31345:     else if (pl.showCmd == SW_SHOWMINIMIZED)
31345:       event.mSizeMode = nsSizeMode_Minimized;
63113:     else if (mFullscreenMode)
63113:       event.mSizeMode = nsSizeMode_Fullscreen;
31345:     else
31345:       event.mSizeMode = nsSizeMode_Normal;
34735: 
31345:     // Windows has just changed the size mode of this window. The following
31345:     // NS_SIZEMODE event will trigger a call into SetSizeMode where we will
31345:     // set the min/max window state again or for nsSizeMode_Normal, call
31345:     // SetWindow with a parameter of SW_RESTORE. There's no need however as
31345:     // this window's mode has already changed. Updating mSizeMode here
31345:     // insures the SetSizeMode call is a no-op. Addresses a bug on Win7 related
31345:     // to window docking. (bug 489258)
31345:     mSizeMode = event.mSizeMode;
31345: 
34786:     // If !sTrimOnMinimize, we minimize windows using SW_SHOWMINIMIZED (See
34786:     // SetSizeMode for internal calls, and WM_SYSCOMMAND for external). This
34786:     // prevents the working set from being trimmed but keeps the window active.
34786:     // After the window is minimized, we need to do some touch up work on the
34786:     // active window. (bugs 76831 & 499816)
34786:     if (!sTrimOnMinimize && nsSizeMode_Minimized == event.mSizeMode)
34786:       ActivateOtherWindowHelper(mWnd);
34786: 
34735: #ifdef WINSTATE_DEBUG_OUTPUT
34735:     switch (mSizeMode) {
34735:       case nsSizeMode_Normal:
76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:                  ("*** mSizeMode: nsSizeMode_Normal\n"));
34735:         break;
34735:       case nsSizeMode_Minimized:
76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:                ("*** mSizeMode: nsSizeMode_Minimized\n"));
34735:         break;
34735:       case nsSizeMode_Maximized:
76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:                  ("*** mSizeMode: nsSizeMode_Maximized\n");
34735:         break;
34735:       default:
76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** mSizeMode: ??????\n");
34735:         break;
34735:     };
34735: #endif
34735: 
31345:     InitEvent(event);
31345: 
31345:     result = DispatchWindowEvent(&event);
34735: 
34735:     // Skip window size change events below on minimization.
34735:     if (mSizeMode == nsSizeMode_Minimized)
34735:       return;
34735:   }
34735: 
34735:   // Handle window size changes
56922:   if (!(wp->flags & SWP_NOSIZE)) {
34735:     RECT r;
34735:     PRInt32 newWidth, newHeight;
34735: 
34735:     ::GetWindowRect(mWnd, &r);
34735: 
34735:     newWidth  = r.right - r.left;
34735:     newHeight = r.bottom - r.top;
34735:     nsIntRect rect(wp->x, wp->y, newWidth, newHeight);
34735: 
34735: #ifdef MOZ_XUL
34735:     if (eTransparencyTransparent == mTransparencyMode)
34735:       ResizeTranslucentWindow(newWidth, newHeight);
34735: #endif
34735: 
34735:     if (newWidth > mLastSize.width)
34735:     {
34735:       RECT drect;
34735: 
34735:       // getting wider
34735:       drect.left   = wp->x + mLastSize.width;
34735:       drect.top    = wp->y;
34735:       drect.right  = drect.left + (newWidth - mLastSize.width);
34735:       drect.bottom = drect.top + newHeight;
34735: 
34735:       ::RedrawWindow(mWnd, &drect, NULL,
34735:                      RDW_INVALIDATE |
34735:                      RDW_NOERASE |
34735:                      RDW_NOINTERNALPAINT |
34735:                      RDW_ERASENOW |
34735:                      RDW_ALLCHILDREN);
34735:     }
34735:     if (newHeight > mLastSize.height)
34735:     {
34735:       RECT drect;
34735: 
34735:       // getting taller
34735:       drect.left   = wp->x;
34735:       drect.top    = wp->y + mLastSize.height;
34735:       drect.right  = drect.left + newWidth;
34735:       drect.bottom = drect.top + (newHeight - mLastSize.height);
34735: 
34735:       ::RedrawWindow(mWnd, &drect, NULL,
34735:                      RDW_INVALIDATE |
34735:                      RDW_NOERASE |
34735:                      RDW_NOINTERNALPAINT |
34735:                      RDW_ERASENOW |
34735:                      RDW_ALLCHILDREN);
34735:     }
34735: 
34735:     mBounds.width    = newWidth;
34735:     mBounds.height   = newHeight;
34735:     mLastSize.width  = newWidth;
34735:     mLastSize.height = newHeight;
34735: 
34735: #ifdef WINSTATE_DEBUG_OUTPUT
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:            ("*** Resize window: %d x %d x %d x %d\n", wp->x, wp->y, 
76714:             newWidth, newHeight));
34735: #endif
34735:     
48424:     // If a maximized window is resized, recalculate the non-client margins and
48424:     // ensure a 1 pixel margin at screen bottom to allow taskbar unhiding to
48424:     // work properly.
48424:     if (mSizeMode == nsSizeMode_Maximized) {
79626:       if (UpdateNonClientMargins(nsSizeMode_Maximized, true)) {
48424:         // gecko resize event already sent by UpdateNonClientMargins.
79626:         result = true;
48424:         return;
48424:       }
48424:     }
48424: 
34735:     // Recalculate the width and height based on the client area for gecko events.
34735:     if (::GetClientRect(mWnd, &r)) {
34735:       rect.width  = r.right - r.left;
34735:       rect.height = r.bottom - r.top;
34735:     }
34735:     
34735:     // Send a gecko resize event
34735:     result = OnResize(rect);
34735:   }
34735: }
34786: 
34786: // static
34786: void nsWindow::ActivateOtherWindowHelper(HWND aWnd)
34786: {
34786:   // Find the next window that is enabled, visible, and not minimized.
34786:   HWND hwndBelow = ::GetNextWindow(aWnd, GW_HWNDNEXT);
34786:   while (hwndBelow && (!::IsWindowEnabled(hwndBelow) || !::IsWindowVisible(hwndBelow) ||
34786:                        ::IsIconic(hwndBelow))) {
34786:     hwndBelow = ::GetNextWindow(hwndBelow, GW_HWNDNEXT);
34786:   }
34786: 
34786:   // Push ourselves to the bottom of the stack, then activate the
34786:   // next window.
34786:   ::SetWindowPos(aWnd, HWND_BOTTOM, 0, 0, 0, 0,
34786:                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
34786:   if (hwndBelow)
34786:     ::SetForegroundWindow(hwndBelow);
34786: 
34786:   // Play the minimize sound while we're here, since that is also
34786:   // forgotten when we use SW_SHOWMINIMIZED.
78043:   nsCOMPtr<nsISound> sound(do_CreateInstance("@mozilla.org/sound;1"));
78043:   if (sound) {
78043:     sound->PlaySystemSound(NS_LITERAL_STRING("Minimize"));
78043:   }
34786: }
68855: 
29835: void nsWindow::OnWindowPosChanging(LPWINDOWPOS& info)
29835: {
46332:   // Update non-client margins if the frame size is changing, and let the
46332:   // browser know we are changing size modes, so alternative css can kick in.
46335:   // If we're going into fullscreen mode, ignore this, since it'll reset
46335:   // margins to normal mode. 
56369:   if ((info->flags & SWP_FRAMECHANGED && !(info->flags & SWP_NOSIZE)) &&
56369:       mSizeMode != nsSizeMode_Fullscreen) {
46332:     WINDOWPLACEMENT pl;
46332:     pl.length = sizeof(pl);
46332:     ::GetWindowPlacement(mWnd, &pl);
46332:     PRInt32 sizeMode;
46332:     if (pl.showCmd == SW_SHOWMAXIMIZED)
62115:       sizeMode = (mFullscreenMode ? nsSizeMode_Fullscreen : nsSizeMode_Maximized);
46332:     else if (pl.showCmd == SW_SHOWMINIMIZED)
46332:       sizeMode = nsSizeMode_Minimized;
63113:     else if (mFullscreenMode)
63113:       sizeMode = nsSizeMode_Fullscreen;
46332:     else
46332:       sizeMode = nsSizeMode_Normal;
46332: 
79626:     nsSizeModeEvent event(true, NS_SIZEMODE, this);
46332: 
46332:     InitEvent(event);
46332:     event.mSizeMode = static_cast<nsSizeMode>(sizeMode);
46332:     DispatchWindowEvent(&event);
46332: 
79626:     UpdateNonClientMargins(sizeMode, false);
46332:   }
46332: 
29835:   // enforce local z-order rules
29835:   if (!(info->flags & SWP_NOZORDER)) {
29835:     HWND hwndAfter = info->hwndInsertAfter;
29835:     
79626:     nsZLevelEvent event(true, NS_SETZLEVEL, this);
29835:     nsWindow *aboveWindow = 0;
29835: 
29835:     InitEvent(event);
29835: 
29835:     if (hwndAfter == HWND_BOTTOM)
29835:       event.mPlacement = nsWindowZBottom;
29835:     else if (hwndAfter == HWND_TOP || hwndAfter == HWND_TOPMOST || hwndAfter == HWND_NOTOPMOST)
29835:       event.mPlacement = nsWindowZTop;
29835:     else {
29835:       event.mPlacement = nsWindowZRelative;
86569:       aboveWindow = WinUtils::GetNSWindowPtr(hwndAfter);
29835:     }
29835:     event.mReqBelow = aboveWindow;
29835:     event.mActualBelow = nsnull;
29835: 
79626:     event.mImmediate = false;
79626:     event.mAdjusted = false;
29835:     DispatchWindowEvent(&event);
29835: 
29835:     if (event.mAdjusted) {
29835:       if (event.mPlacement == nsWindowZBottom)
29835:         info->hwndInsertAfter = HWND_BOTTOM;
29835:       else if (event.mPlacement == nsWindowZTop)
29835:         info->hwndInsertAfter = HWND_TOP;
29835:       else {
29835:         info->hwndInsertAfter = (HWND)event.mActualBelow->GetNativeData(NS_NATIVE_WINDOW);
29835:       }
29835:     }
29835:     NS_IF_RELEASE(event.mActualBelow);
29835:   }
29835:   // prevent rude external programs from making hidden window visible
29835:   if (mWindowType == eWindowType_invisible)
29835:     info->flags &= ~SWP_SHOWWINDOW;
29835: }
29835: 
40944: void nsWindow::UserActivity()
40944: {
40944:   // Check if we have the idle service, if not we try to get it.
40944:   if (!mIdleService) {
40944:     mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
40944:   }
40944: 
40944:   // Check that we now have the idle service.
40944:   if (mIdleService) {
40944:     mIdleService->ResetIdleTimeOut();
40944:   }
40944: }
40944: 
48711: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
79445: bool nsWindow::OnTouch(WPARAM wParam, LPARAM lParam)
48711: {
48711:   PRUint32 cInputs = LOWORD(wParam);
48711:   PTOUCHINPUT pInputs = new TOUCHINPUT[cInputs];
48711: 
48711:   if (mGesture.GetTouchInputInfo((HTOUCHINPUT)lParam, cInputs, pInputs)) {
48711:     for (PRUint32 i = 0; i < cInputs; i++) {
48711:       PRUint32 msg;
48711:       if (pInputs[i].dwFlags & TOUCHEVENTF_MOVE) {
48711:         msg = NS_MOZTOUCH_MOVE;
48711:       } else if (pInputs[i].dwFlags & TOUCHEVENTF_DOWN) {
48711:         msg = NS_MOZTOUCH_DOWN;
48711:       } else if (pInputs[i].dwFlags & TOUCHEVENTF_UP) {
48711:         msg = NS_MOZTOUCH_UP;
48711:       } else {
48711:         continue;
48711:       }
48711: 
48711:       nsPointWin touchPoint;
48711:       touchPoint.x = TOUCH_COORD_TO_PIXEL(pInputs[i].x);
48711:       touchPoint.y = TOUCH_COORD_TO_PIXEL(pInputs[i].y);
48711:       touchPoint.ScreenToClient(mWnd);
48711: 
79626:       nsMozTouchEvent touchEvent(true, msg, this, pInputs[i].dwID);
77227:       touchEvent.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
48711:       touchEvent.refPoint = touchPoint;
48711: 
48711:       nsEventStatus status;
48711:       DispatchEvent(&touchEvent, status);
48711:     }
48711:   }
48711: 
48711:   delete [] pInputs;
48711:   mGesture.CloseTouchInputHandle((HTOUCHINPUT)lParam);
79626:   return true;
48711: }
48711: #endif
48711: 
29835: // Gesture event processing. Handles WM_GESTURE events.
79445: bool nsWindow::OnGesture(WPARAM wParam, LPARAM lParam)
29835: {
29835:   // Treatment for pan events which translate into scroll events:
29835:   if (mGesture.IsPanEvent(lParam)) {
79626:     nsMouseScrollEvent event(true, NS_MOUSE_PIXEL_SCROLL, this);
29835: 
29835:     if ( !mGesture.ProcessPanMessage(mWnd, wParam, lParam) )
79626:       return false; // ignore
29835: 
29835:     nsEventStatus status;
29835: 
29835:     event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:     event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
79626:     event.isMeta    = false;
29835:     event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:     event.button    = 0;
29835:     event.time      = ::GetMessageTime();
77227:     event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
29835: 
79445:     bool endFeedback = true;
29835: 
30890:     PRInt32 scrollOverflowX = 0;
30890:     PRInt32 scrollOverflowY = 0;
30890: 
29835:     if (mGesture.PanDeltaToPixelScrollX(event)) {
29835:       DispatchEvent(&event, status);
30890:       scrollOverflowX = event.scrollOverflow;
30890:     }
29835: 
29835:     if (mGesture.PanDeltaToPixelScrollY(event)) {
29835:       DispatchEvent(&event, status);
30890:       scrollOverflowY = event.scrollOverflow;
30890:     }
30890: 
31443:     if (mDisplayPanFeedback) {
30890:       mGesture.UpdatePanFeedbackX(mWnd, scrollOverflowX, endFeedback);
30890:       mGesture.UpdatePanFeedbackY(mWnd, scrollOverflowY, endFeedback);
29835:       mGesture.PanFeedbackFinalize(mWnd, endFeedback);
30890:     }
30890: 
29835:     mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
29835: 
79626:     return true;
29835:   }
29835: 
29835:   // Other gestures translate into simple gesture events:
79626:   nsSimpleGestureEvent event(true, 0, this, 0, 0.0);
29835:   if ( !mGesture.ProcessGestureMessage(mWnd, wParam, lParam, event) ) {
79626:     return false; // fall through to DefWndProc
29835:   }
29835:   
29835:   // Polish up and send off the new event
29835:   event.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   event.isControl = IS_VK_DOWN(NS_VK_CONTROL);
79626:   event.isMeta    = false;
29835:   event.isAlt     = IS_VK_DOWN(NS_VK_ALT);
29835:   event.button    = 0;
29835:   event.time      = ::GetMessageTime();
77227:   event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
29835: 
29835:   nsEventStatus status;
29835:   DispatchEvent(&event, status);
29835:   if (status == nsEventStatus_eIgnore) {
79626:     return false; // Ignored, fall through
29835:   }
29835: 
29835:   // Only close this if we process and return true.
29835:   mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
29835: 
79626:   return true; // Handled
29835: }
68855: 
69947: /* static */ void
69947: nsWindow::InitMouseWheelScrollData()
69947: {
69947:   if (!sNeedsToInitMouseWheelSettings) {
69947:     return;
69947:   }
79626:   sNeedsToInitMouseWheelSettings = false;
69947:   ResetRemainingWheelDelta();
69947: 
69947:   if (!::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
69947:                               &sMouseWheelScrollLines, 0)) {
69947:     NS_WARNING("Failed to get SPI_GETWHEELSCROLLLINES");
69947:     sMouseWheelScrollLines = 3;
69947:   } else if (sMouseWheelScrollLines > WHEEL_DELTA) {
69947:     // sMouseWheelScrollLines usually equals 3 or 0 (for no scrolling)
69947:     // However, if sMouseWheelScrollLines > WHEEL_DELTA, we assume that
69947:     // the mouse driver wants a page scroll.  The docs state that
69947:     // sMouseWheelScrollLines should explicitly equal WHEEL_PAGESCROLL, but
69947:     // since some mouse drivers use an arbitrary large number instead,
69947:     // we have to handle that as well.
69947:     sMouseWheelScrollLines = WHEEL_PAGESCROLL;
69947:   }
69947: 
69947:   if (!::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0,
69947:                               &sMouseWheelScrollChars, 0)) {
90191:     NS_ASSERTION(WinUtils::GetWindowsVersion() < WinUtils::VISTA_VERSION,
69947:                  "Failed to get SPI_GETWHEELSCROLLCHARS");
69947:     sMouseWheelScrollChars = 1;
69947:   } else if (sMouseWheelScrollChars > WHEEL_DELTA) {
69947:     // See the comments for the case sMouseWheelScrollLines > WHEEL_DELTA.
69947:     sMouseWheelScrollChars = WHEEL_PAGESCROLL;
69947:   }
70956: 
70956:   sEnablePixelScrolling =
79445:     Preferences::GetBool("mousewheel.enable_pixel_scrolling", true);
69947: }
69947: 
69947: /* static */
69947: void
69947: nsWindow::ResetRemainingWheelDelta()
69947: {
69947:   sRemainingDeltaForPixel = 0;
69947:   sRemainingDeltaForScroll = 0;
69947:   sLastMouseWheelWnd = NULL;
69947: }
69947: 
69947: static PRInt32 RoundDelta(double aDelta)
69947: {
75359:   return aDelta >= 0 ? (PRInt32)floor(aDelta) : (PRInt32)ceil(aDelta);
69947: }
69947: 
74639: /**
74639:  * OnMouseWheelInternal - mouse wheel event processing.
74639:  * aMessage may be WM_MOUSEWHEEL or WM_MOUSEHWHEEL but this is called when
74639:  * ProcessMessage() handles MOZ_WM_MOUSEVWHEEL or MOZ_WM_MOUSEHWHEEL.
29835:  */
74639: void
74639: nsWindow::OnMouseWheelInternal(UINT aMessage, WPARAM aWParam, LPARAM aLParam,
74639:                                LRESULT *aRetValue)
69947: {
69947:   InitMouseWheelScrollData();
69947: 
79445:   bool isVertical = (aMessage == WM_MOUSEWHEEL);
69947:   if ((isVertical && sMouseWheelScrollLines == 0) ||
69947:       (!isVertical && sMouseWheelScrollChars == 0)) {
69947:     // XXX I think that we should dispatch mouse wheel events even if the
69947:     // operation will not scroll because the wheel operation really happened
69947:     // and web application may want to handle the event for non-scroll action.
69947:     ResetRemainingWheelDelta();
69947:     *aRetValue = isVertical ? TRUE : FALSE; // means we don't process it
74639:     return;
69947:   }
69947: 
69947:   PRInt32 nativeDelta = (short)HIWORD(aWParam);
69947:   if (!nativeDelta) {
69947:     *aRetValue = isVertical ? TRUE : FALSE; // means we don't process it
69947:     ResetRemainingWheelDelta();
74639:     return; // We cannot process this message
74639:   }
29842: 
79445:   bool isPageScroll =
69947:     ((isVertical && sMouseWheelScrollLines == WHEEL_PAGESCROLL) ||
69947:      (!isVertical && sMouseWheelScrollChars == WHEEL_PAGESCROLL));
69947: 
69947:   // Discard the remaining delta if current wheel message and last one are
69947:   // received by different window or to scroll different direction or
69947:   // different unit scroll.  Furthermore, if the last event was too old.
69947:   PRUint32 now = PR_IntervalToMilliseconds(PR_IntervalNow());
69947:   if (sLastMouseWheelWnd &&
69947:       (sLastMouseWheelWnd != mWnd ||
69947:        sLastMouseWheelDeltaIsPositive != (nativeDelta > 0) ||
69947:        sLastMouseWheelOrientationIsVertical != isVertical ||
69947:        sLastMouseWheelUnitIsPage != isPageScroll ||
69947:        now - sLastMouseWheelTime > 1500)) {
69947:     ResetRemainingWheelDelta();
69947:   }
69947:   sLastMouseWheelWnd = mWnd;
69947:   sLastMouseWheelDeltaIsPositive = (nativeDelta > 0);
69947:   sLastMouseWheelOrientationIsVertical = isVertical;
69947:   sLastMouseWheelUnitIsPage = isPageScroll;
69947:   sLastMouseWheelTime = now;
69947: 
70222:   *aRetValue = isVertical ? FALSE : TRUE; // means we process this message
70222:   nsModifierKeyState modKeyState;
70222: 
70222:   // Our positive delta value means to bottom or right.
70222:   // But positive nativeDelta value means to top or right.
70338:   // Use orienter for computing our delta value with native delta value.
70222:   PRInt32 orienter = isVertical ? -1 : 1;
70222: 
70222:   // Assume the Control key is down if the Elantech touchpad has sent the
70222:   // mis-ordered WM_KEYDOWN/WM_MOUSEWHEEL messages.  (See the comment in
70222:   // OnKeyUp.)
79445:   bool isControl;
70222:   if (mAssumeWheelIsZoomUntil &&
70222:       static_cast<DWORD>(::GetMessageTime()) < mAssumeWheelIsZoomUntil) {
79626:     isControl = true;
70222:   } else {
70222:     isControl = modKeyState.mIsControlDown;
70222:   }
70222: 
70222:   // Create line (or page) scroll event.
79626:   nsMouseScrollEvent scrollEvent(true, NS_MOUSE_SCROLL, this);
70222: 
70222:   // Initialize common members on line scroll event, pixel scroll event and
70222:   // test event.
70222:   InitEvent(scrollEvent);
70222:   scrollEvent.isShift     = modKeyState.mIsShiftDown;
70222:   scrollEvent.isControl   = isControl;
79626:   scrollEvent.isMeta      = false;
70222:   scrollEvent.isAlt       = modKeyState.mIsAltDown;
70222: 
70222:   // Before dispatching line scroll event, we should get the current scroll
70222:   // event target information for pixel scroll.
79445:   bool dispatchPixelScrollEvent = false;
79445:   bool reversePixelScrollDirection = false;
73896:   PRInt32 actualScrollAction = nsQueryContentEvent::SCROLL_ACTION_NONE;
70039:   PRInt32 pixelsPerUnit = 0;
70338:   // the amount is the number of lines (or pages) per WHEEL_DELTA
70338:   PRInt32 computedScrollAmount = isPageScroll ? 1 :
70338:     (isVertical ? sMouseWheelScrollLines : sMouseWheelScrollChars);
70039: 
70039:   if (sEnablePixelScrolling) {
79626:     nsMouseScrollEvent testEvent(true, NS_MOUSE_SCROLL, this);
69947:     InitEvent(testEvent);
69947:     testEvent.scrollFlags = isPageScroll ? nsMouseScrollEvent::kIsFullPage : 0;
69947:     testEvent.scrollFlags |= isVertical ? nsMouseScrollEvent::kIsVertical :
69947:                                           nsMouseScrollEvent::kIsHorizontal;
70222:     testEvent.isShift     = scrollEvent.isShift;
70222:     testEvent.isControl   = scrollEvent.isControl;
70222:     testEvent.isMeta      = scrollEvent.isMeta;
70222:     testEvent.isAlt       = scrollEvent.isAlt;
70338: 
70338:     testEvent.delta       = computedScrollAmount;
70338:     if ((isVertical && sLastMouseWheelDeltaIsPositive) ||
70338:         (!isVertical && !sLastMouseWheelDeltaIsPositive)) {
70338:       testEvent.delta *= -1;
70338:     }
79626:     nsQueryContentEvent queryEvent(true, NS_QUERY_SCROLL_TARGET_INFO, this);
69947:     InitEvent(queryEvent);
69947:     queryEvent.InitForQueryScrollTargetInfo(&testEvent);
69947:     DispatchWindowEvent(&queryEvent);
69947:     // If the necessary interger isn't larger than 0, we should assume that
69947:     // the event failed for us.
69947:     if (queryEvent.mSucceeded) {
73896:       actualScrollAction = queryEvent.mReply.mComputedScrollAction;
73896:       if (actualScrollAction == nsQueryContentEvent::SCROLL_ACTION_PAGE) {
69947:         if (isVertical) {
70039:           pixelsPerUnit = queryEvent.mReply.mPageHeight;
69947:         } else {
70039:           pixelsPerUnit = queryEvent.mReply.mPageWidth;
69947:         }
69947:       } else {
70039:         pixelsPerUnit = queryEvent.mReply.mLineHeight;
70039:       }
70338:       computedScrollAmount = queryEvent.mReply.mComputedScrollAmount;
73896:       if (pixelsPerUnit > 0 && computedScrollAmount != 0 &&
73896:           actualScrollAction != nsQueryContentEvent::SCROLL_ACTION_NONE) {
79626:         dispatchPixelScrollEvent = true;
73896:         // If original delta's sign and computed delta's one are different,
73896:         // we need to reverse the pixel scroll direction at dispatching it.
73896:         reversePixelScrollDirection =
73896:           (testEvent.delta > 0 && computedScrollAmount < 0) ||
73896:           (testEvent.delta < 0 && computedScrollAmount > 0);
73896:         // scroll amount must be positive.
73896:         computedScrollAmount = NS_ABS(computedScrollAmount);
73896:       }
69947:     }
69947:   }
69947: 
70222:   // If we dispatch pixel scroll event after the line scroll event,
70222:   // we should set kHasPixels flag to the line scroll event.
69947:   scrollEvent.scrollFlags =
70039:     dispatchPixelScrollEvent ? nsMouseScrollEvent::kHasPixels : 0;
69947: 
69947:   PRInt32 nativeDeltaForScroll = nativeDelta + sRemainingDeltaForScroll;
69947: 
70338:   // NOTE: Don't use computedScrollAmount for computing the delta value of
70338:   //       line/page scroll event.  The value will be recomputed in ESM.
69947:   if (isPageScroll) {
69947:     scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
69947:     if (isVertical) {
69947:       scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsVertical;
69947:     } else {
69947:       scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsHorizontal;
69947:     }
69947:     scrollEvent.delta = nativeDeltaForScroll * orienter / WHEEL_DELTA;
69947:     PRInt32 recomputedNativeDelta = scrollEvent.delta * orienter / WHEEL_DELTA;
69947:     sRemainingDeltaForScroll = nativeDeltaForScroll - recomputedNativeDelta;
69947:   } else {
69947:     double deltaPerUnit;
69947:     if (isVertical) {
69947:       scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsVertical;
69947:       deltaPerUnit = (double)WHEEL_DELTA / sMouseWheelScrollLines;
69947:     } else {
69947:       scrollEvent.scrollFlags |= nsMouseScrollEvent::kIsHorizontal;
69947:       deltaPerUnit = (double)WHEEL_DELTA / sMouseWheelScrollChars;
69947:     }
69947:     scrollEvent.delta =
69947:       RoundDelta((double)nativeDeltaForScroll * orienter / deltaPerUnit);
69947:     PRInt32 recomputedNativeDelta =
69947:       (PRInt32)(scrollEvent.delta * orienter * deltaPerUnit);
69947:     sRemainingDeltaForScroll = nativeDeltaForScroll - recomputedNativeDelta;
69947:   }
69947: 
69947:   if (scrollEvent.delta) {
74639:     DispatchWindowEvent(&scrollEvent);
69947:     if (mOnDestroyCalled) {
69947:       ResetRemainingWheelDelta();
74639:       return;
69947:     }
69947:   }
69947: 
69947:   // If the query event failed, we cannot send pixel events.
70039:   if (!dispatchPixelScrollEvent) {
69947:     sRemainingDeltaForPixel = 0;
74639:     return;
69947:   }
69947: 
79626:   nsMouseScrollEvent pixelEvent(true, NS_MOUSE_PIXEL_SCROLL, this);
69947:   InitEvent(pixelEvent);
73896:   pixelEvent.scrollFlags = nsMouseScrollEvent::kAllowSmoothScroll;
73896:   pixelEvent.scrollFlags |= isVertical ?
73896:     nsMouseScrollEvent::kIsVertical : nsMouseScrollEvent::kIsHorizontal;
73896:   if (actualScrollAction == nsQueryContentEvent::SCROLL_ACTION_PAGE) {
73896:     pixelEvent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
73896:   }
70222:   // Use same modifier state for pixel scroll event.
70222:   pixelEvent.isShift     = scrollEvent.isShift;
70222:   pixelEvent.isControl   = scrollEvent.isControl;
70222:   pixelEvent.isMeta      = scrollEvent.isMeta;
70222:   pixelEvent.isAlt       = scrollEvent.isAlt;
69947: 
69947:   PRInt32 nativeDeltaForPixel = nativeDelta + sRemainingDeltaForPixel;
73896:   // Pixel scroll event won't be recomputed the scroll amout and direction by
73896:   // ESM.  Therefore, we need to set the computed amout and direction here.
73896:   PRInt32 orienterForPixel = reversePixelScrollDirection ? -orienter : orienter;
69947: 
70338:   double deltaPerPixel =
70338:     (double)WHEEL_DELTA / computedScrollAmount / pixelsPerUnit;
69947:   pixelEvent.delta =
73896:     RoundDelta((double)nativeDeltaForPixel * orienterForPixel / deltaPerPixel);
69947:   PRInt32 recomputedNativeDelta =
73896:     (PRInt32)(pixelEvent.delta * orienterForPixel * deltaPerPixel);
69947:   sRemainingDeltaForPixel = nativeDeltaForPixel - recomputedNativeDelta;
69947:   if (pixelEvent.delta != 0) {
74639:     DispatchWindowEvent(&pixelEvent);
74639:   }
74639:   return;
29835: }
31122: 
79445: static bool
22232: StringCaseInsensitiveEquals(const PRUnichar* aChars1, const PRUint32 aNumChars1,
22232:                             const PRUnichar* aChars2, const PRUint32 aNumChars2)
14799: {
14799:   if (aNumChars1 != aNumChars2)
79626:     return false;
14799: 
14799:   nsCaseInsensitiveStringComparator comp;
56399:   return comp(aChars1, aChars2, aNumChars1, aNumChars2) == 0;
14799: }
    1: 
29835: UINT nsWindow::MapFromNativeToDOM(UINT aNativeKeyCode)
29835: {
29835:   switch (aNativeKeyCode) {
29835:     case VK_OEM_1:     return NS_VK_SEMICOLON;     // 0xBA, For the US standard keyboard, the ';:' key
29835:     case VK_OEM_PLUS:  return NS_VK_ADD;           // 0xBB, For any country/region, the '+' key
29835:     case VK_OEM_MINUS: return NS_VK_SUBTRACT;      // 0xBD, For any country/region, the '-' key
29835:   }
29835:   return aNativeKeyCode;
29835: }
29835: 
60495: /* static */
79445: bool nsWindow::IsRedirectedKeyDownMessage(const MSG &aMsg)
60495: {
60495:   return (aMsg.message == WM_KEYDOWN || aMsg.message == WM_SYSKEYDOWN) &&
60495:          (sRedirectedKeyDown.message == aMsg.message &&
86569:           WinUtils::GetScanCode(sRedirectedKeyDown.lParam) ==
86569:             WinUtils::GetScanCode(aMsg.lParam));
60495: }
60495: 
62477: void
62477: nsWindow::PerformElantechSwipeGestureHack(UINT& aVirtualKeyCode,
62477:                                           nsModifierKeyState& aModKeyState)
62477: {
62477:   // The Elantech touchpad driver understands three-finger swipe left and
62477:   // right gestures, and translates them into Page Up and Page Down key
62477:   // events for most applications.  For Firefox 3.6, it instead sends
62477:   // Alt+Left and Alt+Right to trigger browser back/forward actions.  As
62477:   // with the Thinkpad Driver hack in nsWindow::Create, the change in
62477:   // HWND structure makes Firefox not trigger the driver's heuristics
62477:   // any longer.
62477:   //
62477:   // The Elantech driver actually sends these messages for a three-finger
62477:   // swipe right:
62477:   //
62477:   //   WM_KEYDOWN virtual_key = 0xCC or 0xFF (depending on driver version)
62477:   //   WM_KEYDOWN virtual_key = VK_NEXT
62477:   //   WM_KEYUP   virtual_key = VK_NEXT
62477:   //   WM_KEYUP   virtual_key = 0xCC or 0xFF
62477:   //
62477:   // so we use the 0xCC or 0xFF key modifier to detect whether the Page Down
62477:   // is due to the gesture rather than a regular Page Down keypress.  We then
62477:   // pretend that we were went an Alt+Right keystroke instead.  Similarly
62477:   // for VK_PRIOR and Alt+Left.
62477:   if ((aVirtualKeyCode == VK_NEXT || aVirtualKeyCode == VK_PRIOR) &&
62477:       (IS_VK_DOWN(0xFF) || IS_VK_DOWN(0xCC))) {
62477:     aModKeyState.mIsAltDown = true;
62477:     aVirtualKeyCode = aVirtualKeyCode == VK_NEXT ? VK_RIGHT : VK_LEFT;
62477:   }
62477: }
62477: 
14962: /**
14962:  * nsWindow::OnKeyDown peeks into the message queue and pulls out
14962:  * WM_CHAR messages for processing. During testing we don't want to
14962:  * mess with the real message queue. Instead we pass a
14962:  * pseudo-WM_CHAR-message using this structure, and OnKeyDown will use
14962:  * that as if it was in the message queue, and refrain from actually
14962:  * looking at or touching the message queue.
14962:  */
22788: LRESULT nsWindow::OnKeyDown(const MSG &aMsg,
27961:                             nsModifierKeyState &aModKeyState,
79445:                             bool *aEventDispatched,
14962:                             nsFakeCharMessage* aFakeCharMessage)
    1: {
60495:   UINT virtualKeyCode =
60495:     aMsg.wParam != VK_PROCESSKEY ? aMsg.wParam : ::ImmGetVirtualKey(mWnd);
22788:   gKbdLayout.OnKeyDown(virtualKeyCode);
    1: 
72254:   if (sUseElantechSwipeHack) {
62477:     PerformElantechSwipeGestureHack(virtualKeyCode, aModKeyState);
62477:   }
62477: 
    1:   // Use only DOMKeyCode for XP processing.
60495:   // Use virtualKeyCode for gKbdLayout and native processing.
49149:   UINT DOMKeyCode = nsIMM32Handler::IsComposingOn(this) ?
22788:                       virtualKeyCode : MapFromNativeToDOM(virtualKeyCode);
    1: 
    1: #ifdef DEBUG
76714:   //PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("In OnKeyDown virt: %d\n", DOMKeyCode));
    1: #endif
    1: 
79445:   static bool sRedirectedKeyDownEventPreventedDefault = false;
79445:   bool noDefault;
60495:   if (aFakeCharMessage || !IsRedirectedKeyDownMessage(aMsg)) {
73536:     nsIMEContext IMEContext(mWnd);
60495:     noDefault =
27961:       DispatchKeyEvent(NS_KEY_DOWN, 0, nsnull, DOMKeyCode, &aMsg, aModKeyState);
60495:     if (aEventDispatched) {
79626:       *aEventDispatched = true;
60495:     }
60495: 
60495:     // If IMC wasn't associated to the window but is associated it now (i.e.,
60495:     // focus is moved from a non-editable editor to an editor by keydown
60495:     // event handler), WM_CHAR and WM_SYSCHAR shouldn't cause first character
60495:     // inputting if IME is opened.  But then, we should redirect the native
60495:     // keydown message to IME.
60495:     // However, note that if focus has been already moved to another
60495:     // application, we shouldn't redirect the message to it because the keydown
60495:     // message is processed by us, so, nobody shouldn't process it.
60495:     HWND focusedWnd = ::GetFocus();
73536:     nsIMEContext newIMEContext(mWnd);
73536:     if (!noDefault && !aFakeCharMessage && focusedWnd && !PluginHasFocus() &&
73536:         !IMEContext.get() && newIMEContext.get()) {
60495:       RemoveNextCharMessage(focusedWnd);
60495: 
60495:       INPUT keyinput;
60495:       keyinput.type = INPUT_KEYBOARD;
60495:       keyinput.ki.wVk = aMsg.wParam;
86569:       keyinput.ki.wScan = WinUtils::GetScanCode(aMsg.lParam);
60495:       keyinput.ki.dwFlags = KEYEVENTF_SCANCODE;
86569:       if (WinUtils::IsExtendedScanCode(aMsg.lParam)) {
60495:         keyinput.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
60495:       }
60495:       keyinput.ki.time = 0;
60495:       keyinput.ki.dwExtraInfo = NULL;
60495: 
60495:       sRedirectedKeyDownEventPreventedDefault = noDefault;
60495:       sRedirectedKeyDown = aMsg;
60495: 
60495:       ::SendInput(1, &keyinput, sizeof(keyinput));
60495: 
60495:       // Return here.  We shouldn't dispatch keypress event for this WM_KEYDOWN.
60495:       // If it's needed, it will be dispatched after next (redirected)
60495:       // WM_KEYDOWN.
79626:       return true;
60495:     }
60495: 
60495:     if (mOnDestroyCalled) {
60495:       // If this was destroyed by the keydown event handler, we shouldn't
60495:       // dispatch keypress event on this window.
79626:       return true;
60495:     }
60495:   } else {
60495:     noDefault = sRedirectedKeyDownEventPreventedDefault;
60495:     // If this is redirected keydown message, we have dispatched the keydown
60495:     // event already.
60495:     if (aEventDispatched) {
79626:       *aEventDispatched = true;
60495:     }
60495:   }
60495: 
60495:   ForgetRedirectedKeyDownMessage();
60495: 
60495:   // If the key was processed by IME, we shouldn't dispatch keypress event.
60495:   if (aMsg.wParam == VK_PROCESSKEY) {
60495:     return noDefault;
60495:   }
    1: 
    1:   // If we won't be getting a WM_CHAR, WM_SYSCHAR or WM_DEADCHAR, synthesize a keypress
    1:   // for almost all keys
    1:   switch (DOMKeyCode) {
    1:     case NS_VK_SHIFT:
    1:     case NS_VK_CONTROL:
    1:     case NS_VK_ALT:
    1:     case NS_VK_CAPS_LOCK:
    1:     case NS_VK_NUM_LOCK:
    1:     case NS_VK_SCROLL_LOCK: return noDefault;
    1:   }
    1: 
    1:   PRUint32 extraFlags = (noDefault ? NS_EVENT_FLAG_NO_DEFAULT : 0);
    1:   MSG msg;
14962:   BOOL gotMsg = aFakeCharMessage ||
14962:     ::PeekMessageW(&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
    1:   // Enter and backspace are always handled here to avoid for example the
    1:   // confusion between ctrl-enter and ctrl-J.
    1:   if (DOMKeyCode == NS_VK_RETURN || DOMKeyCode == NS_VK_BACK ||
27961:       ((aModKeyState.mIsControlDown || aModKeyState.mIsAltDown)
48050:        && !gKbdLayout.IsDeadKey() && KeyboardLayout::IsPrintableCharKey(virtualKeyCode)))
    1:   {
    1:     // Remove a possible WM_CHAR or WM_SYSCHAR messages from the message queue.
    1:     // They can be more than one because of:
    1:     //  * Dead-keys not pairing with base character
    1:     //  * Some keyboard layouts may map up to 4 characters to the single key
79445:     bool anyCharMessagesRemoved = false;
14962: 
14962:     if (aFakeCharMessage) {
68737:       RemoveMessageAndDispatchPluginEvent(WM_KEYFIRST, WM_KEYLAST,
68737:                                           aFakeCharMessage);
79626:       anyCharMessagesRemoved = true;
14962:     } else {
    1:       while (gotMsg && (msg.message == WM_CHAR || msg.message == WM_SYSCHAR))
    1:       {
29835:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:                ("%s charCode=%d scanCode=%d\n", msg.message == WM_SYSCHAR ? 
76714:                                                 "WM_SYSCHAR" : "WM_CHAR",
14962:                 msg.wParam, HIWORD(msg.lParam) & 0xFF));
22788:         RemoveMessageAndDispatchPluginEvent(WM_KEYFIRST, WM_KEYLAST);
79626:         anyCharMessagesRemoved = true;
    1: 
    1:         gotMsg = ::PeekMessageW (&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
    1:       }
14962:     }
    1: 
27961:     if (!anyCharMessagesRemoved && DOMKeyCode == NS_VK_BACK &&
27961:         nsIMM32Handler::IsDoingKakuteiUndo(mWnd)) {
27961:       NS_ASSERTION(!aFakeCharMessage,
27961:                    "We shouldn't be touching the real msg queue");
22788:       RemoveMessageAndDispatchPluginEvent(WM_CHAR, WM_CHAR);
    1:     }
    1:   }
    1:   else if (gotMsg &&
14962:            (aFakeCharMessage ||
14962:             msg.message == WM_CHAR || msg.message == WM_SYSCHAR || msg.message == WM_DEADCHAR)) {
68737:     if (aFakeCharMessage) {
68737:       MSG msg = aFakeCharMessage->GetCharMessage(mWnd);
22788:       return OnCharRaw(aFakeCharMessage->mCharCode,
68737:                        aFakeCharMessage->mScanCode,
68737:                        aModKeyState, extraFlags, &msg);
68737:     }
14962: 
    1:     // If prevent default set for keydown, do same for keypress
    1:     ::GetMessageW(&msg, mWnd, msg.message, msg.message);
    1: 
22788:     if (msg.message == WM_DEADCHAR) {
22788:       if (!PluginHasFocus())
79626:         return false;
    1: 
22788:       // We need to send the removed message to focused plug-in.
22788:       DispatchPluginEvent(msg);
22788:       return noDefault;
22788:     }
22788: 
29835:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
14962:            ("%s charCode=%d scanCode=%d\n",
14962:             msg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
14962:             msg.wParam, HIWORD(msg.lParam) & 0xFF));
14962: 
27961:     BOOL result = OnChar(msg, aModKeyState, nsnull, extraFlags);
 7027:     // If a syschar keypress wasn't processed, Windows may want to
 7027:     // handle it to activate a native menu.
 7027:     if (!result && msg.message == WM_SYSCHAR)
 7027:       ::DefWindowProcW(mWnd, msg.message, msg.wParam, msg.lParam);
 7027:     return result;
23335:   }
27961:   else if (!aModKeyState.mIsControlDown && !aModKeyState.mIsAltDown &&
48050:              (KeyboardLayout::IsPrintableCharKey(virtualKeyCode) ||
48050:               KeyboardLayout::IsNumpadKey(virtualKeyCode)))
    1:   {
    1:     // If this is simple KeyDown event but next message is not WM_CHAR,
    1:     // this event may not input text, so we should ignore this event.
    1:     // See bug 314130.
22788:     return PluginHasFocus() && noDefault;
    1:   }
    1: 
    1:   if (gKbdLayout.IsDeadKey ())
22788:     return PluginHasFocus() && noDefault;
    1: 
    1:   PRUint8 shiftStates[5];
22232:   PRUnichar uniChars[5];
22232:   PRUnichar shiftedChars[5] = {0, 0, 0, 0, 0};
22232:   PRUnichar unshiftedChars[5] = {0, 0, 0, 0, 0};
22232:   PRUnichar shiftedLatinChar = 0;
22232:   PRUnichar unshiftedLatinChar = 0;
    1:   PRUint32 numOfUniChars = 0;
14328:   PRUint32 numOfShiftedChars = 0;
14328:   PRUint32 numOfUnshiftedChars = 0;
    1:   PRUint32 numOfShiftStates = 0;
    1: 
22788:   switch (virtualKeyCode) {
    1:     // keys to be sent as characters
    1:     case VK_ADD:       uniChars [0] = '+';  numOfUniChars = 1;  break;
    1:     case VK_SUBTRACT:  uniChars [0] = '-';  numOfUniChars = 1;  break;
    1:     case VK_DIVIDE:    uniChars [0] = '/';  numOfUniChars = 1;  break;
    1:     case VK_MULTIPLY:  uniChars [0] = '*';  numOfUniChars = 1;  break;
    1:     case VK_NUMPAD0:
    1:     case VK_NUMPAD1:
    1:     case VK_NUMPAD2:
    1:     case VK_NUMPAD3:
    1:     case VK_NUMPAD4:
    1:     case VK_NUMPAD5:
    1:     case VK_NUMPAD6:
    1:     case VK_NUMPAD7:
    1:     case VK_NUMPAD8:
    1:     case VK_NUMPAD9:
22788:       uniChars [0] = virtualKeyCode - VK_NUMPAD0 + '0';
    1:       numOfUniChars = 1;
    1:       break;
    1:     default:
48050:       if (KeyboardLayout::IsPrintableCharKey(virtualKeyCode)) {
14328:         numOfUniChars = numOfShiftStates =
14328:           gKbdLayout.GetUniChars(uniChars, shiftStates,
80467:                                  ArrayLength(uniChars));
14328:       }
14328: 
27961:       if (aModKeyState.mIsControlDown ^ aModKeyState.mIsAltDown) {
14799:         PRUint8 capsLockState = (::GetKeyState(VK_CAPITAL) & 1) ? eCapsLock : 0;
14328:         numOfUnshiftedChars =
22788:           gKbdLayout.GetUniCharsWithShiftState(virtualKeyCode, capsLockState,
80467:                        unshiftedChars, ArrayLength(unshiftedChars));
14328:         numOfShiftedChars =
22788:           gKbdLayout.GetUniCharsWithShiftState(virtualKeyCode,
14799:                        capsLockState | eShift,
80467:                        shiftedChars, ArrayLength(shiftedChars));
14799: 
14476:         // The current keyboard cannot input alphabets or numerics,
14476:         // we should append them for Shortcut/Access keys.
14476:         // E.g., for Cyrillic keyboard layout.
14799:         if (NS_VK_A <= DOMKeyCode && DOMKeyCode <= NS_VK_Z) {
14476:           shiftedLatinChar = unshiftedLatinChar = DOMKeyCode;
14799:           if (capsLockState)
14799:             shiftedLatinChar += 0x20;
14799:           else
14476:             unshiftedLatinChar += 0x20;
14799:           if (unshiftedLatinChar == unshiftedChars[0] &&
14799:               shiftedLatinChar == shiftedChars[0]) {
14799:               shiftedLatinChar = unshiftedLatinChar = 0;
14799:           }
14799:         } else {
14799:           PRUint16 ch = 0;
14799:           if (NS_VK_0 <= DOMKeyCode && DOMKeyCode <= NS_VK_9) {
14799:             ch = DOMKeyCode;
14799:           } else {
22788:             switch (virtualKeyCode) {
14799:               case VK_OEM_PLUS:   ch = '+'; break;
14799:               case VK_OEM_MINUS:  ch = '-'; break;
14799:             }
14799:           }
14799:           if (ch && unshiftedChars[0] != ch && shiftedChars[0] != ch) {
14799:             // Windows has assigned a virtual key code to the key even though
14799:             // the character can't be produced with this key.  That probably
14799:             // means the character can't be produced with any key in the
14799:             // current layout and so the assignment is based on a QWERTY
14799:             // layout.  Append this code so that users can access the shortcut.
14799:             unshiftedLatinChar = ch;
14799:           }
14799:         }
14799: 
14799:         // If the charCode is not ASCII character, we should replace the
14799:         // charCode with ASCII character only when Ctrl is pressed.
14799:         // But don't replace the charCode when the charCode is not same as
14799:         // unmodified characters. In such case, Ctrl is sometimes used for a
14799:         // part of character inputting key combination like Shift.
27961:         if (aModKeyState.mIsControlDown) {
14799:           PRUint8 currentState = eCtrl;
27961:           if (aModKeyState.mIsShiftDown)
14799:             currentState |= eShift;
14799: 
27961:           PRUint32 ch =
27961:             aModKeyState.mIsShiftDown ? shiftedLatinChar : unshiftedLatinChar;
14799:           if (ch &&
14799:               (numOfUniChars == 0 ||
14799:                StringCaseInsensitiveEquals(uniChars, numOfUniChars,
27961:                  aModKeyState.mIsShiftDown ? shiftedChars : unshiftedChars,
27961:                  aModKeyState.mIsShiftDown ? numOfShiftedChars :
27961:                                              numOfUnshiftedChars))) {
14799:             numOfUniChars = numOfShiftStates = 1;
14799:             uniChars[0] = ch;
14799:             shiftStates[0] = currentState;
14799:           }
14476:         }
14328:       }
14328:   }
14328: 
14328:   if (numOfUniChars > 0 || numOfShiftedChars > 0 || numOfUnshiftedChars > 0) {
72496:     PRUint32 num = NS_MAX(numOfUniChars,
72496:                           NS_MAX(numOfShiftedChars, numOfUnshiftedChars));
14328:     PRUint32 skipUniChars = num - numOfUniChars;
14328:     PRUint32 skipShiftedChars = num - numOfShiftedChars;
14328:     PRUint32 skipUnshiftedChars = num - numOfUnshiftedChars;
14328:     UINT keyCode = numOfUniChars == 0 ? DOMKeyCode : 0;
14328:     for (PRUint32 cnt = 0; cnt < num; cnt++) {
14328:       PRUint16 uniChar, shiftedChar, unshiftedChar;
14328:       uniChar = shiftedChar = unshiftedChar = 0;
14328:       if (skipUniChars <= cnt) {
14328:         if (cnt - skipUniChars  < numOfShiftStates) {
14328:           // If key in combination with Alt and/or Ctrl produces a different
14328:           // character than without them then do not report these flags
14328:           // because it is separate keyboard layout shift state. If dead-key
14328:           // and base character does not produce a valid composite character
14328:           // then both produced dead-key character and following base
14328:           // character may have different modifier flags, too.
27961:           aModKeyState.mIsShiftDown =
27961:             (shiftStates[cnt - skipUniChars] & eShift) != 0;
27961:           aModKeyState.mIsControlDown =
27961:             (shiftStates[cnt - skipUniChars] & eCtrl) != 0;
27961:           aModKeyState.mIsAltDown =
27961:             (shiftStates[cnt - skipUniChars] & eAlt) != 0;
14328:         }
14328:         uniChar = uniChars[cnt - skipUniChars];
14328:       }
14328:       if (skipShiftedChars <= cnt)
14328:         shiftedChar = shiftedChars[cnt - skipShiftedChars];
14328:       if (skipUnshiftedChars <= cnt)
14328:         unshiftedChar = unshiftedChars[cnt - skipUnshiftedChars];
14476:       nsAutoTArray<nsAlternativeCharCode, 5> altArray;
14476: 
14476:       if (shiftedChar || unshiftedChar) {
14476:         nsAlternativeCharCode chars(unshiftedChar, shiftedChar);
14476:         altArray.AppendElement(chars);
14476:       }
14476:       if (cnt == num - 1 && (unshiftedLatinChar || shiftedLatinChar)) {
14476:         nsAlternativeCharCode chars(unshiftedLatinChar, shiftedLatinChar);
14476:         altArray.AppendElement(chars);
14476:       }
14476: 
14476:       DispatchKeyEvent(NS_KEY_PRESS, uniChar, &altArray,
27961:                        keyCode, nsnull, aModKeyState, extraFlags);
    1:     }
30405:   } else {
27961:     DispatchKeyEvent(NS_KEY_PRESS, 0, nsnull, DOMKeyCode, nsnull, aModKeyState,
27961:                      extraFlags);
30405:   }
    1: 
    1:   return noDefault;
    1: }
    1: 
29835: // OnKeyUp
27961: LRESULT nsWindow::OnKeyUp(const MSG &aMsg,
27961:                           nsModifierKeyState &aModKeyState,
79445:                           bool *aEventDispatched)
22788: {
22788:   UINT virtualKeyCode = aMsg.wParam;
22788: 
72254:   if (sUseElantechSwipeHack) {
62477:     PerformElantechSwipeGestureHack(virtualKeyCode, aModKeyState);
72254:   }
72254: 
72254:   if (sUseElantechPinchHack) {
62480:     // Version 8 of the Elantech touchpad driver sends these messages for
62480:     // zoom gestures:
62480:     //
62480:     //   WM_KEYDOWN    virtual_key = 0xCC        time = 10
62480:     //   WM_KEYDOWN    virtual_key = VK_CONTROL  time = 10
62480:     //   WM_MOUSEWHEEL                           time = ::GetTickCount()
62480:     //   WM_KEYUP      virtual_key = VK_CONTROL  time = 10
62480:     //   WM_KEYUP      virtual_key = 0xCC        time = 10
62480:     //
62480:     // The result of this is that we process all of the WM_KEYDOWN/WM_KEYUP
62480:     // messages first because their timestamps make them appear to have
62480:     // been sent before the WM_MOUSEWHEEL message.  To work around this,
62480:     // we store the current time when we process the WM_KEYUP message and
62480:     // assume that any WM_MOUSEWHEEL message with a timestamp before that
62480:     // time is one that should be processed as if the Control key was down.
62480:     if (virtualKeyCode == VK_CONTROL && aMsg.time == 10) {
62480:       // We look only at the bottom 31 bits of the system tick count since
62480:       // GetMessageTime returns a LONG, which is signed, so we want values
62480:       // that are more easily comparable.
62480:       mAssumeWheelIsZoomUntil = ::GetTickCount() & 0x7FFFFFFF;
62480:     }
62477:   }
62477: 
29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
22788:          ("nsWindow::OnKeyUp VK=%d\n", virtualKeyCode));
14962: 
49149:   if (!nsIMM32Handler::IsComposingOn(this)) {
27961:     virtualKeyCode = MapFromNativeToDOM(virtualKeyCode);
27961:   }
27961: 
22788:   if (aEventDispatched)
79626:     *aEventDispatched = true;
27961:   return DispatchKeyEvent(NS_KEY_UP, 0, nsnull, virtualKeyCode, &aMsg,
27961:                           aModKeyState);
22788: }
22788: 
29835: // OnChar
27961: LRESULT nsWindow::OnChar(const MSG &aMsg, nsModifierKeyState &aModKeyState,
79445:                          bool *aEventDispatched, PRUint32 aFlags)
27961: {
27961:   return OnCharRaw(aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF, aModKeyState,
22788:                    aFlags, &aMsg, aEventDispatched);
22788: }
22788: 
29835: // OnCharRaw
27961: LRESULT nsWindow::OnCharRaw(UINT charCode, UINT aScanCode,
27961:                             nsModifierKeyState &aModKeyState, PRUint32 aFlags,
79445:                             const MSG *aMsg, bool *aEventDispatched)
14962: {
    1:   // ignore [shift+]alt+space so the OS can handle it
27961:   if (aModKeyState.mIsAltDown && !aModKeyState.mIsControlDown &&
27961:       IS_VK_DOWN(NS_VK_SPACE)) {
    1:     return FALSE;
    1:   }
    1:   
16335:   // Ignore Ctrl+Enter (bug 318235)
27961:   if (aModKeyState.mIsControlDown && charCode == 0xA) {
16335:     return FALSE;
16335:   }
16335: 
    1:   // WM_CHAR with Control and Alt (== AltGr) down really means a normal character
79445:   bool saveIsAltDown = aModKeyState.mIsAltDown;
79445:   bool saveIsControlDown = aModKeyState.mIsControlDown;
27961:   if (aModKeyState.mIsAltDown && aModKeyState.mIsControlDown)
79626:     aModKeyState.mIsAltDown = aModKeyState.mIsControlDown = false;
    1: 
    1:   wchar_t uniChar;
    1: 
49149:   if (nsIMM32Handler::IsComposingOn(this)) {
27961:     ResetInputState();
27961:   }
27961: 
27961:   if (aModKeyState.mIsControlDown && charCode <= 0x1A) { // Ctrl+A Ctrl+Z, see Programming Windows 3.1 page 110 for details
    1:     // need to account for shift here.  bug 16486
27961:     if (aModKeyState.mIsShiftDown)
    1:       uniChar = charCode - 1 + 'A';
    1:     else
    1:       uniChar = charCode - 1 + 'a';
    1:     charCode = 0;
    1:   }
27961:   else if (aModKeyState.mIsControlDown && charCode <= 0x1F) {
    1:     // Fix for 50255 - <ctrl><[> and <ctrl><]> are not being processed.
    1:     // also fixes ctrl+\ (x1c), ctrl+^ (x1e) and ctrl+_ (x1f)
    1:     // for some reason the keypress handler need to have the uniChar code set
    1:     // with the addition of a upper case A not the lower case.
    1:     uniChar = charCode - 1 + 'A';
    1:     charCode = 0;
    1:   } else { // 0x20 - SPACE, 0x3D - EQUALS
27961:     if (charCode < 0x20 || (charCode == 0x3D && aModKeyState.mIsControlDown)) {
    1:       uniChar = 0;
    1:     } else {
    1:       uniChar = charCode;
    1:       charCode = 0;
    1:     }
    1:   }
    1: 
    1:   // Keep the characters unshifted for shortcuts and accesskeys and make sure
    1:   // that numbers are always passed as such (among others: bugs 50255 and 351310)
27961:   if (uniChar && (aModKeyState.mIsControlDown || aModKeyState.mIsAltDown)) {
22411:     UINT virtualKeyCode = ::MapVirtualKeyEx(aScanCode, MAPVK_VSC_TO_VK,
22411:                                             gKbdLayout.GetLayout());
    1:     UINT unshiftedCharCode =
    1:       virtualKeyCode >= '0' && virtualKeyCode <= '9' ? virtualKeyCode :
27961:         aModKeyState.mIsShiftDown ? ::MapVirtualKeyEx(virtualKeyCode,
27961:                                         MAPVK_VK_TO_CHAR,
22411:                                         gKbdLayout.GetLayout()) : 0;
    1:     // ignore diacritics (top bit set) and key mapping errors (char code 0)
    1:     if ((INT)unshiftedCharCode > 0)
    1:       uniChar = unshiftedCharCode;
    1:   }
    1: 
    1:   // Fix for bug 285161 (and 295095) which was caused by the initial fix for bug 178110.
    1:   // When pressing (alt|ctrl)+char, the char must be lowercase unless shift is
    1:   // pressed too.
27961:   if (!aModKeyState.mIsShiftDown && (saveIsAltDown || saveIsControlDown)) {
    1:     uniChar = towlower(uniChar);
    1:   }
    1: 
79445:   bool result = DispatchKeyEvent(NS_KEY_PRESS, uniChar, nsnull,
27961:                                    charCode, aMsg, aModKeyState, aFlags);
22788:   if (aEventDispatched)
79626:     *aEventDispatched = true;
27961:   aModKeyState.mIsAltDown = saveIsAltDown;
27961:   aModKeyState.mIsControlDown = saveIsControlDown;
    1:   return result;
    1: }
    1: 
29835: void
29835: nsWindow::SetupKeyModifiersSequence(nsTArray<KeyPair>* aArray, PRUint32 aModifiers)
14962: {
80467:   for (PRUint32 i = 0; i < ArrayLength(sModifierKeyMap); ++i) {
14962:     const PRUint32* map = sModifierKeyMap[i];
14962:     if (aModifiers & map[0]) {
14962:       aArray->AppendElement(KeyPair(map[1], map[2]));
14962:     }
14962:   }
14962: }
14962: 
30515: nsresult
30515: nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
30515: {
30515:   // XXXroc we could use BeginDeferWindowPos/DeferWindowPos/EndDeferWindowPos
30515:   // here, if that helps in some situations. So far I haven't seen a
30515:   // need.
30515:   for (PRUint32 i = 0; i < aConfigurations.Length(); ++i) {
30515:     const Configuration& configuration = aConfigurations[i];
30515:     nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
30515:     NS_ASSERTION(w->GetParent() == this,
30515:                  "Configured widget is not a child");
79626:     nsresult rv = w->SetWindowClipRegion(configuration.mClipRegion, true);
51672:     NS_ENSURE_SUCCESS(rv, rv);
30688:     nsIntRect bounds;
30688:     w->GetBounds(bounds);
30688:     if (bounds.Size() != configuration.mBounds.Size()) {
30515:       w->Resize(configuration.mBounds.x, configuration.mBounds.y,
30515:                 configuration.mBounds.width, configuration.mBounds.height,
79626:                 true);
30688:     } else if (bounds.TopLeft() != configuration.mBounds.TopLeft()) {
30688:       w->Move(configuration.mBounds.x, configuration.mBounds.y);
58644: 
58644: 
58644:       if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
58644:           gfxWindowsPlatform::RENDER_DIRECT2D ||
58644:           GetLayerManager()->GetBackendType() != LayerManager::LAYERS_BASIC) {
58644:         // XXX - Workaround for Bug 587508. This will invalidate the part of the
58644:         // plugin window that might be touched by moving content somehow. The
58644:         // underlying problem should be found and fixed!
58644:         nsIntRegion r;
58644:         r.Sub(bounds, configuration.mBounds);
58644:         r.MoveBy(-bounds.x,
58644:                  -bounds.y);
87336:         w->Invalidate(r.GetBounds());
79626:       }
79626:     }
79626:     rv = w->SetWindowClipRegion(configuration.mClipRegion, false);
30515:     NS_ENSURE_SUCCESS(rv, rv);
30515:   }
30515:   return NS_OK;
30515: }
30515: 
30515: static HRGN
30515: CreateHRGNFromArray(const nsTArray<nsIntRect>& aRects)
30515: {
30515:   PRInt32 size = sizeof(RGNDATAHEADER) + sizeof(RECT)*aRects.Length();
30515:   nsAutoTArray<PRUint8,100> buf;
30515:   if (!buf.SetLength(size))
30515:     return NULL;
30515:   RGNDATA* data = reinterpret_cast<RGNDATA*>(buf.Elements());
30515:   RECT* rects = reinterpret_cast<RECT*>(data->Buffer);
30515:   data->rdh.dwSize = sizeof(data->rdh);
30515:   data->rdh.iType = RDH_RECTANGLES;
30515:   data->rdh.nCount = aRects.Length();
30515:   nsIntRect bounds;
30515:   for (PRUint32 i = 0; i < aRects.Length(); ++i) {
30515:     const nsIntRect& r = aRects[i];
30515:     bounds.UnionRect(bounds, r);
30515:     ::SetRect(&rects[i], r.x, r.y, r.XMost(), r.YMost());
30515:   }
30515:   ::SetRect(&data->rdh.rcBound, bounds.x, bounds.y, bounds.XMost(), bounds.YMost());
30515:   return ::ExtCreateRegion(NULL, buf.Length(), data);
30515: }
30515: 
59749: static const nsTArray<nsIntRect>
59749: ArrayFromRegion(const nsIntRegion& aRegion)
59749: {
59749:   nsTArray<nsIntRect> rects;
59749:   const nsIntRect* r;
59749:   for (nsIntRegionRectIterator iter(aRegion); (r = iter.Next());) {
59749:     rects.AppendElement(*r);
59749:   }
59749:   return rects;
59749: }
59749: 
30515: nsresult
30515: nsWindow::SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
79445:                               bool aIntersectWithExisting)
30515: {
30688:   if (!aIntersectWithExisting) {
30688:     if (!StoreWindowClipRegion(aRects))
30688:       return NS_OK;
51672:   } else {
51672:     // In this case still early return if nothing changed.
51672:     if (mClipRects && mClipRectCount == aRects.Length() &&
51672:         memcmp(mClipRects,
51672:                aRects.Elements(),
51672:                sizeof(nsIntRect)*mClipRectCount) == 0) {
51672:       return NS_OK;
51672:     }
59749: 
59749:     // get current rects
59749:     nsTArray<nsIntRect> currentRects;
59749:     GetWindowClipRegion(&currentRects);
59749:     // create region from them
59749:     nsIntRegion currentRegion = RegionFromArray(currentRects);
59749:     // create region from new rects
59749:     nsIntRegion newRegion = RegionFromArray(aRects);
59749:     // intersect regions
59749:     nsIntRegion intersection;
59749:     intersection.And(currentRegion, newRegion);
59749:     // create int rect array from intersection
59749:     nsTArray<nsIntRect> rects = ArrayFromRegion(intersection);
59749:     // store
59749:     if (!StoreWindowClipRegion(rects))
59749:       return NS_OK;
30688:   }
30688: 
30515:   HRGN dest = CreateHRGNFromArray(aRects);
30515:   if (!dest)
30515:     return NS_ERROR_OUT_OF_MEMORY;
30515: 
30515:   if (aIntersectWithExisting) {
30515:     HRGN current = ::CreateRectRgn(0, 0, 0, 0);
30515:     if (current) {
30515:       if (::GetWindowRgn(mWnd, current) != 0 /*ERROR*/) {
30515:         ::CombineRgn(dest, dest, current, RGN_AND);
30515:       }
30515:       ::DeleteObject(current);
30515:     }
30515:   }
30515: 
89735:   // If a plugin is not visible, especially if it is in a background tab,
77660:   // it should not be able to steal keyboard focus.  This code checks whether
77660:   // the region that the plugin is being clipped to is NULLREGION.  If it is,
77660:   // the plugin window gets disabled.
77660:   if(mWindowType == eWindowType_plugin) {
77660:     if(NULLREGION == ::CombineRgn(dest, dest, dest, RGN_OR)) {
89735:       ::ShowWindow(mWnd, SW_HIDE);
77660:       ::EnableWindow(mWnd, FALSE);
77660:     } else {
77660:       ::EnableWindow(mWnd, TRUE);
89735:       ::ShowWindow(mWnd, SW_SHOW);
77660:     }
77660:   }
30515:   if (!::SetWindowRgn(mWnd, dest, TRUE)) {
30515:     ::DeleteObject(dest);
30515:     return NS_ERROR_FAILURE;
30515:   }
30515:   return NS_OK;
30515: }
30515: 
30223: // WM_DESTROY event handler
    1: void nsWindow::OnDestroy()
    1: {
79626:   mOnDestroyCalled = true;
    1: 
30223:   // Make sure we don't get destroyed in the process of tearing down.
30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
30223:   
30223:   // Dispatch the NS_DESTROY event. Must be called before mEventCallback is cleared.
30223:   if (!mInDtor)
30223:     DispatchStandardEvent(NS_DESTROY);
30223: 
30223:   // Prevent the widget from sending additional events.
30223:   mEventCallback = nsnull;
30223: 
30223:   // Free our subclass and clear |this| stored in the window props. We will no longer
30223:   // receive events from Windows after this point.
    1:   SubclassWindow(FALSE);
 4186: 
30223:   // Once mEventCallback is cleared and the subclass is reset, sCurrentWindow can be
30223:   // cleared. (It's used in tracking windows for mouse events.)
30223:   if (sCurrentWindow == this)
30223:     sCurrentWindow = nsnull;
30223: 
30223:   // Disconnects us from our parent, will call our GetParent().
30223:   nsBaseWidget::Destroy();
30223: 
30223:   // Release references to children, device context, toolkit, and app shell.
30223:   nsBaseWidget::OnDestroy();
30223:   
30223:   // Clear our native parent handle.
30223:   // XXX Windows will take care of this in the proper order, and SetParent(nsnull)'s
30223:   // remove child on the parent already took place in nsBaseWidget's Destroy call above.
30223:   //SetParent(nsnull);
43018:   mParent = nsnull;
30223: 
30223:   // We have to destroy the native drag target before we null out our window pointer.
79626:   EnableDragDrop(false);
 4186: 
30223:   // If we're going away and for some reason we're still the rollup widget, rollup and
30223:   // turn off capture.
30223:   if ( this == sRollupWidget ) {
30223:     if ( sRollupListener )
82030:       sRollupListener->Rollup(0);
82030:     CaptureRollupEvents(nsnull, false, true);
30223:   }
30223: 
73536:   // Restore the IM context.
79626:   AssociateDefaultIMC(true);
30223: 
30223:   // Turn off mouse trails if enabled.
30223:   MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
30223:   if (mtrailer) {
30223:     if (mtrailer->GetMouseTrailerWindow() == mWnd)
30223:       mtrailer->DestroyTimer();
30223: 
30223:     if (mtrailer->GetCaptureWindow() == mWnd)
30223:       mtrailer->SetCaptureWindow(nsnull);
30223:   }
30223: 
30223:   // Free GDI window class objects
    1:   if (mBrush) {
    1:     VERIFY(::DeleteObject(mBrush));
    1:     mBrush = NULL;
    1:   }
    1: 
30223:   // Free app icon resources.
30223:   HICON icon;
30223:   icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) 0);
30223:   if (icon)
30223:     ::DestroyIcon(icon);
30223: 
30223:   icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) 0);
30223:   if (icon)
30223:     ::DestroyIcon(icon);
30223: 
30223:   // Destroy any custom cursor resources.
30223:   if (mCursor == -1)
30223:     SetCursor(eCursor_standard);
30223: 
30223: #ifdef MOZ_XUL
30223:   // Reset transparency
30223:   if (eTransparencyTransparent == mTransparencyMode)
30223:     SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
30223: #endif
30223: 
43073:   // Finalize panning feedback to possibly restore window displacement
79626:   mGesture.PanFeedbackFinalize(mWnd, true);
43073: 
30223:   // Clear the main HWND.
30223:   mWnd = NULL;
    1: }
    1: 
29835: // OnMove
79445: bool nsWindow::OnMove(PRInt32 aX, PRInt32 aY)
    1: {
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
79626:   nsGUIEvent event(true, NS_MOVE, this);
    1:   InitEvent(event);
    1:   event.refPoint.x = aX;
    1:   event.refPoint.y = aY;
    1: 
11297:   return DispatchWindowEvent(&event);
    1: }
    1: 
    1: // Send a resize message to the listener
79445: bool nsWindow::OnResize(nsIntRect &aWindowRect)
    1: {
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:   if (mD2DWindowSurface) {
38727:     mD2DWindowSurface = NULL;
87336:     Invalidate();
38727:   }
38727: #endif
51610: 
    1:   // call the event callback
    1:   if (mEventCallback) {
79626:     nsSizeEvent event(true, NS_SIZE, this);
    1:     InitEvent(event);
    1:     event.windowSize = &aWindowRect;
    1:     RECT r;
    1:     if (::GetWindowRect(mWnd, &r)) {
    1:       event.mWinWidth  = PRInt32(r.right - r.left);
    1:       event.mWinHeight = PRInt32(r.bottom - r.top);
    1:     } else {
    1:       event.mWinWidth  = 0;
    1:       event.mWinHeight = 0;
    1:     }
46192: 
46192: #if 0
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
76714:            ("[%X] OnResize: client:(%d x %d x %d x %d) window:(%d x %d)\n", this,
46192:             aWindowRect.x, aWindowRect.y, aWindowRect.width, aWindowRect.height,
76714:             event.mWinWidth, event.mWinHeight));
46192: #endif
46192: 
11297:     return DispatchWindowEvent(&event);
    1:   }
    1: 
79626:   return false;
    1: }
    1: 
79445: bool nsWindow::OnHotKey(WPARAM wParam, LPARAM lParam)
29835: {
79626:   return true;
29835: }
29835: 
62478: // Determine whether the given HWND is the handle for the Elantech helper
62478: // window.  The helper window cannot be distinguished based on its
62478: // window class, so we need to check if it is owned by the helper process,
62478: // ETDCtrl.exe.
79445: static bool IsElantechHelperWindow(HWND aHWND)
62478: {
62478:   const PRUnichar* filenameSuffix = L"\\etdctrl.exe";
62478:   const int filenameSuffixLength = 12;
62478: 
62478:   DWORD pid;
62478:   ::GetWindowThreadProcessId(aHWND, &pid);
62478: 
79445:   bool result = false;
62478: 
62478:   HANDLE hProcess = ::OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
62478:   if (hProcess) {
62478:     PRUnichar path[256] = {L'\0'};
90802:     if (GetProcessImageFileName(hProcess, path, ArrayLength(path))) {
62478:       int pathLength = lstrlenW(path);
62478:       if (pathLength >= filenameSuffixLength) {
62478:         if (lstrcmpiW(path + pathLength - filenameSuffixLength, filenameSuffix) == 0) {
79626:           result = true;
62478:         }
62478:       }
62478:     }
62478:     ::CloseHandle(hProcess);
62478:   }
62478: 
62478:   return result;
62478: }
62478: 
74639: /**
74639:  * OnMouseWheel() is called when ProcessMessage() handles WM_MOUSEWHEEL,
74639:  * WM_MOUSEHWHEEL and also OnScroll() tries to emulate mouse wheel action for
74639:  * WM_VSCROLL or WM_HSCROLL.
74639:  * So, aMsg may be WM_MOUSEWHEEL, WM_MOUSEHWHEEL, WM_VSCROLL or WM_HSCROLL.
74639:  */
74639: void
74639: nsWindow::OnMouseWheel(UINT aMsg, WPARAM aWParam, LPARAM aLParam,
74639:                        LRESULT *aRetValue)
74639: {
74639:   *aRetValue = (aMsg != WM_MOUSEHWHEEL) ? TRUE : FALSE;
74639: 
32183:   POINT point;
32997:   DWORD dwPoints = ::GetMessagePos();
32183:   point.x = GET_X_LPARAM(dwPoints);
32183:   point.y = GET_Y_LPARAM(dwPoints);
32997: 
79445:   static bool sMayBeUsingLogitechMouse = false;
32997:   if (aMsg == WM_MOUSEHWHEEL) {
32997:     // Logitech (Logicool) mouse driver (confirmed with 4.82.11 and MX-1100)
32997:     // always sets 0 to the lParam of WM_MOUSEHWHEEL.  The driver SENDs one
32997:     // message at first time, this time, ::GetMessagePos works fine.
32997:     // Then, we will return 0 (0 means we process it) to the message. Then, the
32997:     // driver will POST the same messages continuously during the wheel tilted.
32997:     // But ::GetMessagePos API always returns (0, 0), even if the actual mouse
32997:     // cursor isn't 0,0.  Therefore, we cannot trust the result of
32997:     // ::GetMessagePos API if the sender is the driver.
51212:     if (!sMayBeUsingLogitechMouse && aLParam == 0 && (DWORD)aLParam != dwPoints &&
32997:         ::InSendMessage()) {
79626:       sMayBeUsingLogitechMouse = true;
32997:     } else if (sMayBeUsingLogitechMouse && aLParam != 0 && ::InSendMessage()) {
32997:       // The user has changed the mouse from Logitech's to another one (e.g.,
32997:       // the user has changed to the touchpad of the notebook.
79626:       sMayBeUsingLogitechMouse = false;
32997:     }
32997:     // If the WM_MOUSEHWHEEL comes from Logitech's mouse driver, and the
32997:     // ::GetMessagePos isn't correct, probably, we should use ::GetCursorPos
32997:     // instead.
32997:     if (sMayBeUsingLogitechMouse && aLParam == 0 && dwPoints == 0) {
32997:       ::GetCursorPos(&point);
32997:     }
32997:   }
32997: 
74639:   HWND underCursorWnd = ::WindowFromPoint(point);
74639:   if (!underCursorWnd) {
74639:     return;
74639:   }
74639: 
74639:   if (sUseElantechPinchHack && IsElantechHelperWindow(underCursorWnd)) {
62478:     // The Elantech driver places a window right underneath the cursor
62478:     // when sending a WM_MOUSEWHEEL event to us as part of a pinch-to-zoom
62478:     // gesture.  We detect that here, and search for our window that would
62478:     // be beneath the cursor if that window wasn't there.
86569:     underCursorWnd = WinUtils::FindOurWindowAtPoint(point);
74639:     if (!underCursorWnd) {
74639:       return;
74639:     }
74639:   }
74639: 
74639:   // Handle most cases first.  If the window under mouse cursor is our window
74639:   // except plugin window (MozillaWindowClass), we should handle the message
74639:   // on the window.
86569:   if (WinUtils::IsOurProcessWindow(underCursorWnd)) {
86569:     nsWindow* destWindow = WinUtils::GetNSWindowPtr(underCursorWnd);
74639:     if (!destWindow) {
74639:       NS_WARNING("We're not sure what cause this is.");
74639:       HWND wnd = ::GetParent(underCursorWnd);
74639:       for (; wnd; wnd = ::GetParent(wnd)) {
86569:         destWindow = WinUtils::GetNSWindowPtr(wnd);
32183:         if (destWindow) {
74639:           break;
74639:         }
74639:       }
74639:       if (!wnd) {
74639:         return;
74639:       }
74639:     }
74639: 
74639:     NS_ASSERTION(destWindow, "destWindow must not be NULL");
74639:     // If the found window is our plugin window, it means that the message
74639:     // has been handled by the plugin but not consumed.  We should handle the
75024:     // message on its parent window.  However, note that the DOM event may
75024:     // cause accessing the plugin.  Therefore, we should unlock the plugin
75024:     // process by using PostMessage().
74639:     if (destWindow->mWindowType == eWindowType_plugin) {
79626:       destWindow = destWindow->GetParentWindow(false);
74639:       NS_ENSURE_TRUE(destWindow, );
74639:     }
86569:     UINT internalMessage = WinUtils::GetInternalMessage(aMsg);
75024:     ::PostMessage(destWindow->mWnd, internalMessage, aWParam, aLParam);
74639:     return;
74639:   }
74639: 
74639:   // If the window under cursor is not in our process, it means:
74639:   // 1. The window may be a plugin window (GeckoPluginWindow or its descendant).
74639:   // 2. The window may be another application's window.
86569:   HWND pluginWnd = WinUtils::FindOurProcessWindow(underCursorWnd);
74639:   if (!pluginWnd) {
74639:     // If there is no plugin window in ancestors of the window under cursor,
74639:     // the window is for another applications (case 2).
74639:     // We don't need to handle this message.
74639:     return;
74639:   }
74639: 
74639:   // If we're a plugin window (MozillaWindowClass) and cursor in this window,
74639:   // the message shouldn't go to plugin's wndproc again.  So, we should handle
75024:   // it on parent window.  However, note that the DOM event may cause accessing
75024:   // the plugin.  Therefore, we should unlock the plugin process by using
75024:   // PostMessage().
74639:   if (mWindowType == eWindowType_plugin && pluginWnd == mWnd) {
79626:     nsWindow* destWindow = GetParentWindow(false);
74639:     NS_ENSURE_TRUE(destWindow, );
86569:     UINT internalMessage = WinUtils::GetInternalMessage(aMsg);
75024:     ::PostMessage(destWindow->mWnd, internalMessage, aWParam, aLParam);
74639:     return;
74639:   }
74639: 
74639:   // If the window is a part of plugin, we should post the message to it.
74639:   ::PostMessage(underCursorWnd, aMsg, aWParam, aLParam);
74639: }
74639: 
74639: /**
74639:  * OnScroll() is called when ProcessMessage() handles WM_VSCROLL or WM_HSCROLL.
74639:  * aMsg may be WM_VSCROLL or WM_HSCROLL.
74639:  */
79445: bool
74639: nsWindow::OnScroll(UINT aMsg, WPARAM aWParam, LPARAM aLParam)
32183: {
39248:   static PRInt8 sMouseWheelEmulation = -1;
39248:   if (sMouseWheelEmulation < 0) {
79445:     bool emulate =
79445:       Preferences::GetBool("mousewheel.emulate_at_wm_scroll", false);
39248:     sMouseWheelEmulation = PRInt8(emulate);
39248:   }
39248: 
39248:   if (aLParam || sMouseWheelEmulation) {
32183:     // Scroll message generated by Thinkpad Trackpoint Driver or similar
32183:     // Treat as a mousewheel message and scroll appropriately
35155:     LRESULT retVal;
74639:     OnMouseWheel(aMsg, aWParam, aLParam, &retVal);
74639:     // Always consume the scroll message if we try to emulate mouse wheel
74639:     // action.
79626:     return true;
74639:   }
74639: 
74639:   // Scroll message generated by external application
79626:   nsContentCommandEvent command(true, NS_CONTENT_COMMAND_SCROLL, this);
74639: 
74639:   command.mScroll.mIsHorizontal = (aMsg == WM_HSCROLL);
74639: 
74639:   switch (LOWORD(aWParam))
74639:   {
74639:     case SB_LINEUP:   // SB_LINELEFT
74639:       command.mScroll.mUnit = nsContentCommandEvent::eCmdScrollUnit_Line;
74639:       command.mScroll.mAmount = -1;
74639:       break;
74639:     case SB_LINEDOWN: // SB_LINERIGHT
74639:       command.mScroll.mUnit = nsContentCommandEvent::eCmdScrollUnit_Line;
74639:       command.mScroll.mAmount = 1;
74639:       break;
74639:     case SB_PAGEUP:   // SB_PAGELEFT
74639:       command.mScroll.mUnit = nsContentCommandEvent::eCmdScrollUnit_Page;
74639:       command.mScroll.mAmount = -1;
74639:       break;
74639:     case SB_PAGEDOWN: // SB_PAGERIGHT
74639:       command.mScroll.mUnit = nsContentCommandEvent::eCmdScrollUnit_Page;
74639:       command.mScroll.mAmount = 1;
74639:       break;
74639:     case SB_TOP:      // SB_LEFT
74639:       command.mScroll.mUnit = nsContentCommandEvent::eCmdScrollUnit_Whole;
74639:       command.mScroll.mAmount = -1;
74639:       break;
74639:     case SB_BOTTOM:   // SB_RIGHT
74639:       command.mScroll.mUnit = nsContentCommandEvent::eCmdScrollUnit_Whole;
74639:       command.mScroll.mAmount = 1;
74639:       break;
74639:     default:
79626:       return false;
74639:   }
74639:   // XXX If this is a plugin window, we should dispatch the event from
74639:   //     parent window.
74639:   DispatchWindowEvent(&command);
79626:   return true;
74639: }
74639: 
74639: /**
74639:  * OnScrollInternal() is called when ProcessMessage() handles MOZ_WM_VSCROLL or
74639:  * MOZ_WM_HSCROLL but aMsg may be WM_VSCROLL or WM_HSCROLL.
74639:  * These internal messages used only when OnScroll() tries to emulate mouse
74639:  * wheel action for the WM_VSCROLL or WM_HSCROLL message.
74639:  */
74639: void
74639: nsWindow::OnScrollInternal(UINT aMsg, WPARAM aWParam, LPARAM aLParam)
74639: {
79626:   nsMouseScrollEvent scrollevent(true, NS_MOUSE_SCROLL, this);
32183:   scrollevent.scrollFlags = (aMsg == WM_VSCROLL) 
32183:                             ? nsMouseScrollEvent::kIsVertical
32183:                             : nsMouseScrollEvent::kIsHorizontal;
74639:   switch (LOWORD(aWParam)) {
32183:     case SB_PAGEDOWN:
32183:       scrollevent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
32183:     case SB_LINEDOWN:
32183:       scrollevent.delta = 1;
32183:       break;
32183:     case SB_PAGEUP:
32183:       scrollevent.scrollFlags |= nsMouseScrollEvent::kIsFullPage;
32183:     case SB_LINEUP:
32183:       scrollevent.delta = -1;
32183:       break;
32183:     default:
74639:       return;
74639:   }
32183:   scrollevent.isShift   = IS_VK_DOWN(NS_VK_SHIFT);
32183:   scrollevent.isControl = IS_VK_DOWN(NS_VK_CONTROL);
79626:   scrollevent.isMeta    = false;
32183:   scrollevent.isAlt     = IS_VK_DOWN(NS_VK_ALT);
32183:   InitEvent(scrollevent);
74639:   if (mEventCallback) {
32183:     DispatchWindowEvent(&scrollevent);
32183:   }
39248: }
29018: 
32194: // Can be overriden. Controls auto-erase of background.
79445: bool nsWindow::AutoErase(HDC dc)
32194: {
79626:   return false;
    1: }
    1: 
58814: void
58814: nsWindow::AllowD3D9Callback(nsWindow *aWindow)
58814: {
58814:   if (aWindow->mLayerManager) {
58814:     aWindow->mLayerManager->Destroy();
58814:     aWindow->mLayerManager = NULL;
58814:   }
58814: }
58814: 
58814: void
58814: nsWindow::AllowD3D9WithReinitializeCallback(nsWindow *aWindow)
58814: {
58814:   if (aWindow->mLayerManager) {
58814:     aWindow->mLayerManager->Destroy();
58814:     aWindow->mLayerManager = NULL;
58814:     (void) aWindow->GetLayerManager();
58814:   }
58814: }
58814: 
58814: void
58814: nsWindow::StartAllowingD3D9(bool aReinitialize)
58814: {
58814:   sAllowD3D9 = true;
58814: 
60398:   LayerManagerPrefs prefs;
60398:   GetLayerManagerPrefs(&prefs);
60398:   if (prefs.mDisableAcceleration) {
60398:     // The guarantee here is, if there's *any* chance that after we
60398:     // throw out our layer managers we'd create at least one new,
60398:     // accelerated one, we *will* throw out all the current layer
60398:     // managers.  We early-return here because currently, if
60398:     // |disableAcceleration|, we will always use basic managers and
60398:     // it's a waste to recreate them.
60398:     //
60398:     // NB: the above implies that it's eminently possible for us to
60398:     // skip this early return but still recreate basic managers.
60398:     // That's OK.  It's *not* OK to take this early return when we
60398:     // *might* have created an accelerated manager.
60398:     return;
60398:   }
60398: 
58814:   if (aReinitialize) {
58814:     EnumAllWindows(AllowD3D9WithReinitializeCallback);
58814:   } else {
58814:     EnumAllWindows(AllowD3D9Callback);
58814:   }
58814: }
58814: 
63258: bool
63258: nsWindow::HasBogusPopupsDropShadowOnMultiMonitor() {
63258:   if (sHasBogusPopupsDropShadowOnMultiMonitor == TRI_UNKNOWN) {
63258:     // Since any change in the preferences requires a restart, this can be
63258:     // done just once.
63258:     // Check for Direct2D first.
63258:     sHasBogusPopupsDropShadowOnMultiMonitor =
63258:       gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
63258:         gfxWindowsPlatform::RENDER_DIRECT2D ? TRI_TRUE : TRI_FALSE;
63258:     if (!sHasBogusPopupsDropShadowOnMultiMonitor) {
63258:       // Otherwise check if Direct3D 9 may be used.
63258:       LayerManagerPrefs prefs;
63258:       GetLayerManagerPrefs(&prefs);
63258:       if (!prefs.mDisableAcceleration && !prefs.mPreferOpenGL) {
63258:         nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
63258:         if (gfxInfo) {
63258:           PRInt32 status;
63258:           if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, &status))) {
63258:             if (status == nsIGfxInfo::FEATURE_NO_INFO || prefs.mForceAcceleration)
63258:             {
63258:               sHasBogusPopupsDropShadowOnMultiMonitor = TRI_TRUE;
63258:             }
63258:           }
63258:         }
63258:       }
63258:     }
63258:   }
63258:   return !!sHasBogusPopupsDropShadowOnMultiMonitor;
63258: }
63258: 
82569: void
82569: nsWindow::OnSysColorChanged()
82569: {
82569:   if (mWindowType == eWindowType_invisible) {
82569:     ::EnumThreadWindows(GetCurrentThreadId(), nsWindow::BroadcastMsg, WM_SYSCOLORCHANGE);
82569:   }
82569:   else {
82569:     // Note: This is sent for child windows as well as top-level windows.
82569:     // The Win32 toolkit normally only sends these events to top-level windows.
82569:     // But we cycle through all of the childwindows and send it to them as well
82569:     // so all presentations get notified properly.
82569:     // See nsWindow::GlobalMsgWindowProc.
82569:     DispatchStandardEvent(NS_SYSCOLORCHANGED);
82569:   }
82569: }
82569: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: IME management and accessibility
29835:  **
29835:  ** Handles managing IME input and accessibility.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
    1: NS_IMETHODIMP nsWindow::ResetInputState()
    1: {
    1: #ifdef DEBUG_KBSTATE
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("ResetInputState\n"));
    1: #endif
24836: 
24836: #ifdef NS_ENABLE_TSF
79626:   nsTextStore::CommitComposition(false);
24836: #endif //NS_ENABLE_TSF
24836: 
49149:   nsIMM32Handler::CommitComposition(this);
    1:   return NS_OK;
    1: }
    1: 
82841: NS_IMETHODIMP_(void)
82841: nsWindow::SetInputContext(const InputContext& aContext,
82841:                           const InputContextAction& aAction)
82840: {
24836: #ifdef NS_ENABLE_TSF
82841:   nsTextStore::SetInputContext(aContext);
24836: #endif //NS_ENABLE_TSF
49149:   if (nsIMM32Handler::IsComposing()) {
    1:     ResetInputState();
49149:   }
82840:   mInputContext = aContext;
82842:   bool enable = (mInputContext.mIMEState.mEnabled == IMEState::ENABLED ||
82842:                  mInputContext.mIMEState.mEnabled == IMEState::PLUGIN);
25278: 
73536:   AssociateDefaultIMC(enable);
82842: 
82842:   if (enable &&
82842:       mInputContext.mIMEState.mOpen != IMEState::DONT_CHANGE_OPEN_STATE) {
82842:     bool open = (mInputContext.mIMEState.mOpen == IMEState::OPEN);
82842: #ifdef NS_ENABLE_TSF
82842:     nsTextStore::SetIMEOpenState(open);
82842: #endif //NS_ENABLE_TSF
82842:     nsIMEContext IMEContext(mWnd);
82842:     if (IMEContext.IsValid()) {
82842:       ::ImmSetOpenStatus(IMEContext.get(), open);
82842:     }
82842:   }
82841: }
82841: 
82841: NS_IMETHODIMP_(InputContext)
82841: nsWindow::GetInputContext()
  539: {
82842:   mInputContext.mIMEState.mOpen = IMEState::CLOSED;
82842:   switch (mInputContext.mIMEState.mEnabled) {
82842:     case IMEState::ENABLED:
82842:     case IMEState::PLUGIN: {
82842:       nsIMEContext IMEContext(mWnd);
82842:       if (IMEContext.IsValid()) {
82842:         mInputContext.mIMEState.mOpen =
82842:           ::ImmGetOpenStatus(IMEContext.get()) ? IMEState::OPEN :
82842:                                                  IMEState::CLOSED;
82842:       }
82842: #ifdef NS_ENABLE_TSF
82842:       if (mInputContext.mIMEState.mOpen == IMEState::CLOSED &&
82842:           nsTextStore::GetIMEOpenState()) {
82842:         mInputContext.mIMEState.mOpen = IMEState::OPEN;
82842:       }
82842: #endif //NS_ENABLE_TSF
82842:     }
82842:   }
82841:   return mInputContext;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::CancelIMEComposition()
    1: {
    1: #ifdef DEBUG_KBSTATE
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("CancelIMEComposition\n"));
    1: #endif 
24836: 
24836: #ifdef NS_ENABLE_TSF
79626:   nsTextStore::CommitComposition(true);
24836: #endif //NS_ENABLE_TSF
24836: 
49149:   nsIMM32Handler::CancelComposition(this);
    1:   return NS_OK;
    1: }
    1: 
 2475: NS_IMETHODIMP
79445: nsWindow::GetToggledKeyState(PRUint32 aKeyCode, bool* aLEDState)
 2475: {
 2475: #ifdef DEBUG_KBSTATE
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("GetToggledKeyState\n"));
 2475: #endif 
 2475:   NS_ENSURE_ARG_POINTER(aLEDState);
 2475:   *aLEDState = (::GetKeyState(aKeyCode) & 1) != 0;
 2475:   return NS_OK;
 2475: }
    1: 
24836: #ifdef NS_ENABLE_TSF
24836: NS_IMETHODIMP
79445: nsWindow::OnIMEFocusChange(bool aFocus)
24836: {
82840:   nsresult rv = nsTextStore::OnFocusChange(aFocus, this,
82842:                                            mInputContext.mIMEState.mEnabled);
27984:   if (rv == NS_ERROR_NOT_AVAILABLE)
33452:     rv = NS_ERROR_NOT_IMPLEMENTED; // TSF is not enabled, maybe.
27984:   return rv;
24836: }
24836: 
24836: NS_IMETHODIMP
24836: nsWindow::OnIMETextChange(PRUint32 aStart,
24836:                           PRUint32 aOldEnd,
24836:                           PRUint32 aNewEnd)
24836: {
24836:   return nsTextStore::OnTextChange(aStart, aOldEnd, aNewEnd);
24836: }
24836: 
24836: NS_IMETHODIMP
24836: nsWindow::OnIMESelectionChange(void)
24836: {
24836:   return nsTextStore::OnSelectionChange();
24836: }
24836: #endif //NS_ENABLE_TSF
24836: 
79445: bool nsWindow::AssociateDefaultIMC(bool aAssociate)
73536: {
73536:   nsIMEContext IMEContext(mWnd);
73536: 
73536:   if (aAssociate) {
73536:     BOOL ret = ::ImmAssociateContextEx(mWnd, NULL, IACE_DEFAULT);
73536: #ifdef DEBUG
73536:     // Note that if IME isn't available with current keyboard layout,
73536:     // IMM might not be installed on the system such as English Windows.
73536:     // On such system, IMM APIs always fail.
73536:     NS_ASSERTION(ret || !nsIMM32Handler::IsIMEAvailable(),
73536:                  "ImmAssociateContextEx failed to restore default IMC");
73536:     if (ret) {
73536:       nsIMEContext newIMEContext(mWnd);
73536:       NS_ASSERTION(!IMEContext.get() || newIMEContext.get() == IMEContext.get(),
73536:                    "Unknown IMC had been associated");
73536:     }
73536: #endif
73536:     return ret && !IMEContext.get();
73536:   }
73536: 
73536:   if (mOnDestroyCalled) {
73536:     // If OnDestroy() has been called, we shouldn't disassociate the default
73536:     // IMC at destroying the window.
79626:     return false;
73536:   }
73536: 
73536:   if (!IMEContext.get()) {
79626:     return false; // already disassociated
73536:   }
73536: 
73536:   BOOL ret = ::ImmAssociateContextEx(mWnd, NULL, 0);
73536:   NS_ASSERTION(ret, "ImmAssociateContextEx failed to disassociate the IMC");
73536:   return ret != FALSE;
73536: }
73536: 
    1: #ifdef ACCESSIBILITY
47996: 
47996: #ifdef DEBUG_WMGETOBJECT
47996: #define NS_LOG_WMGETOBJECT_WNDACC(aWnd)                                        \
47996:   nsAccessible* acc = aWnd ?                                                   \
47996:     aWnd->DispatchAccessibleEvent(NS_GETACCESSIBLE) : nsnull;                  \
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("     acc: %p", acc));                   \
47996:   if (acc) {                                                                   \
47996:     nsAutoString name;                                                         \
47996:     acc->GetName(name);                                                        \
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                         \
76714:            (", accname: %s", NS_ConvertUTF16toUTF8(name).get()));              \
47996:     nsCOMPtr<nsIAccessibleDocument> doc = do_QueryObject(acc);                 \
47996:     void *hwnd = nsnull;                                                       \
47996:     doc->GetWindowHandle(&hwnd);                                               \
76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, (", acc hwnd: %d", hwnd));              \
47996:   }
47996: 
47996: #define NS_LOG_WMGETOBJECT_THISWND                                             \
47996: {                                                                              \
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                           \
76714:          ("\n*******Get Doc Accessible*******\nOrig Window: "));               \
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                           \
76714:          ("\n  {\n     HWND: %d, parent HWND: %d, wndobj: %p,\n",              \
76714:           mWnd, ::GetParent(mWnd), this));                                     \
47996:   NS_LOG_WMGETOBJECT_WNDACC(this)                                              \
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n  }\n"));                             \
47996: }
47996: 
47996: #define NS_LOG_WMGETOBJECT_WND(aMsg, aHwnd)                                    \
47996: {                                                                              \
86569:   nsWindow* wnd = WinUtils::GetNSWindowPtr(aHwnd);                             \
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                           \
76714:          ("Get " aMsg ":\n  {\n     HWND: %d, parent HWND: %d, wndobj: %p,\n", \
76714:           aHwnd, ::GetParent(aHwnd), wnd));                                    \
47996:   NS_LOG_WMGETOBJECT_WNDACC(wnd);                                              \
76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n }\n"));                              \
47996: }
47996: #else
47996: #define NS_LOG_WMGETOBJECT_THISWND
47996: #define NS_LOG_WMGETOBJECT_WND(aMsg, aHwnd)
47996: #endif // DEBUG_WMGETOBJECT
47996: 
42313: nsAccessible*
42313: nsWindow::GetRootAccessible()
    1: {
39169:   // We want the ability to forcibly disable a11y on windows, because
39169:   // some non-a11y-related components attempt to bring it up.  See bug
39169:   // 538530 for details; we have a pref here that allows it to be disabled
39169:   // for performance and testing resons.
39169:   //
39169:   // This pref is checked only once, and the browser needs a restart to
39169:   // pick up any changes.
39169:   static int accForceDisable = -1;
39169: 
39169:   if (accForceDisable == -1) {
70956:     const char* kPrefName = "accessibility.win32.force_disabled";
79445:     if (Preferences::GetBool(kPrefName, false)) {
39169:       accForceDisable = 1;
39169:     } else {
39169:       accForceDisable = 0;
39169:     }
39169:   }
39169: 
39169:   // If the pref was true, return null here, disabling a11y.
39169:   if (accForceDisable)
39169:       return nsnull;
39169: 
30223:   if (mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
    1:     return nsnull;
    1:   }
    1: 
47996:   NS_LOG_WMGETOBJECT_THISWND
47996:   NS_LOG_WMGETOBJECT_WND("This Window", mWnd);
53976: 
54519:   return DispatchAccessibleEvent(NS_GETACCESSIBLE);
    1: }
    1: #endif
    1: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Transparency
29835:  **
29835:  ** Window transparency helpers.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
    1: #ifdef MOZ_XUL
    1: 
79445: void nsWindow::ResizeTranslucentWindow(PRInt32 aNewWidth, PRInt32 aNewHeight, bool force)
    1: {
    1:   if (!force && aNewWidth == mBounds.width && aNewHeight == mBounds.height)
    1:     return;
    1: 
44140: #ifdef CAIRO_HAS_D2D_SURFACE
43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
43936:     nsRefPtr<gfxD2DSurface> newSurface =
43936:       new gfxD2DSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
43936:     mTransparentSurface = newSurface;
43936:     mMemoryDC = nsnull;
44140:   } else
44140: #endif
44140:   {
43936:     nsRefPtr<gfxWindowsSurface> newSurface =
43936:       new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
43936:     mTransparentSurface = newSurface;
43936:     mMemoryDC = newSurface->GetDC();
43936:   }
    1: }
    1: 
16601: void nsWindow::SetWindowTranslucencyInner(nsTransparencyMode aMode)
16601: {
16601:   if (aMode == mTransparencyMode)
16601:     return;
    1: 
46335:   // stop on dialogs and popups!
86569:   HWND hWnd = WinUtils::GetTopLevelHWND(mWnd, true);
86569:   nsWindow* parent = WinUtils::GetNSWindowPtr(hWnd);
46335: 
46335:   if (!parent)
    1:   {
    1:     NS_WARNING("Trying to use transparent chrome in an embedded context");
16601:     return;
    1:   }
    1: 
46335:   if (parent != this) {
46335:     NS_WARNING("Setting SetWindowTranslucencyInner on a parent this is not us!");
46335:   }
46335: 
46335:   if (aMode == eTransparencyTransparent) {
46335:     // If we're switching to the use of a transparent window, hide the chrome
46335:     // on our parent.
79626:     HideWindowChrome(true);
46335:   } else if (mHideChrome && mTransparencyMode == eTransparencyTransparent) {
46335:     // if we're switching out of transparent, re-enable our parent's chrome.
79626:     HideWindowChrome(false);
46335:   }
46335: 
46335:   LONG_PTR style = ::GetWindowLongPtrW(hWnd, GWL_STYLE),
46335:     exStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
46335:  
46335:    if (parent->mIsVisible)
46335:      style |= WS_VISIBLE;
46335:    if (parent->mSizeMode == nsSizeMode_Maximized)
46335:      style |= WS_MAXIMIZE;
46335:    else if (parent->mSizeMode == nsSizeMode_Minimized)
46335:      style |= WS_MINIMIZE;
46335: 
46335:    if (aMode == eTransparencyTransparent)
16601:      exStyle |= WS_EX_LAYERED;
46335:    else
46335:      exStyle &= ~WS_EX_LAYERED;
46234: 
46234:   VERIFY_WINDOW_STYLE(style);
46234:   ::SetWindowLongPtrW(hWnd, GWL_STYLE, style);
46234:   ::SetWindowLongPtrW(hWnd, GWL_EXSTYLE, exStyle);
    1: 
50770:   if (HasGlass())
42856:     memset(&mGlassMargins, 0, sizeof mGlassMargins);
16601:   mTransparencyMode = aMode;
16601: 
16601:   SetupTranslucentWindowMemoryBitmap(aMode);
39718:   UpdateGlass();
16601: }
16601: 
16601: void nsWindow::SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode)
16601: {
16601:   if (eTransparencyTransparent == aMode) {
79626:     ResizeTranslucentWindow(mBounds.width, mBounds.height, true);
    1:   } else {
 9499:     mTransparentSurface = nsnull;
    1:     mMemoryDC = NULL;
    1:   }
    1: }
    1: 
    1: nsresult nsWindow::UpdateTranslucentWindow()
    1: {
    1:   if (mBounds.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   ::GdiFlush();
    1: 
    1:   BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
    1:   SIZE winSize = { mBounds.width, mBounds.height };
    1:   POINT srcPos = { 0, 0 };
86569:   HWND hWnd = WinUtils::GetTopLevelHWND(mWnd, true);
    1:   RECT winRect;
    1:   ::GetWindowRect(hWnd, &winRect);
    1: 
44140: #ifdef CAIRO_HAS_D2D_SURFACE
43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
43936:     mMemoryDC = static_cast<gfxD2DSurface*>(mTransparentSurface.get())->
79626:       GetDC(true);
43936:   }
44140: #endif
    1:   // perform the alpha blend
79445:   bool updateSuccesful = 
43936:     ::UpdateLayeredWindow(hWnd, NULL, (POINT*)&winRect, &winSize, mMemoryDC, &srcPos, 0, &bf, ULW_ALPHA);
43936: 
44140: #ifdef CAIRO_HAS_D2D_SURFACE
43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
43936:     nsIntRect r(0, 0, 0, 0);
43936:     static_cast<gfxD2DSurface*>(mTransparentSurface.get())->ReleaseDC(&r);
43936:   }
44140: #endif
43936: 
43936:   if (!updateSuccesful) {
 5223:     return NS_ERROR_FAILURE;
43936:   }
 5223: 
 5223:   return NS_OK;
 5223: }
 5223: 
19822: #endif //MOZ_XUL
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Popup rollup hooks
29835:  **
29835:  ** Deals with CaptureRollup on popup windows.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: // Schedules a timer for a window, so we can rollup after processing the hook event
29835: void nsWindow::ScheduleHookTimer(HWND aWnd, UINT aMsgId)
29835: {
29835:   // In some cases multiple hooks may be scheduled
29835:   // so ignore any other requests once one timer is scheduled
29835:   if (sHookTimerId == 0) {
29835:     // Remember the window handle and the message ID to be used later
29835:     sRollupMsgId = aMsgId;
29835:     sRollupMsgWnd = aWnd;
29835:     // Schedule native timer for doing the rollup after
29835:     // this event is done being processed
29835:     sHookTimerId = ::SetTimer(NULL, 0, 0, (TIMERPROC)HookTimerForPopups);
29835:     NS_ASSERTION(sHookTimerId, "Timer couldn't be created.");
29835:   }
29835: }
29835: 
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835: int gLastMsgCode = 0;
29835: extern MSGFEventMsgInfo gMSGFEvents[];
29835: #endif
29835: 
29835: // Process Menu messages, rollup when popup is clicked.
29835: LRESULT CALLBACK nsWindow::MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam)
29835: {
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:   if (sProcessHook) {
29835:     MSG* pMsg = (MSG*)lParam;
29835: 
29835:     int inx = 0;
29835:     while (gMSGFEvents[inx].mId != code && gMSGFEvents[inx].mStr != NULL) {
29835:       inx++;
29835:     }
29835:     if (code != gLastMsgCode) {
29835:       if (gMSGFEvents[inx].mId == code) {
29835: #ifdef DEBUG
76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:                ("MozSpecialMessageProc - code: 0x%X  - %s  hw: %p\n", 
76714:                 code, gMSGFEvents[inx].mStr, pMsg->hwnd));
29835: #endif
29835:       } else {
29835: #ifdef DEBUG
76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:                ("MozSpecialMessageProc - code: 0x%X  - %d  hw: %p\n", 
76714:                 code, gMSGFEvents[inx].mId, pMsg->hwnd));
29835: #endif
29835:       }
29835:       gLastMsgCode = code;
29835:     }
29835:     PrintEvent(pMsg->message, FALSE, FALSE);
29835:   }
29835: #endif // #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835: 
29835:   if (sProcessHook && code == MSGF_MENU) {
29835:     MSG* pMsg = (MSG*)lParam;
29835:     ScheduleHookTimer( pMsg->hwnd, pMsg->message);
29835:   }
29835: 
29835:   return ::CallNextHookEx(sMsgFilterHook, code, wParam, lParam);
29835: }
29835: 
29835: // Process all mouse messages. Roll up when a click is in a native window
29835: // that doesn't have an nsIWidget.
29835: LRESULT CALLBACK nsWindow::MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam)
29835: {
29835:   if (sProcessHook) {
86569:     switch (WinUtils::GetNativeMessage(wParam)) {
29835:       case WM_LBUTTONDOWN:
29835:       case WM_RBUTTONDOWN:
29835:       case WM_MBUTTONDOWN:
29835:       case WM_MOUSEWHEEL:
29835:       case WM_MOUSEHWHEEL:
29835:       {
29835:         MOUSEHOOKSTRUCT* ms = (MOUSEHOOKSTRUCT*)lParam;
86569:         nsIWidget* mozWin = WinUtils::GetNSWindowPtr(ms->hwnd);
29835:         if (mozWin) {
29835:           // If this window is windowed plugin window, the mouse events are not
29835:           // sent to us.
33357:           if (static_cast<nsWindow*>(mozWin)->mWindowType == eWindowType_plugin)
29835:             ScheduleHookTimer(ms->hwnd, (UINT)wParam);
29835:         } else {
29835:           ScheduleHookTimer(ms->hwnd, (UINT)wParam);
29835:         }
29835:         break;
29835:       }
29835:     }
29835:   }
29835:   return ::CallNextHookEx(sCallMouseHook, code, wParam, lParam);
29835: }
29835: 
29835: // Process all messages. Roll up when the window is moving, or
29835: // is resizing or when maximized or mininized.
29835: LRESULT CALLBACK nsWindow::MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam)
29835: {
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:   if (sProcessHook) {
29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
29835:     PrintEvent(cwpt->message, FALSE, FALSE);
29835:   }
29835: #endif
29835: 
29835:   if (sProcessHook) {
29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
29835:     if (cwpt->message == WM_MOVING ||
29835:         cwpt->message == WM_SIZING ||
29835:         cwpt->message == WM_GETMINMAXINFO) {
29835:       ScheduleHookTimer(cwpt->hwnd, (UINT)cwpt->message);
29835:     }
29835:   }
29835: 
29835:   return ::CallNextHookEx(sCallProcHook, code, wParam, lParam);
29835: }
29835: 
29835: // Register the special "hooks" for dropdown processing.
29835: void nsWindow::RegisterSpecialDropdownHooks()
29835: {
29835:   NS_ASSERTION(!sMsgFilterHook, "sMsgFilterHook must be NULL!");
29835:   NS_ASSERTION(!sCallProcHook,  "sCallProcHook must be NULL!");
29835: 
29835:   DISPLAY_NMM_PRT("***************** Installing Msg Hooks ***************\n");
29835: 
29835:   // Install msg hook for moving the window and resizing
29835:   if (!sMsgFilterHook) {
29835:     DISPLAY_NMM_PRT("***** Hooking sMsgFilterHook!\n");
29835:     sMsgFilterHook = SetWindowsHookEx(WH_MSGFILTER, MozSpecialMsgFilter, NULL, GetCurrentThreadId());
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:     if (!sMsgFilterHook) {
76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:              ("***** SetWindowsHookEx is NOT installed for WH_MSGFILTER!\n"));
29835:     }
29835: #endif
29835:   }
29835: 
29835:   // Install msg hook for menus
29835:   if (!sCallProcHook) {
29835:     DISPLAY_NMM_PRT("***** Hooking sCallProcHook!\n");
29835:     sCallProcHook  = SetWindowsHookEx(WH_CALLWNDPROC, MozSpecialWndProc, NULL, GetCurrentThreadId());
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:     if (!sCallProcHook) {
76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:              ("***** SetWindowsHookEx is NOT installed for WH_CALLWNDPROC!\n"));
29835:     }
29835: #endif
29835:   }
29835: 
29835:   // Install msg hook for the mouse
29835:   if (!sCallMouseHook) {
29835:     DISPLAY_NMM_PRT("***** Hooking sCallMouseHook!\n");
29835:     sCallMouseHook  = SetWindowsHookEx(WH_MOUSE, MozSpecialMouseProc, NULL, GetCurrentThreadId());
29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
29835:     if (!sCallMouseHook) {
76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
76714:              ("***** SetWindowsHookEx is NOT installed for WH_MOUSE!\n"));
29835:     }
29835: #endif
29835:   }
29835: }
29835: 
29835: // Unhook special message hooks for dropdowns.
29835: void nsWindow::UnregisterSpecialDropdownHooks()
29835: {
29835:   DISPLAY_NMM_PRT("***************** De-installing Msg Hooks ***************\n");
29835: 
29835:   if (sCallProcHook) {
29835:     DISPLAY_NMM_PRT("***** Unhooking sCallProcHook!\n");
29835:     if (!::UnhookWindowsHookEx(sCallProcHook)) {
29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallProcHook!\n");
29835:     }
29835:     sCallProcHook = NULL;
29835:   }
29835: 
29835:   if (sMsgFilterHook) {
29835:     DISPLAY_NMM_PRT("***** Unhooking sMsgFilterHook!\n");
29835:     if (!::UnhookWindowsHookEx(sMsgFilterHook)) {
29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sMsgFilterHook!\n");
29835:     }
29835:     sMsgFilterHook = NULL;
29835:   }
29835: 
29835:   if (sCallMouseHook) {
29835:     DISPLAY_NMM_PRT("***** Unhooking sCallMouseHook!\n");
29835:     if (!::UnhookWindowsHookEx(sCallMouseHook)) {
29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallMouseHook!\n");
29835:     }
29835:     sCallMouseHook = NULL;
29835:   }
29835: }
29835: 
29835: // This timer is designed to only fire one time at most each time a "hook" function
29835: // is used to rollup the dropdown. In some cases, the timer may be scheduled from the
29835: // hook, but that hook event or a subsequent event may roll up the dropdown before
29835: // this timer function is executed.
29835: //
29835: // For example, if an MFC control takes focus, the combobox will lose focus and rollup
29835: // before this function fires.
29835: VOID CALLBACK nsWindow::HookTimerForPopups(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
29835: {
29835:   if (sHookTimerId != 0) {
29835:     // if the window is NULL then we need to use the ID to kill the timer
29835:     BOOL status = ::KillTimer(NULL, sHookTimerId);
29835:     NS_ASSERTION(status, "Hook Timer was not killed.");
29835:     sHookTimerId = 0;
29835:   }
29835: 
29835:   if (sRollupMsgId != 0) {
29835:     // Note: DealWithPopups does the check to make sure that
29835:     // sRollupListener and sRollupWidget are not NULL
29835:     LRESULT popupHandlingResult;
29835:     nsAutoRollup autoRollup;
29835:     DealWithPopups(sRollupMsgWnd, sRollupMsgId, 0, 0, &popupHandlingResult);
29835:     sRollupMsgId = 0;
29835:     sRollupMsgWnd = NULL;
29835:   }
29835: }
29835: 
51000: BOOL CALLBACK nsWindow::ClearResourcesCallback(HWND aWnd, LPARAM aMsg)
50583: {
86569:     nsWindow *window = WinUtils::GetNSWindowPtr(aWnd);
50583:     if (window) {
51000:         window->ClearCachedResources();
50583:     }  
50583:     return TRUE;
50583: }
50583: 
50583: void
51000: nsWindow::ClearCachedResources()
51000: {
51000: #ifdef CAIRO_HAS_D2D_SURFACE
50583:     mD2DWindowSurface = nsnull;
51000: #endif
51000:     if (mLayerManager &&
51000:         mLayerManager->GetBackendType() == LayerManager::LAYERS_BASIC) {
51000:       static_cast<BasicLayerManager*>(mLayerManager.get())->
51000:         ClearCachedResources();
51000:     }
61525:     ::EnumChildWindows(mWnd, nsWindow::ClearResourcesCallback, 0);
51000: }
50583: 
79445: static bool IsDifferentThreadWindow(HWND aWnd)
29835: {
29835:   return ::GetCurrentThreadId() != ::GetWindowThreadProcessId(aWnd, NULL);
29835: }
29835: 
79445: bool
29835: nsWindow::EventIsInsideWindow(UINT Msg, nsWindow* aWindow)
29835: {
29835:   RECT r;
29835: 
29835:   if (Msg == WM_ACTIVATEAPP)
29835:     // don't care about activation/deactivation
79626:     return false;
29835: 
29835:   ::GetWindowRect(aWindow->mWnd, &r);
29835:   DWORD pos = ::GetMessagePos();
29835:   POINT mp;
29835:   mp.x = GET_X_LPARAM(pos);
29835:   mp.y = GET_Y_LPARAM(pos);
29835: 
29835:   // was the event inside this window?
79445:   return (bool) PtInRect(&r, mp);
29835: }
29835: 
29835: // Handle events that may cause a popup (combobox, XPMenu, etc) to need to rollup.
29835: BOOL
29835: nsWindow::DealWithPopups(HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult)
29835: {
29835:   if (sRollupListener && sRollupWidget && ::IsWindowVisible(inWnd)) {
29835: 
86569:     inMsg = WinUtils::GetNativeMessage(inMsg);
29835:     if (inMsg == WM_LBUTTONDOWN || inMsg == WM_RBUTTONDOWN || inMsg == WM_MBUTTONDOWN ||
29835:         inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL || inMsg == WM_ACTIVATE ||
68855:         (inMsg == WM_KILLFOCUS && IsDifferentThreadWindow((HWND)inWParam)) ||
29835:         inMsg == WM_NCRBUTTONDOWN ||
29835:         inMsg == WM_MOVING ||
29835:         inMsg == WM_SIZING ||
29835:         inMsg == WM_NCLBUTTONDOWN ||
29835:         inMsg == WM_NCMBUTTONDOWN ||
29835:         inMsg == WM_MOUSEACTIVATE ||
29835:         inMsg == WM_ACTIVATEAPP ||
68855:         inMsg == WM_MENUSELECT)
29835:     {
29835:       // Rollup if the event is outside the popup.
79445:       bool rollup = !nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)sRollupWidget);
29835: 
29835:       if (rollup && (inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL))
29835:       {
82030:         rollup = sRollupListener->ShouldRollupOnMouseWheelEvent();
79626:         *outResult = true;
29835:       }
29835: 
29835:       // If we're dealing with menus, we probably have submenus and we don't
29835:       // want to rollup if the click is in a parent menu of the current submenu.
29835:       PRUint32 popupsToRollup = PR_UINT32_MAX;
29835:       if (rollup) {
82030:         if ( sRollupListener ) {
29835:           nsAutoTArray<nsIWidget*, 5> widgetChain;
82030:           PRUint32 sameTypeCount = sRollupListener->GetSubmenuWidgetChain(&widgetChain);
29835:           for ( PRUint32 i = 0; i < widgetChain.Length(); ++i ) {
29835:             nsIWidget* widget = widgetChain[i];
29835:             if ( nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)widget) ) {
42263:               // don't roll up if the mouse event occurred within a menu of the
42263:               // same type. If the mouse event occurred in a menu higher than
29835:               // that, roll up, but pass the number of popups to Rollup so
29835:               // that only those of the same type close up.
29835:               if (i < sameTypeCount) {
79626:                 rollup = false;
29835:               }
29835:               else {
29835:                 popupsToRollup = sameTypeCount;
29835:               }
29835:               break;
29835:             }
29835:           } // foreach parent menu widget
29835:         } // if rollup listener knows about menus
29835:       }
29835: 
29835:       if (inMsg == WM_MOUSEACTIVATE && popupsToRollup == PR_UINT32_MAX) {
29835:         // Prevent the click inside the popup from causing a change in window
29835:         // activation. Since the popup is shown non-activated, we need to eat
29835:         // any requests to activate the window while it is displayed. Windows
29835:         // will automatically activate the popup on the mousedown otherwise.
29835:         if (!rollup) {
29835:           *outResult = MA_NOACTIVATE;
29835:           return TRUE;
29835:         }
29835:         else
29835:         {
29835:           UINT uMsg = HIWORD(inLParam);
29835:           if (uMsg == WM_MOUSEMOVE)
29835:           {
29835:             // WM_MOUSEACTIVATE cause by moving the mouse - X-mouse (eg. TweakUI)
29835:             // must be enabled in Windows.
82030:             rollup = sRollupListener->ShouldRollupOnMouseActivate();
29835:             if (!rollup)
29835:             {
29835:               *outResult = MA_NOACTIVATE;
29835:               return true;
29835:             }
29835:           }
29835:         }
29835:       }
29835:       // if we've still determined that we should still rollup everything, do it.
68855:       else if (rollup) {
29835:         // sRollupConsumeEvent may be modified by
29835:         // nsIRollupListener::Rollup.
79445:         bool consumeRollupEvent = sRollupConsumeEvent;
29835:         // only need to deal with the last rollup for left mouse down events.
82030:         NS_ASSERTION(!mLastRollup, "mLastRollup is null");
82030:         mLastRollup = sRollupListener->Rollup(popupsToRollup, inMsg == WM_LBUTTONDOWN);
82030:         NS_IF_ADDREF(mLastRollup);
29835: 
29835:         // Tell hook to stop processing messages
79626:         sProcessHook = false;
29835:         sRollupMsgId = 0;
29835:         sRollupMsgWnd = NULL;
29835: 
29835:         // return TRUE tells Windows that the event is consumed,
29835:         // false allows the event to be dispatched
29835:         //
29835:         // So if we are NOT supposed to be consuming events, let it go through
29835:         if (consumeRollupEvent && inMsg != WM_RBUTTONDOWN) {
58173:           *outResult = MA_ACTIVATE;
58173: 
58173:           // However, don't activate panels
58173:           if (inMsg == WM_MOUSEACTIVATE) {
86569:             nsWindow* activateWindow = WinUtils::GetNSWindowPtr(inWnd);
58173:             if (activateWindow) {
58173:               nsWindowType wintype;
58173:               activateWindow->GetWindowType(wintype);
58173:               if (wintype == eWindowType_popup && activateWindow->PopupType() == ePopupTypePanel) {
58173:                 *outResult = MA_NOACTIVATE;
58173:               }
58173:             }
58173:           }
29835:           return TRUE;
29835:         }
29835:         // if we are only rolling up some popups, don't activate and don't let
29835:         // the event go through. This prevents clicks menus higher in the
29835:         // chain from opening when a context menu is open
29835:         if (popupsToRollup != PR_UINT32_MAX && inMsg == WM_MOUSEACTIVATE) {
29835:           *outResult = MA_NOACTIVATEANDEAT;
29835:           return TRUE;
29835:         }
29835:       }
29835:     } // if event that might trigger a popup to rollup
29835:   } // if rollup listeners registered
29835: 
29835:   return FALSE;
29835: }
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Misc. utility methods and functions.
29835:  **
29835:  ** General use.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: // nsModifierKeyState used in various character processing. 
29835: nsModifierKeyState::nsModifierKeyState()
29835: {
29835:   mIsShiftDown   = IS_VK_DOWN(NS_VK_SHIFT);
29835:   mIsControlDown = IS_VK_DOWN(NS_VK_CONTROL);
29835:   mIsAltDown     = IS_VK_DOWN(NS_VK_ALT);
29835: }
29835: 
29835: 
29835: // Note that the result of GetTopLevelWindow method can be different from the
86569: // result of WinUtils::GetTopLevelHWND().  The result can be non-floating
86569: // window.  Because our top level window may be contained in another window
86569: // which is not managed by us.
79445: nsWindow* nsWindow::GetTopLevelWindow(bool aStopOnDialogOrPopup)
29835: {
29835:   nsWindow* curWindow = this;
29835: 
79626:   while (true) {
29835:     if (aStopOnDialogOrPopup) {
29835:       switch (curWindow->mWindowType) {
29835:         case eWindowType_dialog:
29835:         case eWindowType_popup:
29835:           return curWindow;
51212:         default:
51212:           break;
29835:       }
29835:     }
29835: 
29835:     // Retrieve the top level parent or owner window
79626:     nsWindow* parentWindow = curWindow->GetParentWindow(true);
29835: 
29835:     if (!parentWindow)
29835:       return curWindow;
29835: 
29835:     curWindow = parentWindow;
29835:   }
29835: }
29835: 
29835: static BOOL CALLBACK gEnumWindowsProc(HWND hwnd, LPARAM lParam)
29835: {
29835:   DWORD pid;
29835:   ::GetWindowThreadProcessId(hwnd, &pid);
29835:   if (pid == GetCurrentProcessId() && ::IsWindowVisible(hwnd))
29835:   {
79626:     gWindowsVisible = true;
29835:     return FALSE;
29835:   }
29835:   return TRUE;
29835: }
29835: 
79445: bool nsWindow::CanTakeFocus()
29835: {
79626:   gWindowsVisible = false;
29835:   EnumWindows(gEnumWindowsProc, 0);
29835:   if (!gWindowsVisible) {
79626:     return true;
29835:   } else {
29835:     HWND fgWnd = ::GetForegroundWindow();
29835:     if (!fgWnd) {
79626:       return true;
29835:     }
29835:     DWORD pid;
29835:     GetWindowThreadProcessId(fgWnd, &pid);
29835:     if (pid == GetCurrentProcessId()) {
79626:       return true;
79626:     }
79626:   }
79626:   return false;
29835: }
29835: 
57092: void nsWindow::GetMainWindowClass(nsAString& aClass)
57092: {
70956:   NS_PRECONDITION(aClass.IsEmpty(), "aClass should be empty string");
70956:   nsresult rv = Preferences::GetString("ui.window_class_override", &aClass);
70956:   if (NS_FAILED(rv) || aClass.IsEmpty()) {
57092:     aClass.AssignASCII(sDefaultMainWindowClass);
57092:   }
70956: }
57092: 
62477: /**
62477:  * Gets the Boolean value of a pref used to enable or disable an input
62477:  * workaround (like the Trackpoint hack).  The pref can take values 0 (for
62477:  * disabled), 1 (for enabled) or -1 (to automatically detect whether to
62477:  * enable the workaround).
62477:  *
62477:  * @param aPrefName The name of the pref.
62477:  * @param aValueIfAutomatic Whether the given input workaround should be
62477:  *   enabled by default.
62477:  */
79445: bool nsWindow::GetInputWorkaroundPref(const char* aPrefName,
79445:                                         bool aValueIfAutomatic)
62477: {
62477:   if (!aPrefName) {
62477:     return aValueIfAutomatic;
62477:   }
62477: 
70956:   PRInt32 lHackValue = 0;
70956:   if (NS_SUCCEEDED(Preferences::GetInt(aPrefName, &lHackValue))) {
57092:     switch (lHackValue) {
57092:       case 0: // disabled
79626:         return false;
57092:       case 1: // enabled
79626:         return true;
57092:       default: // -1: autodetect
57092:         break;
57092:     }
57092:   }
62477:   return aValueIfAutomatic;
62477: }
62477: 
79445: bool nsWindow::UseTrackPointHack()
62477: {
62477:   return GetInputWorkaroundPref("ui.trackpoint_hack.enabled",
62477:                                 sDefaultTrackPointHack);
57092: }
57092: 
79445: static bool
62477: HasRegistryKey(HKEY aRoot, PRUnichar* aName)
57093: {
57093:   HKEY key;
76348:   LONG result = ::RegOpenKeyExW(aRoot, aName, 0, KEY_READ | KEY_WOW64_32KEY, &key);
76348:   if (result != ERROR_SUCCESS) {
76348:     result = ::RegOpenKeyExW(aRoot, aName, 0, KEY_READ | KEY_WOW64_64KEY, &key);
57093:     if (result != ERROR_SUCCESS)
79626:       return false;
76348:   }
57093:   ::RegCloseKey(key);
79626:   return true;
57093: }
57093: 
79445: static bool
62477: IsObsoleteSynapticsDriver()
62477: {
62477:   PRUnichar buf[40];
86569:   bool foundKey = WinUtils::GetRegistryKey(HKEY_LOCAL_MACHINE,
62477:                                            L"Software\\Synaptics\\SynTP\\Install",
62477:                                            L"DriverVersion",
62477:                                            buf,
62477:                                            sizeof buf);
62477:   if (!foundKey)
79626:     return false;
57093: 
57093:   int majorVersion = wcstol(buf, NULL, 10);
76348:   int minorVersion = 0;
76348:   PRUnichar* p = wcschr(buf, L'.');
76348:   if (p) {
76348:     minorVersion = wcstol(p + 1, NULL, 10);
76348:   }
76348:   return majorVersion < 15 || majorVersion == 15 && minorVersion == 0;
57093: }
57093: 
72254: static PRInt32
72254: GetElantechDriverMajorVersion()
62477: {
62477:   PRUnichar buf[40];
62477:   // The driver version is found in one of these two registry keys.
86569:   bool foundKey = WinUtils::GetRegistryKey(HKEY_CURRENT_USER,
62477:                                            L"Software\\Elantech\\MainOption",
62477:                                            L"DriverVersion",
62477:                                            buf,
62477:                                            sizeof buf);
62477:   if (!foundKey)
86569:     foundKey = WinUtils::GetRegistryKey(HKEY_CURRENT_USER,
62477:                                         L"Software\\Elantech",
62477:                                         L"DriverVersion",
62477:                                         buf,
62477:                                         sizeof buf);
62477: 
62477:   if (!foundKey)
79626:     return false;
62477: 
62477:   // Assume that the major version number can be found just after a space
62477:   // or at the start of the string.
62477:   for (PRUnichar* p = buf; *p; p++) {
62477:     if (*p >= L'0' && *p <= L'9' && (p == buf || *(p - 1) == L' ')) {
72254:       return wcstol(p, NULL, 10);
72254:     }
72254:   }
72254: 
72254:   return 0;
62477: }
62477: 
62477: void nsWindow::InitInputWorkaroundPrefDefaults()
33529: {
72254:   PRUint32 elantechDriverVersion = GetElantechDriverMajorVersion();
72254: 
57093:   if (HasRegistryKey(HKEY_CURRENT_USER, L"Software\\Lenovo\\TrackPoint")) {
79626:     sDefaultTrackPointHack = true;
57093:   } else if (HasRegistryKey(HKEY_CURRENT_USER, L"Software\\Lenovo\\UltraNav")) {
79626:     sDefaultTrackPointHack = true;
57093:   } else if (HasRegistryKey(HKEY_CURRENT_USER, L"Software\\Alps\\Apoint\\TrackPoint")) {
79626:     sDefaultTrackPointHack = true;
57093:   } else if ((HasRegistryKey(HKEY_CURRENT_USER, L"Software\\Synaptics\\SynTPEnh\\UltraNavUSB") ||
57093:               HasRegistryKey(HKEY_CURRENT_USER, L"Software\\Synaptics\\SynTPEnh\\UltraNavPS2")) &&
74659:               IsObsoleteSynapticsDriver()) {
79626:     sDefaultTrackPointHack = true;
57092:   }
62477: 
79445:   bool useElantechGestureHacks =
62477:     GetInputWorkaroundPref("ui.elantech_gesture_hacks.enabled",
72254:                            elantechDriverVersion != 0);
72254:   sUseElantechSwipeHack = useElantechGestureHacks && elantechDriverVersion <= 7;
72254:   sUseElantechPinchHack = useElantechGestureHacks && elantechDriverVersion <= 8;
33529: }
33529: 
30750: LPARAM nsWindow::lParamToScreen(LPARAM lParam)
30750: {
30750:   POINT pt;
30750:   pt.x = GET_X_LPARAM(lParam);
30750:   pt.y = GET_Y_LPARAM(lParam);
30750:   ::ClientToScreen(mWnd, &pt);
30750:   return MAKELPARAM(pt.x, pt.y);
30750: }
30750: 
30750: LPARAM nsWindow::lParamToClient(LPARAM lParam)
30750: {
30750:   POINT pt;
30750:   pt.x = GET_X_LPARAM(lParam);
30750:   pt.y = GET_Y_LPARAM(lParam);
30750:   ::ScreenToClient(mWnd, &pt);
30750:   return MAKELPARAM(pt.x, pt.y);
30750: }
30750: 
84178: void nsWindow::PickerOpen()
84178: {
84178:   mPickerDisplayCount++;
84178: }
84178: 
84178: void nsWindow::PickerClosed()
84178: {
84178:   NS_ASSERTION(mPickerDisplayCount > 0, "mPickerDisplayCount out of sync!");
84178:   if (!mPickerDisplayCount)
84178:     return;
84178:   mPickerDisplayCount--;
84178:   if (!mPickerDisplayCount && mDestroyCalled) {
84178:     Destroy();
84178:   }
84178: }
84178: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: ChildWindow impl.
29835:  **
29835:  ** Child window overrides.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: // return the style for a child nsWindow
29835: DWORD ChildWindow::WindowStyle()
29835: {
29835:   DWORD style = WS_CLIPCHILDREN | nsWindow::WindowStyle();
29835:   if (!(style & WS_POPUP))
29835:     style |= WS_CHILD; // WS_POPUP and WS_CHILD are mutually exclusive.
29835:   VERIFY_WINDOW_STYLE(style);
29835:   return style;
31006: }
