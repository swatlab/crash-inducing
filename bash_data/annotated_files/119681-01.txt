     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 95352: #include "Accessible-inl.h"
 75194: #include "AccIterator.h"
 99735: #include "DocAccessible-inl.h"
 41384: #include "nsAccCache.h"
 30820: #include "nsAccessibilityService.h"
 89309: #include "nsAccessiblePivot.h"
 47107: #include "nsAccTreeWalker.h"
 41384: #include "nsAccUtils.h"
106800: #include "nsEventShell.h"
 41384: #include "nsTextEquivUtils.h"
 87094: #include "Role.h"
 97643: #include "RootAccessible.h"
 87094: #include "States.h"
 41384: 
     1: #include "nsIMutableArray.h"
     1: #include "nsICommandManager.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMAttr.h"
     1: #include "nsIDOMCharacterData.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMDocumentType.h"
 43504: #include "nsIDOMXULDocument.h"
     1: #include "nsIDOMMutationEvent.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDOMXULPopupElement.h"
     1: #include "nsIEditingSession.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsIFrame.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIViewManager.h"
 37062: #include "nsIScrollableFrame.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsIURI.h"
     1: #include "nsIWebNavigation.h"
 29018: #include "nsFocusManager.h"
118988: #include "mozilla/Assertions.h"
 51350: #include "mozilla/dom/Element.h"
 99203: 
116102: #ifdef A11Y_LOG
 99203: #include "Logging.h"
 99203: #endif
 99203: 
     1: #ifdef MOZ_XUL
     1: #include "nsIXULDocument.h"
     1: #endif
     1: 
 80467: using namespace mozilla;
 74618: using namespace mozilla::a11y;
 51350: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // Static member initialization
     1: 
 57845: static nsIAtom** kRelationAttrs[] =
 57845: {
 78350:   &nsGkAtoms::aria_labelledby,
 78350:   &nsGkAtoms::aria_describedby,
 78350:   &nsGkAtoms::aria_owns,
 78350:   &nsGkAtoms::aria_controls,
 78350:   &nsGkAtoms::aria_flowto,
 78350:   &nsGkAtoms::_for,
 78350:   &nsGkAtoms::control
 57845: };
 57845: 
108991: static const uint32_t kRelationAttrsLen = NS_ARRAY_LENGTH(kRelationAttrs);
 35523: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // Constructor/desctructor
 35523: 
 99568: DocAccessible::
 99568:   DocAccessible(nsIDocument* aDocument, nsIContent* aRootContent,
 89801:                   nsIPresShell* aPresShell) :
 99901:   HyperTextAccessibleWrap(aRootContent, this),
 75013:   mDocument(aDocument), mScrollPositionChangedTicks(0),
 89309:   mLoadState(eTreeConstructionPending), mLoadEventType(0),
106838:   mVirtualCursor(nullptr),
 89801:   mPresShell(aPresShell)
     1: {
118792:   mFlags |= eDocAccessible | eNotNodeMapEntry;
118988:   MOZ_ASSERT(mPresShell, "should have been given a pres shell");
118986:   mPresShell->SetDocAccessible(this);
 70092: 
 57845:   mDependentIDsHash.Init();
 31335:   // XXX aaronl should we use an algorithm for the initial cache size?
 43538:   mAccessibleCache.Init(kDefaultCacheSize);
 56292:   mNodeToAccessibleMap.Init(kDefaultCacheSize);
 31335: 
 62541:   // If this is a XUL Document, it should not implement nsHyperText
 62541:   if (mDocument && mDocument->IsXUL())
 62541:     mFlags &= ~eHyperTextAccessible;
 62541: 
     1:   // For GTK+ native window, we do nothing here.
 43504:   if (!mDocument)
     1:     return;
     1: 
 43310:   // nsAccDocManager creates document accessible when scrollable frame is
 43310:   // available already, it should be safe time to add scroll listener.
 43310:   AddScrollListener();
 89309: 
 89309:   // We provide a virtual cursor if this is a root doc or if it's a tab doc.
 89309:   mIsCursorable = (!(mDocument->GetParentDocument()) ||
 89309:                    nsCoreUtils::IsTabDocument(mDocument));
     1: }
     1: 
 99568: DocAccessible::~DocAccessible()
     1: {
 89799:   NS_ASSERTION(!mPresShell, "LastRelease was never called!?!");
     1: }
     1: 
 89145: 
 16428: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsISupports
 16428: 
 99568: NS_IMPL_CYCLE_COLLECTION_CLASS(DocAccessible)
 16428: 
 99648: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(DocAccessible, Accessible)
 71499:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
 60746:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNotificationController,
 60746:                                                   NotificationController)
 32285: 
 89309:   if (tmp->mVirtualCursor) {
 89309:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mVirtualCursor,
 89309:                                                     nsAccessiblePivot)
 89309:   }
 89309: 
108991:   uint32_t i, length = tmp->mChildDocuments.Length();
 52279:   for (i = 0; i < length; ++i) {
 71499:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mChildDocuments[i],
 71499:                                                          nsIAccessible)
 52279:   }
 52279: 
 43538:   CycleCollectorTraverseCache(tmp->mAccessibleCache, &cb);
 16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 16428: 
 99648: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(DocAccessible, Accessible)
 71499:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)
 60746:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mNotificationController)
 89309:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mVirtualCursor)
 52279:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mChildDocuments)
 57845:   tmp->mDependentIDsHash.Clear();
 56292:   tmp->mNodeToAccessibleMap.Clear();
 43538:   ClearCache(tmp->mAccessibleCache);
 16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 16428: 
 99568: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(DocAccessible)
     1:   NS_INTERFACE_MAP_ENTRY(nsIAccessibleDocument)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
     1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 29564:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
 89309:   NS_INTERFACE_MAP_ENTRY(nsIAccessiblePivotObserver)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAccessibleDocument)
 89309:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIAccessibleCursorable,
 89309:                                      mIsCursorable)
 43504:     foundInterface = 0;
 43504: 
 43504:   nsresult status;
 43504:   if (!foundInterface) {
 99901:     // HTML document accessible must inherit from HyperTextAccessible to get
 43504:     // support text interfaces. XUL document accessible doesn't need this.
 43504:     // However at some point we may push <body> to implement the interfaces and
 99648:     // return DocAccessible to inherit from AccessibleWrap.
 43504: 
 62541:     status = IsHyperText() ? 
 99901:       HyperTextAccessible::QueryInterface(aIID, (void**)&foundInterface) :
 99648:       Accessible::QueryInterface(aIID, (void**)&foundInterface);
 43504:   } else {
 43504:     NS_ADDREF(foundInterface);
 43504:     status = NS_OK;
 43504:   }
 43504: 
 43504:   *aInstancePtr = foundInterface;
 43504:   return status;
 43504: }
     1: 
 99901: NS_IMPL_ADDREF_INHERITED(DocAccessible, HyperTextAccessible)
 99901: NS_IMPL_RELEASE_INHERITED(DocAccessible, HyperTextAccessible)
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsIAccessible
 35523: 
 97369: ENameValueFlag
 99568: DocAccessible::Name(nsString& aName)
     1: {
     1:   aName.Truncate();
 97369: 
 13094:   if (mParent) {
 97369:     mParent->Name(aName); // Allow owning iframe to override the name
     1:   }
     1:   if (aName.IsEmpty()) {
 20246:     // Allow name via aria-labelledby or title attribute
 99648:     Accessible::Name(aName);
     1:   }
 13094:   if (aName.IsEmpty()) {
 97369:     GetTitle(aName);   // Try title element
 14340:   }
 14340:   if (aName.IsEmpty()) {   // Last resort: use URL
 97369:     GetURL(aName);
     1:   }
     1:  
 97369:   return eNameOK;
     1: }
     1: 
 99648: // Accessible public method
 87094: role
 99568: DocAccessible::NativeRole()
     1: {
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
 43504:     nsCoreUtils::GetDocShellTreeItemFor(mDocument);
     1:   if (docShellTreeItem) {
     1:     nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
     1:     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
108991:     int32_t itemType;
  2395:     docShellTreeItem->GetItemType(&itemType);
     1:     if (sameTypeRoot == docShellTreeItem) {
     1:       // Root of content or chrome tree
 52027:       if (itemType == nsIDocShellTreeItem::typeChrome)
 87094:         return roles::CHROME_WINDOW;
 52027: 
 52027:       if (itemType == nsIDocShellTreeItem::typeContent) {
 52027: #ifdef MOZ_XUL
 52027:         nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
 52027:         if (xulDoc)
 87094:           return roles::APPLICATION;
 52027: #endif
 87094:         return roles::DOCUMENT;
 52027:       }
     1:     }
     1:     else if (itemType == nsIDocShellTreeItem::typeContent) {
 87094:       return roles::DOCUMENT;
  2395:     }
     1:   }
     1: 
 87094:   return roles::PANE; // Fall back;
     1: }
     1: 
 69342: void
 99568: DocAccessible::Description(nsString& aDescription)
  3018: {
 13094:   if (mParent)
 69342:     mParent->Description(aDescription);
 13094: 
118792:   if (HasOwnContent() && aDescription.IsEmpty()) {
 25175:     nsTextEquivUtils::
 78350:       GetTextEquivFromIDRefs(this, nsGkAtoms::aria_describedby,
 69342:                              aDescription);
  3018:   }
118792: }
  3018: 
 99648: // Accessible public method
108991: uint64_t
 99568: DocAccessible::NativeState()
     1: {
 56987:   // The root content of the document might be removed so that mContent is
 56987:   // out of date.
108991:   uint64_t state = (mContent->GetCurrentDoc() == mDocument) ?
 67790:     0 : states::STALE;
   262: 
 79384:   // Document is always focusable.
100246:   state |= states::FOCUSABLE; // keep in sync with NativeIteractiveState() impl
 79384:   if (FocusMgr()->IsFocused(this))
 67790:     state |= states::FOCUSED;
     1: 
 75013:   // Expose stale state until the document is ready (DOM is loaded and tree is
 75013:   // constructed).
 75013:   if (!HasLoadState(eReady))
 75013:     state |= states::STALE;
 75013: 
 75013:   // Expose state busy until the document and all its subdocuments is completely
 75013:   // loaded.
 75013:   if (!HasLoadState(eCompletelyLoaded))
 75013:     state |= states::BUSY;
     1: 
     1:   nsIFrame* frame = GetFrame();
 80911:   if (!frame ||
 80911:       !frame->IsVisibleConsideringAncestors(nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY)) {
 67790:     state |= states::INVISIBLE | states::OFFSCREEN;
     1:   }
     1: 
 91761:   nsCOMPtr<nsIEditor> editor = GetEditor();
 67790:   state |= editor ? states::EDITABLE : states::READONLY;
     1: 
 67790:   return state;
     1: }
     1: 
108991: uint64_t
100246: DocAccessible::NativeInteractiveState() const
100246: {
100246:   // Document is always focusable.
100246:   return states::FOCUSABLE;
100246: }
100246: 
100246: bool
100246: DocAccessible::NativelyUnavailable() const
100246: {
100246:   return false;
100246: }
100246: 
 99648: // Accessible public method
 67790: void
108991: DocAccessible::ApplyARIAState(uint64_t* aState) const
 13094: {
 13094:   // Combine with states from outer doc
 67790:   // 
 99648:   Accessible::ApplyARIAState(aState);
 13094: 
 67790:   // Allow iframe/frame etc. to have final state override via ARIA
 67790:   if (mParent)
 67790:     mParent->ApplyARIAState(aState);
 13094: }
 13094: 
119399: already_AddRefed<nsIPersistentProperties>
119399: DocAccessible::Attributes()
 13094: {
119399:   nsCOMPtr<nsIPersistentProperties> attributes =
119399:     HyperTextAccessibleWrap::Attributes();
119399: 
119681:   // No attributes if document is not attached to the tree or if it's a root
119681:   // document.
119681:   if (!mParent || IsRoot())
119399:     return attributes.forget();
119399: 
119399:   // Override ARIA object attributes from outerdoc.
119399:   aria::AttrIterator attribIter(mParent->GetContent());
119399:   nsAutoString name, value, unused;
119399:   while(attribIter.Next(name, value))
119399:     attributes->SetStringProperty(NS_ConvertUTF16toUTF8(name), value, unused);
119399: 
119399:   return attributes.forget();
 13094: }
 13094: 
 99648: Accessible*
 99568: DocAccessible::FocusedChild()
     1: {
     1:   // Return an accessible for the current global focus, which does not have to
     1:   // be contained within the current document.
 79384:   return FocusMgr()->FocusedAccessible();
     1: }
     1: 
 99568: NS_IMETHODIMP
 99568: DocAccessible::TakeFocus()
     1: {
 43504:   if (IsDefunct())
 43504:     return NS_ERROR_FAILURE;
 43504: 
 43504:   // Focus the document.
 89948:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 43504:   NS_ENSURE_STATE(fm);
 43504: 
 29018:   nsCOMPtr<nsIDOMElement> newFocus;
106838:   return fm->MoveFocus(mDocument->GetWindow(), nullptr,
 29167:                        nsIFocusManager::MOVEFOCUS_ROOT, 0,
 29018:                        getter_AddRefs(newFocus));
  5696: }
     1: 
 35523: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsIAccessibleDocument
     1: 
 99568: NS_IMETHODIMP
 99568: DocAccessible::GetURL(nsAString& aURL)
     1: {
 43504:   if (IsDefunct())
 43504:     return NS_ERROR_FAILURE;
 43504: 
     1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
     1:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(container));
110974:   nsAutoCString theURL;
     1:   if (webNav) {
     1:     nsCOMPtr<nsIURI> pURI;
     1:     webNav->GetCurrentURI(getter_AddRefs(pURI));
     1:     if (pURI)
     1:       pURI->GetSpec(theURL);
     1:   }
     1:   CopyUTF8toUTF16(theURL, aURL);
     1:   return NS_OK;
     1: }
     1: 
 70983: NS_IMETHODIMP
 99568: DocAccessible::GetTitle(nsAString& aTitle)
     1: {
 70983:   nsCOMPtr<nsIDOMDocument> domDocument = do_QueryInterface(mDocument);
 70983:   if (!domDocument) {
     1:     return NS_ERROR_FAILURE;
     1:   }
 70983:   return domDocument->GetTitle(aTitle);
 70983: }
     1: 
 70983: NS_IMETHODIMP
 99568: DocAccessible::GetMimeType(nsAString& aMimeType)
     1: {
 70983:   nsCOMPtr<nsIDOMDocument> domDocument = do_QueryInterface(mDocument);
 70983:   if (!domDocument) {
 70983:     return NS_ERROR_FAILURE;
     1:   }
 70983:   return domDocument->GetContentType(aMimeType);
     1: }
     1: 
 99568: NS_IMETHODIMP
 99568: DocAccessible::GetDocType(nsAString& aDocType)
     1: {
     1:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(mDocument));
     1:   nsCOMPtr<nsIDOMDocumentType> docType;
     1: 
     1: #ifdef MOZ_XUL
     1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
     1:   if (xulDoc) {
     1:     aDocType.AssignLiteral("window"); // doctype not implemented for XUL at time of writing - causes assertion
     1:     return NS_OK;
     1:   } else
     1: #endif
     1:   if (domDoc && NS_SUCCEEDED(domDoc->GetDoctype(getter_AddRefs(docType))) && docType) {
     1:     return docType->GetPublicId(aDocType);
     1:   }
     1: 
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 99568: NS_IMETHODIMP
108991: DocAccessible::GetNameSpaceURIForID(int16_t aNameSpaceID, nsAString& aNameSpaceURI)
     1: {
     1:   if (mDocument) {
     1:     nsCOMPtr<nsINameSpaceManager> nameSpaceManager =
     1:         do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
     1:     if (nameSpaceManager)
     1:       return nameSpaceManager->GetNameSpaceURI(aNameSpaceID, aNameSpaceURI);
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 99568: NS_IMETHODIMP
 99568: DocAccessible::GetWindowHandle(void** aWindow)
     1: {
 54220:   NS_ENSURE_ARG_POINTER(aWindow);
 54220:   *aWindow = GetNativeWindow();
     1:   return NS_OK;
     1: }
     1: 
 99568: NS_IMETHODIMP
 99568: DocAccessible::GetWindow(nsIDOMWindow** aDOMWin)
     1: {
106838:   *aDOMWin = nullptr;
     1:   if (!mDocument) {
     1:     return NS_ERROR_FAILURE;  // Accessible is Shutdown()
     1:   }
     1:   *aDOMWin = mDocument->GetWindow();
     1: 
     1:   if (!*aDOMWin)
     1:     return NS_ERROR_FAILURE;  // No DOM Window
     1: 
     1:   NS_ADDREF(*aDOMWin);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 41374: NS_IMETHODIMP
 99568: DocAccessible::GetDOMDocument(nsIDOMDocument** aDOMDocument)
     1: {
 41374:   NS_ENSURE_ARG_POINTER(aDOMDocument);
106838:   *aDOMDocument = nullptr;
     1: 
 41374:   if (mDocument)
 41374:     CallQueryInterface(mDocument, aDOMDocument);
 41374: 
     1:   return NS_OK;
     1: }
     1: 
 52279: NS_IMETHODIMP
 99568: DocAccessible::GetParentDocument(nsIAccessibleDocument** aDocument)
 52279: {
 52279:   NS_ENSURE_ARG_POINTER(aDocument);
106838:   *aDocument = nullptr;
 52279: 
 52279:   if (!IsDefunct())
 52279:     NS_IF_ADDREF(*aDocument = ParentDocument());
 52279: 
 52279:   return NS_OK;
 52279: }
 52279: 
 52279: NS_IMETHODIMP
108991: DocAccessible::GetChildDocumentCount(uint32_t* aCount)
 52279: {
 52279:   NS_ENSURE_ARG_POINTER(aCount);
 52279:   *aCount = 0;
 52279: 
 52279:   if (!IsDefunct())
 52279:     *aCount = ChildDocumentCount();
 52279: 
 52279:   return NS_OK;
 52279: }
 52279: 
 52279: NS_IMETHODIMP
108991: DocAccessible::GetChildDocumentAt(uint32_t aIndex,
 52279:                                   nsIAccessibleDocument** aDocument)
 52279: {
 52279:   NS_ENSURE_ARG_POINTER(aDocument);
106838:   *aDocument = nullptr;
 52279: 
 52279:   if (IsDefunct())
 52279:     return NS_OK;
 52279: 
 52279:   NS_IF_ADDREF(*aDocument = GetChildDocumentAt(aIndex));
 52279:   return *aDocument ? NS_OK : NS_ERROR_INVALID_ARG;
 52279: }
 52279: 
 89309: // nsIAccessibleVirtualCursor method
 89309: NS_IMETHODIMP
 99568: DocAccessible::GetVirtualCursor(nsIAccessiblePivot** aVirtualCursor)
 89309: {
 89309:   NS_ENSURE_ARG_POINTER(aVirtualCursor);
106838:   *aVirtualCursor = nullptr;
 89309: 
 89309:   if (IsDefunct())
 89309:     return NS_ERROR_FAILURE;
 89309: 
 89309:   NS_ENSURE_TRUE(mIsCursorable, NS_ERROR_NOT_IMPLEMENTED);
 89309: 
 89309:   if (!mVirtualCursor) {
 89309:     mVirtualCursor = new nsAccessiblePivot(this);
 89309:     mVirtualCursor->AddObserver(this);
 89309:   }
 89309: 
 89309:   NS_ADDREF(*aVirtualCursor = mVirtualCursor);
 89309:   return NS_OK;
 89309: }
 89309: 
 99901: // HyperTextAccessible method
 91761: already_AddRefed<nsIEditor>
 99568: DocAccessible::GetEditor() const
     1: {
 20138:   // Check if document is editable (designMode="on" case). Otherwise check if
 20138:   // the html:body (for HTML document case) or document element is editable.
 43504:   if (!mDocument->HasFlag(NODE_IS_EDITABLE) &&
 43504:       !mContent->HasFlag(NODE_IS_EDITABLE))
106838:     return nullptr;
     1: 
     1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
     1:   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(container));
     1:   if (!editingSession)
106838:     return nullptr; // No editing session interface
     1: 
     1:   nsCOMPtr<nsIEditor> editor;
  4625:   editingSession->GetEditorForWindow(mDocument->GetWindow(), getter_AddRefs(editor));
 91761:   if (!editor)
106838:     return nullptr;
 91761: 
 91761:   bool isEditable = false;
  4625:   editor->GetIsDocumentEditable(&isEditable);
 91761:   if (isEditable)
 91761:     return editor.forget();
 91761: 
106838:   return nullptr;
     1: }
     1: 
 99568: // DocAccessible public method
 99648: Accessible*
 99568: DocAccessible::GetAccessible(nsINode* aNode) const
     1: {
 99648:   Accessible* accessible = mNodeToAccessibleMap.Get(aNode);
 38062: 
 38062:   // No accessible in the cache, check if the given ID is unique ID of this
 43538:   // document accessible.
 43538:   if (!accessible) {
 56292:     if (GetNode() != aNode)
106838:       return nullptr;
 43538: 
 99568:     accessible = const_cast<DocAccessible*>(this);
 38062:   }
 38062: 
 38000: #ifdef DEBUG
     1:   // All cached accessible nodes should be in the parent
     1:   // It will assert if not all the children were created
     1:   // when they were first cached, and no invalidation
     1:   // ever corrected parent accessible's child cache.
 99648:   Accessible* parent = accessible->Parent();
 36989:   if (parent)
 43538:     parent->TestChildCache(accessible);
     1: #endif
 38063: 
 43538:   return accessible;
     1: }
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsAccessNode
     1: 
107208: void
 99568: DocAccessible::Init()
     1: {
116102: #ifdef A11Y_LOG
 99203:   if (logging::IsEnabled(logging::eDocCreate))
 99203:     logging::DocCreate("document initialize", mDocument, this);
 99203: #endif
 43765: 
 60746:   // Initialize notification controller.
 89799:   mNotificationController = new NotificationController(this, mPresShell);
     1: 
 70931:   // Mark the document accessible as loaded if its DOM document was loaded at
 70931:   // this point (this can happen because a11y is started late or DOM document
 70931:   // having no container was loaded.
 70931:   if (mDocument->GetReadyStateEnum() == nsIDocument::READYSTATE_COMPLETE)
 75013:     mLoadState |= eDOMLoaded;
 70931: 
     1:   AddEventListeners();
     1: }
     1: 
 43538: void
 99568: DocAccessible::Shutdown()
     1: {
 89799:   if (!mPresShell) // already shutdown
 43538:     return;
     1: 
116102: #ifdef A11Y_LOG
 99203:   if (logging::IsEnabled(logging::eDocDestroy))
 99203:     logging::DocDestroy("document shutdown", mDocument, this);
 99203: #endif
 43310: 
118986:   mPresShell->SetDocAccessible(nullptr);
106800: 
 60746:   if (mNotificationController) {
 60746:     mNotificationController->Shutdown();
106838:     mNotificationController = nullptr;
 38755:   }
 37537: 
 43310:   RemoveEventListeners();
     1: 
 64007:   // Mark the document as shutdown before AT is notified about the document
100123:   // removal from its container (valid for root documents on ATK and due to
100123:   // some reason for MSAA, refer to bug 757392 for details).
100123:   mFlags |= eIsDefunct;
 64007:   nsCOMPtr<nsIDocument> kungFuDeathGripDoc = mDocument;
106838:   mDocument = nullptr;
 64007: 
 52279:   if (mParent) {
 99568:     DocAccessible* parentDocument = mParent->Document();
 52279:     if (parentDocument)
 52279:       parentDocument->RemoveChildDocument(this);
 52279: 
 43310:     mParent->RemoveChild(this);
 52279:   }
 52279: 
 57162:   // Walk the array backwards because child documents remove themselves from the
 57162:   // array as they are shutdown.
108991:   int32_t childDocCount = mChildDocuments.Length();
108991:   for (int32_t idx = childDocCount - 1; idx >= 0; idx--)
 56639:     mChildDocuments[idx]->Shutdown();
 56639: 
 52279:   mChildDocuments.Clear();
     1: 
 89309:   if (mVirtualCursor) {
 89309:     mVirtualCursor->RemoveObserver(this);
106838:     mVirtualCursor = nullptr;
 89309:   }
 89309: 
106838:   mPresShell = nullptr;  // Avoid reentrancy
     1: 
 57845:   mDependentIDsHash.Clear();
 56292:   mNodeToAccessibleMap.Clear();
 43538:   ClearCache(mAccessibleCache);
     1: 
 99901:   HyperTextAccessibleWrap::Shutdown();
 56639: 
 56639:   GetAccService()->NotifyOfDocumentShutdown(kungFuDeathGripDoc);
     1: }
     1: 
 21169: nsIFrame*
 99568: DocAccessible::GetFrame() const
     1: {
106838:   nsIFrame* root = nullptr;
 89799:   if (mPresShell)
 89799:     root = mPresShell->GetRootFrame();
     1: 
     1:   return root;
     1: }
     1: 
 99568: // DocAccessible protected member
 99568: void
 99568: DocAccessible::GetBoundsRect(nsRect& aBounds, nsIFrame** aRelativeFrame)
     1: {
     1:   *aRelativeFrame = GetFrame();
     1: 
     1:   nsIDocument *document = mDocument;
106838:   nsIDocument *parentDoc = nullptr;
     1: 
     1:   while (document) {
 46225:     nsIPresShell *presShell = document->GetShell();
     1:     if (!presShell) {
     1:       return;
     1:     }
     1: 
 37062:     nsRect scrollPort;
 37062:     nsIScrollableFrame* sf = presShell->GetRootScrollFrameAsScrollableExternal();
 37062:     if (sf) {
 37062:       scrollPort = sf->GetScrollPortRect();
 37062:     } else {
 37361:       nsIFrame* rootFrame = presShell->GetRootFrame();
 37361:       if (!rootFrame) {
 37361:         return;
 37361:       }
 37361:       scrollPort = rootFrame->GetRect();
     1:     }
     1: 
     1:     if (parentDoc) {  // After first time thru loop
 37062:       // XXXroc bogus code! scrollPort is relative to the viewport of
 37062:       // this document, but we're intersecting rectangles derived from
 37062:       // multiple documents and assuming they're all in the same coordinate
 37062:       // system. See bug 514117.
 37062:       aBounds.IntersectRect(scrollPort, aBounds);
     1:     }
     1:     else {  // First time through loop
 37062:       aBounds = scrollPort;
     1:     }
     1: 
     1:     document = parentDoc = document->GetParentDocument();
     1:   }
     1: }
     1: 
 99568: // DocAccessible protected member
 99568: nsresult
 99568: DocAccessible::AddEventListeners()
     1: {
     1:   // 1) Set up scroll position listener
     1:   // 2) Check for editor and listen for changes to editor
     1: 
 89799:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem(do_QueryInterface(container));
     1:   NS_ENSURE_TRUE(docShellTreeItem, NS_ERROR_FAILURE);
     1: 
     1:   // Make sure we're a content docshell
     1:   // We don't want to listen to chrome progress
108991:   int32_t itemType;
     1:   docShellTreeItem->GetItemType(&itemType);
     1: 
 79445:   bool isContent = (itemType == nsIDocShellTreeItem::typeContent);
     1: 
     1:   if (isContent) {
     1:     // We're not an editor yet, but we might become one
     1:     nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShellTreeItem);
     1:     if (commandManager) {
     1:       commandManager->AddCommandObserver(this, "obs_documentCreated");
     1:     }
     1:   }
     1: 
  1249:   nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
  1249:   docShellTreeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
  1249:   if (rootTreeItem) {
 97643:     a11y::RootAccessible* rootAccessible = RootAccessible();
  2395:     NS_ENSURE_TRUE(rootAccessible, NS_ERROR_FAILURE);
  2395:     nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
  2395:     if (caretAccessible) {
 89799:       caretAccessible->AddDocSelectionListener(mPresShell);
  1249:     }
  1249:   }
  1249: 
     1:   // add document observer
     1:   mDocument->AddObserver(this);
     1:   return NS_OK;
     1: }
     1: 
 99568: // DocAccessible protected member
 99568: nsresult
 99568: DocAccessible::RemoveEventListeners()
     1: {
     1:   // Remove listeners associated with content documents
     1:   // Remove scroll position listener
     1:   RemoveScrollListener();
     1: 
 29795:   NS_ASSERTION(mDocument, "No document during removal of listeners.");
 29795: 
 29795:   if (mDocument) {
     1:     mDocument->RemoveObserver(this);
     1: 
 29795:     nsCOMPtr<nsISupports> container = mDocument->GetContainer();
 29795:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem(do_QueryInterface(container));
 29795:     NS_ASSERTION(docShellTreeItem, "doc should support nsIDocShellTreeItem.");
 29795: 
 29795:     if (docShellTreeItem) {
108991:       int32_t itemType;
 29795:       docShellTreeItem->GetItemType(&itemType);
 29795:       if (itemType == nsIDocShellTreeItem::typeContent) {
 29795:         nsCOMPtr<nsICommandManager> commandManager = do_GetInterface(docShellTreeItem);
 29795:         if (commandManager) {
 29795:           commandManager->RemoveCommandObserver(this, "obs_documentCreated");
 29795:         }
 29795:       }
 29795:     }
 29795:   }
 29795: 
     1:   if (mScrollWatchTimer) {
     1:     mScrollWatchTimer->Cancel();
106838:     mScrollWatchTimer = nullptr;
 10411:     NS_RELEASE_THIS(); // Kung fu death grip
     1:   }
     1: 
 97643:   a11y::RootAccessible* rootAccessible = RootAccessible();
  1249:   if (rootAccessible) {
  2395:     nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
 89799:     if (caretAccessible)
 89799:       caretAccessible->RemoveDocSelectionListener(mPresShell);
  1249:   }
  1249: 
     1:   return NS_OK;
     1: }
     1: 
 99568: void
 99568: DocAccessible::ScrollTimerCallback(nsITimer* aTimer, void* aClosure)
     1: {
 99568:   DocAccessible* docAcc = reinterpret_cast<DocAccessible*>(aClosure);
     1: 
     1:   if (docAcc && docAcc->mScrollPositionChangedTicks &&
     1:       ++docAcc->mScrollPositionChangedTicks > 2) {
     1:     // Whenever scroll position changes, mScrollPositionChangeTicks gets reset to 1
     1:     // We only want to fire accessibilty scroll event when scrolling stops or pauses
     1:     // Therefore, we wait for no scroll events to occur between 2 ticks of this timer
     1:     // That indicates a pause in scrolling, so we fire the accessibilty scroll event
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SCROLLING_END, docAcc);
  3152: 
     1:     docAcc->mScrollPositionChangedTicks = 0;
     1:     if (docAcc->mScrollWatchTimer) {
     1:       docAcc->mScrollWatchTimer->Cancel();
106838:       docAcc->mScrollWatchTimer = nullptr;
 10411:       NS_RELEASE(docAcc); // Release kung fu death grip
     1:     }
     1:   }
     1: }
     1: 
 99568: // DocAccessible protected member
 99568: void
 99568: DocAccessible::AddScrollListener()
     1: {
 89799:   if (!mPresShell)
 37062:     return;
     1: 
 89799:   nsIScrollableFrame* sf = mPresShell->GetRootScrollFrameAsScrollableExternal();
 37062:   if (sf) {
 37062:     sf->AddScrollPositionListener(this);
116102: #ifdef A11Y_LOG
 99203:     if (logging::IsEnabled(logging::eDocCreate))
 99203:       logging::Text("add scroll listener");
 99203: #endif
 37062:   }
     1: }
     1: 
 99568: // DocAccessible protected member
 99568: void
 99568: DocAccessible::RemoveScrollListener()
     1: {
 89799:   if (!mPresShell)
 37062:     return;
     1:  
 89799:   nsIScrollableFrame* sf = mPresShell->GetRootScrollFrameAsScrollableExternal();
 37062:   if (sf) {
 37062:     sf->RemoveScrollPositionListener(this);
 37062:   }
     1: }
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsIScrollPositionListener
 35523: 
 99568: void
 99568: DocAccessible::ScrollPositionDidChange(nscoord aX, nscoord aY)
     1: {
     1:   // Start new timer, if the timer cycles at least 1 full cycle without more scroll position changes,
     1:   // then the ::Notify() method will fire the accessibility event for scroll position changes
108991:   const uint32_t kScrollPosCheckWait = 50;
     1:   if (mScrollWatchTimer) {
     1:     mScrollWatchTimer->SetDelay(kScrollPosCheckWait);  // Create new timer, to avoid leaks
     1:   }
     1:   else {
     1:     mScrollWatchTimer = do_CreateInstance("@mozilla.org/timer;1");
     1:     if (mScrollWatchTimer) {
 10411:       NS_ADDREF_THIS(); // Kung fu death grip
     1:       mScrollWatchTimer->InitWithFuncCallback(ScrollTimerCallback, this,
     1:                                               kScrollPosCheckWait,
     1:                                               nsITimer::TYPE_REPEATING_SLACK);
     1:     }
     1:   }
     1:   mScrollPositionChangedTicks = 1;
     1: }
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsIObserver
 35523: 
 99568: NS_IMETHODIMP
 99568: DocAccessible::Observe(nsISupports* aSubject, const char* aTopic,
     1:                        const PRUnichar* aData)
     1: {
     1:   if (!nsCRT::strcmp(aTopic,"obs_documentCreated")) {    
  4625:     // State editable will now be set, readonly is now clear
 43016:     // Normally we only fire delayed events created from the node, not an
 51377:     // accessible object. See the AccStateChangeEvent constructor for details
 43016:     // about this exceptional case.
 51377:     nsRefPtr<AccEvent> event =
 80486:       new AccStateChangeEvent(this, states::EDITABLE, true);
 43016:     FireDelayedAccessibleEvent(event);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 89309: // nsIAccessiblePivotObserver
 89309: 
 89309: NS_IMETHODIMP
 99568: DocAccessible::OnPivotChanged(nsIAccessiblePivot* aPivot,
 89309:                               nsIAccessible* aOldAccessible,
108991:                               int32_t aOldStart, int32_t aOldEnd,
102486:                               PivotMoveReason aReason)
 89309: {
 91948:   nsRefPtr<AccEvent> event = new AccVCChangeEvent(this, aOldAccessible,
102486:                                                   aOldStart, aOldEnd,
102486:                                                   aReason);
 89309:   nsEventShell::FireEvent(event);
 89309: 
 89309:   return NS_OK;
 89309: }
 89309: 
 89309: ////////////////////////////////////////////////////////////////////////////////
     1: // nsIDocumentObserver
     1: 
 99568: NS_IMPL_NSIDOCUMENTOBSERVER_CORE_STUB(DocAccessible)
 99568: NS_IMPL_NSIDOCUMENTOBSERVER_LOAD_STUB(DocAccessible)
 99568: NS_IMPL_NSIDOCUMENTOBSERVER_STYLE_STUB(DocAccessible)
     1: 
     1: void
 99568: DocAccessible::AttributeWillChange(nsIDocument* aDocument,
 51352:                                    dom::Element* aElement,
108991:                                    int32_t aNameSpaceID,
108991:                                    nsIAtom* aAttribute, int32_t aModType)
 29833: {
 99648:   Accessible* accessible = GetAccessible(aElement);
 75278:   if (!accessible) {
 75278:     if (aElement != mContent)
 75278:       return;
 75278: 
 75278:     accessible = this;
 75278:   }
 57845: 
 59412:   // Update dependent IDs cache. Take care of elements that are accessible
 59412:   // because dependent IDs cache doesn't contain IDs from non accessible
 59412:   // elements.
 75278:   if (aModType != nsIDOMMutationEvent::ADDITION)
 57845:     RemoveDependentIDsFor(accessible, aAttribute);
 75278: 
 75278:   // Store the ARIA attribute old value so that it can be used after
 75278:   // attribute change. Note, we assume there's no nested ARIA attribute
 75278:   // changes. If this happens then we should end up with keeping a stack of
 75278:   // old values.
 75278: 
 75278:   // XXX TODO: bugs 472142, 472143.
 75278:   // Here we will want to cache whatever attribute values we are interested
 75278:   // in, such as the existence of aria-pressed for button (so we know if we
 75278:   // need to newly expose it as a toggle button) etc.
 78350:   if (aAttribute == nsGkAtoms::aria_checked ||
 78350:       aAttribute == nsGkAtoms::aria_pressed) {
 75278:     mARIAAttrOldValue = (aModType != nsIDOMMutationEvent::ADDITION) ?
106838:       nsAccUtils::GetARIAToken(aElement, aAttribute) : nullptr;
 57845:   }
 29833: }
 29833: 
 29833: void
 99568: DocAccessible::AttributeChanged(nsIDocument* aDocument,
 51350:                                 dom::Element* aElement,
108991:                                 int32_t aNameSpaceID, nsIAtom* aAttribute,
108991:                                 int32_t aModType)
     1: {
 60733:   NS_ASSERTION(!IsDefunct(),
 60733:                "Attribute changed called on defunct document accessible!");
 60733: 
 59464:   // Proceed even if the element is not accessible because element may become
 59464:   // accessible if it gets certain attribute.
 59464:   if (UpdateAccessibleOnAttrChange(aElement, aAttribute))
 59464:     return;
 59464: 
 59464:   // Ignore attribute change if the element doesn't have an accessible (at all
 59464:   // or still) iff the element is not a root content of this document accessible
 59464:   // (which is treated as attribute change on this document accessible).
 60733:   // Note: we don't bail if all the content hasn't finished loading because
 60733:   // these attributes are changing for a loaded part of the content.
 99648:   Accessible* accessible = GetAccessible(aElement);
 62906:   if (!accessible) {
 62906:     if (mContent != aElement)
 59464:       return;
 59464: 
 62906:     accessible = this;
 62906:   }
 62906: 
 59464:   // Fire accessible events iff there's an accessible, otherwise we consider
 59464:   // the accessible state wasn't changed, i.e. its state is initial state.
 51350:   AttributeChangedImpl(aElement, aNameSpaceID, aAttribute);
  6065: 
 59412:   // Update dependent IDs cache. Take care of accessible elements because no
 59412:   // accessible element means either the element is not accessible at all or
 59412:   // its accessible will be created later. It doesn't make sense to keep
 59412:   // dependent IDs for non accessible elements. For the second case we'll update
 59412:   // dependent IDs cache when its accessible is created.
 57845:   if (aModType == nsIDOMMutationEvent::MODIFICATION ||
 57845:       aModType == nsIDOMMutationEvent::ADDITION) {
 57845:     AddDependentIDsFor(accessible, aAttribute);
 57845:   }
  6065: }
  6065: 
 99568: // DocAccessible protected member
  6065: void
108991: DocAccessible::AttributeChangedImpl(nsIContent* aContent, int32_t aNameSpaceID, nsIAtom* aAttribute)
  6065: {
   577:   // Fire accessible event after short timer, because we need to wait for
   577:   // DOM attribute & resulting layout to actually change. Otherwise,
   577:   // assistive technology will retrieve the wrong state/value/selection info.
   577: 
     1:   // XXX todo
     1:   // We still need to handle special HTML cases here
     1:   // For example, if an <img>'s usemap attribute is modified
     1:   // Otherwise it may just be a state change, for example an object changing
     1:   // its visibility
 23549:   // 
 23549:   // XXX todo: report aria state changes for "undefined" literal value changes
 23549:   // filed as bug 472142
 23549:   //
 23549:   // XXX todo:  invalidate accessible when aria state changes affect exposed role
 23549:   // filed as bug 472143
     1: 
 32514:   // Universal boolean properties that don't require a role. Fire the state
 32514:   // change when disabled or aria-disabled attribute is set.
 78350:   if (aAttribute == nsGkAtoms::disabled ||
 78350:       aAttribute == nsGkAtoms::aria_disabled) {
 32514: 
 32514:     // Note. Checking the XUL or HTML namespace would not seem to gain us
 32514:     // anything, because disabled attribute really is going to mean the same
 32514:     // thing in any namespace.
 32514: 
 32514:     // Note. We use the attribute instead of the disabled state bit because
 32514:     // ARIA's aria-disabled does not affect the disabled state bit.
 32514: 
 51377:     nsRefPtr<AccEvent> enabledChangeEvent =
 67790:       new AccStateChangeEvent(aContent, states::ENABLED);
 32514: 
   652:     FireDelayedAccessibleEvent(enabledChangeEvent);
 32514: 
 51377:     nsRefPtr<AccEvent> sensitiveChangeEvent =
 67790:       new AccStateChangeEvent(aContent, states::SENSITIVE);
 32514: 
   652:     FireDelayedAccessibleEvent(sensitiveChangeEvent);
   652:     return;
   652:   }
   652: 
  6279:   // Check for namespaced ARIA attribute
  8937:   if (aNameSpaceID == kNameSpaceID_None) {
  6279:     // Check for hyphenated aria-foo property?
 39100:     if (StringBeginsWith(nsDependentAtomString(aAttribute),
 39100:                          NS_LITERAL_STRING("aria-"))) {
  8937:       ARIAAttributeChanged(aContent, aAttribute);
  6279:     }
  6279:   }
   577: 
 78350:   if (aAttribute == nsGkAtoms::alt ||
 78350:       aAttribute == nsGkAtoms::title ||
 78350:       aAttribute == nsGkAtoms::aria_label ||
 78350:       aAttribute == nsGkAtoms::aria_labelledby) {
 32196:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE,
 43504:                                aContent);
 11915:     return;
 11915:   }
 11915: 
 78350:   if (aAttribute == nsGkAtoms::aria_busy) {
 79445:     bool isOn = aContent->AttrValueIs(aNameSpaceID, aAttribute,
 78350:                                       nsGkAtoms::_true, eCaseMatters);
 70454:     nsRefPtr<AccEvent> event = new AccStateChangeEvent(aContent, states::BUSY, isOn);
 70454:     FireDelayedAccessibleEvent(event);
 70454:     return;
 70454:   }
 70454: 
 81286:   // ARIA or XUL selection
 81286:   if ((aContent->IsXUL() && aAttribute == nsGkAtoms::selected) ||
 78350:       aAttribute == nsGkAtoms::aria_selected) {
 99648:     Accessible* item = GetAccessible(aContent);
 98327:     if (!item)
 98327:       return;
 98327: 
 99648:     Accessible* widget =
 81286:       nsAccUtils::GetSelectableContainer(item, item->State());
 81286:     if (widget) {
 81286:       AccSelChangeEvent::SelChangeType selChangeType =
 81286:         aContent->AttrValueIs(aNameSpaceID, aAttribute,
 81286:                               nsGkAtoms::_true, eCaseMatters) ?
 81286:           AccSelChangeEvent::eSelectionAdd : AccSelChangeEvent::eSelectionRemove;
 43504: 
 81286:       nsRefPtr<AccEvent> event =
 81286:         new AccSelChangeEvent(widget, item, selChangeType);
 81286:       FireDelayedAccessibleEvent(event);
 81286:     }
   577:     return;
     1:   }
   577: 
 78350:   if (aAttribute == nsGkAtoms::contenteditable) {
 51377:     nsRefPtr<AccEvent> editableChangeEvent =
 67790:       new AccStateChangeEvent(aContent, states::EDITABLE);
  4625:     FireDelayedAccessibleEvent(editableChangeEvent);
  4625:     return;
  4625:   }
119017: 
119017:   if (aAttribute == nsGkAtoms::value) {
119017:     Accessible* accessible = GetAccessible(aContent);
119035:     if(accessible && accessible->IsProgress()) {
119017:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE,
119017:                                  aContent);
119017:     }
119017:   }
     1: }
   577: 
 99568: // DocAccessible protected member
   577: void
 99568: DocAccessible::ARIAAttributeChanged(nsIContent* aContent, nsIAtom* aAttribute)
   577: {
 40142:   // Note: For universal/global ARIA states and properties we don't care if
 40142:   // there is an ARIA role present or not.
 40142: 
 78350:   if (aAttribute == nsGkAtoms::aria_required) {
 51377:     nsRefPtr<AccEvent> event =
 67790:       new AccStateChangeEvent(aContent, states::REQUIRED);
   577:     FireDelayedAccessibleEvent(event);
   577:     return;
   577:   }
   577: 
 78350:   if (aAttribute == nsGkAtoms::aria_invalid) {
 51377:     nsRefPtr<AccEvent> event =
 67790:       new AccStateChangeEvent(aContent, states::INVALID);
   577:     FireDelayedAccessibleEvent(event);
   577:     return;
   577:   }
   577: 
 79384:   // The activedescendant universal property redirects accessible focus events
 79384:   // to the element with the id that activedescendant points to. Make sure
 79384:   // the tree up to date before processing.
 78350:   if (aAttribute == nsGkAtoms::aria_activedescendant) {
 99568:     mNotificationController->HandleNotification<DocAccessible, nsIContent>
 99568:       (this, &DocAccessible::ARIAActiveDescendantChanged, aContent);
 79384: 
     1:     return;
     1:   }
   577: 
 40142:   // We treat aria-expanded as a global ARIA state for historical reasons
 78350:   if (aAttribute == nsGkAtoms::aria_expanded) {
 51377:     nsRefPtr<AccEvent> event =
 67790:       new AccStateChangeEvent(aContent, states::EXPANDED);
 40142:     FireDelayedAccessibleEvent(event);
 40142:     return;
 40142:   }
 40142: 
 96799:   // For aria attributes like drag and drop changes we fire a generic attribute
 96799:   // change event; at least until native API comes up with a more meaningful event.
108991:   uint8_t attrFlags = nsAccUtils::GetAttributeCharacteristics(aAttribute);
 96799:   if (!(attrFlags & ATTR_BYPASSOBJ))
 96799:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_OBJECT_ATTRIBUTE_CHANGED,
 96799:                                aContent);
 96799: 
 78350:   if (!aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::role)) {
     1:     // We don't care about these other ARIA attribute changes unless there is
     1:     // an ARIA role set for the element
   577:     // XXX: we should check the role map to see if the changed property is
   577:     // relevant for that particular role.
     1:     return;
     1:   }
   577: 
  8937:   // The following ARIA attributes only take affect when dynamic content role is present
 78350:   if (aAttribute == nsGkAtoms::aria_checked ||
 78350:       aAttribute == nsGkAtoms::aria_pressed) {
108991:     const uint32_t kState = (aAttribute == nsGkAtoms::aria_checked) ?
 67790:                             states::CHECKED : states::PRESSED;
 75278:     nsRefPtr<AccEvent> event = new AccStateChangeEvent(aContent, kState);
  6065:     FireDelayedAccessibleEvent(event);
 75278: 
 99648:     Accessible* accessible = event->GetAccessible();
  6065:     if (accessible) {
 78350:       bool wasMixed = (mARIAAttrOldValue == nsGkAtoms::mixed);
 75278:       bool isMixed = aContent->AttrValueIs(kNameSpaceID_None, aAttribute,
 78350:                                            nsGkAtoms::mixed, eCaseMatters);
 75278:       if (isMixed != wasMixed) {
 51377:         nsRefPtr<AccEvent> event =
 67790:           new AccStateChangeEvent(aContent, states::MIXED, isMixed);
   577:         FireDelayedAccessibleEvent(event);
     1:       }
  6065:     }
  4624:     return;
  4624:   }
  4624: 
 78350:   if (aAttribute == nsGkAtoms::aria_readonly) {
 51377:     nsRefPtr<AccEvent> event =
 67790:       new AccStateChangeEvent(aContent, states::READONLY);
   577:     FireDelayedAccessibleEvent(event);
   577:     return;
   577:   }
   577: 
 29090:   // Fire value change event whenever aria-valuetext is changed, or
 29090:   // when aria-valuenow is changed and aria-valuetext is empty
 78350:   if (aAttribute == nsGkAtoms::aria_valuetext ||
 78350:       (aAttribute == nsGkAtoms::aria_valuenow &&
 78350:        (!aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_valuetext) ||
 78350:         aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::aria_valuetext,
 78350:                               nsGkAtoms::_empty, eCaseMatters)))) {
 32196:     FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE,
 43504:                                aContent);
   577:     return;
   577:   }
     1: }
     1: 
 79384: void
 99568: DocAccessible::ARIAActiveDescendantChanged(nsIContent* aElm)
 79384: {
111153:   Accessible* widget = GetAccessible(aElm);
111153:   if (widget && widget->IsActiveWidget()) {
 79384:     nsAutoString id;
 79384:     if (aElm->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_activedescendant, id)) {
111153:       dom::Element* activeDescendantElm = aElm->OwnerDoc()->GetElementById(id);
 79384:       if (activeDescendantElm) {
 99648:         Accessible* activeDescendant = GetAccessible(activeDescendantElm);
 79384:         if (activeDescendant) {
 79384:           FocusMgr()->ActiveItemChanged(activeDescendant, false);
116102: #ifdef A11Y_LOG
115085:           if (logging::IsEnabled(logging::eFocus))
115085:             logging::ActiveItemChangeCausedBy("ARIA activedescedant changed",
115085:                                               activeDescendant);
115085: #endif
 79384:         }
 79384:       }
 79384:     }
 79384:   }
 79384: }
 79384: 
 99568: void
 99568: DocAccessible::ContentAppended(nsIDocument* aDocument,
     1:                                nsIContent* aContainer,
 42107:                                nsIContent* aFirstNewContent,
108991:                                int32_t /* unused */)
     1: {
  4296: }
  4296: 
 99568: void
 99568: DocAccessible::ContentStateChanged(nsIDocument* aDocument,
 64120:                                    nsIContent* aContent,
 56168:                                    nsEventStates aStateMask)
     1: {
 57105:   if (aStateMask.HasState(NS_EVENT_STATE_CHECKED)) {
 99648:     Accessible* item = GetAccessible(aContent);
 81286:     if (item) {
 99648:       Accessible* widget = item->ContainerWidget();
 81286:       if (widget && widget->IsSelect()) {
 81286:         AccSelChangeEvent::SelChangeType selChangeType =
 81286:           aContent->AsElement()->State().HasState(NS_EVENT_STATE_CHECKED) ?
 81286:             AccSelChangeEvent::eSelectionAdd : AccSelChangeEvent::eSelectionRemove;
 81286:         nsRefPtr<AccEvent> event = new AccSelChangeEvent(widget, item,
 81286:                                                          selChangeType);
 81286:         FireDelayedAccessibleEvent(event);
 81286:       }
 81286:     }
     1:   }
     1: 
 57105:   if (aStateMask.HasState(NS_EVENT_STATE_INVALID)) {
 57105:     nsRefPtr<AccEvent> event =
 80486:       new AccStateChangeEvent(aContent, states::INVALID, true);
 57105:     FireDelayedAccessibleEvent(event);
 57105:    }
     1: }
     1: 
 99568: void
 99568: DocAccessible::DocumentStatesChanged(nsIDocument* aDocument,
 56168:                                      nsEventStates aStateMask)
 39698: {
 39698: }
 39698: 
 99568: void
 99568: DocAccessible::CharacterDataWillChange(nsIDocument* aDocument,
     1:                                        nsIContent* aContent,
     1:                                        CharacterDataChangeInfo* aInfo)
     1: {
     1: }
     1: 
     1: void
 99568: DocAccessible::CharacterDataChanged(nsIDocument* aDocument,
 99568:                                     nsIContent* aContent,
 99568:                                     CharacterDataChangeInfo* aInfo)
 99568: {
 99568: }
 99568: 
 99568: void
 99568: DocAccessible::ContentInserted(nsIDocument* aDocument, nsIContent* aContainer,
108991:                                nsIContent* aChild, int32_t /* unused */)
     1: {
     1: }
     1: 
     1: void
 99568: DocAccessible::ContentRemoved(nsIDocument* aDocument, nsIContent* aContainer,
108991:                               nsIContent* aChild, int32_t /* unused */,
 48038:                               nsIContent* aPreviousSibling)
     1: {
     1: }
     1: 
     1: void
 99568: DocAccessible::ParentChainChanged(nsIContent* aContent)
     1: {
     1: }
     1: 
 35523: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 99648: // Accessible
 35523: 
116102: #ifdef A11Y_LOG
 43310: nsresult
 99568: DocAccessible::HandleAccEvent(AccEvent* aEvent)
 43310: {
 99203:   if (logging::IsEnabled(logging::eDocLoad))
 99203:     logging::DocLoadEventHandled(aEvent);
 43310: 
 99901:   return HyperTextAccessible::HandleAccEvent(aEvent);
 35523: }
 43310: #endif
 43310: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // Public members
 35523: 
 54220: void*
 99568: DocAccessible::GetNativeWindow() const
 54220: {
 89799:   if (!mPresShell)
106838:     return nullptr;
 86958: 
 89799:   nsIViewManager* vm = mPresShell->GetViewManager();
 86958:   if (!vm)
106838:     return nullptr;
 86958: 
 54220:   nsCOMPtr<nsIWidget> widget;
 54220:   vm->GetRootWidget(getter_AddRefs(widget));
 54220:   if (widget)
 54220:     return widget->GetNativeData(NS_NATIVE_WINDOW);
 86958: 
106838:   return nullptr;
 54220: }
 54220: 
 99648: Accessible*
 99568: DocAccessible::GetAccessibleByUniqueIDInSubtree(void* aUniqueID)
 52279: {
 99648:   Accessible* child = GetAccessibleByUniqueID(aUniqueID);
 52279:   if (child)
 52279:     return child;
 52279: 
108991:   uint32_t childDocCount = mChildDocuments.Length();
108991:   for (uint32_t childDocIdx= 0; childDocIdx < childDocCount; childDocIdx++) {
 99568:     DocAccessible* childDocument = mChildDocuments.ElementAt(childDocIdx);
 61461:     child = childDocument->GetAccessibleByUniqueIDInSubtree(aUniqueID);
 52279:     if (child)
 52279:       return child;
 52279:   }
 52279: 
106838:   return nullptr;
 52279: }
 35523: 
 99648: Accessible*
 99568: DocAccessible::GetAccessibleOrContainer(nsINode* aNode)
 61462: {
 61462:   if (!aNode || !aNode->IsInDoc())
106838:     return nullptr;
 61462: 
 61462:   nsINode* currNode = aNode;
106838:   Accessible* accessible = nullptr;
 61462:   while (!(accessible = GetAccessible(currNode)) &&
119415:          (currNode = currNode->GetParentNode()));
 61462: 
 61462:   return accessible;
 61462: }
 61462: 
 57413: bool
 99648: DocAccessible::BindToDocument(Accessible* aAccessible,
 57413:                               nsRoleMapEntry* aRoleMapEntry)
 57413: {
 57413:   if (!aAccessible)
 57413:     return false;
 57413: 
 57413:   // Put into DOM node cache.
118792:   if (aAccessible->IsNodeMapEntry())
 98908:     mNodeToAccessibleMap.Put(aAccessible->GetNode(), aAccessible);
 57413: 
 57413:   // Put into unique ID cache.
 98908:   mAccessibleCache.Put(aAccessible->UniqueID(), aAccessible);
 57413: 
 57413:   // Initialize the accessible.
107208:   aAccessible->Init();
 57413: 
 57413:   aAccessible->SetRoleMapEntry(aRoleMapEntry);
 61465:   if (aAccessible->IsElement())
 57845:     AddDependentIDsFor(aAccessible);
 61465: 
 57413:   return true;
 57413: }
 57413: 
 57413: void
 99648: DocAccessible::UnbindFromDocument(Accessible* aAccessible)
 57413: {
 57934:   NS_ASSERTION(mAccessibleCache.GetWeak(aAccessible->UniqueID()),
 57934:                "Unbinding the unbound accessible!");
 57934: 
 79384:   // Fire focus event on accessible having DOM focus if active item was removed
 79384:   // from the tree.
 79384:   if (FocusMgr()->IsActiveItem(aAccessible)) {
106838:     FocusMgr()->ActiveItemChanged(nullptr);
116102: #ifdef A11Y_LOG
115085:           if (logging::IsEnabled(logging::eFocus))
115085:             logging::ActiveItemChangeCausedBy("tree shutdown", aAccessible);
115085: #endif
 79384:   }
 79384: 
 57414:   // Remove an accessible from node-to-accessible map if it exists there.
118792:   if (aAccessible->IsNodeMapEntry() &&
 57413:       mNodeToAccessibleMap.Get(aAccessible->GetNode()) == aAccessible)
 57413:     mNodeToAccessibleMap.Remove(aAccessible->GetNode());
 57413: 
 57934:   void* uniqueID = aAccessible->UniqueID();
 57413: 
 57934:   NS_ASSERTION(!aAccessible->IsDefunct(), "Shutdown the shutdown accessible!");
 57413:   aAccessible->Shutdown();
 57934: 
 57413:   mAccessibleCache.Remove(uniqueID);
 57413: }
 57413: 
 56292: void
 99568: DocAccessible::ContentInserted(nsIContent* aContainerNode,
 60746:                                nsIContent* aStartChildNode,
 60746:                                nsIContent* aEndChildNode)
 56292: {
 75013:   // Ignore content insertions until we constructed accessible tree. Otherwise
 75013:   // schedule tree update on content insertion after layout.
 75013:   if (mNotificationController && HasLoadState(eTreeConstructed)) {
 56987:     // Update the whole tree of this document accessible when the container is
 56987:     // null (document element is inserted or removed).
 99648:     Accessible* container = aContainerNode ?
 61462:       GetAccessibleOrContainer(aContainerNode) : this;
 56292: 
 60746:     mNotificationController->ScheduleContentInsertion(container,
 60746:                                                       aStartChildNode,
 60746:                                                       aEndChildNode);
 60746:   }
 56987: }
 56987: 
 60746: void
 99568: DocAccessible::ContentRemoved(nsIContent* aContainerNode,
 60746:                               nsIContent* aChildNode)
 60746: {
 60746:   // Update the whole tree of this document accessible when the container is
 60746:   // null (document element is removed).
 99648:   Accessible* container = aContainerNode ?
 61462:     GetAccessibleOrContainer(aContainerNode) : this;
 56292: 
 67625:   UpdateTree(container, aChildNode, false);
 56292: }
 56292: 
 56292: void
 99568: DocAccessible::RecreateAccessible(nsIContent* aContent)
 56292: {
118467: #ifdef A11Y_LOG
118467:   if (logging::IsEnabled(logging::eTree)) {
118467:     logging::MsgBegin("TREE", "accessible recreated");
118467:     logging::Node("content", aContent);
118467:     logging::MsgEnd();
118467:   }
118467: #endif
118467: 
 61681:   // XXX: we shouldn't recreate whole accessible subtree, instead we should
 61681:   // subclass hide and show events to handle them separately and implement their
 61681:   // coalescence with normal hide and show events. Note, in this case they
 61681:   // should be coalesced with normal show/hide events.
 56292: 
 93850:   ContentRemoved(aContent->GetParent(), aContent);
 93850:   ContentInserted(aContent->GetParent(), aContent, aContent->GetNextSibling());
 56292: }
 56292: 
 57890: void
 99568: DocAccessible::ProcessInvalidationList()
 57890: {
 57890:   // Invalidate children of container accessible for each element in
 74257:   // invalidation list. Allow invalidation list insertions while container
 74257:   // children are recached.
108991:   for (uint32_t idx = 0; idx < mInvalidationList.Length(); idx++) {
 57890:     nsIContent* content = mInvalidationList[idx];
 99648:     Accessible* accessible = GetAccessible(content);
 67626:     if (!accessible) {
 99648:       Accessible* container = GetContainerAccessible(content);
 67626:       if (container) {
 61359:         container->UpdateChildren();
 67626:         accessible = GetAccessible(content);
 57890:       }
 62350:     }
 67626: 
 67626:     // Make sure the subtree is created.
 67626:     if (accessible)
 67626:       CacheChildrenInSubtree(accessible);
 67626:   }
 74257: 
 57890:   mInvalidationList.Clear();
 57890: }
 57890: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 99648: // Accessible protected
 57964: 
 57964: void
 99568: DocAccessible::CacheChildren()
 57964: {
 57964:   // Search for accessible children starting from the document element since
 57964:   // some web pages tend to insert elements under it rather than document body.
 89801:   nsAccTreeWalker walker(this, mDocument->GetRootElement(),
 89679:                          CanHaveAnonChildren());
 57964: 
106838:   Accessible* child = nullptr;
 64506:   while ((child = walker.NextChild()) && AppendChild(child));
 57964: }
 57964: 
 57964: ////////////////////////////////////////////////////////////////////////////////
 35523: // Protected members
 35523: 
  3950: void
 99568: DocAccessible::NotifyOfLoading(bool aIsReloading)
 63261: {
 75013:   // Mark the document accessible as loading, if it stays alive then we'll mark
 75013:   // it as loaded when we receive proper notification.
 75013:   mLoadState &= ~eDOMLoaded;
 75013: 
 75013:   if (!IsLoadEventTarget())
 75013:     return;
 75013: 
 75013:   if (aIsReloading) {
 75013:     // Fire reload and state busy events on existing document accessible while
 75013:     // event from user input flag can be calculated properly and accessible
 75013:     // is alive. When new document gets loaded then this one is destroyed.
 75013:     nsRefPtr<AccEvent> reloadEvent =
 75013:       new AccEvent(nsIAccessibleEvent::EVENT_DOCUMENT_RELOAD, this);
 75013:     nsEventShell::FireEvent(reloadEvent);
 75013:   }
 75013: 
 75013:   // Fire state busy change event. Use delayed event since we don't care
 75013:   // actually if event isn't delivered when the document goes away like a shot.
 75013:   nsRefPtr<AccEvent> stateEvent =
 80486:     new AccStateChangeEvent(mDocument, states::BUSY, true);
 75013:   FireDelayedAccessibleEvent(stateEvent);
 75013: }
 75013: 
 75013: void
 99568: DocAccessible::DoInitialUpdate()
 75013: {
 75013:   mLoadState |= eTreeConstructed;
 75013: 
 63310:   // The content element may be changed before the initial update and then we
 63310:   // miss the notification (since content tree change notifications are ignored
 63310:   // prior to initial update). Make sure the content element is valid.
 63310:   nsIContent* contentElm = nsCoreUtils::GetRoleContent(mDocument);
 63310:   if (contentElm && mContent != contentElm)
 63310:     mContent = contentElm;
 63310: 
 63310:   // Build initial tree.
 63310:   CacheChildrenInSubtree(this);
 74015: 
 74015:   // Fire reorder event after the document tree is constructed. Note, since
 74015:   // this reorder event is processed by parent document then events targeted to
 74015:   // this document may be fired prior to this reorder event. If this is
 74015:   // a problem then consider to keep event processing per tab document.
 74015:   if (!IsRoot()) {
 74015:     nsRefPtr<AccEvent> reorderEvent =
 74545:       new AccEvent(nsIAccessibleEvent::EVENT_REORDER, Parent(), eAutoDetect,
 74545:                    AccEvent::eCoalesceFromSameSubtree);
 74015:     ParentDocument()->FireDelayedAccessibleEvent(reorderEvent);
 74015:   }
 63261: }
 63261: 
 63261: void
 99568: DocAccessible::ProcessLoad()
 75013: {
 75013:   mLoadState |= eCompletelyLoaded;
 75013: 
118473: #ifdef A11Y_LOG
118473:   if (logging::IsEnabled(logging::eDocLoad))
118473:     logging::DocCompleteLoad(this, IsLoadEventTarget());
118473: #endif
118473: 
 75013:   // Do not fire document complete/stop events for root chrome document
 75013:   // accessibles and for frame/iframe documents because
 75013:   // a) screen readers start working on focus event in the case of root chrome
 75013:   // documents
 75013:   // b) document load event on sub documents causes screen readers to act is if
 75013:   // entire page is reloaded.
 75013:   if (!IsLoadEventTarget())
 75013:     return;
 75013: 
 75013:   // Fire complete/load stopped if the load event type is given.
 75013:   if (mLoadEventType) {
 75013:     nsRefPtr<AccEvent> loadEvent = new AccEvent(mLoadEventType, this);
 75013:     nsEventShell::FireEvent(loadEvent);
 75013: 
 75013:     mLoadEventType = 0;
 75013:   }
 75013: 
 75013:   // Fire busy state change event.
 75013:   nsRefPtr<AccEvent> stateEvent =
 80486:     new AccStateChangeEvent(this, states::BUSY, false);
 75013:   nsEventShell::FireEvent(stateEvent);
 75013: }
 75013: 
 75013: void
 99648: DocAccessible::AddDependentIDsFor(Accessible* aRelProvider,
 57845:                                   nsIAtom* aRelAttr)
 57845: {
108991:   for (uint32_t idx = 0; idx < kRelationAttrsLen; idx++) {
 57845:     nsIAtom* relAttr = *kRelationAttrs[idx];
 57845:     if (aRelAttr && aRelAttr != relAttr)
 57845:       continue;
 57845: 
 78350:     if (relAttr == nsGkAtoms::_for) {
 57932:       if (!aRelProvider->GetContent()->IsHTML() ||
 84916:           (aRelProvider->GetContent()->Tag() != nsGkAtoms::label &&
 84916:            aRelProvider->GetContent()->Tag() != nsGkAtoms::output))
 57932:         continue;
 57932: 
 78350:     } else if (relAttr == nsGkAtoms::control) {
 57932:       if (!aRelProvider->GetContent()->IsXUL() ||
 84916:           (aRelProvider->GetContent()->Tag() != nsGkAtoms::label &&
 84916:            aRelProvider->GetContent()->Tag() != nsGkAtoms::description))
 57932:         continue;
 57932:     }
 57932: 
 93856:     IDRefsIterator iter(this, aRelProvider->GetContent(), relAttr);
 57845:     while (true) {
 57845:       const nsDependentSubstring id = iter.NextID();
 57845:       if (id.IsEmpty())
 57845:         break;
 57845: 
 57845:       AttrRelProviderArray* providers = mDependentIDsHash.Get(id);
 57845:       if (!providers) {
 57845:         providers = new AttrRelProviderArray();
 57845:         if (providers) {
 98908:           mDependentIDsHash.Put(id, providers);
 57845:         }
 57845:       }
 57845: 
 57845:       if (providers) {
 57845:         AttrRelProvider* provider =
 57845:           new AttrRelProvider(relAttr, aRelProvider->GetContent());
 57890:         if (provider) {
 57845:           providers->AppendElement(provider);
 57890: 
 57890:           // We've got here during the children caching. If the referenced
 57890:           // content is not accessible then store it to pend its container
 57890:           // children invalidation (this happens immediately after the caching
 57890:           // is finished).
 57890:           nsIContent* dependentContent = iter.GetElem(id);
 61461:           if (dependentContent && !HasAccessible(dependentContent)) {
 57890:             mInvalidationList.AppendElement(dependentContent);
 57890:           }
 57890:         }
 57845:       }
 57845:     }
 57845: 
 57845:     // If the relation attribute is given then we don't have anything else to
 57845:     // check.
 57845:     if (aRelAttr)
 57845:       break;
 57845:   }
 57845: }
 57845: 
 57845: void
 99648: DocAccessible::RemoveDependentIDsFor(Accessible* aRelProvider,
 57845:                                      nsIAtom* aRelAttr)
 57845: {
108991:   for (uint32_t idx = 0; idx < kRelationAttrsLen; idx++) {
 57845:     nsIAtom* relAttr = *kRelationAttrs[idx];
 57845:     if (aRelAttr && aRelAttr != *kRelationAttrs[idx])
 57845:       continue;
 57845: 
 93856:     IDRefsIterator iter(this, aRelProvider->GetContent(), relAttr);
 57845:     while (true) {
 57845:       const nsDependentSubstring id = iter.NextID();
 57845:       if (id.IsEmpty())
 57845:         break;
 57845: 
 57845:       AttrRelProviderArray* providers = mDependentIDsHash.Get(id);
 57845:       if (providers) {
108991:         for (uint32_t jdx = 0; jdx < providers->Length(); ) {
 57845:           AttrRelProvider* provider = (*providers)[jdx];
 57845:           if (provider->mRelAttr == relAttr &&
 57845:               provider->mContent == aRelProvider->GetContent())
 57845:             providers->RemoveElement(provider);
 57845:           else
 57845:             jdx++;
 57845:         }
 57845:         if (providers->Length() == 0)
 57845:           mDependentIDsHash.Remove(id);
 57845:       }
 57845:     }
 57845: 
 57845:     // If the relation attribute is given then we don't have anything else to
 57845:     // check.
 57845:     if (aRelAttr)
 57845:       break;
 57845:   }
 57845: }
 57845: 
 59464: bool
 99568: DocAccessible::UpdateAccessibleOnAttrChange(dom::Element* aElement,
 59464:                                             nsIAtom* aAttribute)
 59464: {
 78350:   if (aAttribute == nsGkAtoms::role) {
 59464:     // It is common for js libraries to set the role on the body element after
 59464:     // the document has loaded. In this case we just update the role map entry.
 59464:     if (mContent == aElement) {
 95490:       SetRoleMapEntry(aria::GetRoleMap(aElement));
 59464:       return true;
 59464:     }
 59464: 
 59464:     // Recreate the accessible when role is changed because we might require a
 59464:     // different accessible class for the new role or the accessible may expose
 59464:     // a different sets of interfaces (COM restriction).
 93850:     RecreateAccessible(aElement);
 60851: 
 59464:     return true;
 59464:   }
 59464: 
 78350:   if (aAttribute == nsGkAtoms::href ||
 78350:       aAttribute == nsGkAtoms::onclick) {
 61681:     // Not worth the expense to ensure which namespace these are in. It doesn't
 61681:     // kill use to recreate the accessible even if the attribute was used in
 61681:     // the wrong namespace or an element that doesn't support it.
 61681: 
 93850:     // Make sure the accessible is recreated asynchronously to allow the content
 93850:     // to handle the attribute change.
 93850:     RecreateAccessible(aElement);
 59464:     return true;
 59464:   }
 59464: 
 78350:   if (aAttribute == nsGkAtoms::aria_multiselectable &&
 78350:       aElement->HasAttr(kNameSpaceID_None, nsGkAtoms::role)) {
 59464:     // This affects whether the accessible supports SelectAccessible.
 59464:     // COM says we cannot change what interfaces are supported on-the-fly,
 59464:     // so invalidate this object. A new one will be created on demand.
 93850:     RecreateAccessible(aElement);
 60851: 
 59464:     return true;
 59464:   }
 59464: 
 59464:   return false;
 59464: }
 59464: 
 99568: // DocAccessible public member
 32196: nsresult
108991: DocAccessible::FireDelayedAccessibleEvent(uint32_t aEventType, nsINode* aNode,
 51377:                                           AccEvent::EEventRule aAllowDupes,
 37339:                                           EIsFromUserInput aIsFromUserInput)
     1: {
 51377:   nsRefPtr<AccEvent> event =
 56292:     new AccEvent(aEventType, aNode, aIsFromUserInput, aAllowDupes);
   577:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
   577: 
 13167:   return FireDelayedAccessibleEvent(event);
   577: }
   577: 
 99568: // DocAccessible public member
   577: nsresult
 99568: DocAccessible::FireDelayedAccessibleEvent(AccEvent* aEvent)
   577: {
 32285:   NS_ENSURE_ARG(aEvent);
 99203: 
116102: #ifdef A11Y_LOG
 99203:   if (logging::IsEnabled(logging::eDocLoad))
 99203:     logging::DocLoadEventFired(aEvent);
 99203: #endif
  4846: 
 60746:   if (mNotificationController)
 60746:     mNotificationController->QueueEvent(aEvent);
 32196: 
 37537:   return NS_OK;
     1: }
     1: 
 29564: void
 99568: DocAccessible::ProcessPendingEvent(AccEvent* aEvent)
     1: {
108991:   uint32_t eventType = aEvent->GetEventType();
 43310:   if (eventType == nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED) {
 99901:     HyperTextAccessible* hyperText = aEvent->GetAccessible()->AsHyperText();
108991:     int32_t caretOffset;
 80205:     if (hyperText &&
 80205:         NS_SUCCEEDED(hyperText->GetCaretOffset(&caretOffset))) {
 51377:       nsRefPtr<AccEvent> caretMoveEvent =
 80205:         new AccCaretMoveEvent(hyperText, caretOffset);
 37282:       nsEventShell::FireEvent(caretMoveEvent);
  2688: 
108991:       int32_t selectionCount;
 80205:       hyperText->GetSelectionCount(&selectionCount);
     1:       if (selectionCount) {  // There's a selection so fire selection change as well
 37281:         nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_TEXT_SELECTION_CHANGED,
 80205:                                 hyperText);
     1:       }
     1:     }
     1:   }
     1:   else {
 37537:     nsEventShell::FireEvent(aEvent);
 37339: 
  4637:     // Post event processing
 56292:     if (eventType == nsIAccessibleEvent::EVENT_HIDE)
 80205:       ShutdownChildrenInSubtree(aEvent->GetAccessible());
  4637:   }
     1: }
 56292: 
 60746: void
 99648: DocAccessible::ProcessContentInserted(Accessible* aContainer,
 60746:                                       const nsTArray<nsCOMPtr<nsIContent> >* aInsertedContent)
 60746: {
 60746:   // Process the notification if the container accessible is still in tree.
 61461:   if (!HasAccessible(aContainer->GetNode()))
 60746:     return;
 60746: 
 60746:   if (aContainer == this) {
 60746:     // If new root content has been inserted then update it.
 60746:     nsIContent* rootContent = nsCoreUtils::GetRoleContent(mDocument);
 60746:     if (rootContent && rootContent != mContent)
 60746:       mContent = rootContent;
 60746: 
 60746:     // Continue to update the tree even if we don't have root content.
 60746:     // For example, elements may be inserted under the document element while
 60746:     // there is no HTML body element.
 60746:   }
 60746: 
 60746:   // XXX: Invalidate parent-child relations for container accessible and its
 60746:   // children because there's no good way to find insertion point of new child
 60746:   // accessibles into accessible tree. We need to invalidate children even
 60746:   // there's no inserted accessibles in the end because accessible children
 60746:   // are created while parent recaches child accessibles.
 61359:   aContainer->UpdateChildren();
 60746: 
 60746:   // The container might be changed, for example, because of the subsequent
 60746:   // overlapping content insertion (i.e. other content was inserted between this
 60746:   // inserted content and its container or the content was reinserted into
 60746:   // different container of unrelated part of tree). These cases result in
 60746:   // double processing, however generated events are coalesced and we don't
 61359:   // harm an AT.
 60867:   // Theoretically the element might be not in tree at all at this point what
 60867:   // means there's no container.
108991:   for (uint32_t idx = 0; idx < aInsertedContent->Length(); idx++) {
 99648:     Accessible* directContainer =
 61462:       GetContainerAccessible(aInsertedContent->ElementAt(idx));
 60867:     if (directContainer)
 67625:       UpdateTree(directContainer, aInsertedContent->ElementAt(idx), true);
 60746:   }
 60867: }
 60746: 
 60746: void
 99648: DocAccessible::UpdateTree(Accessible* aContainer, nsIContent* aChildNode,
 67625:                           bool aIsInsert)
 60746: {
108991:   uint32_t updateFlags = eNoAccessible;
 67625: 
 67625:   // If child node is not accessible then look for its accessible children.
 99648:   Accessible* child = GetAccessible(aChildNode);
116102: #ifdef A11Y_LOG
 99989:   if (logging::IsEnabled(logging::eTree)) {
 99989:     logging::MsgBegin("TREE", "process content %s",
 99989:                       (aIsInsert ? "insertion" : "removal"));
 99989:     logging::Node("container", aContainer->GetNode());
 99989:     logging::Node("child", aChildNode);
 99989:     if (child)
 99989:       logging::Address("child", child);
 99989:     else
 99989:       logging::MsgEntry("child accessible: null");
 99989: 
 99989:     logging::MsgEnd();
 99989:   }
 99989: #endif
 99989: 
 67625:   if (child) {
 67625:     updateFlags |= UpdateTreeInternal(child, aIsInsert);
 67625: 
 67625:   } else {
 89801:     nsAccTreeWalker walker(this, aChildNode,
 89679:                            aContainer->CanHaveAnonChildren(), true);
 67625: 
 67625:     while ((child = walker.NextChild()))
 67625:       updateFlags |= UpdateTreeInternal(child, aIsInsert);
 67625:   }
 60746: 
 60746:   // Content insertion/removal is not cause of accessible tree change.
 60746:   if (updateFlags == eNoAccessible)
 60746:     return;
 60746: 
 60746:   // Check to see if change occurred inside an alert, and fire an EVENT_ALERT
 60746:   // if it did.
 60746:   if (aIsInsert && !(updateFlags & eAlertAccessible)) {
 60746:     // XXX: tree traversal is perf issue, accessible should know if they are
 60746:     // children of alert accessible to avoid this.
 99648:     Accessible* ancestor = aContainer;
 60746:     while (ancestor) {
 87094:       if (ancestor->ARIARole() == roles::ALERT) {
 60746:         FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_ALERT,
 60746:                                    ancestor->GetNode());
 60746:         break;
 60746:       }
 60746: 
 60746:       // Don't climb above this document.
 60746:       if (ancestor == this)
 60746:         break;
 60746: 
 74545:       ancestor = ancestor->Parent();
 60746:     }
 60746:   }
 60746: 
 83075:   MaybeNotifyOfValueChange(aContainer);
 60746: 
 60746:   // Fire reorder event so the MSAA clients know the children have changed. Also
 60746:   // the event is used internally by MSAA layer.
 60746:   nsRefPtr<AccEvent> reorderEvent =
 60746:     new AccEvent(nsIAccessibleEvent::EVENT_REORDER, aContainer->GetNode(),
 60746:                  eAutoDetect, AccEvent::eCoalesceFromSameSubtree);
 60746:   if (reorderEvent)
 60746:     FireDelayedAccessibleEvent(reorderEvent);
 60746: }
 60746: 
108991: uint32_t
 99648: DocAccessible::UpdateTreeInternal(Accessible* aChild, bool aIsInsert)
 56292: {
108991:   uint32_t updateFlags = eAccessible;
 56292: 
 67625:   nsINode* node = aChild->GetNode();
 60921:   if (aIsInsert) {
 60921:     // Create accessible tree for shown accessible.
 67625:     CacheChildrenInSubtree(aChild);
 60921: 
 60921:   } else {
 58370:     // Fire menupopup end event before hide event if a menu goes away.
 58370: 
 58370:     // XXX: We don't look into children of hidden subtree to find hiding
 58370:     // menupopup (as we did prior bug 570275) because we don't do that when
 58370:     // menu is showing (and that's impossible until bug 606924 is fixed).
 58370:     // Nevertheless we should do this at least because layout coalesces
 58370:     // the changes before our processing and we may miss some menupopup
 58370:     // events. Now we just want to be consistent in content insertion/removal
 58370:     // handling.
 87094:     if (aChild->ARIARole() == roles::MENUPOPUP) {
 58370:       nsRefPtr<AccEvent> event =
 67625:         new AccEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_END, aChild);
 58370: 
 58370:       if (event)
 58370:         FireDelayedAccessibleEvent(event);
 58370:     }
 58370:   }
 58370: 
 56292:   // Fire show/hide event.
 56292:   nsRefPtr<AccEvent> event;
 56292:   if (aIsInsert)
 67625:     event = new AccShowEvent(aChild, node);
 56292:   else
 67625:     event = new AccHideEvent(aChild, node);
 56292: 
 56292:   if (event)
 56292:     FireDelayedAccessibleEvent(event);
 56292: 
 56292:   if (aIsInsert) {
 87094:     roles::Role ariaRole = aChild->ARIARole();
 87094:     if (ariaRole == roles::MENUPOPUP) {
 56292:       // Fire EVENT_MENUPOPUP_START if ARIA menu appears.
 56292:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_START,
 60746:                                  node, AccEvent::eRemoveDupes);
 56292: 
 87094:     } else if (ariaRole == roles::ALERT) {
 56292:       // Fire EVENT_ALERT if ARIA alert appears.
 56292:       updateFlags = eAlertAccessible;
 56292:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_ALERT, node,
 60746:                                  AccEvent::eRemoveDupes);
 56292:     }
 56292: 
 56292:     // If focused node has been shown then it means its frame was recreated
 56292:     // while it's focused. Fire focus event on new focused accessible. If
 56292:     // the queue contains focus event for this node then it's suppressed by
 56292:     // this one.
 79384:     // XXX: do we really want to send focus to focused DOM node not taking into
 79384:     // account active item?
 79384:     if (FocusMgr()->IsFocused(aChild))
 79384:       FocusMgr()->DispatchFocusEvent(this, aChild);
 79384: 
 56292:   } else {
 56292:     // Update the tree for content removal.
 59274:     // The accessible parent may differ from container accessible if
 59274:     // the parent doesn't have own DOM node like list accessible for HTML
 59274:     // selects.
 99648:     Accessible* parent = aChild->Parent();
 59274:     NS_ASSERTION(parent, "No accessible parent?!");
 61732:     if (parent)
 67625:       parent->RemoveChild(aChild);
 59274: 
 67625:     UncacheChildrenInSubtree(aChild);
 56292:   }
 56292: 
 56292:   return updateFlags;
     1: }
 32285: 
 43504: void
 99648: DocAccessible::CacheChildrenInSubtree(Accessible* aRoot)
 60921: {
 60921:   aRoot->EnsureChildren();
 60921: 
 71381:   // Make sure we create accessible tree defined in DOM only, i.e. if accessible
 71381:   // provides specific tree (like XUL trees) then tree creation is handled by
 71381:   // this accessible.
108991:   uint32_t count = aRoot->ContentChildCount();
108991:   for (uint32_t idx = 0; idx < count; idx++) {
 99648:     Accessible* child = aRoot->ContentChildAt(idx);
 64002:     NS_ASSERTION(child, "Illicit tree change while tree is created!");
 60921:     // Don't cross document boundaries.
 64002:     if (child && child->IsContent())
 60921:       CacheChildrenInSubtree(child);
 60921:   }
101616: 
101616:   // Fire document load complete on ARIA documents.
101616:   // XXX: we should delay an event if the ARIA document has aria-busy.
101616:   if (aRoot->HasARIARole() && !aRoot->IsDoc()) {
101616:     a11y::role role = aRoot->ARIARole();
101616:     if (role == roles::DIALOG || role == roles::DOCUMENT)
101616:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE,
101616:                                  aRoot->GetContent());
101616:   }
 60921: }
 60921: 
 60921: void
 99648: DocAccessible::UncacheChildrenInSubtree(Accessible* aRoot)
 11165: {
101769:   aRoot->mFlags |= eIsNotInDocument;
101769: 
 62351:   if (aRoot->IsElement())
 62351:     RemoveDependentIDsFor(aRoot);
 62351: 
108991:   uint32_t count = aRoot->ContentChildCount();
108991:   for (uint32_t idx = 0; idx < count; idx++)
 71381:     UncacheChildrenInSubtree(aRoot->ContentChildAt(idx));
 11165: 
118792:   if (aRoot->IsNodeMapEntry() &&
 56292:       mNodeToAccessibleMap.Get(aRoot->GetNode()) == aRoot)
 56292:     mNodeToAccessibleMap.Remove(aRoot->GetNode());
 11165: }
 11165: 
 43504: void
 99648: DocAccessible::ShutdownChildrenInSubtree(Accessible* aAccessible)
     1: {
 56292:   // Traverse through children and shutdown them before this accessible. When
 56292:   // child gets shutdown then it removes itself from children array of its
 56292:   //parent. Use jdx index to process the cases if child is not attached to the
 56292:   // parent and as result doesn't remove itself from its children.
108991:   uint32_t count = aAccessible->ContentChildCount();
108991:   for (uint32_t idx = 0, jdx = 0; idx < count; idx++) {
 99648:     Accessible* child = aAccessible->ContentChildAt(jdx);
 56292:     if (!child->IsBoundToParent()) {
 56292:       NS_ERROR("Parent refers to a child, child doesn't refer to parent!");
 56292:       jdx++;
 10580:     }
 10580: 
 56292:     ShutdownChildrenInSubtree(child);
 10625:   }
  8231: 
 57413:   UnbindFromDocument(aAccessible);
  8231: }
 75013: 
 75013: bool
 99568: DocAccessible::IsLoadEventTarget() const
 75013: {
 75013:   nsCOMPtr<nsISupports> container = mDocument->GetContainer();
118473:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(container);
118473:   NS_ASSERTION(treeItem, "No document shell for document!");
 75013: 
 75013:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
118473:   treeItem->GetParent(getter_AddRefs(parentTreeItem));
 75013: 
118473:   // Not a root document.
118473:   if (parentTreeItem) {
118473:     // Return true if it's either:
118473:     // a) tab document;
118473:     nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
118473:     treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
118473:     if (parentTreeItem == rootTreeItem)
118473:       return true;
118473: 
118473:     // b) frame/iframe document and its parent document is not in loading state
100122:     // Note: we can get notifications while document is loading (and thus
100122:     // while there's no parent document yet).
100122:     DocAccessible* parentDoc = ParentDocument();
100122:     return parentDoc && parentDoc->HasLoadState(eCompletelyLoaded);
100122:   }
 75013: 
 99735:   // It's content (not chrome) root document.
108991:   int32_t contentType;
118473:   treeItem->GetItemType(&contentType);
 75013:   return (contentType == nsIDocShellTreeItem::typeContent);
 75013: }
 75013: 
