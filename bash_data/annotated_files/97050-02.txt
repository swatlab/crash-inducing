19963: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
19963:  * ***** BEGIN LICENSE BLOCK *****
19963:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19963:  *
19963:  * The contents of this file are subject to the Mozilla Public License Version
19963:  * 1.1 (the "License"); you may not use this file except in compliance with
19963:  * the License. You may obtain a copy of the License at
19963:  * http://www.mozilla.org/MPL/
19963:  *
19963:  * Software distributed under the License is distributed on an "AS IS" basis,
19963:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19963:  * for the specific language governing rights and limitations under the
19963:  * License.
19963:  *
19963:  * The Original Code is Mozilla Foundation code.
19963:  *
19963:  * The Initial Developer of the Original Code is Mozilla Foundation.
19963:  * Portions created by the Initial Developer are Copyright (C) 2008
19963:  * the Initial Developer. All Rights Reserved.
19963:  *
19963:  * Contributor(s):
19963:  *   John Daggett <jdaggett@mozilla.com>
19963:  *
19963:  * Alternatively, the contents of this file may be used under the terms of
19963:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19963:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19963:  * in which case the provisions of the GPL or the LGPL are applicable instead
19963:  * of those above. If you wish to allow use of your version of this file only
19963:  * under the terms of either the GPL or the LGPL, and not to allow others to
19963:  * use your version of this file under the terms of the MPL, indicate your
19963:  * decision by deleting the provisions above and replace them with the notice
19963:  * and other provisions required by the GPL or the LGPL. If you do not delete
19963:  * the provisions above, a recipient may use your version of this file under
19963:  * the terms of any one of the MPL, the GPL or the LGPL.
19963:  *
19963:  * ***** END LICENSE BLOCK ***** */
19963: 
19963: #ifndef GFX_USER_FONT_SET_H
19963: #define GFX_USER_FONT_SET_H
19963: 
19963: #include "gfxTypes.h"
19963: #include "gfxFont.h"
19963: #include "gfxFontUtils.h"
19963: #include "nsRefPtrHashtable.h"
19963: #include "nsAutoPtr.h"
19963: #include "nsCOMPtr.h"
19963: #include "nsIURI.h"
19963: #include "nsIFile.h"
40109: #include "nsISupportsImpl.h"
73711: #include "nsIScriptError.h"
19963: 
19963: class nsIURI;
19963: class gfxMixedFontFamily;
19963: 
19963: // parsed CSS @font-face rule information
19963: // lifetime: from when @font-face rule processed until font is loaded
19963: struct gfxFontFaceSrc {
79445:     bool                   mIsLocal;       // url or local
21983: 
21983:     // if url, whether to use the origin principal or not
79445:     bool                   mUseOriginPrincipal;
19963: 
19963:     // format hint flags, union of all possible formats
19963:     // (e.g. TrueType, EOT, SVG, etc.)
19963:     // see FLAG_FORMAT_* enum values below
19963:     PRUint32               mFormatFlags;
21983: 
21983:     nsString               mLocalName;     // full font name if local
21983:     nsCOMPtr<nsIURI>       mURI;           // uri if url 
21983:     nsCOMPtr<nsIURI>       mReferrer;      // referrer url if url
21983:     nsCOMPtr<nsISupports>  mOriginPrincipal; // principal if url 
21983:     
19963: };
19963: 
71911: // Subclassed to store platform-specific code cleaned out when font entry is
71911: // deleted.
71911: // Lifetime: from when platform font is created until it is deactivated.
71911: // If the platform does not need to add any platform-specific code/data here,
71911: // then the gfxUserFontSet will allocate a base gfxUserFontData and attach
71911: // to the entry to track the basic user font info fields here.
19963: class gfxUserFontData {
19963: public:
71911:     gfxUserFontData()
71911:         : mSrcIndex(0), mFormat(0), mMetaOrigLen(0)
71911:     { }
19963:     virtual ~gfxUserFontData() { }
71911: 
71911:     nsTArray<PRUint8> mMetadata;  // woff metadata block (compressed), if any
71911:     nsCOMPtr<nsIURI>  mURI;       // URI of the source, if it was url()
71911:     nsString          mLocalName; // font name used for the source, if local()
71914:     nsString          mRealName;  // original fullname from the font resource
71911:     PRUint32          mSrcIndex;  // index in the rule's source list
71911:     PRUint32          mFormat;    // format hint for the source used, if any
71911:     PRUint32          mMetaOrigLen; // length needed to decompress metadata
19963: };
19963: 
19963: // initially contains a set of proxy font entry objects, replaced with
19963: // platform/user fonts as downloaded
19963: 
19963: class gfxMixedFontFamily : public gfxFontFamily {
31590: public:
31590:     friend class gfxUserFontSet;
19963: 
19963:     gfxMixedFontFamily(const nsAString& aName)
31590:         : gfxFontFamily(aName) { }
19963: 
19963:     virtual ~gfxMixedFontFamily() { }
19963: 
75352:     void AddFontEntry(gfxFontEntry *aFontEntry) {
19963:         nsRefPtr<gfxFontEntry> fe = aFontEntry;
19963:         mAvailableFonts.AppendElement(fe);
68402:         aFontEntry->SetFamily(this);
90084:         ResetCharacterMap();
19963:     }
19963: 
90084:     void ReplaceFontEntry(gfxFontEntry *aOldFontEntry,
90084:                           gfxFontEntry *aNewFontEntry) {
19963:         PRUint32 numFonts = mAvailableFonts.Length();
19963:         for (PRUint32 i = 0; i < numFonts; i++) {
19963:             gfxFontEntry *fe = mAvailableFonts[i];
19963:             if (fe == aOldFontEntry) {
69466:                 aOldFontEntry->SetFamily(nsnull);
69466:                 // note that this may delete aOldFontEntry, if there's no
69466:                 // other reference to it except from its family
19963:                 mAvailableFonts[i] = aNewFontEntry;
68402:                 aNewFontEntry->SetFamily(this);
90084:                 break;
19963:             }
19963:         }
90084:         ResetCharacterMap();
19963:     }
19963: 
90084:     void RemoveFontEntry(gfxFontEntry *aFontEntry) {
19963:         PRUint32 numFonts = mAvailableFonts.Length();
19963:         for (PRUint32 i = 0; i < numFonts; i++) {
19963:             gfxFontEntry *fe = mAvailableFonts[i];
19963:             if (fe == aFontEntry) {
68402:                 aFontEntry->SetFamily(nsnull);
19963:                 mAvailableFonts.RemoveElementAt(i);
90084:                 break;
19963:             }
19963:         }
90084:         ResetCharacterMap();
19963:     }
19963: 
89331:     // clear family pointer for all entries and remove them from the family;
89331:     // we need to do this explicitly before inserting the entries into a new
89331:     // family, in case the old one is not actually deleted until later
89331:     void DetachFontEntries() {
89331:         PRUint32 i = mAvailableFonts.Length();
89331:         while (i--) {
89331:             gfxFontEntry *fe = mAvailableFonts[i];
89331:             if (fe) {
89331:                 fe->SetFamily(nsnull);
89331:             }
89331:         }
89331:         mAvailableFonts.Clear();
89331:     }
89331: 
19963:     // temp method to determine if all proxies are loaded
79445:     bool AllLoaded() 
19963:     {
19963:         PRUint32 numFonts = mAvailableFonts.Length();
19963:         for (PRUint32 i = 0; i < numFonts; i++) {
19963:             gfxFontEntry *fe = mAvailableFonts[i];
19963:             if (fe->mIsProxy)
80486:                 return false;
19963:         }
80486:         return true;
19963:     }
19963: };
19963: 
19963: class gfxProxyFontEntry;
19963: 
19963: class THEBES_API gfxUserFontSet {
19963: 
19963: public:
19963: 
40109:     NS_INLINE_DECL_REFCOUNTING(gfxUserFontSet)
19963: 
22722:     gfxUserFontSet();
19963:     virtual ~gfxUserFontSet();
19963: 
19963:     enum {
23576:         // no flags ==> no hint set
23576:         // unknown ==> unknown format hint set
23576:         FLAG_FORMAT_UNKNOWN        = 1,
23576:         FLAG_FORMAT_OPENTYPE       = 1 << 1,
23576:         FLAG_FORMAT_TRUETYPE       = 1 << 2,
23576:         FLAG_FORMAT_TRUETYPE_AAT   = 1 << 3,
23576:         FLAG_FORMAT_EOT            = 1 << 4,
23576:         FLAG_FORMAT_SVG            = 1 << 5,
32809:         FLAG_FORMAT_WOFF           = 1 << 6,
23576: 
23576:         // mask of all unused bits, update when adding new formats
32809:         FLAG_FORMAT_NOT_USED       = ~((1 << 7)-1)
19963:     };
19963: 
19963:     enum LoadStatus {
19963:         STATUS_LOADING = 0,
19963:         STATUS_LOADED,
19963:         STATUS_FORMAT_NOT_SUPPORTED,
19963:         STATUS_ERROR,
19963:         STATUS_END_OF_LIST
19963:     };
19963: 
19963: 
19963:     // add in a font face
19963:     // weight, stretch - 0 == unknown, [1, 9] otherwise
24407:     // italic style = constants in gfxFontConstants.h, e.g. NS_FONT_STYLE_NORMAL
19963:     // TODO: support for unicode ranges not yet implemented
68402:     gfxFontEntry *AddFontFace(const nsAString& aFamilyName,
19963:                               const nsTArray<gfxFontFaceSrc>& aFontFaceSrcList,
47360:                               PRUint32 aWeight,
47360:                               PRUint32 aStretch,
47360:                               PRUint32 aItalicStyle,
96986:                               const nsTArray<gfxFontFeature>& aFeatureSettings,
47360:                               const nsString& aLanguageOverride,
19963:                               gfxSparseBitSet *aUnicodeRanges = nsnull);
19963: 
68402:     // add in a font face for which we have the gfxFontEntry already
68402:     void AddFontFace(const nsAString& aFamilyName, gfxFontEntry* aFontEntry);
68402: 
22397:     // Whether there is a face with this family name
79445:     bool HasFamily(const nsAString& aFamilyName) const
22397:     {
22397:         return GetFamily(aFamilyName) != nsnull;
22397:     }
22397: 
19963:     // lookup a font entry for a given style, returns null if not loaded
19963:     gfxFontEntry *FindFontEntry(const nsAString& aName,
22722:                                 const gfxFontStyle& aFontStyle,
79445:                                 bool& aFoundFamily,
79445:                                 bool& aNeedsBold,
79445:                                 bool& aWaitForUserFont);
22722:                                 
22722:     // initialize the process that loads external font data, which upon 
22722:     // completion will call OnLoadComplete method
69055:     virtual nsresult StartLoad(gfxProxyFontEntry *aProxy, 
22722:                                const gfxFontFaceSrc *aFontFaceSrc) = 0;
19963: 
19963:     // when download has been completed, pass back data here
19963:     // aDownloadStatus == NS_OK ==> download succeeded, error otherwise
19963:     // returns true if platform font creation sucessful (or local()
19963:     // reference was next in line)
32808:     // Ownership of aFontData is passed in here; the font set must
32808:     // ensure that it is eventually deleted with NS_Free().
79445:     bool OnLoadComplete(gfxProxyFontEntry *aProxy,
21067:                           const PRUint8 *aFontData, PRUint32 aLength,
19963:                           nsresult aDownloadStatus);
19963: 
68402:     // Replace a proxy with a real fontEntry; this is implemented in
68402:     // nsUserFontSet in order to keep track of the entry corresponding
68402:     // to each @font-face rule.
68402:     virtual void ReplaceFontEntry(gfxProxyFontEntry *aProxy,
68402:                                   gfxFontEntry *aFontEntry) = 0;
68402: 
19963:     // generation - each time a face is loaded, generation is
19963:     // incremented so that the change can be recognized 
19963:     PRUint64 GetGeneration() { return mGeneration; }
19963: 
62296:     // increment the generation on font load
62296:     void IncrementGeneration();
62296: 
19963: protected:
19963:     // for a given proxy font entry, attempt to load the next resource
19963:     // in the src list
19963:     LoadStatus LoadNext(gfxProxyFontEntry *aProxyEntry);
19963: 
93305:     // helper method for creating a platform font
93305:     // returns font entry if platform font creation successful
93305:     // Ownership of aFontData is passed in here; the font set must
93305:     // ensure that it is eventually deleted with NS_Free().
93305:     gfxFontEntry* LoadFont(gfxProxyFontEntry *aProxy,
93308:                            const PRUint8 *aFontData, PRUint32 &aLength);
93305: 
93305:     // parse data for a data URL
93305:     virtual nsresult SyncLoadFontData(gfxProxyFontEntry *aFontToLoad,
93305:                                       const gfxFontFaceSrc *aFontFaceSrc,
93305:                                       PRUint8* &aBuffer,
93305:                                       PRUint32 &aBufferLength)
93305:     {
93305:         // implemented in nsUserFontSet
93305:         return NS_ERROR_NOT_IMPLEMENTED;
93305:     }
93305: 
22397:     gfxMixedFontFamily *GetFamily(const nsAString& aName) const;
22397: 
73711:     // report a problem of some kind (implemented in nsUserFontSet)
73711:     virtual nsresult LogMessage(gfxProxyFontEntry *aProxy,
73711:                                 const char *aMessage,
73711:                                 PRUint32 aFlags = nsIScriptError::errorFlag,
73711:                                 nsresult aStatus = 0) = 0;
73711: 
19963:     // font families defined by @font-face rules
19963:     nsRefPtrHashtable<nsStringHashKey, gfxMixedFontFamily> mFontFamilies;
19963: 
19963:     PRUint64        mGeneration;
73711: 
73711:     static PRLogModuleInfo *sUserFontsLog;
91674: 
91674: private:
91674:     static void CopyWOFFMetadata(const PRUint8* aFontData,
91674:                                  PRUint32 aLength,
91674:                                  nsTArray<PRUint8>* aMetadata,
91674:                                  PRUint32* aMetaOrigLen);
19963: };
19963: 
19963: // acts a placeholder until the real font is downloaded
19963: 
19963: class gfxProxyFontEntry : public gfxFontEntry {
31590:     friend class gfxUserFontSet;
19963: 
19963: public:
19963:     gfxProxyFontEntry(const nsTArray<gfxFontFaceSrc>& aFontFaceSrcList,
22397:                       gfxMixedFontFamily *aFamily,
19963:                       PRUint32 aWeight,
19963:                       PRUint32 aStretch,
19963:                       PRUint32 aItalicStyle,
58968:                       const nsTArray<gfxFontFeature>& aFeatureSettings,
47360:                       PRUint32 aLanguageOverride,
19963:                       gfxSparseBitSet *aUnicodeRanges);
19963: 
19963:     virtual ~gfxProxyFontEntry();
19963: 
79445:     virtual gfxFont *CreateFontInstance(const gfxFontStyle *aFontStyle, bool aNeedsBold);
37211: 
62296:     // note that code depends on the ordering of these values!
62296:     enum LoadingState {
62296:         NOT_LOADING = 0,     // not started to load any font resources yet
62296:         LOADING_STARTED,     // loading has started; hide fallback font
62296:         LOADING_ALMOST_DONE, // timeout happened but we're nearly done,
62296:                              // so keep hiding fallback font
63802:         LOADING_SLOWLY,      // timeout happened and we're not nearly done,
62296:                              // so use the fallback font
63802:         LOADING_FAILED       // failed to load any source: use fallback
62296:     };
62296:     LoadingState             mLoadingState;
86676:     bool                     mUnsupportedFormat;
62296: 
19963:     nsTArray<gfxFontFaceSrc> mSrcList;
19963:     PRUint32                 mSrcIndex; // index of loading src item
19963: };
19963: 
19963: 
19963: #endif /* GFX_USER_FONT_SET_H */
