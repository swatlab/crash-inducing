     1: /* vim: set sw=2 sts=2 et cin: */
 38942: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 38942:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 38942: 
 38942: //=============================================================================
 38942: /*
 38942:  *  This file is divided into the following major sections:
 38942:  *
 38942:  *  - Macros
 38942:  *  - Variables & Forward declarations
 38942:  *  - nsWindow Create / Destroy
 38942:  *  - Standard Window Operations
 38942:  *  - Window Positioning
 38942:  *  - Plugin Operations
 38942:  *  - Top-level (frame window) Operations
 38942:  *  - Mouse Pointers
 38942:  *  - Rollup Event Handlers
 38942:  *  - nsWindow's Window Procedure
 38942:  *  - Window Message Handlers
 38942:  *  - Drag & Drop - Target methods
 38942:  *  - Keyboard Handlers
103599:  *  - IME
 38942:  *  - Event Dispatch
 38942:  *
 38942:  */
 38942: //=============================================================================
     1: 
     1: #include "nsWindow.h"
 39028: #include "os2FrameWindow.h"
 38942: #include "gfxContext.h"
 38942: #include "gfxOS2Surface.h"
 38942: #include "imgIContainer.h"
 38942: #include "npapi.h"
 38942: #include "nsDragService.h"
 38942: #include "nsGfxCIID.h"
 38942: #include "nsHashKeys.h"
 38942: #include "nsIRollupListener.h"
     1: #include "nsIScreenManager.h"
 38942: #include "nsOS2Uni.h"
 38942: #include "nsTHashtable.h"
 80435: #include "nsGkAtoms.h"
     1: #include "wdgtos2rc.h"
108074: #include "nsIDOMWheelEvent.h"
 71384: #include "mozilla/Preferences.h"
103599: #include <os2im.h>
 71384: 
 71384: using namespace mozilla;
108074: using namespace mozilla::widget;
108074: 
 38942: //=============================================================================
 38942: //  Macros
 38942: //=============================================================================
 38942: 
 38942: // Drag and Drop
 38942: 
 38942: // d&d flags - actions that might cause problems during d&d
     1: #define ACTION_PAINT    1
     1: #define ACTION_DRAW     2
     1: #define ACTION_SCROLL   3
     1: #define ACTION_SHOW     4
     1: #define ACTION_PTRPOS   5
     1: 
 38942: // d&d status - shorten these references a bit
     1: #define DND_None                (nsIDragSessionOS2::DND_NONE)
     1: #define DND_NativeDrag          (nsIDragSessionOS2::DND_NATIVEDRAG)
     1: #define DND_MozDrag             (nsIDragSessionOS2::DND_MOZDRAG)
     1: #define DND_InDrop              (nsIDragSessionOS2::DND_INDROP)
     1: #define DND_DragStatus          (nsIDragSessionOS2::DND_DRAGSTATUS)
     1: #define DND_DispatchEnterEvent  (nsIDragSessionOS2::DND_DISPATCHENTEREVENT)
     1: #define DND_DispatchEvent       (nsIDragSessionOS2::DND_DISPATCHEVENT)
     1: #define DND_GetDragoverResult   (nsIDragSessionOS2::DND_GETDRAGOVERRESULT)
     1: #define DND_ExitSession         (nsIDragSessionOS2::DND_EXITSESSION)
     1: 
 38942: //-----------------------------------------------------------------------------
     1: // App Command messages for IntelliMouse and Natural Keyboard Pro
 38942: 
     1: #define WM_APPCOMMAND                   0x0319
     1: 
     1: #define APPCOMMAND_BROWSER_BACKWARD     1
     1: #define APPCOMMAND_BROWSER_FORWARD      2
     1: #define APPCOMMAND_BROWSER_REFRESH      3
     1: #define APPCOMMAND_BROWSER_STOP         4
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: // Keyboard-related macros
 38942: 
 38942: // Used for character-to-keycode translation
 38942: #define PMSCAN_PADMULT      0x37
 38942: #define PMSCAN_PAD7         0x47
 38942: #define PMSCAN_PAD8         0x48
 38942: #define PMSCAN_PAD9         0x49
 38942: #define PMSCAN_PADMINUS     0x4A
 38942: #define PMSCAN_PAD4         0x4B
 38942: #define PMSCAN_PAD5         0x4C
 38942: #define PMSCAN_PAD6         0x4D
 38942: #define PMSCAN_PADPLUS      0x4E
 38942: #define PMSCAN_PAD1         0x4F
 38942: #define PMSCAN_PAD2         0x50
 38942: #define PMSCAN_PAD3         0x51
 38942: #define PMSCAN_PAD0         0x52
 38942: #define PMSCAN_PADPERIOD    0x53
 38942: #define PMSCAN_PADDIV       0x5c
 38942: 
 38942: #define isNumPadScanCode(scanCode) !((scanCode < PMSCAN_PAD7) ||      \
 38942:                                      (scanCode > PMSCAN_PADPERIOD) || \
 38942:                                      (scanCode == PMSCAN_PADMULT) ||  \
 38942:                                      (scanCode == PMSCAN_PADDIV) ||   \
 38942:                                      (scanCode == PMSCAN_PADMINUS) || \
 38942:                                      (scanCode == PMSCAN_PADPLUS))
 38942: 
 38942: #define isNumlockOn     (WinGetKeyState(HWND_DESKTOP, VK_NUMLOCK) & 0x0001)
 38942: #define isKeyDown(vk)   ((WinGetKeyState(HWND_DESKTOP,vk) & 0x8000) == 0x8000)
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Miscellanea
 38942: 
 38942: // extract X & Y from a mouse msg mparam
 38942: #define XFROMMP(m)      (SHORT(LOUSHORT(m)))
 38942: #define YFROMMP(m)      (SHORT(HIUSHORT(m)))
 38942: 
 38942: // make these methods seem more appropriate in context
 38942: #define PM2NS_PARENT NS2PM_PARENT
 38942: #define PM2NS NS2PM
     1: 
 33769: // used to identify plugin widgets (copied from nsPluginNativeWindowOS2.cpp)
 38942: #define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION \
 38942:                         "MozillaPluginWindowPropertyAssociation"
 38942: 
 38942: // name of the window class used to clip plugins
 38942: #define kClipWndClass   "nsClipWnd"
 38942: 
 39028: //-----------------------------------------------------------------------------
 39028: // Debug
 39028: 
 39028: #ifdef DEBUG_FOCUS
 39028:   #define DEBUGFOCUS(what) fprintf(stderr, "[%8x]  %8lx  (%02d)  "#what"\n", \
 39028:                                    (int)this, mWnd, mWindowIdentifier)
 39028: #else
 39028:   #define DEBUGFOCUS(what)
 39028: #endif
 39028: 
 38942: //=============================================================================
 38942: //  Variables & Forward declarations
 38942: //=============================================================================
 38942: 
 38942: // Miscellaneous global flags
108991: uint32_t            gOS2Flags = 0;
 38942: 
 38942: // Mouse pointers
 38942: static HPOINTER     sPtrArray[IDC_COUNT];
 38942: 
 38942: // location of last MB1 down - used for mouse-based copy/paste
 38942: static POINTS       sLastButton1Down = {0,0};
 38942: 
 38942: // set when any nsWindow is being dragged over
108991: static uint32_t     sDragStatus = 0;
 38942: 
 38942: #ifdef DEBUG_FOCUS
 38942:   int currentWindowIdentifier = 0;
 38942: #endif
103599: // IME stuffs
103599: static HMODULE sIm32Mod = NULLHANDLE;
103599: static APIRET (APIENTRY *spfnImGetInstance)(HWND, PHIMI);
103599: static APIRET (APIENTRY *spfnImReleaseInstance)(HWND, HIMI);
103599: static APIRET (APIENTRY *spfnImGetConversionString)(HIMI, ULONG, PVOID,
103599:                                                     PULONG);
103599: static APIRET (APIENTRY *spfnImGetResultString)(HIMI, ULONG, PVOID, PULONG);
103599: static APIRET (APIENTRY *spfnImRequestIME)(HIMI, ULONG, ULONG, ULONG);
 38942: 
 38942: //-----------------------------------------------------------------------------
108991: static uint32_t     WMChar2KeyCode(MPARAM mp1, MPARAM mp2);
 38942: 
 38942: //=============================================================================
 38942: //  nsWindow Create / Destroy
 38942: //=============================================================================
 38942: 
     1: nsWindow::nsWindow() : nsBaseWidget()
     1: {
     1:   mWnd                = 0;
     1:   mParent             = 0;
 39028:   mFrame              = 0;
 39028:   mWindowType         = eWindowType_toplevel;
     1:   mBorderStyle        = eBorderStyle_default;
 38942:   mWindowState        = nsWindowState_ePrecreate;
 80486:   mOnDestroyCalled    = false;
 80486:   mIsDestroying       = false;
 80486:   mInSetFocus         = false;
 80486:   mNoPaint            = false;
     1:   mDragHps            = 0;
     1:   mDragStatus         = 0;
 38942:   mClipWnd            = 0;
     1:   mCssCursorHPtr      = 0;
 38942:   mThebesSurface      = 0;
103599:   mIsComposing        = false;
 38942:   if (!gOS2Flags) {
 38942:     InitGlobals();
 38942:   }
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
     1: nsWindow::~nsWindow()
     1: {
     1:   // How destruction works: A call of Destroy() destroys the PM window.  This
     1:   // triggers an OnDestroy(), which frees resources.  If not Destroy'd at
     1:   // delete time, Destroy() gets called anyway.
     1: 
     1:   // NOTE: Calling virtual functions from destructors is bad; they always
     1:   //       bind in the current object (ie. as if they weren't virtual).  It
     1:   //       may even be illegal to call them from here.
 38942: 
 80486:   mIsDestroying = true;
     1: 
     1:   if (mCssCursorHPtr) {
     1:     WinDestroyPointer(mCssCursorHPtr);
     1:     mCssCursorHPtr = 0;
     1:   }
     1: 
 38942:   // If the widget was released without calling Destroy() then
 38942:   // the native window still exists, and we need to destroy it
 38942:   if (!(mWindowState & nsWindowState_eDead)) {
     1:     mWindowState |= nsWindowState_eDoingDelete;
     1:     mWindowState &= ~(nsWindowState_eLive | nsWindowState_ePrecreate |
     1:                       nsWindowState_eInCreate);
     1:     Destroy();
     1:   }
 39028: 
 41167:   // Once a plugin window has been destroyed,
 41167:   // its parent, the clipping window, can be destroyed.
 41167:   if (mClipWnd) {
 41167:     WinDestroyWindow(mClipWnd);
 41167:     mClipWnd = 0;
 41167:   }
 41167:  
 39028:   // If it exists, destroy our os2FrameWindow helper object.
 39028:   if (mFrame) {
 39028:     delete mFrame;
 39028:     mFrame = 0;
 39028:   }
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Init Module-level variables.
 38942: 
 38942: // static
 38942: void nsWindow::InitGlobals()
 38942: {
 38942:   gOS2Flags = kIsInitialized;
 38942: 
 38942:   // Register the MozillaWindowClass with PM.
 38942:   WinRegisterClass(0, kWindowClassName, fnwpNSWindow, 0, 8);
 38942: 
 38942:   // Register the dummy window class used to clip plugins.
 38942:   WinRegisterClass(0, kClipWndClass, WinDefWindowProc, 0, 4);
 38942: 
 38942:   // Load the mouse pointers from the dll containing 'gOS2Flags'.
 38942:   HMODULE hModResources = 0;
 38942:   DosQueryModFromEIP(&hModResources, 0, 0, 0, 0, (ULONG)&gOS2Flags);
 38942:   for (int i = 0; i < IDC_COUNT; i++) {
 38942:     sPtrArray[i] = WinLoadPointer(HWND_DESKTOP, hModResources, IDC_BASE+i);
 38942:   }
 38942: 
 38942:   // Work out if the system is DBCS.
 38942:   char buffer[16];
 38942:   COUNTRYCODE cc = { 0 };
 38942:   DosQueryDBCSEnv(sizeof(buffer), &cc, buffer);
 38942:   if (buffer[0] || buffer[1]) {
 38942:     gOS2Flags |= kIsDBCS;
 38942:   }
 38942: 
 38942:   // This is ugly. The Thinkpad TrackPoint driver checks to see whether
 38942:   // or not a window actually has a scroll bar as a child before sending
 38942:   // it scroll messages. Needless to say, no Mozilla window has real scroll
 38942:   // bars. So if you have the "os2.trackpoint" preference set, we put an
 38942:   // invisible scroll bar on every child window so we can scroll.
 79445:   if (Preferences::GetBool("os2.trackpoint", false)) {
 38942:     gOS2Flags |= kIsTrackPoint;
 38942:   }
103599: 
103599:   InitIME();
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
103599: // Determine whether to use IME
103599: static
103599: void InitIME()
103599: {
103599:   if (!getenv("MOZ_IME_OVERTHESPOT")) {
103599:     CHAR szName[CCHMAXPATH];
103599:     ULONG rc;
103599: 
103599:     rc = DosLoadModule(szName, sizeof(szName), "os2im", &sIm32Mod);
103599: 
103599:     if (!rc)
103599:       rc = DosQueryProcAddr(sIm32Mod, 104, NULL,
103599:                             (PFN *)&spfnImGetInstance);
103599: 
103599:     if (!rc)
103599:       rc = DosQueryProcAddr(sIm32Mod, 106, NULL,
103599:                             (PFN *)&spfnImReleaseInstance);
103599: 
103599:     if (!rc)
103599:       rc = DosQueryProcAddr(sIm32Mod, 118, NULL,
103599:                             (PFN *)&spfnImGetConversionString);
103599: 
103599:     if (!rc)
103599:       rc = DosQueryProcAddr(sIm32Mod, 122, NULL,
103599:                             (PFN *)&spfnImGetResultString);
103599: 
103599:     if (!rc)
103599:       rc = DosQueryProcAddr(sIm32Mod, 131, NULL,
103599:                             (PFN *)&spfnImRequestIME);
103599: 
103599:     if (rc) {
103599:       DosFreeModule(sIm32Mod);
103599: 
103599:       sIm32Mod = NULLHANDLE;
103599:     }
103599:   }
103599: }
103599: //-----------------------------------------------------------------------------
 38942: // Release Module-level variables.
 38942: 
 38942: // static
 38942: void nsWindow::ReleaseGlobals()
     1: {
     1:   for (int i = 0; i < IDC_COUNT; i++) {
 38942:     WinDestroyPointer(sPtrArray[i]);
 38942:   }
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 39028: // Init an nsWindow & create the appropriate native window.
 38942: 
     1: NS_METHOD nsWindow::Create(nsIWidget* aParent,
 33013:                            nsNativeWidget aNativeParent,
 23850:                            const nsIntRect& aRect,
     1:                            EVENT_CALLBACK aHandleEventFunction,
 68668:                            nsDeviceContext* aContext,
     1:                            nsWidgetInitData* aInitData)
     1: {
 38942:   mWindowState = nsWindowState_eInCreate;
 38942: 
 38942:   // Identify the parent's nsWindow & native window.  Only one of these
 38942:   // should be supplied.  Note:  only nsWindow saves pParent as mParent;
 39028:   // os2FrameWindow discards it since toplevel widgets have no parent.
 38942:   HWND      hParent;
 33768:   nsWindow* pParent;
 33768:   if (aParent) {
 38942:     hParent = (HWND)aParent->GetNativeData(NS_NATIVE_WINDOW);
 33768:     pParent = (nsWindow*)aParent;
 33768:   } else {
 33768:     if (aNativeParent && (HWND)aNativeParent != HWND_DESKTOP) {
 38942:       hParent = (HWND)aNativeParent;
 38942:       pParent = GetNSWindowPtr(hParent);
 33768:     } else {
 38942:       hParent = HWND_DESKTOP;
 33768:       pParent = 0;
 33768:     }
 33013:   }
 33013: 
 80842:   BaseCreate(aParent, aRect, aHandleEventFunction, aContext, aInitData);
 38942: 
 38942: #ifdef DEBUG_FOCUS
 38942:   mWindowIdentifier = currentWindowIdentifier;
 38942:   currentWindowIdentifier++;
 38942: #endif
 38942: 
 39028:   // Some basic initialization.
 39028:   if (aInitData) {
 51174:     // Suppress creation of a Thebes surface for windows that will never
 51174:     // be painted because they're always covered by another window.
 51174:     if (mWindowType == eWindowType_toplevel ||
 54355:         mWindowType == eWindowType_invisible) {
 80486:       mNoPaint = true;
 51174:     }
 55811:     // Popup windows should not have an nsWindow parent.
 55811:     else if (mWindowType == eWindowType_popup) {
 55811:       pParent = 0;
 55811:     }
 39028:   }
 39028: 
 39028:   // For toplevel windows, create an instance of our helper class,
 39028:   // then have it create a frame & client window;  otherwise,
 39028:   // call our own CreateWindow() method to create a child window.
 39028:   if (mWindowType == eWindowType_toplevel ||
 39028:       mWindowType == eWindowType_dialog   ||
 39028:       mWindowType == eWindowType_invisible) {
 39028:     mFrame = new os2FrameWindow(this);
 39028:     NS_ENSURE_TRUE(mFrame, NS_ERROR_FAILURE);
 39028:     mWnd = mFrame->CreateFrameWindow(pParent, hParent, aRect,
 39028:                                      mWindowType, mBorderStyle);
 39028:     NS_ENSURE_TRUE(mWnd, NS_ERROR_FAILURE);
 39028:   } else {
 39028:     nsresult rv = CreateWindow(pParent, hParent, aRect, aInitData);
 38942:     NS_ENSURE_SUCCESS(rv, rv);
 39028:   }
 39028: 
 39028:   // Store a pointer to this object in the window's extra bytes.
 38942:   SetNSWindowPtr(mWnd, this);
 38942: 
 38942:   // Finalize the widget creation process.
 80486:   nsGUIEvent event(true, NS_CREATE, this);
 38942:   InitEvent(event);
 38942:   DispatchWindowEvent(&event);
 38942: 
 38942:   mWindowState = nsWindowState_eLive;
 39028:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Create a native window for an nsWindow object.
 38942: 
 38942: nsresult nsWindow::CreateWindow(nsWindow* aParent,
 38942:                                 HWND aParentWnd,
 38942:                                 const nsIntRect& aRect,
 39028:                                 nsWidgetInitData* aInitData)
 38942: {
 38942:   // For pop-ups, the Desktop is the parent and aParentWnd is the owner.
 38942:   HWND hOwner = 0;
 38942:   if (mWindowType == eWindowType_popup && aParentWnd != HWND_DESKTOP) {
 38942:     hOwner = aParentWnd;
 38942:     aParentWnd = HWND_DESKTOP;
 38942:   }
 38942: 
 39028:   // While we comply with the clipSiblings flag, we always set
 39028:   // clipChildren regardless of the flag for performance reasons.
108991:   uint32_t style = WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
 39028:   if (aInitData && !aInitData->clipSiblings) {
 39028:     style &= ~WS_CLIPSIBLINGS;
 39028:   }
 39028: 
 38942:   // Create the window hidden;  it will be resized below.
 38942:   mWnd = WinCreateWindow(aParentWnd,
 38942:                          kWindowClassName,
 38942:                          0,
 39028:                          style,
 38942:                          0, 0, 0, 0,
 38942:                          hOwner,
 38942:                          HWND_TOP,
 38942:                          0,
 38942:                          0, 0);
 38942:   NS_ENSURE_TRUE(mWnd, NS_ERROR_FAILURE);
 38942: 
 38942:   // If a TrackPoint is in use, create dummy scrollbars.
 38942:   // XXX  Popups may need this also to scroll comboboxes.
 38942:   if ((gOS2Flags & kIsTrackPoint) && mWindowType == eWindowType_child) {
 38942:     WinCreateWindow(mWnd, WC_SCROLLBAR, 0, SBS_VERT,
 38942:                     0, 0, 0, 0, mWnd, HWND_TOP,
 38942:                     FID_VERTSCROLL, 0, 0);
 38942:   }
 38942: 
 38942:   // Store the window's dimensions, then resize accordingly.
 38942:   mBounds = aRect;
 38942:   nsIntRect parRect;
 38942:   if (aParent) {
 38942:     aParent->GetBounds(parRect);
 38942:   } else {
 38942:     parRect.height = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
 38942:   }
 38942:   WinSetWindowPos(mWnd, 0,
 38942:                   aRect.x, parRect.height - aRect.y - aRect.height,
 38942:                   aRect.width, aRect.height, SWP_SIZE | SWP_MOVE);
 38942: 
 38942:   // Store the widget's parent and add it to the parent's list of children.
 38942:   // Don't ADDREF mParent because AddChild() ADDREFs us.
 38942:   mParent = aParent;
 38942:   if (mParent) {
 38942:     mParent->AddChild(this);
 38942:   }
 38942: 
 38942:   DEBUGFOCUS(Create nsWindow);
     1:   return NS_OK;
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: // Close this nsWindow.
 38942: 
     1: NS_METHOD nsWindow::Destroy()
     1: {
     1:   // avoid calling into other objects if we're being deleted, 'cos
     1:   // they must have no references to us.
     1:   if ((mWindowState & nsWindowState_eLive) && mParent) {
     1:     nsBaseWidget::Destroy();
     1:   }
     1: 
     1:   // just to be safe. If we're going away and for some reason we're still
     1:   // the rollup widget, rollup and turn off capture.
120177:   nsIRollupListener* rollupListener = GetActiveRollupListener();
123327:   nsCOMPtr<nsIWidget> rollupWidget;
123327:   if (rollupListener) {
123327:     rollupWidget = rollupListener->GetRollupWidget();
123327:   }
120177:   if (this == rollupWidget) {
120177:     rollupListener->Rollup(UINT32_MAX);
106838:     CaptureRollupEvents(nullptr, false, true);
     1:   }
     1: 
 39028:   HWND hMain = GetMainWindow();
 38942:   if (hMain) {
 38942:     DEBUGFOCUS(Destroy);
 38942:     if (hMain == WinQueryFocus(HWND_DESKTOP)) {
 38942:       WinSetFocus(HWND_DESKTOP, WinQueryWindow(hMain, QW_PARENT));
 38942:     }
 38942:     WinDestroyWindow(hMain);
 38942:   }
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Standard Window Operations
 38942: //=============================================================================
 38942: 
 39028: // This can't be inlined in nsWindow.h because it doesn't know about
 39028: // GetFrameWnd().
 39028: 
 39028: inline HWND nsWindow::GetMainWindow()
 39028: {
 39028:   return mFrame ? mFrame->GetFrameWnd() : mWnd;
 39028: }
 39028: 
 39028: //-----------------------------------------------------------------------------
 39028: // Inline this here for consistency (and a cleaner looking .h).
 39028: 
 38942: // static
 39028: inline nsWindow* nsWindow::GetNSWindowPtr(HWND aWnd)
 38942: {
 38942:   return (nsWindow*)WinQueryWindowPtr(aWnd, QWL_NSWINDOWPTR);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 38942: // static
 79445: inline bool nsWindow::SetNSWindowPtr(HWND aWnd, nsWindow* aPtr)
 38942: {
 38942:   return WinSetWindowPtr(aWnd, QWL_NSWINDOWPTR, aPtr);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 38942: nsIWidget* nsWindow::GetParent()
 38942: {
 38942:   // if this window isn't supposed to have a parent or it doesn't have
 38942:   // a parent, or if it or its parent is being destroyed, return null
 39028:   if (mFrame || mIsDestroying || mOnDestroyCalled ||
 38942:       !mParent || mParent->mIsDestroying) {
 38942:     return 0;
 38942:   }
 38942: 
 38942:   return mParent;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: NS_METHOD nsWindow::Enable(bool aState)
 38942: {
 38942:   HWND hMain = GetMainWindow();
 38942:   if (hMain) {
 38942:     WinEnableWindow(hMain, aState);
 38942:   }
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
106103: bool nsWindow::IsEnabled() const
 38942: {
 38942:   HWND hMain = GetMainWindow();
106103:   return !hMain || WinIsWindowEnabled(hMain);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: NS_METHOD nsWindow::Show(bool aState)
 38942: {
 39028:   if (mFrame) {
 39028:     return mFrame->Show(aState);
 39028:   }
     1:   if (mWnd) {
 38942:     if (aState) {
     1:       // don't try to show new windows (e.g. the Bookmark menu)
     1:       // during a native dragover because they'll remain invisible;
 13220:       if (CheckDragStatus(ACTION_SHOW, 0)) {
105772:         if (!IsVisible()) {
 80486:           PlaceBehind(eZPlacementTop, 0, false);
 38942:         }
 80486:         WinShowWindow(mWnd, true);
 13220:       }
 13220:     } else {
 80486:       WinShowWindow(mWnd, false);
 13220:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: 
105772: bool nsWindow::IsVisible() const
     1: {
105772:   return WinIsWindowVisible(GetMainWindow());
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: NS_METHOD nsWindow::SetFocus(bool aRaise)
     1: {
 38942:   // for toplevel windows, this is directed to the client (i.e. mWnd)
     1:   if (mWnd) {
     1:     if (!mInSetFocus) {
     1:       DEBUGFOCUS(SetFocus);
 80486:       mInSetFocus = true;
     1:       WinSetFocus(HWND_DESKTOP, mWnd);
 80486:       mInSetFocus = false;
 38942:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 87336: NS_METHOD nsWindow::Invalidate(const nsIntRect& aRect)
     1: {
     1:   if (mWnd) {
     1:     RECTL rcl = {aRect.x, aRect.y, aRect.x + aRect.width, aRect.y + aRect.height};
     1:     NS2PM(rcl);
 80486:     WinInvalidateRect(mWnd, &rcl, false);
 38942:   }
     1:   return NS_OK;
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: // Create a Thebes surface using the current window handle.
 38942: 
 38942: gfxASurface* nsWindow::GetThebesSurface()
 38942: {
 38942:   if (mWnd && !mThebesSurface) {
 38942:     mThebesSurface = new gfxOS2Surface(mWnd);
 38942:   }
 38942:   return mThebesSurface;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 51174: // Internal-only method that suppresses creation of a Thebes surface
 51174: // for windows that aren't supposed to be visible.  If one was created
 51174: // by an external call to GetThebesSurface(), it will be returned.
 51174: 
 51174: gfxASurface* nsWindow::ConfirmThebesSurface()
 51174: {
 51174:   if (!mThebesSurface && !mNoPaint && mWnd) {
 51174:     mThebesSurface = new gfxOS2Surface(mWnd);
 51174:   }
 51174:   return mThebesSurface;
 51174: }
 51174: 
 51174: //-----------------------------------------------------------------------------
 55811: 
 55811: float nsWindow::GetDPI()
 55811: {
108991:   static int32_t sDPI = 0;
 55811: 
 55811:   // Create DC compatible with the screen, then query the DPI setting.
 55811:   // If this fails, fall back to something sensible.
 55811:   if (!sDPI) {
 55811:     HDC dc = DevOpenDC(0, OD_MEMORY,"*",0L, 0, 0);
 55811:     if (dc > 0) {
 55811:       LONG lDPI;
 55811:       if (DevQueryCaps(dc, CAPS_VERTICAL_FONT_RES, 1, &lDPI))
 55811:         sDPI = lDPI;
 55811:       DevCloseDC(dc);
 55811:     }
 55811:     if (sDPI <= 0) {
 55811:       sDPI = 96;
 55811:     }
 55811:   }
 55811:   return sDPI;  
 55811: }
 55811: 
 55811: //-----------------------------------------------------------------------------
 38942: // Return some native data according to aDataType.
 38942: 
108991: void* nsWindow::GetNativeData(uint32_t aDataType)
     1: {
     1:   switch(aDataType) {
     1:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_WINDOW:
     1:     case NS_NATIVE_PLUGIN_PORT:
     1:       return (void*)mWnd;
     1: 
     1:     // during a native drag over the current window or any drag
     1:     // originating in Moz, return a drag HPS to avoid screen corruption;
 38942:     case NS_NATIVE_GRAPHIC: {
     1:       HPS hps = 0;
     1:       CheckDragStatus(ACTION_DRAW, &hps);
 38942:       if (!hps) {
     1:         hps = WinGetPS(mWnd);
 38942:       }
     1:       return (void*)hps;
     1:     }
 38942:   }
 38942: 
 38942:   return 0;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
     1: 
108991: void nsWindow::FreeNativeData(void* data, uint32_t aDataType)
     1: {
 38942:   // an HPS is the only native data that needs to be freed
 38942:   if (aDataType == NS_NATIVE_GRAPHIC &&
 38942:       data &&
 38942:       !ReleaseIfDragHPS((HPS)data)) {
 38942:     WinReleasePS((HPS)data);
 38942:   }
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: NS_METHOD nsWindow::CaptureMouse(bool aCapture)
     1: {
 38942:   if (aCapture) {
 38942:     WinSetCapture(HWND_DESKTOP, mWnd);
 38942:   } else {
 38942:     WinSetCapture(HWND_DESKTOP, 0);
 38942:   }
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: bool nsWindow::HasPendingInputEvent()
 14309: {
 38942:   return (WinQueryQueueStatus(HWND_DESKTOP) & (QS_KEY | QS_MOUSE)) != 0;
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Window Positioning
 38942: //=============================================================================
 38942: 
 39028: // For toplevel windows, mBounds contains the dimensions of the client
 39028: // window.  os2FrameWindow's "override" returns the size of the frame.
 39028: 
 38942: NS_METHOD nsWindow::GetBounds(nsIntRect& aRect)
     1: {
 39028:   if (mFrame) {
 39028:     return mFrame->GetBounds(aRect);
 39028:   }
 38942:   aRect = mBounds;
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 39028: // Since mBounds contains the dimensions of the client, os2FrameWindow
 39028: // doesn't have to provide any special handling for this method.
 38942: 
 38942: NS_METHOD nsWindow::GetClientBounds(nsIntRect& aRect)
     1: {
 83107:   aRect = mBounds;
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 38942: nsIntPoint nsWindow::WidgetToScreenOffset()
     1: {
 38942:   POINTL point = { 0, 0 };
 38942:   NS2PM(point);
 38942: 
 38942:   WinMapWindowPoints(mWnd, HWND_DESKTOP, &point, 1);
 38942:   return nsIntPoint(point.x,
 38942:                     WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN) - point.y - 1);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Transform Y values between PM & XP coordinate systems.
 38942: 
 38942: // ptl is in this window's space
 38942: void nsWindow::NS2PM(POINTL& ptl)
     1: {
 39028:   ptl.y = mBounds.height - ptl.y - 1;
 38942: }
 38942: 
 38942: // rcl is in this window's space
 38942: void nsWindow::NS2PM(RECTL& rcl)
     1: {
 38942:   LONG height = rcl.yTop - rcl.yBottom;
 39028:   rcl.yTop = mBounds.height - rcl.yBottom;
 38942:   rcl.yBottom = rcl.yTop - height;
 38942: }
 38942: 
 38942: // ptl is in parent's space
 38942: void nsWindow::NS2PM_PARENT(POINTL& ptl)
     1: {
 38942:   if (mParent) {
 38942:     mParent->NS2PM(ptl);
 38942:   } else {
 39028:     HWND hParent = WinQueryWindow(mWnd, QW_PARENT);
 38942:     SWP  swp;
 38942:     WinQueryWindowPos(hParent, &swp);
 38942:     ptl.y = swp.cy - ptl.y - 1;
 38942:   }
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: NS_METHOD nsWindow::Move(int32_t aX, int32_t aY)
     1: {
 39028:   if (mFrame) {
102762:     nsresult rv = mFrame->Move(aX, aY);
120177:     NotifyRollupGeometryChange();
102762:     return rv;
 38942:   }
 80486:   Resize(aX, aY, mBounds.width, mBounds.height, false);
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: NS_METHOD nsWindow::Resize(int32_t aWidth, int32_t aHeight, bool aRepaint)
     1: {
 39028:   if (mFrame) {
102762:     nsresult rv = mFrame->Resize(aWidth, aHeight, aRepaint);
120177:     NotifyRollupGeometryChange();
102762:     return rv;
 39028:   }
 38942:   Resize(mBounds.x, mBounds.y, aWidth, aHeight, aRepaint);
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: NS_METHOD nsWindow::Resize(int32_t aX, int32_t aY,
108991:                            int32_t aWidth, int32_t aHeight, bool aRepaint)
     1: {
 39028:   if (mFrame) {
102762:     nsresult rv = mFrame->Resize(aX, aY, aWidth, aHeight, aRepaint);
120177:     NotifyRollupGeometryChange();
102762:     return rv;
 39028:   }
 39028: 
 38942:   // For mWnd & eWindowType_child set the cached values upfront, see bug 286555.
 38942:   // For other mWnd types we defer transfer of values to mBounds to
 38942:   // WinSetWindowPos(), see bug 391421.
 38942: 
 38942:   if (!mWnd ||
 38942:       mWindowType == eWindowType_child ||
 38942:       mWindowType == eWindowType_plugin) {
 38942:     mBounds.x      = aX;
 38942:     mBounds.y      = aY;
 38942:     mBounds.width  = aWidth;
 38942:     mBounds.height = aHeight;
 38942:   }
 38942: 
 38942:   // To keep top-left corner in the same place, use the new height
 38942:   // to calculate the coordinates for the top & bottom left corners.
 38942:   if (mWnd) {
 38942:     POINTL ptl = { aX, aY };
 38942:     NS2PM_PARENT(ptl);
 38942:     ptl.y -= aHeight - 1;
 38942: 
 38942:     // For popups, aX already gives the correct position.
 38942:     if (mWindowType == eWindowType_popup) {
 38942:       ptl.y = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN) - aHeight - 1 - aY;
 38942:     }
 38942:     else if (mParent) {
 38942:       WinMapWindowPoints(mParent->mWnd, WinQueryWindow(mWnd, QW_PARENT),
 38942:                          &ptl, 1);
 38942:     }
 38942: 
 39028:     if (!WinSetWindowPos(mWnd, 0, ptl.x, ptl.y, aWidth, aHeight,
 38942:                          SWP_MOVE | SWP_SIZE) && aRepaint) {
 38942:       WinInvalidateRect(mWnd, 0, FALSE);
 38942:     }
 38942:   }
 38942: 
120177:   NotifyRollupGeometryChange();
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 38942: NS_METHOD nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
 79445:                                 nsIWidget* aWidget, bool aActivate)
     1: {
 38942:   HWND hBehind = HWND_TOP;
 38942: 
 38942:   if (aPlacement == eZPlacementBottom) {
 38942:     hBehind = HWND_BOTTOM;
 38942:   } else
 38942:   if (aPlacement == eZPlacementBelow && aWidget) {
 38942:     hBehind = (static_cast<nsWindow*>(aWidget))->GetMainWindow();
 38942:   }
 38942: 
108991:   uint32_t flags = SWP_ZORDER;
 38942:   if (aActivate) {
 38942:     flags |= SWP_ACTIVATE;
 38942:   }
 38942: 
 38942:   WinSetWindowPos(GetMainWindow(), hBehind, 0, 0, 0, 0, flags);
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Set widget's position within its parent child list.
 38942: 
108991: NS_METHOD nsWindow::SetZIndex(int32_t aZIndex)
 33769: {
 38942:   // nsBaseWidget::SetZIndex() never has done anything sensible but
 38942:   // has randomly placed widgets behind others (see bug 117730#c25).
 38942:   // To get bug #353011 solved simply override it here to do nothing.
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Plugin Operations
 38942: //=============================================================================
 38942: 
 38942: // Fire an NS_PLUGIN_ACTIVATE event whenever a window associated
 38942: // with a plugin widget get the focus.
 33769: 
 33769: void nsWindow::ActivatePlugin(HWND aWnd)
 33769: {
 33769:   // avoid acting on recursive WM_FOCUSCHANGED msgs
 79445:   static bool inPluginActivate = FALSE;
 33769:   if (inPluginActivate) {
 33769:     return;
 33769:   }
 33769: 
 33769:   // This property is used by the plugin window to store a pointer
 33769:   // to its plugin object.  We just use it as a convenient marker.
 33769:   if (!WinQueryProperty(mWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION)) {
 33769:     return;
 33769:   }
 33769: 
 33769:   // Fire a plugin activation event on the plugin widget.
 33769:   inPluginActivate = TRUE;
 33769:   DEBUGFOCUS(NS_PLUGIN_ACTIVATE);
 38942:   DispatchActivationEvent(NS_PLUGIN_ACTIVATE);
 33769: 
 33769:   // Activating the plugin moves the focus off the child that had it,
 33769:   // so try to restore it.  If the WM_FOCUSCHANGED msg was synthesized
 33769:   // by the plugin, then mp1 contains the child window that lost focus.
 33769:   // Otherwise, just move it to the plugin's first child unless this
 33769:   // is the mplayer plugin - doing so will put us into an endless loop.
 33769:   // Since its children belong to another process, use the PID as a test.
 33769:   HWND hFocus = 0;
 33769:   if (WinIsChild(aWnd, mWnd)) {
 33769:     hFocus = aWnd;
 33769:   } else {
 33769:     hFocus = WinQueryWindow(mWnd, QW_TOP);
 33769:     if (hFocus) {
 33769:       PID pidFocus, pidThis;
 33769:       TID tid;
 33769:       WinQueryWindowProcess(hFocus, &pidFocus, &tid);
 33769:       WinQueryWindowProcess(mWnd, &pidThis, &tid);
 33769:       if (pidFocus != pidThis) {
 33769:         hFocus = 0;
 33769:       }
 33769:     }
 33769:   }
 33769:   if (hFocus) {
 33769:     WinSetFocus(HWND_DESKTOP, hFocus);
 33769:   }
 33769: 
 33769:   inPluginActivate = FALSE;
 33769:   return;
 33769: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: // This is invoked on a window that has plugin widget children
 38942: // to resize and clip those child windows.
 38942: 
 38942: nsresult nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
     1: {
108991:   for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
 38942:     const Configuration& configuration = aConfigurations[i];
 38942:     nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
 38942:     NS_ASSERTION(w->GetParent() == this,
 38942:                  "Configured widget is not a child");
 38942:     w->SetPluginClipRegion(configuration);
 38942:   }
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // This is invoked on a plugin window to resize it and set a persistent
 38942: // clipping region for it.  Since the latter isn't possible on OS/2, it
 38942: // inserts a dummy window between the plugin widget and its parent to
 38942: // act as a clipping rectangle.  The dummy window's dimensions and the
 38942: // plugin widget's position within the window are adjusted to correspond
 38942: // to the bounding box of the supplied array of clipping rectangles.
 38942: // Note: this uses PM calls rather than existing methods like Resize()
 38942: // and Update() because none of them support the options needed here.
 38942: 
 38942: void nsWindow::SetPluginClipRegion(const Configuration& aConfiguration)
     1: {
 38942:   NS_ASSERTION((mParent && mParent->mWnd), "Child window has no parent");
 38942: 
 38942:   // If nothing has changed, exit.
 38942:   if (!StoreWindowClipRegion(aConfiguration.mClipRegion) &&
 68638:       mBounds.IsEqualInterior(aConfiguration.mBounds)) {
 38942:     return;
 38942:   }
 38942: 
 38942:   // Set the widget's x/y to its nominal unclipped value.  It doesn't
 38942:   // affect our calculations but other code relies on it being correct.
 38942:   mBounds.MoveTo(aConfiguration.mBounds.TopLeft());
 38942: 
 38942:   // Get or create the PM window we use as a clipping rectangle.
 38942:   HWND hClip = GetPluginClipWindow(mParent->mWnd);
 38942:   NS_ASSERTION(hClip, "No clipping window for plugin");
 38942:   if (!hClip) {
 38942:     return;
 38942:   }
 38942: 
 38942:   // Create the bounding box for the clip region.
 38942:   const nsTArray<nsIntRect>& rects = aConfiguration.mClipRegion;
 38942:   nsIntRect r;
108991:   for (uint32_t i = 0; i < rects.Length(); ++i) {
 38942:     r.UnionRect(r, rects[i]);
 38942:   }
 38942: 
 38942:   // Size and position hClip to match the bounding box.
 38942:   SWP    swp;
 38942:   POINTL ptl;
 38942:   WinQueryWindowPos(hClip, &swp);
 38942:   ptl.x = aConfiguration.mBounds.x + r.x;
 38942:   ptl.y = mParent->mBounds.height
 38942:           - (aConfiguration.mBounds.y + r.y + r.height);
 38942: 
 38942:   ULONG  clipFlags = 0;
 38942:   if (swp.x != ptl.x || swp.y != ptl.y) {
 38942:     clipFlags |= SWP_MOVE;
 38942:   }
 38942:   if (swp.cx != r.width || swp.cy != r.height) {
 38942:     clipFlags |= SWP_SIZE;
 38942:   }
 38942:   if (clipFlags) {
 38942:     WinSetWindowPos(hClip, 0, ptl.x, ptl.y, r.width, r.height, clipFlags);
 38942:   }
 38942: 
 38942:   // Reducing the size of hClip clips the right & top sides of the
 38942:   // plugin widget.  To clip the left & bottom sides, we have to move
 38942:   // the widget so its origin's x and/or y is negative wrt hClip.
 38942:   WinQueryWindowPos(mWnd, &swp);
 38942:   ptl.x = -r.x;
 38942:   ptl.y = r.height + r.y - aConfiguration.mBounds.height;
 38942: 
 38942:   ULONG  wndFlags = 0;
 38942:   if (swp.x != ptl.x || swp.y != ptl.y) {
 38942:     wndFlags |= SWP_MOVE;
 38942:   }
 38942:   if (mBounds.Size() != aConfiguration.mBounds.Size()) {
 38942:     wndFlags |= SWP_SIZE;
 38942:   }
 38942:   if (wndFlags) {
 38942:     WinSetWindowPos(mWnd, 0, ptl.x, ptl.y,
 38942:                     aConfiguration.mBounds.width,
 38942:                     aConfiguration.mBounds.height, wndFlags);
 38942:   }
 38942: 
 38942:   // Some plugins don't resize themselves when the plugin widget changes
 38942:   // size, so help them out by resizing the first child (usually a frame).
 38942:   if (wndFlags & SWP_SIZE) {
 38942:     HWND hChild = WinQueryWindow(mWnd, QW_TOP);
 38942:     if (hChild) {
 38942:       WinSetWindowPos(hChild, 0, 0, 0,
 38942:                       aConfiguration.mBounds.width,
 38942:                       aConfiguration.mBounds.height,
 38942:                       SWP_MOVE | SWP_SIZE);
 38942:     }
 38942:   }
 38942: 
 38942:   // When hClip is resized, mWnd and its children may not get updated
 38942:   // automatically, so invalidate & repaint them
 38942:   if (clipFlags & SWP_SIZE) {
 38942:     WinInvalidateRect(mWnd, 0, TRUE);
 38942:     WinUpdateWindow(mWnd);
 38942:   }
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // This gets or creates a window that's inserted between the main window
 38942: // and its plugin children.  This window does nothing except act as a
 38942: // clipping rectangle for the plugin widget.
 38942: 
 38942: HWND nsWindow::GetPluginClipWindow(HWND aParentWnd)
     1: {
 38942:   if (mClipWnd) {
 38942:     return mClipWnd;
 38942:   }
 38942: 
 38942:   // Insert a new clip window in the hierarchy between mWnd & aParentWnd.
 38942:   mClipWnd = WinCreateWindow(aParentWnd, kClipWndClass, "",
 38942:                              WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
 38942:                              0, 0, 0, 0, 0, mWnd, 0, 0, 0);
 38942:   if (mClipWnd) {
 38942:     if (!WinSetParent(mWnd, mClipWnd, FALSE)) {
 38942:       WinDestroyWindow(mClipWnd);
 38942:       mClipWnd = 0;
 38942:     }
 38942:   }
 38942: 
 38942:   return mClipWnd;
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Top-level (frame window) Operations
 38942: //=============================================================================
 38942: 
 39028: // When a window gets the focus, call os2FrameWindow's version of this
 38942: // method.  It will fire an NS_ACTIVATE event on the top-level widget
 38942: // if appropriate.
 38942: 
 38942: void nsWindow::ActivateTopLevelWidget()
     1: {
 39028:   if (mFrame) {
 39028:     mFrame->ActivateTopLevelWidget();
 39028:   } else {
 38942:     nsWindow* top = static_cast<nsWindow*>(GetTopLevelWidget());
 39028:     if (top && top->mFrame) {
 39028:       top->mFrame->ActivateTopLevelWidget();
 39028:     }
 38942:   }
 38942:   return;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 39028: // All of these methods are inherently toplevel-only, and are in fact
 39028: // only invoked on toplevel widgets.  If they're invoked on a child
 39028: // window, there's an error upstream.
 38942: 
108991: NS_IMETHODIMP nsWindow::SetSizeMode(int32_t aMode)
     1: {
 39028:   NS_ENSURE_TRUE(mFrame, NS_ERROR_UNEXPECTED);
 39028:   return mFrame->SetSizeMode(aMode);
 38942: }
 38942: 
 79445: NS_IMETHODIMP nsWindow::HideWindowChrome(bool aShouldHide)
     1: {
 39028:   NS_ENSURE_TRUE(mFrame, NS_ERROR_UNEXPECTED);
 39028:   return mFrame->HideWindowChrome(aShouldHide);
 38942: }
 38942: 
     1: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
     1: {
 39028:   NS_ENSURE_TRUE(mFrame, NS_ERROR_UNEXPECTED);
 39028:   return mFrame->SetTitle(aTitle);
     1: }
     1: 
     1: NS_METHOD nsWindow::SetIcon(const nsAString& aIconSpec)
     1: {
 39028:   NS_ENSURE_TRUE(mFrame, NS_ERROR_UNEXPECTED);
 39028:   return mFrame->SetIcon(aIconSpec);
 38942: }
 38942: 
 79445: NS_METHOD nsWindow::ConstrainPosition(bool aAllowSlop,
108991:                                       int32_t* aX, int32_t* aY)
 27993: {
 39028:   NS_ENSURE_TRUE(mFrame, NS_ERROR_UNEXPECTED);
 39028:   return mFrame->ConstrainPosition(aAllowSlop, aX, aY);
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Mouse Pointers
 38942: //=============================================================================
 38942: 
 38942: // Set one of the standard mouse pointers.
 38942: 
 38942: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
     1: {
 38942:   HPOINTER newPointer = 0;
 38942: 
 38942:   switch (aCursor) {
 38942:     case eCursor_select:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_TEXT, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_wait:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_WAIT, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_hyperlink:
 38942:       newPointer = sPtrArray[IDC_SELECTANCHOR-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_standard:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_ARROW, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_n_resize:
 38942:     case eCursor_s_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZENS, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_w_resize:
 38942:     case eCursor_e_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZEWE, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_nw_resize:
 38942:     case eCursor_se_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZENWSE, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_ne_resize:
 38942:     case eCursor_sw_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZENESW, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_crosshair:
 38942:       newPointer = sPtrArray[IDC_CROSS-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_move:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_MOVE, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_help:
 38942:       newPointer = sPtrArray[IDC_HELP-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_copy: // CSS3
 38942:       newPointer = sPtrArray[IDC_COPY-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_alias:
 38942:       newPointer = sPtrArray[IDC_ALIAS-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_cell:
 38942:       newPointer = sPtrArray[IDC_CELL-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_grab:
 38942:       newPointer = sPtrArray[IDC_GRAB-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_grabbing:
 38942:       newPointer = sPtrArray[IDC_GRABBING-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_spinning:
 38942:       newPointer = sPtrArray[IDC_ARROWWAIT-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_context_menu:
 38942:       // XXX this CSS3 cursor needs to be implemented
 38942:       break;
 38942: 
 38942:     case eCursor_zoom_in:
 38942:       newPointer = sPtrArray[IDC_ZOOMIN-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_zoom_out:
 38942:       newPointer = sPtrArray[IDC_ZOOMOUT-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_not_allowed:
 38942:     case eCursor_no_drop:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_ILLEGAL, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_col_resize:
 38942:       newPointer = sPtrArray[IDC_COLRESIZE-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_row_resize:
 38942:       newPointer = sPtrArray[IDC_ROWRESIZE-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_vertical_text:
 38942:       newPointer = sPtrArray[IDC_VERTICALTEXT-IDC_BASE];
 38942:       break;
 38942: 
 38942:     case eCursor_all_scroll:
 38942:       // XXX not 100% appropriate perhaps
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_MOVE, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_nesw_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZENESW, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_nwse_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZENWSE, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_ns_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZENS, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_ew_resize:
 38942:       newPointer = WinQuerySysPointer(HWND_DESKTOP, SPTR_SIZEWE, FALSE);
 38942:       break;
 38942: 
 38942:     case eCursor_none:
 38942:       newPointer = sPtrArray[IDC_NONE-IDC_BASE];
 38942:       break;
 38942: 
 38942:     default:
 38942:       NS_ERROR("Invalid cursor type");
 38942:       break;
 38942:   }
 38942: 
 38942:   if (newPointer) {
 38942:     WinSetPointer(HWND_DESKTOP, newPointer);
 38942:   }
 38942: 
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Create a mouse pointer on the fly to support the CSS 'cursor' style.
 38942: // This code is based on the Win version by C. Biesinger but has been
 38942: // substantially modified to accommodate platform differences and to
 38942: // improve efficiency.
 38942: 
 38942: NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
108991:                                   uint32_t aHotspotX, uint32_t aHotspotY)
     1: {
 38942: 
 38942:   // if this is the same image as last time, reuse the saved hptr;
 38942:   // it will be destroyed when we create a new one or when the
 38942:   // current window is destroyed
 38942:   if (mCssCursorImg == aCursor && mCssCursorHPtr) {
 38942:     WinSetPointer(HWND_DESKTOP, mCssCursorHPtr);
     1:     return NS_OK;
     1:   }
     1: 
 38942:   nsRefPtr<gfxImageSurface> frame;
 38942:   aCursor->CopyFrame(imgIContainer::FRAME_CURRENT,
 38942:                      imgIContainer::FLAG_SYNC_DECODE,
 38942:                      getter_AddRefs(frame));
 38942:   NS_ENSURE_TRUE(frame, NS_ERROR_NOT_AVAILABLE);
 38942: 
 38942:   // if the image is ridiculously large, exit because
 38942:   // it will be unrecognizable when shrunk to 32x32
108991:   int32_t width = frame->Width();
108991:   int32_t height = frame->Height();
 38942:   NS_ENSURE_TRUE(width <= 128 && height <= 128, NS_ERROR_FAILURE);
 38942: 
108991:   uint8_t* data = frame->Data();
 38942: 
 38942:   // create the color bitmap
 38942:   HBITMAP hBmp = CreateBitmapRGB(data, width, height);
 38942:   NS_ENSURE_TRUE(hBmp, NS_ERROR_FAILURE);
 38942: 
 38942:   // create a transparency mask from the alpha bytes
 38942:   HBITMAP hAlpha = CreateTransparencyMask(frame->Format(), data, width, height);
 38942:   if (!hAlpha) {
 38942:     GpiDeleteBitmap(hBmp);
 38942:     return NS_ERROR_FAILURE;
 38942:   }
 38942: 
 38942:   POINTERINFO info = {0};
 38942:   info.fPointer = TRUE;
 38942:   info.xHotspot = aHotspotX;
 38942:   info.yHotspot = height - aHotspotY - 1;
 38942:   info.hbmPointer = hAlpha;
 38942:   info.hbmColor = hBmp;
 38942: 
 38942:   // create the pointer
 38942:   HPOINTER cursor = WinCreatePointerIndirect(HWND_DESKTOP, &info);
 38942:   GpiDeleteBitmap(hBmp);
 38942:   GpiDeleteBitmap(hAlpha);
 38942:   NS_ENSURE_TRUE(cursor, NS_ERROR_FAILURE);
 38942: 
 38942:   // use it
 38942:   WinSetPointer(HWND_DESKTOP, cursor);
 38942: 
 38942:   // destroy the previous hptr;  this has to be done after the
 38942:   // new pointer is set or else WinDestroyPointer() will fail
 38942:   if (mCssCursorHPtr) {
 38942:     WinDestroyPointer(mCssCursorHPtr);
 38942:   }
 38942: 
 38942:   // save the hptr and a reference to the image for next time
 38942:   mCssCursorHPtr = cursor;
 38942:   mCssCursorImg = aCursor;
 38942: 
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Render image or modified alpha data as a native bitmap.
 38942: 
 38942: // aligned bytes per row, rounded up to next dword bounday
 38942: #define ALIGNEDBPR(cx,bits) ( ( ( ((cx)*(bits)) + 31) / 32) * 4)
 38942: 
108991: HBITMAP nsWindow::DataToBitmap(uint8_t* aImageData, uint32_t aWidth,
108991:                                uint32_t aHeight, uint32_t aDepth)
     1: {
 38942:   // get a presentation space for this window
 38942:   HPS hps = (HPS)GetNativeData(NS_NATIVE_GRAPHIC);
 38942:   if (!hps) {
 38942:     return 0;
 38942:   }
 38942: 
 38942:   // a handy structure that does double duty
 38942:   // as both BITMAPINFOHEADER2 & BITMAPINFO2
 38942:   struct {
 38942:     BITMAPINFOHEADER2 head;
 38942:     RGB2 black;
 38942:     RGB2 white;
 38942:   } bi;
 38942: 
 38942:   memset(&bi, 0, sizeof(bi));
 38942:   bi.white.bBlue = (BYTE)255;
 38942:   bi.white.bGreen = (BYTE)255;
 38942:   bi.white.bRed = (BYTE)255;
 38942: 
 38942:   // fill in the particulars
 38942:   bi.head.cbFix = sizeof(bi.head);
 38942:   bi.head.cx = aWidth;
 38942:   bi.head.cy = aHeight;
 38942:   bi.head.cPlanes = 1;
 38942:   bi.head.cBitCount = aDepth;
 38942:   bi.head.ulCompression = BCA_UNCOMP;
 38942:   bi.head.cbImage = ALIGNEDBPR(aWidth, aDepth) * aHeight;
 38942:   bi.head.cclrUsed = (aDepth == 1 ? 2 : 0);
 38942: 
 38942:   // create a bitmap from the image data
 38942:   HBITMAP hBmp = GpiCreateBitmap(hps, &bi.head, CBM_INIT,
 38942:                  reinterpret_cast<BYTE*>(aImageData),
 38942:                  (BITMAPINFO2*)&bi);
 38942: 
 38942:   // free the hps, then return the bitmap
 38942:   FreeNativeData((void*)hps, NS_NATIVE_GRAPHIC);
 38942:   return hBmp;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Create an RGB24 bitmap from Cairo image data.
 38942: 
108991: HBITMAP nsWindow::CreateBitmapRGB(uint8_t* aImageData,
108991:                                   uint32_t aWidth,
108991:                                   uint32_t aHeight)
     1: {
 38942:   // calc width in bytes, rounding up to a dword boundary
108991:   const uint32_t bpr = ALIGNEDBPR(aWidth, 24);
108991:   uint8_t* bmp = (uint8_t*)malloc(bpr * aHeight);
 38942:   if (!bmp) {
 38942:     return 0;
 38942:   }
 38942: 
108991:   uint32_t* pSrc = (uint32_t*)aImageData;
108991:   for (uint32_t row = aHeight; row > 0; --row) {
108991:     uint8_t* pDst = bmp + bpr * (row - 1);
108991: 
108991:     for (uint32_t col = aWidth; col > 0; --col) {
 38942:       // In Cairo a color is encoded as ARGB in a DWORD
 38942:       // stored in machine endianess.
108991:       uint32_t color = *pSrc++;
 38942:       *pDst++ = color;       // Blue
 38942:       *pDst++ = color >> 8;  // Green
 38942:       *pDst++ = color >> 16; // Red
 38942:     }
 38942:   }
 38942: 
 38942:   // create the bitmap
 38942:   HBITMAP hAlpha = DataToBitmap(bmp, aWidth, aHeight, 24);
 38942: 
 38942:   // free the buffer, then return the bitmap
 38942:   free(bmp);
 38942:   return hAlpha;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Create a monochrome AND/XOR bitmap from 0, 1, or 8-bit alpha data.
 38942: 
 38942: HBITMAP nsWindow::CreateTransparencyMask(gfxASurface::gfxImageFormat format,
108991:                                          uint8_t* aImageData,
108991:                                          uint32_t aWidth,
108991:                                          uint32_t aHeight)
     1: {
 38942:   // calc width in bytes, rounding up to a dword boundary
108991:   uint32_t abpr = ALIGNEDBPR(aWidth, 1);
108991:   uint32_t cbData = abpr * aHeight;
 38942: 
 38942:   // alloc and clear space to hold both the AND & XOR bitmaps
108991:   uint8_t* mono = (uint8_t*)calloc(cbData, 2);
 38942:   if (!mono) {
 38942:     return 0;
 38942:   }
 38942: 
 38942:   // Non-alpha formats are already taken care of
 38942:   // by initializing the XOR and AND masks to zero
 38942:   if (format == gfxASurface::ImageFormatARGB32) {
 38942: 
 38942:     // make the AND mask the inverse of the 8-bit alpha data
108991:     int32_t* pSrc = (int32_t*)aImageData;
108991:     for (uint32_t row = aHeight; row > 0; --row) {
 38942:       // Point to the right row in the AND mask
108991:       uint8_t* pDst = mono + cbData + abpr * (row - 1);
108991:       uint8_t mask = 0x80;
108991:       for (uint32_t col = aWidth; col > 0; --col) {
 38942:         // Use the sign bit to test for transparency, as the alpha byte
 38942:         // is highest byte.  Positive means, alpha < 128, so consider it
 38942:         // as transparent and set the AND mask.
 38942:         if (*pSrc++ >= 0) {
 38942:           *pDst |= mask;
 38942:         }
 38942: 
 38942:         mask >>= 1;
 38942:         if (!mask) {
 38942:           pDst++;
 38942:           mask = 0x80;
 38942:         }
 38942:       }
 38942:     }
 38942:   }
 38942: 
 38942:   // create the bitmap
 38942:   HBITMAP hAlpha = DataToBitmap(mono, aWidth, aHeight * 2, 1);
 38942: 
 38942:   // free the buffer, then return the bitmap
 38942:   free(mono);
 38942:   return hAlpha;
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Rollup Event Handlers
 38942: //=============================================================================
 38942: 
 38942: NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener* aListener,
120177:                                             bool aDoCapture)
 29468: {
120177:   gRollupListener = aDoCapture ? aListener : nullptr;
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 38942: // static
 79445: bool nsWindow::EventIsInsideWindow(nsWindow* aWindow)
 38942: {
 38942:   RECTL  rcl;
 38942:   POINTL ptl;
123327:   NS_ENSURE_TRUE(aWindow, false);
 38942:   if (WinQueryMsgPos(0, &ptl)) {
 38942:     WinMapWindowPoints(HWND_DESKTOP, aWindow->mWnd, &ptl, 1);
 38942:     WinQueryWindowRect(aWindow->mWnd, &rcl);
 38942: 
 38942:     // now make sure that it wasn't one of our children
 38942:     if (ptl.x < rcl.xLeft || ptl.x > rcl.xRight ||
 38942:         ptl.y > rcl.yTop  || ptl.y < rcl.yBottom) {
 80486:       return false;
 38942:     }
 38942:   }
 38942: 
 80486:   return true;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Handle events that would cause a popup (combobox, menu, etc) to rollup.
 38942: 
 38942: // static
 79445: bool nsWindow::RollupOnButtonDown(ULONG aMsg)
 38942: {
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
123327:   nsCOMPtr<nsIWidget> rollupWidget;
123327:   if (rollupListener) {
123327:     rollupWidget = rollupListener->GetRollupWidget();
123327:   }
120177: 
 38942:   // Exit if the event is inside the most recent popup.
120177:   if (EventIsInsideWindow((nsWindow*)rollupWidget)) {
 80486:     return false;
 38942:   }
 38942: 
 38942:   // See if we're dealing with a menu.  If so, exit if the
 38942:   // event was inside a parent of the current submenu.
115367:   uint32_t popupsToRollup = UINT32_MAX;
 38942: 
120177:   if (rollupListener) {
 38942:     nsAutoTArray<nsIWidget*, 5> widgetChain;
120177:     uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
108991:     for (uint32_t i = 0; i < widgetChain.Length(); ++i) {
 38942:       nsIWidget* widget = widgetChain[i];
 38942:       if (EventIsInsideWindow((nsWindow*)widget)) {
 38942:         if (i < sameTypeCount) {
 80486:           return false;
 38942:         }
 38942:         popupsToRollup = sameTypeCount;
 29468:         break;
 38942:       }
 38942:     } // for each parent menu widget
 38942:   } // if rollup listener knows about menus
 38942: 
 38942:   // We only need to deal with the last rollup for left mouse down events.
 82030:   NS_ASSERTION(!mLastRollup, "mLastRollup is null");
120177:   bool consumeRollupEvent =
120177:     rollupListener->Rollup(popupsToRollup, aMsg == WM_LBUTTONDOWN ? &mLastRollup : nullptr);
 82030:   NS_IF_ADDREF(mLastRollup);
 38942: 
 38942:   // If true, the buttondown event won't be passed on to the wndproc.
120177:   return consumeRollupEvent;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 38942: // static
 38942: void nsWindow::RollupOnFocusLost(HWND aFocus)
 38942: {
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
123327:   nsCOMPtr<nsIWidget> rollupWidget;
123327:   if (rollupListener) {
123327:     rollupWidget = rollupListener->GetRollupWidget();
123327:   }
123327:   HWND hRollup = rollupWidget ? ((nsWindow*)rollupWidget)->mWnd : NULL;
 38942: 
 38942:   // Exit if focus was lost to the most recent popup.
 38942:   if (hRollup == aFocus) {
 38942:     return;
 38942:   }
 38942: 
 38942:   // Exit if focus was lost to a parent of the current submenu.
120177:   if (rollupListener) {
 38942:     nsAutoTArray<nsIWidget*, 5> widgetChain;
120177:     rollupListener->GetSubmenuWidgetChain(&widgetChain);
108991:     for (uint32_t i = 0; i < widgetChain.Length(); ++i) {
 38942:       if (((nsWindow*)widgetChain[i])->mWnd == aFocus) {
 38942:         return;
 38942:       }
 38942:     }
120177: 
120177:     // Rollup all popups.
120177:     rollupListener->Rollup(UINT32_MAX);
 38942:   }
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  nsWindow's Window Procedure
 38942: //=============================================================================
 38942: 
 38942: // This is the actual wndproc;  it does some preprocessing then passes
 38942: // the msgs to the ProcessMessage() method which does most of the work.
 38942: 
 38942: MRESULT EXPENTRY fnwpNSWindow(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
 38942: {
 38942:   nsAutoRollup autoRollup;
 38942: 
 38942:   // If this window doesn't have an object ptr,
 38942:   // send the msg to the default wndproc.
 38942:   nsWindow* wnd = nsWindow::GetNSWindowPtr(hwnd);
 38942:   if (!wnd) {
 38942:     return WinDefWindowProc(hwnd, msg, mp1, mp2);
 38942:   }
 38942: 
 38942:   // If we're not in the destructor, hold on to the object for the
 38942:   // life of this method, in case it gets deleted during processing.
 38942:   // Yes, it's a double hack since someWindow is not really an interface.
 38942:   nsCOMPtr<nsISupports> kungFuDeathGrip;
 38942:   if (!wnd->mIsDestroying) {
 38942:     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)wnd);
 38942:   }
 38942: 
 38942:   // Pre-process msgs that may cause a rollup.
120177:   }
 38942:   switch (msg) {
 38942:     case WM_BUTTON1DOWN:
 38942:     case WM_BUTTON2DOWN:
 38942:     case WM_BUTTON3DOWN:
 38942:       if (nsWindow::RollupOnButtonDown(msg)) {
 80486:         return (MRESULT)true;
 38942:       }
 29468:       break;
 38942: 
 38942:     case WM_SETFOCUS:
 38942:       if (!mp2) {
 38942:         nsWindow::RollupOnFocusLost((HWND)mp1);
 38942:       }
 29468:       break;
 38942:   }
 38942: 
 38942:   return wnd->ProcessMessage(msg, mp1, mp2);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // In effect, nsWindow's real wndproc.
 38942: 
 38942: MRESULT nsWindow::ProcessMessage(ULONG msg, MPARAM mp1, MPARAM mp2)
 38942: {
 79445:   bool    isDone = false;
 38942:   MRESULT mresult = 0;
 38942: 
 38942:   switch (msg) {
 38942: 
 38942:     // Interpret WM_QUIT as a close request so that
 38942:     // windows can be closed from the Window List
 38942:     case WM_CLOSE:
 38942:     case WM_QUIT: {
 38942:       mWindowState |= nsWindowState_eClosing;
 80486:       nsGUIEvent event(true, NS_XUL_CLOSE, this);
 38942:       InitEvent(event);
 38942:       DispatchWindowEvent(&event);
 38942:       // abort window closure
 80486:       isDone = true;
 38942:       break;
 38942:     }
 38942: 
 38942:     case WM_DESTROY:
 38942:       OnDestroy();
 80486:       isDone = true;
 38942:       break;
 38942: 
 38942:     case WM_PAINT:
 38942:       isDone = OnPaint();
 38942:       break;
 38942: 
 38942:     case WM_TRANSLATEACCEL:
 38942:       isDone = OnTranslateAccelerator((PQMSG)mp1);
 38942:       break;
 38942: 
 38942:     case WM_CHAR:
 38942:       isDone = DispatchKeyEvent(mp1, mp2);
 38942:       break;
 38942: 
 38942:     // Mouseclicks: we don't dispatch CLICK events because they just cause
 38942:     // trouble: gecko seems to expect EITHER buttondown/up OR click events
 38942:     // and so that's what we give it.
 38942: 
 38942:     case WM_BUTTON1DOWN:
 38942:       WinSetCapture(HWND_DESKTOP, mWnd);
 67794:       isDone = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, mp1, mp2);
 67794:       // If this msg is forwarded to a popup's owner, Moz will cause the
 67794:       // popup to be rolled-up in error when the owner processes the msg.
 67794:       if (mWindowType == eWindowType_popup) {
 80486:         isDone = true;
 67794:       }
 38942:       // there's no need to clear this on button-up
 38942:       sLastButton1Down.x = XFROMMP(mp1);
 38942:       sLastButton1Down.y = YFROMMP(mp1);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON1UP:
 38942:       WinSetCapture(HWND_DESKTOP, 0);
 38942:       isDone = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, mp1, mp2);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON1DBLCLK:
 38942:       isDone = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, mp1, mp2);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON2DOWN:
 38942:       WinSetCapture(HWND_DESKTOP, mWnd);
 80486:       isDone = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, mp1, mp2, false,
 38942:                                   nsMouseEvent::eRightButton);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON2UP:
 38942:       WinSetCapture(HWND_DESKTOP, 0);
 80486:       isDone = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, mp1, mp2, false,
 38942:                                   nsMouseEvent::eRightButton);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON2DBLCLK:
 38942:       isDone = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, mp1, mp2,
 80486:                                   false, nsMouseEvent::eRightButton);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON3DOWN:
 38942:       WinSetCapture(HWND_DESKTOP, mWnd);
 80486:       isDone = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, mp1, mp2, false,
 38942:                                   nsMouseEvent::eMiddleButton);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON3UP:
 38942:       WinSetCapture(HWND_DESKTOP, 0);
 80486:       isDone = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, mp1, mp2, false,
 38942:                                   nsMouseEvent::eMiddleButton);
 38942:       break;
 38942: 
 38942:     case WM_BUTTON3DBLCLK:
 80486:       isDone = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, mp1, mp2, false,
 38942:                                   nsMouseEvent::eMiddleButton);
 38942:       break;
 38942: 
 38942:     case WM_CONTEXTMENU:
 38942:       if (SHORT2FROMMP(mp2)) {
 38942:         HWND hFocus = WinQueryFocus(HWND_DESKTOP);
 38942:         if (hFocus != mWnd) {
 38942:           WinSendMsg(hFocus, msg, mp1, mp2);
 38942:         } else {
 80486:           isDone = DispatchMouseEvent(NS_CONTEXTMENU, mp1, mp2, true,
 38942:                                       nsMouseEvent::eLeftButton);
 38942:         }
 38942:       } else {
 80486:         isDone = DispatchMouseEvent(NS_CONTEXTMENU, mp1, mp2, false,
 38942:                                     nsMouseEvent::eRightButton);
 38942:       }
 38942:       break;
 38942: 
 38942:     // If MB1 & MB2 are both pressed, perform a copy or paste.
 38942:     case WM_CHORD:
 38942:       isDone = OnMouseChord(mp1, mp2);
 38942:       break;
 38942: 
 38942:     case WM_MOUSEMOVE: {
 38942:       static POINTL ptlLastPos = { -1, -1 };
 38942: 
 38942:       // If mouse has actually moved, remember the new position,
 38942:       // then dispatch the event.
 38942:       if (ptlLastPos.x != (SHORT)SHORT1FROMMP(mp1) ||
 38942:           ptlLastPos.y != (SHORT)SHORT2FROMMP(mp1)) {
 38942:         ptlLastPos.x = (SHORT)SHORT1FROMMP(mp1);
 38942:         ptlLastPos.y = (SHORT)SHORT2FROMMP(mp1);
 38942:         DispatchMouseEvent(NS_MOUSE_MOVE, mp1, mp2);
 38942:       }
 38942: 
 38942:       // don't propagate mouse move or the OS will change the pointer
 80486:       isDone = true;
 38942:       break;
 38942:     }
 38942: 
 38942:     case WM_MOUSEENTER:
 38942:       isDone = DispatchMouseEvent(NS_MOUSE_ENTER, mp1, mp2);
 38942:       break;
 38942: 
 38942:     case WM_MOUSELEAVE:
 38942:       isDone = DispatchMouseEvent(NS_MOUSE_EXIT, mp1, mp2);
 38942:       break;
 38942: 
 38942:     case WM_APPCOMMAND: {
108991:       uint32_t appCommand = SHORT2FROMMP(mp2) & 0xfff;
 38942: 
 38942:       switch (appCommand) {
 38942:         case APPCOMMAND_BROWSER_BACKWARD:
 38942:         case APPCOMMAND_BROWSER_FORWARD:
 38942:         case APPCOMMAND_BROWSER_REFRESH:
 38942:         case APPCOMMAND_BROWSER_STOP:
 38942:           DispatchCommandEvent(appCommand);
 38942:           // tell the driver that we handled the event
 38942:           mresult = (MRESULT)1;
 80486:           isDone = true;
 38942:           break;
 38942:       }
 38942:       break;
 38942:     }
 38942: 
 38942:     case WM_HSCROLL:
 38942:     case WM_VSCROLL:
 38942:       isDone = DispatchScrollEvent(msg, mp1, mp2);
 38942:       break;
 38942: 
 39028:     // Do not act on WM_ACTIVATE - it is handled by os2FrameWindow.
 38942:     // case WM_ACTIVATE:
 38942:     //   break;
 38942: 
 38942:     // This msg is used to activate top-level and plugin widgets
 38942:     // after PM is done changing the focus.  We're only interested
 38942:     // in windows gaining focus, not in those losing it.
 38942:     case WM_FOCUSCHANGED:
 38942:       DEBUGFOCUS(WM_FOCUSCHANGED);
 38942:       if (SHORT1FROMMP(mp2)) {
 38942:         ActivateTopLevelWidget();
 38942:         ActivatePlugin(HWNDFROMMP(mp1));
 38942:       }
 38942:       break;
 38942: 
 38942:     case WM_WINDOWPOSCHANGED:
 38942:       isDone = OnReposition((PSWP) mp1);
 38942:       break;
 38942: 
 38942:       // all msgs that occur when this window is the target of a drag
 38942:     case DM_DRAGOVER:
 38942:     case DM_DRAGLEAVE:
 38942:     case DM_DROP:
 38942:     case DM_RENDERCOMPLETE:
 38942:     case DM_DROPHELP:
 38942:       OnDragDropMsg(msg, mp1, mp2, mresult);
 80486:       isDone = true;
 38942:       break;
103455: 
103455:     case WM_QUERYCONVERTPOS:
103455:       isDone = OnQueryConvertPos(mp1, mresult);
103455:       break;
103599: 
103599:     case WM_IMEREQUEST:
103599:       isDone = OnImeRequest(mp1, mp2);
103599:       break;
 38942:   }
 38942:   // If an event handler signalled that we should consume the event,
 38942:   // return.  Otherwise, pass it on to the default wndproc.
 38942:   if (!isDone) {
 38942:     mresult = WinDefWindowProc(mWnd, msg, mp1, mp2);
 38942:   }
 38942: 
 38942:   return mresult;
 38942: }
 38942: 
 38942: //=============================================================================
 38942: //  Window Message Handlers
 38942: //=============================================================================
 38942: 
 38942: // WM_DESTROY has been called.
 38942: 
 38942: void nsWindow::OnDestroy()
 38942: {
 80486:   mOnDestroyCalled = true;
 38942: 
 38942:   SetNSWindowPtr(mWnd, 0);
 38942:   mWnd = 0;
 38942: 
 80842:   // release references to context and children
 38942:   nsBaseWidget::OnDestroy();
 38942: 
 38942:   // dispatching of the event may cause the reference count to drop to 0
 38942:   // and result in this object being deleted. To avoid that, add a
 38942:   // reference and then release it after dispatching the event.
 38942:   //
 38942:   // It's important *not* to do this if we're being called from the
 38942:   // destructor -- this would result in our destructor being called *again*
 38942:   // from the Release() below.  This is very bad...
 38942:   if (!(nsWindowState_eDoingDelete & mWindowState)) {
 38942:     AddRef();
108456:     NotifyWindowDestroyed();
 38942:     Release();
 38942:   }
 38942: 
 38942:   // dead widget
 38942:   mWindowState |= nsWindowState_eDead;
 38942:   mWindowState &= ~(nsWindowState_eLive|nsWindowState_ePrecreate|
 38942:                     nsWindowState_eInCreate);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: bool nsWindow::OnReposition(PSWP pSwp)
 38942: {
 79445:   bool result = false;
 38942: 
 38942:   if (pSwp->fl & SWP_MOVE && !(pSwp->fl & SWP_MINIMIZE)) {
 38942:     HWND hParent = mParent ? mParent->mWnd : WinQueryWindow(mWnd, QW_PARENT);
 38942: 
 38942:     // need screen coords.
 38942:     POINTL ptl = { pSwp->x, pSwp->y + pSwp->cy - 1 };
 38942:     // XXX - this is peculiar...
 38942:     WinMapWindowPoints(WinQueryWindow(mWnd, QW_PARENT), hParent, &ptl, 1);
 38942:     PM2NS_PARENT(ptl);
 38942:     mBounds.x = ptl.x;
 38942:     mBounds.y = ptl.y;
 38942:     WinMapWindowPoints(hParent, HWND_DESKTOP, &ptl, 1);
 38942: 
 38942:     result = DispatchMoveEvent(ptl.x, ptl.y);
 38942:   }
 38942: 
 38942:   if (pSwp->fl & SWP_SIZE && !(pSwp->fl & SWP_MINIMIZE)) {
 38942:     mBounds.width  = pSwp->cx;
 38942:     mBounds.height = pSwp->cy;
 38942: 
 51174:     // If the window is supposed to have a thebes surface, resize it.
 51174:     if (ConfirmThebesSurface()) {
 51174:         mThebesSurface->Resize(gfxIntSize(mBounds.width, mBounds.height));
 38942:     }
 38942: 
 38942:     result = DispatchResizeEvent(mBounds.width, mBounds.height);
 38942:   }
 38942: 
 38942:   return result;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: bool nsWindow::OnPaint()
 38942: {
 39956:   HPS    hPS;
 39956:   HPS    hpsDrag;
 39956:   HRGN   hrgn;
 38942:   nsEventStatus eventStatus = nsEventStatus_eIgnore;
 38942: 
 39956: #ifdef DEBUG_PAINT
 38942:   HRGN debugPaintFlashRegion = 0;
 38942:   HPS  debugPaintFlashPS = 0;
 38942: 
 38942:   if (debug_WantPaintFlashing()) {
 38942:     debugPaintFlashPS = WinGetPS(mWnd);
 38942:     debugPaintFlashRegion = GpiCreateRegion(debugPaintFlashPS, 0, 0);
 38942:     WinQueryUpdateRegion(mWnd, debugPaintFlashRegion);
 39956:   }
 38942: #endif
 38942: 
 39956: // Use a dummy do..while(0) loop to facilitate error handling & early-outs.
 39956: do {
 39956: 
 39956:   // Get the current drag status.  If we're in a Moz-originated drag,
 39956:   // it will return a special drag HPS to pass to WinBeginPaint().
 39956:   // Oherwise, get a cached micro PS.
 39956:   CheckDragStatus(ACTION_PAINT, &hpsDrag);
 39956:   hPS = hpsDrag ? hpsDrag : WinGetPS(mWnd);
 39956: 
 39956:   // If we can't get an HPS, validate the window so we don't
 39956:   // keep getting the same WM_PAINT msg over & over again.
 38942:   RECTL  rcl = { 0 };
 39956:   if (!hPS) {
 39956:     WinQueryWindowRect(mWnd, &rcl);
 39956:     WinValidateRect(mWnd, &rcl, FALSE);
 39956:     break;
 39956:   }
 39956: 
 39956:   // Get the update region before WinBeginPaint() resets it.
 39956:   hrgn = GpiCreateRegion(hPS, 0, 0);
 39956:   WinQueryUpdateRegion(mWnd, hrgn);
 39956:   WinBeginPaint(mWnd, hPS, &rcl);
 39956: 
 51174:   // Exit if the update rect is empty.
 51174:   if (WinIsRectEmpty(0, &rcl)) {
 51174:     break;
 51174:   }
 51174: 
 51174:   // Exit if a thebes surface can not/should not be created,
 51174:   // but first fill the area with the default background color
 51174:   // to erase any visual artifacts.
 51174:   if (!ConfirmThebesSurface()) {
 51174:     WinDrawBorder(hPS, &rcl, 0, 0, 0, 0, DB_INTERIOR | DB_AREAATTRS);
 39956:     break;
 39956:   }
 39956: 
 39956:   // Even if there is no callback to update the content (unlikely)
 39956:   // we still want to update the screen with whatever's available.
 39956:   if (!mEventCallback) {
 39956:     mThebesSurface->Refresh(&rcl, hPS);
 39956:     break;
 39956:   }
 39956: 
 39956:   // Create an event & a Thebes context.
 80486:   nsPaintEvent event(true, NS_PAINT, this);
 38942:   InitEvent(event);
 39956:   nsRefPtr<gfxContext> thebesContext = new gfxContext(mThebesSurface);
 39956: 
 51174:   // Intersect the update region with the paint rectangle to clip areas
 51174:   // that aren't visible (e.g. offscreen or covered by another window).
 51174:   HRGN hrgnPaint;
 51174:   hrgnPaint = GpiCreateRegion(hPS, 1, &rcl);
 51174:   if (hrgnPaint) {
 51174:     GpiCombineRegion(hPS, hrgn, hrgn, hrgnPaint, CRGN_AND);
 51174:     GpiDestroyRegion(hPS, hrgnPaint);
 51174:   }
 51174: 
 39956:   // See how many rects comprise the update region.  If there are 8
 39956:   // or fewer, update them individually.  If there are more or the call
 39956:   // failed, update the bounding rectangle returned by WinBeginPaint().
 39956:   #define MAX_CLIPRECTS 8
 39956:   RGNRECT rgnrect = { 1, MAX_CLIPRECTS, 0, RECTDIR_LFRT_TOPBOT };
 39956:   RECTL   arect[MAX_CLIPRECTS];
 39956:   RECTL*  pr = arect;
 39956: 
 39956:   if (!GpiQueryRegionRects(hPS, hrgn, 0, &rgnrect, 0) ||
 39956:       rgnrect.crcReturned > MAX_CLIPRECTS) {
 39956:     rgnrect.crcReturned = 1;
 39956:     arect[0] = rcl;
 39956:   } else {
 39956:     GpiQueryRegionRects(hPS, hrgn, 0, &rgnrect, arect);
 39956:   }
 39956: 
 39956:   // Create clipping regions for the event & the Thebes context.
 39956:   thebesContext->NewPath();
108991:   for (uint32_t i = 0; i < rgnrect.crcReturned; i++, pr++) {
 39956:     event.region.Or(event.region, 
 39956:                     nsIntRect(pr->xLeft,
 39956:                               mBounds.height - pr->yTop,
 39956:                               pr->xRight - pr->xLeft,
 39956:                               pr->yTop - pr->yBottom));
 39956: 
 39956:     thebesContext->Rectangle(gfxRect(pr->xLeft,
 39956:                                      mBounds.height - pr->yTop,
 39956:                                      pr->xRight - pr->xLeft,
 39956:                                      pr->yTop - pr->yBottom));
 39956:   }
 39956:   thebesContext->Clip();
 39956: 
 39956: #ifdef DEBUG_PAINT
110974:   debug_DumpPaintEvent(stdout, this, &event, nsAutoCString("noname"),
108991:                        (int32_t)mWnd);
 38942: #endif
 38942: 
 39956:   // Init the Layers manager then dispatch the event.
 39956:   // If it returns false there's nothing to paint, so exit.
 47746:   AutoLayerManagerSetup
 47746:       setupLayerManager(this, thebesContext, BasicLayerManager::BUFFER_NONE);
 39956:   if (!DispatchWindowEvent(&event, eventStatus)) {
 38942:     break;
 38942:   }
 39956: 
 39956:   // Paint the surface, then use Refresh() to blit each rect to the screen.
 38942:   thebesContext->PopGroupToSource();
 38942:   thebesContext->SetOperator(gfxContext::OPERATOR_SOURCE);
 38942:   thebesContext->Paint();
 39956:   pr = arect;
108991:   for (uint32_t i = 0; i < rgnrect.crcReturned; i++, pr++) {
 39956:     mThebesSurface->Refresh(pr, hPS);
 38942:   }
 39956: 
 39956: } while (0);
 39956: 
 39956:   // Cleanup.
 39956:   if (hPS) {
 38942:     WinEndPaint(hPS);
 39956:     if (hrgn) {
 39956:       GpiDestroyRegion(hPS, hrgn);
 38942:     }
 39956:     if (!hpsDrag || !ReleaseIfDragHPS(hpsDrag)) {
 39956:       WinReleasePS(hPS);
 39956:     }
 39956:   }
 39956: 
 39956: #ifdef DEBUG_PAINT
 38942:   if (debug_WantPaintFlashing()) {
 38942:     // Only flash paint events which have not ignored the paint message.
 38942:     // Those that ignore the paint message aren't painting anything so there
 38942:     // is only the overhead of the dispatching the paint event.
 38942:     if (eventStatus != nsEventStatus_eIgnore) {
 38942:       LONG CurMix = GpiQueryMix(debugPaintFlashPS);
 38942:       GpiSetMix(debugPaintFlashPS, FM_INVERT);
 38942: 
 38942:       GpiPaintRegion(debugPaintFlashPS, debugPaintFlashRegion);
 38942:       PR_Sleep(PR_MillisecondsToInterval(30));
 38942:       GpiPaintRegion(debugPaintFlashPS, debugPaintFlashRegion);
 38942:       PR_Sleep(PR_MillisecondsToInterval(30));
 38942: 
 38942:       GpiSetMix(debugPaintFlashPS, CurMix);
 39956:     }
 38942:     GpiDestroyRegion(debugPaintFlashPS, debugPaintFlashRegion);
 38942:     WinReleasePS(debugPaintFlashPS);
 39956:   }
 38942: #endif
 38942: 
 80486:   return true;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // If MB1 & MB2 are both pressed, perform a copy or paste.
 38942: 
 79445: bool nsWindow::OnMouseChord(MPARAM mp1, MPARAM mp2)
 38942: {
 38942:   if (!isKeyDown(VK_BUTTON1) || !isKeyDown(VK_BUTTON2)) {
 80486:     return false;
 38942:   }
 38942: 
 38942:   // See how far the mouse has moved since MB1-down to determine
 38942:   // the operation (this really ought to look for selected content).
 79445:   bool isCopy = false;
 38942:   if (abs(XFROMMP(mp1) - sLastButton1Down.x) >
 38942:         (WinQuerySysValue(HWND_DESKTOP, SV_CXMOTIONSTART) / 2) ||
 38942:       abs(YFROMMP(mp1) - sLastButton1Down.y) >
 38942:         (WinQuerySysValue(HWND_DESKTOP, SV_CYMOTIONSTART) / 2)) {
 80486:     isCopy = true;
 38942:   }
 38942: 
 80486:   nsKeyEvent event(true, NS_KEY_PRESS, this);
 38942:   nsIntPoint point(0,0);
 38942:   InitEvent(event, &point);
 38942: 
 38942:   event.keyCode     = NS_VK_INSERT;
 38942:   if (isCopy) {
 96893:     event.modifiers = widget::MODIFIER_CONTROL;
 38942:   } else {
 96893:     event.modifiers = widget::MODIFIER_SHIFT;
 38942:   }
 38942:   event.eventStructType = NS_KEY_EVENT;
 38942:   event.charCode    = 0;
 38942: 
 38942:   // OS/2 does not set the Shift, Ctrl, or Alt on keyup
 38942:   if (SHORT1FROMMP(mp1) & (KC_VIRTUALKEY | KC_KEYUP | KC_LONEKEY)) {
 38942:     USHORT usVKey = SHORT2FROMMP(mp2);
 38942:     if (usVKey == VK_SHIFT) {
 96893:       event.modifiers |= widget::MODIFIER_SHIFT;
 38942:     }
 38942:     if (usVKey == VK_CTRL) {
 96893:       event.modifiers |= widget::MODIFIER_CONTROL;
 38942:     }
 38942:     if (usVKey == VK_ALTGRAF || usVKey == VK_ALT) {
 96893:       event.modifiers |= widget::MODIFIER_ALT;
 38942:     }
 38942:   }
 38942: 
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //=============================================================================
     1: //  Drag & Drop - Target methods
 38942: //=============================================================================
     1: //
     1: // nsWindow knows almost nothing about d&d except that it can cause
     1: // video corruption if the screen is updated during a drag. It relies
     1: // on nsIDragSessionOS2 to handle native d&d messages and to return
     1: // the status flags it uses to control screen updates.
     1: //
     1: // OnDragDropMsg() handles all of the DM_* messages messages nsWindow
     1: // should ever receive.  CheckDragStatus() determines if a screen update
     1: // is safe and may return a drag HPS if doing so will avoid corruption.
     1: // As far as its author (R.Walsh) can tell, every use is required.
     1: //
     1: // For Moz drags, all while-you-drag features should be fully enabled &
     1: // corruption free;  for native drags, popups & scrolling are suppressed
     1: // but some niceties, e.g. moving the cursor in text fields, are enabled.
     1: //
 38942: //-----------------------------------------------------------------------------
     1: 
     1: // This method was designed to be totally ignorant of drag and drop.
     1: // It gives nsIDragSessionOS2 (near) complete control over handling.
     1: 
 79445: bool nsWindow::OnDragDropMsg(ULONG msg, MPARAM mp1, MPARAM mp2, MRESULT& mr)
     1: {
     1:   nsresult rv;
108991:   uint32_t eventType = 0;
108991:   uint32_t dragFlags = 0;
     1: 
     1:   mr = 0;
     1:   nsCOMPtr<nsIDragService> dragService =
     1:                     do_GetService("@mozilla.org/widget/dragservice;1", &rv);
     1:   if (dragService) {
     1:     nsCOMPtr<nsIDragSessionOS2> dragSession(
     1:                         do_QueryInterface(dragService, &rv));
     1:     if (dragSession) {
     1: 
     1:       // handle all possible input without regard to outcome
     1:       switch (msg) {
     1: 
     1:         case DM_DRAGOVER:
   482:           dragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
     1:           rv = dragSession->DragOverMsg((PDRAGINFO)mp1, mr, &dragFlags);
     1:           eventType = NS_DRAGDROP_OVER;
     1:           break;
     1: 
     1:         case DM_DRAGLEAVE:
     1:           rv = dragSession->DragLeaveMsg((PDRAGINFO)mp1, &dragFlags);
     1:           eventType = NS_DRAGDROP_EXIT;
     1:           break;
     1: 
     1:         case DM_DROP:
     1:           rv = dragSession->DropMsg((PDRAGINFO)mp1, mWnd, &dragFlags);
     1:           eventType = NS_DRAGDROP_DROP;
     1:           break;
     1: 
     1:         case DM_DROPHELP:
     1:           rv = dragSession->DropHelpMsg((PDRAGINFO)mp1, &dragFlags);
     1:           eventType = NS_DRAGDROP_EXIT;
     1:           break;
     1: 
     1:         case DM_RENDERCOMPLETE:
     1:           rv = dragSession->RenderCompleteMsg((PDRAGTRANSFER)mp1,
     1:                                               SHORT1FROMMP(mp2), &dragFlags);
     1:           eventType = NS_DRAGDROP_DROP;
     1:           break;
     1: 
     1:         default:
     1:           rv = NS_ERROR_FAILURE;
     1:       }
     1: 
     1:       // handle all possible outcomes without regard to their source
     1:       if (NS_SUCCEEDED(rv)) {
 38942:         mDragStatus = sDragStatus = (dragFlags & DND_DragStatus);
 38942: 
 38942:         if (dragFlags & DND_DispatchEnterEvent) {
     1:           DispatchDragDropEvent(NS_DRAGDROP_ENTER);
 38942:         }
 38942:         if (dragFlags & DND_DispatchEvent) {
     1:           DispatchDragDropEvent(eventType);
 38942:         }
 38942:         if (dragFlags & DND_GetDragoverResult) {
     1:           dragSession->GetDragoverResult(mr);
 38942:         }
 38942:         if (dragFlags & DND_ExitSession) {
     1:           dragSession->ExitSession(&dragFlags);
     1:         }
     1:       }
     1:     }
 38942:   }
     1:   // save final drag status
 38942:   sDragStatus = mDragStatus = (dragFlags & DND_DragStatus);
     1: 
 80486:   return true;
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
     1: // CheckDragStatus() concentrates all the hacks needed to avoid video
     1: // corruption during d&d into one place.  The caller specifies an action
     1: // that might be a problem;  the method tells it whether to proceed and
     1: // provides a Drg HPS if the situation calls for one.
     1: 
108991: bool nsWindow::CheckDragStatus(uint32_t aAction, HPS* aHps)
     1: {
 79445:   bool rtn    = true;
 79445:   bool getHps = false;
     1: 
     1:   switch (aAction) {
     1: 
     1:     // OnPaint() & Scroll..() - only Moz drags get a Drg hps
     1:     case ACTION_PAINT:
     1:     case ACTION_SCROLL:
 38942:       if (sDragStatus & DND_MozDrag) {
 80486:         getHps = true;
 38942:       }
     1:       break;
     1: 
     1:     // GetNativeData() - Moz drags + native drags over this nsWindow
     1:     case ACTION_DRAW:
 38942:       if ((sDragStatus & DND_MozDrag) ||
 38942:           (mDragStatus & DND_NativeDrag)) {
 80486:         getHps = true;
 38942:       }
     1:       break;
     1: 
     1:     // Show() - don't show popups during a native dragover
     1:     case ACTION_SHOW:
 38942:       if ((sDragStatus & (DND_NativeDrag | DND_InDrop)) == DND_NativeDrag) {
 80486:         rtn = false;
 38942:       }
     1:       break;
     1: 
     1:     // InitEvent() - use PtrPos while in drag, MsgPos otherwise
     1:     case ACTION_PTRPOS:
 38942:       if (!sDragStatus) {
 80486:         rtn = false;
 38942:       }
     1:       break;
     1: 
     1:     default:
 80486:       rtn = false;
     1:   }
     1: 
 38942:   // If the caller wants an HPS, and the current drag status
     1:   // calls for one, *and* a drag hps hasn't already been requested
     1:   // for this window, get the hps;  otherwise, return zero;
     1:   // (if we provide a 2nd hps for a window, the cursor in text
     1:   // fields won't be erased when it's moved to another position)
 38942:   if (aHps) {
     1:     if (getHps && !mDragHps) {
     1:       mDragHps = DrgGetPS(mWnd);
 38942:       *aHps = mDragHps;
 34518:     } else {
 38942:       *aHps = 0;
 34518:     }
 34518:   }
     1: 
     1:   return rtn;
     1: }
     1: 
 38942: //-----------------------------------------------------------------------------
 38942: // If there's an outstanding drag hps & it matches the one passed in,
 38942: // release it.
     1: 
 79445: bool nsWindow::ReleaseIfDragHPS(HPS aHps)
     1: {
     1:   if (mDragHps && aHps == mDragHps) {
     1:     DrgReleasePS(mDragHps);
     1:     mDragHps = 0;
 80486:     return true;
     1:   }
     1: 
 80486:   return false;
     1: }
     1: 
 38942: //=============================================================================
 38942: //  Keyboard Handlers
 38942: //=============================================================================
 38942: 
 38942: // Figure out which keyboard LEDs are on.
 38942: 
108991: NS_IMETHODIMP nsWindow::GetToggledKeyState(uint32_t aKeyCode, bool* aLEDState)
 38942: {
108991:   uint32_t  vkey;
 38942: 
 38942:   NS_ENSURE_ARG_POINTER(aLEDState);
 38942: 
 38942:   switch (aKeyCode) {
 38942:     case NS_VK_CAPS_LOCK:
 38942:       vkey = VK_CAPSLOCK;
 38942:       break;
 38942:     case NS_VK_NUM_LOCK:
 38942:       vkey = VK_NUMLOCK;
 38942:       break;
 38942:     case NS_VK_SCROLL_LOCK:
 38942:       vkey = VK_SCRLLOCK;
 38942:       break;
 38942:     default:
 80486:       *aLEDState = false;
 38942:       return NS_OK;
 38942:   }
 38942: 
 38942:   *aLEDState = (WinGetKeyState(HWND_DESKTOP, vkey) & 1) != 0;
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Prevent PM from translating some keys & key-combos into accelerators.
 38942: 
 79445: bool nsWindow::OnTranslateAccelerator(PQMSG pQmsg)
 38942: {
 38942:   if (pQmsg->msg != WM_CHAR) {
 80486:     return false;
 38942:   }
 38942: 
 38942:   LONG mp1 = (LONG)pQmsg->mp1;
 38942:   LONG mp2 = (LONG)pQmsg->mp2;
 38942:   LONG sca = SHORT1FROMMP(mp1) & (KC_SHIFT | KC_CTRL | KC_ALT);
 38942: 
 38942:   if (SHORT1FROMMP(mp1) & KC_VIRTUALKEY) {
 38942: 
 38942:     // standalone F1 & F10
 38942:     if (SHORT2FROMMP(mp2) == VK_F1 || SHORT2FROMMP(mp2) == VK_F10) {
 80486:       return (!sca ? true : false);
 38942:     }
 38942: 
 38942:     // Shift+Enter
 38942:     if (SHORT2FROMMP(mp2) == VK_ENTER) {
 80486:       return (sca == KC_SHIFT ? true : false);
 38942:     }
 38942: 
 38942:     // Alt+Enter
 38942:     if (SHORT2FROMMP(mp2) == VK_NEWLINE) {
 80486:       return (sca == KC_ALT ? true : false);
 38942:     }
 38942: 
 38942:     // standalone Alt & AltGraf
 38942:     if ((SHORT2FROMMP(mp2) == VK_ALT || SHORT2FROMMP(mp2) == VK_ALTGRAF) &&
 38942:         (SHORT1FROMMP(mp1) & (KC_KEYUP | KC_LONEKEY))
 38942:                           == (KC_KEYUP | KC_LONEKEY)) {
 80486:       return true;
 38942:     }
 38942:   }
 38942: 
 80486:   return false;
 38942: }
103455: bool nsWindow::OnQueryConvertPos(MPARAM mp1, MRESULT& mresult)
103455: {
103455:   PRECTL pCursorPos = (PRECTL)mp1;
103455: 
103455:   nsIntPoint point(0, 0);
103455: 
103455:   nsQueryContentEvent selection(true, NS_QUERY_SELECTED_TEXT, this);
103455:   InitEvent(selection, &point);
103455:   DispatchWindowEvent(&selection);
103455:   if (!selection.mSucceeded)
103455:     return false;
103455: 
103455:   nsQueryContentEvent caret(true, NS_QUERY_CARET_RECT, this);
103455:   caret.InitForQueryCaretRect(selection.mReply.mOffset);
103455:   InitEvent(caret, &point);
103455:   DispatchWindowEvent(&caret);
103455:   if (!caret.mSucceeded)
103455:     return false;
103455: 
103455:   pCursorPos->xLeft = caret.mReply.mRect.x;
103455:   pCursorPos->yBottom = caret.mReply.mRect.y;
103455:   pCursorPos->xRight = pCursorPos->xLeft + caret.mReply.mRect.width;
103455:   pCursorPos->yTop = pCursorPos->yBottom + caret.mReply.mRect.height;
103455:   NS2PM(*pCursorPos);
103455: 
103455:   mresult = (MRESULT)QCP_CONVERT;
103455: 
103455:   return true;
103455: }
103599: bool nsWindow::ImeResultString(HIMI himi)
103599: {
103599:   PCHAR pBuf;
103599:   ULONG ulBufLen;
103599: 
103599:   // Get a buffer size
103599:   ulBufLen = 0;
103599:   if (spfnImGetResultString(himi, IMR_RESULT_RESULTSTRING, NULL, &ulBufLen))
103599:     return false;
103599: 
103599:   pBuf = new CHAR[ulBufLen];
103599:   if (!pBuf)
103599:     return false;
103599: 
103599:   if (spfnImGetResultString(himi, IMR_RESULT_RESULTSTRING, pBuf,
103599:                             &ulBufLen)) {
103599:     delete pBuf;
103599: 
103599:     return false;
103599:   }
103599: 
103599:   if (!mIsComposing) {
104604:     mLastDispatchedCompositionString.Truncate();
104604: 
103599:     nsCompositionEvent start(true, NS_COMPOSITION_START, this);
103599:     InitEvent(start);
103599:     DispatchWindowEvent(&start);
103599: 
103599:     mIsComposing = true;
103599:   }
103599: 
103599:   nsAutoChar16Buffer outBuf;
108991:   int32_t outBufLen;
103599:   MultiByteToWideChar(0, pBuf, ulBufLen, outBuf, outBufLen);
103599: 
103599:   delete pBuf;
103599: 
104604:   nsAutoString compositionString(outBuf.Elements());
104604: 
104604:   if (mLastDispatchedCompositionString != compositionString) {
104604:     nsCompositionEvent update(true, NS_COMPOSITION_UPDATE, this);
104604:     InitEvent(update);
104604:     update.data = compositionString;
104604:     mLastDispatchedCompositionString = compositionString;
104604:     DispatchWindowEvent(&update);
104604:   }
104604: 
103599:   nsTextEvent text(true, NS_TEXT_TEXT, this);
103599:   InitEvent(text);
104604:   text.theText = compositionString;
103599:   DispatchWindowEvent(&text);
103599: 
103599:   nsCompositionEvent end(true, NS_COMPOSITION_END, this);
103599:   InitEvent(end);
104604:   end.data = compositionString;
103599:   DispatchWindowEvent(&end);
103599:   mIsComposing = false;
104604:   mLastDispatchedCompositionString.Truncate();
103599: 
103599:   return true;
103599: }
103599: 
103599: bool nsWindow::ImeConversionString(HIMI himi)
103599: {
103599:   PCHAR pBuf;
103599:   ULONG ulBufLen;
103599: 
103599:   // Get a buffer size
103599:   ulBufLen = 0;
103599:   if (spfnImGetConversionString(himi, IMR_CONV_CONVERSIONSTRING, NULL,
103599:                                 &ulBufLen))
103599:     return false;
103599: 
103599:   pBuf = new CHAR[ulBufLen];
103599:   if (!pBuf)
103599:     return false;
103599: 
103599:   if (spfnImGetConversionString(himi, IMR_CONV_CONVERSIONSTRING, pBuf,
103599:                                 &ulBufLen)) {
103599:     delete pBuf;
103599: 
103599:     return false;
103599:   }
103599: 
103599:   if (!mIsComposing) {
104604:     mLastDispatchedCompositionString.Truncate();
104604: 
103599:     nsCompositionEvent start(true, NS_COMPOSITION_START, this);
103599:     InitEvent(start);
103599:     DispatchWindowEvent(&start);
103599: 
103599:     mIsComposing = true;
103599:   }
103599: 
103599:   nsAutoChar16Buffer outBuf;
108991:   int32_t outBufLen;
103599:   MultiByteToWideChar(0, pBuf, ulBufLen, outBuf, outBufLen);
103599: 
103599:   delete pBuf;
103599: 
104604:   nsAutoString compositionString(outBuf.Elements());
104604: 
104604:   // Is a conversion string changed ?
104604:   if (mLastDispatchedCompositionString != compositionString) {
104604:     nsCompositionEvent update(true, NS_COMPOSITION_UPDATE, this);
104604:     InitEvent(update);
104604:     update.data = compositionString;
104604:     mLastDispatchedCompositionString = compositionString;
104604:     DispatchWindowEvent(&update);
104604:   }
104604: 
103599:   nsAutoTArray<nsTextRange, 4> textRanges;
103599: 
104604:   if (!compositionString.IsEmpty()) {
103599:     nsTextRange newRange;
103599:     newRange.mStartOffset = 0;
104604:     newRange.mEndOffset = compositionString.Length();
103599:     newRange.mRangeType = NS_TEXTRANGE_SELECTEDRAWTEXT;
103599:     textRanges.AppendElement(newRange);
103599: 
104604:     newRange.mStartOffset = compositionString.Length();
103599:     newRange.mEndOffset = newRange.mStartOffset;
103599:     newRange.mRangeType = NS_TEXTRANGE_CARETPOSITION;
103599:     textRanges.AppendElement(newRange);
103599:   }
103599: 
103599:   nsTextEvent text(true, NS_TEXT_TEXT, this);
103599:   InitEvent(text);
104604:   text.theText = compositionString;
103599:   text.rangeArray = textRanges.Elements();
103599:   text.rangeCount = textRanges.Length();
103599:   DispatchWindowEvent(&text);
103599: 
104604:   if (compositionString.IsEmpty()) { // IME conversion was canceled ?
103599:     nsCompositionEvent end(true, NS_COMPOSITION_END, this);
103599:     InitEvent(end);
104604:     end.data = compositionString;
103599:     DispatchWindowEvent(&end);
103599: 
103599:     mIsComposing = false;
104604:     mLastDispatchedCompositionString.Truncate();
103599:   }
103599: 
103599:   return true;
103599: }
103599: 
103599: bool nsWindow::OnImeRequest(MPARAM mp1, MPARAM mp2)
103599: {
103599:   HIMI himi;
103599:   bool rc;
103599: 
103599:   if (!sIm32Mod)
103599:     return false;
103599: 
103599:   if (SHORT1FROMMP(mp1) != IMR_CONVRESULT)
103599:     return false;
103599: 
103599:   if (spfnImGetInstance(mWnd, &himi))
103599:     return false;
103599: 
103599:   if (LONGFROMMP(mp2) & IMR_RESULT_RESULTSTRING)
103599:     rc = ImeResultString(himi);
103599:   else if (LONGFROMMP(mp2) & IMR_CONV_CONVERSIONSTRING)
103599:     rc = ImeConversionString(himi);
103599:   else
103599:     rc = true;
103599: 
103599:   spfnImReleaseInstance(mWnd, himi);
103599: 
103599:   return rc;
103599: }
 38942: 
120234: NS_IMETHODIMP_(InputContext) nsWindow::GetInputContext()
120234: {
120234:   HIMI himi;
120234:   if (sIm32Mod && spfnImGetInstance(mWnd, &himi)) {
120234:     mInputContext.mNativeIMEContext = static_cast<void*>(himi);
120234:   }
120234:   if (!mInputContext.mNativeIMEContext) {
120234:     mInputContext.mNativeIMEContext = this;
120234:   }
120234:   return mInputContext;
120234: }
120234: 
 38942: //-----------------------------------------------------------------------------
 38942: // Key handler.  Specs for the various text messages are really confused;
 38942: // see other platforms for best results of how things are supposed to work.
 38942: //
 38942: // Perhaps more importantly, the main man listening to these events
 38942: // (besides random bits of javascript) is ender -- see
 38942: // mozilla/editor/base/nsEditorEventListeners.cpp.
 38942: 
 79445: bool nsWindow::DispatchKeyEvent(MPARAM mp1, MPARAM mp2)
 38942: {
106838:   nsKeyEvent pressEvent(true, 0, nullptr);
 38942:   USHORT fsFlags = SHORT1FROMMP(mp1);
 38942:   USHORT usVKey = SHORT2FROMMP(mp2);
 38942:   USHORT usChar = SHORT1FROMMP(mp2);
 38942:   UCHAR uchScan = CHAR4FROMMP(mp1);
 38942: 
 38942:   // It appears we're not supposed to transmit shift,
 38942:   // control, & alt events to gecko.
 38942:   if (fsFlags & KC_VIRTUALKEY && !(fsFlags & KC_KEYUP) &&
 38942:       (usVKey == VK_SHIFT || usVKey == VK_CTRL || usVKey == VK_ALTGRAF)) {
 80486:     return false;
 38942:   }
 38942: 
 38942:   // Workaround bug where using Alt+Esc let an Alt key creep through
 38942:   // Only handle alt by itself if the LONEKEY bit is set
 38942:   if ((fsFlags & KC_VIRTUALKEY) && (usVKey == VK_ALT) && !usChar &&
 38942:       (!(fsFlags & KC_LONEKEY)) && (fsFlags & KC_KEYUP)) {
 80486:     return false;
 38942:   }
 38942: 
 38942:    // Now check if it's a dead-key
 38942:   if (fsFlags & KC_DEADKEY) {
 80486:     return true;
 38942:   }
 38942: 
 38942:   // Now dispatch a keyup/keydown event.  This one is *not* meant to
 38942:   // have the unicode charcode in.
 38942:   nsIntPoint point(0,0);
 80486:   nsKeyEvent event(true, (fsFlags & KC_KEYUP) ? NS_KEY_UP : NS_KEY_DOWN,
 38942:                    this);
 38942:   InitEvent(event, &point);
 38942:   event.keyCode   = WMChar2KeyCode(mp1, mp2);
 96893:   event.InitBasicModifiers(fsFlags & KC_CTRL, fsFlags & KC_ALT,
 96893:                            fsFlags & KC_SHIFT, false);
 38942:   event.charCode  = 0;
 38942: 
 38942:   // Check for a scroll mouse event vs. a keyboard event.  The way we know
 38942:   // this is that the repeat count is 0 and the key is not physically down.
 38942:   // Unfortunately, there is an exception here - if alt or ctrl are held
 38942:   // down, repeat count is set so we have to add special checks for them.
 38942:   if (((event.keyCode == NS_VK_UP) || (event.keyCode == NS_VK_DOWN)) &&
 38942:       !(fsFlags & KC_KEYUP) &&
 38942:       (!CHAR3FROMMP(mp1) || fsFlags & KC_CTRL || fsFlags & KC_ALT)) {
 38942:     if (!(WinGetPhysKeyState(HWND_DESKTOP, uchScan) & 0x8000)) {
 38942:       MPARAM mp2;
 38942:       if (event.keyCode == NS_VK_UP) {
 38942:         mp2 = MPFROM2SHORT(0, SB_LINEUP);
 38942:       } else {
 38942:         mp2 = MPFROM2SHORT(0, SB_LINEDOWN);
 38942:       }
 38942:       WinSendMsg(mWnd, WM_VSCROLL, 0, mp2);
 38942:       return FALSE;
 38942:     }
 38942:   }
 38942: 
 38942:   pressEvent = event;
 79445:   bool rc = DispatchWindowEvent(&event);
 38942: 
 38942:   // Break off now if this was a key-up.
 38942:   if (fsFlags & KC_KEYUP) {
 38942:     return rc;
 38942:   }
 38942: 
 38942:   // Break off if we've got an "invalid composition" -- that is,
 38942:   // the user typed a deadkey last time, but has now typed something
 38942:   // that doesn't make sense in that context.
 38942:   if (fsFlags & KC_INVALIDCOMP) {
 38942:     // actually, not sure whether we're supposed to abort the keypress
 38942:     // or process it as though the dead key has been pressed.
 38942:     return rc;
 38942:   }
 38942: 
 38942:   // Now we need to dispatch a keypress event which has the unicode char.
 38942:   // If keydown default was prevented, do same for keypress
 38942:   pressEvent.message = NS_KEY_PRESS;
 38942:   if (rc) {
 38942:     pressEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 38942:   }
 38942: 
 38942:   if (usChar) {
 38942:     USHORT inbuf[2];
 38942:     inbuf[0] = usChar;
 38942:     inbuf[1] = '\0';
 38942: 
 38942:     nsAutoChar16Buffer outbuf;
108991:     int32_t bufLength;
 38942:     MultiByteToWideChar(0, (const char*)inbuf, 2, outbuf, bufLength);
 38942: 
 38942:     pressEvent.charCode = outbuf[0];
 38942: 
 96893:     if (pressEvent.IsControl() && !(fsFlags & (KC_VIRTUALKEY | KC_DEADKEY))) {
 96893:       if (!pressEvent.IsShift() && (pressEvent.charCode >= 'A' && pressEvent.charCode <= 'Z')) {
 38942:         pressEvent.charCode = tolower(pressEvent.charCode);
 38942:       }
 96893:       if (pressEvent.IsShift() && (pressEvent.charCode >= 'a' && pressEvent.charCode <= 'z')) {
 38942:         pressEvent.charCode = toupper(pressEvent.charCode);
 38942:       }
 38942:       pressEvent.keyCode = 0;
 96893:     } else if (!pressEvent.IsControl() && !pressEvent.IsAlt() && pressEvent.charCode != 0) {
 38942:       if (!(fsFlags & KC_VIRTUALKEY) || // not virtual key
 38942:           ((fsFlags & KC_CHAR) && !pressEvent.keyCode)) {
 38942:         pressEvent.keyCode = 0;
 38942:       } else if (usVKey == VK_SPACE) {
 38942:         // space key, do nothing here
 38942:       } else if ((fsFlags & KC_VIRTUALKEY) &&
 38942:                  isNumPadScanCode(uchScan) && pressEvent.keyCode != 0 && isNumlockOn) {
 38942:         // this is NumLock+Numpad (no Alt), handle this like a normal number
 38942:         pressEvent.keyCode = 0;
 38942:       } else { // Real virtual key
 38942:         pressEvent.charCode = 0;
 38942:       }
 38942:     }
 38942:     rc = DispatchWindowEvent(&pressEvent);
 38942:   }
 38942: 
 38942:   return rc;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Helper function to translate from a WM_CHAR to an NS_VK_ constant.
 38942: 
 38942: static
108991: uint32_t WMChar2KeyCode(MPARAM mp1, MPARAM mp2)
     1: {
108991:   uint32_t rc = SHORT1FROMMP(mp2);  // character code
108991:   uint32_t rcmask = rc & 0x00FF;    // masked character code for key up events
     1:   USHORT sc = CHAR4FROMMP(mp1);     // scan code
     1:   USHORT flags = SHORT1FROMMP(mp1); // flag word
     1: 
     1:   // First check for characters.
     1:   // This is complicated by keystrokes such as Ctrl+K not having the KC_CHAR
     1:   // bit set, but thankfully they do have the character actually there.
 38942: 
     1:   // Assume that `if not vkey or deadkey or valid number then char'
     1:   if (!(flags & (KC_VIRTUALKEY | KC_DEADKEY)) ||
     1:       (rcmask >= '0' && rcmask <= '9' &&             // handle keys on Numpad, too,
     1:        (isNumPadScanCode(sc) ? isNumlockOn : 1))) { // if NumLock is on
     1:     if (flags & KC_KEYUP) { // On OS/2 the scancode is in the upper byte of
     1:                             // usChar when KC_KEYUP is set so mask it off
     1:       rc = rcmask;
     1:     } else { // not KC_KEYUP
     1:       if (!(flags & KC_CHAR)) {
 38942:         if ((flags & KC_ALT) || (flags & KC_CTRL)) {
     1:           rc = rcmask;
 38942:         } else {
     1:           rc = 0;
     1:         }
     1:       }
 38942:     }
     1: 
     1:     if (rc < 0xFF) {
     1:       if (rc >= 'a' && rc <= 'z') { // The DOM_VK are for upper case only so
     1:                                     // if rc is lower case upper case it.
     1:         rc = rc - 'a' + NS_VK_A;
     1:       } else if (rc >= 'A' && rc <= 'Z') { // Upper case
     1:         rc = rc - 'A' + NS_VK_A;
     1:       } else if (rc >= '0' && rc <= '9') {
     1:         // Number keys, including Numpad if NumLock is not set
     1:         rc = rc - '0' + NS_VK_0;
     1:       } else {
 38942:         // For some characters, map the scan code to the NS_VK value
 38942:         // This only happens in the char case NOT the VK case!
     1:         switch (sc) {
     1:           case 0x02: rc = NS_VK_1;             break;
     1:           case 0x03: rc = NS_VK_2;             break;
     1:           case 0x04: rc = NS_VK_3;             break;
     1:           case 0x05: rc = NS_VK_4;             break;
     1:           case 0x06: rc = NS_VK_5;             break;
     1:           case 0x07: rc = NS_VK_6;             break;
     1:           case 0x08: rc = NS_VK_7;             break;
     1:           case 0x09: rc = NS_VK_8;             break;
     1:           case 0x0A: rc = NS_VK_9;             break;
     1:           case 0x0B: rc = NS_VK_0;             break;
     1:           case 0x0D: rc = NS_VK_EQUALS;        break;
     1:           case 0x1A: rc = NS_VK_OPEN_BRACKET;  break;
     1:           case 0x1B: rc = NS_VK_CLOSE_BRACKET; break;
     1:           case 0x27: rc = NS_VK_SEMICOLON;     break;
     1:           case 0x28: rc = NS_VK_QUOTE;         break;
     1:           case 0x29: rc = NS_VK_BACK_QUOTE;    break;
     1:           case 0x2B: rc = NS_VK_BACK_SLASH;    break;
     1:           case 0x33: rc = NS_VK_COMMA;         break;
     1:           case 0x34: rc = NS_VK_PERIOD;        break;
     1:           case 0x35: rc = NS_VK_SLASH;         break;
     1:           case 0x37: rc = NS_VK_MULTIPLY;      break;
     1:           case 0x4A: rc = NS_VK_SUBTRACT;      break;
     1:           case 0x4C: rc = NS_VK_CLEAR;         break; // numeric case is handled above
     1:           case 0x4E: rc = NS_VK_ADD;           break;
     1:           case 0x5C: rc = NS_VK_DIVIDE;        break;
     1:           default: break;
     1:         } // switch
     1:       } // else
     1:     } // if (rc < 0xFF)
     1:   } else if (flags & KC_VIRTUALKEY) {
     1:     USHORT vk = SHORT2FROMMP(mp2);
     1:     if (flags & KC_KEYUP) { // On OS/2 there are extraneous bits in the upper byte of
     1:                             // usChar when KC_KEYUP is set so mask them off
     1:       rc = rcmask;
     1:     }
     1:     if (isNumPadScanCode(sc) &&
     1:         (((flags & KC_ALT) && (sc != PMSCAN_PADPERIOD)) ||
     1:           ((flags & (KC_CHAR | KC_SHIFT)) == KC_CHAR)  ||
     1:           ((flags & KC_KEYUP) && rc != 0))) {
     1:       CHAR numpadMap[] = {NS_VK_NUMPAD7, NS_VK_NUMPAD8, NS_VK_NUMPAD9, 0,
     1:                           NS_VK_NUMPAD4, NS_VK_NUMPAD5, NS_VK_NUMPAD6, 0,
     1:                           NS_VK_NUMPAD1, NS_VK_NUMPAD2, NS_VK_NUMPAD3,
     1:                           NS_VK_NUMPAD0, NS_VK_DECIMAL};
     1:       // If this is the Numpad must not return VK for ALT+Numpad or ALT+NumLock+Numpad
     1:       // NumLock+Numpad is OK
     1:       if (numpadMap[sc - PMSCAN_PAD7] != 0) { // not plus or minus on Numpad
 38942:         if (flags & KC_ALT) { // do not react on Alt plus ASCII-code sequences
     1:           rc = 0;
 38942:         } else {
     1:           rc = numpadMap[sc - PMSCAN_PAD7];
 38942:         }
     1:       } else {                                // plus or minus of Numpad
     1:         rc = 0; // No virtual key for Alt+Numpad or NumLock+Numpad
     1:       }
     1:     } else if (!(flags & KC_CHAR) || isNumPadScanCode(sc) ||
     1:                (vk == VK_BACKSPACE) || (vk == VK_TAB) || (vk == VK_BACKTAB) ||
     1:                (vk == VK_ENTER) || (vk == VK_NEWLINE) || (vk == VK_SPACE)) {
     1:       if (vk >= VK_F1 && vk <= VK_F24) {
     1:         rc = NS_VK_F1 + (vk - VK_F1);
     1:       }
     1:       else switch (vk) {
     1:         case VK_NUMLOCK:   rc = NS_VK_NUM_LOCK; break;
     1:         case VK_SCRLLOCK:  rc = NS_VK_SCROLL_LOCK; break;
     1:         case VK_ESC:       rc = NS_VK_ESCAPE; break; // NS_VK_CANCEL
     1:         case VK_BACKSPACE: rc = NS_VK_BACK; break;
     1:         case VK_TAB:       rc = NS_VK_TAB; break;
     1:         case VK_BACKTAB:   rc = NS_VK_TAB; break; // layout tests for isShift
     1:         case VK_CLEAR:     rc = NS_VK_CLEAR; break;
     1:         case VK_NEWLINE:   rc = NS_VK_RETURN; break;
     1:         case VK_ENTER:     rc = NS_VK_RETURN; break;
     1:         case VK_SHIFT:     rc = NS_VK_SHIFT; break;
     1:         case VK_CTRL:      rc = NS_VK_CONTROL; break;
     1:         case VK_ALT:       rc = NS_VK_ALT; break;
     1:         case VK_PAUSE:     rc = NS_VK_PAUSE; break;
     1:         case VK_CAPSLOCK:  rc = NS_VK_CAPS_LOCK; break;
     1:         case VK_SPACE:     rc = NS_VK_SPACE; break;
     1:         case VK_PAGEUP:    rc = NS_VK_PAGE_UP; break;
     1:         case VK_PAGEDOWN:  rc = NS_VK_PAGE_DOWN; break;
     1:         case VK_END:       rc = NS_VK_END; break;
     1:         case VK_HOME:      rc = NS_VK_HOME; break;
     1:         case VK_LEFT:      rc = NS_VK_LEFT; break;
     1:         case VK_UP:        rc = NS_VK_UP; break;
     1:         case VK_RIGHT:     rc = NS_VK_RIGHT; break;
     1:         case VK_DOWN:      rc = NS_VK_DOWN; break;
     1:         case VK_PRINTSCRN: rc = NS_VK_PRINTSCREEN; break;
     1:         case VK_INSERT:    rc = NS_VK_INSERT; break;
     1:         case VK_DELETE:    rc = NS_VK_DELETE; break;
     1:       } // switch
     1:     }
     1:   } // KC_VIRTUALKEY
     1: 
     1:   return rc;
     1: }
     1: 
 38942: //=============================================================================
 38942: //  Event Dispatch
 38942: //=============================================================================
 38942: 
 38942: // Initialize an event to dispatch.
 38942: 
 38942: void nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
     1: {
 38942:   // if no point was supplied, calculate it
 38942:   if (!aPoint) {
 38942:     // for most events, get the message position;  for drag events,
 38942:     // msg position may be incorrect, so get the current position instead
 38942:     POINTL ptl;
 38942:     if (CheckDragStatus(ACTION_PTRPOS, 0)) {
 38942:       WinQueryPointerPos(HWND_DESKTOP, &ptl);
 38942:     } else {
 38942:       WinQueryMsgPos(0, &ptl);
 38942:     }
 38942: 
 38942:     WinMapWindowPoints(HWND_DESKTOP, mWnd, &ptl, 1);
 38942:     PM2NS(ptl);
 38942:     event.refPoint.x = ptl.x;
 38942:     event.refPoint.y = ptl.y;
 38942:   } else {
 38942:     // use the point override if provided
 38942:     event.refPoint.x = aPoint->x;
 38942:     event.refPoint.y = aPoint->y;
 38942:   }
 38942: 
 38942:   event.time = WinQueryMsgTime(0);
 38942:   return;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Invoke the Event Listener object's callback.
 38942: 
 38942: NS_IMETHODIMP nsWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
     1: {
 38942:   aStatus = nsEventStatus_eIgnore;
 38942: 
 38942:   if (!mEventCallback) {
 38942:     return NS_OK;
 38942:   }
 38942: 
 38942:   // if state is eDoingDelete, don't send out anything
108453:   if (mWindowState & nsWindowState_eLive) {
 38942:     aStatus = (*mEventCallback)(event);
 38942:   }
 38942:   return NS_OK;
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 54312: NS_IMETHODIMP nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
 54312: {
 54312:   NS_PRECONDITION(aNewParent, "");
 54312:   return NS_ERROR_NOT_IMPLEMENTED;
 54312: }
 54312: 
 54312: //-----------------------------------------------------------------------------
 54312: 
 79445: bool nsWindow::DispatchWindowEvent(nsGUIEvent* event)
     1: {
 38942:   nsEventStatus status;
 38942:   DispatchEvent(event, status);
 38942:   return (status == nsEventStatus_eConsumeNoDefault);
 38942: }
 38942: 
 79445: bool nsWindow::DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus) {
 38942:   DispatchEvent(event, aStatus);
 38942:   return (aStatus == nsEventStatus_eConsumeNoDefault);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: bool nsWindow::DispatchCommandEvent(uint32_t aEventCommand)
     1: {
 38942:   nsCOMPtr<nsIAtom> command;
 38942: 
 38942:   switch (aEventCommand) {
 38942:     case APPCOMMAND_BROWSER_BACKWARD:
 80435:       command = nsGkAtoms::Back;
 38942:       break;
 38942:     case APPCOMMAND_BROWSER_FORWARD:
 80435:       command = nsGkAtoms::Forward;
 38942:       break;
 38942:     case APPCOMMAND_BROWSER_REFRESH:
 80435:       command = nsGkAtoms::Reload;
 38942:       break;
 38942:     case APPCOMMAND_BROWSER_STOP:
 80435:       command = nsGkAtoms::Stop;
 38942:       break;
 38942:     default:
 80486:       return false;
 38942:   }
 38942: 
 80486:   nsCommandEvent event(true, nsGkAtoms::onAppCommand, command, this);
 38942:   InitEvent(event);
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: bool nsWindow::DispatchDragDropEvent(uint32_t aMsg)
 38942: {
 80486:   nsDragEvent event(true, aMsg, this);
 38942:   InitEvent(event);
 38942: 
 96893:   event.InitBasicModifiers(isKeyDown(VK_CTRL),
 96893:                            isKeyDown(VK_ALT) || isKeyDown(VK_ALTGRAF),
 96893:                            isKeyDown(VK_SHIFT), false);
 38942: 
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: bool nsWindow::DispatchMoveEvent(int32_t aX, int32_t aY)
 38942: {
 38942:   // Params here are in XP-space for the desktop
 80486:   nsGUIEvent event(true, NS_MOVE, this);
 38942:   nsIntPoint point(aX, aY);
 38942:   InitEvent(event, &point);
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
108991: bool nsWindow::DispatchResizeEvent(int32_t aX, int32_t aY)
 38942: {
 80486:   nsSizeEvent event(true, NS_SIZE, this);
 38942:   nsIntRect   rect(0, 0, aX, aY);
 38942: 
 38942:   InitEvent(event);
 38942:   event.windowSize = &rect;             // this is the *client* rectangle
 38942:   event.mWinWidth = mBounds.width;
 38942:   event.mWinHeight = mBounds.height;
 38942: 
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Deal with all sorts of mouse events.
 38942: 
108991: bool nsWindow::DispatchMouseEvent(uint32_t aEventType, MPARAM mp1, MPARAM mp2,
108991:                                     bool aIsContextMenuKey, int16_t aButton)
 38942: {
 80486:   NS_ENSURE_TRUE(aEventType, false);
 80486: 
 80486:   nsMouseEvent event(true, aEventType, this, nsMouseEvent::eReal,
 38942:                      aIsContextMenuKey
 38942:                      ? nsMouseEvent::eContextMenuKey
 38942:                      : nsMouseEvent::eNormal);
 38942:   event.button = aButton;
103599:   if (aEventType == NS_MOUSE_BUTTON_DOWN && mIsComposing) {
103599:     // If IME is composing, let it complete.
103599:     HIMI himi;
103599: 
103599:     spfnImGetInstance(mWnd, &himi);
103599:     spfnImRequestIME(himi, REQ_CONVERSIONSTRING, CNV_COMPLETE, 0);
103599:     spfnImReleaseInstance(mWnd, himi);
103599:   }
 38942: 
 50878:   if (aEventType == NS_MOUSE_ENTER || aEventType == NS_MOUSE_EXIT) {
 50878:     // Ignore enter/leave msgs forwarded from the frame to FID_CLIENT
 50878:     // because we're only interested msgs involving the content area.
 50878:     if (HWNDFROMMP(mp1) != mWnd) {
 50878:       return FALSE;
 50878:     }
 50878: 
 50878:     // If the mouse has exited the content area and entered either an
 50878:     // unrelated window or what Windows would call the nonclient area
 50878:     // (i.e. frame, titlebar, etc.), mark this as a toplevel exit.
 50878:     // Note: exits to and from menus will also be marked toplevel.
 50878:     if (aEventType == NS_MOUSE_EXIT) {
 55811:       HWND  hTop = 0;
 50878:       HWND  hCur = mWnd;
 50878:       HWND  hDesk = WinQueryDesktopWindow(0, 0);
 50878:       while (hCur && hCur != hDesk) {
 50878:         hTop = hCur;
 50878:         hCur = WinQueryWindow(hCur, QW_PARENT);
 50878:       }
 50878: 
 50878:       // event.exit was init'ed to eChild, so we don't need an 'else'
 50878:       hTop = WinWindowFromID(hTop, FID_CLIENT);
 50878:       if (!hTop || !WinIsChild(HWNDFROMMP(mp2), hTop)) {
 50878:         event.exit = nsMouseEvent::eTopLevel;
 50878:       }
 50878:     }
 50878: 
106838:     InitEvent(event, nullptr);
 96893:     event.InitBasicModifiers(isKeyDown(VK_CTRL),
 96893:                              isKeyDown(VK_ALT) || isKeyDown(VK_ALTGRAF),
 96893:                              isKeyDown(VK_SHIFT), false);
 50878:   } else {
 38942:     POINTL ptl;
 38942:     if (aEventType == NS_CONTEXTMENU && aIsContextMenuKey) {
 38942:       WinQueryPointerPos(HWND_DESKTOP, &ptl);
 38942:       WinMapWindowPoints(HWND_DESKTOP, mWnd, &ptl, 1);
     1:     } else {
 38942:       ptl.x = (SHORT)SHORT1FROMMP(mp1);
 38942:       ptl.y = (SHORT)SHORT2FROMMP(mp1);
 38942:     }
 38942:     PM2NS(ptl);
 38942:     nsIntPoint pt(ptl.x, ptl.y);
 38942:     InitEvent(event, &pt);
 38942: 
 38942:     USHORT usFlags  = SHORT2FROMMP(mp2);
 96893:     event.InitBasicModifiers(usFlags & KC_CTRL, usFlags & KC_ALT,
 96893:                              usFlags & KC_SHIFT, false);
 38942:   }
 38942: 
 38942:   // Dblclicks are used to set the click count, then changed to mousedowns
 38942:   if (aEventType == NS_MOUSE_DOUBLECLICK &&
 38942:       (aButton == nsMouseEvent::eLeftButton ||
 38942:        aButton == nsMouseEvent::eRightButton)) {
 38942:     event.message = NS_MOUSE_BUTTON_DOWN;
 38942:     event.button = (aButton == nsMouseEvent::eLeftButton) ?
 38942:                    nsMouseEvent::eLeftButton : nsMouseEvent::eRightButton;
 38942:     event.clickCount = 2;
 38942:   } else {
 38942:     event.clickCount = 1;
 38942:   }
 38942: 
 38942:   NPEvent pluginEvent;
 38942:   switch (aEventType) {
 38942: 
 38942:     case NS_MOUSE_BUTTON_DOWN:
 38942:       switch (aButton) {
 38942:         case nsMouseEvent::eLeftButton:
 38942:           pluginEvent.event = WM_BUTTON1DOWN;
 38942:           break;
 38942:         case nsMouseEvent::eMiddleButton:
 38942:           pluginEvent.event = WM_BUTTON3DOWN;
 38942:           break;
 38942:         case nsMouseEvent::eRightButton:
 38942:           pluginEvent.event = WM_BUTTON2DOWN;
 38942:           break;
 38942:         default:
 38942:           break;
 38942:       }
 38942:       break;
 38942: 
 38942:     case NS_MOUSE_BUTTON_UP:
 38942:       switch (aButton) {
 38942:         case nsMouseEvent::eLeftButton:
 38942:           pluginEvent.event = WM_BUTTON1UP;
 38942:           break;
 38942:         case nsMouseEvent::eMiddleButton:
 38942:           pluginEvent.event = WM_BUTTON3UP;
 38942:           break;
 38942:         case nsMouseEvent::eRightButton:
 38942:           pluginEvent.event = WM_BUTTON2UP;
 38942:           break;
 38942:         default:
 38942:           break;
 38942:       }
 38942:       break;
 38942: 
 38942:     case NS_MOUSE_DOUBLECLICK:
 38942:       switch (aButton) {
 38942:         case nsMouseEvent::eLeftButton:
 38942:           pluginEvent.event = WM_BUTTON1DBLCLK;
 38942:           break;
 38942:         case nsMouseEvent::eMiddleButton:
 38942:           pluginEvent.event = WM_BUTTON3DBLCLK;
 38942:           break;
 38942:         case nsMouseEvent::eRightButton:
 38942:           pluginEvent.event = WM_BUTTON2DBLCLK;
 38942:           break;
 38942:         default:
 38942:           break;
 38942:       }
 38942:       break;
 38942: 
 38942:     case NS_MOUSE_MOVE:
 38942:       pluginEvent.event = WM_MOUSEMOVE;
 38942:       break;
 38942:   }
 38942: 
 38942:   pluginEvent.wParam = 0;
 38942:   pluginEvent.lParam = MAKELONG(event.refPoint.x, event.refPoint.y);
 38942: 
 38942:   event.pluginEvent = (void*)&pluginEvent;
 38942: 
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: // Signal plugin & top-level window activation.
 38942: 
108991: bool nsWindow::DispatchActivationEvent(uint32_t aEventType)
 38942: {
 80486:   nsGUIEvent event(true, aEventType, this);
 38942: 
 38942:   // These events should go to their base widget location,
 38942:   // not current mouse position.
 38942:   nsIntPoint point(0, 0);
 38942:   InitEvent(event, &point);
 38942: 
 38942:   NPEvent pluginEvent;
 38942:   switch (aEventType) {
 38942:     case NS_ACTIVATE:
 38942:       pluginEvent.event = WM_SETFOCUS;
 38942:       break;
 38942:     case NS_DEACTIVATE:
 38942:       pluginEvent.event = WM_FOCUSCHANGED;
 38942:       break;
 38942:     case NS_PLUGIN_ACTIVATE:
 38942:       pluginEvent.event = WM_FOCUSCHANGED;
 38942:       break;
 38942:   }
 38942:   event.pluginEvent = (void*)&pluginEvent;
 38942: 
 38942:   return DispatchWindowEvent(&event);
 38942: }
 38942: 
 38942: //-----------------------------------------------------------------------------
 38942: 
 79445: bool nsWindow::DispatchScrollEvent(ULONG msg, MPARAM mp1, MPARAM mp2)
 38942: {
108074:   WheelEvent wheelEvent(true, NS_WHEEL_WHEEL, this);
108074:   InitEvent(wheelEvent);
108074: 
108074:   wheelEvent.InitBasicModifiers(isKeyDown(VK_CTRL),
 96893:                                 isKeyDown(VK_ALT) || isKeyDown(VK_ALTGRAF),
 96893:                                 isKeyDown(VK_SHIFT), false);
 38942:   // The SB_* constants for analogous vertical & horizontal ops have the
 38942:   // the same values, so only use the verticals to avoid compiler errors.
108991:   int32_t delta;
 38942:   switch (SHORT2FROMMP(mp2)) {
 38942:     case SB_LINEUP:
 38942:     //   SB_LINELEFT:
108074:       wheelEvent.deltaMode = nsIDOMWheelEvent.DOM_DELTA_LINE;
108074:       delta = -1;
 38942:       break;
 38942: 
 38942:     case SB_LINEDOWN:
 38942:     //   SB_LINERIGHT:
108074:       wheelEvent.deltaMode = nsIDOMWheelEvent.DOM_DELTA_LINE;
108074:       delta = 1;
 38942:       break;
 38942: 
 38942:     case SB_PAGEUP:
 38942:     //   SB_PAGELEFT:
108074:       wheelEvent.deltaMode = nsIDOMWheelEvent.DOM_DELTA_PAGE;
108074:       delta = -1;
 38942:       break;
 38942: 
 38942:     case SB_PAGEDOWN:
 38942:     //   SB_PAGERIGHT:
108074:       wheelEvent.deltaMode = nsIDOMWheelEvent.DOM_DELTA_PAGE;
108074:       delta = 1;
 38942:       break;
 38942: 
 38942:     default:
 80486:       return false;
 38942:   }
 38942: 
108074:   if (msg == WM_HSCROLL) {
108074:     wheelEvent.deltaX = wheelEvent.lineOrPageDeltaX = delta;
108074:   } else {
108074:     wheelEvent.deltaY = wheelEvent.lineOrPageDeltaY = delta;
108074:   }
108074: 
108074:   DispatchWindowEvent(&wheelEvent);
108074: 
108074:   return false;
108074: }
108074: 
 38942: //=============================================================================
 38942: 
