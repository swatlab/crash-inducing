37281: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
37281: /* ***** BEGIN LICENSE BLOCK *****
37281:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
37281:  *
37281:  * The contents of this file are subject to the Mozilla Public License Version
37281:  * 1.1 (the "License"); you may not use this file except in compliance with
37281:  * the License. You may obtain a copy of the License at
37281:  * http://www.mozilla.org/MPL/
37281:  *
37281:  * Software distributed under the License is distributed on an "AS IS" basis,
37281:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37281:  * for the specific language governing rights and limitations under the
37281:  * License.
37281:  *
37281:  * The Original Code is mozilla.org code.
37281:  *
37281:  * The Initial Developer of the Original Code is
60746:  * Mozilla Foundation.
37281:  * Portions created by the Initial Developer are Copyright (C) 2010
37281:  * the Initial Developer. All Rights Reserved.
37281:  *
37281:  * Contributor(s):
37281:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
37281:  *
37281:  * Alternatively, the contents of this file may be used under the terms of
37281:  * either of the GNU General Public License Version 2 or later (the "GPL"),
37281:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37281:  * in which case the provisions of the GPL or the LGPL are applicable instead
37281:  * of those above. If you wish to allow use of your version of this file only
37281:  * under the terms of either the GPL or the LGPL, and not to allow others to
37281:  * use your version of this file under the terms of the MPL, indicate your
37281:  * decision by deleting the provisions above and replace them with the notice
37281:  * and other provisions required by the GPL or the LGPL. If you do not delete
37281:  * the provisions above, a recipient may use your version of this file under
37281:  * the terms of any one of the MPL, the GPL or the LGPL.
37281:  *
37281:  * ***** END LICENSE BLOCK ***** */
37281: 
60746: #ifndef NotificationController_h_
60746: #define NotificationController_h_
37281: 
51377: #include "AccEvent.h"
60746: #include "nsCycleCollectionParticipant.h"
39509: 
60746: class nsAccessible;
60746: class nsDocAccessible;
60746: class nsIContent;
41384: 
60746: // Uncomment to log notifications processing.
60746: //#define DEBUG_NOTIFICATIONS
39509: 
60746: #ifdef DEBUG_NOTIFICATIONS
60746: #define DEBUG_CONTENTMUTATION
60746: #endif
37281: 
37537: /**
60746:  * Notification interface.
37537:  */
60746: class Notification
37281: {
37281: public:
60746:   virtual ~Notification() { };
60746: 
60746:   NS_INLINE_DECL_REFCOUNTING(Notification)
37281: 
37281:   /**
60746:    * Process notification.
37282:    */
60746:   virtual void Process() = 0;
60746: 
60746: protected:
60746:   Notification() { }
60746: 
60746: private:
60746:   Notification(const Notification&);
60746:   Notification& operator = (const Notification&);
60746: };
60746: 
37282: 
37282: /**
60746:  * Template class for generic notification.
37281:  *
60746:  * @note  Instance is kept as a weak ref, the caller must guarantee it exists
60746:  *        longer than the document accessible owning the notification controller
60746:  *        that this notification is processed by.
37281:  */
60746: template<class Class, class Arg>
60746: class TNotification : public Notification
60746: {
60746: public:
60746:   typedef void (Class::*Callback)(Arg*);
60746: 
60746:   TNotification(Class* aInstance, Callback aCallback, Arg* aArg) :
60746:     mInstance(aInstance), mCallback(aCallback), mArg(aArg) { }
60746:   virtual ~TNotification() { mInstance = nsnull; }
60746: 
60746:   virtual void Process()
60746:   {
60746:     (mInstance->*mCallback)(mArg);
60746: 
60746:     mInstance = nsnull;
60746:     mCallback = nsnull;
60746:     mArg = nsnull;
60746:   }
60746: 
60746: private:
60746:   TNotification(const TNotification&);
60746:   TNotification& operator = (const TNotification&);
60746: 
60746:   Class* mInstance;
60746:   Callback mCallback;
60746:   nsCOMPtr<Arg> mArg;
60746: };
37339: 
37339: /**
60746:  * Used to process notifications from core for the document accessible.
37339:  */
60746: class NotificationController : public nsARefreshObserver
60746: {
60746: public:
60746:   NotificationController(nsDocAccessible* aDocument, nsIPresShell* aPresShell);
60746:   virtual ~NotificationController();
37339: 
60746:   NS_IMETHOD_(nsrefcnt) AddRef(void);
60746:   NS_IMETHOD_(nsrefcnt) Release(void);
37281: 
60746:   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(NotificationController)
37537: 
37537:   /**
61317:    * Return true when tree is constructed.
61317:    */
61317:   inline bool IsTreeConstructed()
61317:   {
61317:     return mTreeConstructedState == eTreeConstructed;
61317:   }
61317: 
61317:   /**
60746:    * Shutdown the notification controller.
37537:    */
37537:   void Shutdown();
37537: 
60746:   /**
60746:    * Put an accessible event into the queue to process it later.
60746:    */
60746:   void QueueEvent(AccEvent* aEvent);
37537: 
37537:   /**
61317:    * Schedule binding the child document to the tree of this document.
61317:    */
61317:   void ScheduleChildDocBinding(nsDocAccessible* aDocument);
61317: 
61317:   /**
61516:    * Schedule the accessible tree update because of rendered text changes.
61516:    */
61516:   inline void ScheduleTextUpdate(nsIContent* aTextNode)
61516:   {
61516:     // Ignore the notification if initial tree construction hasn't been done yet.
61637:     if (mTreeConstructedState != eTreeConstructionPending &&
61637:         mTextHash.PutEntry(aTextNode)) {
61637:       ScheduleProcessing();
61637:     }
61516:   }
61516: 
61516:   /**
61638:    * Cancel pending text update.
61638:    */
61638:   inline void CancelTextUpdate(nsIContent* aTextNode)
61638:   {
61638:     mTextHash.RemoveEntry(aTextNode);
61638:   }
61638: 
61638:   /**
60746:    * Pend accessible tree update for content insertion.
37537:    */
60746:   void ScheduleContentInsertion(nsAccessible* aContainer,
60746:                                 nsIContent* aStartChildNode,
60746:                                 nsIContent* aEndChildNode);
37537: 
37537:   /**
60746:    * Process the generic notification synchronously if there are no pending
60746:    * layout changes and no notifications are pending or being processed right
60746:    * now. Otherwise, queue it up to process asynchronously.
60746:    *
60746:    * @note  The caller must guarantee that the given instance still exists when
60746:    *        the notification is processed.
37537:    */
60746:   template<class Class, class Arg>
60746:   inline void HandleNotification(Class* aInstance,
60746:                                  typename TNotification<Class, Arg>::Callback aMethod,
60746:                                  Arg* aArg)
60746:   {
60746:     if (!IsUpdatePending()) {
60746: #ifdef DEBUG_NOTIFICATIONS
60746:       printf("\nsync notification processing\n");
60746: #endif
60746:       (aInstance->*aMethod)(aArg);
60746:       return;
60746:     }
60746: 
60746:     nsRefPtr<Notification> notification =
60746:       new TNotification<Class, Arg>(aInstance, aMethod, aArg);
60746:     if (notification && mNotifications.AppendElement(notification))
60746:       ScheduleProcessing();
60746:   }
60746: 
60746: protected:
60746:   nsAutoRefCnt mRefCnt;
60746:   NS_DECL_OWNINGTHREAD
60746: 
60746:   /**
60746:    * Start to observe refresh to make notifications and events processing after
60746:    * layout.
60746:    */
60746:   void ScheduleProcessing();
60746: 
60746:   /**
60746:    * Return true if the accessible tree state update is pending.
60746:    */
60746:   bool IsUpdatePending();
60746: 
60746: private:
60746:   NotificationController(const NotificationController&);
60746:   NotificationController& operator = (const NotificationController&);
60746: 
60746:   // nsARefreshObserver
43800:   virtual void WillRefresh(mozilla::TimeStamp aTime);
37537: 
60746:   // Event queue processing
37537:   /**
43383:    * Coalesce redundant events from the queue.
37537:    */
37537:   void CoalesceEvents();
37537: 
37537:   /**
37537:    * Apply aEventRule to same type event that from sibling nodes of aDOMNode.
37537:    * @param aEventsToFire    array of pending events
37537:    * @param aStart           start index of pending events to be scanned
37537:    * @param aEnd             end index to be scanned (not included)
37537:    * @param aEventType       target event type
37537:    * @param aDOMNode         target are siblings of this node
37537:    * @param aEventRule       the event rule to be applied
37537:    *                         (should be eDoNotEmit or eAllowDupes)
37537:    */
37537:   void ApplyToSiblings(PRUint32 aStart, PRUint32 aEnd,
37539:                        PRUint32 aEventType, nsINode* aNode,
51377:                        AccEvent::EEventRule aEventRule);
37537: 
37537:   /**
37537:    * Do not emit one of two given reorder events fired for DOM nodes in the case
37537:    * when one DOM node is in parent chain of second one.
37537:    */
51377:   void CoalesceReorderEventsFromSameTree(AccEvent* aAccEvent,
51377:                                          AccEvent* aDescendantAccEvent);
37537: 
43383:   /**
47106:    * Coalesce text change events caused by sibling hide events.
47106:    */
47106:   void CoalesceTextChangeEventsFor(AccHideEvent* aTailEvent,
47106:                                    AccHideEvent* aThisEvent);
56292:   void CoalesceTextChangeEventsFor(AccShowEvent* aTailEvent,
56292:                                    AccShowEvent* aThisEvent);
47106: 
47106:   /**
56292:    * Create text change event caused by hide or show event. When a node is
56292:    * hidden/removed or shown/appended, the text in an ancestor hyper text will
56292:    * lose or get new characters.
47106:    */
56292:   void CreateTextChangeEventFor(AccMutationEvent* aEvent);
47106: 
60746: private:
47106:   /**
60746:    * Indicates whether we're waiting on an event queue processing from our
60746:    * notification controller to flush events.
43383:    */
60746:   enum eObservingState {
60746:     eNotObservingRefresh,
60746:     eRefreshObserving,
60746:     eRefreshProcessingForUpdate
60746:   };
60746:   eObservingState mObservingState;
43383: 
43383:   /**
43383:    * The document accessible reference owning this queue.
43383:    */
37537:   nsRefPtr<nsDocAccessible> mDocument;
43383: 
43383:   /**
60746:    * The presshell of the document accessible.
60746:    */
60746:   nsIPresShell* mPresShell;
60746: 
60746:   /**
61152:    * Indicate whether initial construction of the document's accessible tree
61152:    * performed or pending. When the document accessible is created then
61152:    * we construct its initial accessible tree.
61152:    */
61152:   enum eTreeConstructedState {
61152:     eTreeConstructed,
61152:     eTreeConstructionPending
61152:   };
61152:   eTreeConstructedState mTreeConstructedState;
61152: 
61152:   /**
61317:    * Child documents that needs to be bound to the tree.
61317:    */
61317:   nsTArray<nsRefPtr<nsDocAccessible> > mHangingChildDocuments;
61317: 
61317:   /**
60746:    * Storage for content inserted notification information.
60746:    */
60746:   class ContentInsertion
60746:   {
60746:   public:
60746:     ContentInsertion(nsDocAccessible* aDocument, nsAccessible* aContainer,
60746:                      nsIContent* aStartChildNode, nsIContent* aEndChildNode);
60746:     virtual ~ContentInsertion() { mDocument = nsnull; }
60746: 
60746:     NS_INLINE_DECL_REFCOUNTING(ContentInsertion)
60746:     NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(ContentInsertion)
60746: 
60746:     void Process();
60746: 
60746:   private:
60746:     ContentInsertion();
60746:     ContentInsertion(const ContentInsertion&);
60746:     ContentInsertion& operator = (const ContentInsertion&);
60746: 
60746:     // The document used to process content insertion, matched to document of
60746:     // the notification controller that this notification belongs to, therefore
60746:     // it's ok to keep it as weak ref.
60746:     nsDocAccessible* mDocument;
60746: 
60746:     // The container accessible that content insertion occurs within.
60746:     nsRefPtr<nsAccessible> mContainer;
60746: 
60746:     // Array of inserted contents.
60746:     nsTArray<nsCOMPtr<nsIContent> > mInsertedContent;
60746:   };
60746: 
60746:   /**
60746:    * A pending accessible tree update notifications for content insertions.
60746:    * Don't make this an nsAutoTArray; we use SwapElements() on it.
60746:    */
60746:   nsTArray<nsRefPtr<ContentInsertion> > mContentInsertions;
60746: 
60746:   /**
61516:    * A pending accessible tree update notifications for rendered text changes.
61516:    */
61516:   nsTHashtable<nsPtrHashKey<nsIContent> > mTextHash;
61516: 
61516:   /**
61516:    * Update the accessible tree for pending rendered text change notifications.
61516:    */
61516:   static PLDHashOperator TextEnumerator(nsPtrHashKey<nsIContent>* aEntry,
61516:                                         void* aUserArg);
61516: 
61516:   /**
60746:    * Other notifications like DOM events. Don't make this an nsAutoTArray; we
60746:    * use SwapElements() on it.
60746:    */
60746:   nsTArray<nsRefPtr<Notification> > mNotifications;
60746: 
60746:   /**
43800:    * Pending events array. Don't make this an nsAutoTArray; we use
43800:    * SwapElements() on it.
43383:    */
51377:   nsTArray<nsRefPtr<AccEvent> > mEvents;
37537: };
37537: 
37281: #endif
